{"version":3,"file":"bundle.753.js","mappings":"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","sources":["webpack://ace-linters-root/./packages/ace-linters/services/base-service.ts","webpack://ace-linters-root/./packages/ace-linters/services/xml/xml-converters.ts","webpack://ace-linters-root/./packages/ace-linters/services/xml/xml-service.ts"],"sourcesContent":["import * as lsp from \"vscode-languageserver-protocol\";\nimport {AceLinters} from \"../types\";\nimport {mergeObjects} from \"../utils\";\nimport {TextDocument} from \"vscode-languageserver-textdocument\";\n\nexport abstract class BaseService<OptionsType extends AceLinters.ServiceOptions = AceLinters.ServiceOptions> implements AceLinters.LanguageService {\n    abstract $service;\n    mode: string;\n    documents: { [sessionID: string]: TextDocument } = {};\n    options: { [sessionID: string]: OptionsType } = {};\n    globalOptions: OptionsType = {} as OptionsType;\n\n    protected constructor(mode: string) {\n        this.mode = mode;\n    }\n\n    addDocument(document: lsp.TextDocumentItem) {\n        this.documents[document.uri] = TextDocument.create(document.uri, document.languageId, document.version,\n            (document as lsp.TextDocumentItem).text)\n        //TODO:\n        /*if (options)\n            this.setOptions(sessionID, options);*/\n    }\n\n    getDocument(uri: string): TextDocument {\n        return this.documents[uri];\n    }\n\n    removeDocument(document: lsp.TextDocumentIdentifier) {\n        delete this.documents[document.uri];\n        if (this.options[document.uri]) {\n            delete this.options[document.uri];\n        }\n    }\n\n    getDocumentValue(uri: string): string {\n        return this.getDocument(uri).getText();\n    }\n\n    setValue(identifier: lsp.VersionedTextDocumentIdentifier, value: string) {\n        let document = this.getDocument(identifier.uri);\n        if (document) {\n            document = TextDocument.create(document.uri, document.languageId, document.version, value);\n            this.documents[document.uri] = document;\n        }\n    }\n\n    setGlobalOptions(options: OptionsType) {\n        this.globalOptions = options ?? {} as OptionsType;\n    }\n\n    setOptions(sessionID: string, options: OptionsType, merge = false) {\n        this.options[sessionID] = merge ? mergeObjects(options, this.options[sessionID]) : options;\n    }\n\n    getOption<T extends keyof OptionsType>(sessionID: string, optionName: T): OptionsType[T] {\n        if (this.options[sessionID] && this.options[sessionID][optionName]) {\n            return this.options[sessionID][optionName];\n        } else {\n            return this.globalOptions[optionName];\n        }\n    }\n\n    applyDeltas(identifier: lsp.VersionedTextDocumentIdentifier, deltas: lsp.TextDocumentContentChangeEvent[]) {\n        let document = this.getDocument(identifier.uri);\n        if (document)\n            TextDocument.update(document, deltas, identifier.version);\n    }\n\n    async doComplete(document, position: lsp.Position): Promise<lsp.CompletionItem[] | lsp.CompletionList | null> {\n        return null;\n    }\n\n    async doHover(document, position: lsp.Position): Promise<lsp.Hover | null> {\n        return null;\n    }\n\n    async doResolve(item: lsp.CompletionItem): Promise<lsp.CompletionItem | null> {\n        return null;\n    }\n\n    async doValidation(document): Promise<lsp.Diagnostic[]> {\n        return [];\n    }\n\n    format(document, range: lsp.Range, options: lsp.FormattingOptions): lsp.TextEdit[] {\n        return [];\n    }\n\n}\n","import {Diagnostic, DiagnosticSeverity, Range} from \"vscode-languageserver-protocol\";\nimport {TextDocument} from \"vscode-languageserver-textdocument\";\n\nexport function lexingErrorToDiagnostic(document: TextDocument, error): Diagnostic {\n    return {\n        message: error.message,\n        range: Range.create(\n            document.positionAt(error.offset),\n            document.positionAt(error.offset + error.length)\n        ),\n        severity: DiagnosticSeverity.Error,\n    };\n}\n\nexport function parsingErrorToDiagnostic(document: TextDocument, error): Diagnostic {\n    return {\n        message: error.message,\n        range: {\n            start: document.positionAt(error.token.startOffset),\n            end: document.positionAt(\n                error.token.endOffset ? error.token.endOffset : 0\n            ),\n        },\n        severity: DiagnosticSeverity.Error,\n    };\n}\n\nexport function issueToDiagnostic(document: TextDocument, issue): Diagnostic {\n    return {\n        message: issue.msg,\n        range: {\n            start: document.positionAt(issue.position.startOffset),\n            // Chevrotain Token positions are non-inclusive for endOffsets\n            end: document.positionAt(issue.position.endOffset + 1),\n        },\n        severity: toDiagnosticSeverity(issue.severity),\n    };\n}\n\nfunction toDiagnosticSeverity(issueSeverity: string): DiagnosticSeverity {\n    switch (issueSeverity) {\n        case \"error\":\n            return DiagnosticSeverity.Error;\n        case \"warning\":\n            return DiagnosticSeverity.Warning;\n        case \"info\":\n        default:\n            return DiagnosticSeverity.Information;\n    }\n}\n","import {BaseService} from \"../base-service\";\nimport {AceLinters} from \"../../types\";\nimport * as lsp from \"vscode-languageserver-protocol\";\nimport {DocumentCstNode, parse} from \"@xml-tools/parser\";\nimport {buildAst} from \"@xml-tools/ast\";\nimport {checkConstraints} from \"@xml-tools/constraints\";\nimport {getSchemaValidators} from \"@xml-tools/simple-schema\";\nimport {validate, ValidationIssue} from \"@xml-tools/validation\";\n\nimport {\n    issueToDiagnostic,\n    lexingErrorToDiagnostic,\n    parsingErrorToDiagnostic\n} from \"./xml-converters\";\nimport {TextDocumentItem} from \"vscode-languageserver-protocol\";\nimport XmlServiceOptions = AceLinters.XmlServiceOptions;\n\n\nexport class XmlService extends BaseService<XmlServiceOptions> implements AceLinters.LanguageService {\n    $service;\n    schemas: { [schemaUri: string]: string } = {};\n\n    constructor(mode: string) {\n        super(mode);\n    }\n\n    addDocument(document: TextDocumentItem) {\n        super.addDocument(document);\n        this.$configureService(document.uri);\n    }\n\n    private $getXmlSchemaUri(sessionID): string | undefined {\n        return this.getOption(sessionID, \"schemaUri\");\n    }\n\n    private $configureService(sessionID: string) {\n        let schemas = this.getOption(sessionID, \"schemas\");\n        schemas?.forEach((el) => {\n            if (el.uri === this.$getXmlSchemaUri(sessionID)) {\n                el.fileMatch ??= [];\n                el.fileMatch.push(sessionID);\n            }\n            let schema = el.schema ?? this.schemas[el.uri];\n            if (schema)\n                this.schemas[el.uri] = schema;\n            el.schema = undefined;\n        });\n    }\n\n    $getSchema(sessionId) {\n        let schemaId = this.$getXmlSchemaUri(sessionId);\n        if (schemaId && this.schemas[schemaId]) {\n            return JSON.parse(this.schemas[schemaId])\n        }\n    }\n\n    async doValidation(document: lsp.TextDocumentIdentifier): Promise<lsp.Diagnostic[]> {\n        let fullDocument = this.getDocument(document.uri);\n        if (!fullDocument)\n            return [];\n\n        const {cst, tokenVector, lexErrors, parseErrors} = parse(\n            fullDocument.getText()\n        );\n        const xmlDoc = buildAst(cst as DocumentCstNode, tokenVector);\n        const constraintsIssues = checkConstraints(xmlDoc as any);\n\n        let schema = this.$getSchema(document.uri);\n        let schemaIssues: ValidationIssue[] = [];\n        if (schema) {\n            const schemaValidators = getSchemaValidators(schema);\n            schemaIssues = validate({\n                doc: xmlDoc,\n                validators: {\n                    attribute: [schemaValidators.attribute],\n                    element: [schemaValidators.element],\n                },\n            });\n        }\n\n        return [\n            ...lexErrors.map((_) => lexingErrorToDiagnostic(fullDocument, _)),\n            ...parseErrors.map((_) => parsingErrorToDiagnostic(fullDocument, _)),\n            ...constraintsIssues.map((_) => issueToDiagnostic(fullDocument, _)),\n            ...schemaIssues.map((_) => issueToDiagnostic(fullDocument, _))\n        ];\n    }\n}\n"],"names":[],"sourceRoot":""}