(self["webpackChunkace_linters_root"] = self["webpackChunkace_linters_root"] || []).push([[8765],{

/***/ 68765:
/***/ (function(module) {

(function webpackUniversalModuleDefinition(root, factory) {
    if (true) module.exports = factory();
    else { var i, a; }
})(this, ()=>{
    return /******/ (()=>{
        /******/ var __webpack_modules__ = {
            /***/ 1696: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_511__)=>{
                "use strict";
                /* provided dependency */ var process = __nested_webpack_require_511__(4406);
                /* provided dependency */ var console = __nested_webpack_require_511__(3716);
                // Currently in sync with Node.js lib/assert.js
                // https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b
                // Originally from narwhal.js (http://narwhaljs.org)
                // Copyright (c) 2009 Thomas Robinson <280north.com>
                //
                // Permission is hereby granted, free of charge, to any person obtaining a copy
                // of this software and associated documentation files (the 'Software'), to
                // deal in the Software without restriction, including without limitation the
                // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
                // sell copies of the Software, and to permit persons to whom the Software is
                // furnished to do so, subject to the following conditions:
                //
                // The above copyright notice and this permission notice shall be included in
                // all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                // AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
                // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                var _require = __nested_webpack_require_511__(7515), _require$codes = _require.codes, ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE, ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
                var AssertionError = __nested_webpack_require_511__(4082);
                var _require2 = __nested_webpack_require_511__(3335), inspect = _require2.inspect;
                var _require$types = __nested_webpack_require_511__(3335).types, isPromise = _require$types.isPromise, isRegExp = _require$types.isRegExp;
                var objectAssign = Object.assign ? Object.assign : __nested_webpack_require_511__(4956).assign;
                var objectIs = Object.is ? Object.is : __nested_webpack_require_511__(4679);
                var errorCache = new Map();
                var isDeepEqual;
                var isDeepStrictEqual;
                var parseExpressionAt;
                var findNodeAround;
                var decoder;
                function lazyLoadComparison() {
                    var comparison = __nested_webpack_require_511__(6796);
                    isDeepEqual = comparison.isDeepEqual;
                    isDeepStrictEqual = comparison.isDeepStrictEqual;
                } // Escape control characters but not \n and \t to keep the line breaks and
                // indentation intact.
                // eslint-disable-next-line no-control-regex
                var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
                var meta = /* unused pure expression or super */ null && 0;
                var escapeFn = function escapeFn(str) {
                    return meta[str.charCodeAt(0)];
                };
                var warned = false; // The assert module provides functions that throw
                // AssertionError's when particular conditions are not met. The
                // assert module must conform to the following interface.
                var assert = module1.exports = ok;
                var NO_EXCEPTION_SENTINEL = {}; // All of the following functions must throw an AssertionError
                // when a corresponding condition is not met, with a message that
                // may be undefined if not provided. All assertion methods provide
                // both the actual and expected values to the assertion error for
                // display purposes.
                function innerFail(obj) {
                    if (obj.message instanceof Error) throw obj.message;
                    throw new AssertionError(obj);
                }
                function fail(actual, expected, message, operator, stackStartFn) {
                    var argsLen = arguments.length;
                    var internalMessage;
                    if (argsLen === 0) {
                        internalMessage = 'Failed';
                    } else if (argsLen === 1) {
                        message = actual;
                        actual = undefined;
                    } else {
                        if (warned === false) {
                            warned = true;
                            var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
                            warn('assert.fail() with more than one argument is deprecated. ' + 'Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094');
                        }
                        if (argsLen === 2) operator = '!=';
                    }
                    if (message instanceof Error) throw message;
                    var errArgs = {
                        actual: actual,
                        expected: expected,
                        operator: operator === undefined ? 'fail' : operator,
                        stackStartFn: stackStartFn || fail
                    };
                    if (message !== undefined) {
                        errArgs.message = message;
                    }
                    var err = new AssertionError(errArgs);
                    if (internalMessage) {
                        err.message = internalMessage;
                        err.generatedMessage = true;
                    }
                    throw err;
                }
                assert.fail = fail; // The AssertionError is defined in internal/error.
                assert.AssertionError = AssertionError;
                function innerOk(fn, argLen, value, message) {
                    if (!value) {
                        var generatedMessage = false;
                        if (argLen === 0) {
                            generatedMessage = true;
                            message = 'No value argument passed to `assert.ok()`';
                        } else if (message instanceof Error) {
                            throw message;
                        }
                        var err = new AssertionError({
                            actual: value,
                            expected: true,
                            message: message,
                            operator: '==',
                            stackStartFn: fn
                        });
                        err.generatedMessage = generatedMessage;
                        throw err;
                    }
                } // Pure assertion tests whether a value is truthy, as determined
                // by !!value.
                function ok() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    innerOk.apply(void 0, [
                        ok,
                        args.length
                    ].concat(args));
                }
                assert.ok = ok; // The equality assertion tests shallow, coercive equality with ==.
                /* eslint-disable no-restricted-properties */ assert.equal = function equal(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    } // eslint-disable-next-line eqeqeq
                    if (actual != expected) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: '==',
                            stackStartFn: equal
                        });
                    }
                }; // The non-equality assertion tests for whether two objects are not
                // equal with !=.
                assert.notEqual = function notEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    } // eslint-disable-next-line eqeqeq
                    if (actual == expected) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: '!=',
                            stackStartFn: notEqual
                        });
                    }
                }; // The equivalence assertion tests a deep equality relation.
                assert.deepEqual = function deepEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (!isDeepEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'deepEqual',
                            stackStartFn: deepEqual
                        });
                    }
                }; // The non-equivalence assertion tests for any deep inequality.
                assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (isDeepEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'notDeepEqual',
                            stackStartFn: notDeepEqual
                        });
                    }
                };
                /* eslint-enable */ assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (!isDeepStrictEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'deepStrictEqual',
                            stackStartFn: deepStrictEqual
                        });
                    }
                };
                assert.notDeepStrictEqual = notDeepStrictEqual;
                function notDeepStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (isDeepStrictEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'notDeepStrictEqual',
                            stackStartFn: notDeepStrictEqual
                        });
                    }
                }
                assert.strictEqual = function strictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (!objectIs(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'strictEqual',
                            stackStartFn: strictEqual
                        });
                    }
                };
                assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (objectIs(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'notStrictEqual',
                            stackStartFn: notStrictEqual
                        });
                    }
                };
                var Comparison = function Comparison(obj, keys, actual) {
                    var _this = this;
                    _classCallCheck(this, Comparison);
                    keys.forEach(function(key) {
                        if (key in obj) {
                            if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && obj[key].test(actual[key])) {
                                _this[key] = actual[key];
                            } else {
                                _this[key] = obj[key];
                            }
                        }
                    });
                };
                function compareExceptionKey(actual, expected, key, message, keys, fn) {
                    if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
                        if (!message) {
                            // Create placeholder objects to create a nice output.
                            var a = new Comparison(actual, keys);
                            var b = new Comparison(expected, keys, actual);
                            var err = new AssertionError({
                                actual: a,
                                expected: b,
                                operator: 'deepStrictEqual',
                                stackStartFn: fn
                            });
                            err.actual = actual;
                            err.expected = expected;
                            err.operator = fn.name;
                            throw err;
                        }
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: fn.name,
                            stackStartFn: fn
                        });
                    }
                }
                function expectedException(actual, expected, msg, fn) {
                    if (typeof expected !== 'function') {
                        if (isRegExp(expected)) return expected.test(actual); // assert.doesNotThrow does not accept objects.
                        if (arguments.length === 2) {
                            throw new ERR_INVALID_ARG_TYPE('expected', [
                                'Function',
                                'RegExp'
                            ], expected);
                        } // Handle primitives properly.
                        if (_typeof(actual) !== 'object' || actual === null) {
                            var err = new AssertionError({
                                actual: actual,
                                expected: expected,
                                message: msg,
                                operator: 'deepStrictEqual',
                                stackStartFn: fn
                            });
                            err.operator = fn.name;
                            throw err;
                        }
                        var keys = Object.keys(expected); // Special handle errors to make sure the name and the message are compared
                        // as well.
                        if (expected instanceof Error) {
                            keys.push('name', 'message');
                        } else if (keys.length === 0) {
                            throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');
                        }
                        if (isDeepEqual === undefined) lazyLoadComparison();
                        keys.forEach(function(key) {
                            if (typeof actual[key] === 'string' && isRegExp(expected[key]) && expected[key].test(actual[key])) {
                                return;
                            }
                            compareExceptionKey(actual, expected, key, msg, keys, fn);
                        });
                        return true;
                    } // Guard instanceof against arrow functions as they don't have a prototype.
                    if (expected.prototype !== undefined && actual instanceof expected) {
                        return true;
                    }
                    if (Error.isPrototypeOf(expected)) {
                        return false;
                    }
                    return expected.call({}, actual) === true;
                }
                function getActual(fn) {
                    if (typeof fn !== 'function') {
                        throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);
                    }
                    try {
                        fn();
                    } catch (e) {
                        return e;
                    }
                    return NO_EXCEPTION_SENTINEL;
                }
                function checkIsPromise(obj) {
                    // Accept native ES6 promises and promises that are implemented in a similar
                    // way. Do not accept thenables that use a function as `obj` and that have no
                    // `catch` handler.
                    // TODO: thenables are checked up until they have the correct methods,
                    // but according to documentation, the `then` method should receive
                    // the `fulfill` and `reject` arguments as well or it may be never resolved.
                    return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';
                }
                function waitForActual(promiseFn) {
                    return Promise.resolve().then(function() {
                        var resultPromise;
                        if (typeof promiseFn === 'function') {
                            // Return a rejected promise if `promiseFn` throws synchronously.
                            resultPromise = promiseFn(); // Fail in case no promise is returned.
                            if (!checkIsPromise(resultPromise)) {
                                throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);
                            }
                        } else if (checkIsPromise(promiseFn)) {
                            resultPromise = promiseFn;
                        } else {
                            throw new ERR_INVALID_ARG_TYPE('promiseFn', [
                                'Function',
                                'Promise'
                            ], promiseFn);
                        }
                        return Promise.resolve().then(function() {
                            return resultPromise;
                        }).then(function() {
                            return NO_EXCEPTION_SENTINEL;
                        }).catch(function(e) {
                            return e;
                        });
                    });
                }
                function expectsError(stackStartFn, actual, error, message) {
                    if (typeof error === 'string') {
                        if (arguments.length === 4) {
                            throw new ERR_INVALID_ARG_TYPE('error', [
                                'Object',
                                'Error',
                                'Function',
                                'RegExp'
                            ], error);
                        }
                        if (_typeof(actual) === 'object' && actual !== null) {
                            if (actual.message === error) {
                                throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error message \"".concat(actual.message, "\" is identical to the message."));
                            }
                        } else if (actual === error) {
                            throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error \"".concat(actual, "\" is identical to the message."));
                        }
                        message = error;
                        error = undefined;
                    } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') {
                        throw new ERR_INVALID_ARG_TYPE('error', [
                            'Object',
                            'Error',
                            'Function',
                            'RegExp'
                        ], error);
                    }
                    if (actual === NO_EXCEPTION_SENTINEL) {
                        var details = '';
                        if (error && error.name) {
                            details += " (".concat(error.name, ")");
                        }
                        details += message ? ": ".concat(message) : '.';
                        var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';
                        innerFail({
                            actual: undefined,
                            expected: error,
                            operator: stackStartFn.name,
                            message: "Missing expected ".concat(fnType).concat(details),
                            stackStartFn: stackStartFn
                        });
                    }
                    if (error && !expectedException(actual, error, message, stackStartFn)) {
                        throw actual;
                    }
                }
                function expectsNoError(stackStartFn, actual, error, message) {
                    if (actual === NO_EXCEPTION_SENTINEL) return;
                    if (typeof error === 'string') {
                        message = error;
                        error = undefined;
                    }
                    if (!error || expectedException(actual, error)) {
                        var details = message ? ": ".concat(message) : '.';
                        var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';
                        innerFail({
                            actual: actual,
                            expected: error,
                            operator: stackStartFn.name,
                            message: "Got unwanted ".concat(fnType).concat(details, "\n") + "Actual message: \"".concat(actual && actual.message, "\""),
                            stackStartFn: stackStartFn
                        });
                    }
                    throw actual;
                }
                assert.throws = function throws(promiseFn) {
                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                        args[_key2 - 1] = arguments[_key2];
                    }
                    expectsError.apply(void 0, [
                        throws,
                        getActual(promiseFn)
                    ].concat(args));
                };
                assert.rejects = function rejects(promiseFn) {
                    for(var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++){
                        args[_key3 - 1] = arguments[_key3];
                    }
                    return waitForActual(promiseFn).then(function(result) {
                        return expectsError.apply(void 0, [
                            rejects,
                            result
                        ].concat(args));
                    });
                };
                assert.doesNotThrow = function doesNotThrow(fn) {
                    for(var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++){
                        args[_key4 - 1] = arguments[_key4];
                    }
                    expectsNoError.apply(void 0, [
                        doesNotThrow,
                        getActual(fn)
                    ].concat(args));
                };
                assert.doesNotReject = function doesNotReject(fn) {
                    for(var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++){
                        args[_key5 - 1] = arguments[_key5];
                    }
                    return waitForActual(fn).then(function(result) {
                        return expectsNoError.apply(void 0, [
                            doesNotReject,
                            result
                        ].concat(args));
                    });
                };
                assert.ifError = function ifError(err) {
                    if (err !== null && err !== undefined) {
                        var message = 'ifError got unwanted exception: ';
                        if (_typeof(err) === 'object' && typeof err.message === 'string') {
                            if (err.message.length === 0 && err.constructor) {
                                message += err.constructor.name;
                            } else {
                                message += err.message;
                            }
                        } else {
                            message += inspect(err);
                        }
                        var newErr = new AssertionError({
                            actual: err,
                            expected: null,
                            operator: 'ifError',
                            message: message,
                            stackStartFn: ifError
                        }); // Make sure we actually have a stack trace!
                        var origStack = err.stack;
                        if (typeof origStack === 'string') {
                            // This will remove any duplicated frames from the error frames taken
                            // from within `ifError` and add the original error frames to the newly
                            // created ones.
                            var tmp2 = origStack.split('\n');
                            tmp2.shift(); // Filter all frames existing in err.stack.
                            var tmp1 = newErr.stack.split('\n');
                            for(var i = 0; i < tmp2.length; i++){
                                // Find the first occurrence of the frame.
                                var pos = tmp1.indexOf(tmp2[i]);
                                if (pos !== -1) {
                                    // Only keep new frames.
                                    tmp1 = tmp1.slice(0, pos);
                                    break;
                                }
                            }
                            newErr.stack = "".concat(tmp1.join('\n'), "\n").concat(tmp2.join('\n'));
                        }
                        throw newErr;
                    }
                }; // Expose a strict only variant of assert
                function strict() {
                    for(var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++){
                        args[_key6] = arguments[_key6];
                    }
                    innerOk.apply(void 0, [
                        strict,
                        args.length
                    ].concat(args));
                }
                assert.strict = objectAssign(strict, assert, {
                    equal: assert.strictEqual,
                    deepEqual: assert.deepStrictEqual,
                    notEqual: assert.notStrictEqual,
                    notDeepEqual: assert.notDeepStrictEqual
                });
                assert.strict.strict = assert.strict;
            /***/ },
            /***/ 4082: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_31729__)=>{
                "use strict";
                /* provided dependency */ var process = __nested_webpack_require_31729__(4406);
                // Currently in sync with Node.js lib/internal/assert/assertion_error.js
                // https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c
                function _objectSpread(target) {
                    for(var i = 1; i < arguments.length; i++){
                        var source = arguments[i] != null ? arguments[i] : {};
                        var ownKeys = Object.keys(source);
                        if (typeof Object.getOwnPropertySymbols === 'function') {
                            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                            }));
                        }
                        ownKeys.forEach(function(key) {
                            _defineProperty(target, key, source[key]);
                        });
                    }
                    return target;
                }
                function _defineProperty(obj, key, value) {
                    if (key in obj) {
                        Object.defineProperty(obj, key, {
                            value: value,
                            enumerable: true,
                            configurable: true,
                            writable: true
                        });
                    } else {
                        obj[key] = value;
                    }
                    return obj;
                }
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                function _defineProperties(target, props) {
                    for(var i = 0; i < props.length; i++){
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    return Constructor;
                }
                function _possibleConstructorReturn(self, call) {
                    if (call && (_typeof(call) === "object" || typeof call === "function")) {
                        return call;
                    }
                    return _assertThisInitialized(self);
                }
                function _assertThisInitialized(self) {
                    if (self === void 0) {
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    }
                    return self;
                }
                function _inherits(subClass, superClass) {
                    if (typeof superClass !== "function" && superClass !== null) {
                        throw new TypeError("Super expression must either be null or a function");
                    }
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            writable: true,
                            configurable: true
                        }
                    });
                    if (superClass) _setPrototypeOf(subClass, superClass);
                }
                function _wrapNativeSuper(Class) {
                    var _cache = typeof Map === "function" ? new Map() : undefined;
                    _wrapNativeSuper = function _wrapNativeSuper(Class) {
                        if (Class === null || !_isNativeFunction(Class)) return Class;
                        if (typeof Class !== "function") {
                            throw new TypeError("Super expression must either be null or a function");
                        }
                        if (typeof _cache !== "undefined") {
                            if (_cache.has(Class)) return _cache.get(Class);
                            _cache.set(Class, Wrapper);
                        }
                        function Wrapper() {
                            return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                        }
                        Wrapper.prototype = Object.create(Class.prototype, {
                            constructor: {
                                value: Wrapper,
                                enumerable: false,
                                writable: true,
                                configurable: true
                            }
                        });
                        return _setPrototypeOf(Wrapper, Class);
                    };
                    return _wrapNativeSuper(Class);
                }
                function isNativeReflectConstruct() {
                    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if (typeof Proxy === "function") return true;
                    try {
                        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
                        return true;
                    } catch (e) {
                        return false;
                    }
                }
                function _construct(Parent, args, Class) {
                    if (isNativeReflectConstruct()) {
                        _construct = Reflect.construct;
                    } else {
                        _construct = function _construct(Parent, args, Class) {
                            var a = [
                                null
                            ];
                            a.push.apply(a, args);
                            var Constructor = Function.bind.apply(Parent, a);
                            var instance = new Constructor();
                            if (Class) _setPrototypeOf(instance, Class.prototype);
                            return instance;
                        };
                    }
                    return _construct.apply(null, arguments);
                }
                function _isNativeFunction(fn) {
                    return Function.toString.call(fn).indexOf("[native code]") !== -1;
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                        o.__proto__ = p;
                        return o;
                    };
                    return _setPrototypeOf(o, p);
                }
                function _getPrototypeOf(o) {
                    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                        return o.__proto__ || Object.getPrototypeOf(o);
                    };
                    return _getPrototypeOf(o);
                }
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                var _require = __nested_webpack_require_31729__(3335), inspect = _require.inspect;
                var _require2 = __nested_webpack_require_31729__(7515), ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
                function endsWith(str, search, this_len) {
                    if (this_len === undefined || this_len > str.length) {
                        this_len = str.length;
                    }
                    return str.substring(this_len - search.length, this_len) === search;
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
                function repeat(str, count) {
                    count = Math.floor(count);
                    if (str.length == 0 || count == 0) return '';
                    var maxCount = str.length * count;
                    count = Math.floor(Math.log(count) / Math.log(2));
                    while(count){
                        str += str;
                        count--;
                    }
                    str += str.substring(0, maxCount - str.length);
                    return str;
                }
                var blue = '';
                var green = '';
                var red = '';
                var white = '';
                var kReadableOperator = {
                    deepStrictEqual: 'Expected values to be strictly deep-equal:',
                    strictEqual: 'Expected values to be strictly equal:',
                    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
                    deepEqual: 'Expected values to be loosely deep-equal:',
                    equal: 'Expected values to be loosely equal:',
                    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
                    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
                    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
                    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
                    notEqual: 'Expected "actual" to be loosely unequal to:',
                    notIdentical: 'Values identical but not reference-equal:'
                }; // Comparing short primitives should just show === / !== instead of using the
                // diff.
                var kMaxShortLength = 10;
                function copyError(source) {
                    var keys = Object.keys(source);
                    var target = Object.create(Object.getPrototypeOf(source));
                    keys.forEach(function(key) {
                        target[key] = source[key];
                    });
                    Object.defineProperty(target, 'message', {
                        value: source.message
                    });
                    return target;
                }
                function inspectValue(val) {
                    // The util.inspect default values could be changed. This makes sure the
                    // error messages contain the necessary information nevertheless.
                    return inspect(val, {
                        compact: false,
                        customInspect: false,
                        depth: 1000,
                        maxArrayLength: Infinity,
                        // Assert compares only enumerable properties (with a few exceptions).
                        showHidden: false,
                        // Having a long line as error is better than wrapping the line for
                        // comparison for now.
                        // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
                        // have meta information about the inspected properties (i.e., know where
                        // in what line the property starts and ends).
                        breakLength: Infinity,
                        // Assert does not detect proxies currently.
                        showProxy: false,
                        sorted: true,
                        // Inspect getters as we also check them when comparing entries.
                        getters: true
                    });
                }
                function createErrDiff(actual, expected, operator) {
                    var other = '';
                    var res = '';
                    var lastPos = 0;
                    var end = '';
                    var skipped = false;
                    var actualInspected = inspectValue(actual);
                    var actualLines = actualInspected.split('\n');
                    var expectedLines = inspectValue(expected).split('\n');
                    var i = 0;
                    var indicator = ''; // In case both values are objects explicitly mark them as not reference equal
                    // for the `strictEqual` operator.
                    if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) {
                        operator = 'strictEqualObject';
                    } // If "actual" and "expected" fit on a single line and they are not strictly
                    // equal, check further special handling.
                    if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
                        var inputLength = actualLines[0].length + expectedLines[0].length; // If the character length of "actual" and "expected" together is less than
                        // kMaxShortLength and if neither is an object and at least one of them is
                        // not `zero`, use the strict equal comparison to visualize the output.
                        if (inputLength <= kMaxShortLength) {
                            if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) {
                                // -0 === +0
                                return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
                            }
                        } else if (operator !== 'strictEqualObject') {
                            // If the stderr is a tty and the input length is lower than the current
                            // columns per line, add a mismatch indicator below the output. If it is
                            // not a tty, use a default value of 80 characters.
                            var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
                            if (inputLength < maxLength) {
                                while(actualLines[0][i] === expectedLines[0][i]){
                                    i++;
                                } // Ignore the first characters.
                                if (i > 2) {
                                    // Add position indicator for the first mismatch in case it is a
                                    // single line and the input length is less than the column length.
                                    indicator = "\n  ".concat(repeat(' ', i), "^");
                                    i = 0;
                                }
                            }
                        }
                    } // Remove all ending lines that match (this optimizes the output for
                    // readability by reducing the number of total changed lines).
                    var a = actualLines[actualLines.length - 1];
                    var b = expectedLines[expectedLines.length - 1];
                    while(a === b){
                        if (i++ < 2) {
                            end = "\n  ".concat(a).concat(end);
                        } else {
                            other = a;
                        }
                        actualLines.pop();
                        expectedLines.pop();
                        if (actualLines.length === 0 || expectedLines.length === 0) break;
                        a = actualLines[actualLines.length - 1];
                        b = expectedLines[expectedLines.length - 1];
                    }
                    var maxLines = Math.max(actualLines.length, expectedLines.length); // Strict equal with identical objects that are not identical by reference.
                    // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })
                    if (maxLines === 0) {
                        // We have to get the result again. The lines were all removed before.
                        var _actualLines = actualInspected.split('\n'); // Only remove lines in case it makes sense to collapse those.
                        // TODO: Accept env to always show the full error.
                        if (_actualLines.length > 30) {
                            _actualLines[26] = "".concat(blue, "...").concat(white);
                            while(_actualLines.length > 27){
                                _actualLines.pop();
                            }
                        }
                        return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join('\n'), "\n");
                    }
                    if (i > 3) {
                        end = "\n".concat(blue, "...").concat(white).concat(end);
                        skipped = true;
                    }
                    if (other !== '') {
                        end = "\n  ".concat(other).concat(end);
                        other = '';
                    }
                    var printedLines = 0;
                    var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
                    var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
                    for(i = 0; i < maxLines; i++){
                        // Only extra expected lines exist
                        var cur = i - lastPos;
                        if (actualLines.length < i + 1) {
                            // If the last diverging line is more than one line above and the
                            // current line is at least line three, add some of the former lines and
                            // also add dots to indicate skipped entries.
                            if (cur > 1 && i > 2) {
                                if (cur > 4) {
                                    res += "\n".concat(blue, "...").concat(white);
                                    skipped = true;
                                } else if (cur > 3) {
                                    res += "\n  ".concat(expectedLines[i - 2]);
                                    printedLines++;
                                }
                                res += "\n  ".concat(expectedLines[i - 1]);
                                printedLines++;
                            } // Mark the current line as the last diverging one.
                            lastPos = i; // Add the expected line to the cache.
                            other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
                            printedLines++; // Only extra actual lines exist
                        } else if (expectedLines.length < i + 1) {
                            // If the last diverging line is more than one line above and the
                            // current line is at least line three, add some of the former lines and
                            // also add dots to indicate skipped entries.
                            if (cur > 1 && i > 2) {
                                if (cur > 4) {
                                    res += "\n".concat(blue, "...").concat(white);
                                    skipped = true;
                                } else if (cur > 3) {
                                    res += "\n  ".concat(actualLines[i - 2]);
                                    printedLines++;
                                }
                                res += "\n  ".concat(actualLines[i - 1]);
                                printedLines++;
                            } // Mark the current line as the last diverging one.
                            lastPos = i; // Add the actual line to the result.
                            res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
                            printedLines++; // Lines diverge
                        } else {
                            var expectedLine = expectedLines[i];
                            var actualLine = actualLines[i]; // If the lines diverge, specifically check for lines that only diverge by
                            // a trailing comma. In that case it is actually identical and we should
                            // mark it as such.
                            var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine); // If the expected line has a trailing comma but is otherwise identical,
                            // add a comma at the end of the actual line. Otherwise the output could
                            // look weird as in:
                            //
                            //   [
                            //     1         // No comma at the end!
                            // +   2
                            //   ]
                            //
                            if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {
                                divergingLines = false;
                                actualLine += ',';
                            }
                            if (divergingLines) {
                                // If the last diverging line is more than one line above and the
                                // current line is at least line three, add some of the former lines and
                                // also add dots to indicate skipped entries.
                                if (cur > 1 && i > 2) {
                                    if (cur > 4) {
                                        res += "\n".concat(blue, "...").concat(white);
                                        skipped = true;
                                    } else if (cur > 3) {
                                        res += "\n  ".concat(actualLines[i - 2]);
                                        printedLines++;
                                    }
                                    res += "\n  ".concat(actualLines[i - 1]);
                                    printedLines++;
                                } // Mark the current line as the last diverging one.
                                lastPos = i; // Add the actual line to the result and cache the expected diverging
                                // line so consecutive diverging lines show up as +++--- and not +-+-+-.
                                res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
                                other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
                                printedLines += 2; // Lines are identical
                            } else {
                                // Add all cached information to the result before adding other things
                                // and reset the cache.
                                res += other;
                                other = ''; // If the last diverging line is exactly one line above or if it is the
                                // very first line, add the line to the result.
                                if (cur === 1 || i === 0) {
                                    res += "\n  ".concat(actualLine);
                                    printedLines++;
                                }
                            }
                        } // Inspected object to big (Show ~20 rows max)
                        if (printedLines > 20 && i < maxLines - 2) {
                            return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
                        }
                    }
                    return "".concat(msg).concat(skipped ? skippedMsg : '', "\n").concat(res).concat(other).concat(end).concat(indicator);
                }
                var AssertionError = /*#__PURE__*/ function(_Error) {
                    _inherits(AssertionError, _Error);
                    function AssertionError(options) {
                        var _this;
                        _classCallCheck(this, AssertionError);
                        if (_typeof(options) !== 'object' || options === null) {
                            throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
                        }
                        var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
                        var actual = options.actual, expected = options.expected;
                        var limit = Error.stackTraceLimit;
                        Error.stackTraceLimit = 0;
                        if (message != null) {
                            _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, String(message)));
                        } else {
                            if (process.stderr && process.stderr.isTTY) {
                                // Reset on each call to make sure we handle dynamically set environment
                                // variables correct.
                                if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
                                    blue = "\x1B[34m";
                                    green = "\x1B[32m";
                                    white = "\x1B[39m";
                                    red = "\x1B[31m";
                                } else {
                                    blue = '';
                                    green = '';
                                    white = '';
                                    red = '';
                                }
                            } // Prevent the error stack from being visible by duplicating the error
                            // in a very close way to the original in case both sides are actually
                            // instances of Error.
                            if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {
                                actual = copyError(actual);
                                expected = copyError(expected);
                            }
                            if (operator === 'deepStrictEqual' || operator === 'strictEqual') {
                                _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, createErrDiff(actual, expected, operator)));
                            } else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {
                                // In case the objects are equal but the operator requires unequal, show
                                // the first object and say A equals B
                                var base = kReadableOperator[operator];
                                var res = inspectValue(actual).split('\n'); // In case "actual" is an object, it should not be reference equal.
                                if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) {
                                    base = kReadableOperator.notStrictEqualObject;
                                } // Only remove lines in case it makes sense to collapse those.
                                // TODO: Accept env to always show the full error.
                                if (res.length > 30) {
                                    res[26] = "".concat(blue, "...").concat(white);
                                    while(res.length > 27){
                                        res.pop();
                                    }
                                } // Only print a single input.
                                if (res.length === 1) {
                                    _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, " ").concat(res[0])));
                                } else {
                                    _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, "\n\n").concat(res.join('\n'), "\n")));
                                }
                            } else {
                                var _res = inspectValue(actual);
                                var other = '';
                                var knownOperators = kReadableOperator[operator];
                                if (operator === 'notDeepEqual' || operator === 'notEqual') {
                                    _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
                                    if (_res.length > 1024) {
                                        _res = "".concat(_res.slice(0, 1021), "...");
                                    }
                                } else {
                                    other = "".concat(inspectValue(expected));
                                    if (_res.length > 512) {
                                        _res = "".concat(_res.slice(0, 509), "...");
                                    }
                                    if (other.length > 512) {
                                        other = "".concat(other.slice(0, 509), "...");
                                    }
                                    if (operator === 'deepEqual' || operator === 'equal') {
                                        _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
                                    } else {
                                        other = " ".concat(operator, " ").concat(other);
                                    }
                                }
                                _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(_res).concat(other)));
                            }
                        }
                        Error.stackTraceLimit = limit;
                        _this.generatedMessage = !message;
                        Object.defineProperty(_assertThisInitialized(_this), 'name', {
                            value: 'AssertionError [ERR_ASSERTION]',
                            enumerable: false,
                            writable: true,
                            configurable: true
                        });
                        _this.code = 'ERR_ASSERTION';
                        _this.actual = actual;
                        _this.expected = expected;
                        _this.operator = operator;
                        if (Error.captureStackTrace) {
                            // eslint-disable-next-line no-restricted-syntax
                            Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
                        } // Create error message including the error code in the name.
                        _this.stack; // Reset the name.
                        _this.name = 'AssertionError';
                        return _possibleConstructorReturn(_this);
                    }
                    _createClass(AssertionError, [
                        {
                            key: "toString",
                            value: function toString() {
                                return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
                            }
                        },
                        {
                            key: inspect.custom,
                            value: function value(recurseTimes, ctx) {
                                // This limits the `actual` and `expected` property default inspection to
                                // the minimum depth. Otherwise those values would be too verbose compared
                                // to the actual error message which contains a combined view of these two
                                // input values.
                                return inspect(this, _objectSpread({}, ctx, {
                                    customInspect: false,
                                    depth: 0
                                }));
                            }
                        }
                    ]);
                    return AssertionError;
                }(_wrapNativeSuper(Error));
                module1.exports = AssertionError;
            /***/ },
            /***/ 7515: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_65318__)=>{
                "use strict";
                // Currently in sync with Node.js lib/internal/errors.js
                // https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f
                /* eslint node-core/documented-errors: "error" */ /* eslint node-core/alphabetize-errors: "error" */ /* eslint node-core/prefer-util-format-errors: "error" */ // The whole point behind this internal module is to allow Node.js to no
                // longer be forced to treat every error message change as a semver-major
                // change. The NodeError classes here all expose a `code` property whose
                // value statically and permanently identifies the error. While the error
                // message may change, the code should not.
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                function _possibleConstructorReturn(self, call) {
                    if (call && (_typeof(call) === "object" || typeof call === "function")) {
                        return call;
                    }
                    return _assertThisInitialized(self);
                }
                function _assertThisInitialized(self) {
                    if (self === void 0) {
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    }
                    return self;
                }
                function _getPrototypeOf(o) {
                    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                        return o.__proto__ || Object.getPrototypeOf(o);
                    };
                    return _getPrototypeOf(o);
                }
                function _inherits(subClass, superClass) {
                    if (typeof superClass !== "function" && superClass !== null) {
                        throw new TypeError("Super expression must either be null or a function");
                    }
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            writable: true,
                            configurable: true
                        }
                    });
                    if (superClass) _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                        o.__proto__ = p;
                        return o;
                    };
                    return _setPrototypeOf(o, p);
                }
                var codes = {}; // Lazy loaded
                var assert;
                var util;
                function createErrorType(code, message, Base) {
                    if (!Base) {
                        Base = Error;
                    }
                    function getMessage(arg1, arg2, arg3) {
                        if (typeof message === 'string') {
                            return message;
                        } else {
                            return message(arg1, arg2, arg3);
                        }
                    }
                    var NodeError = /*#__PURE__*/ function(_Base) {
                        _inherits(NodeError, _Base);
                        function NodeError(arg1, arg2, arg3) {
                            var _this;
                            _classCallCheck(this, NodeError);
                            _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError).call(this, getMessage(arg1, arg2, arg3)));
                            _this.code = code;
                            return _this;
                        }
                        return NodeError;
                    }(Base);
                    codes[code] = NodeError;
                } // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
                function oneOf(expected, thing) {
                    if (Array.isArray(expected)) {
                        var len = expected.length;
                        expected = expected.map(function(i) {
                            return String(i);
                        });
                        if (len > 2) {
                            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
                        } else if (len === 2) {
                            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
                        } else {
                            return "of ".concat(thing, " ").concat(expected[0]);
                        }
                    } else {
                        return "of ".concat(thing, " ").concat(String(expected));
                    }
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
                function startsWith(str, search, pos) {
                    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
                function endsWith(str, search, this_len) {
                    if (this_len === undefined || this_len > str.length) {
                        this_len = str.length;
                    }
                    return str.substring(this_len - search.length, this_len) === search;
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
                function includes(str, search, start) {
                    if (typeof start !== 'number') {
                        start = 0;
                    }
                    if (start + search.length > str.length) {
                        return false;
                    } else {
                        return str.indexOf(search, start) !== -1;
                    }
                }
                createErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The "%s" argument is ambiguous. %s', TypeError);
                createErrorType('ERR_INVALID_ARG_TYPE', function(name, expected, actual) {
                    if (assert === undefined) assert = __nested_webpack_require_65318__(1696);
                    assert(typeof name === 'string', "'name' must be a string"); // determiner: 'must be' or 'must not be'
                    var determiner;
                    if (typeof expected === 'string' && startsWith(expected, 'not ')) {
                        determiner = 'must not be';
                        expected = expected.replace(/^not /, '');
                    } else {
                        determiner = 'must be';
                    }
                    var msg;
                    if (endsWith(name, ' argument')) {
                        // For cases like 'first argument'
                        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
                    } else {
                        var type = includes(name, '.') ? 'property' : 'argument';
                        msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
                    } // TODO(BridgeAR): Improve the output by showing `null` and similar.
                    msg += ". Received type ".concat(_typeof(actual));
                    return msg;
                }, TypeError);
                createErrorType('ERR_INVALID_ARG_VALUE', function(name, value) {
                    var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';
                    if (util === undefined) util = __nested_webpack_require_65318__(3335);
                    var inspected = util.inspect(value);
                    if (inspected.length > 128) {
                        inspected = "".concat(inspected.slice(0, 128), "...");
                    }
                    return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
                }, TypeError, RangeError);
                createErrorType('ERR_INVALID_RETURN_VALUE', function(input, name, value) {
                    var type;
                    if (value && value.constructor && value.constructor.name) {
                        type = "instance of ".concat(value.constructor.name);
                    } else {
                        type = "type ".concat(_typeof(value));
                    }
                    return "Expected ".concat(input, " to be returned from the \"").concat(name, "\"") + " function but got ".concat(type, ".");
                }, TypeError);
                createErrorType('ERR_MISSING_ARGS', function() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    if (assert === undefined) assert = __nested_webpack_require_65318__(1696);
                    assert(args.length > 0, 'At least one arg needs to be specified');
                    var msg = 'The ';
                    var len = args.length;
                    args = args.map(function(a) {
                        return "\"".concat(a, "\"");
                    });
                    switch(len){
                        case 1:
                            msg += "".concat(args[0], " argument");
                            break;
                        case 2:
                            msg += "".concat(args[0], " and ").concat(args[1], " arguments");
                            break;
                        default:
                            msg += args.slice(0, len - 1).join(', ');
                            msg += ", and ".concat(args[len - 1], " arguments");
                            break;
                    }
                    return "".concat(msg, " must be specified");
                }, TypeError);
                module1.exports.codes = codes;
            /***/ },
            /***/ 6796: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_76379__)=>{
                "use strict";
                // Currently in sync with Node.js lib/internal/util/comparisons.js
                // https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
                function _slicedToArray(arr, i) {
                    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
                }
                function _nonIterableRest() {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
                function _iterableToArrayLimit(arr, i) {
                    var _arr = [];
                    var _n = true;
                    var _d = false;
                    var _e = undefined;
                    try {
                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){
                            _arr.push(_s.value);
                            if (i && _arr.length === i) break;
                        }
                    } catch (err) {
                        _d = true;
                        _e = err;
                    } finally{
                        try {
                            if (!_n && _i["return"] != null) _i["return"]();
                        } finally{
                            if (_d) throw _e;
                        }
                    }
                    return _arr;
                }
                function _arrayWithHoles(arr) {
                    if (Array.isArray(arr)) return arr;
                }
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                var regexFlagsSupported = /a/g.flags !== undefined;
                var arrayFromSet = function arrayFromSet(set) {
                    var array = [];
                    set.forEach(function(value) {
                        return array.push(value);
                    });
                    return array;
                };
                var arrayFromMap = function arrayFromMap(map) {
                    var array = [];
                    map.forEach(function(value, key) {
                        return array.push([
                            key,
                            value
                        ]);
                    });
                    return array;
                };
                var objectIs = Object.is ? Object.is : __nested_webpack_require_76379__(4679);
                var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
                    return [];
                };
                var numberIsNaN = Number.isNaN ? Number.isNaN : __nested_webpack_require_76379__(4782);
                function uncurryThis(f) {
                    return f.call.bind(f);
                }
                var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
                var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
                var objectToString = uncurryThis(Object.prototype.toString);
                var _require$types = __nested_webpack_require_76379__(3335).types, isAnyArrayBuffer = _require$types.isAnyArrayBuffer, isArrayBufferView = _require$types.isArrayBufferView, isDate = _require$types.isDate, isMap = _require$types.isMap, isRegExp = _require$types.isRegExp, isSet = _require$types.isSet, isNativeError = _require$types.isNativeError, isBoxedPrimitive = _require$types.isBoxedPrimitive, isNumberObject = _require$types.isNumberObject, isStringObject = _require$types.isStringObject, isBooleanObject = _require$types.isBooleanObject, isBigIntObject = _require$types.isBigIntObject, isSymbolObject = _require$types.isSymbolObject, isFloat32Array = _require$types.isFloat32Array, isFloat64Array = _require$types.isFloat64Array;
                function isNonIndex(key) {
                    if (key.length === 0 || key.length > 10) return true;
                    for(var i = 0; i < key.length; i++){
                        var code = key.charCodeAt(i);
                        if (code < 48 || code > 57) return true;
                    } // The maximum size for an array is 2 ** 32 -1.
                    return key.length === 10 && key >= Math.pow(2, 32);
                }
                function getOwnNonIndexProperties(value) {
                    return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
                } // Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
                // original notice:
                /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */ function compare(a, b) {
                    if (a === b) {
                        return 0;
                    }
                    var x = a.length;
                    var y = b.length;
                    for(var i = 0, len = Math.min(x, y); i < len; ++i){
                        if (a[i] !== b[i]) {
                            x = a[i];
                            y = b[i];
                            break;
                        }
                    }
                    if (x < y) {
                        return -1;
                    }
                    if (y < x) {
                        return 1;
                    }
                    return 0;
                }
                var ONLY_ENUMERABLE = undefined;
                var kStrict = true;
                var kLoose = false;
                var kNoIterator = 0;
                var kIsArray = 1;
                var kIsSet = 2;
                var kIsMap = 3; // Check if they have the same source and flags
                function areSimilarRegExps(a, b) {
                    return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
                }
                function areSimilarFloatArrays(a, b) {
                    if (a.byteLength !== b.byteLength) {
                        return false;
                    }
                    for(var offset = 0; offset < a.byteLength; offset++){
                        if (a[offset] !== b[offset]) {
                            return false;
                        }
                    }
                    return true;
                }
                function areSimilarTypedArrays(a, b) {
                    if (a.byteLength !== b.byteLength) {
                        return false;
                    }
                    return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
                }
                function areEqualArrayBuffers(buf1, buf2) {
                    return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
                }
                function isEqualBoxedPrimitive(val1, val2) {
                    if (isNumberObject(val1)) {
                        return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
                    }
                    if (isStringObject(val1)) {
                        return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
                    }
                    if (isBooleanObject(val1)) {
                        return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
                    }
                    if (isBigIntObject(val1)) {
                        return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
                    }
                    return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
                } // Notes: Type tags are historical [[Class]] properties that can be set by
                // FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
                // and retrieved using Object.prototype.toString.call(obj) in JS
                // See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
                // for a list of tags pre-defined in the spec.
                // There are some unspecified tags in the wild too (e.g. typed array tags).
                // Since tags can be altered, they only serve fast failures
                //
                // Typed arrays and buffers are checked by comparing the content in their
                // underlying ArrayBuffer. This optimization requires that it's
                // reasonable to interpret their underlying memory in the same way,
                // which is checked by comparing their type tags.
                // (e.g. a Uint8Array and a Uint16Array with the same memory content
                // could still be different because they will be interpreted differently).
                //
                // For strict comparison, objects should have
                // a) The same built-in type tags
                // b) The same prototypes.
                function innerDeepEqual(val1, val2, strict, memos) {
                    // All identical values are equivalent, as determined by ===.
                    if (val1 === val2) {
                        if (val1 !== 0) return true;
                        return strict ? objectIs(val1, val2) : true;
                    } // Check more closely if val1 and val2 are equal.
                    if (strict) {
                        if (_typeof(val1) !== 'object') {
                            return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);
                        }
                        if (_typeof(val2) !== 'object' || val1 === null || val2 === null) {
                            return false;
                        }
                        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
                            return false;
                        }
                    } else {
                        if (val1 === null || _typeof(val1) !== 'object') {
                            if (val2 === null || _typeof(val2) !== 'object') {
                                // eslint-disable-next-line eqeqeq
                                return val1 == val2;
                            }
                            return false;
                        }
                        if (val2 === null || _typeof(val2) !== 'object') {
                            return false;
                        }
                    }
                    var val1Tag = objectToString(val1);
                    var val2Tag = objectToString(val2);
                    if (val1Tag !== val2Tag) {
                        return false;
                    }
                    if (Array.isArray(val1)) {
                        // Check for sparse arrays and general fast path
                        if (val1.length !== val2.length) {
                            return false;
                        }
                        var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
                        var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
                        if (keys1.length !== keys2.length) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
                    } // [browserify] This triggers on certain types in IE (Map/Set) so we don't
                    // wan't to early return out of the rest of the checks. However we can check
                    // if the second value is one of these values and the first isn't.
                    if (val1Tag === '[object Object]') {
                        // return keyCheck(val1, val2, strict, memos, kNoIterator);
                        if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
                            return false;
                        }
                    }
                    if (isDate(val1)) {
                        if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
                            return false;
                        }
                    } else if (isRegExp(val1)) {
                        if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
                            return false;
                        }
                    } else if (isNativeError(val1) || val1 instanceof Error) {
                        // Do not compare the stack as it might differ even though the error itself
                        // is otherwise identical.
                        if (val1.message !== val2.message || val1.name !== val2.name) {
                            return false;
                        }
                    } else if (isArrayBufferView(val1)) {
                        if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
                            if (!areSimilarFloatArrays(val1, val2)) {
                                return false;
                            }
                        } else if (!areSimilarTypedArrays(val1, val2)) {
                            return false;
                        } // Buffer.compare returns true, so val1.length === val2.length. If they both
                        // only contain numeric keys, we don't need to exam further than checking
                        // the symbols.
                        var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
                        var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
                        if (_keys.length !== _keys2.length) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
                    } else if (isSet(val1)) {
                        if (!isSet(val2) || val1.size !== val2.size) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kIsSet);
                    } else if (isMap(val1)) {
                        if (!isMap(val2) || val1.size !== val2.size) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kIsMap);
                    } else if (isAnyArrayBuffer(val1)) {
                        if (!areEqualArrayBuffers(val1, val2)) {
                            return false;
                        }
                    } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
                        return false;
                    }
                    return keyCheck(val1, val2, strict, memos, kNoIterator);
                }
                function getEnumerables(val, keys) {
                    return keys.filter(function(k) {
                        return propertyIsEnumerable(val, k);
                    });
                }
                function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
                    // For all remaining Object pairs, including Array, objects and Maps,
                    // equivalence is determined by having:
                    // a) The same number of owned enumerable properties
                    // b) The same set of keys/indexes (although not necessarily the same order)
                    // c) Equivalent values for every corresponding key/index
                    // d) For Sets and Maps, equal contents
                    // Note: this accounts for both named and indexed properties on Arrays.
                    if (arguments.length === 5) {
                        aKeys = Object.keys(val1);
                        var bKeys = Object.keys(val2); // The pair must have the same number of owned properties.
                        if (aKeys.length !== bKeys.length) {
                            return false;
                        }
                    } // Cheap key test
                    var i = 0;
                    for(; i < aKeys.length; i++){
                        if (!hasOwnProperty(val2, aKeys[i])) {
                            return false;
                        }
                    }
                    if (strict && arguments.length === 5) {
                        var symbolKeysA = objectGetOwnPropertySymbols(val1);
                        if (symbolKeysA.length !== 0) {
                            var count = 0;
                            for(i = 0; i < symbolKeysA.length; i++){
                                var key = symbolKeysA[i];
                                if (propertyIsEnumerable(val1, key)) {
                                    if (!propertyIsEnumerable(val2, key)) {
                                        return false;
                                    }
                                    aKeys.push(key);
                                    count++;
                                } else if (propertyIsEnumerable(val2, key)) {
                                    return false;
                                }
                            }
                            var symbolKeysB = objectGetOwnPropertySymbols(val2);
                            if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
                                return false;
                            }
                        } else {
                            var _symbolKeysB = objectGetOwnPropertySymbols(val2);
                            if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
                                return false;
                            }
                        }
                    }
                    if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
                        return true;
                    } // Use memos to handle cycles.
                    if (memos === undefined) {
                        memos = {
                            val1: new Map(),
                            val2: new Map(),
                            position: 0
                        };
                    } else {
                        // We prevent up to two map.has(x) calls by directly retrieving the value
                        // and checking for undefined. The map can only contain numbers, so it is
                        // safe to check for undefined only.
                        var val2MemoA = memos.val1.get(val1);
                        if (val2MemoA !== undefined) {
                            var val2MemoB = memos.val2.get(val2);
                            if (val2MemoB !== undefined) {
                                return val2MemoA === val2MemoB;
                            }
                        }
                        memos.position++;
                    }
                    memos.val1.set(val1, memos.position);
                    memos.val2.set(val2, memos.position);
                    var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
                    memos.val1.delete(val1);
                    memos.val2.delete(val2);
                    return areEq;
                }
                function setHasEqualElement(set, val1, strict, memo) {
                    // Go looking.
                    var setValues = arrayFromSet(set);
                    for(var i = 0; i < setValues.length; i++){
                        var val2 = setValues[i];
                        if (innerDeepEqual(val1, val2, strict, memo)) {
                            // Remove the matching element to make sure we do not check that again.
                            set.delete(val2);
                            return true;
                        }
                    }
                    return false;
                } // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
                // Sadly it is not possible to detect corresponding values properly in case the
                // type is a string, number, bigint or boolean. The reason is that those values
                // can match lots of different string values (e.g., 1n == '+00001').
                function findLooseMatchingPrimitives(prim) {
                    switch(_typeof(prim)){
                        case 'undefined':
                            return null;
                        case 'object':
                            // Only pass in null as object!
                            return undefined;
                        case 'symbol':
                            return false;
                        case 'string':
                            prim = +prim;
                        // Loose equal entries exist only if the string is possible to convert to
                        // a regular number and not NaN.
                        // Fall through
                        case 'number':
                            if (numberIsNaN(prim)) {
                                return false;
                            }
                    }
                    return true;
                }
                function setMightHaveLoosePrim(a, b, prim) {
                    var altValue = findLooseMatchingPrimitives(prim);
                    if (altValue != null) return altValue;
                    return b.has(altValue) && !a.has(altValue);
                }
                function mapMightHaveLoosePrim(a, b, prim, item, memo) {
                    var altValue = findLooseMatchingPrimitives(prim);
                    if (altValue != null) {
                        return altValue;
                    }
                    var curB = b.get(altValue);
                    if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
                        return false;
                    }
                    return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
                }
                function setEquiv(a, b, strict, memo) {
                    // This is a lazily initiated Set of entries which have to be compared
                    // pairwise.
                    var set = null;
                    var aValues = arrayFromSet(a);
                    for(var i = 0; i < aValues.length; i++){
                        var val = aValues[i]; // Note: Checking for the objects first improves the performance for object
                        // heavy sets but it is a minor slow down for primitives. As they are fast
                        // to check this improves the worst case scenario instead.
                        if (_typeof(val) === 'object' && val !== null) {
                            if (set === null) {
                                set = new Set();
                            } // If the specified value doesn't exist in the second set its an not null
                            // object (or non strict only: a not matching primitive) we'll need to go
                            // hunting for something thats deep-(strict-)equal to it. To make this
                            // O(n log n) complexity we have to copy these values in a new set first.
                            set.add(val);
                        } else if (!b.has(val)) {
                            if (strict) return false; // Fast path to detect missing string, symbol, undefined and null values.
                            if (!setMightHaveLoosePrim(a, b, val)) {
                                return false;
                            }
                            if (set === null) {
                                set = new Set();
                            }
                            set.add(val);
                        }
                    }
                    if (set !== null) {
                        var bValues = arrayFromSet(b);
                        for(var _i = 0; _i < bValues.length; _i++){
                            var _val = bValues[_i]; // We have to check if a primitive value is already
                            // matching and only if it's not, go hunting for it.
                            if (_typeof(_val) === 'object' && _val !== null) {
                                if (!setHasEqualElement(set, _val, strict, memo)) return false;
                            } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
                                return false;
                            }
                        }
                        return set.size === 0;
                    }
                    return true;
                }
                function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
                    // To be able to handle cases like:
                    //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
                    // ... we need to consider *all* matching keys, not just the first we find.
                    var setValues = arrayFromSet(set);
                    for(var i = 0; i < setValues.length; i++){
                        var key2 = setValues[i];
                        if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
                            set.delete(key2);
                            return true;
                        }
                    }
                    return false;
                }
                function mapEquiv(a, b, strict, memo) {
                    var set = null;
                    var aEntries = arrayFromMap(a);
                    for(var i = 0; i < aEntries.length; i++){
                        var _aEntries$i = _slicedToArray(aEntries[i], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
                        if (_typeof(key) === 'object' && key !== null) {
                            if (set === null) {
                                set = new Set();
                            }
                            set.add(key);
                        } else {
                            // By directly retrieving the value we prevent another b.has(key) check in
                            // almost all possible cases.
                            var item2 = b.get(key);
                            if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
                                if (strict) return false; // Fast path to detect missing string, symbol, undefined and null
                                // keys.
                                if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;
                                if (set === null) {
                                    set = new Set();
                                }
                                set.add(key);
                            }
                        }
                    }
                    if (set !== null) {
                        var bEntries = arrayFromMap(b);
                        for(var _i2 = 0; _i2 < bEntries.length; _i2++){
                            var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), key = _bEntries$_i[0], item = _bEntries$_i[1];
                            if (_typeof(key) === 'object' && key !== null) {
                                if (!mapHasEqualEntry(set, a, key, item, strict, memo)) return false;
                            } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) {
                                return false;
                            }
                        }
                        return set.size === 0;
                    }
                    return true;
                }
                function objEquiv(a, b, strict, keys, memos, iterationType) {
                    // Sets and maps don't have their entries accessible via normal object
                    // properties.
                    var i = 0;
                    if (iterationType === kIsSet) {
                        if (!setEquiv(a, b, strict, memos)) {
                            return false;
                        }
                    } else if (iterationType === kIsMap) {
                        if (!mapEquiv(a, b, strict, memos)) {
                            return false;
                        }
                    } else if (iterationType === kIsArray) {
                        for(; i < a.length; i++){
                            if (hasOwnProperty(a, i)) {
                                if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
                                    return false;
                                }
                            } else if (hasOwnProperty(b, i)) {
                                return false;
                            } else {
                                // Array is sparse.
                                var keysA = Object.keys(a);
                                for(; i < keysA.length; i++){
                                    var key = keysA[i];
                                    if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
                                        return false;
                                    }
                                }
                                if (keysA.length !== Object.keys(b).length) {
                                    return false;
                                }
                                return true;
                            }
                        }
                    } // The pair must have equivalent values for every corresponding key.
                    // Possibly expensive deep test:
                    for(i = 0; i < keys.length; i++){
                        var _key = keys[i];
                        if (!innerDeepEqual(a[_key], b[_key], strict, memos)) {
                            return false;
                        }
                    }
                    return true;
                }
                function isDeepEqual(val1, val2) {
                    return innerDeepEqual(val1, val2, kLoose);
                }
                function isDeepStrictEqual(val1, val2) {
                    return innerDeepEqual(val1, val2, kStrict);
                }
                module1.exports = {
                    isDeepEqual: isDeepEqual,
                    isDeepStrictEqual: isDeepStrictEqual
                };
            /***/ },
            /***/ 2680: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_107933__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_107933__(7286);
                var callBind = __nested_webpack_require_107933__(9429);
                var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));
                module1.exports = function callBoundIntrinsic(name, allowMissing) {
                    var intrinsic = GetIntrinsic(name, !!allowMissing);
                    if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
                        return callBind(intrinsic);
                    }
                    return intrinsic;
                };
            /***/ },
            /***/ 9429: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_108661__)=>{
                "use strict";
                var bind = __nested_webpack_require_108661__(4090);
                var GetIntrinsic = __nested_webpack_require_108661__(7286);
                var $apply = GetIntrinsic('%Function.prototype.apply%');
                var $call = GetIntrinsic('%Function.prototype.call%');
                var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);
                var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
                var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
                var $max = GetIntrinsic('%Math.max%');
                if ($defineProperty) {
                    try {
                        $defineProperty({}, 'a', {
                            value: 1
                        });
                    } catch (e) {
                        // IE 8 has a broken defineProperty
                        $defineProperty = null;
                    }
                }
                module1.exports = function callBind(originalFunction) {
                    var func = $reflectApply(bind, $call, arguments);
                    if ($gOPD && $defineProperty) {
                        var desc = $gOPD(func, 'length');
                        if (desc.configurable) {
                            // original length, plus the receiver, minus any additional arguments (after the receiver)
                            $defineProperty(func, 'length', {
                                value: 1 + $max(0, originalFunction.length - (arguments.length - 1))
                            });
                        }
                    }
                    return func;
                };
                var applyBind = function applyBind() {
                    return $reflectApply(bind, $apply, arguments);
                };
                if ($defineProperty) {
                    $defineProperty(module1.exports, 'apply', {
                        value: applyBind
                    });
                } else {
                    module1.exports.apply = applyBind;
                }
            /***/ },
            /***/ 3716: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_110875__)=>{
                /*global window, global*/ var util = __nested_webpack_require_110875__(3335);
                var assert = __nested_webpack_require_110875__(1696);
                function now() {
                    return new Date().getTime();
                }
                var slice = Array.prototype.slice;
                var console;
                var times = {};
                if (typeof __nested_webpack_require_110875__.g !== "undefined" && __nested_webpack_require_110875__.g.console) {
                    console = __nested_webpack_require_110875__.g.console;
                } else if (typeof window !== "undefined" && window.console) {
                    console = window.console;
                } else {
                    console = {};
                }
                var functions = [
                    [
                        log,
                        "log"
                    ],
                    [
                        info,
                        "info"
                    ],
                    [
                        warn,
                        "warn"
                    ],
                    [
                        error,
                        "error"
                    ],
                    [
                        time,
                        "time"
                    ],
                    [
                        timeEnd,
                        "timeEnd"
                    ],
                    [
                        trace,
                        "trace"
                    ],
                    [
                        dir,
                        "dir"
                    ],
                    [
                        consoleAssert,
                        "assert"
                    ]
                ];
                for(var i = 0; i < functions.length; i++){
                    var tuple = functions[i];
                    var f = tuple[0];
                    var name = tuple[1];
                    if (!console[name]) {
                        console[name] = f;
                    }
                }
                module1.exports = console;
                function log() {}
                function info() {
                    console.log.apply(console, arguments);
                }
                function warn() {
                    console.log.apply(console, arguments);
                }
                function error() {
                    console.warn.apply(console, arguments);
                }
                function time(label) {
                    times[label] = now();
                }
                function timeEnd(label) {
                    var time = times[label];
                    if (!time) {
                        throw new Error("No such label: " + label);
                    }
                    delete times[label];
                    var duration = now() - time;
                    console.log(label + ": " + duration + "ms");
                }
                function trace() {
                    var err = new Error();
                    err.name = "Trace";
                    err.message = util.format.apply(null, arguments);
                    console.error(err.stack);
                }
                function dir(object) {
                    console.log(util.inspect(object) + "\n");
                }
                function consoleAssert(expression) {
                    if (!expression) {
                        var arr = slice.call(arguments, 1);
                        assert.ok(false, util.format.apply(null, arr));
                    }
                }
            /***/ },
            /***/ 4926: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_114558__)=>{
                "use strict";
                var keys = __nested_webpack_require_114558__(3464);
                var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';
                var toStr = Object.prototype.toString;
                var concat = Array.prototype.concat;
                var origDefineProperty = Object.defineProperty;
                var isFunction = function(fn) {
                    return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
                };
                var hasPropertyDescriptors = __nested_webpack_require_114558__(1181)();
                var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;
                var defineProperty = function(object, name, value, predicate) {
                    if (name in object) {
                        if (predicate === true) {
                            if (object[name] === value) {
                                return;
                            }
                        } else if (!isFunction(predicate) || !predicate()) {
                            return;
                        }
                    }
                    if (supportsDescriptors) {
                        origDefineProperty(object, name, {
                            configurable: true,
                            enumerable: false,
                            value: value,
                            writable: true
                        });
                    } else {
                        object[name] = value; // eslint-disable-line no-param-reassign
                    }
                };
                var defineProperties = function(object, map) {
                    var predicates = arguments.length > 2 ? arguments[2] : {};
                    var props = keys(map);
                    if (hasSymbols) {
                        props = concat.call(props, Object.getOwnPropertySymbols(map));
                    }
                    for(var i = 0; i < props.length; i += 1){
                        defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
                    }
                };
                defineProperties.supportsDescriptors = !!supportsDescriptors;
                module1.exports = defineProperties;
            /***/ },
            /***/ 4956: /***/ (module1)=>{
                "use strict";
                /**
 * Code refactored from Mozilla Developer Network:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 */ function assign(target, firstSource) {
                    if (target === undefined || target === null) {
                        throw new TypeError('Cannot convert first argument to object');
                    }
                    var to = Object(target);
                    for(var i = 1; i < arguments.length; i++){
                        var nextSource = arguments[i];
                        if (nextSource === undefined || nextSource === null) {
                            continue;
                        }
                        var keysArray = Object.keys(Object(nextSource));
                        for(var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++){
                            var nextKey = keysArray[nextIndex];
                            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                            if (desc !== undefined && desc.enumerable) {
                                to[nextKey] = nextSource[nextKey];
                            }
                        }
                    }
                    return to;
                }
                function polyfill() {
                    if (!Object.assign) {
                        Object.defineProperty(Object, 'assign', {
                            enumerable: false,
                            configurable: true,
                            writable: true,
                            value: assign
                        });
                    }
                }
                module1.exports = {
                    assign: assign,
                    polyfill: polyfill
                };
            /***/ },
            /***/ 3243: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_118854__)=>{
                "use strict";
                var isCallable = __nested_webpack_require_118854__(9680);
                var toStr = Object.prototype.toString;
                var hasOwnProperty = Object.prototype.hasOwnProperty;
                var forEachArray = function forEachArray(array, iterator, receiver) {
                    for(var i = 0, len = array.length; i < len; i++){
                        if (hasOwnProperty.call(array, i)) {
                            if (receiver == null) {
                                iterator(array[i], i, array);
                            } else {
                                iterator.call(receiver, array[i], i, array);
                            }
                        }
                    }
                };
                var forEachString = function forEachString(string, iterator, receiver) {
                    for(var i = 0, len = string.length; i < len; i++){
                        // no such thing as a sparse string.
                        if (receiver == null) {
                            iterator(string.charAt(i), i, string);
                        } else {
                            iterator.call(receiver, string.charAt(i), i, string);
                        }
                    }
                };
                var forEachObject = function forEachObject(object, iterator, receiver) {
                    for(var k in object){
                        if (hasOwnProperty.call(object, k)) {
                            if (receiver == null) {
                                iterator(object[k], k, object);
                            } else {
                                iterator.call(receiver, object[k], k, object);
                            }
                        }
                    }
                };
                var forEach = function forEach(list, iterator, thisArg) {
                    if (!isCallable(iterator)) {
                        throw new TypeError('iterator must be a function');
                    }
                    var receiver;
                    if (arguments.length >= 3) {
                        receiver = thisArg;
                    }
                    if (toStr.call(list) === '[object Array]') {
                        forEachArray(list, iterator, receiver);
                    } else if (typeof list === 'string') {
                        forEachString(list, iterator, receiver);
                    } else {
                        forEachObject(list, iterator, receiver);
                    }
                };
                module1.exports = forEach;
            /***/ },
            /***/ 7795: /***/ (module1)=>{
                "use strict";
                /* eslint no-invalid-this: 1 */ var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
                var slice = Array.prototype.slice;
                var toStr = Object.prototype.toString;
                var funcType = '[object Function]';
                module1.exports = function bind(that) {
                    var target = this;
                    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
                        throw new TypeError(ERROR_MESSAGE + target);
                    }
                    var args = slice.call(arguments, 1);
                    var bound;
                    var binder = function() {
                        if (this instanceof bound) {
                            var result = target.apply(this, args.concat(slice.call(arguments)));
                            if (Object(result) === result) {
                                return result;
                            }
                            return this;
                        } else {
                            return target.apply(that, args.concat(slice.call(arguments)));
                        }
                    };
                    var boundLength = Math.max(0, target.length - args.length);
                    var boundArgs = [];
                    for(var i = 0; i < boundLength; i++){
                        boundArgs.push('$' + i);
                    }
                    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);
                    if (target.prototype) {
                        var Empty = function Empty() {};
                        Empty.prototype = target.prototype;
                        bound.prototype = new Empty();
                        Empty.prototype = null;
                    }
                    return bound;
                };
            /***/ },
            /***/ 4090: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_123580__)=>{
                "use strict";
                var implementation = __nested_webpack_require_123580__(7795);
                module1.exports = Function.prototype.bind || implementation;
            /***/ },
            /***/ 7286: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_123862__)=>{
                "use strict";
                var undefined1;
                var $SyntaxError = SyntaxError;
                var $Function = Function;
                var $TypeError = TypeError;
                // eslint-disable-next-line consistent-return
                var getEvalledConstructor = function(expressionSyntax) {
                    try {
                        return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
                    } catch (e) {}
                };
                var $gOPD = Object.getOwnPropertyDescriptor;
                if ($gOPD) {
                    try {
                        $gOPD({}, '');
                    } catch (e) {
                        $gOPD = null; // this is IE 8, which has a broken gOPD
                    }
                }
                var throwTypeError = function() {
                    throw new $TypeError();
                };
                var ThrowTypeError = $gOPD ? function() {
                    try {
                        // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
                        arguments.callee; // IE 8 does not throw here
                        return throwTypeError;
                    } catch (calleeThrows) {
                        try {
                            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
                            return $gOPD(arguments, 'callee').get;
                        } catch (gOPDthrows) {
                            return throwTypeError;
                        }
                    }
                }() : throwTypeError;
                var hasSymbols = __nested_webpack_require_123862__(2636)();
                var hasProto = __nested_webpack_require_123862__(8486)();
                var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
                    return x.__proto__;
                } // eslint-disable-line no-proto
                 : null);
                var needsEval = {};
                var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined1 : getProto(Uint8Array);
                var INTRINSICS = {
                    '%AggregateError%': typeof AggregateError === 'undefined' ? undefined1 : AggregateError,
                    '%Array%': Array,
                    '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined1 : ArrayBuffer,
                    '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined1,
                    '%AsyncFromSyncIteratorPrototype%': undefined1,
                    '%AsyncFunction%': needsEval,
                    '%AsyncGenerator%': needsEval,
                    '%AsyncGeneratorFunction%': needsEval,
                    '%AsyncIteratorPrototype%': needsEval,
                    '%Atomics%': typeof Atomics === 'undefined' ? undefined1 : Atomics,
                    '%BigInt%': typeof BigInt === 'undefined' ? undefined1 : BigInt,
                    '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined1 : BigInt64Array,
                    '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined1 : BigUint64Array,
                    '%Boolean%': Boolean,
                    '%DataView%': typeof DataView === 'undefined' ? undefined1 : DataView,
                    '%Date%': Date,
                    '%decodeURI%': decodeURI,
                    '%decodeURIComponent%': decodeURIComponent,
                    '%encodeURI%': encodeURI,
                    '%encodeURIComponent%': encodeURIComponent,
                    '%Error%': Error,
                    '%eval%': eval,
                    '%EvalError%': EvalError,
                    '%Float32Array%': typeof Float32Array === 'undefined' ? undefined1 : Float32Array,
                    '%Float64Array%': typeof Float64Array === 'undefined' ? undefined1 : Float64Array,
                    '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined1 : FinalizationRegistry,
                    '%Function%': $Function,
                    '%GeneratorFunction%': needsEval,
                    '%Int8Array%': typeof Int8Array === 'undefined' ? undefined1 : Int8Array,
                    '%Int16Array%': typeof Int16Array === 'undefined' ? undefined1 : Int16Array,
                    '%Int32Array%': typeof Int32Array === 'undefined' ? undefined1 : Int32Array,
                    '%isFinite%': isFinite,
                    '%isNaN%': isNaN,
                    '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined1,
                    '%JSON%': typeof JSON === 'object' ? JSON : undefined1,
                    '%Map%': typeof Map === 'undefined' ? undefined1 : Map,
                    '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined1 : getProto(new Map()[Symbol.iterator]()),
                    '%Math%': Math,
                    '%Number%': Number,
                    '%Object%': Object,
                    '%parseFloat%': parseFloat,
                    '%parseInt%': parseInt,
                    '%Promise%': typeof Promise === 'undefined' ? undefined1 : Promise,
                    '%Proxy%': typeof Proxy === 'undefined' ? undefined1 : Proxy,
                    '%RangeError%': RangeError,
                    '%ReferenceError%': ReferenceError,
                    '%Reflect%': typeof Reflect === 'undefined' ? undefined1 : Reflect,
                    '%RegExp%': RegExp,
                    '%Set%': typeof Set === 'undefined' ? undefined1 : Set,
                    '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined1 : getProto(new Set()[Symbol.iterator]()),
                    '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined1 : SharedArrayBuffer,
                    '%String%': String,
                    '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined1,
                    '%Symbol%': hasSymbols ? Symbol : undefined1,
                    '%SyntaxError%': $SyntaxError,
                    '%ThrowTypeError%': ThrowTypeError,
                    '%TypedArray%': TypedArray,
                    '%TypeError%': $TypeError,
                    '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined1 : Uint8Array,
                    '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined1 : Uint8ClampedArray,
                    '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined1 : Uint16Array,
                    '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined1 : Uint32Array,
                    '%URIError%': URIError,
                    '%WeakMap%': typeof WeakMap === 'undefined' ? undefined1 : WeakMap,
                    '%WeakRef%': typeof WeakRef === 'undefined' ? undefined1 : WeakRef,
                    '%WeakSet%': typeof WeakSet === 'undefined' ? undefined1 : WeakSet
                };
                if (getProto) {
                    try {
                        null.error; // eslint-disable-line no-unused-expressions
                    } catch (e) {
                        // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
                        var errorProto = getProto(getProto(e));
                        INTRINSICS['%Error.prototype%'] = errorProto;
                    }
                }
                var doEval = function doEval(name) {
                    var value;
                    if (name === '%AsyncFunction%') {
                        value = getEvalledConstructor('async function () {}');
                    } else if (name === '%GeneratorFunction%') {
                        value = getEvalledConstructor('function* () {}');
                    } else if (name === '%AsyncGeneratorFunction%') {
                        value = getEvalledConstructor('async function* () {}');
                    } else if (name === '%AsyncGenerator%') {
                        var fn = doEval('%AsyncGeneratorFunction%');
                        if (fn) {
                            value = fn.prototype;
                        }
                    } else if (name === '%AsyncIteratorPrototype%') {
                        var gen = doEval('%AsyncGenerator%');
                        if (gen && getProto) {
                            value = getProto(gen.prototype);
                        }
                    }
                    INTRINSICS[name] = value;
                    return value;
                };
                var LEGACY_ALIASES = {
                    '%ArrayBufferPrototype%': [
                        'ArrayBuffer',
                        'prototype'
                    ],
                    '%ArrayPrototype%': [
                        'Array',
                        'prototype'
                    ],
                    '%ArrayProto_entries%': [
                        'Array',
                        'prototype',
                        'entries'
                    ],
                    '%ArrayProto_forEach%': [
                        'Array',
                        'prototype',
                        'forEach'
                    ],
                    '%ArrayProto_keys%': [
                        'Array',
                        'prototype',
                        'keys'
                    ],
                    '%ArrayProto_values%': [
                        'Array',
                        'prototype',
                        'values'
                    ],
                    '%AsyncFunctionPrototype%': [
                        'AsyncFunction',
                        'prototype'
                    ],
                    '%AsyncGenerator%': [
                        'AsyncGeneratorFunction',
                        'prototype'
                    ],
                    '%AsyncGeneratorPrototype%': [
                        'AsyncGeneratorFunction',
                        'prototype',
                        'prototype'
                    ],
                    '%BooleanPrototype%': [
                        'Boolean',
                        'prototype'
                    ],
                    '%DataViewPrototype%': [
                        'DataView',
                        'prototype'
                    ],
                    '%DatePrototype%': [
                        'Date',
                        'prototype'
                    ],
                    '%ErrorPrototype%': [
                        'Error',
                        'prototype'
                    ],
                    '%EvalErrorPrototype%': [
                        'EvalError',
                        'prototype'
                    ],
                    '%Float32ArrayPrototype%': [
                        'Float32Array',
                        'prototype'
                    ],
                    '%Float64ArrayPrototype%': [
                        'Float64Array',
                        'prototype'
                    ],
                    '%FunctionPrototype%': [
                        'Function',
                        'prototype'
                    ],
                    '%Generator%': [
                        'GeneratorFunction',
                        'prototype'
                    ],
                    '%GeneratorPrototype%': [
                        'GeneratorFunction',
                        'prototype',
                        'prototype'
                    ],
                    '%Int8ArrayPrototype%': [
                        'Int8Array',
                        'prototype'
                    ],
                    '%Int16ArrayPrototype%': [
                        'Int16Array',
                        'prototype'
                    ],
                    '%Int32ArrayPrototype%': [
                        'Int32Array',
                        'prototype'
                    ],
                    '%JSONParse%': [
                        'JSON',
                        'parse'
                    ],
                    '%JSONStringify%': [
                        'JSON',
                        'stringify'
                    ],
                    '%MapPrototype%': [
                        'Map',
                        'prototype'
                    ],
                    '%NumberPrototype%': [
                        'Number',
                        'prototype'
                    ],
                    '%ObjectPrototype%': [
                        'Object',
                        'prototype'
                    ],
                    '%ObjProto_toString%': [
                        'Object',
                        'prototype',
                        'toString'
                    ],
                    '%ObjProto_valueOf%': [
                        'Object',
                        'prototype',
                        'valueOf'
                    ],
                    '%PromisePrototype%': [
                        'Promise',
                        'prototype'
                    ],
                    '%PromiseProto_then%': [
                        'Promise',
                        'prototype',
                        'then'
                    ],
                    '%Promise_all%': [
                        'Promise',
                        'all'
                    ],
                    '%Promise_reject%': [
                        'Promise',
                        'reject'
                    ],
                    '%Promise_resolve%': [
                        'Promise',
                        'resolve'
                    ],
                    '%RangeErrorPrototype%': [
                        'RangeError',
                        'prototype'
                    ],
                    '%ReferenceErrorPrototype%': [
                        'ReferenceError',
                        'prototype'
                    ],
                    '%RegExpPrototype%': [
                        'RegExp',
                        'prototype'
                    ],
                    '%SetPrototype%': [
                        'Set',
                        'prototype'
                    ],
                    '%SharedArrayBufferPrototype%': [
                        'SharedArrayBuffer',
                        'prototype'
                    ],
                    '%StringPrototype%': [
                        'String',
                        'prototype'
                    ],
                    '%SymbolPrototype%': [
                        'Symbol',
                        'prototype'
                    ],
                    '%SyntaxErrorPrototype%': [
                        'SyntaxError',
                        'prototype'
                    ],
                    '%TypedArrayPrototype%': [
                        'TypedArray',
                        'prototype'
                    ],
                    '%TypeErrorPrototype%': [
                        'TypeError',
                        'prototype'
                    ],
                    '%Uint8ArrayPrototype%': [
                        'Uint8Array',
                        'prototype'
                    ],
                    '%Uint8ClampedArrayPrototype%': [
                        'Uint8ClampedArray',
                        'prototype'
                    ],
                    '%Uint16ArrayPrototype%': [
                        'Uint16Array',
                        'prototype'
                    ],
                    '%Uint32ArrayPrototype%': [
                        'Uint32Array',
                        'prototype'
                    ],
                    '%URIErrorPrototype%': [
                        'URIError',
                        'prototype'
                    ],
                    '%WeakMapPrototype%': [
                        'WeakMap',
                        'prototype'
                    ],
                    '%WeakSetPrototype%': [
                        'WeakSet',
                        'prototype'
                    ]
                };
                var bind = __nested_webpack_require_123862__(4090);
                var hasOwn = __nested_webpack_require_123862__(3198);
                var $concat = bind.call(Function.call, Array.prototype.concat);
                var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
                var $replace = bind.call(Function.call, String.prototype.replace);
                var $strSlice = bind.call(Function.call, String.prototype.slice);
                var $exec = bind.call(Function.call, RegExp.prototype.exec);
                /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */ var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
                var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */ 
                var stringToPath = function stringToPath(string) {
                    var first = $strSlice(string, 0, 1);
                    var last = $strSlice(string, -1);
                    if (first === '%' && last !== '%') {
                        throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
                    } else if (last === '%' && first !== '%') {
                        throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
                    }
                    var result = [];
                    $replace(string, rePropName, function(match, number, quote, subString) {
                        result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
                    });
                    return result;
                };
                /* end adaptation */ var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
                    var intrinsicName = name;
                    var alias;
                    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
                        alias = LEGACY_ALIASES[intrinsicName];
                        intrinsicName = '%' + alias[0] + '%';
                    }
                    if (hasOwn(INTRINSICS, intrinsicName)) {
                        var value = INTRINSICS[intrinsicName];
                        if (value === needsEval) {
                            value = doEval(intrinsicName);
                        }
                        if (typeof value === 'undefined' && !allowMissing) {
                            throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
                        }
                        return {
                            alias: alias,
                            name: intrinsicName,
                            value: value
                        };
                    }
                    throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
                };
                module1.exports = function GetIntrinsic(name, allowMissing) {
                    if (typeof name !== 'string' || name.length === 0) {
                        throw new $TypeError('intrinsic name must be a non-empty string');
                    }
                    if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
                        throw new $TypeError('"allowMissing" argument must be a boolean');
                    }
                    if ($exec(/^%?[^%]*%?$/, name) === null) {
                        throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
                    }
                    var parts = stringToPath(name);
                    var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
                    var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
                    var intrinsicRealName = intrinsic.name;
                    var value = intrinsic.value;
                    var skipFurtherCaching = false;
                    var alias = intrinsic.alias;
                    if (alias) {
                        intrinsicBaseName = alias[0];
                        $spliceApply(parts, $concat([
                            0,
                            1
                        ], alias));
                    }
                    for(var i = 1, isOwn = true; i < parts.length; i += 1){
                        var part = parts[i];
                        var first = $strSlice(part, 0, 1);
                        var last = $strSlice(part, -1);
                        if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
                            throw new $SyntaxError('property names with quotes must have matching quotes');
                        }
                        if (part === 'constructor' || !isOwn) {
                            skipFurtherCaching = true;
                        }
                        intrinsicBaseName += '.' + part;
                        intrinsicRealName = '%' + intrinsicBaseName + '%';
                        if (hasOwn(INTRINSICS, intrinsicRealName)) {
                            value = INTRINSICS[intrinsicRealName];
                        } else if (value != null) {
                            if (!(part in value)) {
                                if (!allowMissing) {
                                    throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
                                }
                                return void undefined1;
                            }
                            if ($gOPD && i + 1 >= parts.length) {
                                var desc = $gOPD(value, part);
                                isOwn = !!desc;
                                // By convention, when a data property is converted to an accessor
                                // property to emulate a data property that does not suffer from
                                // the override mistake, that accessor's getter is marked with
                                // an `originalValue` property. Here, when we detect this, we
                                // uphold the illusion by pretending to see that original data
                                // property, i.e., returning the value rather than the getter
                                // itself.
                                if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
                                    value = desc.get;
                                } else {
                                    value = value[part];
                                }
                            } else {
                                isOwn = hasOwn(value, part);
                                value = value[part];
                            }
                            if (isOwn && !skipFurtherCaching) {
                                INTRINSICS[intrinsicRealName] = value;
                            }
                        }
                    }
                    return value;
                };
            /***/ },
            /***/ 326: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_147329__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_147329__(7286);
                var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
                if ($gOPD) {
                    try {
                        $gOPD([], 'length');
                    } catch (e) {
                        // IE 8 has a broken gOPD
                        $gOPD = null;
                    }
                }
                module1.exports = $gOPD;
            /***/ },
            /***/ 1181: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_147920__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_147920__(7286);
                var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
                var hasPropertyDescriptors = function hasPropertyDescriptors() {
                    if ($defineProperty) {
                        try {
                            $defineProperty({}, 'a', {
                                value: 1
                            });
                            return true;
                        } catch (e) {
                            // IE 8 has a broken defineProperty
                            return false;
                        }
                    }
                    return false;
                };
                hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
                    // node v0.6 has a bug where array lengths can be Set but not Defined
                    if (!hasPropertyDescriptors()) {
                        return null;
                    }
                    try {
                        return $defineProperty([], 'length', {
                            value: 1
                        }).length !== 1;
                    } catch (e) {
                        // In Firefox 4-22, defining length on an array throws an exception.
                        return true;
                    }
                };
                module1.exports = hasPropertyDescriptors;
            /***/ },
            /***/ 8486: /***/ (module1)=>{
                "use strict";
                var test = {
                    foo: {}
                };
                var $Object = Object;
                module1.exports = function hasProto() {
                    return ({
                        __proto__: test
                    }).foo === test.foo && !(({
                        __proto__: null
                    }) instanceof $Object);
                };
            /***/ },
            /***/ 2636: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_149995__)=>{
                "use strict";
                var origSymbol = typeof Symbol !== 'undefined' && Symbol;
                var hasSymbolSham = __nested_webpack_require_149995__(6679);
                module1.exports = function hasNativeSymbols() {
                    if (typeof origSymbol !== 'function') {
                        return false;
                    }
                    if (typeof Symbol !== 'function') {
                        return false;
                    }
                    if (typeof origSymbol('foo') !== 'symbol') {
                        return false;
                    }
                    if (typeof Symbol('bar') !== 'symbol') {
                        return false;
                    }
                    return hasSymbolSham();
                };
            /***/ },
            /***/ 6679: /***/ (module1)=>{
                "use strict";
                /* eslint complexity: [2, 18], max-statements: [2, 33] */ module1.exports = function hasSymbols() {
                    if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
                        return false;
                    }
                    if (typeof Symbol.iterator === 'symbol') {
                        return true;
                    }
                    var obj = {};
                    var sym = Symbol('test');
                    var symObj = Object(sym);
                    if (typeof sym === 'string') {
                        return false;
                    }
                    if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
                        return false;
                    }
                    if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
                        return false;
                    }
                    // temp disabled per https://github.com/ljharb/object.assign/issues/17
                    // if (sym instanceof Symbol) { return false; }
                    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
                    // if (!(symObj instanceof Symbol)) { return false; }
                    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
                    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
                    var symVal = 42;
                    obj[sym] = symVal;
                    for(sym in obj){
                        return false;
                    } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
                    if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
                        return false;
                    }
                    if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
                        return false;
                    }
                    var syms = Object.getOwnPropertySymbols(obj);
                    if (syms.length !== 1 || syms[0] !== sym) {
                        return false;
                    }
                    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
                        return false;
                    }
                    if (typeof Object.getOwnPropertyDescriptor === 'function') {
                        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
                        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
                            return false;
                        }
                    }
                    return true;
                };
            /***/ },
            /***/ 7226: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_153754__)=>{
                "use strict";
                var hasSymbols = __nested_webpack_require_153754__(6679);
                module1.exports = function hasToStringTagShams() {
                    return hasSymbols() && !!Symbol.toStringTag;
                };
            /***/ },
            /***/ 3198: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_154106__)=>{
                "use strict";
                var bind = __nested_webpack_require_154106__(4090);
                module1.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
            /***/ },
            /***/ 1285: /***/ (module1)=>{
                if (typeof Object.create === 'function') {
                    // implementation from standard node.js 'util' module
                    module1.exports = function inherits(ctor, superCtor) {
                        if (superCtor) {
                            ctor.super_ = superCtor;
                            ctor.prototype = Object.create(superCtor.prototype, {
                                constructor: {
                                    value: ctor,
                                    enumerable: false,
                                    writable: true,
                                    configurable: true
                                }
                            });
                        }
                    };
                } else {
                    // old school shim for old browsers
                    module1.exports = function inherits(ctor, superCtor) {
                        if (superCtor) {
                            ctor.super_ = superCtor;
                            var TempCtor = function() {};
                            TempCtor.prototype = superCtor.prototype;
                            ctor.prototype = new TempCtor();
                            ctor.prototype.constructor = ctor;
                        }
                    };
                }
            /***/ },
            /***/ 2635: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_155784__)=>{
                "use strict";
                var hasToStringTag = __nested_webpack_require_155784__(7226)();
                var callBound = __nested_webpack_require_155784__(2680);
                var $toString = callBound('Object.prototype.toString');
                var isStandardArguments = function isArguments(value) {
                    if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
                        return false;
                    }
                    return $toString(value) === '[object Arguments]';
                };
                var isLegacyArguments = function isArguments(value) {
                    if (isStandardArguments(value)) {
                        return true;
                    }
                    return value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && $toString(value) !== '[object Array]' && $toString(value.callee) === '[object Function]';
                };
                var supportsStandardArguments = function() {
                    return isStandardArguments(arguments);
                }();
                isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests
                module1.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
            /***/ },
            /***/ 9680: /***/ (module1)=>{
                "use strict";
                var fnToStr = Function.prototype.toString;
                var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
                var badArrayLike;
                var isCallableMarker;
                if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
                    try {
                        badArrayLike = Object.defineProperty({}, 'length', {
                            get: function() {
                                throw isCallableMarker;
                            }
                        });
                        isCallableMarker = {};
                        // eslint-disable-next-line no-throw-literal
                        reflectApply(function() {
                            throw 42;
                        }, null, badArrayLike);
                    } catch (_) {
                        if (_ !== isCallableMarker) {
                            reflectApply = null;
                        }
                    }
                } else {
                    reflectApply = null;
                }
                var constructorRegex = /^\s*class\b/;
                var isES6ClassFn = function isES6ClassFunction(value) {
                    try {
                        var fnStr = fnToStr.call(value);
                        return constructorRegex.test(fnStr);
                    } catch (e) {
                        return false; // not a function
                    }
                };
                var tryFunctionObject = function tryFunctionToStr(value) {
                    try {
                        if (isES6ClassFn(value)) {
                            return false;
                        }
                        fnToStr.call(value);
                        return true;
                    } catch (e) {
                        return false;
                    }
                };
                var toStr = Object.prototype.toString;
                var objectClass = '[object Object]';
                var fnClass = '[object Function]';
                var genClass = '[object GeneratorFunction]';
                var ddaClass = '[object HTMLAllCollection]'; // IE 11
                var ddaClass2 = '[object HTML document.all class]';
                var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
                var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`
                var isIE68 = !(0 in [
                    , 
                ]); // eslint-disable-line no-sparse-arrays, comma-spacing
                var isDDA = function isDocumentDotAll() {
                    return false;
                };
                if (typeof document === 'object') {
                    // Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
                    var all = document.all;
                    if (toStr.call(all) === toStr.call(document.all)) {
                        isDDA = function isDocumentDotAll(value) {
                            /* globals document: false */ // in IE 6-8, typeof document.all is "object" and it's truthy
                            if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
                                try {
                                    var str = toStr.call(value);
                                    return (str === ddaClass || str === ddaClass2 || str === ddaClass3 // opera 12.16
                                     || str === objectClass // IE 6-8
                                    ) && value('') == null; // eslint-disable-line eqeqeq
                                } catch (e) {}
                            }
                            return false;
                        };
                    }
                }
                module1.exports = reflectApply ? function isCallable(value) {
                    if (isDDA(value)) {
                        return true;
                    }
                    if (!value) {
                        return false;
                    }
                    if (typeof value !== 'function' && typeof value !== 'object') {
                        return false;
                    }
                    try {
                        reflectApply(value, null, badArrayLike);
                    } catch (e) {
                        if (e !== isCallableMarker) {
                            return false;
                        }
                    }
                    return !isES6ClassFn(value) && tryFunctionObject(value);
                } : function isCallable(value) {
                    if (isDDA(value)) {
                        return true;
                    }
                    if (!value) {
                        return false;
                    }
                    if (typeof value !== 'function' && typeof value !== 'object') {
                        return false;
                    }
                    if (hasToStringTag) {
                        return tryFunctionObject(value);
                    }
                    if (isES6ClassFn(value)) {
                        return false;
                    }
                    var strClass = toStr.call(value);
                    if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
                        return false;
                    }
                    return tryFunctionObject(value);
                };
            /***/ },
            /***/ 3138: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_162844__)=>{
                "use strict";
                var toStr = Object.prototype.toString;
                var fnToStr = Function.prototype.toString;
                var isFnRegex = /^\s*(?:function)?\*/;
                var hasToStringTag = __nested_webpack_require_162844__(7226)();
                var getProto = Object.getPrototypeOf;
                var getGeneratorFunc = function() {
                    if (!hasToStringTag) {
                        return false;
                    }
                    try {
                        return Function('return function*() {}')();
                    } catch (e) {}
                };
                var GeneratorFunction;
                module1.exports = function isGeneratorFunction(fn) {
                    if (typeof fn !== 'function') {
                        return false;
                    }
                    if (isFnRegex.test(fnToStr.call(fn))) {
                        return true;
                    }
                    if (!hasToStringTag) {
                        var str = toStr.call(fn);
                        return str === '[object GeneratorFunction]';
                    }
                    if (!getProto) {
                        return false;
                    }
                    if (typeof GeneratorFunction === 'undefined') {
                        var generatorFunc = getGeneratorFunc();
                        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
                    }
                    return getProto(fn) === GeneratorFunction;
                };
            /***/ },
            /***/ 7053: /***/ (module1)=>{
                "use strict";
                /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ module1.exports = function isNaN1(value) {
                    return value !== value;
                };
            /***/ },
            /***/ 4782: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_164813__)=>{
                "use strict";
                var callBind = __nested_webpack_require_164813__(9429);
                var define1 = __nested_webpack_require_164813__(4926);
                var implementation = __nested_webpack_require_164813__(7053);
                var getPolyfill = __nested_webpack_require_164813__(755);
                var shim = __nested_webpack_require_164813__(5346);
                var polyfill = callBind(getPolyfill(), Number);
                /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ define1(polyfill, {
                    getPolyfill: getPolyfill,
                    implementation: implementation,
                    shim: shim
                });
                module1.exports = polyfill;
            /***/ },
            /***/ 755: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_165610__)=>{
                "use strict";
                var implementation = __nested_webpack_require_165610__(7053);
                module1.exports = function getPolyfill() {
                    if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {
                        return Number.isNaN;
                    }
                    return implementation;
                };
            /***/ },
            /***/ 5346: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_166086__)=>{
                "use strict";
                var define1 = __nested_webpack_require_166086__(4926);
                var getPolyfill = __nested_webpack_require_166086__(755);
                /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ module1.exports = function shimNumberIsNaN() {
                    var polyfill = getPolyfill();
                    define1(Number, {
                        isNaN: polyfill
                    }, {
                        isNaN: function testIsNaN() {
                            return Number.isNaN !== polyfill;
                        }
                    });
                    return polyfill;
                };
            /***/ },
            /***/ 198: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_166852__)=>{
                "use strict";
                var whichTypedArray = __nested_webpack_require_166852__(2094);
                module1.exports = function isTypedArray(value) {
                    return !!whichTypedArray(value);
                };
            /***/ },
            /***/ 8169: /***/ (module1)=>{
                "use strict";
                var numberIsNaN = function(value) {
                    return value !== value;
                };
                module1.exports = function is(a, b) {
                    if (a === 0 && b === 0) {
                        return 1 / a === 1 / b;
                    }
                    if (a === b) {
                        return true;
                    }
                    if (numberIsNaN(a) && numberIsNaN(b)) {
                        return true;
                    }
                    return false;
                };
            /***/ },
            /***/ 4679: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_167840__)=>{
                "use strict";
                var define1 = __nested_webpack_require_167840__(4926);
                var callBind = __nested_webpack_require_167840__(9429);
                var implementation = __nested_webpack_require_167840__(8169);
                var getPolyfill = __nested_webpack_require_167840__(8070);
                var shim = __nested_webpack_require_167840__(191);
                var polyfill = callBind(getPolyfill(), Object);
                define1(polyfill, {
                    getPolyfill: getPolyfill,
                    implementation: implementation,
                    shim: shim
                });
                module1.exports = polyfill;
            /***/ },
            /***/ 8070: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_168567__)=>{
                "use strict";
                var implementation = __nested_webpack_require_168567__(8169);
                module1.exports = function getPolyfill() {
                    return typeof Object.is === 'function' ? Object.is : implementation;
                };
            /***/ },
            /***/ 191: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_168938__)=>{
                "use strict";
                var getPolyfill = __nested_webpack_require_168938__(8070);
                var define1 = __nested_webpack_require_168938__(4926);
                module1.exports = function shimObjectIs() {
                    var polyfill = getPolyfill();
                    define1(Object, {
                        is: polyfill
                    }, {
                        is: function testObjectIs() {
                            return Object.is !== polyfill;
                        }
                    });
                    return polyfill;
                };
            /***/ },
            /***/ 5691: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_169626__)=>{
                "use strict";
                var keysShim;
                if (!Object.keys) {
                    // modified from https://github.com/es-shims/es5-shim
                    var has = Object.prototype.hasOwnProperty;
                    var toStr = Object.prototype.toString;
                    var isArgs = __nested_webpack_require_169626__(801); // eslint-disable-line global-require
                    var isEnumerable = Object.prototype.propertyIsEnumerable;
                    var hasDontEnumBug = !isEnumerable.call({
                        toString: null
                    }, 'toString');
                    var hasProtoEnumBug = isEnumerable.call(function() {}, 'prototype');
                    var dontEnums = [
                        'toString',
                        'toLocaleString',
                        'valueOf',
                        'hasOwnProperty',
                        'isPrototypeOf',
                        'propertyIsEnumerable',
                        'constructor'
                    ];
                    var equalsConstructorPrototype = function(o) {
                        var ctor = o.constructor;
                        return ctor && ctor.prototype === o;
                    };
                    var excludedKeys = {
                        $applicationCache: true,
                        $console: true,
                        $external: true,
                        $frame: true,
                        $frameElement: true,
                        $frames: true,
                        $innerHeight: true,
                        $innerWidth: true,
                        $onmozfullscreenchange: true,
                        $onmozfullscreenerror: true,
                        $outerHeight: true,
                        $outerWidth: true,
                        $pageXOffset: true,
                        $pageYOffset: true,
                        $parent: true,
                        $scrollLeft: true,
                        $scrollTop: true,
                        $scrollX: true,
                        $scrollY: true,
                        $self: true,
                        $webkitIndexedDB: true,
                        $webkitStorageInfo: true,
                        $window: true
                    };
                    var hasAutomationEqualityBug = function() {
                        /* global window */ if (typeof window === 'undefined') {
                            return false;
                        }
                        for(var k in window){
                            try {
                                if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
                                    try {
                                        equalsConstructorPrototype(window[k]);
                                    } catch (e) {
                                        return true;
                                    }
                                }
                            } catch (e) {
                                return true;
                            }
                        }
                        return false;
                    }();
                    var equalsConstructorPrototypeIfNotBuggy = function(o) {
                        /* global window */ if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
                            return equalsConstructorPrototype(o);
                        }
                        try {
                            return equalsConstructorPrototype(o);
                        } catch (e) {
                            return false;
                        }
                    };
                    keysShim = function keys(object) {
                        var isObject = object !== null && typeof object === 'object';
                        var isFunction = toStr.call(object) === '[object Function]';
                        var isArguments = isArgs(object);
                        var isString = isObject && toStr.call(object) === '[object String]';
                        var theKeys = [];
                        if (!isObject && !isFunction && !isArguments) {
                            throw new TypeError('Object.keys called on a non-object');
                        }
                        var skipProto = hasProtoEnumBug && isFunction;
                        if (isString && object.length > 0 && !has.call(object, 0)) {
                            for(var i = 0; i < object.length; ++i){
                                theKeys.push(String(i));
                            }
                        }
                        if (isArguments && object.length > 0) {
                            for(var j = 0; j < object.length; ++j){
                                theKeys.push(String(j));
                            }
                        } else {
                            for(var name in object){
                                if (!(skipProto && name === 'prototype') && has.call(object, name)) {
                                    theKeys.push(String(name));
                                }
                            }
                        }
                        if (hasDontEnumBug) {
                            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
                            for(var k = 0; k < dontEnums.length; ++k){
                                if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
                                    theKeys.push(dontEnums[k]);
                                }
                            }
                        }
                        return theKeys;
                    };
                }
                module1.exports = keysShim;
            /***/ },
            /***/ 3464: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_175595__)=>{
                "use strict";
                var slice = Array.prototype.slice;
                var isArgs = __nested_webpack_require_175595__(801);
                var origKeys = Object.keys;
                var keysShim = origKeys ? function keys(o) {
                    return origKeys(o);
                } : __nested_webpack_require_175595__(5691);
                var originalKeys = Object.keys;
                keysShim.shim = function shimObjectKeys() {
                    if (Object.keys) {
                        var keysWorksWithArguments = function() {
                            // Safari 5.0 bug
                            var args = Object.keys(arguments);
                            return args && args.length === arguments.length;
                        }(1, 2);
                        if (!keysWorksWithArguments) {
                            Object.keys = function keys(object) {
                                if (isArgs(object)) {
                                    return originalKeys(slice.call(object));
                                }
                                return originalKeys(object);
                            };
                        }
                    } else {
                        Object.keys = keysShim;
                    }
                    return Object.keys || keysShim;
                };
                module1.exports = keysShim;
            /***/ },
            /***/ 801: /***/ (module1)=>{
                "use strict";
                var toStr = Object.prototype.toString;
                module1.exports = function isArguments(value) {
                    var str = toStr.call(value);
                    var isArgs = str === '[object Arguments]';
                    if (!isArgs) {
                        isArgs = str !== '[object Array]' && value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
                    }
                    return isArgs;
                };
            /***/ },
            /***/ 4406: /***/ (module1)=>{
                // shim for using process in browser
                var process = module1.exports = {};
                // cached from whatever global is present so that test runners that stub it
                // don't break things.  But we need to wrap it in a try catch in case it is
                // wrapped in strict mode code which doesn't define any globals.  It's inside a
                // function because try/catches deoptimize in certain engines.
                var cachedSetTimeout;
                var cachedClearTimeout;
                function defaultSetTimout() {
                    throw new Error('setTimeout has not been defined');
                }
                function defaultClearTimeout() {
                    throw new Error('clearTimeout has not been defined');
                }
                (function() {
                    try {
                        if (typeof setTimeout === 'function') {
                            cachedSetTimeout = setTimeout;
                        } else {
                            cachedSetTimeout = defaultSetTimout;
                        }
                    } catch (e) {
                        cachedSetTimeout = defaultSetTimout;
                    }
                    try {
                        if (typeof clearTimeout === 'function') {
                            cachedClearTimeout = clearTimeout;
                        } else {
                            cachedClearTimeout = defaultClearTimeout;
                        }
                    } catch (e) {
                        cachedClearTimeout = defaultClearTimeout;
                    }
                })();
                function runTimeout(fun) {
                    if (cachedSetTimeout === setTimeout) {
                        //normal enviroments in sane situations
                        return setTimeout(fun, 0);
                    }
                    // if setTimeout wasn't available but was latter defined
                    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                        cachedSetTimeout = setTimeout;
                        return setTimeout(fun, 0);
                    }
                    try {
                        // when when somebody has screwed with setTimeout but no I.E. maddness
                        return cachedSetTimeout(fun, 0);
                    } catch (e) {
                        try {
                            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                            return cachedSetTimeout.call(null, fun, 0);
                        } catch (e) {
                            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                            return cachedSetTimeout.call(this, fun, 0);
                        }
                    }
                }
                function runClearTimeout(marker) {
                    if (cachedClearTimeout === clearTimeout) {
                        //normal enviroments in sane situations
                        return clearTimeout(marker);
                    }
                    // if clearTimeout wasn't available but was latter defined
                    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                        cachedClearTimeout = clearTimeout;
                        return clearTimeout(marker);
                    }
                    try {
                        // when when somebody has screwed with setTimeout but no I.E. maddness
                        return cachedClearTimeout(marker);
                    } catch (e) {
                        try {
                            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                            return cachedClearTimeout.call(null, marker);
                        } catch (e) {
                            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                            return cachedClearTimeout.call(this, marker);
                        }
                    }
                }
                var queue = [];
                var draining = false;
                var currentQueue;
                var queueIndex = -1;
                function cleanUpNextTick() {
                    if (!draining || !currentQueue) {
                        return;
                    }
                    draining = false;
                    if (currentQueue.length) {
                        queue = currentQueue.concat(queue);
                    } else {
                        queueIndex = -1;
                    }
                    if (queue.length) {
                        drainQueue();
                    }
                }
                function drainQueue() {
                    if (draining) {
                        return;
                    }
                    var timeout = runTimeout(cleanUpNextTick);
                    draining = true;
                    var len = queue.length;
                    while(len){
                        currentQueue = queue;
                        queue = [];
                        while(++queueIndex < len){
                            if (currentQueue) {
                                currentQueue[queueIndex].run();
                            }
                        }
                        queueIndex = -1;
                        len = queue.length;
                    }
                    currentQueue = null;
                    draining = false;
                    runClearTimeout(timeout);
                }
                process.nextTick = function(fun) {
                    var args = new Array(arguments.length - 1);
                    if (arguments.length > 1) {
                        for(var i = 1; i < arguments.length; i++){
                            args[i - 1] = arguments[i];
                        }
                    }
                    queue.push(new Item(fun, args));
                    if (queue.length === 1 && !draining) {
                        runTimeout(drainQueue);
                    }
                };
                // v8 likes predictible objects
                function Item(fun, array) {
                    this.fun = fun;
                    this.array = array;
                }
                Item.prototype.run = function() {
                    this.fun.apply(null, this.array);
                };
                process.title = 'browser';
                process.browser = true;
                process.env = {};
                process.argv = [];
                process.version = ''; // empty string to avoid regexp issues
                process.versions = {};
                function noop() {}
                process.on = noop;
                process.addListener = noop;
                process.once = noop;
                process.off = noop;
                process.removeListener = noop;
                process.removeAllListeners = noop;
                process.emit = noop;
                process.prependListener = noop;
                process.prependOnceListener = noop;
                process.listeners = function(name) {
                    return [];
                };
                process.binding = function(name) {
                    throw new Error('process.binding is not supported');
                };
                process.cwd = function() {
                    return '/';
                };
                process.chdir = function(dir) {
                    throw new Error('process.chdir is not supported');
                };
                process.umask = function() {
                    return 0;
                };
            /***/ },
            /***/ 4487: /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_185970__)=>{
                "use strict";
                /* harmony export */ __nested_webpack_require_185970__.d(__nested_webpack_exports__, {
                    /* harmony export */ BaseService: ()=>/* binding */ BaseService
                });
                /* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_185970__(6297);
                /* harmony import */ var vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_185970__(4881);
                function _define_property(obj, key, value) {
                    if (key in obj) {
                        Object.defineProperty(obj, key, {
                            value: value,
                            enumerable: true,
                            configurable: true,
                            writable: true
                        });
                    } else {
                        obj[key] = value;
                    }
                    return obj;
                }
                class BaseService {
                    addDocument(document1) {
                        this.documents[document1.uri] = vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_0__ /* .TextDocument */ .n.create(document1.uri, document1.languageId, document1.version, document1.text);
                    //TODO:
                    /*if (options)
            this.setSessionOptions(sessionID, options);*/ }
                    getDocument(uri) {
                        return this.documents[uri];
                    }
                    removeDocument(document1) {
                        delete this.documents[document1.uri];
                        if (this.options[document1.uri]) {
                            delete this.options[document1.uri];
                        }
                    }
                    getDocumentValue(uri) {
                        var _this_getDocument;
                        return (_this_getDocument = this.getDocument(uri)) === null || _this_getDocument === void 0 ? void 0 : _this_getDocument.getText();
                    }
                    setValue(identifier, value) {
                        let document1 = this.getDocument(identifier.uri);
                        if (document1) {
                            document1 = vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_0__ /* .TextDocument */ .n.create(document1.uri, document1.languageId, document1.version, value);
                            this.documents[document1.uri] = document1;
                        }
                    }
                    setGlobalOptions(options) {
                        this.globalOptions = options !== null && options !== void 0 ? options : {};
                    }
                    setOptions(sessionID, options, merge = false) {
                        this.options[sessionID] = merge ? (0, _utils__WEBPACK_IMPORTED_MODULE_1__ /* .mergeObjects */ .PM)(options, this.options[sessionID]) : options;
                    }
                    getOption(sessionID, optionName) {
                        if (this.options[sessionID] && this.options[sessionID][optionName]) {
                            return this.options[sessionID][optionName];
                        } else {
                            return this.globalOptions[optionName];
                        }
                    }
                    applyDeltas(identifier, deltas) {
                        let document1 = this.getDocument(identifier.uri);
                        if (document1) vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_0__ /* .TextDocument */ .n.update(document1, deltas, identifier.version);
                    }
                    async doComplete(document1, position) {
                        return null;
                    }
                    async doHover(document1, position) {
                        return null;
                    }
                    async doResolve(item) {
                        return null;
                    }
                    async doValidation(document1) {
                        return [];
                    }
                    format(document1, range, options) {
                        return Promise.resolve([]);
                    }
                    async provideSignatureHelp(document1, position) {
                        return null;
                    }
                    async findDocumentHighlights(document1, position) {
                        return [];
                    }
                    get optionsToFilterDiagnostics() {
                        var _this_globalOptions_errorCodesToIgnore, _this_globalOptions_errorCodesToTreatAsWarning, _this_globalOptions_errorCodesToTreatAsInfo, _this_globalOptions_errorMessagesToIgnore, _this_globalOptions_errorMessagesToTreatAsWarning, _this_globalOptions_errorMessagesToTreatAsInfo;
                        return {
                            errorCodesToIgnore: (_this_globalOptions_errorCodesToIgnore = this.globalOptions.errorCodesToIgnore) !== null && _this_globalOptions_errorCodesToIgnore !== void 0 ? _this_globalOptions_errorCodesToIgnore : [],
                            errorCodesToTreatAsWarning: (_this_globalOptions_errorCodesToTreatAsWarning = this.globalOptions.errorCodesToTreatAsWarning) !== null && _this_globalOptions_errorCodesToTreatAsWarning !== void 0 ? _this_globalOptions_errorCodesToTreatAsWarning : [],
                            errorCodesToTreatAsInfo: (_this_globalOptions_errorCodesToTreatAsInfo = this.globalOptions.errorCodesToTreatAsInfo) !== null && _this_globalOptions_errorCodesToTreatAsInfo !== void 0 ? _this_globalOptions_errorCodesToTreatAsInfo : [],
                            errorMessagesToIgnore: (_this_globalOptions_errorMessagesToIgnore = this.globalOptions.errorMessagesToIgnore) !== null && _this_globalOptions_errorMessagesToIgnore !== void 0 ? _this_globalOptions_errorMessagesToIgnore : [],
                            errorMessagesToTreatAsWarning: (_this_globalOptions_errorMessagesToTreatAsWarning = this.globalOptions.errorMessagesToTreatAsWarning) !== null && _this_globalOptions_errorMessagesToTreatAsWarning !== void 0 ? _this_globalOptions_errorMessagesToTreatAsWarning : [],
                            errorMessagesToTreatAsInfo: (_this_globalOptions_errorMessagesToTreatAsInfo = this.globalOptions.errorMessagesToTreatAsInfo) !== null && _this_globalOptions_errorMessagesToTreatAsInfo !== void 0 ? _this_globalOptions_errorMessagesToTreatAsInfo : []
                        };
                    }
                    dispose() {
                        return Promise.resolve();
                    }
                    constructor(mode){
                        _define_property(this, "mode", void 0);
                        _define_property(this, "documents", {});
                        _define_property(this, "options", {});
                        _define_property(this, "globalOptions", {});
                        _define_property(this, "serviceData", void 0);
                        _define_property(this, "serviceCapabilities", {});
                        this.mode = mode;
                    }
                }
            /***/ },
            /***/ 6297: /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_193256__)=>{
                "use strict";
                /* harmony export */ __nested_webpack_require_193256__.d(__nested_webpack_exports__, {
                    /* harmony export */ $p: ()=>/* binding */ checkValueAgainstRegexpArray,
                    /* harmony export */ PM: ()=>/* binding */ mergeObjects
                });
                /* unused harmony exports notEmpty, mergeRanges */ function mergeObjects(obj1, obj2) {
                    if (!obj1) return obj2;
                    if (!obj2) return obj1;
                    const mergedObjects = {
                        ...obj2,
                        ...obj1
                    }; // Give priority to obj1 values by spreading obj2 first, then obj1
                    for (const key of Object.keys(mergedObjects)){
                        if (obj1[key] && obj2[key]) {
                            if (Array.isArray(obj1[key])) {
                                mergedObjects[key] = obj1[key].concat(obj2[key]);
                            } else if (Array.isArray(obj2[key])) {
                                mergedObjects[key] = obj2[key].concat(obj1[key]);
                            } else if (typeof obj1[key] === 'object' && typeof obj2[key] === 'object') {
                                mergedObjects[key] = mergeObjects(obj1[key], obj2[key]);
                            }
                        }
                    }
                    return mergedObjects;
                }
                function notEmpty1(value) {
                    return value !== null && value !== undefined;
                }
                //taken with small changes from ace-code
                function mergeRanges1(ranges) {
                    var list = ranges;
                    list = list.sort(function(a, b) {
                        return comparePoints(a.start, b.start);
                    });
                    var next = list[0], range;
                    for(var i = 1; i < list.length; i++){
                        range = next;
                        next = list[i];
                        var cmp = comparePoints(range.end, next.start);
                        if (cmp < 0) continue;
                        if (cmp == 0 && !range.isEmpty() && !next.isEmpty()) continue;
                        if (comparePoints(range.end, next.end) < 0) {
                            range.end.row = next.end.row;
                            range.end.column = next.end.column;
                        }
                        list.splice(i, 1);
                        next = range;
                        i--;
                    }
                    return list;
                }
                function comparePoints(p1, p2) {
                    return p1.row - p2.row || p1.column - p2.column;
                }
                function checkValueAgainstRegexpArray(value, regexpArray) {
                    if (!regexpArray) {
                        return false;
                    }
                    for(let i = 0; i < regexpArray.length; i++){
                        if (regexpArray[i].test(value)) {
                            return true;
                        }
                    }
                    return false;
                }
            /***/ },
            /***/ 82: /***/ (module1)=>{
                module1.exports = function isBuffer(arg) {
                    return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
                };
            /***/ },
            /***/ 4895: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_196888__)=>{
                "use strict";
                // Currently in sync with Node.js lib/internal/util/types.js
                // https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
                var isArgumentsObject = __nested_webpack_require_196888__(2635);
                var isGeneratorFunction = __nested_webpack_require_196888__(3138);
                var whichTypedArray = __nested_webpack_require_196888__(2094);
                var isTypedArray = __nested_webpack_require_196888__(198);
                function uncurryThis(f) {
                    return f.call.bind(f);
                }
                var BigIntSupported = typeof BigInt !== 'undefined';
                var SymbolSupported = typeof Symbol !== 'undefined';
                var ObjectToString = uncurryThis(Object.prototype.toString);
                var numberValue = uncurryThis(Number.prototype.valueOf);
                var stringValue = uncurryThis(String.prototype.valueOf);
                var booleanValue = uncurryThis(Boolean.prototype.valueOf);
                if (BigIntSupported) {
                    var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
                }
                if (SymbolSupported) {
                    var symbolValue = uncurryThis(Symbol.prototype.valueOf);
                }
                function checkBoxedPrimitive(value, prototypeValueOf) {
                    if (typeof value !== 'object') {
                        return false;
                    }
                    try {
                        prototypeValueOf(value);
                        return true;
                    } catch (e) {
                        return false;
                    }
                }
                exports1.isArgumentsObject = isArgumentsObject;
                exports1.isGeneratorFunction = isGeneratorFunction;
                exports1.isTypedArray = isTypedArray;
                // Taken from here and modified for better browser support
                // https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
                function isPromise(input) {
                    return typeof Promise !== 'undefined' && input instanceof Promise || input !== null && typeof input === 'object' && typeof input.then === 'function' && typeof input.catch === 'function';
                }
                exports1.isPromise = isPromise;
                function isArrayBufferView(value) {
                    if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
                        return ArrayBuffer.isView(value);
                    }
                    return isTypedArray(value) || isDataView(value);
                }
                exports1.isArrayBufferView = isArrayBufferView;
                function isUint8Array(value) {
                    return whichTypedArray(value) === 'Uint8Array';
                }
                exports1.isUint8Array = isUint8Array;
                function isUint8ClampedArray(value) {
                    return whichTypedArray(value) === 'Uint8ClampedArray';
                }
                exports1.isUint8ClampedArray = isUint8ClampedArray;
                function isUint16Array(value) {
                    return whichTypedArray(value) === 'Uint16Array';
                }
                exports1.isUint16Array = isUint16Array;
                function isUint32Array(value) {
                    return whichTypedArray(value) === 'Uint32Array';
                }
                exports1.isUint32Array = isUint32Array;
                function isInt8Array(value) {
                    return whichTypedArray(value) === 'Int8Array';
                }
                exports1.isInt8Array = isInt8Array;
                function isInt16Array(value) {
                    return whichTypedArray(value) === 'Int16Array';
                }
                exports1.isInt16Array = isInt16Array;
                function isInt32Array(value) {
                    return whichTypedArray(value) === 'Int32Array';
                }
                exports1.isInt32Array = isInt32Array;
                function isFloat32Array(value) {
                    return whichTypedArray(value) === 'Float32Array';
                }
                exports1.isFloat32Array = isFloat32Array;
                function isFloat64Array(value) {
                    return whichTypedArray(value) === 'Float64Array';
                }
                exports1.isFloat64Array = isFloat64Array;
                function isBigInt64Array(value) {
                    return whichTypedArray(value) === 'BigInt64Array';
                }
                exports1.isBigInt64Array = isBigInt64Array;
                function isBigUint64Array(value) {
                    return whichTypedArray(value) === 'BigUint64Array';
                }
                exports1.isBigUint64Array = isBigUint64Array;
                function isMapToString(value) {
                    return ObjectToString(value) === '[object Map]';
                }
                isMapToString.working = typeof Map !== 'undefined' && isMapToString(new Map());
                function isMap(value) {
                    if (typeof Map === 'undefined') {
                        return false;
                    }
                    return isMapToString.working ? isMapToString(value) : value instanceof Map;
                }
                exports1.isMap = isMap;
                function isSetToString(value) {
                    return ObjectToString(value) === '[object Set]';
                }
                isSetToString.working = typeof Set !== 'undefined' && isSetToString(new Set());
                function isSet(value) {
                    if (typeof Set === 'undefined') {
                        return false;
                    }
                    return isSetToString.working ? isSetToString(value) : value instanceof Set;
                }
                exports1.isSet = isSet;
                function isWeakMapToString(value) {
                    return ObjectToString(value) === '[object WeakMap]';
                }
                isWeakMapToString.working = typeof WeakMap !== 'undefined' && isWeakMapToString(new WeakMap());
                function isWeakMap(value) {
                    if (typeof WeakMap === 'undefined') {
                        return false;
                    }
                    return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
                }
                exports1.isWeakMap = isWeakMap;
                function isWeakSetToString(value) {
                    return ObjectToString(value) === '[object WeakSet]';
                }
                isWeakSetToString.working = typeof WeakSet !== 'undefined' && isWeakSetToString(new WeakSet());
                function isWeakSet(value) {
                    return isWeakSetToString(value);
                }
                exports1.isWeakSet = isWeakSet;
                function isArrayBufferToString(value) {
                    return ObjectToString(value) === '[object ArrayBuffer]';
                }
                isArrayBufferToString.working = typeof ArrayBuffer !== 'undefined' && isArrayBufferToString(new ArrayBuffer());
                function isArrayBuffer(value) {
                    if (typeof ArrayBuffer === 'undefined') {
                        return false;
                    }
                    return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
                }
                exports1.isArrayBuffer = isArrayBuffer;
                function isDataViewToString(value) {
                    return ObjectToString(value) === '[object DataView]';
                }
                isDataViewToString.working = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined' && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
                function isDataView(value) {
                    if (typeof DataView === 'undefined') {
                        return false;
                    }
                    return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
                }
                exports1.isDataView = isDataView;
                // Store a copy of SharedArrayBuffer in case it's deleted elsewhere
                var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
                function isSharedArrayBufferToString(value) {
                    return ObjectToString(value) === '[object SharedArrayBuffer]';
                }
                function isSharedArrayBuffer(value) {
                    if (typeof SharedArrayBufferCopy === 'undefined') {
                        return false;
                    }
                    if (typeof isSharedArrayBufferToString.working === 'undefined') {
                        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
                    }
                    return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
                }
                exports1.isSharedArrayBuffer = isSharedArrayBuffer;
                function isAsyncFunction(value) {
                    return ObjectToString(value) === '[object AsyncFunction]';
                }
                exports1.isAsyncFunction = isAsyncFunction;
                function isMapIterator(value) {
                    return ObjectToString(value) === '[object Map Iterator]';
                }
                exports1.isMapIterator = isMapIterator;
                function isSetIterator(value) {
                    return ObjectToString(value) === '[object Set Iterator]';
                }
                exports1.isSetIterator = isSetIterator;
                function isGeneratorObject(value) {
                    return ObjectToString(value) === '[object Generator]';
                }
                exports1.isGeneratorObject = isGeneratorObject;
                function isWebAssemblyCompiledModule(value) {
                    return ObjectToString(value) === '[object WebAssembly.Module]';
                }
                exports1.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
                function isNumberObject(value) {
                    return checkBoxedPrimitive(value, numberValue);
                }
                exports1.isNumberObject = isNumberObject;
                function isStringObject(value) {
                    return checkBoxedPrimitive(value, stringValue);
                }
                exports1.isStringObject = isStringObject;
                function isBooleanObject(value) {
                    return checkBoxedPrimitive(value, booleanValue);
                }
                exports1.isBooleanObject = isBooleanObject;
                function isBigIntObject(value) {
                    return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
                }
                exports1.isBigIntObject = isBigIntObject;
                function isSymbolObject(value) {
                    return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
                }
                exports1.isSymbolObject = isSymbolObject;
                function isBoxedPrimitive(value) {
                    return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
                }
                exports1.isBoxedPrimitive = isBoxedPrimitive;
                function isAnyArrayBuffer(value) {
                    return typeof Uint8Array !== 'undefined' && (isArrayBuffer(value) || isSharedArrayBuffer(value));
                }
                exports1.isAnyArrayBuffer = isAnyArrayBuffer;
                [
                    'isProxy',
                    'isExternal',
                    'isModuleNamespaceObject'
                ].forEach(function(method) {
                    Object.defineProperty(exports1, method, {
                        enumerable: false,
                        value: function() {
                            throw new Error(method + ' is not supported in userland');
                        }
                    });
                });
            /***/ },
            /***/ 3335: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_209364__)=>{
                /* provided dependency */ var process = __nested_webpack_require_209364__(4406);
                /* provided dependency */ var console = __nested_webpack_require_209364__(3716);
                // Copyright Joyent, Inc. and other Node contributors.
                //
                // Permission is hereby granted, free of charge, to any person obtaining a
                // copy of this software and associated documentation files (the
                // "Software"), to deal in the Software without restriction, including
                // without limitation the rights to use, copy, modify, merge, publish,
                // distribute, sublicense, and/or sell copies of the Software, and to permit
                // persons to whom the Software is furnished to do so, subject to the
                // following conditions:
                //
                // The above copyright notice and this permission notice shall be included
                // in all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
                // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
                // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
                // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
                // USE OR OTHER DEALINGS IN THE SOFTWARE.
                var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
                    var keys = Object.keys(obj);
                    var descriptors = {};
                    for(var i = 0; i < keys.length; i++){
                        descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
                    }
                    return descriptors;
                };
                var formatRegExp = /%[sdj%]/g;
                exports1.format = function(f) {
                    if (!isString(f)) {
                        var objects = [];
                        for(var i = 0; i < arguments.length; i++){
                            objects.push(inspect(arguments[i]));
                        }
                        return objects.join(' ');
                    }
                    var i = 1;
                    var args = arguments;
                    var len = args.length;
                    var str = String(f).replace(formatRegExp, function(x) {
                        if (x === '%%') return '%';
                        if (i >= len) return x;
                        switch(x){
                            case '%s':
                                return String(args[i++]);
                            case '%d':
                                return Number(args[i++]);
                            case '%j':
                                try {
                                    return JSON.stringify(args[i++]);
                                } catch (_) {
                                    return '[Circular]';
                                }
                            default:
                                return x;
                        }
                    });
                    for(var x = args[i]; i < len; x = args[++i]){
                        if (isNull(x) || !isObject(x)) {
                            str += ' ' + x;
                        } else {
                            str += ' ' + inspect(x);
                        }
                    }
                    return str;
                };
                // Mark that a method should not be used.
                // Returns a modified function which warns once by default.
                // If --no-deprecation is set, then it is a no-op.
                exports1.deprecate = function(fn, msg) {
                    if (typeof process !== 'undefined' && process.noDeprecation === true) {
                        return fn;
                    }
                    // Allow for deprecating things in the process of starting up.
                    if (typeof process === 'undefined') {
                        return function() {
                            return exports1.deprecate(fn, msg).apply(this, arguments);
                        };
                    }
                    var warned = false;
                    function deprecated() {
                        if (!warned) {
                            if (process.throwDeprecation) {
                                throw new Error(msg);
                            } else if (process.traceDeprecation) {
                                console.trace(msg);
                            } else {
                                console.error(msg);
                            }
                            warned = true;
                        }
                        return fn.apply(this, arguments);
                    }
                    return deprecated;
                };
                var debugs = {};
                var debugEnvRegex = /^$/;
                if (process.env.NODE_DEBUG) {
                    var debugEnv = process.env.NODE_DEBUG;
                    debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&').replace(/\*/g, '.*').replace(/,/g, '$|^').toUpperCase();
                    debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
                }
                exports1.debuglog = function(set) {
                    set = set.toUpperCase();
                    if (!debugs[set]) {
                        if (debugEnvRegex.test(set)) {
                            var pid = process.pid;
                            debugs[set] = function() {
                                var msg = exports1.format.apply(exports1, arguments);
                                console.error('%s %d: %s', set, pid, msg);
                            };
                        } else {
                            debugs[set] = function() {};
                        }
                    }
                    return debugs[set];
                };
                /**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */ /* legacy: obj, showHidden, depth, colors*/ function inspect(obj, opts) {
                    // default options
                    var ctx = {
                        seen: [],
                        stylize: stylizeNoColor
                    };
                    // legacy...
                    if (arguments.length >= 3) ctx.depth = arguments[2];
                    if (arguments.length >= 4) ctx.colors = arguments[3];
                    if (isBoolean(opts)) {
                        // legacy...
                        ctx.showHidden = opts;
                    } else if (opts) {
                        // got an "options" object
                        exports1._extend(ctx, opts);
                    }
                    // set default options
                    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
                    if (isUndefined(ctx.depth)) ctx.depth = 2;
                    if (isUndefined(ctx.colors)) ctx.colors = false;
                    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
                    if (ctx.colors) ctx.stylize = stylizeWithColor;
                    return formatValue(ctx, obj, ctx.depth);
                }
                exports1.inspect = inspect;
                // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
                inspect.colors = {
                    'bold': [
                        1,
                        22
                    ],
                    'italic': [
                        3,
                        23
                    ],
                    'underline': [
                        4,
                        24
                    ],
                    'inverse': [
                        7,
                        27
                    ],
                    'white': [
                        37,
                        39
                    ],
                    'grey': [
                        90,
                        39
                    ],
                    'black': [
                        30,
                        39
                    ],
                    'blue': [
                        34,
                        39
                    ],
                    'cyan': [
                        36,
                        39
                    ],
                    'green': [
                        32,
                        39
                    ],
                    'magenta': [
                        35,
                        39
                    ],
                    'red': [
                        31,
                        39
                    ],
                    'yellow': [
                        33,
                        39
                    ]
                };
                // Don't use 'blue' not visible on cmd.exe
                inspect.styles = {
                    'special': 'cyan',
                    'number': 'yellow',
                    'boolean': 'yellow',
                    'undefined': 'grey',
                    'null': 'bold',
                    'string': 'green',
                    'date': 'magenta',
                    // "name": intentionally not styling
                    'regexp': 'red'
                };
                function stylizeWithColor(str, styleType) {
                    var style = inspect.styles[styleType];
                    if (style) {
                        return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
                    } else {
                        return str;
                    }
                }
                function stylizeNoColor(str, styleType) {
                    return str;
                }
                function arrayToHash(array) {
                    var hash = {};
                    array.forEach(function(val, idx) {
                        hash[val] = true;
                    });
                    return hash;
                }
                function formatValue(ctx, value, recurseTimes) {
                    // Provide a hook for user-specified inspect functions.
                    // Check that value is an object with an inspect function on it
                    if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
                    value.inspect !== exports1.inspect && // Also filter out any prototype objects using the circular check.
                    !(value.constructor && value.constructor.prototype === value)) {
                        var ret = value.inspect(recurseTimes, ctx);
                        if (!isString(ret)) {
                            ret = formatValue(ctx, ret, recurseTimes);
                        }
                        return ret;
                    }
                    // Primitive types cannot have properties
                    var primitive = formatPrimitive(ctx, value);
                    if (primitive) {
                        return primitive;
                    }
                    // Look up the keys of the object.
                    var keys = Object.keys(value);
                    var visibleKeys = arrayToHash(keys);
                    if (ctx.showHidden) {
                        keys = Object.getOwnPropertyNames(value);
                    }
                    // IE doesn't make error fields non-enumerable
                    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
                    if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
                        return formatError(value);
                    }
                    // Some type of object without properties can be shortcutted.
                    if (keys.length === 0) {
                        if (isFunction(value)) {
                            var name = value.name ? ': ' + value.name : '';
                            return ctx.stylize('[Function' + name + ']', 'special');
                        }
                        if (isRegExp(value)) {
                            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                        }
                        if (isDate(value)) {
                            return ctx.stylize(Date.prototype.toString.call(value), 'date');
                        }
                        if (isError(value)) {
                            return formatError(value);
                        }
                    }
                    var base = '', array = false, braces = [
                        '{',
                        '}'
                    ];
                    // Make Array say that they are Array
                    if (isArray(value)) {
                        array = true;
                        braces = [
                            '[',
                            ']'
                        ];
                    }
                    // Make functions say that they are functions
                    if (isFunction(value)) {
                        var n = value.name ? ': ' + value.name : '';
                        base = ' [Function' + n + ']';
                    }
                    // Make RegExps say that they are RegExps
                    if (isRegExp(value)) {
                        base = ' ' + RegExp.prototype.toString.call(value);
                    }
                    // Make dates with properties first say the date
                    if (isDate(value)) {
                        base = ' ' + Date.prototype.toUTCString.call(value);
                    }
                    // Make error with message first say the error
                    if (isError(value)) {
                        base = ' ' + formatError(value);
                    }
                    if (keys.length === 0 && (!array || value.length == 0)) {
                        return braces[0] + base + braces[1];
                    }
                    if (recurseTimes < 0) {
                        if (isRegExp(value)) {
                            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                        } else {
                            return ctx.stylize('[Object]', 'special');
                        }
                    }
                    ctx.seen.push(value);
                    var output;
                    if (array) {
                        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
                    } else {
                        output = keys.map(function(key) {
                            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                        });
                    }
                    ctx.seen.pop();
                    return reduceToSingleString(output, base, braces);
                }
                function formatPrimitive(ctx, value) {
                    if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
                    if (isString(value)) {
                        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
                        return ctx.stylize(simple, 'string');
                    }
                    if (isNumber(value)) return ctx.stylize('' + value, 'number');
                    if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
                    // For some reason typeof null is "object", so special case here.
                    if (isNull(value)) return ctx.stylize('null', 'null');
                }
                function formatError(value) {
                    return '[' + Error.prototype.toString.call(value) + ']';
                }
                function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                    var output = [];
                    for(var i = 0, l = value.length; i < l; ++i){
                        if (hasOwnProperty(value, String(i))) {
                            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
                        } else {
                            output.push('');
                        }
                    }
                    keys.forEach(function(key) {
                        if (!key.match(/^\d+$/)) {
                            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
                        }
                    });
                    return output;
                }
                function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                    var name, str, desc;
                    desc = Object.getOwnPropertyDescriptor(value, key) || {
                        value: value[key]
                    };
                    if (desc.get) {
                        if (desc.set) {
                            str = ctx.stylize('[Getter/Setter]', 'special');
                        } else {
                            str = ctx.stylize('[Getter]', 'special');
                        }
                    } else {
                        if (desc.set) {
                            str = ctx.stylize('[Setter]', 'special');
                        }
                    }
                    if (!hasOwnProperty(visibleKeys, key)) {
                        name = '[' + key + ']';
                    }
                    if (!str) {
                        if (ctx.seen.indexOf(desc.value) < 0) {
                            if (isNull(recurseTimes)) {
                                str = formatValue(ctx, desc.value, null);
                            } else {
                                str = formatValue(ctx, desc.value, recurseTimes - 1);
                            }
                            if (str.indexOf('\n') > -1) {
                                if (array) {
                                    str = str.split('\n').map(function(line) {
                                        return '  ' + line;
                                    }).join('\n').slice(2);
                                } else {
                                    str = '\n' + str.split('\n').map(function(line) {
                                        return '   ' + line;
                                    }).join('\n');
                                }
                            }
                        } else {
                            str = ctx.stylize('[Circular]', 'special');
                        }
                    }
                    if (isUndefined(name)) {
                        if (array && key.match(/^\d+$/)) {
                            return str;
                        }
                        name = JSON.stringify('' + key);
                        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                            name = name.slice(1, -1);
                            name = ctx.stylize(name, 'name');
                        } else {
                            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                            name = ctx.stylize(name, 'string');
                        }
                    }
                    return name + ': ' + str;
                }
                function reduceToSingleString(output, base, braces) {
                    var numLinesEst = 0;
                    var length = output.reduce(function(prev, cur) {
                        numLinesEst++;
                        if (cur.indexOf('\n') >= 0) numLinesEst++;
                        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
                    }, 0);
                    if (length > 60) {
                        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
                    }
                    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
                }
                // NOTE: These type checking functions intentionally don't use `instanceof`
                // because it is fragile and can be easily faked with `Object.create()`.
                exports1.types = __nested_webpack_require_209364__(4895);
                function isArray(ar) {
                    return Array.isArray(ar);
                }
                exports1.isArray = isArray;
                function isBoolean(arg) {
                    return typeof arg === 'boolean';
                }
                exports1.isBoolean = isBoolean;
                function isNull(arg) {
                    return arg === null;
                }
                exports1.isNull = isNull;
                function isNullOrUndefined(arg) {
                    return arg == null;
                }
                exports1.isNullOrUndefined = isNullOrUndefined;
                function isNumber(arg) {
                    return typeof arg === 'number';
                }
                exports1.isNumber = isNumber;
                function isString(arg) {
                    return typeof arg === 'string';
                }
                exports1.isString = isString;
                function isSymbol(arg) {
                    return typeof arg === 'symbol';
                }
                exports1.isSymbol = isSymbol;
                function isUndefined(arg) {
                    return arg === void 0;
                }
                exports1.isUndefined = isUndefined;
                function isRegExp(re) {
                    return isObject(re) && objectToString(re) === '[object RegExp]';
                }
                exports1.isRegExp = isRegExp;
                exports1.types.isRegExp = isRegExp;
                function isObject(arg) {
                    return typeof arg === 'object' && arg !== null;
                }
                exports1.isObject = isObject;
                function isDate(d) {
                    return isObject(d) && objectToString(d) === '[object Date]';
                }
                exports1.isDate = isDate;
                exports1.types.isDate = isDate;
                function isError(e) {
                    return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
                }
                exports1.isError = isError;
                exports1.types.isNativeError = isError;
                function isFunction(arg) {
                    return typeof arg === 'function';
                }
                exports1.isFunction = isFunction;
                function isPrimitive(arg) {
                    return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
                    typeof arg === 'undefined';
                }
                exports1.isPrimitive = isPrimitive;
                exports1.isBuffer = __nested_webpack_require_209364__(82);
                function objectToString(o) {
                    return Object.prototype.toString.call(o);
                }
                function pad(n) {
                    return n < 10 ? '0' + n.toString(10) : n.toString(10);
                }
                var months = [
                    'Jan',
                    'Feb',
                    'Mar',
                    'Apr',
                    'May',
                    'Jun',
                    'Jul',
                    'Aug',
                    'Sep',
                    'Oct',
                    'Nov',
                    'Dec'
                ];
                // 26 Feb 16:19:34
                function timestamp() {
                    var d = new Date();
                    var time = [
                        pad(d.getHours()),
                        pad(d.getMinutes()),
                        pad(d.getSeconds())
                    ].join(':');
                    return [
                        d.getDate(),
                        months[d.getMonth()],
                        time
                    ].join(' ');
                }
                // log is just a thin wrapper to console.log that prepends a timestamp
                exports1.log = function() {
                    console.log('%s - %s', timestamp(), exports1.format.apply(exports1, arguments));
                };
                /**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */ exports1.inherits = __nested_webpack_require_209364__(1285);
                exports1._extend = function(origin, add) {
                    // Don't do anything if add isn't an object
                    if (!add || !isObject(add)) return origin;
                    var keys = Object.keys(add);
                    var i = keys.length;
                    while(i--){
                        origin[keys[i]] = add[keys[i]];
                    }
                    return origin;
                };
                function hasOwnProperty(obj, prop) {
                    return Object.prototype.hasOwnProperty.call(obj, prop);
                }
                var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;
                exports1.promisify = function promisify(original) {
                    if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');
                    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
                        var fn = original[kCustomPromisifiedSymbol];
                        if (typeof fn !== 'function') {
                            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                        }
                        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                            value: fn,
                            enumerable: false,
                            writable: false,
                            configurable: true
                        });
                        return fn;
                    }
                    function fn() {
                        var promiseResolve, promiseReject;
                        var promise = new Promise(function(resolve, reject) {
                            promiseResolve = resolve;
                            promiseReject = reject;
                        });
                        var args = [];
                        for(var i = 0; i < arguments.length; i++){
                            args.push(arguments[i]);
                        }
                        args.push(function(err, value) {
                            if (err) {
                                promiseReject(err);
                            } else {
                                promiseResolve(value);
                            }
                        });
                        try {
                            original.apply(this, args);
                        } catch (err) {
                            promiseReject(err);
                        }
                        return promise;
                    }
                    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
                    if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                        value: fn,
                        enumerable: false,
                        writable: false,
                        configurable: true
                    });
                    return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
                };
                exports1.promisify.custom = kCustomPromisifiedSymbol;
                function callbackifyOnRejected(reason, cb) {
                    // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
                    // Because `null` is a special error value in callbacks which means "no error
                    // occurred", we error-wrap so the callback consumer can distinguish between
                    // "the promise rejected with null" or "the promise fulfilled with undefined".
                    if (!reason) {
                        var newReason = new Error('Promise was rejected with a falsy value');
                        newReason.reason = reason;
                        reason = newReason;
                    }
                    return cb(reason);
                }
                function callbackify(original) {
                    if (typeof original !== 'function') {
                        throw new TypeError('The "original" argument must be of type Function');
                    }
                    // We DO NOT return the promise as it gives the user a false sense that
                    // the promise is actually somehow related to the callback's execution
                    // and that the callback throwing will reject the promise.
                    function callbackified() {
                        var args = [];
                        for(var i = 0; i < arguments.length; i++){
                            args.push(arguments[i]);
                        }
                        var maybeCb = args.pop();
                        if (typeof maybeCb !== 'function') {
                            throw new TypeError('The last argument must be of type Function');
                        }
                        var self = this;
                        var cb = function() {
                            return maybeCb.apply(self, arguments);
                        };
                        // In true node style we process the callback on `nextTick` with all the
                        // implications (stack, `uncaughtException`, `async_hooks`)
                        original.apply(this, args).then(function(ret) {
                            process.nextTick(cb.bind(null, null, ret));
                        }, function(rej) {
                            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
                        });
                    }
                    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
                    Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
                    return callbackified;
                }
                exports1.callbackify = callbackify;
            /***/ },
            /***/ 1200: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_240960__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */ module1.exports = __nested_webpack_require_240960__(5953);
            /***/ },
            /***/ 5953: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_241519__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createMessageConnection = exports1.BrowserMessageWriter = exports1.BrowserMessageReader = void 0;
                const ril_1 = __nested_webpack_require_241519__(3632);
                // Install the browser runtime abstract.
                ril_1.default.install();
                const api_1 = __nested_webpack_require_241519__(5247);
                __exportStar(__nested_webpack_require_241519__(5247), exports1);
                class BrowserMessageReader extends api_1.AbstractMessageReader {
                    listen(callback) {
                        return this._onData.event(callback);
                    }
                    constructor(port){
                        super();
                        this._onData = new api_1.Emitter();
                        this._messageListener = (event)=>{
                            this._onData.fire(event.data);
                        };
                        port.addEventListener('error', (event)=>this.fireError(event));
                        port.onmessage = this._messageListener;
                    }
                }
                exports1.BrowserMessageReader = BrowserMessageReader;
                class BrowserMessageWriter extends api_1.AbstractMessageWriter {
                    write(msg) {
                        try {
                            this.port.postMessage(msg);
                            return Promise.resolve();
                        } catch (error) {
                            this.handleError(error, msg);
                            return Promise.reject(error);
                        }
                    }
                    handleError(error, msg) {
                        this.errorCount++;
                        this.fireError(error, msg, this.errorCount);
                    }
                    end() {}
                    constructor(port){
                        super();
                        this.port = port;
                        this.errorCount = 0;
                        port.addEventListener('error', (event)=>this.fireError(event));
                    }
                }
                exports1.BrowserMessageWriter = BrowserMessageWriter;
                function createMessageConnection(reader, writer, logger, options) {
                    if (logger === undefined) {
                        logger = api_1.NullLogger;
                    }
                    if (api_1.ConnectionStrategy.is(options)) {
                        options = {
                            connectionStrategy: options
                        };
                    }
                    return (0, api_1.createMessageConnection)(reader, writer, logger, options);
                }
                exports1.createMessageConnection = createMessageConnection;
            /***/ },
            /***/ 3632: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_245934__)=>{
                "use strict";
                /* provided dependency */ var console = __nested_webpack_require_245934__(3716);
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                const api_1 = __nested_webpack_require_245934__(5247);
                class MessageBuffer extends api_1.AbstractMessageBuffer {
                    emptyBuffer() {
                        return MessageBuffer.emptyBuffer;
                    }
                    fromString(value, _encoding) {
                        return new TextEncoder().encode(value);
                    }
                    toString(value, encoding) {
                        if (encoding === 'ascii') {
                            return this.asciiDecoder.decode(value);
                        } else {
                            return new TextDecoder(encoding).decode(value);
                        }
                    }
                    asNative(buffer, length) {
                        if (length === undefined) {
                            return buffer;
                        } else {
                            return buffer.slice(0, length);
                        }
                    }
                    allocNative(length) {
                        return new Uint8Array(length);
                    }
                    constructor(encoding = 'utf-8'){
                        super(encoding);
                        this.asciiDecoder = new TextDecoder('ascii');
                    }
                }
                MessageBuffer.emptyBuffer = new Uint8Array(0);
                class ReadableStreamWrapper {
                    onClose(listener) {
                        this.socket.addEventListener('close', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('close', listener));
                    }
                    onError(listener) {
                        this.socket.addEventListener('error', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('error', listener));
                    }
                    onEnd(listener) {
                        this.socket.addEventListener('end', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('end', listener));
                    }
                    onData(listener) {
                        return this._onData.event(listener);
                    }
                    constructor(socket){
                        this.socket = socket;
                        this._onData = new api_1.Emitter();
                        this._messageListener = (event)=>{
                            const blob = event.data;
                            blob.arrayBuffer().then((buffer)=>{
                                this._onData.fire(new Uint8Array(buffer));
                            }, ()=>{
                                (0, api_1.RAL)().console.error(`Converting blob to array buffer failed.`);
                            });
                        };
                        this.socket.addEventListener('message', this._messageListener);
                    }
                }
                class WritableStreamWrapper {
                    onClose(listener) {
                        this.socket.addEventListener('close', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('close', listener));
                    }
                    onError(listener) {
                        this.socket.addEventListener('error', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('error', listener));
                    }
                    onEnd(listener) {
                        this.socket.addEventListener('end', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('end', listener));
                    }
                    write(data, encoding) {
                        if (typeof data === 'string') {
                            if (encoding !== undefined && encoding !== 'utf-8') {
                                throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);
                            }
                            this.socket.send(data);
                        } else {
                            this.socket.send(data);
                        }
                        return Promise.resolve();
                    }
                    end() {
                        this.socket.close();
                    }
                    constructor(socket){
                        this.socket = socket;
                    }
                }
                const _textEncoder = new TextEncoder();
                const _ril = Object.freeze({
                    messageBuffer: Object.freeze({
                        create: (encoding)=>new MessageBuffer(encoding)
                    }),
                    applicationJson: Object.freeze({
                        encoder: Object.freeze({
                            name: 'application/json',
                            encode: (msg, options)=>{
                                if (options.charset !== 'utf-8') {
                                    throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);
                                }
                                return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, undefined, 0)));
                            }
                        }),
                        decoder: Object.freeze({
                            name: 'application/json',
                            decode: (buffer, options)=>{
                                if (!(buffer instanceof Uint8Array)) {
                                    throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
                                }
                                return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
                            }
                        })
                    }),
                    stream: Object.freeze({
                        asReadableStream: (socket)=>new ReadableStreamWrapper(socket),
                        asWritableStream: (socket)=>new WritableStreamWrapper(socket)
                    }),
                    console: console,
                    timer: Object.freeze({
                        setTimeout (callback, ms, ...args) {
                            const handle = setTimeout(callback, ms, ...args);
                            return {
                                dispose: ()=>clearTimeout(handle)
                            };
                        },
                        setImmediate (callback, ...args) {
                            const handle = setTimeout(callback, 0, ...args);
                            return {
                                dispose: ()=>clearTimeout(handle)
                            };
                        },
                        setInterval (callback, ms, ...args) {
                            const handle = setInterval(callback, ms, ...args);
                            return {
                                dispose: ()=>clearInterval(handle)
                            };
                        }
                    })
                });
                function RIL() {
                    return _ril;
                }
                (function(RIL) {
                    function install() {
                        api_1.RAL.install(_ril);
                    }
                    RIL.install = install;
                })(RIL || (RIL = {}));
                exports1["default"] = RIL;
            /***/ },
            /***/ 5247: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_254313__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ /// <reference path="../../typings/thenable.d.ts" />
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ProgressType = exports1.ProgressToken = exports1.createMessageConnection = exports1.NullLogger = exports1.ConnectionOptions = exports1.ConnectionStrategy = exports1.AbstractMessageBuffer = exports1.WriteableStreamMessageWriter = exports1.AbstractMessageWriter = exports1.MessageWriter = exports1.ReadableStreamMessageReader = exports1.AbstractMessageReader = exports1.MessageReader = exports1.SharedArrayReceiverStrategy = exports1.SharedArraySenderStrategy = exports1.CancellationToken = exports1.CancellationTokenSource = exports1.Emitter = exports1.Event = exports1.Disposable = exports1.LRUCache = exports1.Touch = exports1.LinkedMap = exports1.ParameterStructures = exports1.NotificationType9 = exports1.NotificationType8 = exports1.NotificationType7 = exports1.NotificationType6 = exports1.NotificationType5 = exports1.NotificationType4 = exports1.NotificationType3 = exports1.NotificationType2 = exports1.NotificationType1 = exports1.NotificationType0 = exports1.NotificationType = exports1.ErrorCodes = exports1.ResponseError = exports1.RequestType9 = exports1.RequestType8 = exports1.RequestType7 = exports1.RequestType6 = exports1.RequestType5 = exports1.RequestType4 = exports1.RequestType3 = exports1.RequestType2 = exports1.RequestType1 = exports1.RequestType0 = exports1.RequestType = exports1.Message = exports1.RAL = void 0;
                exports1.MessageStrategy = exports1.CancellationStrategy = exports1.CancellationSenderStrategy = exports1.CancellationReceiverStrategy = exports1.ConnectionError = exports1.ConnectionErrors = exports1.LogTraceNotification = exports1.SetTraceNotification = exports1.TraceFormat = exports1.TraceValues = exports1.Trace = void 0;
                const messages_1 = __nested_webpack_require_254313__(9141);
                Object.defineProperty(exports1, "Message", {
                    enumerable: true,
                    get: function() {
                        return messages_1.Message;
                    }
                });
                Object.defineProperty(exports1, "RequestType", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType;
                    }
                });
                Object.defineProperty(exports1, "RequestType0", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType0;
                    }
                });
                Object.defineProperty(exports1, "RequestType1", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType1;
                    }
                });
                Object.defineProperty(exports1, "RequestType2", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType2;
                    }
                });
                Object.defineProperty(exports1, "RequestType3", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType3;
                    }
                });
                Object.defineProperty(exports1, "RequestType4", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType4;
                    }
                });
                Object.defineProperty(exports1, "RequestType5", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType5;
                    }
                });
                Object.defineProperty(exports1, "RequestType6", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType6;
                    }
                });
                Object.defineProperty(exports1, "RequestType7", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType7;
                    }
                });
                Object.defineProperty(exports1, "RequestType8", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType8;
                    }
                });
                Object.defineProperty(exports1, "RequestType9", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType9;
                    }
                });
                Object.defineProperty(exports1, "ResponseError", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ResponseError;
                    }
                });
                Object.defineProperty(exports1, "ErrorCodes", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ErrorCodes;
                    }
                });
                Object.defineProperty(exports1, "NotificationType", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType;
                    }
                });
                Object.defineProperty(exports1, "NotificationType0", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType0;
                    }
                });
                Object.defineProperty(exports1, "NotificationType1", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType1;
                    }
                });
                Object.defineProperty(exports1, "NotificationType2", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType2;
                    }
                });
                Object.defineProperty(exports1, "NotificationType3", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType3;
                    }
                });
                Object.defineProperty(exports1, "NotificationType4", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType4;
                    }
                });
                Object.defineProperty(exports1, "NotificationType5", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType5;
                    }
                });
                Object.defineProperty(exports1, "NotificationType6", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType6;
                    }
                });
                Object.defineProperty(exports1, "NotificationType7", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType7;
                    }
                });
                Object.defineProperty(exports1, "NotificationType8", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType8;
                    }
                });
                Object.defineProperty(exports1, "NotificationType9", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType9;
                    }
                });
                Object.defineProperty(exports1, "ParameterStructures", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ParameterStructures;
                    }
                });
                const linkedMap_1 = __nested_webpack_require_254313__(7040);
                Object.defineProperty(exports1, "LinkedMap", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.LinkedMap;
                    }
                });
                Object.defineProperty(exports1, "LRUCache", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.LRUCache;
                    }
                });
                Object.defineProperty(exports1, "Touch", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.Touch;
                    }
                });
                const disposable_1 = __nested_webpack_require_254313__(8437);
                Object.defineProperty(exports1, "Disposable", {
                    enumerable: true,
                    get: function() {
                        return disposable_1.Disposable;
                    }
                });
                const events_1 = __nested_webpack_require_254313__(5165);
                Object.defineProperty(exports1, "Event", {
                    enumerable: true,
                    get: function() {
                        return events_1.Event;
                    }
                });
                Object.defineProperty(exports1, "Emitter", {
                    enumerable: true,
                    get: function() {
                        return events_1.Emitter;
                    }
                });
                const cancellation_1 = __nested_webpack_require_254313__(415);
                Object.defineProperty(exports1, "CancellationTokenSource", {
                    enumerable: true,
                    get: function() {
                        return cancellation_1.CancellationTokenSource;
                    }
                });
                Object.defineProperty(exports1, "CancellationToken", {
                    enumerable: true,
                    get: function() {
                        return cancellation_1.CancellationToken;
                    }
                });
                const sharedArrayCancellation_1 = __nested_webpack_require_254313__(178);
                Object.defineProperty(exports1, "SharedArraySenderStrategy", {
                    enumerable: true,
                    get: function() {
                        return sharedArrayCancellation_1.SharedArraySenderStrategy;
                    }
                });
                Object.defineProperty(exports1, "SharedArrayReceiverStrategy", {
                    enumerable: true,
                    get: function() {
                        return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
                    }
                });
                const messageReader_1 = __nested_webpack_require_254313__(451);
                Object.defineProperty(exports1, "MessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.MessageReader;
                    }
                });
                Object.defineProperty(exports1, "AbstractMessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.AbstractMessageReader;
                    }
                });
                Object.defineProperty(exports1, "ReadableStreamMessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.ReadableStreamMessageReader;
                    }
                });
                const messageWriter_1 = __nested_webpack_require_254313__(1251);
                Object.defineProperty(exports1, "MessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.MessageWriter;
                    }
                });
                Object.defineProperty(exports1, "AbstractMessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.AbstractMessageWriter;
                    }
                });
                Object.defineProperty(exports1, "WriteableStreamMessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.WriteableStreamMessageWriter;
                    }
                });
                const messageBuffer_1 = __nested_webpack_require_254313__(8652);
                Object.defineProperty(exports1, "AbstractMessageBuffer", {
                    enumerable: true,
                    get: function() {
                        return messageBuffer_1.AbstractMessageBuffer;
                    }
                });
                const connection_1 = __nested_webpack_require_254313__(1908);
                Object.defineProperty(exports1, "ConnectionStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionStrategy;
                    }
                });
                Object.defineProperty(exports1, "ConnectionOptions", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionOptions;
                    }
                });
                Object.defineProperty(exports1, "NullLogger", {
                    enumerable: true,
                    get: function() {
                        return connection_1.NullLogger;
                    }
                });
                Object.defineProperty(exports1, "createMessageConnection", {
                    enumerable: true,
                    get: function() {
                        return connection_1.createMessageConnection;
                    }
                });
                Object.defineProperty(exports1, "ProgressToken", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ProgressToken;
                    }
                });
                Object.defineProperty(exports1, "ProgressType", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ProgressType;
                    }
                });
                Object.defineProperty(exports1, "Trace", {
                    enumerable: true,
                    get: function() {
                        return connection_1.Trace;
                    }
                });
                Object.defineProperty(exports1, "TraceValues", {
                    enumerable: true,
                    get: function() {
                        return connection_1.TraceValues;
                    }
                });
                Object.defineProperty(exports1, "TraceFormat", {
                    enumerable: true,
                    get: function() {
                        return connection_1.TraceFormat;
                    }
                });
                Object.defineProperty(exports1, "SetTraceNotification", {
                    enumerable: true,
                    get: function() {
                        return connection_1.SetTraceNotification;
                    }
                });
                Object.defineProperty(exports1, "LogTraceNotification", {
                    enumerable: true,
                    get: function() {
                        return connection_1.LogTraceNotification;
                    }
                });
                Object.defineProperty(exports1, "ConnectionErrors", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionErrors;
                    }
                });
                Object.defineProperty(exports1, "ConnectionError", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionError;
                    }
                });
                Object.defineProperty(exports1, "CancellationReceiverStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationReceiverStrategy;
                    }
                });
                Object.defineProperty(exports1, "CancellationSenderStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationSenderStrategy;
                    }
                });
                Object.defineProperty(exports1, "CancellationStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationStrategy;
                    }
                });
                Object.defineProperty(exports1, "MessageStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.MessageStrategy;
                    }
                });
                const ral_1 = __nested_webpack_require_254313__(5706);
                exports1.RAL = ral_1.default;
            /***/ },
            /***/ 415: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_272374__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.CancellationTokenSource = exports1.CancellationToken = void 0;
                const ral_1 = __nested_webpack_require_272374__(5706);
                const Is = __nested_webpack_require_272374__(8811);
                const events_1 = __nested_webpack_require_272374__(5165);
                var CancellationToken;
                (function(CancellationToken) {
                    CancellationToken.None = Object.freeze({
                        isCancellationRequested: false,
                        onCancellationRequested: events_1.Event.None
                    });
                    CancellationToken.Cancelled = Object.freeze({
                        isCancellationRequested: true,
                        onCancellationRequested: events_1.Event.None
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate === CancellationToken.None || candidate === CancellationToken.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
                    }
                    CancellationToken.is = is;
                })(CancellationToken = exports1.CancellationToken || (exports1.CancellationToken = {}));
                const shortcutEvent = Object.freeze(function(callback, context) {
                    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
                    return {
                        dispose () {
                            handle.dispose();
                        }
                    };
                });
                class MutableToken {
                    cancel() {
                        if (!this._isCancelled) {
                            this._isCancelled = true;
                            if (this._emitter) {
                                this._emitter.fire(undefined);
                                this.dispose();
                            }
                        }
                    }
                    get isCancellationRequested() {
                        return this._isCancelled;
                    }
                    get onCancellationRequested() {
                        if (this._isCancelled) {
                            return shortcutEvent;
                        }
                        if (!this._emitter) {
                            this._emitter = new events_1.Emitter();
                        }
                        return this._emitter.event;
                    }
                    dispose() {
                        if (this._emitter) {
                            this._emitter.dispose();
                            this._emitter = undefined;
                        }
                    }
                    constructor(){
                        this._isCancelled = false;
                    }
                }
                class CancellationTokenSource {
                    get token() {
                        if (!this._token) {
                            // be lazy and create the token only when
                            // actually needed
                            this._token = new MutableToken();
                        }
                        return this._token;
                    }
                    cancel() {
                        if (!this._token) {
                            // save an object by returning the default
                            // cancelled token when cancellation happens
                            // before someone asks for the token
                            this._token = CancellationToken.Cancelled;
                        } else {
                            this._token.cancel();
                        }
                    }
                    dispose() {
                        if (!this._token) {
                            // ensure to initialize with an empty token if we had none
                            this._token = CancellationToken.None;
                        } else if (this._token instanceof MutableToken) {
                            // actually dispose
                            this._token.dispose();
                        }
                    }
                }
                exports1.CancellationTokenSource = CancellationTokenSource;
            /***/ },
            /***/ 1908: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_277308__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createMessageConnection = exports1.ConnectionOptions = exports1.MessageStrategy = exports1.CancellationStrategy = exports1.CancellationSenderStrategy = exports1.CancellationReceiverStrategy = exports1.RequestCancellationReceiverStrategy = exports1.IdCancellationReceiverStrategy = exports1.ConnectionStrategy = exports1.ConnectionError = exports1.ConnectionErrors = exports1.LogTraceNotification = exports1.SetTraceNotification = exports1.TraceFormat = exports1.TraceValues = exports1.Trace = exports1.NullLogger = exports1.ProgressType = exports1.ProgressToken = void 0;
                const ral_1 = __nested_webpack_require_277308__(5706);
                const Is = __nested_webpack_require_277308__(8811);
                const messages_1 = __nested_webpack_require_277308__(9141);
                const linkedMap_1 = __nested_webpack_require_277308__(7040);
                const events_1 = __nested_webpack_require_277308__(5165);
                const cancellation_1 = __nested_webpack_require_277308__(415);
                var CancelNotification;
                (function(CancelNotification) {
                    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
                })(CancelNotification || (CancelNotification = {}));
                var ProgressToken;
                (function(ProgressToken) {
                    function is(value) {
                        return typeof value === 'string' || typeof value === 'number';
                    }
                    ProgressToken.is = is;
                })(ProgressToken = exports1.ProgressToken || (exports1.ProgressToken = {}));
                var ProgressNotification;
                (function(ProgressNotification) {
                    ProgressNotification.type = new messages_1.NotificationType('$/progress');
                })(ProgressNotification || (ProgressNotification = {}));
                class ProgressType {
                    constructor(){}
                }
                exports1.ProgressType = ProgressType;
                var StarRequestHandler;
                (function(StarRequestHandler) {
                    function is(value) {
                        return Is.func(value);
                    }
                    StarRequestHandler.is = is;
                })(StarRequestHandler || (StarRequestHandler = {}));
                exports1.NullLogger = Object.freeze({
                    error: ()=>{},
                    warn: ()=>{},
                    info: ()=>{},
                    log: ()=>{}
                });
                var Trace;
                (function(Trace) {
                    Trace[Trace["Off"] = 0] = "Off";
                    Trace[Trace["Messages"] = 1] = "Messages";
                    Trace[Trace["Compact"] = 2] = "Compact";
                    Trace[Trace["Verbose"] = 3] = "Verbose";
                })(Trace = exports1.Trace || (exports1.Trace = {}));
                var TraceValues;
                (function(TraceValues) {
                    /**
     * Turn tracing off.
     */ TraceValues.Off = 'off';
                    /**
     * Trace messages only.
     */ TraceValues.Messages = 'messages';
                    /**
     * Compact message tracing.
     */ TraceValues.Compact = 'compact';
                    /**
     * Verbose message tracing.
     */ TraceValues.Verbose = 'verbose';
                })(TraceValues = exports1.TraceValues || (exports1.TraceValues = {}));
                (function(Trace) {
                    function fromString(value) {
                        if (!Is.string(value)) {
                            return Trace.Off;
                        }
                        value = value.toLowerCase();
                        switch(value){
                            case 'off':
                                return Trace.Off;
                            case 'messages':
                                return Trace.Messages;
                            case 'compact':
                                return Trace.Compact;
                            case 'verbose':
                                return Trace.Verbose;
                            default:
                                return Trace.Off;
                        }
                    }
                    Trace.fromString = fromString;
                    function toString(value) {
                        switch(value){
                            case Trace.Off:
                                return 'off';
                            case Trace.Messages:
                                return 'messages';
                            case Trace.Compact:
                                return 'compact';
                            case Trace.Verbose:
                                return 'verbose';
                            default:
                                return 'off';
                        }
                    }
                    Trace.toString = toString;
                })(Trace = exports1.Trace || (exports1.Trace = {}));
                var TraceFormat;
                (function(TraceFormat) {
                    TraceFormat["Text"] = "text";
                    TraceFormat["JSON"] = "json";
                })(TraceFormat = exports1.TraceFormat || (exports1.TraceFormat = {}));
                (function(TraceFormat) {
                    function fromString(value) {
                        if (!Is.string(value)) {
                            return TraceFormat.Text;
                        }
                        value = value.toLowerCase();
                        if (value === 'json') {
                            return TraceFormat.JSON;
                        } else {
                            return TraceFormat.Text;
                        }
                    }
                    TraceFormat.fromString = fromString;
                })(TraceFormat = exports1.TraceFormat || (exports1.TraceFormat = {}));
                var SetTraceNotification;
                (function(SetTraceNotification) {
                    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');
                })(SetTraceNotification = exports1.SetTraceNotification || (exports1.SetTraceNotification = {}));
                var LogTraceNotification;
                (function(LogTraceNotification) {
                    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');
                })(LogTraceNotification = exports1.LogTraceNotification || (exports1.LogTraceNotification = {}));
                var ConnectionErrors;
                (function(ConnectionErrors) {
                    /**
     * The connection is closed.
     */ ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
                    /**
     * The connection got disposed.
     */ ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
                    /**
     * The connection is already in listening mode.
     */ ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
                })(ConnectionErrors = exports1.ConnectionErrors || (exports1.ConnectionErrors = {}));
                class ConnectionError extends Error {
                    constructor(code, message){
                        super(message);
                        this.code = code;
                        Object.setPrototypeOf(this, ConnectionError.prototype);
                    }
                }
                exports1.ConnectionError = ConnectionError;
                var ConnectionStrategy;
                (function(ConnectionStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.cancelUndispatched);
                    }
                    ConnectionStrategy.is = is;
                })(ConnectionStrategy = exports1.ConnectionStrategy || (exports1.ConnectionStrategy = {}));
                var IdCancellationReceiverStrategy;
                (function(IdCancellationReceiverStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate.kind === undefined || candidate.kind === 'id') && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
                    }
                    IdCancellationReceiverStrategy.is = is;
                })(IdCancellationReceiverStrategy = exports1.IdCancellationReceiverStrategy || (exports1.IdCancellationReceiverStrategy = {}));
                var RequestCancellationReceiverStrategy;
                (function(RequestCancellationReceiverStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && candidate.kind === 'request' && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
                    }
                    RequestCancellationReceiverStrategy.is = is;
                })(RequestCancellationReceiverStrategy = exports1.RequestCancellationReceiverStrategy || (exports1.RequestCancellationReceiverStrategy = {}));
                var CancellationReceiverStrategy;
                (function(CancellationReceiverStrategy) {
                    CancellationReceiverStrategy.Message = Object.freeze({
                        createCancellationTokenSource (_) {
                            return new cancellation_1.CancellationTokenSource();
                        }
                    });
                    function is(value) {
                        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
                    }
                    CancellationReceiverStrategy.is = is;
                })(CancellationReceiverStrategy = exports1.CancellationReceiverStrategy || (exports1.CancellationReceiverStrategy = {}));
                var CancellationSenderStrategy;
                (function(CancellationSenderStrategy) {
                    CancellationSenderStrategy.Message = Object.freeze({
                        sendCancellation (conn, id) {
                            return conn.sendNotification(CancelNotification.type, {
                                id
                            });
                        },
                        cleanup (_) {}
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
                    }
                    CancellationSenderStrategy.is = is;
                })(CancellationSenderStrategy = exports1.CancellationSenderStrategy || (exports1.CancellationSenderStrategy = {}));
                var CancellationStrategy;
                (function(CancellationStrategy) {
                    CancellationStrategy.Message = Object.freeze({
                        receiver: CancellationReceiverStrategy.Message,
                        sender: CancellationSenderStrategy.Message
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
                    }
                    CancellationStrategy.is = is;
                })(CancellationStrategy = exports1.CancellationStrategy || (exports1.CancellationStrategy = {}));
                var MessageStrategy;
                (function(MessageStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.handleMessage);
                    }
                    MessageStrategy.is = is;
                })(MessageStrategy = exports1.MessageStrategy || (exports1.MessageStrategy = {}));
                var ConnectionOptions;
                (function(ConnectionOptions) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
                    }
                    ConnectionOptions.is = is;
                })(ConnectionOptions = exports1.ConnectionOptions || (exports1.ConnectionOptions = {}));
                var ConnectionState;
                (function(ConnectionState) {
                    ConnectionState[ConnectionState["New"] = 1] = "New";
                    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
                    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
                    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
                })(ConnectionState || (ConnectionState = {}));
                function createMessageConnection(messageReader, messageWriter, _logger, options) {
                    const logger = _logger !== undefined ? _logger : exports1.NullLogger;
                    let sequenceNumber = 0;
                    let notificationSequenceNumber = 0;
                    let unknownResponseSequenceNumber = 0;
                    const version = '2.0';
                    let starRequestHandler = undefined;
                    const requestHandlers = new Map();
                    let starNotificationHandler = undefined;
                    const notificationHandlers = new Map();
                    const progressHandlers = new Map();
                    let timer;
                    let messageQueue = new linkedMap_1.LinkedMap();
                    let responsePromises = new Map();
                    let knownCanceledRequests = new Set();
                    let requestTokens = new Map();
                    let trace = Trace.Off;
                    let traceFormat = TraceFormat.Text;
                    let tracer;
                    let state = ConnectionState.New;
                    const errorEmitter = new events_1.Emitter();
                    const closeEmitter = new events_1.Emitter();
                    const unhandledNotificationEmitter = new events_1.Emitter();
                    const unhandledProgressEmitter = new events_1.Emitter();
                    const disposeEmitter = new events_1.Emitter();
                    const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
                    function createRequestQueueKey(id) {
                        if (id === null) {
                            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
                        }
                        return 'req-' + id.toString();
                    }
                    function createResponseQueueKey(id) {
                        if (id === null) {
                            return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();
                        } else {
                            return 'res-' + id.toString();
                        }
                    }
                    function createNotificationQueueKey() {
                        return 'not-' + (++notificationSequenceNumber).toString();
                    }
                    function addMessageToQueue(queue, message) {
                        if (messages_1.Message.isRequest(message)) {
                            queue.set(createRequestQueueKey(message.id), message);
                        } else if (messages_1.Message.isResponse(message)) {
                            queue.set(createResponseQueueKey(message.id), message);
                        } else {
                            queue.set(createNotificationQueueKey(), message);
                        }
                    }
                    function cancelUndispatched(_message) {
                        return undefined;
                    }
                    function isListening() {
                        return state === ConnectionState.Listening;
                    }
                    function isClosed() {
                        return state === ConnectionState.Closed;
                    }
                    function isDisposed() {
                        return state === ConnectionState.Disposed;
                    }
                    function closeHandler() {
                        if (state === ConnectionState.New || state === ConnectionState.Listening) {
                            state = ConnectionState.Closed;
                            closeEmitter.fire(undefined);
                        }
                    // If the connection is disposed don't sent close events.
                    }
                    function readErrorHandler(error) {
                        errorEmitter.fire([
                            error,
                            undefined,
                            undefined
                        ]);
                    }
                    function writeErrorHandler(data) {
                        errorEmitter.fire(data);
                    }
                    messageReader.onClose(closeHandler);
                    messageReader.onError(readErrorHandler);
                    messageWriter.onClose(closeHandler);
                    messageWriter.onError(writeErrorHandler);
                    function triggerMessageQueue() {
                        if (timer || messageQueue.size === 0) {
                            return;
                        }
                        timer = (0, ral_1.default)().timer.setImmediate(()=>{
                            timer = undefined;
                            processMessageQueue();
                        });
                    }
                    function handleMessage(message) {
                        if (messages_1.Message.isRequest(message)) {
                            handleRequest(message);
                        } else if (messages_1.Message.isNotification(message)) {
                            handleNotification(message);
                        } else if (messages_1.Message.isResponse(message)) {
                            handleResponse(message);
                        } else {
                            handleInvalidMessage(message);
                        }
                    }
                    function processMessageQueue() {
                        if (messageQueue.size === 0) {
                            return;
                        }
                        const message = messageQueue.shift();
                        try {
                            var _options;
                            const messageStrategy = (_options = options) === null || _options === void 0 ? void 0 : _options.messageStrategy;
                            if (MessageStrategy.is(messageStrategy)) {
                                messageStrategy.handleMessage(message, handleMessage);
                            } else {
                                handleMessage(message);
                            }
                        } finally{
                            triggerMessageQueue();
                        }
                    }
                    const callback = (message)=>{
                        try {
                            // We have received a cancellation message. Check if the message is still in the queue
                            // and cancel it if allowed to do so.
                            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
                                const cancelId = message.params.id;
                                const key = createRequestQueueKey(cancelId);
                                const toCancel = messageQueue.get(key);
                                if (messages_1.Message.isRequest(toCancel)) {
                                    var _options;
                                    const strategy = (_options = options) === null || _options === void 0 ? void 0 : _options.connectionStrategy;
                                    const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                                    if (response && (response.error !== undefined || response.result !== undefined)) {
                                        messageQueue.delete(key);
                                        requestTokens.delete(cancelId);
                                        response.id = toCancel.id;
                                        traceSendingResponse(response, message.method, Date.now());
                                        messageWriter.write(response).catch(()=>logger.error(`Sending response for canceled message failed.`));
                                        return;
                                    }
                                }
                                const cancellationToken = requestTokens.get(cancelId);
                                // The request is already running. Cancel the token
                                if (cancellationToken !== undefined) {
                                    cancellationToken.cancel();
                                    traceReceivedNotification(message);
                                    return;
                                } else {
                                    // Remember the cancel but still queue the message to
                                    // clean up state in process message.
                                    knownCanceledRequests.add(cancelId);
                                }
                            }
                            addMessageToQueue(messageQueue, message);
                        } finally{
                            triggerMessageQueue();
                        }
                    };
                    function handleRequest(requestMessage) {
                        if (isDisposed()) {
                            // we return here silently since we fired an event when the
                            // connection got disposed.
                            return;
                        }
                        function reply(resultOrError, method, startTime) {
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id
                            };
                            if (resultOrError instanceof messages_1.ResponseError) {
                                message.error = resultOrError.toJson();
                            } else {
                                message.result = resultOrError === undefined ? null : resultOrError;
                            }
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        function replyError(error, method, startTime) {
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id,
                                error: error.toJson()
                            };
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        function replySuccess(result, method, startTime) {
                            // The JSON RPC defines that a response must either have a result or an error
                            // So we can't treat undefined as a valid response result.
                            if (result === undefined) {
                                result = null;
                            }
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id,
                                result: result
                            };
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        traceReceivedRequest(requestMessage);
                        const element = requestHandlers.get(requestMessage.method);
                        let type;
                        let requestHandler;
                        if (element) {
                            type = element.type;
                            requestHandler = element.handler;
                        }
                        const startTime = Date.now();
                        if (requestHandler || starRequestHandler) {
                            var _requestMessage_id;
                            const tokenKey = (_requestMessage_id = requestMessage.id) !== null && _requestMessage_id !== void 0 ? _requestMessage_id : String(Date.now()); //
                            const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
                            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
                                cancellationSource.cancel();
                            }
                            if (requestMessage.id !== null) {
                                requestTokens.set(tokenKey, cancellationSource);
                            }
                            try {
                                let handlerResult;
                                if (requestHandler) {
                                    if (requestMessage.params === undefined) {
                                        if (type !== undefined && type.numberOfParams !== 0) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(cancellationSource.token);
                                    } else if (Array.isArray(requestMessage.params)) {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                                    } else {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                                    }
                                } else if (starRequestHandler) {
                                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                                }
                                const promise = handlerResult;
                                if (!handlerResult) {
                                    requestTokens.delete(tokenKey);
                                    replySuccess(handlerResult, requestMessage.method, startTime);
                                } else if (promise.then) {
                                    promise.then((resultOrError)=>{
                                        requestTokens.delete(tokenKey);
                                        reply(resultOrError, requestMessage.method, startTime);
                                    }, (error)=>{
                                        requestTokens.delete(tokenKey);
                                        if (error instanceof messages_1.ResponseError) {
                                            replyError(error, requestMessage.method, startTime);
                                        } else if (error && Is.string(error.message)) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                                        } else {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                                        }
                                    });
                                } else {
                                    requestTokens.delete(tokenKey);
                                    reply(handlerResult, requestMessage.method, startTime);
                                }
                            } catch (error) {
                                requestTokens.delete(tokenKey);
                                if (error instanceof messages_1.ResponseError) {
                                    reply(error, requestMessage.method, startTime);
                                } else if (error && Is.string(error.message)) {
                                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                                } else {
                                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                                }
                            }
                        } else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
                        }
                    }
                    function handleResponse(responseMessage) {
                        if (isDisposed()) {
                            // See handle request.
                            return;
                        }
                        if (responseMessage.id === null) {
                            if (responseMessage.error) {
                                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
                            } else {
                                logger.error(`Received response message without id. No further error information provided.`);
                            }
                        } else {
                            const key = responseMessage.id;
                            const responsePromise = responsePromises.get(key);
                            traceReceivedResponse(responseMessage, responsePromise);
                            if (responsePromise !== undefined) {
                                responsePromises.delete(key);
                                try {
                                    if (responseMessage.error) {
                                        const error = responseMessage.error;
                                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                                    } else if (responseMessage.result !== undefined) {
                                        responsePromise.resolve(responseMessage.result);
                                    } else {
                                        throw new Error('Should never happen.');
                                    }
                                } catch (error) {
                                    if (error.message) {
                                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                                    } else {
                                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                                    }
                                }
                            }
                        }
                    }
                    function handleNotification(message) {
                        if (isDisposed()) {
                            // See handle request.
                            return;
                        }
                        let type = undefined;
                        let notificationHandler;
                        if (message.method === CancelNotification.type.method) {
                            const cancelId = message.params.id;
                            knownCanceledRequests.delete(cancelId);
                            traceReceivedNotification(message);
                            return;
                        } else {
                            const element = notificationHandlers.get(message.method);
                            if (element) {
                                notificationHandler = element.handler;
                                type = element.type;
                            }
                        }
                        if (notificationHandler || starNotificationHandler) {
                            try {
                                traceReceivedNotification(message);
                                if (notificationHandler) {
                                    if (message.params === undefined) {
                                        if (type !== undefined) {
                                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                                            }
                                        }
                                        notificationHandler();
                                    } else if (Array.isArray(message.params)) {
                                        // There are JSON-RPC libraries that send progress message as positional params although
                                        // specified as named. So convert them if this is the case.
                                        const params = message.params;
                                        if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                                            notificationHandler({
                                                token: params[0],
                                                value: params[1]
                                            });
                                        } else {
                                            if (type !== undefined) {
                                                if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                                                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                                                }
                                                if (type.numberOfParams !== message.params.length) {
                                                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                                                }
                                            }
                                            notificationHandler(...params);
                                        }
                                    } else {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                                        }
                                        notificationHandler(message.params);
                                    }
                                } else if (starNotificationHandler) {
                                    starNotificationHandler(message.method, message.params);
                                }
                            } catch (error) {
                                if (error.message) {
                                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
                                } else {
                                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
                                }
                            }
                        } else {
                            unhandledNotificationEmitter.fire(message);
                        }
                    }
                    function handleInvalidMessage(message) {
                        if (!message) {
                            logger.error('Received empty message.');
                            return;
                        }
                        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
                        // Test whether we find an id to reject the promise
                        const responseMessage = message;
                        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
                            const key = responseMessage.id;
                            const responseHandler = responsePromises.get(key);
                            if (responseHandler) {
                                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
                            }
                        }
                    }
                    function stringifyTrace(params) {
                        if (params === undefined || params === null) {
                            return undefined;
                        }
                        switch(trace){
                            case Trace.Verbose:
                                return JSON.stringify(params, null, 4);
                            case Trace.Compact:
                                return JSON.stringify(params);
                            default:
                                return undefined;
                        }
                    }
                    function traceSendingRequest(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                                data = `Params: ${stringifyTrace(message.params)}\n\n`;
                            }
                            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
                        } else {
                            logLSPMessage('send-request', message);
                        }
                    }
                    function traceSendingNotification(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.params) {
                                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                                } else {
                                    data = 'No parameters provided.\n\n';
                                }
                            }
                            tracer.log(`Sending notification '${message.method}'.`, data);
                        } else {
                            logLSPMessage('send-notification', message);
                        }
                    }
                    function traceSendingResponse(message, method, startTime) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.error && message.error.data) {
                                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                                } else {
                                    if (message.result) {
                                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                                    } else if (message.error === undefined) {
                                        data = 'No result returned.\n\n';
                                    }
                                }
                            }
                            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
                        } else {
                            logLSPMessage('send-response', message);
                        }
                    }
                    function traceReceivedRequest(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                                data = `Params: ${stringifyTrace(message.params)}\n\n`;
                            }
                            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
                        } else {
                            logLSPMessage('receive-request', message);
                        }
                    }
                    function traceReceivedNotification(message) {
                        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.params) {
                                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                                } else {
                                    data = 'No parameters provided.\n\n';
                                }
                            }
                            tracer.log(`Received notification '${message.method}'.`, data);
                        } else {
                            logLSPMessage('receive-notification', message);
                        }
                    }
                    function traceReceivedResponse(message, responsePromise) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.error && message.error.data) {
                                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                                } else {
                                    if (message.result) {
                                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                                    } else if (message.error === undefined) {
                                        data = 'No result returned.\n\n';
                                    }
                                }
                            }
                            if (responsePromise) {
                                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
                                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
                            } else {
                                tracer.log(`Received response ${message.id} without active response promise.`, data);
                            }
                        } else {
                            logLSPMessage('receive-response', message);
                        }
                    }
                    function logLSPMessage(type, message) {
                        if (!tracer || trace === Trace.Off) {
                            return;
                        }
                        const lspMessage = {
                            isLSPMessage: true,
                            type,
                            message,
                            timestamp: Date.now()
                        };
                        tracer.log(lspMessage);
                    }
                    function throwIfClosedOrDisposed() {
                        if (isClosed()) {
                            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
                        }
                        if (isDisposed()) {
                            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
                        }
                    }
                    function throwIfListening() {
                        if (isListening()) {
                            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
                        }
                    }
                    function throwIfNotListening() {
                        if (!isListening()) {
                            throw new Error('Call listen() first.');
                        }
                    }
                    function undefinedToNull(param) {
                        if (param === undefined) {
                            return null;
                        } else {
                            return param;
                        }
                    }
                    function nullToUndefined(param) {
                        if (param === null) {
                            return undefined;
                        } else {
                            return param;
                        }
                    }
                    function isNamedParam(param) {
                        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';
                    }
                    function computeSingleParam(parameterStructures, param) {
                        switch(parameterStructures){
                            case messages_1.ParameterStructures.auto:
                                if (isNamedParam(param)) {
                                    return nullToUndefined(param);
                                } else {
                                    return [
                                        undefinedToNull(param)
                                    ];
                                }
                            case messages_1.ParameterStructures.byName:
                                if (!isNamedParam(param)) {
                                    throw new Error(`Received parameters by name but param is not an object literal.`);
                                }
                                return nullToUndefined(param);
                            case messages_1.ParameterStructures.byPosition:
                                return [
                                    undefinedToNull(param)
                                ];
                            default:
                                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
                        }
                    }
                    function computeMessageParams(type, params) {
                        let result;
                        const numberOfParams = type.numberOfParams;
                        switch(numberOfParams){
                            case 0:
                                result = undefined;
                                break;
                            case 1:
                                result = computeSingleParam(type.parameterStructures, params[0]);
                                break;
                            default:
                                result = [];
                                for(let i = 0; i < params.length && i < numberOfParams; i++){
                                    result.push(undefinedToNull(params[i]));
                                }
                                if (params.length < numberOfParams) {
                                    for(let i = params.length; i < numberOfParams; i++){
                                        result.push(null);
                                    }
                                }
                                break;
                        }
                        return result;
                    }
                    const connection = {
                        sendNotification: (type, ...args)=>{
                            throwIfClosedOrDisposed();
                            let method;
                            let messageParams;
                            if (Is.string(type)) {
                                method = type;
                                const first = args[0];
                                let paramStart = 0;
                                let parameterStructures = messages_1.ParameterStructures.auto;
                                if (messages_1.ParameterStructures.is(first)) {
                                    paramStart = 1;
                                    parameterStructures = first;
                                }
                                let paramEnd = args.length;
                                const numberOfParams = paramEnd - paramStart;
                                switch(numberOfParams){
                                    case 0:
                                        messageParams = undefined;
                                        break;
                                    case 1:
                                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                                        break;
                                    default:
                                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                                        }
                                        messageParams = args.slice(paramStart, paramEnd).map((value)=>undefinedToNull(value));
                                        break;
                                }
                            } else {
                                const params = args;
                                method = type.method;
                                messageParams = computeMessageParams(type, params);
                            }
                            const notificationMessage = {
                                jsonrpc: version,
                                method: method,
                                params: messageParams
                            };
                            traceSendingNotification(notificationMessage);
                            return messageWriter.write(notificationMessage).catch((error)=>{
                                logger.error(`Sending notification failed.`);
                                throw error;
                            });
                        },
                        onNotification: (type, handler)=>{
                            throwIfClosedOrDisposed();
                            let method;
                            if (Is.func(type)) {
                                starNotificationHandler = type;
                            } else if (handler) {
                                if (Is.string(type)) {
                                    method = type;
                                    notificationHandlers.set(type, {
                                        type: undefined,
                                        handler
                                    });
                                } else {
                                    method = type.method;
                                    notificationHandlers.set(type.method, {
                                        type,
                                        handler
                                    });
                                }
                            }
                            return {
                                dispose: ()=>{
                                    if (method !== undefined) {
                                        notificationHandlers.delete(method);
                                    } else {
                                        starNotificationHandler = undefined;
                                    }
                                }
                            };
                        },
                        onProgress: (_type, token, handler)=>{
                            if (progressHandlers.has(token)) {
                                throw new Error(`Progress handler for token ${token} already registered`);
                            }
                            progressHandlers.set(token, handler);
                            return {
                                dispose: ()=>{
                                    progressHandlers.delete(token);
                                }
                            };
                        },
                        sendProgress: (_type, token, value)=>{
                            // This should not await but simple return to ensure that we don't have another
                            // async scheduling. Otherwise one send could overtake another send.
                            return connection.sendNotification(ProgressNotification.type, {
                                token,
                                value
                            });
                        },
                        onUnhandledProgress: unhandledProgressEmitter.event,
                        sendRequest: (type, ...args)=>{
                            throwIfClosedOrDisposed();
                            throwIfNotListening();
                            let method;
                            let messageParams;
                            let token = undefined;
                            if (Is.string(type)) {
                                method = type;
                                const first = args[0];
                                const last = args[args.length - 1];
                                let paramStart = 0;
                                let parameterStructures = messages_1.ParameterStructures.auto;
                                if (messages_1.ParameterStructures.is(first)) {
                                    paramStart = 1;
                                    parameterStructures = first;
                                }
                                let paramEnd = args.length;
                                if (cancellation_1.CancellationToken.is(last)) {
                                    paramEnd = paramEnd - 1;
                                    token = last;
                                }
                                const numberOfParams = paramEnd - paramStart;
                                switch(numberOfParams){
                                    case 0:
                                        messageParams = undefined;
                                        break;
                                    case 1:
                                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                                        break;
                                    default:
                                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                                        }
                                        messageParams = args.slice(paramStart, paramEnd).map((value)=>undefinedToNull(value));
                                        break;
                                }
                            } else {
                                const params = args;
                                method = type.method;
                                messageParams = computeMessageParams(type, params);
                                const numberOfParams = type.numberOfParams;
                                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
                            }
                            const id = sequenceNumber++;
                            let disposable;
                            if (token) {
                                disposable = token.onCancellationRequested(()=>{
                                    const p = cancellationStrategy.sender.sendCancellation(connection, id);
                                    if (p === undefined) {
                                        logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                                        return Promise.resolve();
                                    } else {
                                        return p.catch(()=>{
                                            logger.log(`Sending cancellation messages for id ${id} failed`);
                                        });
                                    }
                                });
                            }
                            const requestMessage = {
                                jsonrpc: version,
                                id: id,
                                method: method,
                                params: messageParams
                            };
                            traceSendingRequest(requestMessage);
                            if (typeof cancellationStrategy.sender.enableCancellation === 'function') {
                                cancellationStrategy.sender.enableCancellation(requestMessage);
                            }
                            return new Promise(async (resolve, reject)=>{
                                const resolveWithCleanup = (r)=>{
                                    var _disposable;
                                    resolve(r);
                                    cancellationStrategy.sender.cleanup(id);
                                    (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable.dispose();
                                };
                                const rejectWithCleanup = (r)=>{
                                    var _disposable;
                                    reject(r);
                                    cancellationStrategy.sender.cleanup(id);
                                    (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable.dispose();
                                };
                                const responsePromise = {
                                    method: method,
                                    timerStart: Date.now(),
                                    resolve: resolveWithCleanup,
                                    reject: rejectWithCleanup
                                };
                                try {
                                    await messageWriter.write(requestMessage);
                                    responsePromises.set(id, responsePromise);
                                } catch (error) {
                                    logger.error(`Sending request failed.`);
                                    // Writing the message failed. So we need to reject the promise.
                                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : 'Unknown reason'));
                                    throw error;
                                }
                            });
                        },
                        onRequest: (type, handler)=>{
                            throwIfClosedOrDisposed();
                            let method = null;
                            if (StarRequestHandler.is(type)) {
                                method = undefined;
                                starRequestHandler = type;
                            } else if (Is.string(type)) {
                                method = null;
                                if (handler !== undefined) {
                                    method = type;
                                    requestHandlers.set(type, {
                                        handler: handler,
                                        type: undefined
                                    });
                                }
                            } else {
                                if (handler !== undefined) {
                                    method = type.method;
                                    requestHandlers.set(type.method, {
                                        type,
                                        handler
                                    });
                                }
                            }
                            return {
                                dispose: ()=>{
                                    if (method === null) {
                                        return;
                                    }
                                    if (method !== undefined) {
                                        requestHandlers.delete(method);
                                    } else {
                                        starRequestHandler = undefined;
                                    }
                                }
                            };
                        },
                        hasPendingResponse: ()=>{
                            return responsePromises.size > 0;
                        },
                        trace: async (_value, _tracer, sendNotificationOrTraceOptions)=>{
                            let _sendNotification = false;
                            let _traceFormat = TraceFormat.Text;
                            if (sendNotificationOrTraceOptions !== undefined) {
                                if (Is.boolean(sendNotificationOrTraceOptions)) {
                                    _sendNotification = sendNotificationOrTraceOptions;
                                } else {
                                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                                }
                            }
                            trace = _value;
                            traceFormat = _traceFormat;
                            if (trace === Trace.Off) {
                                tracer = undefined;
                            } else {
                                tracer = _tracer;
                            }
                            if (_sendNotification && !isClosed() && !isDisposed()) {
                                await connection.sendNotification(SetTraceNotification.type, {
                                    value: Trace.toString(_value)
                                });
                            }
                        },
                        onError: errorEmitter.event,
                        onClose: closeEmitter.event,
                        onUnhandledNotification: unhandledNotificationEmitter.event,
                        onDispose: disposeEmitter.event,
                        end: ()=>{
                            messageWriter.end();
                        },
                        dispose: ()=>{
                            if (isDisposed()) {
                                return;
                            }
                            state = ConnectionState.Disposed;
                            disposeEmitter.fire(undefined);
                            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, 'Pending response rejected since connection got disposed');
                            for (const promise of responsePromises.values()){
                                promise.reject(error);
                            }
                            responsePromises = new Map();
                            requestTokens = new Map();
                            knownCanceledRequests = new Set();
                            messageQueue = new linkedMap_1.LinkedMap();
                            // Test for backwards compatibility
                            if (Is.func(messageWriter.dispose)) {
                                messageWriter.dispose();
                            }
                            if (Is.func(messageReader.dispose)) {
                                messageReader.dispose();
                            }
                        },
                        listen: ()=>{
                            throwIfClosedOrDisposed();
                            throwIfListening();
                            state = ConnectionState.Listening;
                            messageReader.listen(callback);
                        },
                        inspect: ()=>{
                            // eslint-disable-next-line no-console
                            (0, ral_1.default)().console.log('inspect');
                        }
                    };
                    connection.onNotification(LogTraceNotification.type, (params)=>{
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
                        tracer.log(params.message, verbose ? params.verbose : undefined);
                    });
                    connection.onNotification(ProgressNotification.type, (params)=>{
                        const handler = progressHandlers.get(params.token);
                        if (handler) {
                            handler(params.value);
                        } else {
                            unhandledProgressEmitter.fire(params);
                        }
                    });
                    return connection;
                }
                exports1.createMessageConnection = createMessageConnection;
            /***/ },
            /***/ 8437: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Disposable = void 0;
                var Disposable;
                (function(Disposable) {
                    function create(func) {
                        return {
                            dispose: func
                        };
                    }
                    Disposable.create = create;
                })(Disposable = exports1.Disposable || (exports1.Disposable = {}));
            /***/ },
            /***/ 5165: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_348399__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Emitter = exports1.Event = void 0;
                const ral_1 = __nested_webpack_require_348399__(5706);
                var Event;
                (function(Event) {
                    const _disposable = {
                        dispose () {}
                    };
                    Event.None = function() {
                        return _disposable;
                    };
                })(Event = exports1.Event || (exports1.Event = {}));
                class CallbackList {
                    add(callback, context = null, bucket) {
                        if (!this._callbacks) {
                            this._callbacks = [];
                            this._contexts = [];
                        }
                        this._callbacks.push(callback);
                        this._contexts.push(context);
                        if (Array.isArray(bucket)) {
                            bucket.push({
                                dispose: ()=>this.remove(callback, context)
                            });
                        }
                    }
                    remove(callback, context = null) {
                        if (!this._callbacks) {
                            return;
                        }
                        let foundCallbackWithDifferentContext = false;
                        for(let i = 0, len = this._callbacks.length; i < len; i++){
                            if (this._callbacks[i] === callback) {
                                if (this._contexts[i] === context) {
                                    // callback & context match => remove it
                                    this._callbacks.splice(i, 1);
                                    this._contexts.splice(i, 1);
                                    return;
                                } else {
                                    foundCallbackWithDifferentContext = true;
                                }
                            }
                        }
                        if (foundCallbackWithDifferentContext) {
                            throw new Error('When adding a listener with a context, you should remove it with the same context');
                        }
                    }
                    invoke(...args) {
                        if (!this._callbacks) {
                            return [];
                        }
                        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
                        for(let i = 0, len = callbacks.length; i < len; i++){
                            try {
                                ret.push(callbacks[i].apply(contexts[i], args));
                            } catch (e) {
                                // eslint-disable-next-line no-console
                                (0, ral_1.default)().console.error(e);
                            }
                        }
                        return ret;
                    }
                    isEmpty() {
                        return !this._callbacks || this._callbacks.length === 0;
                    }
                    dispose() {
                        this._callbacks = undefined;
                        this._contexts = undefined;
                    }
                }
                class Emitter {
                    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */ get event() {
                        if (!this._event) {
                            this._event = (listener, thisArgs, disposables)=>{
                                if (!this._callbacks) {
                                    this._callbacks = new CallbackList();
                                }
                                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                                    this._options.onFirstListenerAdd(this);
                                }
                                this._callbacks.add(listener, thisArgs);
                                const result = {
                                    dispose: ()=>{
                                        if (!this._callbacks) {
                                            // disposable is disposed after emitter is disposed.
                                            return;
                                        }
                                        this._callbacks.remove(listener, thisArgs);
                                        result.dispose = Emitter._noop;
                                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                                            this._options.onLastListenerRemove(this);
                                        }
                                    }
                                };
                                if (Array.isArray(disposables)) {
                                    disposables.push(result);
                                }
                                return result;
                            };
                        }
                        return this._event;
                    }
                    /**
     * To be kept private to fire an event to
     * subscribers
     */ fire(event) {
                        if (this._callbacks) {
                            this._callbacks.invoke.call(this._callbacks, event);
                        }
                    }
                    dispose() {
                        if (this._callbacks) {
                            this._callbacks.dispose();
                            this._callbacks = undefined;
                        }
                    }
                    constructor(_options){
                        this._options = _options;
                    }
                }
                exports1.Emitter = Emitter;
                Emitter._noop = function() {};
            /***/ },
            /***/ 8811: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.stringArray = exports1.array = exports1.func = exports1.error = exports1.number = exports1.string = exports1.boolean = void 0;
                function boolean(value) {
                    return value === true || value === false;
                }
                exports1.boolean = boolean;
                function string(value) {
                    return typeof value === 'string' || value instanceof String;
                }
                exports1.string = string;
                function number(value) {
                    return typeof value === 'number' || value instanceof Number;
                }
                exports1.number = number;
                function error(value) {
                    return value instanceof Error;
                }
                exports1.error = error;
                function func(value) {
                    return typeof value === 'function';
                }
                exports1.func = func;
                function array(value) {
                    return Array.isArray(value);
                }
                exports1.array = array;
                function stringArray(value) {
                    return array(value) && value.every((elem)=>string(elem));
                }
                exports1.stringArray = stringArray;
            /***/ },
            /***/ 7040: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ var _a;
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LRUCache = exports1.LinkedMap = exports1.Touch = void 0;
                var Touch;
                (function(Touch) {
                    Touch.None = 0;
                    Touch.First = 1;
                    Touch.AsOld = Touch.First;
                    Touch.Last = 2;
                    Touch.AsNew = Touch.Last;
                })(Touch = exports1.Touch || (exports1.Touch = {}));
                class LinkedMap {
                    clear() {
                        this._map.clear();
                        this._head = undefined;
                        this._tail = undefined;
                        this._size = 0;
                        this._state++;
                    }
                    isEmpty() {
                        return !this._head && !this._tail;
                    }
                    get size() {
                        return this._size;
                    }
                    get first() {
                        var _this__head;
                        return (_this__head = this._head) === null || _this__head === void 0 ? void 0 : _this__head.value;
                    }
                    get last() {
                        var _this__tail;
                        return (_this__tail = this._tail) === null || _this__tail === void 0 ? void 0 : _this__tail.value;
                    }
                    has(key) {
                        return this._map.has(key);
                    }
                    get(key, touch = Touch.None) {
                        const item = this._map.get(key);
                        if (!item) {
                            return undefined;
                        }
                        if (touch !== Touch.None) {
                            this.touch(item, touch);
                        }
                        return item.value;
                    }
                    set(key, value, touch = Touch.None) {
                        let item = this._map.get(key);
                        if (item) {
                            item.value = value;
                            if (touch !== Touch.None) {
                                this.touch(item, touch);
                            }
                        } else {
                            item = {
                                key,
                                value,
                                next: undefined,
                                previous: undefined
                            };
                            switch(touch){
                                case Touch.None:
                                    this.addItemLast(item);
                                    break;
                                case Touch.First:
                                    this.addItemFirst(item);
                                    break;
                                case Touch.Last:
                                    this.addItemLast(item);
                                    break;
                                default:
                                    this.addItemLast(item);
                                    break;
                            }
                            this._map.set(key, item);
                            this._size++;
                        }
                        return this;
                    }
                    delete(key) {
                        return !!this.remove(key);
                    }
                    remove(key) {
                        const item = this._map.get(key);
                        if (!item) {
                            return undefined;
                        }
                        this._map.delete(key);
                        this.removeItem(item);
                        this._size--;
                        return item.value;
                    }
                    shift() {
                        if (!this._head && !this._tail) {
                            return undefined;
                        }
                        if (!this._head || !this._tail) {
                            throw new Error('Invalid list');
                        }
                        const item = this._head;
                        this._map.delete(item.key);
                        this.removeItem(item);
                        this._size--;
                        return item.value;
                    }
                    forEach(callbackfn, thisArg) {
                        const state = this._state;
                        let current = this._head;
                        while(current){
                            if (thisArg) {
                                callbackfn.bind(thisArg)(current.value, current.key, this);
                            } else {
                                callbackfn(current.value, current.key, this);
                            }
                            if (this._state !== state) {
                                throw new Error(`LinkedMap got modified during iteration.`);
                            }
                            current = current.next;
                        }
                    }
                    keys() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: current.key,
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    values() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: current.value,
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    entries() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: [
                                            current.key,
                                            current.value
                                        ],
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
                        return this.entries();
                    }
                    trimOld(newSize) {
                        if (newSize >= this.size) {
                            return;
                        }
                        if (newSize === 0) {
                            this.clear();
                            return;
                        }
                        let current = this._head;
                        let currentSize = this.size;
                        while(current && currentSize > newSize){
                            this._map.delete(current.key);
                            current = current.next;
                            currentSize--;
                        }
                        this._head = current;
                        this._size = currentSize;
                        if (current) {
                            current.previous = undefined;
                        }
                        this._state++;
                    }
                    addItemFirst(item) {
                        // First time Insert
                        if (!this._head && !this._tail) {
                            this._tail = item;
                        } else if (!this._head) {
                            throw new Error('Invalid list');
                        } else {
                            item.next = this._head;
                            this._head.previous = item;
                        }
                        this._head = item;
                        this._state++;
                    }
                    addItemLast(item) {
                        // First time Insert
                        if (!this._head && !this._tail) {
                            this._head = item;
                        } else if (!this._tail) {
                            throw new Error('Invalid list');
                        } else {
                            item.previous = this._tail;
                            this._tail.next = item;
                        }
                        this._tail = item;
                        this._state++;
                    }
                    removeItem(item) {
                        if (item === this._head && item === this._tail) {
                            this._head = undefined;
                            this._tail = undefined;
                        } else if (item === this._head) {
                            // This can only happened if size === 1 which is handle
                            // by the case above.
                            if (!item.next) {
                                throw new Error('Invalid list');
                            }
                            item.next.previous = undefined;
                            this._head = item.next;
                        } else if (item === this._tail) {
                            // This can only happened if size === 1 which is handle
                            // by the case above.
                            if (!item.previous) {
                                throw new Error('Invalid list');
                            }
                            item.previous.next = undefined;
                            this._tail = item.previous;
                        } else {
                            const next = item.next;
                            const previous = item.previous;
                            if (!next || !previous) {
                                throw new Error('Invalid list');
                            }
                            next.previous = previous;
                            previous.next = next;
                        }
                        item.next = undefined;
                        item.previous = undefined;
                        this._state++;
                    }
                    touch(item, touch) {
                        if (!this._head || !this._tail) {
                            throw new Error('Invalid list');
                        }
                        if (touch !== Touch.First && touch !== Touch.Last) {
                            return;
                        }
                        if (touch === Touch.First) {
                            if (item === this._head) {
                                return;
                            }
                            const next = item.next;
                            const previous = item.previous;
                            // Unlink the item
                            if (item === this._tail) {
                                // previous must be defined since item was not head but is tail
                                // So there are more than on item in the map
                                previous.next = undefined;
                                this._tail = previous;
                            } else {
                                // Both next and previous are not undefined since item was neither head nor tail.
                                next.previous = previous;
                                previous.next = next;
                            }
                            // Insert the node at head
                            item.previous = undefined;
                            item.next = this._head;
                            this._head.previous = item;
                            this._head = item;
                            this._state++;
                        } else if (touch === Touch.Last) {
                            if (item === this._tail) {
                                return;
                            }
                            const next = item.next;
                            const previous = item.previous;
                            // Unlink the item.
                            if (item === this._head) {
                                // next must be defined since item was not tail but is head
                                // So there are more than on item in the map
                                next.previous = undefined;
                                this._head = next;
                            } else {
                                // Both next and previous are not undefined since item was neither head nor tail.
                                next.previous = previous;
                                previous.next = next;
                            }
                            item.next = undefined;
                            item.previous = this._tail;
                            this._tail.next = item;
                            this._tail = item;
                            this._state++;
                        }
                    }
                    toJSON() {
                        const data = [];
                        this.forEach((value, key)=>{
                            data.push([
                                key,
                                value
                            ]);
                        });
                        return data;
                    }
                    fromJSON(data) {
                        this.clear();
                        for (const [key, value] of data){
                            this.set(key, value);
                        }
                    }
                    constructor(){
                        this[_a] = 'LinkedMap';
                        this._map = new Map();
                        this._head = undefined;
                        this._tail = undefined;
                        this._size = 0;
                        this._state = 0;
                    }
                }
                exports1.LinkedMap = LinkedMap;
                class LRUCache extends LinkedMap {
                    get limit() {
                        return this._limit;
                    }
                    set limit(limit) {
                        this._limit = limit;
                        this.checkTrim();
                    }
                    get ratio() {
                        return this._ratio;
                    }
                    set ratio(ratio) {
                        this._ratio = Math.min(Math.max(0, ratio), 1);
                        this.checkTrim();
                    }
                    get(key, touch = Touch.AsNew) {
                        return super.get(key, touch);
                    }
                    peek(key) {
                        return super.get(key, Touch.None);
                    }
                    set(key, value) {
                        super.set(key, value, Touch.Last);
                        this.checkTrim();
                        return this;
                    }
                    checkTrim() {
                        if (this.size > this._limit) {
                            this.trimOld(Math.round(this._limit * this._ratio));
                        }
                    }
                    constructor(limit, ratio = 1){
                        super();
                        this._limit = limit;
                        this._ratio = Math.min(Math.max(0, ratio), 1);
                    }
                }
                exports1.LRUCache = LRUCache;
            /***/ },
            /***/ 8652: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.AbstractMessageBuffer = void 0;
                const CR = 13;
                const LF = 10;
                const CRLF = '\r\n';
                class AbstractMessageBuffer {
                    get encoding() {
                        return this._encoding;
                    }
                    append(chunk) {
                        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;
                        this._chunks.push(toAppend);
                        this._totalLength += toAppend.byteLength;
                    }
                    tryReadHeaders(lowerCaseKeys = false) {
                        if (this._chunks.length === 0) {
                            return undefined;
                        }
                        let state = 0;
                        let chunkIndex = 0;
                        let offset = 0;
                        let chunkBytesRead = 0;
                        row: while(chunkIndex < this._chunks.length){
                            const chunk = this._chunks[chunkIndex];
                            offset = 0;
                            column: while(offset < chunk.length){
                                const value = chunk[offset];
                                switch(value){
                                    case CR:
                                        switch(state){
                                            case 0:
                                                state = 1;
                                                break;
                                            case 2:
                                                state = 3;
                                                break;
                                            default:
                                                state = 0;
                                        }
                                        break;
                                    case LF:
                                        switch(state){
                                            case 1:
                                                state = 2;
                                                break;
                                            case 3:
                                                state = 4;
                                                offset++;
                                                break row;
                                            default:
                                                state = 0;
                                        }
                                        break;
                                    default:
                                        state = 0;
                                }
                                offset++;
                            }
                            chunkBytesRead += chunk.byteLength;
                            chunkIndex++;
                        }
                        if (state !== 4) {
                            return undefined;
                        }
                        // The buffer contains the two CRLF at the end. So we will
                        // have two empty lines after the split at the end as well.
                        const buffer = this._read(chunkBytesRead + offset);
                        const result = new Map();
                        const headers = this.toString(buffer, 'ascii').split(CRLF);
                        if (headers.length < 2) {
                            return result;
                        }
                        for(let i = 0; i < headers.length - 2; i++){
                            const header = headers[i];
                            const index = header.indexOf(':');
                            if (index === -1) {
                                throw new Error('Message header must separate key and value using :');
                            }
                            const key = header.substr(0, index);
                            const value = header.substr(index + 1).trim();
                            result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
                        }
                        return result;
                    }
                    tryReadBody(length) {
                        if (this._totalLength < length) {
                            return undefined;
                        }
                        return this._read(length);
                    }
                    get numberOfBytes() {
                        return this._totalLength;
                    }
                    _read(byteCount) {
                        if (byteCount === 0) {
                            return this.emptyBuffer();
                        }
                        if (byteCount > this._totalLength) {
                            throw new Error(`Cannot read so many bytes!`);
                        }
                        if (this._chunks[0].byteLength === byteCount) {
                            // super fast path, precisely first chunk must be returned
                            const chunk = this._chunks[0];
                            this._chunks.shift();
                            this._totalLength -= byteCount;
                            return this.asNative(chunk);
                        }
                        if (this._chunks[0].byteLength > byteCount) {
                            // fast path, the reading is entirely within the first chunk
                            const chunk = this._chunks[0];
                            const result = this.asNative(chunk, byteCount);
                            this._chunks[0] = chunk.slice(byteCount);
                            this._totalLength -= byteCount;
                            return result;
                        }
                        const result = this.allocNative(byteCount);
                        let resultOffset = 0;
                        let chunkIndex = 0;
                        while(byteCount > 0){
                            const chunk = this._chunks[chunkIndex];
                            if (chunk.byteLength > byteCount) {
                                // this chunk will survive
                                const chunkPart = chunk.slice(0, byteCount);
                                result.set(chunkPart, resultOffset);
                                resultOffset += byteCount;
                                this._chunks[chunkIndex] = chunk.slice(byteCount);
                                this._totalLength -= byteCount;
                                byteCount -= byteCount;
                            } else {
                                // this chunk will be entirely read
                                result.set(chunk, resultOffset);
                                resultOffset += chunk.byteLength;
                                this._chunks.shift();
                                this._totalLength -= chunk.byteLength;
                                byteCount -= chunk.byteLength;
                            }
                        }
                        return result;
                    }
                    constructor(encoding = 'utf-8'){
                        this._encoding = encoding;
                        this._chunks = [];
                        this._totalLength = 0;
                    }
                }
                exports1.AbstractMessageBuffer = AbstractMessageBuffer;
            /***/ },
            /***/ 451: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_384091__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ReadableStreamMessageReader = exports1.AbstractMessageReader = exports1.MessageReader = void 0;
                const ral_1 = __nested_webpack_require_384091__(5706);
                const Is = __nested_webpack_require_384091__(8811);
                const events_1 = __nested_webpack_require_384091__(5165);
                const semaphore_1 = __nested_webpack_require_384091__(2339);
                var MessageReader;
                (function(MessageReader) {
                    function is(value) {
                        let candidate = value;
                        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
                    }
                    MessageReader.is = is;
                })(MessageReader = exports1.MessageReader || (exports1.MessageReader = {}));
                class AbstractMessageReader {
                    dispose() {
                        this.errorEmitter.dispose();
                        this.closeEmitter.dispose();
                    }
                    get onError() {
                        return this.errorEmitter.event;
                    }
                    fireError(error) {
                        this.errorEmitter.fire(this.asError(error));
                    }
                    get onClose() {
                        return this.closeEmitter.event;
                    }
                    fireClose() {
                        this.closeEmitter.fire(undefined);
                    }
                    get onPartialMessage() {
                        return this.partialMessageEmitter.event;
                    }
                    firePartialMessage(info) {
                        this.partialMessageEmitter.fire(info);
                    }
                    asError(error) {
                        if (error instanceof Error) {
                            return error;
                        } else {
                            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
                        }
                    }
                    constructor(){
                        this.errorEmitter = new events_1.Emitter();
                        this.closeEmitter = new events_1.Emitter();
                        this.partialMessageEmitter = new events_1.Emitter();
                    }
                }
                exports1.AbstractMessageReader = AbstractMessageReader;
                var ResolvedMessageReaderOptions;
                (function(ResolvedMessageReaderOptions) {
                    function fromOptions(options) {
                        let charset;
                        let result;
                        let contentDecoder;
                        const contentDecoders = new Map();
                        let contentTypeDecoder;
                        const contentTypeDecoders = new Map();
                        if (options === undefined || typeof options === 'string') {
                            charset = options !== null && options !== void 0 ? options : 'utf-8';
                        } else {
                            var _options_charset;
                            charset = (_options_charset = options.charset) !== null && _options_charset !== void 0 ? _options_charset : 'utf-8';
                            if (options.contentDecoder !== undefined) {
                                contentDecoder = options.contentDecoder;
                                contentDecoders.set(contentDecoder.name, contentDecoder);
                            }
                            if (options.contentDecoders !== undefined) {
                                for (const decoder of options.contentDecoders){
                                    contentDecoders.set(decoder.name, decoder);
                                }
                            }
                            if (options.contentTypeDecoder !== undefined) {
                                contentTypeDecoder = options.contentTypeDecoder;
                                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
                            }
                            if (options.contentTypeDecoders !== undefined) {
                                for (const decoder of options.contentTypeDecoders){
                                    contentTypeDecoders.set(decoder.name, decoder);
                                }
                            }
                        }
                        if (contentTypeDecoder === undefined) {
                            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
                            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
                        }
                        return {
                            charset,
                            contentDecoder,
                            contentDecoders,
                            contentTypeDecoder,
                            contentTypeDecoders
                        };
                    }
                    ResolvedMessageReaderOptions.fromOptions = fromOptions;
                })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
                class ReadableStreamMessageReader extends AbstractMessageReader {
                    set partialMessageTimeout(timeout) {
                        this._partialMessageTimeout = timeout;
                    }
                    get partialMessageTimeout() {
                        return this._partialMessageTimeout;
                    }
                    listen(callback) {
                        this.nextMessageLength = -1;
                        this.messageToken = 0;
                        this.partialMessageTimer = undefined;
                        this.callback = callback;
                        const result = this.readable.onData((data)=>{
                            this.onData(data);
                        });
                        this.readable.onError((error)=>this.fireError(error));
                        this.readable.onClose(()=>this.fireClose());
                        return result;
                    }
                    onData(data) {
                        this.buffer.append(data);
                        while(true){
                            if (this.nextMessageLength === -1) {
                                const headers = this.buffer.tryReadHeaders(true);
                                if (!headers) {
                                    return;
                                }
                                const contentLength = headers.get('content-length');
                                if (!contentLength) {
                                    this.fireError(new Error('Header must provide a Content-Length property.'));
                                    return;
                                }
                                const length = parseInt(contentLength);
                                if (isNaN(length)) {
                                    this.fireError(new Error('Content-Length value must be a number.'));
                                    return;
                                }
                                this.nextMessageLength = length;
                            }
                            const body = this.buffer.tryReadBody(this.nextMessageLength);
                            if (body === undefined) {
                                /** We haven't received the full message yet. */ this.setPartialMessageTimer();
                                return;
                            }
                            this.clearPartialMessageTimer();
                            this.nextMessageLength = -1;
                            // Make sure that we convert one received message after the
                            // other. Otherwise it could happen that a decoding of a second
                            // smaller message finished before the decoding of a first larger
                            // message and then we would deliver the second message first.
                            this.readSemaphore.lock(async ()=>{
                                const bytes = this.options.contentDecoder !== undefined ? await this.options.contentDecoder.decode(body) : body;
                                const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
                                this.callback(message);
                            }).catch((error)=>{
                                this.fireError(error);
                            });
                        }
                    }
                    clearPartialMessageTimer() {
                        if (this.partialMessageTimer) {
                            this.partialMessageTimer.dispose();
                            this.partialMessageTimer = undefined;
                        }
                    }
                    setPartialMessageTimer() {
                        this.clearPartialMessageTimer();
                        if (this._partialMessageTimeout <= 0) {
                            return;
                        }
                        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout)=>{
                            this.partialMessageTimer = undefined;
                            if (token === this.messageToken) {
                                this.firePartialMessage({
                                    messageToken: token,
                                    waitingTime: timeout
                                });
                                this.setPartialMessageTimer();
                            }
                        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
                    }
                    constructor(readable, options){
                        super();
                        this.readable = readable;
                        this.options = ResolvedMessageReaderOptions.fromOptions(options);
                        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
                        this._partialMessageTimeout = 10000;
                        this.nextMessageLength = -1;
                        this.messageToken = 0;
                        this.readSemaphore = new semaphore_1.Semaphore(1);
                    }
                }
                exports1.ReadableStreamMessageReader = ReadableStreamMessageReader;
            /***/ },
            /***/ 1251: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_395353__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WriteableStreamMessageWriter = exports1.AbstractMessageWriter = exports1.MessageWriter = void 0;
                const ral_1 = __nested_webpack_require_395353__(5706);
                const Is = __nested_webpack_require_395353__(8811);
                const semaphore_1 = __nested_webpack_require_395353__(2339);
                const events_1 = __nested_webpack_require_395353__(5165);
                const ContentLength = 'Content-Length: ';
                const CRLF = '\r\n';
                var MessageWriter;
                (function(MessageWriter) {
                    function is(value) {
                        let candidate = value;
                        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
                    }
                    MessageWriter.is = is;
                })(MessageWriter = exports1.MessageWriter || (exports1.MessageWriter = {}));
                class AbstractMessageWriter {
                    dispose() {
                        this.errorEmitter.dispose();
                        this.closeEmitter.dispose();
                    }
                    get onError() {
                        return this.errorEmitter.event;
                    }
                    fireError(error, message, count) {
                        this.errorEmitter.fire([
                            this.asError(error),
                            message,
                            count
                        ]);
                    }
                    get onClose() {
                        return this.closeEmitter.event;
                    }
                    fireClose() {
                        this.closeEmitter.fire(undefined);
                    }
                    asError(error) {
                        if (error instanceof Error) {
                            return error;
                        } else {
                            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
                        }
                    }
                    constructor(){
                        this.errorEmitter = new events_1.Emitter();
                        this.closeEmitter = new events_1.Emitter();
                    }
                }
                exports1.AbstractMessageWriter = AbstractMessageWriter;
                var ResolvedMessageWriterOptions;
                (function(ResolvedMessageWriterOptions) {
                    function fromOptions(options) {
                        if (options === undefined || typeof options === 'string') {
                            return {
                                charset: options !== null && options !== void 0 ? options : 'utf-8',
                                contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder
                            };
                        } else {
                            var _options_charset, _options_contentTypeEncoder;
                            return {
                                charset: (_options_charset = options.charset) !== null && _options_charset !== void 0 ? _options_charset : 'utf-8',
                                contentEncoder: options.contentEncoder,
                                contentTypeEncoder: (_options_contentTypeEncoder = options.contentTypeEncoder) !== null && _options_contentTypeEncoder !== void 0 ? _options_contentTypeEncoder : (0, ral_1.default)().applicationJson.encoder
                            };
                        }
                    }
                    ResolvedMessageWriterOptions.fromOptions = fromOptions;
                })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
                class WriteableStreamMessageWriter extends AbstractMessageWriter {
                    async write(msg) {
                        return this.writeSemaphore.lock(async ()=>{
                            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer)=>{
                                if (this.options.contentEncoder !== undefined) {
                                    return this.options.contentEncoder.encode(buffer);
                                } else {
                                    return buffer;
                                }
                            });
                            return payload.then((buffer)=>{
                                const headers = [];
                                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
                                headers.push(CRLF);
                                return this.doWrite(msg, headers, buffer);
                            }, (error)=>{
                                this.fireError(error);
                                throw error;
                            });
                        });
                    }
                    async doWrite(msg, headers, data) {
                        try {
                            await this.writable.write(headers.join(''), 'ascii');
                            return this.writable.write(data);
                        } catch (error) {
                            this.handleError(error, msg);
                            return Promise.reject(error);
                        }
                    }
                    handleError(error, msg) {
                        this.errorCount++;
                        this.fireError(error, msg, this.errorCount);
                    }
                    end() {
                        this.writable.end();
                    }
                    constructor(writable, options){
                        super();
                        this.writable = writable;
                        this.options = ResolvedMessageWriterOptions.fromOptions(options);
                        this.errorCount = 0;
                        this.writeSemaphore = new semaphore_1.Semaphore(1);
                        this.writable.onError((error)=>this.fireError(error));
                        this.writable.onClose(()=>this.fireClose());
                    }
                }
                exports1.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
            /***/ },
            /***/ 9141: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_402239__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Message = exports1.NotificationType9 = exports1.NotificationType8 = exports1.NotificationType7 = exports1.NotificationType6 = exports1.NotificationType5 = exports1.NotificationType4 = exports1.NotificationType3 = exports1.NotificationType2 = exports1.NotificationType1 = exports1.NotificationType0 = exports1.NotificationType = exports1.RequestType9 = exports1.RequestType8 = exports1.RequestType7 = exports1.RequestType6 = exports1.RequestType5 = exports1.RequestType4 = exports1.RequestType3 = exports1.RequestType2 = exports1.RequestType1 = exports1.RequestType = exports1.RequestType0 = exports1.AbstractMessageSignature = exports1.ParameterStructures = exports1.ResponseError = exports1.ErrorCodes = void 0;
                const is = __nested_webpack_require_402239__(8811);
                /**
 * Predefined error codes.
 */ var ErrorCodes;
                (function(ErrorCodes) {
                    // Defined by JSON RPC
                    ErrorCodes.ParseError = -32700;
                    ErrorCodes.InvalidRequest = -32600;
                    ErrorCodes.MethodNotFound = -32601;
                    ErrorCodes.InvalidParams = -32602;
                    ErrorCodes.InternalError = -32603;
                    /**
     * This is the start range of JSON RPC reserved error codes.
     * It doesn't denote a real error code. No application error codes should
     * be defined between the start and end range. For backwards
     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
     * are left in the range.
     *
     * @since 3.16.0
    */ ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;
                    /** @deprecated use  jsonrpcReservedErrorRangeStart */ ErrorCodes.serverErrorStart = -32099;
                    /**
     * An error occurred when write a message to the transport layer.
     */ ErrorCodes.MessageWriteError = -32099;
                    /**
     * An error occurred when reading a message from the transport layer.
     */ ErrorCodes.MessageReadError = -32098;
                    /**
     * The connection got disposed or lost and all pending responses got
     * rejected.
     */ ErrorCodes.PendingResponseRejected = -32097;
                    /**
     * The connection is inactive and a use of it failed.
     */ ErrorCodes.ConnectionInactive = -32096;
                    /**
     * Error code indicating that a server received a notification or
     * request before the server has received the `initialize` request.
     */ ErrorCodes.ServerNotInitialized = -32002;
                    ErrorCodes.UnknownErrorCode = -32001;
                    /**
     * This is the end range of JSON RPC reserved error codes.
     * It doesn't denote a real error code.
     *
     * @since 3.16.0
    */ ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;
                    /** @deprecated use  jsonrpcReservedErrorRangeEnd */ ErrorCodes.serverErrorEnd = -32000;
                })(ErrorCodes = exports1.ErrorCodes || (exports1.ErrorCodes = {}));
                /**
 * An error object return in a response in case a request
 * has failed.
 */ class ResponseError extends Error {
                    toJson() {
                        const result = {
                            code: this.code,
                            message: this.message
                        };
                        if (this.data !== undefined) {
                            result.data = this.data;
                        }
                        return result;
                    }
                    constructor(code, message, data){
                        super(message);
                        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
                        this.data = data;
                        Object.setPrototypeOf(this, ResponseError.prototype);
                    }
                }
                exports1.ResponseError = ResponseError;
                class ParameterStructures {
                    static is(value) {
                        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
                    }
                    toString() {
                        return this.kind;
                    }
                    constructor(kind){
                        this.kind = kind;
                    }
                }
                exports1.ParameterStructures = ParameterStructures;
                /**
 * The parameter structure is automatically inferred on the number of parameters
 * and the parameter type in case of a single param.
 */ ParameterStructures.auto = new ParameterStructures('auto');
                /**
 * Forces `byPosition` parameter structure. This is useful if you have a single
 * parameter which has a literal type.
 */ ParameterStructures.byPosition = new ParameterStructures('byPosition');
                /**
 * Forces `byName` parameter structure. This is only useful when having a single
 * parameter. The library will report errors if used with a different number of
 * parameters.
 */ ParameterStructures.byName = new ParameterStructures('byName');
                /**
 * An abstract implementation of a MessageType.
 */ class AbstractMessageSignature {
                    get parameterStructures() {
                        return ParameterStructures.auto;
                    }
                    constructor(method, numberOfParams){
                        this.method = method;
                        this.numberOfParams = numberOfParams;
                    }
                }
                exports1.AbstractMessageSignature = AbstractMessageSignature;
                /**
 * Classes to type request response pairs
 */ class RequestType0 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 0);
                    }
                }
                exports1.RequestType0 = RequestType0;
                class RequestType extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.RequestType = RequestType;
                class RequestType1 extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.RequestType1 = RequestType1;
                class RequestType2 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 2);
                    }
                }
                exports1.RequestType2 = RequestType2;
                class RequestType3 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 3);
                    }
                }
                exports1.RequestType3 = RequestType3;
                class RequestType4 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 4);
                    }
                }
                exports1.RequestType4 = RequestType4;
                class RequestType5 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 5);
                    }
                }
                exports1.RequestType5 = RequestType5;
                class RequestType6 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 6);
                    }
                }
                exports1.RequestType6 = RequestType6;
                class RequestType7 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 7);
                    }
                }
                exports1.RequestType7 = RequestType7;
                class RequestType8 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 8);
                    }
                }
                exports1.RequestType8 = RequestType8;
                class RequestType9 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 9);
                    }
                }
                exports1.RequestType9 = RequestType9;
                class NotificationType extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.NotificationType = NotificationType;
                class NotificationType0 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 0);
                    }
                }
                exports1.NotificationType0 = NotificationType0;
                class NotificationType1 extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.NotificationType1 = NotificationType1;
                class NotificationType2 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 2);
                    }
                }
                exports1.NotificationType2 = NotificationType2;
                class NotificationType3 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 3);
                    }
                }
                exports1.NotificationType3 = NotificationType3;
                class NotificationType4 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 4);
                    }
                }
                exports1.NotificationType4 = NotificationType4;
                class NotificationType5 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 5);
                    }
                }
                exports1.NotificationType5 = NotificationType5;
                class NotificationType6 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 6);
                    }
                }
                exports1.NotificationType6 = NotificationType6;
                class NotificationType7 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 7);
                    }
                }
                exports1.NotificationType7 = NotificationType7;
                class NotificationType8 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 8);
                    }
                }
                exports1.NotificationType8 = NotificationType8;
                class NotificationType9 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 9);
                    }
                }
                exports1.NotificationType9 = NotificationType9;
                var Message;
                (function(Message) {
                    /**
     * Tests if the given message is a request message
     */ function isRequest(message) {
                        const candidate = message;
                        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
                    }
                    Message.isRequest = isRequest;
                    /**
     * Tests if the given message is a notification message
     */ function isNotification(message) {
                        const candidate = message;
                        return candidate && is.string(candidate.method) && message.id === void 0;
                    }
                    Message.isNotification = isNotification;
                    /**
     * Tests if the given message is a response message
     */ function isResponse(message) {
                        const candidate = message;
                        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
                    }
                    Message.isResponse = isResponse;
                })(Message = exports1.Message || (exports1.Message = {}));
            /***/ },
            /***/ 5706: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                let _ral;
                function RAL() {
                    if (_ral === undefined) {
                        throw new Error(`No runtime abstraction layer installed`);
                    }
                    return _ral;
                }
                (function(RAL) {
                    function install(ral) {
                        if (ral === undefined) {
                            throw new Error(`No runtime abstraction layer provided`);
                        }
                        _ral = ral;
                    }
                    RAL.install = install;
                })(RAL || (RAL = {}));
                exports1["default"] = RAL;
            /***/ },
            /***/ 2339: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_417747__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Semaphore = void 0;
                const ral_1 = __nested_webpack_require_417747__(5706);
                class Semaphore {
                    lock(thunk) {
                        return new Promise((resolve, reject)=>{
                            this._waiting.push({
                                thunk,
                                resolve,
                                reject
                            });
                            this.runNext();
                        });
                    }
                    get active() {
                        return this._active;
                    }
                    runNext() {
                        if (this._waiting.length === 0 || this._active === this._capacity) {
                            return;
                        }
                        (0, ral_1.default)().timer.setImmediate(()=>this.doRunNext());
                    }
                    doRunNext() {
                        if (this._waiting.length === 0 || this._active === this._capacity) {
                            return;
                        }
                        const next = this._waiting.shift();
                        this._active++;
                        if (this._active > this._capacity) {
                            throw new Error(`To many thunks active`);
                        }
                        try {
                            const result = next.thunk();
                            if (result instanceof Promise) {
                                result.then((value)=>{
                                    this._active--;
                                    next.resolve(value);
                                    this.runNext();
                                }, (err)=>{
                                    this._active--;
                                    next.reject(err);
                                    this.runNext();
                                });
                            } else {
                                this._active--;
                                next.resolve(result);
                                this.runNext();
                            }
                        } catch (err) {
                            this._active--;
                            next.reject(err);
                            this.runNext();
                        }
                    }
                    constructor(capacity = 1){
                        if (capacity <= 0) {
                            throw new Error('Capacity must be greater than 0');
                        }
                        this._capacity = capacity;
                        this._active = 0;
                        this._waiting = [];
                    }
                }
                exports1.Semaphore = Semaphore;
            /***/ },
            /***/ 178: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_421189__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.SharedArrayReceiverStrategy = exports1.SharedArraySenderStrategy = void 0;
                const cancellation_1 = __nested_webpack_require_421189__(415);
                var CancellationState;
                (function(CancellationState) {
                    CancellationState.Continue = 0;
                    CancellationState.Cancelled = 1;
                })(CancellationState || (CancellationState = {}));
                class SharedArraySenderStrategy {
                    enableCancellation(request) {
                        if (request.id === null) {
                            return;
                        }
                        const buffer = new SharedArrayBuffer(4);
                        const data = new Int32Array(buffer, 0, 1);
                        data[0] = CancellationState.Continue;
                        this.buffers.set(request.id, buffer);
                        request.$cancellationData = buffer;
                    }
                    async sendCancellation(_conn, id) {
                        const buffer = this.buffers.get(id);
                        if (buffer === undefined) {
                            return;
                        }
                        const data = new Int32Array(buffer, 0, 1);
                        Atomics.store(data, 0, CancellationState.Cancelled);
                    }
                    cleanup(id) {
                        this.buffers.delete(id);
                    }
                    dispose() {
                        this.buffers.clear();
                    }
                    constructor(){
                        this.buffers = new Map();
                    }
                }
                exports1.SharedArraySenderStrategy = SharedArraySenderStrategy;
                class SharedArrayBufferCancellationToken {
                    get isCancellationRequested() {
                        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
                    }
                    get onCancellationRequested() {
                        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
                    }
                    constructor(buffer){
                        this.data = new Int32Array(buffer, 0, 1);
                    }
                }
                class SharedArrayBufferCancellationTokenSource {
                    cancel() {}
                    dispose() {}
                    constructor(buffer){
                        this.token = new SharedArrayBufferCancellationToken(buffer);
                    }
                }
                class SharedArrayReceiverStrategy {
                    createCancellationTokenSource(request) {
                        const buffer = request.$cancellationData;
                        if (buffer === undefined) {
                            return new cancellation_1.CancellationTokenSource();
                        }
                        return new SharedArrayBufferCancellationTokenSource(buffer);
                    }
                    constructor(){
                        this.kind = 'request';
                    }
                }
                exports1.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
            /***/ },
            /***/ 294: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_425092__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createProtocolConnection = void 0;
                const browser_1 = __nested_webpack_require_425092__(1200);
                __exportStar(__nested_webpack_require_425092__(1200), exports1);
                __exportStar(__nested_webpack_require_425092__(9372), exports1);
                function createProtocolConnection(reader, writer, logger, options) {
                    return (0, browser_1.createMessageConnection)(reader, writer, logger, options);
                }
                exports1.createProtocolConnection = createProtocolConnection;
            /***/ },
            /***/ 9372: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_427281__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LSPErrorCodes = exports1.createProtocolConnection = void 0;
                __exportStar(__nested_webpack_require_427281__(5953), exports1);
                __exportStar(__nested_webpack_require_427281__(4767), exports1);
                __exportStar(__nested_webpack_require_427281__(8599), exports1);
                __exportStar(__nested_webpack_require_427281__(6525), exports1);
                var connection_1 = __nested_webpack_require_427281__(2798);
                Object.defineProperty(exports1, "createProtocolConnection", {
                    enumerable: true,
                    get: function() {
                        return connection_1.createProtocolConnection;
                    }
                });
                var LSPErrorCodes;
                (function(LSPErrorCodes) {
                    /**
    * This is the start range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */ LSPErrorCodes.lspReservedErrorRangeStart = -32899;
                    /**
     * A request failed but it was syntactically correct, e.g the
     * method name was known and the parameters were valid. The error
     * message should contain human readable information about why
     * the request failed.
     *
     * @since 3.17.0
     */ LSPErrorCodes.RequestFailed = -32803;
                    /**
     * The server cancelled the request. This error code should
     * only be used for requests that explicitly support being
     * server cancellable.
     *
     * @since 3.17.0
     */ LSPErrorCodes.ServerCancelled = -32802;
                    /**
     * The server detected that the content of a document got
     * modified outside normal conditions. A server should
     * NOT send this error code if it detects a content change
     * in it unprocessed messages. The result even computed
     * on an older state might still be useful for the client.
     *
     * If a client decides that a result is not of any use anymore
     * the client should cancel the request.
     */ LSPErrorCodes.ContentModified = -32801;
                    /**
     * The client has canceled a request and a server as detected
     * the cancel.
     */ LSPErrorCodes.RequestCancelled = -32800;
                    /**
    * This is the end range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */ LSPErrorCodes.lspReservedErrorRangeEnd = -32800;
                })(LSPErrorCodes = exports1.LSPErrorCodes || (exports1.LSPErrorCodes = {}));
            /***/ },
            /***/ 2798: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_431432__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createProtocolConnection = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_431432__(5953);
                function createProtocolConnection(input, output, logger, options) {
                    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
                        options = {
                            connectionStrategy: options
                        };
                    }
                    return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
                }
                exports1.createProtocolConnection = createProtocolConnection;
            /***/ },
            /***/ 8599: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_432669__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ProtocolNotificationType = exports1.ProtocolNotificationType0 = exports1.ProtocolRequestType = exports1.ProtocolRequestType0 = exports1.RegistrationType = exports1.MessageDirection = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_432669__(5953);
                var MessageDirection;
                (function(MessageDirection) {
                    MessageDirection["clientToServer"] = "clientToServer";
                    MessageDirection["serverToClient"] = "serverToClient";
                    MessageDirection["both"] = "both";
                })(MessageDirection = exports1.MessageDirection || (exports1.MessageDirection = {}));
                class RegistrationType {
                    constructor(method){
                        this.method = method;
                    }
                }
                exports1.RegistrationType = RegistrationType;
                class ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {
                    constructor(method){
                        super(method);
                    }
                }
                exports1.ProtocolRequestType0 = ProtocolRequestType0;
                class ProtocolRequestType extends vscode_jsonrpc_1.RequestType {
                    constructor(method){
                        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
                    }
                }
                exports1.ProtocolRequestType = ProtocolRequestType;
                class ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {
                    constructor(method){
                        super(method);
                    }
                }
                exports1.ProtocolNotificationType0 = ProtocolNotificationType0;
                class ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {
                    constructor(method){
                        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
                    }
                }
                exports1.ProtocolNotificationType = ProtocolNotificationType;
            /***/ },
            /***/ 4434: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_435395__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.CallHierarchyOutgoingCallsRequest = exports1.CallHierarchyIncomingCallsRequest = exports1.CallHierarchyPrepareRequest = void 0;
                const messages_1 = __nested_webpack_require_435395__(8599);
                /**
 * A request to result a `CallHierarchyItem` in a document at a given position.
 * Can be used as an input to an incoming or outgoing call hierarchy.
 *
 * @since 3.16.0
 */ var CallHierarchyPrepareRequest;
                (function(CallHierarchyPrepareRequest) {
                    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';
                    CallHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);
                })(CallHierarchyPrepareRequest = exports1.CallHierarchyPrepareRequest || (exports1.CallHierarchyPrepareRequest = {}));
                /**
 * A request to resolve the incoming calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */ var CallHierarchyIncomingCallsRequest;
                (function(CallHierarchyIncomingCallsRequest) {
                    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';
                    CallHierarchyIncomingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);
                })(CallHierarchyIncomingCallsRequest = exports1.CallHierarchyIncomingCallsRequest || (exports1.CallHierarchyIncomingCallsRequest = {}));
                /**
 * A request to resolve the outgoing calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */ var CallHierarchyOutgoingCallsRequest;
                (function(CallHierarchyOutgoingCallsRequest) {
                    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';
                    CallHierarchyOutgoingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);
                })(CallHierarchyOutgoingCallsRequest = exports1.CallHierarchyOutgoingCallsRequest || (exports1.CallHierarchyOutgoingCallsRequest = {}));
            /***/ },
            /***/ 7908: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_438426__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ColorPresentationRequest = exports1.DocumentColorRequest = void 0;
                const messages_1 = __nested_webpack_require_438426__(8599);
                /**
 * A request to list all color symbols found in a given text document. The request's
 * parameter is of type {@link DocumentColorParams} the
 * response is of type {@link ColorInformation ColorInformation[]} or a Thenable
 * that resolves to such.
 */ var DocumentColorRequest;
                (function(DocumentColorRequest) {
                    DocumentColorRequest.method = 'textDocument/documentColor';
                    DocumentColorRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);
                })(DocumentColorRequest = exports1.DocumentColorRequest || (exports1.DocumentColorRequest = {}));
                /**
 * A request to list all presentation for a color. The request's
 * parameter is of type {@link ColorPresentationParams} the
 * response is of type {@link ColorInformation ColorInformation[]} or a Thenable
 * that resolves to such.
 */ var ColorPresentationRequest;
                (function(ColorPresentationRequest) {
                    ColorPresentationRequest.method = 'textDocument/colorPresentation';
                    ColorPresentationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ColorPresentationRequest.type = new messages_1.ProtocolRequestType(ColorPresentationRequest.method);
                })(ColorPresentationRequest = exports1.ColorPresentationRequest || (exports1.ColorPresentationRequest = {}));
            /***/ },
            /***/ 5442: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_440729__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ConfigurationRequest = void 0;
                const messages_1 = __nested_webpack_require_440729__(8599);
                //---- Get Configuration request ----
                /**
 * The 'workspace/configuration' request is sent from the server to the client to fetch a certain
 * configuration setting.
 *
 * This pull model replaces the old push model were the client signaled configuration change via an
 * event. If the server still needs to react to configuration changes (since the server caches the
 * result of `workspace/configuration` requests) the server should register for an empty configuration
 * change event and empty the cache if such an event is received.
 */ var ConfigurationRequest;
                (function(ConfigurationRequest) {
                    ConfigurationRequest.method = 'workspace/configuration';
                    ConfigurationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ConfigurationRequest.type = new messages_1.ProtocolRequestType(ConfigurationRequest.method);
                })(ConfigurationRequest = exports1.ConfigurationRequest || (exports1.ConfigurationRequest = {}));
            /***/ },
            /***/ 7210: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_442511__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DeclarationRequest = void 0;
                const messages_1 = __nested_webpack_require_442511__(8599);
                // @ts-ignore: to avoid inlining LocationLink as dynamic import
                let __noDynamicImport;
                /**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositionParams]
 * (#TextDocumentPositionParams) the response is of type {@link Declaration}
 * or a typed array of {@link DeclarationLink} or a Thenable that resolves
 * to such.
 */ var DeclarationRequest;
                (function(DeclarationRequest) {
                    DeclarationRequest.method = 'textDocument/declaration';
                    DeclarationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);
                })(DeclarationRequest = exports1.DeclarationRequest || (exports1.DeclarationRequest = {}));
            /***/ },
            /***/ 5692: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_444176__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DiagnosticRefreshRequest = exports1.WorkspaceDiagnosticRequest = exports1.DocumentDiagnosticRequest = exports1.DocumentDiagnosticReportKind = exports1.DiagnosticServerCancellationData = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_444176__(5953);
                const Is = __nested_webpack_require_444176__(2523);
                const messages_1 = __nested_webpack_require_444176__(8599);
                /**
 * @since 3.17.0
 */ var DiagnosticServerCancellationData;
                (function(DiagnosticServerCancellationData) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.boolean(candidate.retriggerRequest);
                    }
                    DiagnosticServerCancellationData.is = is;
                })(DiagnosticServerCancellationData = exports1.DiagnosticServerCancellationData || (exports1.DiagnosticServerCancellationData = {}));
                /**
 * The document diagnostic report kinds.
 *
 * @since 3.17.0
 */ var DocumentDiagnosticReportKind;
                (function(DocumentDiagnosticReportKind) {
                    /**
     * A diagnostic report with a full
     * set of problems.
     */ DocumentDiagnosticReportKind.Full = 'full';
                    /**
     * A report indicating that the last
     * returned report is still accurate.
     */ DocumentDiagnosticReportKind.Unchanged = 'unchanged';
                })(DocumentDiagnosticReportKind = exports1.DocumentDiagnosticReportKind || (exports1.DocumentDiagnosticReportKind = {}));
                /**
 * The document diagnostic request definition.
 *
 * @since 3.17.0
 */ var DocumentDiagnosticRequest;
                (function(DocumentDiagnosticRequest) {
                    DocumentDiagnosticRequest.method = 'textDocument/diagnostic';
                    DocumentDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentDiagnosticRequest.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest.method);
                    DocumentDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
                })(DocumentDiagnosticRequest = exports1.DocumentDiagnosticRequest || (exports1.DocumentDiagnosticRequest = {}));
                /**
 * The workspace diagnostic request definition.
 *
 * @since 3.17.0
 */ var WorkspaceDiagnosticRequest;
                (function(WorkspaceDiagnosticRequest) {
                    WorkspaceDiagnosticRequest.method = 'workspace/diagnostic';
                    WorkspaceDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkspaceDiagnosticRequest.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest.method);
                    WorkspaceDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
                })(WorkspaceDiagnosticRequest = exports1.WorkspaceDiagnosticRequest || (exports1.WorkspaceDiagnosticRequest = {}));
                /**
 * The diagnostic refresh request definition.
 *
 * @since 3.17.0
 */ var DiagnosticRefreshRequest;
                (function(DiagnosticRefreshRequest) {
                    DiagnosticRefreshRequest.method = `workspace/diagnostic/refresh`;
                    DiagnosticRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    DiagnosticRefreshRequest.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest.method);
                })(DiagnosticRefreshRequest = exports1.DiagnosticRefreshRequest || (exports1.DiagnosticRefreshRequest = {}));
            /***/ },
            /***/ 6190: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_448420__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WillDeleteFilesRequest = exports1.DidDeleteFilesNotification = exports1.DidRenameFilesNotification = exports1.WillRenameFilesRequest = exports1.DidCreateFilesNotification = exports1.WillCreateFilesRequest = exports1.FileOperationPatternKind = void 0;
                const messages_1 = __nested_webpack_require_448420__(8599);
                /**
 * A pattern kind describing if a glob pattern matches a file a folder or
 * both.
 *
 * @since 3.16.0
 */ var FileOperationPatternKind;
                (function(FileOperationPatternKind) {
                    /**
     * The pattern matches a file only.
     */ FileOperationPatternKind.file = 'file';
                    /**
     * The pattern matches a folder only.
     */ FileOperationPatternKind.folder = 'folder';
                })(FileOperationPatternKind = exports1.FileOperationPatternKind || (exports1.FileOperationPatternKind = {}));
                /**
 * The will create files request is sent from the client to the server before files are actually
 * created as long as the creation is triggered from within the client.
 *
 * The request can return a `WorkspaceEdit` which will be applied to workspace before the
 * files are created. Hence the `WorkspaceEdit` can not manipulate the content of the file
 * to be created.
 *
 * @since 3.16.0
 */ var WillCreateFilesRequest;
                (function(WillCreateFilesRequest) {
                    WillCreateFilesRequest.method = 'workspace/willCreateFiles';
                    WillCreateFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillCreateFilesRequest.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest.method);
                })(WillCreateFilesRequest = exports1.WillCreateFilesRequest || (exports1.WillCreateFilesRequest = {}));
                /**
 * The did create files notification is sent from the client to the server when
 * files were created from within the client.
 *
 * @since 3.16.0
 */ var DidCreateFilesNotification;
                (function(DidCreateFilesNotification) {
                    DidCreateFilesNotification.method = 'workspace/didCreateFiles';
                    DidCreateFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidCreateFilesNotification.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification.method);
                })(DidCreateFilesNotification = exports1.DidCreateFilesNotification || (exports1.DidCreateFilesNotification = {}));
                /**
 * The will rename files request is sent from the client to the server before files are actually
 * renamed as long as the rename is triggered from within the client.
 *
 * @since 3.16.0
 */ var WillRenameFilesRequest;
                (function(WillRenameFilesRequest) {
                    WillRenameFilesRequest.method = 'workspace/willRenameFiles';
                    WillRenameFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillRenameFilesRequest.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest.method);
                })(WillRenameFilesRequest = exports1.WillRenameFilesRequest || (exports1.WillRenameFilesRequest = {}));
                /**
 * The did rename files notification is sent from the client to the server when
 * files were renamed from within the client.
 *
 * @since 3.16.0
 */ var DidRenameFilesNotification;
                (function(DidRenameFilesNotification) {
                    DidRenameFilesNotification.method = 'workspace/didRenameFiles';
                    DidRenameFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidRenameFilesNotification.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification.method);
                })(DidRenameFilesNotification = exports1.DidRenameFilesNotification || (exports1.DidRenameFilesNotification = {}));
                /**
 * The will delete files request is sent from the client to the server before files are actually
 * deleted as long as the deletion is triggered from within the client.
 *
 * @since 3.16.0
 */ var DidDeleteFilesNotification;
                (function(DidDeleteFilesNotification) {
                    DidDeleteFilesNotification.method = 'workspace/didDeleteFiles';
                    DidDeleteFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidDeleteFilesNotification.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification.method);
                })(DidDeleteFilesNotification = exports1.DidDeleteFilesNotification || (exports1.DidDeleteFilesNotification = {}));
                /**
 * The did delete files notification is sent from the client to the server when
 * files were deleted from within the client.
 *
 * @since 3.16.0
 */ var WillDeleteFilesRequest;
                (function(WillDeleteFilesRequest) {
                    WillDeleteFilesRequest.method = 'workspace/willDeleteFiles';
                    WillDeleteFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillDeleteFilesRequest.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest.method);
                })(WillDeleteFilesRequest = exports1.WillDeleteFilesRequest || (exports1.WillDeleteFilesRequest = {}));
            /***/ },
            /***/ 7029: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_454425__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.FoldingRangeRequest = void 0;
                const messages_1 = __nested_webpack_require_454425__(8599);
                /**
 * A request to provide folding ranges in a document. The request's
 * parameter is of type {@link FoldingRangeParams}, the
 * response is of type {@link FoldingRangeList} or a Thenable
 * that resolves to such.
 */ var FoldingRangeRequest;
                (function(FoldingRangeRequest) {
                    FoldingRangeRequest.method = 'textDocument/foldingRange';
                    FoldingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);
                })(FoldingRangeRequest = exports1.FoldingRangeRequest || (exports1.FoldingRangeRequest = {}));
            /***/ },
            /***/ 9380: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_455864__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ImplementationRequest = void 0;
                const messages_1 = __nested_webpack_require_455864__(8599);
                // @ts-ignore: to avoid inlining LocationLink as dynamic import
                let __noDynamicImport;
                /**
 * A request to resolve the implementation locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositionParams]
 * (#TextDocumentPositionParams) the response is of type {@link Definition} or a
 * Thenable that resolves to such.
 */ var ImplementationRequest;
                (function(ImplementationRequest) {
                    ImplementationRequest.method = 'textDocument/implementation';
                    ImplementationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);
                })(ImplementationRequest = exports1.ImplementationRequest || (exports1.ImplementationRequest = {}));
            /***/ },
            /***/ 6315: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_457513__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.InlayHintRefreshRequest = exports1.InlayHintResolveRequest = exports1.InlayHintRequest = void 0;
                const messages_1 = __nested_webpack_require_457513__(8599);
                /**
 * A request to provide inlay hints in a document. The request's parameter is of
 * type {@link InlayHintsParams}, the response is of type
 * {@link InlayHint InlayHint[]} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */ var InlayHintRequest;
                (function(InlayHintRequest) {
                    InlayHintRequest.method = 'textDocument/inlayHint';
                    InlayHintRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlayHintRequest.type = new messages_1.ProtocolRequestType(InlayHintRequest.method);
                })(InlayHintRequest = exports1.InlayHintRequest || (exports1.InlayHintRequest = {}));
                /**
 * A request to resolve additional properties for an inlay hint.
 * The request's parameter is of type {@link InlayHint}, the response is
 * of type {@link InlayHint} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */ var InlayHintResolveRequest;
                (function(InlayHintResolveRequest) {
                    InlayHintResolveRequest.method = 'inlayHint/resolve';
                    InlayHintResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlayHintResolveRequest.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest.method);
                })(InlayHintResolveRequest = exports1.InlayHintResolveRequest || (exports1.InlayHintResolveRequest = {}));
                /**
 * @since 3.17.0
 */ var InlayHintRefreshRequest;
                (function(InlayHintRefreshRequest) {
                    InlayHintRefreshRequest.method = `workspace/inlayHint/refresh`;
                    InlayHintRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    InlayHintRefreshRequest.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest.method);
                })(InlayHintRefreshRequest = exports1.InlayHintRefreshRequest || (exports1.InlayHintRefreshRequest = {}));
            /***/ },
            /***/ 7425: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_460316__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.InlineValueRefreshRequest = exports1.InlineValueRequest = void 0;
                const messages_1 = __nested_webpack_require_460316__(8599);
                /**
 * A request to provide inline values in a document. The request's parameter is of
 * type {@link InlineValueParams}, the response is of type
 * {@link InlineValue InlineValue[]} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */ var InlineValueRequest;
                (function(InlineValueRequest) {
                    InlineValueRequest.method = 'textDocument/inlineValue';
                    InlineValueRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlineValueRequest.type = new messages_1.ProtocolRequestType(InlineValueRequest.method);
                })(InlineValueRequest = exports1.InlineValueRequest || (exports1.InlineValueRequest = {}));
                /**
 * @since 3.17.0
 */ var InlineValueRefreshRequest;
                (function(InlineValueRefreshRequest) {
                    InlineValueRefreshRequest.method = `workspace/inlineValue/refresh`;
                    InlineValueRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    InlineValueRefreshRequest.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest.method);
                })(InlineValueRefreshRequest = exports1.InlineValueRefreshRequest || (exports1.InlineValueRefreshRequest = {}));
            /***/ },
            /***/ 6525: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_462382__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WorkspaceSymbolRequest = exports1.CodeActionResolveRequest = exports1.CodeActionRequest = exports1.DocumentSymbolRequest = exports1.DocumentHighlightRequest = exports1.ReferencesRequest = exports1.DefinitionRequest = exports1.SignatureHelpRequest = exports1.SignatureHelpTriggerKind = exports1.HoverRequest = exports1.CompletionResolveRequest = exports1.CompletionRequest = exports1.CompletionTriggerKind = exports1.PublishDiagnosticsNotification = exports1.WatchKind = exports1.RelativePattern = exports1.FileChangeType = exports1.DidChangeWatchedFilesNotification = exports1.WillSaveTextDocumentWaitUntilRequest = exports1.WillSaveTextDocumentNotification = exports1.TextDocumentSaveReason = exports1.DidSaveTextDocumentNotification = exports1.DidCloseTextDocumentNotification = exports1.DidChangeTextDocumentNotification = exports1.TextDocumentContentChangeEvent = exports1.DidOpenTextDocumentNotification = exports1.TextDocumentSyncKind = exports1.TelemetryEventNotification = exports1.LogMessageNotification = exports1.ShowMessageRequest = exports1.ShowMessageNotification = exports1.MessageType = exports1.DidChangeConfigurationNotification = exports1.ExitNotification = exports1.ShutdownRequest = exports1.InitializedNotification = exports1.InitializeErrorCodes = exports1.InitializeRequest = exports1.WorkDoneProgressOptions = exports1.TextDocumentRegistrationOptions = exports1.StaticRegistrationOptions = exports1.PositionEncodingKind = exports1.FailureHandlingKind = exports1.ResourceOperationKind = exports1.UnregistrationRequest = exports1.RegistrationRequest = exports1.DocumentSelector = exports1.NotebookCellTextDocumentFilter = exports1.NotebookDocumentFilter = exports1.TextDocumentFilter = void 0;
                exports1.TypeHierarchySubtypesRequest = exports1.TypeHierarchyPrepareRequest = exports1.MonikerRequest = exports1.MonikerKind = exports1.UniquenessLevel = exports1.WillDeleteFilesRequest = exports1.DidDeleteFilesNotification = exports1.WillRenameFilesRequest = exports1.DidRenameFilesNotification = exports1.WillCreateFilesRequest = exports1.DidCreateFilesNotification = exports1.FileOperationPatternKind = exports1.LinkedEditingRangeRequest = exports1.ShowDocumentRequest = exports1.SemanticTokensRegistrationType = exports1.SemanticTokensRefreshRequest = exports1.SemanticTokensRangeRequest = exports1.SemanticTokensDeltaRequest = exports1.SemanticTokensRequest = exports1.TokenFormat = exports1.CallHierarchyPrepareRequest = exports1.CallHierarchyOutgoingCallsRequest = exports1.CallHierarchyIncomingCallsRequest = exports1.WorkDoneProgressCancelNotification = exports1.WorkDoneProgressCreateRequest = exports1.WorkDoneProgress = exports1.SelectionRangeRequest = exports1.DeclarationRequest = exports1.FoldingRangeRequest = exports1.ColorPresentationRequest = exports1.DocumentColorRequest = exports1.ConfigurationRequest = exports1.DidChangeWorkspaceFoldersNotification = exports1.WorkspaceFoldersRequest = exports1.TypeDefinitionRequest = exports1.ImplementationRequest = exports1.ApplyWorkspaceEditRequest = exports1.ExecuteCommandRequest = exports1.PrepareRenameRequest = exports1.RenameRequest = exports1.PrepareSupportDefaultBehavior = exports1.DocumentOnTypeFormattingRequest = exports1.DocumentRangeFormattingRequest = exports1.DocumentFormattingRequest = exports1.DocumentLinkResolveRequest = exports1.DocumentLinkRequest = exports1.CodeLensRefreshRequest = exports1.CodeLensResolveRequest = exports1.CodeLensRequest = exports1.WorkspaceSymbolResolveRequest = void 0;
                exports1.DidCloseNotebookDocumentNotification = exports1.DidSaveNotebookDocumentNotification = exports1.DidChangeNotebookDocumentNotification = exports1.NotebookCellArrayChange = exports1.DidOpenNotebookDocumentNotification = exports1.NotebookDocumentSyncRegistrationType = exports1.NotebookDocument = exports1.NotebookCell = exports1.ExecutionSummary = exports1.NotebookCellKind = exports1.DiagnosticRefreshRequest = exports1.WorkspaceDiagnosticRequest = exports1.DocumentDiagnosticRequest = exports1.DocumentDiagnosticReportKind = exports1.DiagnosticServerCancellationData = exports1.InlayHintRefreshRequest = exports1.InlayHintResolveRequest = exports1.InlayHintRequest = exports1.InlineValueRefreshRequest = exports1.InlineValueRequest = exports1.TypeHierarchySupertypesRequest = void 0;
                const messages_1 = __nested_webpack_require_462382__(8599);
                const vscode_languageserver_types_1 = __nested_webpack_require_462382__(4767);
                const Is = __nested_webpack_require_462382__(2523);
                const protocol_implementation_1 = __nested_webpack_require_462382__(9380);
                Object.defineProperty(exports1, "ImplementationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_implementation_1.ImplementationRequest;
                    }
                });
                const protocol_typeDefinition_1 = __nested_webpack_require_462382__(8642);
                Object.defineProperty(exports1, "TypeDefinitionRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeDefinition_1.TypeDefinitionRequest;
                    }
                });
                const protocol_workspaceFolder_1 = __nested_webpack_require_462382__(3402);
                Object.defineProperty(exports1, "WorkspaceFoldersRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
                    }
                });
                Object.defineProperty(exports1, "DidChangeWorkspaceFoldersNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
                    }
                });
                const protocol_configuration_1 = __nested_webpack_require_462382__(5442);
                Object.defineProperty(exports1, "ConfigurationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_configuration_1.ConfigurationRequest;
                    }
                });
                const protocol_colorProvider_1 = __nested_webpack_require_462382__(7908);
                Object.defineProperty(exports1, "DocumentColorRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_colorProvider_1.DocumentColorRequest;
                    }
                });
                Object.defineProperty(exports1, "ColorPresentationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_colorProvider_1.ColorPresentationRequest;
                    }
                });
                const protocol_foldingRange_1 = __nested_webpack_require_462382__(7029);
                Object.defineProperty(exports1, "FoldingRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_foldingRange_1.FoldingRangeRequest;
                    }
                });
                const protocol_declaration_1 = __nested_webpack_require_462382__(7210);
                Object.defineProperty(exports1, "DeclarationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_declaration_1.DeclarationRequest;
                    }
                });
                const protocol_selectionRange_1 = __nested_webpack_require_462382__(2392);
                Object.defineProperty(exports1, "SelectionRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_selectionRange_1.SelectionRangeRequest;
                    }
                });
                const protocol_progress_1 = __nested_webpack_require_462382__(7895);
                Object.defineProperty(exports1, "WorkDoneProgress", {
                    enumerable: true,
                    get: function() {
                        return protocol_progress_1.WorkDoneProgress;
                    }
                });
                Object.defineProperty(exports1, "WorkDoneProgressCreateRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_progress_1.WorkDoneProgressCreateRequest;
                    }
                });
                Object.defineProperty(exports1, "WorkDoneProgressCancelNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_progress_1.WorkDoneProgressCancelNotification;
                    }
                });
                const protocol_callHierarchy_1 = __nested_webpack_require_462382__(4434);
                Object.defineProperty(exports1, "CallHierarchyIncomingCallsRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
                    }
                });
                Object.defineProperty(exports1, "CallHierarchyOutgoingCallsRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
                    }
                });
                Object.defineProperty(exports1, "CallHierarchyPrepareRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
                    }
                });
                const protocol_semanticTokens_1 = __nested_webpack_require_462382__(8489);
                Object.defineProperty(exports1, "TokenFormat", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.TokenFormat;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensDeltaRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRangeRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRegistrationType", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRegistrationType;
                    }
                });
                const protocol_showDocument_1 = __nested_webpack_require_462382__(1541);
                Object.defineProperty(exports1, "ShowDocumentRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_showDocument_1.ShowDocumentRequest;
                    }
                });
                const protocol_linkedEditingRange_1 = __nested_webpack_require_462382__(527);
                Object.defineProperty(exports1, "LinkedEditingRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
                    }
                });
                const protocol_fileOperations_1 = __nested_webpack_require_462382__(6190);
                Object.defineProperty(exports1, "FileOperationPatternKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.FileOperationPatternKind;
                    }
                });
                Object.defineProperty(exports1, "DidCreateFilesNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.DidCreateFilesNotification;
                    }
                });
                Object.defineProperty(exports1, "WillCreateFilesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.WillCreateFilesRequest;
                    }
                });
                Object.defineProperty(exports1, "DidRenameFilesNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.DidRenameFilesNotification;
                    }
                });
                Object.defineProperty(exports1, "WillRenameFilesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.WillRenameFilesRequest;
                    }
                });
                Object.defineProperty(exports1, "DidDeleteFilesNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.DidDeleteFilesNotification;
                    }
                });
                Object.defineProperty(exports1, "WillDeleteFilesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.WillDeleteFilesRequest;
                    }
                });
                const protocol_moniker_1 = __nested_webpack_require_462382__(1964);
                Object.defineProperty(exports1, "UniquenessLevel", {
                    enumerable: true,
                    get: function() {
                        return protocol_moniker_1.UniquenessLevel;
                    }
                });
                Object.defineProperty(exports1, "MonikerKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_moniker_1.MonikerKind;
                    }
                });
                Object.defineProperty(exports1, "MonikerRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_moniker_1.MonikerRequest;
                    }
                });
                const protocol_typeHierarchy_1 = __nested_webpack_require_462382__(5318);
                Object.defineProperty(exports1, "TypeHierarchyPrepareRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
                    }
                });
                Object.defineProperty(exports1, "TypeHierarchySubtypesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
                    }
                });
                Object.defineProperty(exports1, "TypeHierarchySupertypesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
                    }
                });
                const protocol_inlineValue_1 = __nested_webpack_require_462382__(7425);
                Object.defineProperty(exports1, "InlineValueRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlineValue_1.InlineValueRequest;
                    }
                });
                Object.defineProperty(exports1, "InlineValueRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlineValue_1.InlineValueRefreshRequest;
                    }
                });
                const protocol_inlayHint_1 = __nested_webpack_require_462382__(6315);
                Object.defineProperty(exports1, "InlayHintRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlayHint_1.InlayHintRequest;
                    }
                });
                Object.defineProperty(exports1, "InlayHintResolveRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlayHint_1.InlayHintResolveRequest;
                    }
                });
                Object.defineProperty(exports1, "InlayHintRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlayHint_1.InlayHintRefreshRequest;
                    }
                });
                const protocol_diagnostic_1 = __nested_webpack_require_462382__(5692);
                Object.defineProperty(exports1, "DiagnosticServerCancellationData", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DiagnosticServerCancellationData;
                    }
                });
                Object.defineProperty(exports1, "DocumentDiagnosticReportKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DocumentDiagnosticReportKind;
                    }
                });
                Object.defineProperty(exports1, "DocumentDiagnosticRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DocumentDiagnosticRequest;
                    }
                });
                Object.defineProperty(exports1, "WorkspaceDiagnosticRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
                    }
                });
                Object.defineProperty(exports1, "DiagnosticRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DiagnosticRefreshRequest;
                    }
                });
                const protocol_notebook_1 = __nested_webpack_require_462382__(4460);
                Object.defineProperty(exports1, "NotebookCellKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookCellKind;
                    }
                });
                Object.defineProperty(exports1, "ExecutionSummary", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.ExecutionSummary;
                    }
                });
                Object.defineProperty(exports1, "NotebookCell", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookCell;
                    }
                });
                Object.defineProperty(exports1, "NotebookDocument", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookDocument;
                    }
                });
                Object.defineProperty(exports1, "NotebookDocumentSyncRegistrationType", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
                    }
                });
                Object.defineProperty(exports1, "DidOpenNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidOpenNotebookDocumentNotification;
                    }
                });
                Object.defineProperty(exports1, "NotebookCellArrayChange", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookCellArrayChange;
                    }
                });
                Object.defineProperty(exports1, "DidChangeNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidChangeNotebookDocumentNotification;
                    }
                });
                Object.defineProperty(exports1, "DidSaveNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidSaveNotebookDocumentNotification;
                    }
                });
                Object.defineProperty(exports1, "DidCloseNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidCloseNotebookDocumentNotification;
                    }
                });
                // @ts-ignore: to avoid inlining LocationLink as dynamic import
                let __noDynamicImport;
                /**
 * The TextDocumentFilter namespace provides helper functions to work with
 * {@link TextDocumentFilter} literals.
 *
 * @since 3.17.0
 */ var TextDocumentFilter;
                (function(TextDocumentFilter) {
                    function is(value) {
                        const candidate = value;
                        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
                    }
                    TextDocumentFilter.is = is;
                })(TextDocumentFilter = exports1.TextDocumentFilter || (exports1.TextDocumentFilter = {}));
                /**
 * The NotebookDocumentFilter namespace provides helper functions to work with
 * {@link NotebookDocumentFilter} literals.
 *
 * @since 3.17.0
 */ var NotebookDocumentFilter;
                (function(NotebookDocumentFilter) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
                    }
                    NotebookDocumentFilter.is = is;
                })(NotebookDocumentFilter = exports1.NotebookDocumentFilter || (exports1.NotebookDocumentFilter = {}));
                /**
 * The NotebookCellTextDocumentFilter namespace provides helper functions to work with
 * {@link NotebookCellTextDocumentFilter} literals.
 *
 * @since 3.17.0
 */ var NotebookCellTextDocumentFilter;
                (function(NotebookCellTextDocumentFilter) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === undefined || Is.string(candidate.language));
                    }
                    NotebookCellTextDocumentFilter.is = is;
                })(NotebookCellTextDocumentFilter = exports1.NotebookCellTextDocumentFilter || (exports1.NotebookCellTextDocumentFilter = {}));
                /**
 * The DocumentSelector namespace provides helper functions to work with
 * {@link DocumentSelector}s.
 */ var DocumentSelector;
                (function(DocumentSelector) {
                    function is(value) {
                        if (!Array.isArray(value)) {
                            return false;
                        }
                        for (let elem of value){
                            if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
                                return false;
                            }
                        }
                        return true;
                    }
                    DocumentSelector.is = is;
                })(DocumentSelector = exports1.DocumentSelector || (exports1.DocumentSelector = {}));
                /**
 * The `client/registerCapability` request is sent from the server to the client to register a new capability
 * handler on the client side.
 */ var RegistrationRequest;
                (function(RegistrationRequest) {
                    RegistrationRequest.method = 'client/registerCapability';
                    RegistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    RegistrationRequest.type = new messages_1.ProtocolRequestType(RegistrationRequest.method);
                })(RegistrationRequest = exports1.RegistrationRequest || (exports1.RegistrationRequest = {}));
                /**
 * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
 * handler on the client side.
 */ var UnregistrationRequest;
                (function(UnregistrationRequest) {
                    UnregistrationRequest.method = 'client/unregisterCapability';
                    UnregistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    UnregistrationRequest.type = new messages_1.ProtocolRequestType(UnregistrationRequest.method);
                })(UnregistrationRequest = exports1.UnregistrationRequest || (exports1.UnregistrationRequest = {}));
                var ResourceOperationKind;
                (function(ResourceOperationKind) {
                    /**
     * Supports creating new files and folders.
     */ ResourceOperationKind.Create = 'create';
                    /**
     * Supports renaming existing files and folders.
     */ ResourceOperationKind.Rename = 'rename';
                    /**
     * Supports deleting existing files and folders.
     */ ResourceOperationKind.Delete = 'delete';
                })(ResourceOperationKind = exports1.ResourceOperationKind || (exports1.ResourceOperationKind = {}));
                var FailureHandlingKind;
                (function(FailureHandlingKind) {
                    /**
     * Applying the workspace change is simply aborted if one of the changes provided
     * fails. All operations executed before the failing operation stay executed.
     */ FailureHandlingKind.Abort = 'abort';
                    /**
     * All operations are executed transactional. That means they either all
     * succeed or no changes at all are applied to the workspace.
     */ FailureHandlingKind.Transactional = 'transactional';
                    /**
     * If the workspace edit contains only textual file changes they are executed transactional.
     * If resource changes (create, rename or delete file) are part of the change the failure
     * handling strategy is abort.
     */ FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';
                    /**
     * The client tries to undo the operations already executed. But there is no
     * guarantee that this is succeeding.
     */ FailureHandlingKind.Undo = 'undo';
                })(FailureHandlingKind = exports1.FailureHandlingKind || (exports1.FailureHandlingKind = {}));
                /**
 * A set of predefined position encoding kinds.
 *
 * @since 3.17.0
 */ var PositionEncodingKind;
                (function(PositionEncodingKind) {
                    /**
     * Character offsets count UTF-8 code units (e.g. bytes).
     */ PositionEncodingKind.UTF8 = 'utf-8';
                    /**
     * Character offsets count UTF-16 code units.
     *
     * This is the default and must always be supported
     * by servers
     */ PositionEncodingKind.UTF16 = 'utf-16';
                    /**
     * Character offsets count UTF-32 code units.
     *
     * Implementation note: these are the same as Unicode codepoints,
     * so this `PositionEncodingKind` may also be used for an
     * encoding-agnostic representation of character offsets.
     */ PositionEncodingKind.UTF32 = 'utf-32';
                })(PositionEncodingKind = exports1.PositionEncodingKind || (exports1.PositionEncodingKind = {}));
                /**
 * The StaticRegistrationOptions namespace provides helper functions to work with
 * {@link StaticRegistrationOptions} literals.
 */ var StaticRegistrationOptions;
                (function(StaticRegistrationOptions) {
                    function hasId(value) {
                        const candidate = value;
                        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
                    }
                    StaticRegistrationOptions.hasId = hasId;
                })(StaticRegistrationOptions = exports1.StaticRegistrationOptions || (exports1.StaticRegistrationOptions = {}));
                /**
 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
 * {@link TextDocumentRegistrationOptions} literals.
 */ var TextDocumentRegistrationOptions;
                (function(TextDocumentRegistrationOptions) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
                    }
                    TextDocumentRegistrationOptions.is = is;
                })(TextDocumentRegistrationOptions = exports1.TextDocumentRegistrationOptions || (exports1.TextDocumentRegistrationOptions = {}));
                /**
 * The WorkDoneProgressOptions namespace provides helper functions to work with
 * {@link WorkDoneProgressOptions} literals.
 */ var WorkDoneProgressOptions;
                (function(WorkDoneProgressOptions) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));
                    }
                    WorkDoneProgressOptions.is = is;
                    function hasWorkDoneProgress(value) {
                        const candidate = value;
                        return candidate && Is.boolean(candidate.workDoneProgress);
                    }
                    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;
                })(WorkDoneProgressOptions = exports1.WorkDoneProgressOptions || (exports1.WorkDoneProgressOptions = {}));
                /**
 * The initialize request is sent from the client to the server.
 * It is sent once as the request after starting up the server.
 * The requests parameter is of type {@link InitializeParams}
 * the response if of type {@link InitializeResult} of a Thenable that
 * resolves to such.
 */ var InitializeRequest;
                (function(InitializeRequest) {
                    InitializeRequest.method = 'initialize';
                    InitializeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InitializeRequest.type = new messages_1.ProtocolRequestType(InitializeRequest.method);
                })(InitializeRequest = exports1.InitializeRequest || (exports1.InitializeRequest = {}));
                /**
 * Known error codes for an `InitializeErrorCodes`;
 */ var InitializeErrorCodes;
                (function(InitializeErrorCodes) {
                    /**
     * If the protocol version provided by the client can't be handled by the server.
     *
     * @deprecated This initialize error got replaced by client capabilities. There is
     * no version handshake in version 3.0x
     */ InitializeErrorCodes.unknownProtocolVersion = 1;
                })(InitializeErrorCodes = exports1.InitializeErrorCodes || (exports1.InitializeErrorCodes = {}));
                /**
 * The initialized notification is sent from the client to the
 * server after the client is fully initialized and the server
 * is allowed to send requests from the server to the client.
 */ var InitializedNotification;
                (function(InitializedNotification) {
                    InitializedNotification.method = 'initialized';
                    InitializedNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    InitializedNotification.type = new messages_1.ProtocolNotificationType(InitializedNotification.method);
                })(InitializedNotification = exports1.InitializedNotification || (exports1.InitializedNotification = {}));
                //---- Shutdown Method ----
                /**
 * A shutdown request is sent from the client to the server.
 * It is sent once when the client decides to shutdown the
 * server. The only notification that is sent after a shutdown request
 * is the exit event.
 */ var ShutdownRequest;
                (function(ShutdownRequest) {
                    ShutdownRequest.method = 'shutdown';
                    ShutdownRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ShutdownRequest.type = new messages_1.ProtocolRequestType0(ShutdownRequest.method);
                })(ShutdownRequest = exports1.ShutdownRequest || (exports1.ShutdownRequest = {}));
                //---- Exit Notification ----
                /**
 * The exit event is sent from the client to the server to
 * ask the server to exit its process.
 */ var ExitNotification;
                (function(ExitNotification) {
                    ExitNotification.method = 'exit';
                    ExitNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    ExitNotification.type = new messages_1.ProtocolNotificationType0(ExitNotification.method);
                })(ExitNotification = exports1.ExitNotification || (exports1.ExitNotification = {}));
                /**
 * The configuration change notification is sent from the client to the server
 * when the client's configuration has changed. The notification contains
 * the changed configuration as defined by the language client.
 */ var DidChangeConfigurationNotification;
                (function(DidChangeConfigurationNotification) {
                    DidChangeConfigurationNotification.method = 'workspace/didChangeConfiguration';
                    DidChangeConfigurationNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification.method);
                })(DidChangeConfigurationNotification = exports1.DidChangeConfigurationNotification || (exports1.DidChangeConfigurationNotification = {}));
                //---- Message show and log notifications ----
                /**
 * The message type
 */ var MessageType;
                (function(MessageType) {
                    /**
     * An error message.
     */ MessageType.Error = 1;
                    /**
     * A warning message.
     */ MessageType.Warning = 2;
                    /**
     * An information message.
     */ MessageType.Info = 3;
                    /**
     * A log message.
     */ MessageType.Log = 4;
                })(MessageType = exports1.MessageType || (exports1.MessageType = {}));
                /**
 * The show message notification is sent from a server to a client to ask
 * the client to display a particular message in the user interface.
 */ var ShowMessageNotification;
                (function(ShowMessageNotification) {
                    ShowMessageNotification.method = 'window/showMessage';
                    ShowMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    ShowMessageNotification.type = new messages_1.ProtocolNotificationType(ShowMessageNotification.method);
                })(ShowMessageNotification = exports1.ShowMessageNotification || (exports1.ShowMessageNotification = {}));
                /**
 * The show message request is sent from the server to the client to show a message
 * and a set of options actions to the user.
 */ var ShowMessageRequest;
                (function(ShowMessageRequest) {
                    ShowMessageRequest.method = 'window/showMessageRequest';
                    ShowMessageRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ShowMessageRequest.type = new messages_1.ProtocolRequestType(ShowMessageRequest.method);
                })(ShowMessageRequest = exports1.ShowMessageRequest || (exports1.ShowMessageRequest = {}));
                /**
 * The log message notification is sent from the server to the client to ask
 * the client to log a particular message.
 */ var LogMessageNotification;
                (function(LogMessageNotification) {
                    LogMessageNotification.method = 'window/logMessage';
                    LogMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    LogMessageNotification.type = new messages_1.ProtocolNotificationType(LogMessageNotification.method);
                })(LogMessageNotification = exports1.LogMessageNotification || (exports1.LogMessageNotification = {}));
                //---- Telemetry notification
                /**
 * The telemetry event notification is sent from the server to the client to ask
 * the client to log telemetry data.
 */ var TelemetryEventNotification;
                (function(TelemetryEventNotification) {
                    TelemetryEventNotification.method = 'telemetry/event';
                    TelemetryEventNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification.method);
                })(TelemetryEventNotification = exports1.TelemetryEventNotification || (exports1.TelemetryEventNotification = {}));
                /**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */ var TextDocumentSyncKind;
                (function(TextDocumentSyncKind) {
                    /**
     * Documents should not be synced at all.
     */ TextDocumentSyncKind.None = 0;
                    /**
     * Documents are synced by always sending the full content
     * of the document.
     */ TextDocumentSyncKind.Full = 1;
                    /**
     * Documents are synced by sending the full content on open.
     * After that only incremental updates to the document are
     * send.
     */ TextDocumentSyncKind.Incremental = 2;
                })(TextDocumentSyncKind = exports1.TextDocumentSyncKind || (exports1.TextDocumentSyncKind = {}));
                /**
 * The document open notification is sent from the client to the server to signal
 * newly opened text documents. The document's truth is now managed by the client
 * and the server must not try to read the document's truth using the document's
 * uri. Open in this sense means it is managed by the client. It doesn't necessarily
 * mean that its content is presented in an editor. An open notification must not
 * be sent more than once without a corresponding close notification send before.
 * This means open and close notification must be balanced and the max open count
 * is one.
 */ var DidOpenTextDocumentNotification;
                (function(DidOpenTextDocumentNotification) {
                    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';
                    DidOpenTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);
                })(DidOpenTextDocumentNotification = exports1.DidOpenTextDocumentNotification || (exports1.DidOpenTextDocumentNotification = {}));
                var TextDocumentContentChangeEvent;
                (function(TextDocumentContentChangeEvent) {
                    /**
     * Checks whether the information describes a delta event.
     */ function isIncremental(event) {
                        let candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range !== undefined && (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
                    }
                    TextDocumentContentChangeEvent.isIncremental = isIncremental;
                    /**
     * Checks whether the information describes a full replacement event.
     */ function isFull(event) {
                        let candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
                    }
                    TextDocumentContentChangeEvent.isFull = isFull;
                })(TextDocumentContentChangeEvent = exports1.TextDocumentContentChangeEvent || (exports1.TextDocumentContentChangeEvent = {}));
                /**
 * The document change notification is sent from the client to the server to signal
 * changes to a text document.
 */ var DidChangeTextDocumentNotification;
                (function(DidChangeTextDocumentNotification) {
                    DidChangeTextDocumentNotification.method = 'textDocument/didChange';
                    DidChangeTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);
                })(DidChangeTextDocumentNotification = exports1.DidChangeTextDocumentNotification || (exports1.DidChangeTextDocumentNotification = {}));
                /**
 * The document close notification is sent from the client to the server when
 * the document got closed in the client. The document's truth now exists where
 * the document's uri points to (e.g. if the document's uri is a file uri the
 * truth now exists on disk). As with the open notification the close notification
 * is about managing the document's content. Receiving a close notification
 * doesn't mean that the document was open in an editor before. A close
 * notification requires a previous open notification to be sent.
 */ var DidCloseTextDocumentNotification;
                (function(DidCloseTextDocumentNotification) {
                    DidCloseTextDocumentNotification.method = 'textDocument/didClose';
                    DidCloseTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);
                })(DidCloseTextDocumentNotification = exports1.DidCloseTextDocumentNotification || (exports1.DidCloseTextDocumentNotification = {}));
                /**
 * The document save notification is sent from the client to the server when
 * the document got saved in the client.
 */ var DidSaveTextDocumentNotification;
                (function(DidSaveTextDocumentNotification) {
                    DidSaveTextDocumentNotification.method = 'textDocument/didSave';
                    DidSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);
                })(DidSaveTextDocumentNotification = exports1.DidSaveTextDocumentNotification || (exports1.DidSaveTextDocumentNotification = {}));
                /**
 * Represents reasons why a text document is saved.
 */ var TextDocumentSaveReason;
                (function(TextDocumentSaveReason) {
                    /**
     * Manually triggered, e.g. by the user pressing save, by starting debugging,
     * or by an API call.
     */ TextDocumentSaveReason.Manual = 1;
                    /**
     * Automatic after a delay.
     */ TextDocumentSaveReason.AfterDelay = 2;
                    /**
     * When the editor lost focus.
     */ TextDocumentSaveReason.FocusOut = 3;
                })(TextDocumentSaveReason = exports1.TextDocumentSaveReason || (exports1.TextDocumentSaveReason = {}));
                /**
 * A document will save notification is sent from the client to the server before
 * the document is actually saved.
 */ var WillSaveTextDocumentNotification;
                (function(WillSaveTextDocumentNotification) {
                    WillSaveTextDocumentNotification.method = 'textDocument/willSave';
                    WillSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);
                })(WillSaveTextDocumentNotification = exports1.WillSaveTextDocumentNotification || (exports1.WillSaveTextDocumentNotification = {}));
                /**
 * A document will save request is sent from the client to the server before
 * the document is actually saved. The request can return an array of TextEdits
 * which will be applied to the text document before it is saved. Please note that
 * clients might drop results if computing the text edits took too long or if a
 * server constantly fails on this request. This is done to keep the save fast and
 * reliable.
 */ var WillSaveTextDocumentWaitUntilRequest;
                (function(WillSaveTextDocumentWaitUntilRequest) {
                    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';
                    WillSaveTextDocumentWaitUntilRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);
                })(WillSaveTextDocumentWaitUntilRequest = exports1.WillSaveTextDocumentWaitUntilRequest || (exports1.WillSaveTextDocumentWaitUntilRequest = {}));
                /**
 * The watched files notification is sent from the client to the server when
 * the client detects changes to file watched by the language client.
 */ var DidChangeWatchedFilesNotification;
                (function(DidChangeWatchedFilesNotification) {
                    DidChangeWatchedFilesNotification.method = 'workspace/didChangeWatchedFiles';
                    DidChangeWatchedFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification.method);
                })(DidChangeWatchedFilesNotification = exports1.DidChangeWatchedFilesNotification || (exports1.DidChangeWatchedFilesNotification = {}));
                /**
 * The file event type
 */ var FileChangeType;
                (function(FileChangeType) {
                    /**
     * The file got created.
     */ FileChangeType.Created = 1;
                    /**
     * The file got changed.
     */ FileChangeType.Changed = 2;
                    /**
     * The file got deleted.
     */ FileChangeType.Deleted = 3;
                })(FileChangeType = exports1.FileChangeType || (exports1.FileChangeType = {}));
                var RelativePattern;
                (function(RelativePattern) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
                    }
                    RelativePattern.is = is;
                })(RelativePattern = exports1.RelativePattern || (exports1.RelativePattern = {}));
                var WatchKind;
                (function(WatchKind) {
                    /**
     * Interested in create events.
     */ WatchKind.Create = 1;
                    /**
     * Interested in change events
     */ WatchKind.Change = 2;
                    /**
     * Interested in delete events
     */ WatchKind.Delete = 4;
                })(WatchKind = exports1.WatchKind || (exports1.WatchKind = {}));
                /**
 * Diagnostics notification are sent from the server to the client to signal
 * results of validation runs.
 */ var PublishDiagnosticsNotification;
                (function(PublishDiagnosticsNotification) {
                    PublishDiagnosticsNotification.method = 'textDocument/publishDiagnostics';
                    PublishDiagnosticsNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification.method);
                })(PublishDiagnosticsNotification = exports1.PublishDiagnosticsNotification || (exports1.PublishDiagnosticsNotification = {}));
                /**
 * How a completion was triggered
 */ var CompletionTriggerKind;
                (function(CompletionTriggerKind) {
                    /**
     * Completion was triggered by typing an identifier (24x7 code
     * complete), manual invocation (e.g Ctrl+Space) or via API.
     */ CompletionTriggerKind.Invoked = 1;
                    /**
     * Completion was triggered by a trigger character specified by
     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
     */ CompletionTriggerKind.TriggerCharacter = 2;
                    /**
     * Completion was re-triggered as current completion list is incomplete
     */ CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
                })(CompletionTriggerKind = exports1.CompletionTriggerKind || (exports1.CompletionTriggerKind = {}));
                /**
 * Request to request completion at a given text document position. The request's
 * parameter is of type {@link TextDocumentPosition} the response
 * is of type {@link CompletionItem CompletionItem[]} or {@link CompletionList}
 * or a Thenable that resolves to such.
 *
 * The request can delay the computation of the {@link CompletionItem.detail `detail`}
 * and {@link CompletionItem.documentation `documentation`} properties to the `completionItem/resolve`
 * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
 * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
 */ var CompletionRequest;
                (function(CompletionRequest) {
                    CompletionRequest.method = 'textDocument/completion';
                    CompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);
                })(CompletionRequest = exports1.CompletionRequest || (exports1.CompletionRequest = {}));
                /**
 * Request to resolve additional information for a given completion item.The request's
 * parameter is of type {@link CompletionItem} the response
 * is of type {@link CompletionItem} or a Thenable that resolves to such.
 */ var CompletionResolveRequest;
                (function(CompletionResolveRequest) {
                    CompletionResolveRequest.method = 'completionItem/resolve';
                    CompletionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);
                })(CompletionResolveRequest = exports1.CompletionResolveRequest || (exports1.CompletionResolveRequest = {}));
                /**
 * Request to request hover information at a given text document position. The request's
 * parameter is of type {@link TextDocumentPosition} the response is of
 * type {@link Hover} or a Thenable that resolves to such.
 */ var HoverRequest;
                (function(HoverRequest) {
                    HoverRequest.method = 'textDocument/hover';
                    HoverRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);
                })(HoverRequest = exports1.HoverRequest || (exports1.HoverRequest = {}));
                /**
 * How a signature help was triggered.
 *
 * @since 3.15.0
 */ var SignatureHelpTriggerKind;
                (function(SignatureHelpTriggerKind) {
                    /**
     * Signature help was invoked manually by the user or by a command.
     */ SignatureHelpTriggerKind.Invoked = 1;
                    /**
     * Signature help was triggered by a trigger character.
     */ SignatureHelpTriggerKind.TriggerCharacter = 2;
                    /**
     * Signature help was triggered by the cursor moving or by the document content changing.
     */ SignatureHelpTriggerKind.ContentChange = 3;
                })(SignatureHelpTriggerKind = exports1.SignatureHelpTriggerKind || (exports1.SignatureHelpTriggerKind = {}));
                var SignatureHelpRequest;
                (function(SignatureHelpRequest) {
                    SignatureHelpRequest.method = 'textDocument/signatureHelp';
                    SignatureHelpRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);
                })(SignatureHelpRequest = exports1.SignatureHelpRequest || (exports1.SignatureHelpRequest = {}));
                /**
 * A request to resolve the definition location of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the response is of either type {@link Definition}
 * or a typed array of {@link DefinitionLink} or a Thenable that resolves
 * to such.
 */ var DefinitionRequest;
                (function(DefinitionRequest) {
                    DefinitionRequest.method = 'textDocument/definition';
                    DefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);
                })(DefinitionRequest = exports1.DefinitionRequest || (exports1.DefinitionRequest = {}));
                /**
 * A request to resolve project-wide references for the symbol denoted
 * by the given text document position. The request's parameter is of
 * type {@link ReferenceParams} the response is of type
 * {@link Location Location[]} or a Thenable that resolves to such.
 */ var ReferencesRequest;
                (function(ReferencesRequest) {
                    ReferencesRequest.method = 'textDocument/references';
                    ReferencesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);
                })(ReferencesRequest = exports1.ReferencesRequest || (exports1.ReferencesRequest = {}));
                /**
 * Request to resolve a {@link DocumentHighlight} for a given
 * text document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the request response is of type [DocumentHighlight[]]
 * (#DocumentHighlight) or a Thenable that resolves to such.
 */ var DocumentHighlightRequest;
                (function(DocumentHighlightRequest) {
                    DocumentHighlightRequest.method = 'textDocument/documentHighlight';
                    DocumentHighlightRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);
                })(DocumentHighlightRequest = exports1.DocumentHighlightRequest || (exports1.DocumentHighlightRequest = {}));
                /**
 * A request to list all symbols found in a given text document. The request's
 * parameter is of type {@link TextDocumentIdentifier} the
 * response is of type {@link SymbolInformation SymbolInformation[]} or a Thenable
 * that resolves to such.
 */ var DocumentSymbolRequest;
                (function(DocumentSymbolRequest) {
                    DocumentSymbolRequest.method = 'textDocument/documentSymbol';
                    DocumentSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);
                })(DocumentSymbolRequest = exports1.DocumentSymbolRequest || (exports1.DocumentSymbolRequest = {}));
                /**
 * A request to provide commands for the given text document and range.
 */ var CodeActionRequest;
                (function(CodeActionRequest) {
                    CodeActionRequest.method = 'textDocument/codeAction';
                    CodeActionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);
                })(CodeActionRequest = exports1.CodeActionRequest || (exports1.CodeActionRequest = {}));
                /**
 * Request to resolve additional information for a given code action.The request's
 * parameter is of type {@link CodeAction} the response
 * is of type {@link CodeAction} or a Thenable that resolves to such.
 */ var CodeActionResolveRequest;
                (function(CodeActionResolveRequest) {
                    CodeActionResolveRequest.method = 'codeAction/resolve';
                    CodeActionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeActionResolveRequest.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest.method);
                })(CodeActionResolveRequest = exports1.CodeActionResolveRequest || (exports1.CodeActionResolveRequest = {}));
                /**
 * A request to list project-wide symbols matching the query string given
 * by the {@link WorkspaceSymbolParams}. The response is
 * of type {@link SymbolInformation SymbolInformation[]} or a Thenable that
 * resolves to such.
 *
 * @since 3.17.0 - support for WorkspaceSymbol in the returned data. Clients
 *  need to advertise support for WorkspaceSymbols via the client capability
 *  `workspace.symbol.resolveSupport`.
 *
 */ var WorkspaceSymbolRequest;
                (function(WorkspaceSymbolRequest) {
                    WorkspaceSymbolRequest.method = 'workspace/symbol';
                    WorkspaceSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);
                })(WorkspaceSymbolRequest = exports1.WorkspaceSymbolRequest || (exports1.WorkspaceSymbolRequest = {}));
                /**
 * A request to resolve the range inside the workspace
 * symbol's location.
 *
 * @since 3.17.0
 */ var WorkspaceSymbolResolveRequest;
                (function(WorkspaceSymbolResolveRequest) {
                    WorkspaceSymbolResolveRequest.method = 'workspaceSymbol/resolve';
                    WorkspaceSymbolResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkspaceSymbolResolveRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest.method);
                })(WorkspaceSymbolResolveRequest = exports1.WorkspaceSymbolResolveRequest || (exports1.WorkspaceSymbolResolveRequest = {}));
                /**
 * A request to provide code lens for the given text document.
 */ var CodeLensRequest;
                (function(CodeLensRequest) {
                    CodeLensRequest.method = 'textDocument/codeLens';
                    CodeLensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeLensRequest.type = new messages_1.ProtocolRequestType(CodeLensRequest.method);
                })(CodeLensRequest = exports1.CodeLensRequest || (exports1.CodeLensRequest = {}));
                /**
 * A request to resolve a command for a given code lens.
 */ var CodeLensResolveRequest;
                (function(CodeLensResolveRequest) {
                    CodeLensResolveRequest.method = 'codeLens/resolve';
                    CodeLensResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest.method);
                })(CodeLensResolveRequest = exports1.CodeLensResolveRequest || (exports1.CodeLensResolveRequest = {}));
                /**
 * A request to refresh all code actions
 *
 * @since 3.16.0
 */ var CodeLensRefreshRequest;
                (function(CodeLensRefreshRequest) {
                    CodeLensRefreshRequest.method = `workspace/codeLens/refresh`;
                    CodeLensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    CodeLensRefreshRequest.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest.method);
                })(CodeLensRefreshRequest = exports1.CodeLensRefreshRequest || (exports1.CodeLensRefreshRequest = {}));
                /**
 * A request to provide document links
 */ var DocumentLinkRequest;
                (function(DocumentLinkRequest) {
                    DocumentLinkRequest.method = 'textDocument/documentLink';
                    DocumentLinkRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);
                })(DocumentLinkRequest = exports1.DocumentLinkRequest || (exports1.DocumentLinkRequest = {}));
                /**
 * Request to resolve additional information for a given document link. The request's
 * parameter is of type {@link DocumentLink} the response
 * is of type {@link DocumentLink} or a Thenable that resolves to such.
 */ var DocumentLinkResolveRequest;
                (function(DocumentLinkResolveRequest) {
                    DocumentLinkResolveRequest.method = 'documentLink/resolve';
                    DocumentLinkResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest.method);
                })(DocumentLinkResolveRequest = exports1.DocumentLinkResolveRequest || (exports1.DocumentLinkResolveRequest = {}));
                /**
 * A request to to format a whole document.
 */ var DocumentFormattingRequest;
                (function(DocumentFormattingRequest) {
                    DocumentFormattingRequest.method = 'textDocument/formatting';
                    DocumentFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);
                })(DocumentFormattingRequest = exports1.DocumentFormattingRequest || (exports1.DocumentFormattingRequest = {}));
                /**
 * A request to to format a range in a document.
 */ var DocumentRangeFormattingRequest;
                (function(DocumentRangeFormattingRequest) {
                    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';
                    DocumentRangeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);
                })(DocumentRangeFormattingRequest = exports1.DocumentRangeFormattingRequest || (exports1.DocumentRangeFormattingRequest = {}));
                /**
 * A request to format a document on type.
 */ var DocumentOnTypeFormattingRequest;
                (function(DocumentOnTypeFormattingRequest) {
                    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';
                    DocumentOnTypeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);
                })(DocumentOnTypeFormattingRequest = exports1.DocumentOnTypeFormattingRequest || (exports1.DocumentOnTypeFormattingRequest = {}));
                //---- Rename ----------------------------------------------
                var PrepareSupportDefaultBehavior;
                (function(PrepareSupportDefaultBehavior) {
                    /**
     * The client's default behavior is to select the identifier
     * according the to language's syntax rule.
     */ PrepareSupportDefaultBehavior.Identifier = 1;
                })(PrepareSupportDefaultBehavior = exports1.PrepareSupportDefaultBehavior || (exports1.PrepareSupportDefaultBehavior = {}));
                /**
 * A request to rename a symbol.
 */ var RenameRequest;
                (function(RenameRequest) {
                    RenameRequest.method = 'textDocument/rename';
                    RenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);
                })(RenameRequest = exports1.RenameRequest || (exports1.RenameRequest = {}));
                /**
 * A request to test and perform the setup necessary for a rename.
 *
 * @since 3.16 - support for default behavior
 */ var PrepareRenameRequest;
                (function(PrepareRenameRequest) {
                    PrepareRenameRequest.method = 'textDocument/prepareRename';
                    PrepareRenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);
                })(PrepareRenameRequest = exports1.PrepareRenameRequest || (exports1.PrepareRenameRequest = {}));
                /**
 * A request send from the client to the server to execute a command. The request might return
 * a workspace edit which the client will apply to the workspace.
 */ var ExecuteCommandRequest;
                (function(ExecuteCommandRequest) {
                    ExecuteCommandRequest.method = 'workspace/executeCommand';
                    ExecuteCommandRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest.method);
                })(ExecuteCommandRequest = exports1.ExecuteCommandRequest || (exports1.ExecuteCommandRequest = {}));
                /**
 * A request sent from the server to the client to modified certain resources.
 */ var ApplyWorkspaceEditRequest;
                (function(ApplyWorkspaceEditRequest) {
                    ApplyWorkspaceEditRequest.method = 'workspace/applyEdit';
                    ApplyWorkspaceEditRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');
                })(ApplyWorkspaceEditRequest = exports1.ApplyWorkspaceEditRequest || (exports1.ApplyWorkspaceEditRequest = {}));
            /***/ },
            /***/ 527: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_531496__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LinkedEditingRangeRequest = void 0;
                const messages_1 = __nested_webpack_require_531496__(8599);
                /**
 * A request to provide ranges that can be edited together.
 *
 * @since 3.16.0
 */ var LinkedEditingRangeRequest;
                (function(LinkedEditingRangeRequest) {
                    LinkedEditingRangeRequest.method = 'textDocument/linkedEditingRange';
                    LinkedEditingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    LinkedEditingRangeRequest.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest.method);
                })(LinkedEditingRangeRequest = exports1.LinkedEditingRangeRequest || (exports1.LinkedEditingRangeRequest = {}));
            /***/ },
            /***/ 1964: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_532869__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.MonikerRequest = exports1.MonikerKind = exports1.UniquenessLevel = void 0;
                const messages_1 = __nested_webpack_require_532869__(8599);
                /**
 * Moniker uniqueness level to define scope of the moniker.
 *
 * @since 3.16.0
 */ var UniquenessLevel;
                (function(UniquenessLevel) {
                    /**
     * The moniker is only unique inside a document
     */ UniquenessLevel.document = 'document';
                    /**
     * The moniker is unique inside a project for which a dump got created
     */ UniquenessLevel.project = 'project';
                    /**
     * The moniker is unique inside the group to which a project belongs
     */ UniquenessLevel.group = 'group';
                    /**
     * The moniker is unique inside the moniker scheme.
     */ UniquenessLevel.scheme = 'scheme';
                    /**
     * The moniker is globally unique
     */ UniquenessLevel.global = 'global';
                })(UniquenessLevel = exports1.UniquenessLevel || (exports1.UniquenessLevel = {}));
                /**
 * The moniker kind.
 *
 * @since 3.16.0
 */ var MonikerKind;
                (function(MonikerKind) {
                    /**
     * The moniker represent a symbol that is imported into a project
     */ MonikerKind.$import = 'import';
                    /**
     * The moniker represents a symbol that is exported from a project
     */ MonikerKind.$export = 'export';
                    /**
     * The moniker represents a symbol that is local to a project (e.g. a local
     * variable of a function, a class not visible outside the project, ...)
     */ MonikerKind.local = 'local';
                })(MonikerKind = exports1.MonikerKind || (exports1.MonikerKind = {}));
                /**
 * A request to get the moniker of a symbol at a given text document position.
 * The request parameter is of type {@link TextDocumentPositionParams}.
 * The response is of type {@link Moniker Moniker[]} or `null`.
 */ var MonikerRequest;
                (function(MonikerRequest) {
                    MonikerRequest.method = 'textDocument/moniker';
                    MonikerRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    MonikerRequest.type = new messages_1.ProtocolRequestType(MonikerRequest.method);
                })(MonikerRequest = exports1.MonikerRequest || (exports1.MonikerRequest = {}));
            /***/ },
            /***/ 4460: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_535903__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DidCloseNotebookDocumentNotification = exports1.DidSaveNotebookDocumentNotification = exports1.DidChangeNotebookDocumentNotification = exports1.NotebookCellArrayChange = exports1.DidOpenNotebookDocumentNotification = exports1.NotebookDocumentSyncRegistrationType = exports1.NotebookDocument = exports1.NotebookCell = exports1.ExecutionSummary = exports1.NotebookCellKind = void 0;
                const vscode_languageserver_types_1 = __nested_webpack_require_535903__(4767);
                const Is = __nested_webpack_require_535903__(2523);
                const messages_1 = __nested_webpack_require_535903__(8599);
                /**
 * A notebook cell kind.
 *
 * @since 3.17.0
 */ var NotebookCellKind;
                (function(NotebookCellKind) {
                    /**
     * A markup-cell is formatted source that is used for display.
     */ NotebookCellKind.Markup = 1;
                    /**
     * A code-cell is source code.
     */ NotebookCellKind.Code = 2;
                    function is(value) {
                        return value === 1 || value === 2;
                    }
                    NotebookCellKind.is = is;
                })(NotebookCellKind = exports1.NotebookCellKind || (exports1.NotebookCellKind = {}));
                var ExecutionSummary;
                (function(ExecutionSummary) {
                    function create(executionOrder, success) {
                        const result = {
                            executionOrder
                        };
                        if (success === true || success === false) {
                            result.success = success;
                        }
                        return result;
                    }
                    ExecutionSummary.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === undefined || Is.boolean(candidate.success));
                    }
                    ExecutionSummary.is = is;
                    function equals(one, other) {
                        if (one === other) {
                            return true;
                        }
                        if (one === null || one === undefined || other === null || other === undefined) {
                            return false;
                        }
                        return one.executionOrder === other.executionOrder && one.success === other.success;
                    }
                    ExecutionSummary.equals = equals;
                })(ExecutionSummary = exports1.ExecutionSummary || (exports1.ExecutionSummary = {}));
                var NotebookCell;
                (function(NotebookCell) {
                    function create(kind, document1) {
                        return {
                            kind,
                            document: document1
                        };
                    }
                    NotebookCell.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === undefined || Is.objectLiteral(candidate.metadata));
                    }
                    NotebookCell.is = is;
                    function diff(one, two) {
                        const result = new Set();
                        if (one.document !== two.document) {
                            result.add('document');
                        }
                        if (one.kind !== two.kind) {
                            result.add('kind');
                        }
                        if (one.executionSummary !== two.executionSummary) {
                            result.add('executionSummary');
                        }
                        if ((one.metadata !== undefined || two.metadata !== undefined) && !equalsMetadata(one.metadata, two.metadata)) {
                            result.add('metadata');
                        }
                        if ((one.executionSummary !== undefined || two.executionSummary !== undefined) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
                            result.add('executionSummary');
                        }
                        return result;
                    }
                    NotebookCell.diff = diff;
                    function equalsMetadata(one, other) {
                        if (one === other) {
                            return true;
                        }
                        if (one === null || one === undefined || other === null || other === undefined) {
                            return false;
                        }
                        if (typeof one !== typeof other) {
                            return false;
                        }
                        if (typeof one !== 'object') {
                            return false;
                        }
                        const oneArray = Array.isArray(one);
                        const otherArray = Array.isArray(other);
                        if (oneArray !== otherArray) {
                            return false;
                        }
                        if (oneArray && otherArray) {
                            if (one.length !== other.length) {
                                return false;
                            }
                            for(let i = 0; i < one.length; i++){
                                if (!equalsMetadata(one[i], other[i])) {
                                    return false;
                                }
                            }
                        }
                        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
                            const oneKeys = Object.keys(one);
                            const otherKeys = Object.keys(other);
                            if (oneKeys.length !== otherKeys.length) {
                                return false;
                            }
                            oneKeys.sort();
                            otherKeys.sort();
                            if (!equalsMetadata(oneKeys, otherKeys)) {
                                return false;
                            }
                            for(let i = 0; i < oneKeys.length; i++){
                                const prop = oneKeys[i];
                                if (!equalsMetadata(one[prop], other[prop])) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                })(NotebookCell = exports1.NotebookCell || (exports1.NotebookCell = {}));
                var NotebookDocument;
                (function(NotebookDocument) {
                    function create(uri, notebookType, version, cells) {
                        return {
                            uri,
                            notebookType,
                            version,
                            cells
                        };
                    }
                    NotebookDocument.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
                    }
                    NotebookDocument.is = is;
                })(NotebookDocument = exports1.NotebookDocument || (exports1.NotebookDocument = {}));
                var NotebookDocumentSyncRegistrationType;
                (function(NotebookDocumentSyncRegistrationType) {
                    NotebookDocumentSyncRegistrationType.method = 'notebookDocument/sync';
                    NotebookDocumentSyncRegistrationType.messageDirection = messages_1.MessageDirection.clientToServer;
                    NotebookDocumentSyncRegistrationType.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType.method);
                })(NotebookDocumentSyncRegistrationType = exports1.NotebookDocumentSyncRegistrationType || (exports1.NotebookDocumentSyncRegistrationType = {}));
                /**
 * A notification sent when a notebook opens.
 *
 * @since 3.17.0
 */ var DidOpenNotebookDocumentNotification;
                (function(DidOpenNotebookDocumentNotification) {
                    DidOpenNotebookDocumentNotification.method = 'notebookDocument/didOpen';
                    DidOpenNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidOpenNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification.method);
                    DidOpenNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidOpenNotebookDocumentNotification = exports1.DidOpenNotebookDocumentNotification || (exports1.DidOpenNotebookDocumentNotification = {}));
                var NotebookCellArrayChange;
                (function(NotebookCellArrayChange) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === undefined || Is.typedArray(candidate.cells, NotebookCell.is));
                    }
                    NotebookCellArrayChange.is = is;
                    function create(start, deleteCount, cells) {
                        const result = {
                            start,
                            deleteCount
                        };
                        if (cells !== undefined) {
                            result.cells = cells;
                        }
                        return result;
                    }
                    NotebookCellArrayChange.create = create;
                })(NotebookCellArrayChange = exports1.NotebookCellArrayChange || (exports1.NotebookCellArrayChange = {}));
                var DidChangeNotebookDocumentNotification;
                (function(DidChangeNotebookDocumentNotification) {
                    DidChangeNotebookDocumentNotification.method = 'notebookDocument/didChange';
                    DidChangeNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification.method);
                    DidChangeNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidChangeNotebookDocumentNotification = exports1.DidChangeNotebookDocumentNotification || (exports1.DidChangeNotebookDocumentNotification = {}));
                /**
 * A notification sent when a notebook document is saved.
 *
 * @since 3.17.0
 */ var DidSaveNotebookDocumentNotification;
                (function(DidSaveNotebookDocumentNotification) {
                    DidSaveNotebookDocumentNotification.method = 'notebookDocument/didSave';
                    DidSaveNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidSaveNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification.method);
                    DidSaveNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidSaveNotebookDocumentNotification = exports1.DidSaveNotebookDocumentNotification || (exports1.DidSaveNotebookDocumentNotification = {}));
                /**
 * A notification sent when a notebook closes.
 *
 * @since 3.17.0
 */ var DidCloseNotebookDocumentNotification;
                (function(DidCloseNotebookDocumentNotification) {
                    DidCloseNotebookDocumentNotification.method = 'notebookDocument/didClose';
                    DidCloseNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidCloseNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification.method);
                    DidCloseNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidCloseNotebookDocumentNotification = exports1.DidCloseNotebookDocumentNotification || (exports1.DidCloseNotebookDocumentNotification = {}));
            /***/ },
            /***/ 7895: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_549480__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WorkDoneProgressCancelNotification = exports1.WorkDoneProgressCreateRequest = exports1.WorkDoneProgress = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_549480__(5953);
                const messages_1 = __nested_webpack_require_549480__(8599);
                var WorkDoneProgress;
                (function(WorkDoneProgress) {
                    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();
                    function is(value) {
                        return value === WorkDoneProgress.type;
                    }
                    WorkDoneProgress.is = is;
                })(WorkDoneProgress = exports1.WorkDoneProgress || (exports1.WorkDoneProgress = {}));
                /**
 * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress
 * reporting from the server.
 */ var WorkDoneProgressCreateRequest;
                (function(WorkDoneProgressCreateRequest) {
                    WorkDoneProgressCreateRequest.method = 'window/workDoneProgress/create';
                    WorkDoneProgressCreateRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest.method);
                })(WorkDoneProgressCreateRequest = exports1.WorkDoneProgressCreateRequest || (exports1.WorkDoneProgressCreateRequest = {}));
                /**
 * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
 * initiated on the server side.
 */ var WorkDoneProgressCancelNotification;
                (function(WorkDoneProgressCancelNotification) {
                    WorkDoneProgressCancelNotification.method = 'window/workDoneProgress/cancel';
                    WorkDoneProgressCancelNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification.method);
                })(WorkDoneProgressCancelNotification = exports1.WorkDoneProgressCancelNotification || (exports1.WorkDoneProgressCancelNotification = {}));
            /***/ },
            /***/ 2392: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_552321__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.SelectionRangeRequest = void 0;
                const messages_1 = __nested_webpack_require_552321__(8599);
                /**
 * A request to provide selection ranges in a document. The request's
 * parameter is of type {@link SelectionRangeParams}, the
 * response is of type {@link SelectionRange SelectionRange[]} or a Thenable
 * that resolves to such.
 */ var SelectionRangeRequest;
                (function(SelectionRangeRequest) {
                    SelectionRangeRequest.method = 'textDocument/selectionRange';
                    SelectionRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);
                })(SelectionRangeRequest = exports1.SelectionRangeRequest || (exports1.SelectionRangeRequest = {}));
            /***/ },
            /***/ 8489: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_553801__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.SemanticTokensRefreshRequest = exports1.SemanticTokensRangeRequest = exports1.SemanticTokensDeltaRequest = exports1.SemanticTokensRequest = exports1.SemanticTokensRegistrationType = exports1.TokenFormat = void 0;
                const messages_1 = __nested_webpack_require_553801__(8599);
                //------- 'textDocument/semanticTokens' -----
                var TokenFormat;
                (function(TokenFormat) {
                    TokenFormat.Relative = 'relative';
                })(TokenFormat = exports1.TokenFormat || (exports1.TokenFormat = {}));
                var SemanticTokensRegistrationType;
                (function(SemanticTokensRegistrationType) {
                    SemanticTokensRegistrationType.method = 'textDocument/semanticTokens';
                    SemanticTokensRegistrationType.type = new messages_1.RegistrationType(SemanticTokensRegistrationType.method);
                })(SemanticTokensRegistrationType = exports1.SemanticTokensRegistrationType || (exports1.SemanticTokensRegistrationType = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensRequest;
                (function(SemanticTokensRequest) {
                    SemanticTokensRequest.method = 'textDocument/semanticTokens/full';
                    SemanticTokensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);
                    SemanticTokensRequest.registrationMethod = SemanticTokensRegistrationType.method;
                })(SemanticTokensRequest = exports1.SemanticTokensRequest || (exports1.SemanticTokensRequest = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensDeltaRequest;
                (function(SemanticTokensDeltaRequest) {
                    SemanticTokensDeltaRequest.method = 'textDocument/semanticTokens/full/delta';
                    SemanticTokensDeltaRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensDeltaRequest.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest.method);
                    SemanticTokensDeltaRequest.registrationMethod = SemanticTokensRegistrationType.method;
                })(SemanticTokensDeltaRequest = exports1.SemanticTokensDeltaRequest || (exports1.SemanticTokensDeltaRequest = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensRangeRequest;
                (function(SemanticTokensRangeRequest) {
                    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';
                    SemanticTokensRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);
                    SemanticTokensRangeRequest.registrationMethod = SemanticTokensRegistrationType.method;
                })(SemanticTokensRangeRequest = exports1.SemanticTokensRangeRequest || (exports1.SemanticTokensRangeRequest = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensRefreshRequest;
                (function(SemanticTokensRefreshRequest) {
                    SemanticTokensRefreshRequest.method = `workspace/semanticTokens/refresh`;
                    SemanticTokensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    SemanticTokensRefreshRequest.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest.method);
                })(SemanticTokensRefreshRequest = exports1.SemanticTokensRefreshRequest || (exports1.SemanticTokensRefreshRequest = {}));
            /***/ },
            /***/ 1541: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_558112__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ShowDocumentRequest = void 0;
                const messages_1 = __nested_webpack_require_558112__(8599);
                /**
 * A request to show a document. This request might open an
 * external program depending on the value of the URI to open.
 * For example a request to open `https://code.visualstudio.com/`
 * will very likely open the URI in a WEB browser.
 *
 * @since 3.16.0
*/ var ShowDocumentRequest;
                (function(ShowDocumentRequest) {
                    ShowDocumentRequest.method = 'window/showDocument';
                    ShowDocumentRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ShowDocumentRequest.type = new messages_1.ProtocolRequestType(ShowDocumentRequest.method);
                })(ShowDocumentRequest = exports1.ShowDocumentRequest || (exports1.ShowDocumentRequest = {}));
            /***/ },
            /***/ 8642: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_559590__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.TypeDefinitionRequest = void 0;
                const messages_1 = __nested_webpack_require_559590__(8599);
                // @ts-ignore: to avoid inlining LocatioLink as dynamic import
                let __noDynamicImport;
                /**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositionParams]
 * (#TextDocumentPositionParams) the response is of type {@link Definition} or a
 * Thenable that resolves to such.
 */ var TypeDefinitionRequest;
                (function(TypeDefinitionRequest) {
                    TypeDefinitionRequest.method = 'textDocument/typeDefinition';
                    TypeDefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);
                })(TypeDefinitionRequest = exports1.TypeDefinitionRequest || (exports1.TypeDefinitionRequest = {}));
            /***/ },
            /***/ 5318: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_561239__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.TypeHierarchySubtypesRequest = exports1.TypeHierarchySupertypesRequest = exports1.TypeHierarchyPrepareRequest = void 0;
                const messages_1 = __nested_webpack_require_561239__(8599);
                /**
 * A request to result a `TypeHierarchyItem` in a document at a given position.
 * Can be used as an input to a subtypes or supertypes type hierarchy.
 *
 * @since 3.17.0
 */ var TypeHierarchyPrepareRequest;
                (function(TypeHierarchyPrepareRequest) {
                    TypeHierarchyPrepareRequest.method = 'textDocument/prepareTypeHierarchy';
                    TypeHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest.method);
                })(TypeHierarchyPrepareRequest = exports1.TypeHierarchyPrepareRequest || (exports1.TypeHierarchyPrepareRequest = {}));
                /**
 * A request to resolve the supertypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */ var TypeHierarchySupertypesRequest;
                (function(TypeHierarchySupertypesRequest) {
                    TypeHierarchySupertypesRequest.method = 'typeHierarchy/supertypes';
                    TypeHierarchySupertypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeHierarchySupertypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest.method);
                })(TypeHierarchySupertypesRequest = exports1.TypeHierarchySupertypesRequest || (exports1.TypeHierarchySupertypesRequest = {}));
                /**
 * A request to resolve the subtypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */ var TypeHierarchySubtypesRequest;
                (function(TypeHierarchySubtypesRequest) {
                    TypeHierarchySubtypesRequest.method = 'typeHierarchy/subtypes';
                    TypeHierarchySubtypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeHierarchySubtypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest.method);
                })(TypeHierarchySubtypesRequest = exports1.TypeHierarchySubtypesRequest || (exports1.TypeHierarchySubtypesRequest = {}));
            /***/ },
            /***/ 3402: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_564173__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DidChangeWorkspaceFoldersNotification = exports1.WorkspaceFoldersRequest = void 0;
                const messages_1 = __nested_webpack_require_564173__(8599);
                /**
 * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
 */ var WorkspaceFoldersRequest;
                (function(WorkspaceFoldersRequest) {
                    WorkspaceFoldersRequest.method = 'workspace/workspaceFolders';
                    WorkspaceFoldersRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest.method);
                })(WorkspaceFoldersRequest = exports1.WorkspaceFoldersRequest || (exports1.WorkspaceFoldersRequest = {}));
                /**
 * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
 * folder configuration changes.
 */ var DidChangeWorkspaceFoldersNotification;
                (function(DidChangeWorkspaceFoldersNotification) {
                    DidChangeWorkspaceFoldersNotification.method = 'workspace/didChangeWorkspaceFolders';
                    DidChangeWorkspaceFoldersNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification.method);
                })(DidChangeWorkspaceFoldersNotification = exports1.DidChangeWorkspaceFoldersNotification || (exports1.DidChangeWorkspaceFoldersNotification = {}));
            /***/ },
            /***/ 2523: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.objectLiteral = exports1.typedArray = exports1.stringArray = exports1.array = exports1.func = exports1.error = exports1.number = exports1.string = exports1.boolean = void 0;
                function boolean(value) {
                    return value === true || value === false;
                }
                exports1.boolean = boolean;
                function string(value) {
                    return typeof value === 'string' || value instanceof String;
                }
                exports1.string = string;
                function number(value) {
                    return typeof value === 'number' || value instanceof Number;
                }
                exports1.number = number;
                function error(value) {
                    return value instanceof Error;
                }
                exports1.error = error;
                function func(value) {
                    return typeof value === 'function';
                }
                exports1.func = func;
                function array(value) {
                    return Array.isArray(value);
                }
                exports1.array = array;
                function stringArray(value) {
                    return array(value) && value.every((elem)=>string(elem));
                }
                exports1.stringArray = stringArray;
                function typedArray(value, check) {
                    return Array.isArray(value) && value.every(check);
                }
                exports1.typedArray = typedArray;
                function objectLiteral(value) {
                    // Strictly speaking class instances pass this check as well. Since the LSP
                    // doesn't use classes we ignore this for now. If we do we need to add something
                    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
                    return value !== null && typeof value === 'object';
                }
                exports1.objectLiteral = objectLiteral;
            /***/ },
            /***/ 4881: /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_569068__)=>{
                "use strict";
                /* harmony export */ __nested_webpack_require_569068__.d(__nested_webpack_exports__, {
                    /* harmony export */ n: ()=>/* binding */ TextDocument
                });
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __spreadArray =  false || function(to, from, pack) {
                    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
                        if (ar || !(i in from)) {
                            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                            ar[i] = from[i];
                        }
                    }
                    return to.concat(ar || Array.prototype.slice.call(from));
                };
                var FullTextDocument = /** @class */ function() {
                    function FullTextDocument(uri, languageId, version, content) {
                        this._uri = uri;
                        this._languageId = languageId;
                        this._version = version;
                        this._content = content;
                        this._lineOffsets = undefined;
                    }
                    Object.defineProperty(FullTextDocument.prototype, "uri", {
                        get: function() {
                            return this._uri;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(FullTextDocument.prototype, "languageId", {
                        get: function() {
                            return this._languageId;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(FullTextDocument.prototype, "version", {
                        get: function() {
                            return this._version;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    FullTextDocument.prototype.getText = function(range) {
                        if (range) {
                            var start = this.offsetAt(range.start);
                            var end = this.offsetAt(range.end);
                            return this._content.substring(start, end);
                        }
                        return this._content;
                    };
                    FullTextDocument.prototype.update = function(changes, version) {
                        for(var _i = 0, changes_1 = changes; _i < changes_1.length; _i++){
                            var change = changes_1[_i];
                            if (FullTextDocument.isIncremental(change)) {
                                // makes sure start is before end
                                var range = getWellformedRange(change.range);
                                // update content
                                var startOffset = this.offsetAt(range.start);
                                var endOffset = this.offsetAt(range.end);
                                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
                                // update the offsets
                                var startLine = Math.max(range.start.line, 0);
                                var endLine = Math.max(range.end.line, 0);
                                var lineOffsets = this._lineOffsets;
                                var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
                                if (endLine - startLine === addedLineOffsets.length) {
                                    for(var i = 0, len = addedLineOffsets.length; i < len; i++){
                                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];
                                    }
                                } else {
                                    if (addedLineOffsets.length < 10000) {
                                        lineOffsets.splice.apply(lineOffsets, __spreadArray([
                                            startLine + 1,
                                            endLine - startLine
                                        ], addedLineOffsets, false));
                                    } else {
                                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
                                    }
                                }
                                var diff = change.text.length - (endOffset - startOffset);
                                if (diff !== 0) {
                                    for(var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++){
                                        lineOffsets[i] = lineOffsets[i] + diff;
                                    }
                                }
                            } else if (FullTextDocument.isFull(change)) {
                                this._content = change.text;
                                this._lineOffsets = undefined;
                            } else {
                                throw new Error('Unknown change event received');
                            }
                        }
                        this._version = version;
                    };
                    FullTextDocument.prototype.getLineOffsets = function() {
                        if (this._lineOffsets === undefined) {
                            this._lineOffsets = computeLineOffsets(this._content, true);
                        }
                        return this._lineOffsets;
                    };
                    FullTextDocument.prototype.positionAt = function(offset) {
                        offset = Math.max(Math.min(offset, this._content.length), 0);
                        var lineOffsets = this.getLineOffsets();
                        var low = 0, high = lineOffsets.length;
                        if (high === 0) {
                            return {
                                line: 0,
                                character: offset
                            };
                        }
                        while(low < high){
                            var mid = Math.floor((low + high) / 2);
                            if (lineOffsets[mid] > offset) {
                                high = mid;
                            } else {
                                low = mid + 1;
                            }
                        }
                        // low is the least x for which the line offset is larger than the current offset
                        // or array.length if no line offset is larger than the current offset
                        var line = low - 1;
                        return {
                            line: line,
                            character: offset - lineOffsets[line]
                        };
                    };
                    FullTextDocument.prototype.offsetAt = function(position) {
                        var lineOffsets = this.getLineOffsets();
                        if (position.line >= lineOffsets.length) {
                            return this._content.length;
                        } else if (position.line < 0) {
                            return 0;
                        }
                        var lineOffset = lineOffsets[position.line];
                        var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
                        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
                    };
                    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
                        get: function() {
                            return this.getLineOffsets().length;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    FullTextDocument.isIncremental = function(event) {
                        var candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range !== undefined && (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
                    };
                    FullTextDocument.isFull = function(event) {
                        var candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
                    };
                    return FullTextDocument;
                }();
                var TextDocument;
                (function(TextDocument) {
                    /**
     * Creates a new text document.
     *
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param version The document's initial version number.
     * @param content The document's content.
     */ function create(uri, languageId, version, content) {
                        return new FullTextDocument(uri, languageId, version, content);
                    }
                    TextDocument.create = create;
                    /**
     * Updates a TextDocument by modifying its content.
     *
     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.
     * @param changes the changes to apply to the document.
     * @param version the changes version for the document.
     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.
     *
     */ function update(document1, changes, version) {
                        if (document1 instanceof FullTextDocument) {
                            document1.update(changes, version);
                            return document1;
                        } else {
                            throw new Error('TextDocument.update: document must be created by TextDocument.create');
                        }
                    }
                    TextDocument.update = update;
                    function applyEdits(document1, edits) {
                        var text = document1.getText();
                        var sortedEdits = mergeSort(edits.map(getWellformedEdit), function(a, b) {
                            var diff = a.range.start.line - b.range.start.line;
                            if (diff === 0) {
                                return a.range.start.character - b.range.start.character;
                            }
                            return diff;
                        });
                        var lastModifiedOffset = 0;
                        var spans = [];
                        for(var _i = 0, sortedEdits_1 = sortedEdits; _i < sortedEdits_1.length; _i++){
                            var e = sortedEdits_1[_i];
                            var startOffset = document1.offsetAt(e.range.start);
                            if (startOffset < lastModifiedOffset) {
                                throw new Error('Overlapping edit');
                            } else if (startOffset > lastModifiedOffset) {
                                spans.push(text.substring(lastModifiedOffset, startOffset));
                            }
                            if (e.newText.length) {
                                spans.push(e.newText);
                            }
                            lastModifiedOffset = document1.offsetAt(e.range.end);
                        }
                        spans.push(text.substr(lastModifiedOffset));
                        return spans.join('');
                    }
                    TextDocument.applyEdits = applyEdits;
                })(TextDocument || (TextDocument = {}));
                function mergeSort(data, compare) {
                    if (data.length <= 1) {
                        // sorted
                        return data;
                    }
                    var p = data.length / 2 | 0;
                    var left = data.slice(0, p);
                    var right = data.slice(p);
                    mergeSort(left, compare);
                    mergeSort(right, compare);
                    var leftIdx = 0;
                    var rightIdx = 0;
                    var i = 0;
                    while(leftIdx < left.length && rightIdx < right.length){
                        var ret = compare(left[leftIdx], right[rightIdx]);
                        if (ret <= 0) {
                            // smaller_equal -> take left to preserve order
                            data[i++] = left[leftIdx++];
                        } else {
                            // greater -> take right
                            data[i++] = right[rightIdx++];
                        }
                    }
                    while(leftIdx < left.length){
                        data[i++] = left[leftIdx++];
                    }
                    while(rightIdx < right.length){
                        data[i++] = right[rightIdx++];
                    }
                    return data;
                }
                function computeLineOffsets(text, isAtLineStart, textOffset) {
                    if (textOffset === void 0) {
                        textOffset = 0;
                    }
                    var result = isAtLineStart ? [
                        textOffset
                    ] : [];
                    for(var i = 0; i < text.length; i++){
                        var ch = text.charCodeAt(i);
                        if (ch === 13 /* CharCode.CarriageReturn */  || ch === 10 /* CharCode.LineFeed */ ) {
                            if (ch === 13 /* CharCode.CarriageReturn */  && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */ ) {
                                i++;
                            }
                            result.push(textOffset + i + 1);
                        }
                    }
                    return result;
                }
                function getWellformedRange(range) {
                    var start = range.start;
                    var end = range.end;
                    if (start.line > end.line || start.line === end.line && start.character > end.character) {
                        return {
                            start: end,
                            end: start
                        };
                    }
                    return range;
                }
                function getWellformedEdit(textEdit) {
                    var range = getWellformedRange(textEdit.range);
                    if (range !== textEdit.range) {
                        return {
                            newText: textEdit.newText,
                            range: range
                        };
                    }
                    return textEdit;
                }
            /***/ },
            /***/ 4767: /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_584892__)=>{
                "use strict";
                __nested_webpack_require_584892__.r(__nested_webpack_exports__);
                /* harmony export */ __nested_webpack_require_584892__.d(__nested_webpack_exports__, {
                    /* harmony export */ AnnotatedTextEdit: ()=>/* binding */ AnnotatedTextEdit,
                    /* harmony export */ ChangeAnnotation: ()=>/* binding */ ChangeAnnotation,
                    /* harmony export */ ChangeAnnotationIdentifier: ()=>/* binding */ ChangeAnnotationIdentifier,
                    /* harmony export */ CodeAction: ()=>/* binding */ CodeAction,
                    /* harmony export */ CodeActionContext: ()=>/* binding */ CodeActionContext,
                    /* harmony export */ CodeActionKind: ()=>/* binding */ CodeActionKind,
                    /* harmony export */ CodeActionTriggerKind: ()=>/* binding */ CodeActionTriggerKind,
                    /* harmony export */ CodeDescription: ()=>/* binding */ CodeDescription,
                    /* harmony export */ CodeLens: ()=>/* binding */ CodeLens,
                    /* harmony export */ Color: ()=>/* binding */ Color,
                    /* harmony export */ ColorInformation: ()=>/* binding */ ColorInformation,
                    /* harmony export */ ColorPresentation: ()=>/* binding */ ColorPresentation,
                    /* harmony export */ Command: ()=>/* binding */ Command,
                    /* harmony export */ CompletionItem: ()=>/* binding */ CompletionItem,
                    /* harmony export */ CompletionItemKind: ()=>/* binding */ CompletionItemKind1,
                    /* harmony export */ CompletionItemLabelDetails: ()=>/* binding */ CompletionItemLabelDetails,
                    /* harmony export */ CompletionItemTag: ()=>/* binding */ CompletionItemTag,
                    /* harmony export */ CompletionList: ()=>/* binding */ CompletionList,
                    /* harmony export */ CreateFile: ()=>/* binding */ CreateFile,
                    /* harmony export */ DeleteFile: ()=>/* binding */ DeleteFile,
                    /* harmony export */ Diagnostic: ()=>/* binding */ Diagnostic,
                    /* harmony export */ DiagnosticRelatedInformation: ()=>/* binding */ DiagnosticRelatedInformation,
                    /* harmony export */ DiagnosticSeverity: ()=>/* binding */ DiagnosticSeverity,
                    /* harmony export */ DiagnosticTag: ()=>/* binding */ DiagnosticTag,
                    /* harmony export */ DocumentHighlight: ()=>/* binding */ DocumentHighlight,
                    /* harmony export */ DocumentHighlightKind: ()=>/* binding */ DocumentHighlightKind,
                    /* harmony export */ DocumentLink: ()=>/* binding */ DocumentLink,
                    /* harmony export */ DocumentSymbol: ()=>/* binding */ DocumentSymbol,
                    /* harmony export */ DocumentUri: ()=>/* binding */ DocumentUri,
                    /* harmony export */ EOL: ()=>/* binding */ EOL,
                    /* harmony export */ FoldingRange: ()=>/* binding */ FoldingRange,
                    /* harmony export */ FoldingRangeKind: ()=>/* binding */ FoldingRangeKind,
                    /* harmony export */ FormattingOptions: ()=>/* binding */ FormattingOptions,
                    /* harmony export */ Hover: ()=>/* binding */ Hover,
                    /* harmony export */ InlayHint: ()=>/* binding */ InlayHint,
                    /* harmony export */ InlayHintKind: ()=>/* binding */ InlayHintKind,
                    /* harmony export */ InlayHintLabelPart: ()=>/* binding */ InlayHintLabelPart,
                    /* harmony export */ InlineValueContext: ()=>/* binding */ InlineValueContext,
                    /* harmony export */ InlineValueEvaluatableExpression: ()=>/* binding */ InlineValueEvaluatableExpression,
                    /* harmony export */ InlineValueText: ()=>/* binding */ InlineValueText,
                    /* harmony export */ InlineValueVariableLookup: ()=>/* binding */ InlineValueVariableLookup,
                    /* harmony export */ InsertReplaceEdit: ()=>/* binding */ InsertReplaceEdit,
                    /* harmony export */ InsertTextFormat: ()=>/* binding */ InsertTextFormat1,
                    /* harmony export */ InsertTextMode: ()=>/* binding */ InsertTextMode,
                    /* harmony export */ Location: ()=>/* binding */ Location,
                    /* harmony export */ LocationLink: ()=>/* binding */ LocationLink,
                    /* harmony export */ MarkedString: ()=>/* binding */ MarkedString1,
                    /* harmony export */ MarkupContent: ()=>/* binding */ MarkupContent1,
                    /* harmony export */ MarkupKind: ()=>/* binding */ MarkupKind,
                    /* harmony export */ OptionalVersionedTextDocumentIdentifier: ()=>/* binding */ OptionalVersionedTextDocumentIdentifier,
                    /* harmony export */ ParameterInformation: ()=>/* binding */ ParameterInformation,
                    /* harmony export */ Position: ()=>/* binding */ Position,
                    /* harmony export */ Range: ()=>/* binding */ Range,
                    /* harmony export */ RenameFile: ()=>/* binding */ RenameFile,
                    /* harmony export */ SelectionRange: ()=>/* binding */ SelectionRange,
                    /* harmony export */ SemanticTokenModifiers: ()=>/* binding */ SemanticTokenModifiers,
                    /* harmony export */ SemanticTokenTypes: ()=>/* binding */ SemanticTokenTypes,
                    /* harmony export */ SemanticTokens: ()=>/* binding */ SemanticTokens,
                    /* harmony export */ SignatureInformation: ()=>/* binding */ SignatureInformation,
                    /* harmony export */ SymbolInformation: ()=>/* binding */ SymbolInformation,
                    /* harmony export */ SymbolKind: ()=>/* binding */ SymbolKind,
                    /* harmony export */ SymbolTag: ()=>/* binding */ SymbolTag,
                    /* harmony export */ TextDocument: ()=>/* binding */ TextDocument,
                    /* harmony export */ TextDocumentEdit: ()=>/* binding */ TextDocumentEdit,
                    /* harmony export */ TextDocumentIdentifier: ()=>/* binding */ TextDocumentIdentifier,
                    /* harmony export */ TextDocumentItem: ()=>/* binding */ TextDocumentItem,
                    /* harmony export */ TextEdit: ()=>/* binding */ TextEdit,
                    /* harmony export */ URI: ()=>/* binding */ URI,
                    /* harmony export */ VersionedTextDocumentIdentifier: ()=>/* binding */ VersionedTextDocumentIdentifier,
                    /* harmony export */ WorkspaceChange: ()=>/* binding */ WorkspaceChange,
                    /* harmony export */ WorkspaceEdit: ()=>/* binding */ WorkspaceEdit,
                    /* harmony export */ WorkspaceFolder: ()=>/* binding */ WorkspaceFolder,
                    /* harmony export */ WorkspaceSymbol: ()=>/* binding */ WorkspaceSymbol,
                    /* harmony export */ integer: ()=>/* binding */ integer,
                    /* harmony export */ uinteger: ()=>/* binding */ uinteger
                });
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var DocumentUri;
                (function(DocumentUri) {
                    function is(value) {
                        return typeof value === 'string';
                    }
                    DocumentUri.is = is;
                })(DocumentUri || (DocumentUri = {}));
                var URI;
                (function(URI) {
                    function is(value) {
                        return typeof value === 'string';
                    }
                    URI.is = is;
                })(URI || (URI = {}));
                var integer;
                (function(integer) {
                    integer.MIN_VALUE = -2147483648;
                    integer.MAX_VALUE = 2147483647;
                    function is(value) {
                        return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;
                    }
                    integer.is = is;
                })(integer || (integer = {}));
                var uinteger;
                (function(uinteger) {
                    uinteger.MIN_VALUE = 0;
                    uinteger.MAX_VALUE = 2147483647;
                    function is(value) {
                        return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;
                    }
                    uinteger.is = is;
                })(uinteger || (uinteger = {}));
                /**
 * The Position namespace provides helper functions to work with
 * {@link Position} literals.
 */ var Position;
                (function(Position) {
                    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */ function create(line, character) {
                        if (line === Number.MAX_VALUE) {
                            line = uinteger.MAX_VALUE;
                        }
                        if (character === Number.MAX_VALUE) {
                            character = uinteger.MAX_VALUE;
                        }
                        return {
                            line: line,
                            character: character
                        };
                    }
                    Position.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Position} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
                    }
                    Position.is = is;
                })(Position || (Position = {}));
                /**
 * The Range namespace provides helper functions to work with
 * {@link Range} literals.
 */ var Range;
                (function(Range) {
                    function create(one, two, three, four) {
                        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
                            return {
                                start: Position.create(one, two),
                                end: Position.create(three, four)
                            };
                        } else if (Position.is(one) && Position.is(two)) {
                            return {
                                start: one,
                                end: two
                            };
                        } else {
                            throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
                        }
                    }
                    Range.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Range} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
                    }
                    Range.is = is;
                })(Range || (Range = {}));
                /**
 * The Location namespace provides helper functions to work with
 * {@link Location} literals.
 */ var Location;
                (function(Location) {
                    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */ function create(uri, range) {
                        return {
                            uri: uri,
                            range: range
                        };
                    }
                    Location.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Location} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
                    }
                    Location.is = is;
                })(Location || (Location = {}));
                /**
 * The LocationLink namespace provides helper functions to work with
 * {@link LocationLink} literals.
 */ var LocationLink;
                (function(LocationLink) {
                    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */ function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
                        return {
                            targetUri: targetUri,
                            targetRange: targetRange,
                            targetSelectionRange: targetSelectionRange,
                            originSelectionRange: originSelectionRange
                        };
                    }
                    LocationLink.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link LocationLink} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
                    }
                    LocationLink.is = is;
                })(LocationLink || (LocationLink = {}));
                /**
 * The Color namespace provides helper functions to work with
 * {@link Color} literals.
 */ var Color;
                (function(Color) {
                    /**
     * Creates a new Color literal.
     */ function create(red, green, blue, alpha) {
                        return {
                            red: red,
                            green: green,
                            blue: blue,
                            alpha: alpha
                        };
                    }
                    Color.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Color} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
                    }
                    Color.is = is;
                })(Color || (Color = {}));
                /**
 * The ColorInformation namespace provides helper functions to work with
 * {@link ColorInformation} literals.
 */ var ColorInformation;
                (function(ColorInformation) {
                    /**
     * Creates a new ColorInformation literal.
     */ function create(range, color) {
                        return {
                            range: range,
                            color: color
                        };
                    }
                    ColorInformation.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
                    }
                    ColorInformation.is = is;
                })(ColorInformation || (ColorInformation = {}));
                /**
 * The Color namespace provides helper functions to work with
 * {@link ColorPresentation} literals.
 */ var ColorPresentation;
                (function(ColorPresentation) {
                    /**
     * Creates a new ColorInformation literal.
     */ function create(label, textEdit, additionalTextEdits) {
                        return {
                            label: label,
                            textEdit: textEdit,
                            additionalTextEdits: additionalTextEdits
                        };
                    }
                    ColorPresentation.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
                    }
                    ColorPresentation.is = is;
                })(ColorPresentation || (ColorPresentation = {}));
                /**
 * A set of predefined range kinds.
 */ var FoldingRangeKind;
                (function(FoldingRangeKind) {
                    /**
     * Folding range for a comment
     */ FoldingRangeKind.Comment = 'comment';
                    /**
     * Folding range for an import or include
     */ FoldingRangeKind.Imports = 'imports';
                    /**
     * Folding range for a region (e.g. `#region`)
     */ FoldingRangeKind.Region = 'region';
                })(FoldingRangeKind || (FoldingRangeKind = {}));
                /**
 * The folding range namespace provides helper functions to work with
 * {@link FoldingRange} literals.
 */ var FoldingRange;
                (function(FoldingRange) {
                    /**
     * Creates a new FoldingRange literal.
     */ function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
                        var result = {
                            startLine: startLine,
                            endLine: endLine
                        };
                        if (Is.defined(startCharacter)) {
                            result.startCharacter = startCharacter;
                        }
                        if (Is.defined(endCharacter)) {
                            result.endCharacter = endCharacter;
                        }
                        if (Is.defined(kind)) {
                            result.kind = kind;
                        }
                        if (Is.defined(collapsedText)) {
                            result.collapsedText = collapsedText;
                        }
                        return result;
                    }
                    FoldingRange.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link FoldingRange} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
                    }
                    FoldingRange.is = is;
                })(FoldingRange || (FoldingRange = {}));
                /**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * {@link DiagnosticRelatedInformation} literals.
 */ var DiagnosticRelatedInformation;
                (function(DiagnosticRelatedInformation) {
                    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */ function create(location, message) {
                        return {
                            location: location,
                            message: message
                        };
                    }
                    DiagnosticRelatedInformation.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
                    }
                    DiagnosticRelatedInformation.is = is;
                })(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
                /**
 * The diagnostic's severity.
 */ var DiagnosticSeverity;
                (function(DiagnosticSeverity) {
                    /**
     * Reports an error.
     */ DiagnosticSeverity.Error = 1;
                    /**
     * Reports a warning.
     */ DiagnosticSeverity.Warning = 2;
                    /**
     * Reports an information.
     */ DiagnosticSeverity.Information = 3;
                    /**
     * Reports a hint.
     */ DiagnosticSeverity.Hint = 4;
                })(DiagnosticSeverity || (DiagnosticSeverity = {}));
                /**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */ var DiagnosticTag;
                (function(DiagnosticTag) {
                    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */ DiagnosticTag.Unnecessary = 1;
                    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */ DiagnosticTag.Deprecated = 2;
                })(DiagnosticTag || (DiagnosticTag = {}));
                /**
 * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
 *
 * @since 3.16.0
 */ var CodeDescription;
                (function(CodeDescription) {
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.href);
                    }
                    CodeDescription.is = is;
                })(CodeDescription || (CodeDescription = {}));
                /**
 * The Diagnostic namespace provides helper functions to work with
 * {@link Diagnostic} literals.
 */ var Diagnostic;
                (function(Diagnostic) {
                    /**
     * Creates a new Diagnostic literal.
     */ function create(range, message, severity, code, source, relatedInformation) {
                        var result = {
                            range: range,
                            message: message
                        };
                        if (Is.defined(severity)) {
                            result.severity = severity;
                        }
                        if (Is.defined(code)) {
                            result.code = code;
                        }
                        if (Is.defined(source)) {
                            result.source = source;
                        }
                        if (Is.defined(relatedInformation)) {
                            result.relatedInformation = relatedInformation;
                        }
                        return result;
                    }
                    Diagnostic.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Diagnostic} interface.
     */ function is(value) {
                        var _a;
                        var candidate = value;
                        return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
                    }
                    Diagnostic.is = is;
                })(Diagnostic || (Diagnostic = {}));
                /**
 * The Command namespace provides helper functions to work with
 * {@link Command} literals.
 */ var Command;
                (function(Command) {
                    /**
     * Creates a new Command literal.
     */ function create(title, command) {
                        var args = [];
                        for(var _i = 2; _i < arguments.length; _i++){
                            args[_i - 2] = arguments[_i];
                        }
                        var result = {
                            title: title,
                            command: command
                        };
                        if (Is.defined(args) && args.length > 0) {
                            result.arguments = args;
                        }
                        return result;
                    }
                    Command.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Command} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
                    }
                    Command.is = is;
                })(Command || (Command = {}));
                /**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */ var TextEdit;
                (function(TextEdit) {
                    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */ function replace(range, newText) {
                        return {
                            range: range,
                            newText: newText
                        };
                    }
                    TextEdit.replace = replace;
                    /**
     * Creates an insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */ function insert(position, newText) {
                        return {
                            range: {
                                start: position,
                                end: position
                            },
                            newText: newText
                        };
                    }
                    TextEdit.insert = insert;
                    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */ function del(range) {
                        return {
                            range: range,
                            newText: ''
                        };
                    }
                    TextEdit.del = del;
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
                    }
                    TextEdit.is = is;
                })(TextEdit || (TextEdit = {}));
                var ChangeAnnotation;
                (function(ChangeAnnotation) {
                    function create(label, needsConfirmation, description) {
                        var result = {
                            label: label
                        };
                        if (needsConfirmation !== undefined) {
                            result.needsConfirmation = needsConfirmation;
                        }
                        if (description !== undefined) {
                            result.description = description;
                        }
                        return result;
                    }
                    ChangeAnnotation.create = create;
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) && (Is.string(candidate.description) || candidate.description === undefined);
                    }
                    ChangeAnnotation.is = is;
                })(ChangeAnnotation || (ChangeAnnotation = {}));
                var ChangeAnnotationIdentifier;
                (function(ChangeAnnotationIdentifier) {
                    function is(value) {
                        var candidate = value;
                        return Is.string(candidate);
                    }
                    ChangeAnnotationIdentifier.is = is;
                })(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
                var AnnotatedTextEdit;
                (function(AnnotatedTextEdit) {
                    /**
     * Creates an annotated replace text edit.
     *
     * @param range The range of text to be replaced.
     * @param newText The new text.
     * @param annotation The annotation.
     */ function replace(range, newText, annotation) {
                        return {
                            range: range,
                            newText: newText,
                            annotationId: annotation
                        };
                    }
                    AnnotatedTextEdit.replace = replace;
                    /**
     * Creates an annotated insert text edit.
     *
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     * @param annotation The annotation.
     */ function insert(position, newText, annotation) {
                        return {
                            range: {
                                start: position,
                                end: position
                            },
                            newText: newText,
                            annotationId: annotation
                        };
                    }
                    AnnotatedTextEdit.insert = insert;
                    /**
     * Creates an annotated delete text edit.
     *
     * @param range The range of text to be deleted.
     * @param annotation The annotation.
     */ function del(range, annotation) {
                        return {
                            range: range,
                            newText: '',
                            annotationId: annotation
                        };
                    }
                    AnnotatedTextEdit.del = del;
                    function is(value) {
                        var candidate = value;
                        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    AnnotatedTextEdit.is = is;
                })(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
                /**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */ var TextDocumentEdit;
                (function(TextDocumentEdit) {
                    /**
     * Creates a new `TextDocumentEdit`
     */ function create(textDocument, edits) {
                        return {
                            textDocument: textDocument,
                            edits: edits
                        };
                    }
                    TextDocumentEdit.create = create;
                    function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
                    }
                    TextDocumentEdit.is = is;
                })(TextDocumentEdit || (TextDocumentEdit = {}));
                var CreateFile;
                (function(CreateFile) {
                    function create(uri, options, annotation) {
                        var result = {
                            kind: 'create',
                            uri: uri
                        };
                        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
                            result.options = options;
                        }
                        if (annotation !== undefined) {
                            result.annotationId = annotation;
                        }
                        return result;
                    }
                    CreateFile.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    CreateFile.is = is;
                })(CreateFile || (CreateFile = {}));
                var RenameFile;
                (function(RenameFile) {
                    function create(oldUri, newUri, options, annotation) {
                        var result = {
                            kind: 'rename',
                            oldUri: oldUri,
                            newUri: newUri
                        };
                        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
                            result.options = options;
                        }
                        if (annotation !== undefined) {
                            result.annotationId = annotation;
                        }
                        return result;
                    }
                    RenameFile.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    RenameFile.is = is;
                })(RenameFile || (RenameFile = {}));
                var DeleteFile;
                (function(DeleteFile) {
                    function create(uri, options, annotation) {
                        var result = {
                            kind: 'delete',
                            uri: uri
                        };
                        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
                            result.options = options;
                        }
                        if (annotation !== undefined) {
                            result.annotationId = annotation;
                        }
                        return result;
                    }
                    DeleteFile.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    DeleteFile.is = is;
                })(DeleteFile || (DeleteFile = {}));
                var WorkspaceEdit;
                (function(WorkspaceEdit) {
                    function is(value) {
                        var candidate = value;
                        return candidate && (candidate.changes !== undefined || candidate.documentChanges !== undefined) && (candidate.documentChanges === undefined || candidate.documentChanges.every(function(change) {
                            if (Is.string(change.kind)) {
                                return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                            } else {
                                return TextDocumentEdit.is(change);
                            }
                        }));
                    }
                    WorkspaceEdit.is = is;
                })(WorkspaceEdit || (WorkspaceEdit = {}));
                var TextEditChangeImpl = /** @class */ function() {
                    function TextEditChangeImpl(edits, changeAnnotations) {
                        this.edits = edits;
                        this.changeAnnotations = changeAnnotations;
                    }
                    TextEditChangeImpl.prototype.insert = function(position, newText, annotation) {
                        var edit1;
                        var id;
                        if (annotation === undefined) {
                            edit1 = TextEdit.insert(position, newText);
                        } else if (ChangeAnnotationIdentifier.is(annotation)) {
                            id = annotation;
                            edit1 = AnnotatedTextEdit.insert(position, newText, annotation);
                        } else {
                            this.assertChangeAnnotations(this.changeAnnotations);
                            id = this.changeAnnotations.manage(annotation);
                            edit1 = AnnotatedTextEdit.insert(position, newText, id);
                        }
                        this.edits.push(edit1);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    TextEditChangeImpl.prototype.replace = function(range, newText, annotation) {
                        var edit1;
                        var id;
                        if (annotation === undefined) {
                            edit1 = TextEdit.replace(range, newText);
                        } else if (ChangeAnnotationIdentifier.is(annotation)) {
                            id = annotation;
                            edit1 = AnnotatedTextEdit.replace(range, newText, annotation);
                        } else {
                            this.assertChangeAnnotations(this.changeAnnotations);
                            id = this.changeAnnotations.manage(annotation);
                            edit1 = AnnotatedTextEdit.replace(range, newText, id);
                        }
                        this.edits.push(edit1);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    TextEditChangeImpl.prototype.delete = function(range, annotation) {
                        var edit1;
                        var id;
                        if (annotation === undefined) {
                            edit1 = TextEdit.del(range);
                        } else if (ChangeAnnotationIdentifier.is(annotation)) {
                            id = annotation;
                            edit1 = AnnotatedTextEdit.del(range, annotation);
                        } else {
                            this.assertChangeAnnotations(this.changeAnnotations);
                            id = this.changeAnnotations.manage(annotation);
                            edit1 = AnnotatedTextEdit.del(range, id);
                        }
                        this.edits.push(edit1);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    TextEditChangeImpl.prototype.add = function(edit1) {
                        this.edits.push(edit1);
                    };
                    TextEditChangeImpl.prototype.all = function() {
                        return this.edits;
                    };
                    TextEditChangeImpl.prototype.clear = function() {
                        this.edits.splice(0, this.edits.length);
                    };
                    TextEditChangeImpl.prototype.assertChangeAnnotations = function(value) {
                        if (value === undefined) {
                            throw new Error("Text edit change is not configured to manage change annotations.");
                        }
                    };
                    return TextEditChangeImpl;
                }();
                /**
 * A helper class
 */ var ChangeAnnotations = /** @class */ function() {
                    function ChangeAnnotations(annotations) {
                        this._annotations = annotations === undefined ? Object.create(null) : annotations;
                        this._counter = 0;
                        this._size = 0;
                    }
                    ChangeAnnotations.prototype.all = function() {
                        return this._annotations;
                    };
                    Object.defineProperty(ChangeAnnotations.prototype, "size", {
                        get: function() {
                            return this._size;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    ChangeAnnotations.prototype.manage = function(idOrAnnotation, annotation) {
                        var id;
                        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
                            id = idOrAnnotation;
                        } else {
                            id = this.nextId();
                            annotation = idOrAnnotation;
                        }
                        if (this._annotations[id] !== undefined) {
                            throw new Error("Id ".concat(id, " is already in use."));
                        }
                        if (annotation === undefined) {
                            throw new Error("No annotation provided for id ".concat(id));
                        }
                        this._annotations[id] = annotation;
                        this._size++;
                        return id;
                    };
                    ChangeAnnotations.prototype.nextId = function() {
                        this._counter++;
                        return this._counter.toString();
                    };
                    return ChangeAnnotations;
                }();
                /**
 * A workspace change helps constructing changes to a workspace.
 */ var WorkspaceChange = /** @class */ function() {
                    function WorkspaceChange(workspaceEdit) {
                        var _this = this;
                        this._textEditChanges = Object.create(null);
                        if (workspaceEdit !== undefined) {
                            this._workspaceEdit = workspaceEdit;
                            if (workspaceEdit.documentChanges) {
                                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                                workspaceEdit.documentChanges.forEach(function(change) {
                                    if (TextDocumentEdit.is(change)) {
                                        var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                                        _this._textEditChanges[change.textDocument.uri] = textEditChange;
                                    }
                                });
                            } else if (workspaceEdit.changes) {
                                Object.keys(workspaceEdit.changes).forEach(function(key) {
                                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                                    _this._textEditChanges[key] = textEditChange;
                                });
                            }
                        } else {
                            this._workspaceEdit = {};
                        }
                    }
                    Object.defineProperty(WorkspaceChange.prototype, "edit", {
                        /**
         * Returns the underlying {@link WorkspaceEdit} literal
         * use to be returned from a workspace edit operation like rename.
         */ get: function() {
                            this.initDocumentChanges();
                            if (this._changeAnnotations !== undefined) {
                                if (this._changeAnnotations.size === 0) {
                                    this._workspaceEdit.changeAnnotations = undefined;
                                } else {
                                    this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                                }
                            }
                            return this._workspaceEdit;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    WorkspaceChange.prototype.getTextEditChange = function(key) {
                        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
                            this.initDocumentChanges();
                            if (this._workspaceEdit.documentChanges === undefined) {
                                throw new Error('Workspace edit is not configured for document changes.');
                            }
                            var textDocument = {
                                uri: key.uri,
                                version: key.version
                            };
                            var result = this._textEditChanges[textDocument.uri];
                            if (!result) {
                                var edits = [];
                                var textDocumentEdit = {
                                    textDocument: textDocument,
                                    edits: edits
                                };
                                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                                this._textEditChanges[textDocument.uri] = result;
                            }
                            return result;
                        } else {
                            this.initChanges();
                            if (this._workspaceEdit.changes === undefined) {
                                throw new Error('Workspace edit is not configured for normal text edit changes.');
                            }
                            var result = this._textEditChanges[key];
                            if (!result) {
                                var edits = [];
                                this._workspaceEdit.changes[key] = edits;
                                result = new TextEditChangeImpl(edits);
                                this._textEditChanges[key] = result;
                            }
                            return result;
                        }
                    };
                    WorkspaceChange.prototype.initDocumentChanges = function() {
                        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
                            this._changeAnnotations = new ChangeAnnotations();
                            this._workspaceEdit.documentChanges = [];
                            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                        }
                    };
                    WorkspaceChange.prototype.initChanges = function() {
                        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
                            this._workspaceEdit.changes = Object.create(null);
                        }
                    };
                    WorkspaceChange.prototype.createFile = function(uri, optionsOrAnnotation, options) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error('Workspace edit is not configured for document changes.');
                        }
                        var annotation;
                        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                            annotation = optionsOrAnnotation;
                        } else {
                            options = optionsOrAnnotation;
                        }
                        var operation;
                        var id;
                        if (annotation === undefined) {
                            operation = CreateFile.create(uri, options);
                        } else {
                            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                            operation = CreateFile.create(uri, options, id);
                        }
                        this._workspaceEdit.documentChanges.push(operation);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    WorkspaceChange.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error('Workspace edit is not configured for document changes.');
                        }
                        var annotation;
                        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                            annotation = optionsOrAnnotation;
                        } else {
                            options = optionsOrAnnotation;
                        }
                        var operation;
                        var id;
                        if (annotation === undefined) {
                            operation = RenameFile.create(oldUri, newUri, options);
                        } else {
                            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                            operation = RenameFile.create(oldUri, newUri, options, id);
                        }
                        this._workspaceEdit.documentChanges.push(operation);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    WorkspaceChange.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error('Workspace edit is not configured for document changes.');
                        }
                        var annotation;
                        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                            annotation = optionsOrAnnotation;
                        } else {
                            options = optionsOrAnnotation;
                        }
                        var operation;
                        var id;
                        if (annotation === undefined) {
                            operation = DeleteFile.create(uri, options);
                        } else {
                            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                            operation = DeleteFile.create(uri, options, id);
                        }
                        this._workspaceEdit.documentChanges.push(operation);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    return WorkspaceChange;
                }();
                /**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * {@link TextDocumentIdentifier} literals.
 */ var TextDocumentIdentifier;
                (function(TextDocumentIdentifier) {
                    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */ function create(uri) {
                        return {
                            uri: uri
                        };
                    }
                    TextDocumentIdentifier.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri);
                    }
                    TextDocumentIdentifier.is = is;
                })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
                /**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link VersionedTextDocumentIdentifier} literals.
 */ var VersionedTextDocumentIdentifier;
                (function(VersionedTextDocumentIdentifier) {
                    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */ function create(uri, version) {
                        return {
                            uri: uri,
                            version: version
                        };
                    }
                    VersionedTextDocumentIdentifier.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
                    }
                    VersionedTextDocumentIdentifier.is = is;
                })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
                /**
 * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link OptionalVersionedTextDocumentIdentifier} literals.
 */ var OptionalVersionedTextDocumentIdentifier;
                (function(OptionalVersionedTextDocumentIdentifier) {
                    /**
     * Creates a new OptionalVersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */ function create(uri, version) {
                        return {
                            uri: uri,
                            version: version
                        };
                    }
                    OptionalVersionedTextDocumentIdentifier.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
                    }
                    OptionalVersionedTextDocumentIdentifier.is = is;
                })(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
                /**
 * The TextDocumentItem namespace provides helper functions to work with
 * {@link TextDocumentItem} literals.
 */ var TextDocumentItem;
                (function(TextDocumentItem) {
                    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */ function create(uri, languageId, version, text) {
                        return {
                            uri: uri,
                            languageId: languageId,
                            version: version,
                            text: text
                        };
                    }
                    TextDocumentItem.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
                    }
                    TextDocumentItem.is = is;
                })(TextDocumentItem || (TextDocumentItem = {}));
                /**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */ var MarkupKind;
                (function(MarkupKind) {
                    /**
     * Plain text is supported as a content format
     */ MarkupKind.PlainText = 'plaintext';
                    /**
     * Markdown is supported as a content format
     */ MarkupKind.Markdown = 'markdown';
                    /**
     * Checks whether the given value is a value of the {@link MarkupKind} type.
     */ function is(value) {
                        var candidate = value;
                        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
                    }
                    MarkupKind.is = is;
                })(MarkupKind || (MarkupKind = {}));
                var MarkupContent1;
                (function(MarkupContent1) {
                    /**
     * Checks whether the given value conforms to the {@link MarkupContent} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
                    }
                    MarkupContent1.is = is;
                })(MarkupContent1 || (MarkupContent1 = {}));
                /**
 * The kind of a completion entry.
 */ var CompletionItemKind1;
                (function(CompletionItemKind1) {
                    CompletionItemKind1.Text = 1;
                    CompletionItemKind1.Method = 2;
                    CompletionItemKind1.Function = 3;
                    CompletionItemKind1.Constructor = 4;
                    CompletionItemKind1.Field = 5;
                    CompletionItemKind1.Variable = 6;
                    CompletionItemKind1.Class = 7;
                    CompletionItemKind1.Interface = 8;
                    CompletionItemKind1.Module = 9;
                    CompletionItemKind1.Property = 10;
                    CompletionItemKind1.Unit = 11;
                    CompletionItemKind1.Value = 12;
                    CompletionItemKind1.Enum = 13;
                    CompletionItemKind1.Keyword = 14;
                    CompletionItemKind1.Snippet = 15;
                    CompletionItemKind1.Color = 16;
                    CompletionItemKind1.File = 17;
                    CompletionItemKind1.Reference = 18;
                    CompletionItemKind1.Folder = 19;
                    CompletionItemKind1.EnumMember = 20;
                    CompletionItemKind1.Constant = 21;
                    CompletionItemKind1.Struct = 22;
                    CompletionItemKind1.Event = 23;
                    CompletionItemKind1.Operator = 24;
                    CompletionItemKind1.TypeParameter = 25;
                })(CompletionItemKind1 || (CompletionItemKind1 = {}));
                /**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */ var InsertTextFormat1;
                (function(InsertTextFormat1) {
                    /**
     * The primary text to be inserted is treated as a plain string.
     */ InsertTextFormat1.PlainText = 1;
                    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
     */ InsertTextFormat1.Snippet = 2;
                })(InsertTextFormat1 || (InsertTextFormat1 = {}));
                /**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */ var CompletionItemTag;
                (function(CompletionItemTag) {
                    /**
     * Render a completion as obsolete, usually using a strike-out.
     */ CompletionItemTag.Deprecated = 1;
                })(CompletionItemTag || (CompletionItemTag = {}));
                /**
 * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
 *
 * @since 3.16.0
 */ var InsertReplaceEdit;
                (function(InsertReplaceEdit) {
                    /**
     * Creates a new insert / replace edit
     */ function create(newText, insert, replace) {
                        return {
                            newText: newText,
                            insert: insert,
                            replace: replace
                        };
                    }
                    InsertReplaceEdit.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.
     */ function is(value) {
                        var candidate = value;
                        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
                    }
                    InsertReplaceEdit.is = is;
                })(InsertReplaceEdit || (InsertReplaceEdit = {}));
                /**
 * How whitespace and indentation is handled during completion
 * item insertion.
 *
 * @since 3.16.0
 */ var InsertTextMode;
                (function(InsertTextMode) {
                    /**
     * The insertion or replace strings is taken as it is. If the
     * value is multi line the lines below the cursor will be
     * inserted using the indentation defined in the string value.
     * The client will not apply any kind of adjustments to the
     * string.
     */ InsertTextMode.asIs = 1;
                    /**
     * The editor adjusts leading whitespace of new lines so that
     * they match the indentation up to the cursor of the line for
     * which the item is accepted.
     *
     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
     * multi line completion item is indented using 2 tabs and all
     * following lines inserted will be indented using 2 tabs as well.
     */ InsertTextMode.adjustIndentation = 2;
                })(InsertTextMode || (InsertTextMode = {}));
                var CompletionItemLabelDetails;
                (function(CompletionItemLabelDetails) {
                    function is(value) {
                        var candidate = value;
                        return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) && (Is.string(candidate.description) || candidate.description === undefined);
                    }
                    CompletionItemLabelDetails.is = is;
                })(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
                /**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */ var CompletionItem;
                (function(CompletionItem) {
                    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */ function create(label) {
                        return {
                            label: label
                        };
                    }
                    CompletionItem.create = create;
                })(CompletionItem || (CompletionItem = {}));
                /**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */ var CompletionList;
                (function(CompletionList) {
                    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */ function create(items, isIncomplete) {
                        return {
                            items: items ? items : [],
                            isIncomplete: !!isIncomplete
                        };
                    }
                    CompletionList.create = create;
                })(CompletionList || (CompletionList = {}));
                var MarkedString1;
                (function(MarkedString1) {
                    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */ function fromPlainText(plainText) {
                        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
                    }
                    MarkedString1.fromPlainText = fromPlainText;
                    /**
     * Checks whether the given value conforms to the {@link MarkedString} type.
     */ function is(value) {
                        var candidate = value;
                        return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
                    }
                    MarkedString1.is = is;
                })(MarkedString1 || (MarkedString1 = {}));
                var Hover;
                (function(Hover) {
                    /**
     * Checks whether the given value conforms to the {@link Hover} interface.
     */ function is(value) {
                        var candidate = value;
                        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent1.is(candidate.contents) || MarkedString1.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString1.is)) && (value.range === undefined || Range.is(value.range));
                    }
                    Hover.is = is;
                })(Hover || (Hover = {}));
                /**
 * The ParameterInformation namespace provides helper functions to work with
 * {@link ParameterInformation} literals.
 */ var ParameterInformation;
                (function(ParameterInformation) {
                    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */ function create(label, documentation) {
                        return documentation ? {
                            label: label,
                            documentation: documentation
                        } : {
                            label: label
                        };
                    }
                    ParameterInformation.create = create;
                })(ParameterInformation || (ParameterInformation = {}));
                /**
 * The SignatureInformation namespace provides helper functions to work with
 * {@link SignatureInformation} literals.
 */ var SignatureInformation;
                (function(SignatureInformation) {
                    function create(label, documentation) {
                        var parameters = [];
                        for(var _i = 2; _i < arguments.length; _i++){
                            parameters[_i - 2] = arguments[_i];
                        }
                        var result = {
                            label: label
                        };
                        if (Is.defined(documentation)) {
                            result.documentation = documentation;
                        }
                        if (Is.defined(parameters)) {
                            result.parameters = parameters;
                        } else {
                            result.parameters = [];
                        }
                        return result;
                    }
                    SignatureInformation.create = create;
                })(SignatureInformation || (SignatureInformation = {}));
                /**
 * A document highlight kind.
 */ var DocumentHighlightKind;
                (function(DocumentHighlightKind) {
                    /**
     * A textual occurrence.
     */ DocumentHighlightKind.Text = 1;
                    /**
     * Read-access of a symbol, like reading a variable.
     */ DocumentHighlightKind.Read = 2;
                    /**
     * Write-access of a symbol, like writing to a variable.
     */ DocumentHighlightKind.Write = 3;
                })(DocumentHighlightKind || (DocumentHighlightKind = {}));
                /**
 * DocumentHighlight namespace to provide helper functions to work with
 * {@link DocumentHighlight} literals.
 */ var DocumentHighlight;
                (function(DocumentHighlight) {
                    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     * @param kind The highlight kind
     */ function create(range, kind) {
                        var result = {
                            range: range
                        };
                        if (Is.number(kind)) {
                            result.kind = kind;
                        }
                        return result;
                    }
                    DocumentHighlight.create = create;
                })(DocumentHighlight || (DocumentHighlight = {}));
                /**
 * A symbol kind.
 */ var SymbolKind;
                (function(SymbolKind) {
                    SymbolKind.File = 1;
                    SymbolKind.Module = 2;
                    SymbolKind.Namespace = 3;
                    SymbolKind.Package = 4;
                    SymbolKind.Class = 5;
                    SymbolKind.Method = 6;
                    SymbolKind.Property = 7;
                    SymbolKind.Field = 8;
                    SymbolKind.Constructor = 9;
                    SymbolKind.Enum = 10;
                    SymbolKind.Interface = 11;
                    SymbolKind.Function = 12;
                    SymbolKind.Variable = 13;
                    SymbolKind.Constant = 14;
                    SymbolKind.String = 15;
                    SymbolKind.Number = 16;
                    SymbolKind.Boolean = 17;
                    SymbolKind.Array = 18;
                    SymbolKind.Object = 19;
                    SymbolKind.Key = 20;
                    SymbolKind.Null = 21;
                    SymbolKind.EnumMember = 22;
                    SymbolKind.Struct = 23;
                    SymbolKind.Event = 24;
                    SymbolKind.Operator = 25;
                    SymbolKind.TypeParameter = 26;
                })(SymbolKind || (SymbolKind = {}));
                /**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 *
 * @since 3.16
 */ var SymbolTag;
                (function(SymbolTag) {
                    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */ SymbolTag.Deprecated = 1;
                })(SymbolTag || (SymbolTag = {}));
                var SymbolInformation;
                (function(SymbolInformation) {
                    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol.
     * @param containerName The name of the symbol containing the symbol.
     */ function create(name, kind, range, uri, containerName) {
                        var result = {
                            name: name,
                            kind: kind,
                            location: {
                                uri: uri,
                                range: range
                            }
                        };
                        if (containerName) {
                            result.containerName = containerName;
                        }
                        return result;
                    }
                    SymbolInformation.create = create;
                })(SymbolInformation || (SymbolInformation = {}));
                var WorkspaceSymbol;
                (function(WorkspaceSymbol) {
                    /**
     * Create a new workspace symbol.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param uri The resource of the location of the symbol.
     * @param range An options range of the location.
     * @returns A WorkspaceSymbol.
     */ function create(name, kind, uri, range) {
                        return range !== undefined ? {
                            name: name,
                            kind: kind,
                            location: {
                                uri: uri,
                                range: range
                            }
                        } : {
                            name: name,
                            kind: kind,
                            location: {
                                uri: uri
                            }
                        };
                    }
                    WorkspaceSymbol.create = create;
                })(WorkspaceSymbol || (WorkspaceSymbol = {}));
                var DocumentSymbol;
                (function(DocumentSymbol) {
                    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */ function create(name, detail, kind, range, selectionRange, children) {
                        var result = {
                            name: name,
                            detail: detail,
                            kind: kind,
                            range: range,
                            selectionRange: selectionRange
                        };
                        if (children !== undefined) {
                            result.children = children;
                        }
                        return result;
                    }
                    DocumentSymbol.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.
     */ function is(value) {
                        var candidate = value;
                        return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === undefined || Is.string(candidate.detail)) && (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) && (candidate.children === undefined || Array.isArray(candidate.children)) && (candidate.tags === undefined || Array.isArray(candidate.tags));
                    }
                    DocumentSymbol.is = is;
                })(DocumentSymbol || (DocumentSymbol = {}));
                /**
 * A set of predefined code action kinds
 */ var CodeActionKind;
                (function(CodeActionKind) {
                    /**
     * Empty kind.
     */ CodeActionKind.Empty = '';
                    /**
     * Base kind for quickfix actions: 'quickfix'
     */ CodeActionKind.QuickFix = 'quickfix';
                    /**
     * Base kind for refactoring actions: 'refactor'
     */ CodeActionKind.Refactor = 'refactor';
                    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */ CodeActionKind.RefactorExtract = 'refactor.extract';
                    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */ CodeActionKind.RefactorInline = 'refactor.inline';
                    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */ CodeActionKind.RefactorRewrite = 'refactor.rewrite';
                    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */ CodeActionKind.Source = 'source';
                    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */ CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
                    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */ CodeActionKind.SourceFixAll = 'source.fixAll';
                })(CodeActionKind || (CodeActionKind = {}));
                /**
 * The reason why code actions were requested.
 *
 * @since 3.17.0
 */ var CodeActionTriggerKind;
                (function(CodeActionTriggerKind) {
                    /**
     * Code actions were explicitly requested by the user or by an extension.
     */ CodeActionTriggerKind.Invoked = 1;
                    /**
     * Code actions were requested automatically.
     *
     * This typically happens when current selection in a file changes, but can
     * also be triggered when file content changes.
     */ CodeActionTriggerKind.Automatic = 2;
                })(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
                /**
 * The CodeActionContext namespace provides helper functions to work with
 * {@link CodeActionContext} literals.
 */ var CodeActionContext;
                (function(CodeActionContext) {
                    /**
     * Creates a new CodeActionContext literal.
     */ function create(diagnostics, only, triggerKind) {
                        var result = {
                            diagnostics: diagnostics
                        };
                        if (only !== undefined && only !== null) {
                            result.only = only;
                        }
                        if (triggerKind !== undefined && triggerKind !== null) {
                            result.triggerKind = triggerKind;
                        }
                        return result;
                    }
                    CodeActionContext.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link CodeActionContext} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
                    }
                    CodeActionContext.is = is;
                })(CodeActionContext || (CodeActionContext = {}));
                var CodeAction;
                (function(CodeAction) {
                    function create(title, kindOrCommandOrEdit, kind) {
                        var result = {
                            title: title
                        };
                        var checkKind = true;
                        if (typeof kindOrCommandOrEdit === 'string') {
                            checkKind = false;
                            result.kind = kindOrCommandOrEdit;
                        } else if (Command.is(kindOrCommandOrEdit)) {
                            result.command = kindOrCommandOrEdit;
                        } else {
                            result.edit = kindOrCommandOrEdit;
                        }
                        if (checkKind && kind !== undefined) {
                            result.kind = kind;
                        }
                        return result;
                    }
                    CodeAction.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate && Is.string(candidate.title) && (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === undefined || Is.string(candidate.kind)) && (candidate.edit !== undefined || candidate.command !== undefined) && (candidate.command === undefined || Command.is(candidate.command)) && (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) && (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
                    }
                    CodeAction.is = is;
                })(CodeAction || (CodeAction = {}));
                /**
 * The CodeLens namespace provides helper functions to work with
 * {@link CodeLens} literals.
 */ var CodeLens;
                (function(CodeLens) {
                    /**
     * Creates a new CodeLens literal.
     */ function create(range, data) {
                        var result = {
                            range: range
                        };
                        if (Is.defined(data)) {
                            result.data = data;
                        }
                        return result;
                    }
                    CodeLens.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link CodeLens} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
                    }
                    CodeLens.is = is;
                })(CodeLens || (CodeLens = {}));
                /**
 * The FormattingOptions namespace provides helper functions to work with
 * {@link FormattingOptions} literals.
 */ var FormattingOptions;
                (function(FormattingOptions) {
                    /**
     * Creates a new FormattingOptions literal.
     */ function create(tabSize, insertSpaces) {
                        return {
                            tabSize: tabSize,
                            insertSpaces: insertSpaces
                        };
                    }
                    FormattingOptions.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link FormattingOptions} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
                    }
                    FormattingOptions.is = is;
                })(FormattingOptions || (FormattingOptions = {}));
                /**
 * The DocumentLink namespace provides helper functions to work with
 * {@link DocumentLink} literals.
 */ var DocumentLink;
                (function(DocumentLink) {
                    /**
     * Creates a new DocumentLink literal.
     */ function create(range, target, data) {
                        return {
                            range: range,
                            target: target,
                            data: data
                        };
                    }
                    DocumentLink.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link DocumentLink} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
                    }
                    DocumentLink.is = is;
                })(DocumentLink || (DocumentLink = {}));
                /**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */ var SelectionRange;
                (function(SelectionRange) {
                    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */ function create(range, parent) {
                        return {
                            range: range,
                            parent: parent
                        };
                    }
                    SelectionRange.create = create;
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
                    }
                    SelectionRange.is = is;
                })(SelectionRange || (SelectionRange = {}));
                /**
 * A set of predefined token types. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */ var SemanticTokenTypes;
                (function(SemanticTokenTypes) {
                    SemanticTokenTypes["namespace"] = "namespace";
                    /**
     * Represents a generic type. Acts as a fallback for types which can't be mapped to
     * a specific type like class or enum.
     */ SemanticTokenTypes["type"] = "type";
                    SemanticTokenTypes["class"] = "class";
                    SemanticTokenTypes["enum"] = "enum";
                    SemanticTokenTypes["interface"] = "interface";
                    SemanticTokenTypes["struct"] = "struct";
                    SemanticTokenTypes["typeParameter"] = "typeParameter";
                    SemanticTokenTypes["parameter"] = "parameter";
                    SemanticTokenTypes["variable"] = "variable";
                    SemanticTokenTypes["property"] = "property";
                    SemanticTokenTypes["enumMember"] = "enumMember";
                    SemanticTokenTypes["event"] = "event";
                    SemanticTokenTypes["function"] = "function";
                    SemanticTokenTypes["method"] = "method";
                    SemanticTokenTypes["macro"] = "macro";
                    SemanticTokenTypes["keyword"] = "keyword";
                    SemanticTokenTypes["modifier"] = "modifier";
                    SemanticTokenTypes["comment"] = "comment";
                    SemanticTokenTypes["string"] = "string";
                    SemanticTokenTypes["number"] = "number";
                    SemanticTokenTypes["regexp"] = "regexp";
                    SemanticTokenTypes["operator"] = "operator";
                    /**
     * @since 3.17.0
     */ SemanticTokenTypes["decorator"] = "decorator";
                })(SemanticTokenTypes || (SemanticTokenTypes = {}));
                /**
 * A set of predefined token modifiers. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */ var SemanticTokenModifiers;
                (function(SemanticTokenModifiers) {
                    SemanticTokenModifiers["declaration"] = "declaration";
                    SemanticTokenModifiers["definition"] = "definition";
                    SemanticTokenModifiers["readonly"] = "readonly";
                    SemanticTokenModifiers["static"] = "static";
                    SemanticTokenModifiers["deprecated"] = "deprecated";
                    SemanticTokenModifiers["abstract"] = "abstract";
                    SemanticTokenModifiers["async"] = "async";
                    SemanticTokenModifiers["modification"] = "modification";
                    SemanticTokenModifiers["documentation"] = "documentation";
                    SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";
                })(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokens;
                (function(SemanticTokens) {
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
                    }
                    SemanticTokens.is = is;
                })(SemanticTokens || (SemanticTokens = {}));
                /**
 * The InlineValueText namespace provides functions to deal with InlineValueTexts.
 *
 * @since 3.17.0
 */ var InlineValueText;
                (function(InlineValueText) {
                    /**
     * Creates a new InlineValueText literal.
     */ function create(range, text) {
                        return {
                            range: range,
                            text: text
                        };
                    }
                    InlineValueText.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
                    }
                    InlineValueText.is = is;
                })(InlineValueText || (InlineValueText = {}));
                /**
 * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.
 *
 * @since 3.17.0
 */ var InlineValueVariableLookup;
                (function(InlineValueVariableLookup) {
                    /**
     * Creates a new InlineValueText literal.
     */ function create(range, variableName, caseSensitiveLookup) {
                        return {
                            range: range,
                            variableName: variableName,
                            caseSensitiveLookup: caseSensitiveLookup
                        };
                    }
                    InlineValueVariableLookup.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === undefined);
                    }
                    InlineValueVariableLookup.is = is;
                })(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
                /**
 * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.
 *
 * @since 3.17.0
 */ var InlineValueEvaluatableExpression;
                (function(InlineValueEvaluatableExpression) {
                    /**
     * Creates a new InlineValueEvaluatableExpression literal.
     */ function create(range, expression) {
                        return {
                            range: range,
                            expression: expression
                        };
                    }
                    InlineValueEvaluatableExpression.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === undefined);
                    }
                    InlineValueEvaluatableExpression.is = is;
                })(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
                /**
 * The InlineValueContext namespace provides helper functions to work with
 * {@link InlineValueContext} literals.
 *
 * @since 3.17.0
 */ var InlineValueContext;
                (function(InlineValueContext) {
                    /**
     * Creates a new InlineValueContext literal.
     */ function create(frameId, stoppedLocation) {
                        return {
                            frameId: frameId,
                            stoppedLocation: stoppedLocation
                        };
                    }
                    InlineValueContext.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link InlineValueContext} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Range.is(value.stoppedLocation);
                    }
                    InlineValueContext.is = is;
                })(InlineValueContext || (InlineValueContext = {}));
                /**
 * Inlay hint kinds.
 *
 * @since 3.17.0
 */ var InlayHintKind;
                (function(InlayHintKind) {
                    /**
     * An inlay hint that for a type annotation.
     */ InlayHintKind.Type = 1;
                    /**
     * An inlay hint that is for a parameter.
     */ InlayHintKind.Parameter = 2;
                    function is(value) {
                        return value === 1 || value === 2;
                    }
                    InlayHintKind.is = is;
                })(InlayHintKind || (InlayHintKind = {}));
                var InlayHintLabelPart;
                (function(InlayHintLabelPart) {
                    function create(value) {
                        return {
                            value: value
                        };
                    }
                    InlayHintLabelPart.create = create;
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent1.is(candidate.tooltip)) && (candidate.location === undefined || Location.is(candidate.location)) && (candidate.command === undefined || Command.is(candidate.command));
                    }
                    InlayHintLabelPart.is = is;
                })(InlayHintLabelPart || (InlayHintLabelPart = {}));
                var InlayHint;
                (function(InlayHint) {
                    function create(position, label, kind) {
                        var result = {
                            position: position,
                            label: label
                        };
                        if (kind !== undefined) {
                            result.kind = kind;
                        }
                        return result;
                    }
                    InlayHint.create = create;
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === undefined || InlayHintKind.is(candidate.kind)) && candidate.textEdits === undefined || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent1.is(candidate.tooltip)) && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));
                    }
                    InlayHint.is = is;
                })(InlayHint || (InlayHint = {}));
                var WorkspaceFolder;
                (function(WorkspaceFolder) {
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
                    }
                    WorkspaceFolder.is = is;
                })(WorkspaceFolder || (WorkspaceFolder = {}));
                var EOL = [
                    '\n',
                    '\r\n',
                    '\r'
                ];
                /**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */ var TextDocument;
                (function(TextDocument) {
                    /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId The document's language Id.
     * @param version The document's version.
     * @param content The document's content.
     */ function create(uri, languageId, version, content) {
                        return new FullTextDocument(uri, languageId, version, content);
                    }
                    TextDocument.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link ITextDocument} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
                    }
                    TextDocument.is = is;
                    function applyEdits(document1, edits) {
                        var text = document1.getText();
                        var sortedEdits = mergeSort(edits, function(a, b) {
                            var diff = a.range.start.line - b.range.start.line;
                            if (diff === 0) {
                                return a.range.start.character - b.range.start.character;
                            }
                            return diff;
                        });
                        var lastModifiedOffset = text.length;
                        for(var i = sortedEdits.length - 1; i >= 0; i--){
                            var e = sortedEdits[i];
                            var startOffset = document1.offsetAt(e.range.start);
                            var endOffset = document1.offsetAt(e.range.end);
                            if (endOffset <= lastModifiedOffset) {
                                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
                            } else {
                                throw new Error('Overlapping edit');
                            }
                            lastModifiedOffset = startOffset;
                        }
                        return text;
                    }
                    TextDocument.applyEdits = applyEdits;
                    function mergeSort(data, compare) {
                        if (data.length <= 1) {
                            // sorted
                            return data;
                        }
                        var p = data.length / 2 | 0;
                        var left = data.slice(0, p);
                        var right = data.slice(p);
                        mergeSort(left, compare);
                        mergeSort(right, compare);
                        var leftIdx = 0;
                        var rightIdx = 0;
                        var i = 0;
                        while(leftIdx < left.length && rightIdx < right.length){
                            var ret = compare(left[leftIdx], right[rightIdx]);
                            if (ret <= 0) {
                                // smaller_equal -> take left to preserve order
                                data[i++] = left[leftIdx++];
                            } else {
                                // greater -> take right
                                data[i++] = right[rightIdx++];
                            }
                        }
                        while(leftIdx < left.length){
                            data[i++] = left[leftIdx++];
                        }
                        while(rightIdx < right.length){
                            data[i++] = right[rightIdx++];
                        }
                        return data;
                    }
                })(TextDocument || (TextDocument = {}));
                /**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */ var FullTextDocument = /** @class */ function() {
                    function FullTextDocument(uri, languageId, version, content) {
                        this._uri = uri;
                        this._languageId = languageId;
                        this._version = version;
                        this._content = content;
                        this._lineOffsets = undefined;
                    }
                    Object.defineProperty(FullTextDocument.prototype, "uri", {
                        get: function() {
                            return this._uri;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(FullTextDocument.prototype, "languageId", {
                        get: function() {
                            return this._languageId;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(FullTextDocument.prototype, "version", {
                        get: function() {
                            return this._version;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    FullTextDocument.prototype.getText = function(range) {
                        if (range) {
                            var start = this.offsetAt(range.start);
                            var end = this.offsetAt(range.end);
                            return this._content.substring(start, end);
                        }
                        return this._content;
                    };
                    FullTextDocument.prototype.update = function(event, version) {
                        this._content = event.text;
                        this._version = version;
                        this._lineOffsets = undefined;
                    };
                    FullTextDocument.prototype.getLineOffsets = function() {
                        if (this._lineOffsets === undefined) {
                            var lineOffsets = [];
                            var text = this._content;
                            var isLineStart = true;
                            for(var i = 0; i < text.length; i++){
                                if (isLineStart) {
                                    lineOffsets.push(i);
                                    isLineStart = false;
                                }
                                var ch = text.charAt(i);
                                isLineStart = ch === '\r' || ch === '\n';
                                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                                    i++;
                                }
                            }
                            if (isLineStart && text.length > 0) {
                                lineOffsets.push(text.length);
                            }
                            this._lineOffsets = lineOffsets;
                        }
                        return this._lineOffsets;
                    };
                    FullTextDocument.prototype.positionAt = function(offset) {
                        offset = Math.max(Math.min(offset, this._content.length), 0);
                        var lineOffsets = this.getLineOffsets();
                        var low = 0, high = lineOffsets.length;
                        if (high === 0) {
                            return Position.create(0, offset);
                        }
                        while(low < high){
                            var mid = Math.floor((low + high) / 2);
                            if (lineOffsets[mid] > offset) {
                                high = mid;
                            } else {
                                low = mid + 1;
                            }
                        }
                        // low is the least x for which the line offset is larger than the current offset
                        // or array.length if no line offset is larger than the current offset
                        var line = low - 1;
                        return Position.create(line, offset - lineOffsets[line]);
                    };
                    FullTextDocument.prototype.offsetAt = function(position) {
                        var lineOffsets = this.getLineOffsets();
                        if (position.line >= lineOffsets.length) {
                            return this._content.length;
                        } else if (position.line < 0) {
                            return 0;
                        }
                        var lineOffset = lineOffsets[position.line];
                        var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
                        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
                    };
                    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
                        get: function() {
                            return this.getLineOffsets().length;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    return FullTextDocument;
                }();
                var Is;
                (function(Is) {
                    var toString = Object.prototype.toString;
                    function defined(value) {
                        return typeof value !== 'undefined';
                    }
                    Is.defined = defined;
                    function undefined1(value) {
                        return typeof value === 'undefined';
                    }
                    Is.undefined = undefined1;
                    function boolean(value) {
                        return value === true || value === false;
                    }
                    Is.boolean = boolean;
                    function string(value) {
                        return toString.call(value) === '[object String]';
                    }
                    Is.string = string;
                    function number(value) {
                        return toString.call(value) === '[object Number]';
                    }
                    Is.number = number;
                    function numberRange(value, min, max) {
                        return toString.call(value) === '[object Number]' && min <= value && value <= max;
                    }
                    Is.numberRange = numberRange;
                    function integer(value) {
                        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;
                    }
                    Is.integer = integer;
                    function uinteger(value) {
                        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;
                    }
                    Is.uinteger = uinteger;
                    function func(value) {
                        return toString.call(value) === '[object Function]';
                    }
                    Is.func = func;
                    function objectLiteral(value) {
                        // Strictly speaking class instances pass this check as well. Since the LSP
                        // doesn't use classes we ignore this for now. If we do we need to add something
                        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
                        return value !== null && typeof value === 'object';
                    }
                    Is.objectLiteral = objectLiteral;
                    function typedArray(value, check) {
                        return Array.isArray(value) && value.every(check);
                    }
                    Is.typedArray = typedArray;
                })(Is || (Is = {}));
            /***/ },
            /***/ 2094: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_696006__)=>{
                "use strict";
                var forEach = __nested_webpack_require_696006__(3243);
                var availableTypedArrays = __nested_webpack_require_696006__(2191);
                var callBind = __nested_webpack_require_696006__(9429);
                var callBound = __nested_webpack_require_696006__(2680);
                var gOPD = __nested_webpack_require_696006__(326);
                var $toString = callBound('Object.prototype.toString');
                var hasToStringTag = __nested_webpack_require_696006__(7226)();
                var g = typeof globalThis === 'undefined' ? __nested_webpack_require_696006__.g : globalThis;
                var typedArrays = availableTypedArrays();
                var $slice = callBound('String.prototype.slice');
                var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
                var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
                    for(var i = 0; i < array.length; i += 1){
                        if (array[i] === value) {
                            return i;
                        }
                    }
                    return -1;
                };
                var cache = {
                    __proto__: null
                };
                if (hasToStringTag && gOPD && getPrototypeOf) {
                    forEach(typedArrays, function(typedArray) {
                        var arr = new g[typedArray]();
                        if (Symbol.toStringTag in arr) {
                            var proto = getPrototypeOf(arr);
                            var descriptor = gOPD(proto, Symbol.toStringTag);
                            if (!descriptor) {
                                var superProto = getPrototypeOf(proto);
                                descriptor = gOPD(superProto, Symbol.toStringTag);
                            }
                            cache['$' + typedArray] = callBind(descriptor.get);
                        }
                    });
                } else {
                    forEach(typedArrays, function(typedArray) {
                        var arr = new g[typedArray]();
                        cache['$' + typedArray] = callBind(arr.slice);
                    });
                }
                var tryTypedArrays = function tryAllTypedArrays(value) {
                    var found = false;
                    forEach(cache, function(getter, typedArray) {
                        if (!found) {
                            try {
                                if ('$' + getter(value) === typedArray) {
                                    found = $slice(typedArray, 1);
                                }
                            } catch (e) {}
                        }
                    });
                    return found;
                };
                var trySlices = function tryAllSlices(value) {
                    var found = false;
                    forEach(cache, function(getter, name) {
                        if (!found) {
                            try {
                                getter(value);
                                found = $slice(name, 1);
                            } catch (e) {}
                        }
                    });
                    return found;
                };
                module1.exports = function whichTypedArray(value) {
                    if (!value || typeof value !== 'object') {
                        return false;
                    }
                    if (!hasToStringTag) {
                        var tag = $slice($toString(value), 8, -1);
                        if ($indexOf(typedArrays, tag) > -1) {
                            return tag;
                        }
                        if (tag !== 'Object') {
                            return false;
                        }
                        // node < 0.6 hits here on real Typed Arrays
                        return trySlices(value);
                    }
                    if (!gOPD) {
                        return null;
                    } // unknown engine
                    return tryTypedArrays(value);
                };
            /***/ },
            /***/ 2191: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_700253__)=>{
                "use strict";
                var possibleNames = [
                    'BigInt64Array',
                    'BigUint64Array',
                    'Float32Array',
                    'Float64Array',
                    'Int16Array',
                    'Int32Array',
                    'Int8Array',
                    'Uint16Array',
                    'Uint32Array',
                    'Uint8Array',
                    'Uint8ClampedArray'
                ];
                var g = typeof globalThis === 'undefined' ? __nested_webpack_require_700253__.g : globalThis;
                module1.exports = function availableTypedArrays() {
                    var out = [];
                    for(var i = 0; i < possibleNames.length; i++){
                        if (typeof g[possibleNames[i]] === 'function') {
                            out[out.length] = possibleNames[i];
                        }
                    }
                    return out;
                };
            /***/ }
        };
        /************************************************************************/ /******/ // The module cache
        /******/ var __webpack_module_cache__ = {};
        /******/ /******/ // The require function
        /******/ function __nested_webpack_require_701519__(moduleId) {
            /******/ // Check if module is in cache
            /******/ var cachedModule = __webpack_module_cache__[moduleId];
            /******/ if (cachedModule !== undefined) {
                /******/ return cachedModule.exports;
            /******/ }
            /******/ // Create a new module (and put it into the cache)
            /******/ var module1 = __webpack_module_cache__[moduleId] = {
                /******/ // no module.id needed
                /******/ // no module.loaded needed
                /******/ exports: {}
            };
            /******/ /******/ // Execute the module function
            /******/ __webpack_modules__[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_701519__);
            /******/ /******/ // Return the exports of the module
            /******/ return module1.exports;
        /******/ }
        /******/ /************************************************************************/ /******/ /* webpack/runtime/define property getters */ /******/ (()=>{
            /******/ // define getter functions for harmony exports
            /******/ __nested_webpack_require_701519__.d = (exports1, definition)=>{
                /******/ for(var key in definition){
                    /******/ if (__nested_webpack_require_701519__.o(definition, key) && !__nested_webpack_require_701519__.o(exports1, key)) {
                        /******/ Object.defineProperty(exports1, key, {
                            enumerable: true,
                            get: definition[key]
                        });
                    /******/ }
                /******/ }
            /******/ };
        /******/ })();
        /******/ /******/ /* webpack/runtime/global */ /******/ (()=>{
            /******/ __nested_webpack_require_701519__.g = function() {
                /******/ if (typeof globalThis === 'object') return globalThis;
                /******/ try {
                    /******/ return this || new Function('return this')();
                /******/ } catch (e) {
                    /******/ if (typeof window === 'object') return window;
                /******/ }
            /******/ }();
        /******/ })();
        /******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ (()=>{
            /******/ __nested_webpack_require_701519__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
        /******/ })();
        /******/ /******/ /* webpack/runtime/make namespace object */ /******/ (()=>{
            /******/ // define __esModule on exports
            /******/ __nested_webpack_require_701519__.r = (exports1)=>{
                /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
                    /******/ Object.defineProperty(exports1, Symbol.toStringTag, {
                        value: 'Module'
                    });
                /******/ }
                /******/ Object.defineProperty(exports1, '__esModule', {
                    value: true
                });
            /******/ };
        /******/ })();
        /******/ /************************************************************************/ var __nested_webpack_exports__ = {};
        // This entry need to be wrapped in an IIFE because it need to be in strict mode.
        (()=>{
            "use strict";
            // ESM COMPAT FLAG
            __nested_webpack_require_701519__.r(__nested_webpack_exports__);
            // EXPORTS
            __nested_webpack_require_701519__.d(__nested_webpack_exports__, {
                JsonService: ()=>/* binding */ JsonService
            });
            // EXTERNAL MODULE: ./src/services/base-service.ts
            var base_service = __nested_webpack_require_701519__(4487);
            ; // CONCATENATED MODULE: ../../node_modules/jsonc-parser/lib/esm/impl/scanner.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ /**
 * Creates a JSON scanner on the given text.
 * If ignoreTrivia is set, whitespaces or comments are ignored.
 */ function createScanner(text, ignoreTrivia = false) {
                const len = text.length;
                let pos = 0, value = '', tokenOffset = 0, token = 16 /* SyntaxKind.Unknown */ , lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0 /* ScanError.None */ ;
                function scanHexDigits(count, exact) {
                    let digits = 0;
                    let value = 0;
                    while(digits < count || !exact){
                        let ch = text.charCodeAt(pos);
                        if (ch >= 48 /* CharacterCodes._0 */  && ch <= 57 /* CharacterCodes._9 */ ) {
                            value = value * 16 + ch - 48 /* CharacterCodes._0 */ ;
                        } else if (ch >= 65 /* CharacterCodes.A */  && ch <= 70 /* CharacterCodes.F */ ) {
                            value = value * 16 + ch - 65 /* CharacterCodes.A */  + 10;
                        } else if (ch >= 97 /* CharacterCodes.a */  && ch <= 102 /* CharacterCodes.f */ ) {
                            value = value * 16 + ch - 97 /* CharacterCodes.a */  + 10;
                        } else {
                            break;
                        }
                        pos++;
                        digits++;
                    }
                    if (digits < count) {
                        value = -1;
                    }
                    return value;
                }
                function setPosition(newPosition) {
                    pos = newPosition;
                    value = '';
                    tokenOffset = 0;
                    token = 16 /* SyntaxKind.Unknown */ ;
                    scanError = 0 /* ScanError.None */ ;
                }
                function scanNumber() {
                    let start = pos;
                    if (text.charCodeAt(pos) === 48 /* CharacterCodes._0 */ ) {
                        pos++;
                    } else {
                        pos++;
                        while(pos < text.length && isDigit(text.charCodeAt(pos))){
                            pos++;
                        }
                    }
                    if (pos < text.length && text.charCodeAt(pos) === 46 /* CharacterCodes.dot */ ) {
                        pos++;
                        if (pos < text.length && isDigit(text.charCodeAt(pos))) {
                            pos++;
                            while(pos < text.length && isDigit(text.charCodeAt(pos))){
                                pos++;
                            }
                        } else {
                            scanError = 3 /* ScanError.UnexpectedEndOfNumber */ ;
                            return text.substring(start, pos);
                        }
                    }
                    let end = pos;
                    if (pos < text.length && (text.charCodeAt(pos) === 69 /* CharacterCodes.E */  || text.charCodeAt(pos) === 101 /* CharacterCodes.e */ )) {
                        pos++;
                        if (pos < text.length && text.charCodeAt(pos) === 43 /* CharacterCodes.plus */  || text.charCodeAt(pos) === 45 /* CharacterCodes.minus */ ) {
                            pos++;
                        }
                        if (pos < text.length && isDigit(text.charCodeAt(pos))) {
                            pos++;
                            while(pos < text.length && isDigit(text.charCodeAt(pos))){
                                pos++;
                            }
                            end = pos;
                        } else {
                            scanError = 3 /* ScanError.UnexpectedEndOfNumber */ ;
                        }
                    }
                    return text.substring(start, end);
                }
                function scanString() {
                    let result = '', start = pos;
                    while(true){
                        if (pos >= len) {
                            result += text.substring(start, pos);
                            scanError = 2 /* ScanError.UnexpectedEndOfString */ ;
                            break;
                        }
                        const ch = text.charCodeAt(pos);
                        if (ch === 34 /* CharacterCodes.doubleQuote */ ) {
                            result += text.substring(start, pos);
                            pos++;
                            break;
                        }
                        if (ch === 92 /* CharacterCodes.backslash */ ) {
                            result += text.substring(start, pos);
                            pos++;
                            if (pos >= len) {
                                scanError = 2 /* ScanError.UnexpectedEndOfString */ ;
                                break;
                            }
                            const ch2 = text.charCodeAt(pos++);
                            switch(ch2){
                                case 34 /* CharacterCodes.doubleQuote */ :
                                    result += '\"';
                                    break;
                                case 92 /* CharacterCodes.backslash */ :
                                    result += '\\';
                                    break;
                                case 47 /* CharacterCodes.slash */ :
                                    result += '/';
                                    break;
                                case 98 /* CharacterCodes.b */ :
                                    result += '\b';
                                    break;
                                case 102 /* CharacterCodes.f */ :
                                    result += '\f';
                                    break;
                                case 110 /* CharacterCodes.n */ :
                                    result += '\n';
                                    break;
                                case 114 /* CharacterCodes.r */ :
                                    result += '\r';
                                    break;
                                case 116 /* CharacterCodes.t */ :
                                    result += '\t';
                                    break;
                                case 117 /* CharacterCodes.u */ :
                                    const ch3 = scanHexDigits(4, true);
                                    if (ch3 >= 0) {
                                        result += String.fromCharCode(ch3);
                                    } else {
                                        scanError = 4 /* ScanError.InvalidUnicode */ ;
                                    }
                                    break;
                                default:
                                    scanError = 5 /* ScanError.InvalidEscapeCharacter */ ;
                            }
                            start = pos;
                            continue;
                        }
                        if (ch >= 0 && ch <= 0x1f) {
                            if (isLineBreak(ch)) {
                                result += text.substring(start, pos);
                                scanError = 2 /* ScanError.UnexpectedEndOfString */ ;
                                break;
                            } else {
                                scanError = 6 /* ScanError.InvalidCharacter */ ;
                            // mark as error but continue with string
                            }
                        }
                        pos++;
                    }
                    return result;
                }
                function scanNext() {
                    value = '';
                    scanError = 0 /* ScanError.None */ ;
                    tokenOffset = pos;
                    lineStartOffset = lineNumber;
                    prevTokenLineStartOffset = tokenLineStartOffset;
                    if (pos >= len) {
                        // at the end
                        tokenOffset = len;
                        return token = 17 /* SyntaxKind.EOF */ ;
                    }
                    let code = text.charCodeAt(pos);
                    // trivia: whitespace
                    if (isWhiteSpace(code)) {
                        do {
                            pos++;
                            value += String.fromCharCode(code);
                            code = text.charCodeAt(pos);
                        }while (isWhiteSpace(code))
                        return token = 15 /* SyntaxKind.Trivia */ ;
                    }
                    // trivia: newlines
                    if (isLineBreak(code)) {
                        pos++;
                        value += String.fromCharCode(code);
                        if (code === 13 /* CharacterCodes.carriageReturn */  && text.charCodeAt(pos) === 10 /* CharacterCodes.lineFeed */ ) {
                            pos++;
                            value += '\n';
                        }
                        lineNumber++;
                        tokenLineStartOffset = pos;
                        return token = 14 /* SyntaxKind.LineBreakTrivia */ ;
                    }
                    switch(code){
                        // tokens: []{}:,
                        case 123 /* CharacterCodes.openBrace */ :
                            pos++;
                            return token = 1 /* SyntaxKind.OpenBraceToken */ ;
                        case 125 /* CharacterCodes.closeBrace */ :
                            pos++;
                            return token = 2 /* SyntaxKind.CloseBraceToken */ ;
                        case 91 /* CharacterCodes.openBracket */ :
                            pos++;
                            return token = 3 /* SyntaxKind.OpenBracketToken */ ;
                        case 93 /* CharacterCodes.closeBracket */ :
                            pos++;
                            return token = 4 /* SyntaxKind.CloseBracketToken */ ;
                        case 58 /* CharacterCodes.colon */ :
                            pos++;
                            return token = 6 /* SyntaxKind.ColonToken */ ;
                        case 44 /* CharacterCodes.comma */ :
                            pos++;
                            return token = 5 /* SyntaxKind.CommaToken */ ;
                        // strings
                        case 34 /* CharacterCodes.doubleQuote */ :
                            pos++;
                            value = scanString();
                            return token = 10 /* SyntaxKind.StringLiteral */ ;
                        // comments
                        case 47 /* CharacterCodes.slash */ :
                            const start = pos - 1;
                            // Single-line comment
                            if (text.charCodeAt(pos + 1) === 47 /* CharacterCodes.slash */ ) {
                                pos += 2;
                                while(pos < len){
                                    if (isLineBreak(text.charCodeAt(pos))) {
                                        break;
                                    }
                                    pos++;
                                }
                                value = text.substring(start, pos);
                                return token = 12 /* SyntaxKind.LineCommentTrivia */ ;
                            }
                            // Multi-line comment
                            if (text.charCodeAt(pos + 1) === 42 /* CharacterCodes.asterisk */ ) {
                                pos += 2;
                                const safeLength = len - 1; // For lookahead.
                                let commentClosed = false;
                                while(pos < safeLength){
                                    const ch = text.charCodeAt(pos);
                                    if (ch === 42 /* CharacterCodes.asterisk */  && text.charCodeAt(pos + 1) === 47 /* CharacterCodes.slash */ ) {
                                        pos += 2;
                                        commentClosed = true;
                                        break;
                                    }
                                    pos++;
                                    if (isLineBreak(ch)) {
                                        if (ch === 13 /* CharacterCodes.carriageReturn */  && text.charCodeAt(pos) === 10 /* CharacterCodes.lineFeed */ ) {
                                            pos++;
                                        }
                                        lineNumber++;
                                        tokenLineStartOffset = pos;
                                    }
                                }
                                if (!commentClosed) {
                                    pos++;
                                    scanError = 1 /* ScanError.UnexpectedEndOfComment */ ;
                                }
                                value = text.substring(start, pos);
                                return token = 13 /* SyntaxKind.BlockCommentTrivia */ ;
                            }
                            // just a single slash
                            value += String.fromCharCode(code);
                            pos++;
                            return token = 16 /* SyntaxKind.Unknown */ ;
                        // numbers
                        case 45 /* CharacterCodes.minus */ :
                            value += String.fromCharCode(code);
                            pos++;
                            if (pos === len || !isDigit(text.charCodeAt(pos))) {
                                return token = 16 /* SyntaxKind.Unknown */ ;
                            }
                        // found a minus, followed by a number so
                        // we fall through to proceed with scanning
                        // numbers
                        case 48 /* CharacterCodes._0 */ :
                        case 49 /* CharacterCodes._1 */ :
                        case 50 /* CharacterCodes._2 */ :
                        case 51 /* CharacterCodes._3 */ :
                        case 52 /* CharacterCodes._4 */ :
                        case 53 /* CharacterCodes._5 */ :
                        case 54 /* CharacterCodes._6 */ :
                        case 55 /* CharacterCodes._7 */ :
                        case 56 /* CharacterCodes._8 */ :
                        case 57 /* CharacterCodes._9 */ :
                            value += scanNumber();
                            return token = 11 /* SyntaxKind.NumericLiteral */ ;
                        // literals and unknown symbols
                        default:
                            // is a literal? Read the full word.
                            while(pos < len && isUnknownContentCharacter(code)){
                                pos++;
                                code = text.charCodeAt(pos);
                            }
                            if (tokenOffset !== pos) {
                                value = text.substring(tokenOffset, pos);
                                // keywords: true, false, null
                                switch(value){
                                    case 'true':
                                        return token = 8 /* SyntaxKind.TrueKeyword */ ;
                                    case 'false':
                                        return token = 9 /* SyntaxKind.FalseKeyword */ ;
                                    case 'null':
                                        return token = 7 /* SyntaxKind.NullKeyword */ ;
                                }
                                return token = 16 /* SyntaxKind.Unknown */ ;
                            }
                            // some
                            value += String.fromCharCode(code);
                            pos++;
                            return token = 16 /* SyntaxKind.Unknown */ ;
                    }
                }
                function isUnknownContentCharacter(code) {
                    if (isWhiteSpace(code) || isLineBreak(code)) {
                        return false;
                    }
                    switch(code){
                        case 125 /* CharacterCodes.closeBrace */ :
                        case 93 /* CharacterCodes.closeBracket */ :
                        case 123 /* CharacterCodes.openBrace */ :
                        case 91 /* CharacterCodes.openBracket */ :
                        case 34 /* CharacterCodes.doubleQuote */ :
                        case 58 /* CharacterCodes.colon */ :
                        case 44 /* CharacterCodes.comma */ :
                        case 47 /* CharacterCodes.slash */ :
                            return false;
                    }
                    return true;
                }
                function scanNextNonTrivia() {
                    let result;
                    do {
                        result = scanNext();
                    }while (result >= 12 /* SyntaxKind.LineCommentTrivia */  && result <= 15 /* SyntaxKind.Trivia */ )
                    return result;
                }
                return {
                    setPosition: setPosition,
                    getPosition: ()=>pos,
                    scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
                    getToken: ()=>token,
                    getTokenValue: ()=>value,
                    getTokenOffset: ()=>tokenOffset,
                    getTokenLength: ()=>pos - tokenOffset,
                    getTokenStartLine: ()=>lineStartOffset,
                    getTokenStartCharacter: ()=>tokenOffset - prevTokenLineStartOffset,
                    getTokenError: ()=>scanError
                };
            }
            function isWhiteSpace(ch) {
                return ch === 32 /* CharacterCodes.space */  || ch === 9 /* CharacterCodes.tab */ ;
            }
            function isLineBreak(ch) {
                return ch === 10 /* CharacterCodes.lineFeed */  || ch === 13 /* CharacterCodes.carriageReturn */ ;
            }
            function isDigit(ch) {
                return ch >= 48 /* CharacterCodes._0 */  && ch <= 57 /* CharacterCodes._9 */ ;
            }
            var CharacterCodes;
            (function(CharacterCodes) {
                CharacterCodes[CharacterCodes["lineFeed"] = 10] = "lineFeed";
                CharacterCodes[CharacterCodes["carriageReturn"] = 13] = "carriageReturn";
                CharacterCodes[CharacterCodes["space"] = 32] = "space";
                CharacterCodes[CharacterCodes["_0"] = 48] = "_0";
                CharacterCodes[CharacterCodes["_1"] = 49] = "_1";
                CharacterCodes[CharacterCodes["_2"] = 50] = "_2";
                CharacterCodes[CharacterCodes["_3"] = 51] = "_3";
                CharacterCodes[CharacterCodes["_4"] = 52] = "_4";
                CharacterCodes[CharacterCodes["_5"] = 53] = "_5";
                CharacterCodes[CharacterCodes["_6"] = 54] = "_6";
                CharacterCodes[CharacterCodes["_7"] = 55] = "_7";
                CharacterCodes[CharacterCodes["_8"] = 56] = "_8";
                CharacterCodes[CharacterCodes["_9"] = 57] = "_9";
                CharacterCodes[CharacterCodes["a"] = 97] = "a";
                CharacterCodes[CharacterCodes["b"] = 98] = "b";
                CharacterCodes[CharacterCodes["c"] = 99] = "c";
                CharacterCodes[CharacterCodes["d"] = 100] = "d";
                CharacterCodes[CharacterCodes["e"] = 101] = "e";
                CharacterCodes[CharacterCodes["f"] = 102] = "f";
                CharacterCodes[CharacterCodes["g"] = 103] = "g";
                CharacterCodes[CharacterCodes["h"] = 104] = "h";
                CharacterCodes[CharacterCodes["i"] = 105] = "i";
                CharacterCodes[CharacterCodes["j"] = 106] = "j";
                CharacterCodes[CharacterCodes["k"] = 107] = "k";
                CharacterCodes[CharacterCodes["l"] = 108] = "l";
                CharacterCodes[CharacterCodes["m"] = 109] = "m";
                CharacterCodes[CharacterCodes["n"] = 110] = "n";
                CharacterCodes[CharacterCodes["o"] = 111] = "o";
                CharacterCodes[CharacterCodes["p"] = 112] = "p";
                CharacterCodes[CharacterCodes["q"] = 113] = "q";
                CharacterCodes[CharacterCodes["r"] = 114] = "r";
                CharacterCodes[CharacterCodes["s"] = 115] = "s";
                CharacterCodes[CharacterCodes["t"] = 116] = "t";
                CharacterCodes[CharacterCodes["u"] = 117] = "u";
                CharacterCodes[CharacterCodes["v"] = 118] = "v";
                CharacterCodes[CharacterCodes["w"] = 119] = "w";
                CharacterCodes[CharacterCodes["x"] = 120] = "x";
                CharacterCodes[CharacterCodes["y"] = 121] = "y";
                CharacterCodes[CharacterCodes["z"] = 122] = "z";
                CharacterCodes[CharacterCodes["A"] = 65] = "A";
                CharacterCodes[CharacterCodes["B"] = 66] = "B";
                CharacterCodes[CharacterCodes["C"] = 67] = "C";
                CharacterCodes[CharacterCodes["D"] = 68] = "D";
                CharacterCodes[CharacterCodes["E"] = 69] = "E";
                CharacterCodes[CharacterCodes["F"] = 70] = "F";
                CharacterCodes[CharacterCodes["G"] = 71] = "G";
                CharacterCodes[CharacterCodes["H"] = 72] = "H";
                CharacterCodes[CharacterCodes["I"] = 73] = "I";
                CharacterCodes[CharacterCodes["J"] = 74] = "J";
                CharacterCodes[CharacterCodes["K"] = 75] = "K";
                CharacterCodes[CharacterCodes["L"] = 76] = "L";
                CharacterCodes[CharacterCodes["M"] = 77] = "M";
                CharacterCodes[CharacterCodes["N"] = 78] = "N";
                CharacterCodes[CharacterCodes["O"] = 79] = "O";
                CharacterCodes[CharacterCodes["P"] = 80] = "P";
                CharacterCodes[CharacterCodes["Q"] = 81] = "Q";
                CharacterCodes[CharacterCodes["R"] = 82] = "R";
                CharacterCodes[CharacterCodes["S"] = 83] = "S";
                CharacterCodes[CharacterCodes["T"] = 84] = "T";
                CharacterCodes[CharacterCodes["U"] = 85] = "U";
                CharacterCodes[CharacterCodes["V"] = 86] = "V";
                CharacterCodes[CharacterCodes["W"] = 87] = "W";
                CharacterCodes[CharacterCodes["X"] = 88] = "X";
                CharacterCodes[CharacterCodes["Y"] = 89] = "Y";
                CharacterCodes[CharacterCodes["Z"] = 90] = "Z";
                CharacterCodes[CharacterCodes["asterisk"] = 42] = "asterisk";
                CharacterCodes[CharacterCodes["backslash"] = 92] = "backslash";
                CharacterCodes[CharacterCodes["closeBrace"] = 125] = "closeBrace";
                CharacterCodes[CharacterCodes["closeBracket"] = 93] = "closeBracket";
                CharacterCodes[CharacterCodes["colon"] = 58] = "colon";
                CharacterCodes[CharacterCodes["comma"] = 44] = "comma";
                CharacterCodes[CharacterCodes["dot"] = 46] = "dot";
                CharacterCodes[CharacterCodes["doubleQuote"] = 34] = "doubleQuote";
                CharacterCodes[CharacterCodes["minus"] = 45] = "minus";
                CharacterCodes[CharacterCodes["openBrace"] = 123] = "openBrace";
                CharacterCodes[CharacterCodes["openBracket"] = 91] = "openBracket";
                CharacterCodes[CharacterCodes["plus"] = 43] = "plus";
                CharacterCodes[CharacterCodes["slash"] = 47] = "slash";
                CharacterCodes[CharacterCodes["formFeed"] = 12] = "formFeed";
                CharacterCodes[CharacterCodes["tab"] = 9] = "tab";
            })(CharacterCodes || (CharacterCodes = {}));
            ; // CONCATENATED MODULE: ../../node_modules/jsonc-parser/lib/esm/impl/format.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ function format_format(documentText, range, options) {
                let initialIndentLevel;
                let formatText;
                let formatTextStart;
                let rangeStart;
                let rangeEnd;
                if (range) {
                    rangeStart = range.offset;
                    rangeEnd = rangeStart + range.length;
                    formatTextStart = rangeStart;
                    while(formatTextStart > 0 && !format_isEOL(documentText, formatTextStart - 1)){
                        formatTextStart--;
                    }
                    let endOffset = rangeEnd;
                    while(endOffset < documentText.length && !format_isEOL(documentText, endOffset)){
                        endOffset++;
                    }
                    formatText = documentText.substring(formatTextStart, endOffset);
                    initialIndentLevel = computeIndentLevel(formatText, options);
                } else {
                    formatText = documentText;
                    initialIndentLevel = 0;
                    formatTextStart = 0;
                    rangeStart = 0;
                    rangeEnd = documentText.length;
                }
                const eol = getEOL(options, documentText);
                let numberLineBreaks = 0;
                let indentLevel = 0;
                let indentValue;
                if (options.insertSpaces) {
                    indentValue = repeat(' ', options.tabSize || 4);
                } else {
                    indentValue = '\t';
                }
                let scanner = createScanner(formatText, false);
                let hasError = false;
                function newLinesAndIndent() {
                    if (numberLineBreaks > 1) {
                        return repeat(eol, numberLineBreaks) + repeat(indentValue, initialIndentLevel + indentLevel);
                    } else {
                        return eol + repeat(indentValue, initialIndentLevel + indentLevel);
                    }
                }
                function scanNext() {
                    let token = scanner.scan();
                    numberLineBreaks = 0;
                    while(token === 15 /* SyntaxKind.Trivia */  || token === 14 /* SyntaxKind.LineBreakTrivia */ ){
                        if (token === 14 /* SyntaxKind.LineBreakTrivia */  && options.keepLines) {
                            numberLineBreaks += 1;
                        } else if (token === 14 /* SyntaxKind.LineBreakTrivia */ ) {
                            numberLineBreaks = 1;
                        }
                        token = scanner.scan();
                    }
                    hasError = token === 16 /* SyntaxKind.Unknown */  || scanner.getTokenError() !== 0 /* ScanError.None */ ;
                    return token;
                }
                const editOperations = [];
                function addEdit(text, startOffset, endOffset) {
                    if (!hasError && (!range || startOffset < rangeEnd && endOffset > rangeStart) && documentText.substring(startOffset, endOffset) !== text) {
                        editOperations.push({
                            offset: startOffset,
                            length: endOffset - startOffset,
                            content: text
                        });
                    }
                }
                let firstToken = scanNext();
                if (options.keepLines && numberLineBreaks > 0) {
                    addEdit(repeat(eol, numberLineBreaks), 0, 0);
                }
                if (firstToken !== 17 /* SyntaxKind.EOF */ ) {
                    let firstTokenStart = scanner.getTokenOffset() + formatTextStart;
                    let initialIndent = repeat(indentValue, initialIndentLevel);
                    addEdit(initialIndent, formatTextStart, firstTokenStart);
                }
                while(firstToken !== 17 /* SyntaxKind.EOF */ ){
                    let firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;
                    let secondToken = scanNext();
                    let replaceContent = '';
                    let needsLineBreak = false;
                    while(numberLineBreaks === 0 && (secondToken === 12 /* SyntaxKind.LineCommentTrivia */  || secondToken === 13 /* SyntaxKind.BlockCommentTrivia */ )){
                        let commentTokenStart = scanner.getTokenOffset() + formatTextStart;
                        addEdit(' ', firstTokenEnd, commentTokenStart);
                        firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;
                        needsLineBreak = secondToken === 12 /* SyntaxKind.LineCommentTrivia */ ;
                        replaceContent = needsLineBreak ? newLinesAndIndent() : '';
                        secondToken = scanNext();
                    }
                    if (secondToken === 2 /* SyntaxKind.CloseBraceToken */ ) {
                        if (firstToken !== 1 /* SyntaxKind.OpenBraceToken */ ) {
                            indentLevel--;
                        }
                        ;
                        if (options.keepLines && numberLineBreaks > 0 || !options.keepLines && firstToken !== 1 /* SyntaxKind.OpenBraceToken */ ) {
                            replaceContent = newLinesAndIndent();
                        } else if (options.keepLines) {
                            replaceContent = ' ';
                        }
                    } else if (secondToken === 4 /* SyntaxKind.CloseBracketToken */ ) {
                        if (firstToken !== 3 /* SyntaxKind.OpenBracketToken */ ) {
                            indentLevel--;
                        }
                        ;
                        if (options.keepLines && numberLineBreaks > 0 || !options.keepLines && firstToken !== 3 /* SyntaxKind.OpenBracketToken */ ) {
                            replaceContent = newLinesAndIndent();
                        } else if (options.keepLines) {
                            replaceContent = ' ';
                        }
                    } else {
                        switch(firstToken){
                            case 3 /* SyntaxKind.OpenBracketToken */ :
                            case 1 /* SyntaxKind.OpenBraceToken */ :
                                indentLevel++;
                                if (options.keepLines && numberLineBreaks > 0 || !options.keepLines) {
                                    replaceContent = newLinesAndIndent();
                                } else {
                                    replaceContent = ' ';
                                }
                                break;
                            case 5 /* SyntaxKind.CommaToken */ :
                                if (options.keepLines && numberLineBreaks > 0 || !options.keepLines) {
                                    replaceContent = newLinesAndIndent();
                                } else {
                                    replaceContent = ' ';
                                }
                                break;
                            case 12 /* SyntaxKind.LineCommentTrivia */ :
                                replaceContent = newLinesAndIndent();
                                break;
                            case 13 /* SyntaxKind.BlockCommentTrivia */ :
                                if (numberLineBreaks > 0) {
                                    replaceContent = newLinesAndIndent();
                                } else if (!needsLineBreak) {
                                    replaceContent = ' ';
                                }
                                break;
                            case 6 /* SyntaxKind.ColonToken */ :
                                if (options.keepLines && numberLineBreaks > 0) {
                                    replaceContent = newLinesAndIndent();
                                } else if (!needsLineBreak) {
                                    replaceContent = ' ';
                                }
                                break;
                            case 10 /* SyntaxKind.StringLiteral */ :
                                if (options.keepLines && numberLineBreaks > 0) {
                                    replaceContent = newLinesAndIndent();
                                } else if (secondToken === 6 /* SyntaxKind.ColonToken */  && !needsLineBreak) {
                                    replaceContent = '';
                                }
                                break;
                            case 7 /* SyntaxKind.NullKeyword */ :
                            case 8 /* SyntaxKind.TrueKeyword */ :
                            case 9 /* SyntaxKind.FalseKeyword */ :
                            case 11 /* SyntaxKind.NumericLiteral */ :
                            case 2 /* SyntaxKind.CloseBraceToken */ :
                            case 4 /* SyntaxKind.CloseBracketToken */ :
                                if (options.keepLines && numberLineBreaks > 0) {
                                    replaceContent = newLinesAndIndent();
                                } else {
                                    if ((secondToken === 12 /* SyntaxKind.LineCommentTrivia */  || secondToken === 13 /* SyntaxKind.BlockCommentTrivia */ ) && !needsLineBreak) {
                                        replaceContent = ' ';
                                    } else if (secondToken !== 5 /* SyntaxKind.CommaToken */  && secondToken !== 17 /* SyntaxKind.EOF */ ) {
                                        hasError = true;
                                    }
                                }
                                break;
                            case 16 /* SyntaxKind.Unknown */ :
                                hasError = true;
                                break;
                        }
                        if (numberLineBreaks > 0 && (secondToken === 12 /* SyntaxKind.LineCommentTrivia */  || secondToken === 13 /* SyntaxKind.BlockCommentTrivia */ )) {
                            replaceContent = newLinesAndIndent();
                        }
                    }
                    if (secondToken === 17 /* SyntaxKind.EOF */ ) {
                        if (options.keepLines && numberLineBreaks > 0) {
                            replaceContent = newLinesAndIndent();
                        } else {
                            replaceContent = options.insertFinalNewline ? eol : '';
                        }
                    }
                    const secondTokenStart = scanner.getTokenOffset() + formatTextStart;
                    addEdit(replaceContent, firstTokenEnd, secondTokenStart);
                    firstToken = secondToken;
                }
                return editOperations;
            }
            function repeat(s, count) {
                let result = '';
                for(let i = 0; i < count; i++){
                    result += s;
                }
                return result;
            }
            function computeIndentLevel(content, options) {
                let i = 0;
                let nChars = 0;
                const tabSize = options.tabSize || 4;
                while(i < content.length){
                    let ch = content.charAt(i);
                    if (ch === ' ') {
                        nChars++;
                    } else if (ch === '\t') {
                        nChars += tabSize;
                    } else {
                        break;
                    }
                    i++;
                }
                return Math.floor(nChars / tabSize);
            }
            function getEOL(options, text) {
                for(let i = 0; i < text.length; i++){
                    const ch = text.charAt(i);
                    if (ch === '\r') {
                        if (i + 1 < text.length && text.charAt(i + 1) === '\n') {
                            return '\r\n';
                        }
                        return '\r';
                    } else if (ch === '\n') {
                        return '\n';
                    }
                }
                return options && options.eol || '\n';
            }
            function format_isEOL(text, offset) {
                return '\r\n'.indexOf(text.charAt(offset)) !== -1;
            }
            ; // CONCATENATED MODULE: ../../node_modules/jsonc-parser/lib/esm/impl/parser.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ var ParseOptions;
            (function(ParseOptions) {
                ParseOptions.DEFAULT = {
                    allowTrailingComma: false
                };
            })(ParseOptions || (ParseOptions = {}));
            /**
 * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.
 */ function getLocation(text, position) {
                const segments = []; // strings or numbers
                const earlyReturnException = new Object();
                let previousNode = undefined;
                const previousNodeInst = {
                    value: {},
                    offset: 0,
                    length: 0,
                    type: 'object',
                    parent: undefined
                };
                let isAtPropertyKey = false;
                function setPreviousNode(value, offset, length, type) {
                    previousNodeInst.value = value;
                    previousNodeInst.offset = offset;
                    previousNodeInst.length = length;
                    previousNodeInst.type = type;
                    previousNodeInst.colonOffset = undefined;
                    previousNode = previousNodeInst;
                }
                try {
                    visit(text, {
                        onObjectBegin: (offset, length)=>{
                            if (position <= offset) {
                                throw earlyReturnException;
                            }
                            previousNode = undefined;
                            isAtPropertyKey = position > offset;
                            segments.push(''); // push a placeholder (will be replaced)
                        },
                        onObjectProperty: (name, offset, length)=>{
                            if (position < offset) {
                                throw earlyReturnException;
                            }
                            setPreviousNode(name, offset, length, 'property');
                            segments[segments.length - 1] = name;
                            if (position <= offset + length) {
                                throw earlyReturnException;
                            }
                        },
                        onObjectEnd: (offset, length)=>{
                            if (position <= offset) {
                                throw earlyReturnException;
                            }
                            previousNode = undefined;
                            segments.pop();
                        },
                        onArrayBegin: (offset, length)=>{
                            if (position <= offset) {
                                throw earlyReturnException;
                            }
                            previousNode = undefined;
                            segments.push(0);
                        },
                        onArrayEnd: (offset, length)=>{
                            if (position <= offset) {
                                throw earlyReturnException;
                            }
                            previousNode = undefined;
                            segments.pop();
                        },
                        onLiteralValue: (value, offset, length)=>{
                            if (position < offset) {
                                throw earlyReturnException;
                            }
                            setPreviousNode(value, offset, length, getNodeType(value));
                            if (position <= offset + length) {
                                throw earlyReturnException;
                            }
                        },
                        onSeparator: (sep, offset, length)=>{
                            if (position <= offset) {
                                throw earlyReturnException;
                            }
                            if (sep === ':' && previousNode && previousNode.type === 'property') {
                                previousNode.colonOffset = offset;
                                isAtPropertyKey = false;
                                previousNode = undefined;
                            } else if (sep === ',') {
                                const last = segments[segments.length - 1];
                                if (typeof last === 'number') {
                                    segments[segments.length - 1] = last + 1;
                                } else {
                                    isAtPropertyKey = true;
                                    segments[segments.length - 1] = '';
                                }
                                previousNode = undefined;
                            }
                        }
                    });
                } catch (e) {
                    if (e !== earlyReturnException) {
                        throw e;
                    }
                }
                return {
                    path: segments,
                    previousNode,
                    isAtPropertyKey,
                    matches: (pattern)=>{
                        let k = 0;
                        for(let i = 0; k < pattern.length && i < segments.length; i++){
                            if (pattern[k] === segments[i] || pattern[k] === '*') {
                                k++;
                            } else if (pattern[k] !== '**') {
                                return false;
                            }
                        }
                        return k === pattern.length;
                    }
                };
            }
            /**
 * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 * Therefore always check the errors list to find out if the input was valid.
 */ function parse(text, errors = [], options = ParseOptions.DEFAULT) {
                let currentProperty = null;
                let currentParent = [];
                const previousParents = [];
                function onValue(value) {
                    if (Array.isArray(currentParent)) {
                        currentParent.push(value);
                    } else if (currentProperty !== null) {
                        currentParent[currentProperty] = value;
                    }
                }
                const visitor = {
                    onObjectBegin: ()=>{
                        const object = {};
                        onValue(object);
                        previousParents.push(currentParent);
                        currentParent = object;
                        currentProperty = null;
                    },
                    onObjectProperty: (name)=>{
                        currentProperty = name;
                    },
                    onObjectEnd: ()=>{
                        currentParent = previousParents.pop();
                    },
                    onArrayBegin: ()=>{
                        const array = [];
                        onValue(array);
                        previousParents.push(currentParent);
                        currentParent = array;
                        currentProperty = null;
                    },
                    onArrayEnd: ()=>{
                        currentParent = previousParents.pop();
                    },
                    onLiteralValue: onValue,
                    onError: (error, offset, length)=>{
                        errors.push({
                            error,
                            offset,
                            length
                        });
                    }
                };
                visit(text, visitor, options);
                return currentParent[0];
            }
            /**
 * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 */ function parser_parseTree(text, errors = [], options = ParseOptions.DEFAULT) {
                let currentParent = {
                    type: 'array',
                    offset: -1,
                    length: -1,
                    children: [],
                    parent: undefined
                }; // artificial root
                function ensurePropertyComplete(endOffset) {
                    if (currentParent.type === 'property') {
                        currentParent.length = endOffset - currentParent.offset;
                        currentParent = currentParent.parent;
                    }
                }
                function onValue(valueNode) {
                    currentParent.children.push(valueNode);
                    return valueNode;
                }
                const visitor = {
                    onObjectBegin: (offset)=>{
                        currentParent = onValue({
                            type: 'object',
                            offset,
                            length: -1,
                            parent: currentParent,
                            children: []
                        });
                    },
                    onObjectProperty: (name, offset, length)=>{
                        currentParent = onValue({
                            type: 'property',
                            offset,
                            length: -1,
                            parent: currentParent,
                            children: []
                        });
                        currentParent.children.push({
                            type: 'string',
                            value: name,
                            offset,
                            length,
                            parent: currentParent
                        });
                    },
                    onObjectEnd: (offset, length)=>{
                        ensurePropertyComplete(offset + length); // in case of a missing value for a property: make sure property is complete
                        currentParent.length = offset + length - currentParent.offset;
                        currentParent = currentParent.parent;
                        ensurePropertyComplete(offset + length);
                    },
                    onArrayBegin: (offset, length)=>{
                        currentParent = onValue({
                            type: 'array',
                            offset,
                            length: -1,
                            parent: currentParent,
                            children: []
                        });
                    },
                    onArrayEnd: (offset, length)=>{
                        currentParent.length = offset + length - currentParent.offset;
                        currentParent = currentParent.parent;
                        ensurePropertyComplete(offset + length);
                    },
                    onLiteralValue: (value, offset, length)=>{
                        onValue({
                            type: getNodeType(value),
                            offset,
                            length,
                            parent: currentParent,
                            value
                        });
                        ensurePropertyComplete(offset + length);
                    },
                    onSeparator: (sep, offset, length)=>{
                        if (currentParent.type === 'property') {
                            if (sep === ':') {
                                currentParent.colonOffset = offset;
                            } else if (sep === ',') {
                                ensurePropertyComplete(offset);
                            }
                        }
                    },
                    onError: (error, offset, length)=>{
                        errors.push({
                            error,
                            offset,
                            length
                        });
                    }
                };
                visit(text, visitor, options);
                const result = currentParent.children[0];
                if (result) {
                    delete result.parent;
                }
                return result;
            }
            /**
 * Finds the node at the given path in a JSON DOM.
 */ function parser_findNodeAtLocation(root, path) {
                if (!root) {
                    return undefined;
                }
                let node = root;
                for (let segment of path){
                    if (typeof segment === 'string') {
                        if (node.type !== 'object' || !Array.isArray(node.children)) {
                            return undefined;
                        }
                        let found = false;
                        for (const propertyNode of node.children){
                            if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment && propertyNode.children.length === 2) {
                                node = propertyNode.children[1];
                                found = true;
                                break;
                            }
                        }
                        if (!found) {
                            return undefined;
                        }
                    } else {
                        const index = segment;
                        if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {
                            return undefined;
                        }
                        node = node.children[index];
                    }
                }
                return node;
            }
            /**
 * Gets the JSON path of the given JSON DOM node
 */ function getNodePath(node) {
                if (!node.parent || !node.parent.children) {
                    return [];
                }
                const path = getNodePath(node.parent);
                if (node.parent.type === 'property') {
                    const key = node.parent.children[0].value;
                    path.push(key);
                } else if (node.parent.type === 'array') {
                    const index = node.parent.children.indexOf(node);
                    if (index !== -1) {
                        path.push(index);
                    }
                }
                return path;
            }
            /**
 * Evaluates the JavaScript object of the given JSON DOM node
 */ function getNodeValue(node) {
                switch(node.type){
                    case 'array':
                        return node.children.map(getNodeValue);
                    case 'object':
                        const obj = Object.create(null);
                        for (let prop of node.children){
                            const valueNode = prop.children[1];
                            if (valueNode) {
                                obj[prop.children[0].value] = getNodeValue(valueNode);
                            }
                        }
                        return obj;
                    case 'null':
                    case 'string':
                    case 'number':
                    case 'boolean':
                        return node.value;
                    default:
                        return undefined;
                }
            }
            function contains(node, offset, includeRightBound = false) {
                return offset >= node.offset && offset < node.offset + node.length || includeRightBound && offset === node.offset + node.length;
            }
            /**
 * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.
 */ function findNodeAtOffset(node, offset, includeRightBound = false) {
                if (contains(node, offset, includeRightBound)) {
                    const children = node.children;
                    if (Array.isArray(children)) {
                        for(let i = 0; i < children.length && children[i].offset <= offset; i++){
                            const item = findNodeAtOffset(children[i], offset, includeRightBound);
                            if (item) {
                                return item;
                            }
                        }
                    }
                    return node;
                }
                return undefined;
            }
            /**
 * Parses the given text and invokes the visitor functions for each object, array and literal reached.
 */ function visit(text, visitor, options = ParseOptions.DEFAULT) {
                const _scanner = createScanner(text, false);
                // Important: Only pass copies of this to visitor functions to prevent accidental modification, and
                // to not affect visitor functions which stored a reference to a previous JSONPath
                const _jsonPath = [];
                function toNoArgVisit(visitFunction) {
                    return visitFunction ? ()=>visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : ()=>true;
                }
                function toNoArgVisitWithPath(visitFunction) {
                    return visitFunction ? ()=>visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), ()=>_jsonPath.slice()) : ()=>true;
                }
                function toOneArgVisit(visitFunction) {
                    return visitFunction ? (arg)=>visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : ()=>true;
                }
                function toOneArgVisitWithPath(visitFunction) {
                    return visitFunction ? (arg)=>visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), ()=>_jsonPath.slice()) : ()=>true;
                }
                const onObjectBegin = toNoArgVisitWithPath(visitor.onObjectBegin), onObjectProperty = toOneArgVisitWithPath(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisitWithPath(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisitWithPath(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);
                const disallowComments = options && options.disallowComments;
                const allowTrailingComma = options && options.allowTrailingComma;
                function scanNext() {
                    while(true){
                        const token = _scanner.scan();
                        switch(_scanner.getTokenError()){
                            case 4 /* ScanError.InvalidUnicode */ :
                                handleError(14 /* ParseErrorCode.InvalidUnicode */ );
                                break;
                            case 5 /* ScanError.InvalidEscapeCharacter */ :
                                handleError(15 /* ParseErrorCode.InvalidEscapeCharacter */ );
                                break;
                            case 3 /* ScanError.UnexpectedEndOfNumber */ :
                                handleError(13 /* ParseErrorCode.UnexpectedEndOfNumber */ );
                                break;
                            case 1 /* ScanError.UnexpectedEndOfComment */ :
                                if (!disallowComments) {
                                    handleError(11 /* ParseErrorCode.UnexpectedEndOfComment */ );
                                }
                                break;
                            case 2 /* ScanError.UnexpectedEndOfString */ :
                                handleError(12 /* ParseErrorCode.UnexpectedEndOfString */ );
                                break;
                            case 6 /* ScanError.InvalidCharacter */ :
                                handleError(16 /* ParseErrorCode.InvalidCharacter */ );
                                break;
                        }
                        switch(token){
                            case 12 /* SyntaxKind.LineCommentTrivia */ :
                            case 13 /* SyntaxKind.BlockCommentTrivia */ :
                                if (disallowComments) {
                                    handleError(10 /* ParseErrorCode.InvalidCommentToken */ );
                                } else {
                                    onComment();
                                }
                                break;
                            case 16 /* SyntaxKind.Unknown */ :
                                handleError(1 /* ParseErrorCode.InvalidSymbol */ );
                                break;
                            case 15 /* SyntaxKind.Trivia */ :
                            case 14 /* SyntaxKind.LineBreakTrivia */ :
                                break;
                            default:
                                return token;
                        }
                    }
                }
                function handleError(error, skipUntilAfter = [], skipUntil = []) {
                    onError(error);
                    if (skipUntilAfter.length + skipUntil.length > 0) {
                        let token = _scanner.getToken();
                        while(token !== 17 /* SyntaxKind.EOF */ ){
                            if (skipUntilAfter.indexOf(token) !== -1) {
                                scanNext();
                                break;
                            } else if (skipUntil.indexOf(token) !== -1) {
                                break;
                            }
                            token = scanNext();
                        }
                    }
                }
                function parseString(isValue) {
                    const value = _scanner.getTokenValue();
                    if (isValue) {
                        onLiteralValue(value);
                    } else {
                        onObjectProperty(value);
                        // add property name afterwards
                        _jsonPath.push(value);
                    }
                    scanNext();
                    return true;
                }
                function parseLiteral() {
                    switch(_scanner.getToken()){
                        case 11 /* SyntaxKind.NumericLiteral */ :
                            const tokenValue = _scanner.getTokenValue();
                            let value = Number(tokenValue);
                            if (isNaN(value)) {
                                handleError(2 /* ParseErrorCode.InvalidNumberFormat */ );
                                value = 0;
                            }
                            onLiteralValue(value);
                            break;
                        case 7 /* SyntaxKind.NullKeyword */ :
                            onLiteralValue(null);
                            break;
                        case 8 /* SyntaxKind.TrueKeyword */ :
                            onLiteralValue(true);
                            break;
                        case 9 /* SyntaxKind.FalseKeyword */ :
                            onLiteralValue(false);
                            break;
                        default:
                            return false;
                    }
                    scanNext();
                    return true;
                }
                function parseProperty() {
                    if (_scanner.getToken() !== 10 /* SyntaxKind.StringLiteral */ ) {
                        handleError(3 /* ParseErrorCode.PropertyNameExpected */ , [], [
                            2 /* SyntaxKind.CloseBraceToken */ ,
                            5 /* SyntaxKind.CommaToken */ 
                        ]);
                        return false;
                    }
                    parseString(false);
                    if (_scanner.getToken() === 6 /* SyntaxKind.ColonToken */ ) {
                        onSeparator(':');
                        scanNext(); // consume colon
                        if (!parseValue()) {
                            handleError(4 /* ParseErrorCode.ValueExpected */ , [], [
                                2 /* SyntaxKind.CloseBraceToken */ ,
                                5 /* SyntaxKind.CommaToken */ 
                            ]);
                        }
                    } else {
                        handleError(5 /* ParseErrorCode.ColonExpected */ , [], [
                            2 /* SyntaxKind.CloseBraceToken */ ,
                            5 /* SyntaxKind.CommaToken */ 
                        ]);
                    }
                    _jsonPath.pop(); // remove processed property name
                    return true;
                }
                function parseObject() {
                    onObjectBegin();
                    scanNext(); // consume open brace
                    let needsComma = false;
                    while(_scanner.getToken() !== 2 /* SyntaxKind.CloseBraceToken */  && _scanner.getToken() !== 17 /* SyntaxKind.EOF */ ){
                        if (_scanner.getToken() === 5 /* SyntaxKind.CommaToken */ ) {
                            if (!needsComma) {
                                handleError(4 /* ParseErrorCode.ValueExpected */ , [], []);
                            }
                            onSeparator(',');
                            scanNext(); // consume comma
                            if (_scanner.getToken() === 2 /* SyntaxKind.CloseBraceToken */  && allowTrailingComma) {
                                break;
                            }
                        } else if (needsComma) {
                            handleError(6 /* ParseErrorCode.CommaExpected */ , [], []);
                        }
                        if (!parseProperty()) {
                            handleError(4 /* ParseErrorCode.ValueExpected */ , [], [
                                2 /* SyntaxKind.CloseBraceToken */ ,
                                5 /* SyntaxKind.CommaToken */ 
                            ]);
                        }
                        needsComma = true;
                    }
                    onObjectEnd();
                    if (_scanner.getToken() !== 2 /* SyntaxKind.CloseBraceToken */ ) {
                        handleError(7 /* ParseErrorCode.CloseBraceExpected */ , [
                            2 /* SyntaxKind.CloseBraceToken */ 
                        ], []);
                    } else {
                        scanNext(); // consume close brace
                    }
                    return true;
                }
                function parseArray() {
                    onArrayBegin();
                    scanNext(); // consume open bracket
                    let isFirstElement = true;
                    let needsComma = false;
                    while(_scanner.getToken() !== 4 /* SyntaxKind.CloseBracketToken */  && _scanner.getToken() !== 17 /* SyntaxKind.EOF */ ){
                        if (_scanner.getToken() === 5 /* SyntaxKind.CommaToken */ ) {
                            if (!needsComma) {
                                handleError(4 /* ParseErrorCode.ValueExpected */ , [], []);
                            }
                            onSeparator(',');
                            scanNext(); // consume comma
                            if (_scanner.getToken() === 4 /* SyntaxKind.CloseBracketToken */  && allowTrailingComma) {
                                break;
                            }
                        } else if (needsComma) {
                            handleError(6 /* ParseErrorCode.CommaExpected */ , [], []);
                        }
                        if (isFirstElement) {
                            _jsonPath.push(0);
                            isFirstElement = false;
                        } else {
                            _jsonPath[_jsonPath.length - 1]++;
                        }
                        if (!parseValue()) {
                            handleError(4 /* ParseErrorCode.ValueExpected */ , [], [
                                4 /* SyntaxKind.CloseBracketToken */ ,
                                5 /* SyntaxKind.CommaToken */ 
                            ]);
                        }
                        needsComma = true;
                    }
                    onArrayEnd();
                    if (!isFirstElement) {
                        _jsonPath.pop(); // remove array index
                    }
                    if (_scanner.getToken() !== 4 /* SyntaxKind.CloseBracketToken */ ) {
                        handleError(8 /* ParseErrorCode.CloseBracketExpected */ , [
                            4 /* SyntaxKind.CloseBracketToken */ 
                        ], []);
                    } else {
                        scanNext(); // consume close bracket
                    }
                    return true;
                }
                function parseValue() {
                    switch(_scanner.getToken()){
                        case 3 /* SyntaxKind.OpenBracketToken */ :
                            return parseArray();
                        case 1 /* SyntaxKind.OpenBraceToken */ :
                            return parseObject();
                        case 10 /* SyntaxKind.StringLiteral */ :
                            return parseString(true);
                        default:
                            return parseLiteral();
                    }
                }
                scanNext();
                if (_scanner.getToken() === 17 /* SyntaxKind.EOF */ ) {
                    if (options.allowEmptyContent) {
                        return true;
                    }
                    handleError(4 /* ParseErrorCode.ValueExpected */ , [], []);
                    return false;
                }
                if (!parseValue()) {
                    handleError(4 /* ParseErrorCode.ValueExpected */ , [], []);
                    return false;
                }
                if (_scanner.getToken() !== 17 /* SyntaxKind.EOF */ ) {
                    handleError(9 /* ParseErrorCode.EndOfFileExpected */ , [], []);
                }
                return true;
            }
            /**
 * Takes JSON with JavaScript-style comments and remove
 * them. Optionally replaces every none-newline character
 * of comments with a replaceCharacter
 */ function stripComments(text, replaceCh) {
                let _scanner = createScanner(text), parts = [], kind, offset = 0, pos;
                do {
                    pos = _scanner.getPosition();
                    kind = _scanner.scan();
                    switch(kind){
                        case 12 /* SyntaxKind.LineCommentTrivia */ :
                        case 13 /* SyntaxKind.BlockCommentTrivia */ :
                        case 17 /* SyntaxKind.EOF */ :
                            if (offset !== pos) {
                                parts.push(text.substring(offset, pos));
                            }
                            if (replaceCh !== undefined) {
                                parts.push(_scanner.getTokenValue().replace(/[^\r\n]/g, replaceCh));
                            }
                            offset = _scanner.getPosition();
                            break;
                    }
                }while (kind !== 17 /* SyntaxKind.EOF */ )
                return parts.join('');
            }
            function getNodeType(value) {
                switch(typeof value){
                    case 'boolean':
                        return 'boolean';
                    case 'number':
                        return 'number';
                    case 'string':
                        return 'string';
                    case 'object':
                        {
                            if (!value) {
                                return 'null';
                            } else if (Array.isArray(value)) {
                                return 'array';
                            }
                            return 'object';
                        }
                    default:
                        return 'null';
                }
            }
            ; // CONCATENATED MODULE: ../../node_modules/jsonc-parser/lib/esm/impl/edit.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ function removeProperty(text, path, options) {
                return setProperty(text, path, void 0, options);
            }
            function setProperty(text, originalPath, value, options) {
                const path = originalPath.slice();
                const errors = [];
                const root = parseTree(text, errors);
                let parent = void 0;
                let lastSegment = void 0;
                while(path.length > 0){
                    lastSegment = path.pop();
                    parent = findNodeAtLocation(root, path);
                    if (parent === void 0 && value !== void 0) {
                        if (typeof lastSegment === 'string') {
                            value = {
                                [lastSegment]: value
                            };
                        } else {
                            value = [
                                value
                            ];
                        }
                    } else {
                        break;
                    }
                }
                if (!parent) {
                    // empty document
                    if (value === void 0) {
                        throw new Error('Can not delete in empty document');
                    }
                    return withFormatting(text, {
                        offset: root ? root.offset : 0,
                        length: root ? root.length : 0,
                        content: JSON.stringify(value)
                    }, options);
                } else if (parent.type === 'object' && typeof lastSegment === 'string' && Array.isArray(parent.children)) {
                    const existing = findNodeAtLocation(parent, [
                        lastSegment
                    ]);
                    if (existing !== void 0) {
                        if (value === void 0) {
                            if (!existing.parent) {
                                throw new Error('Malformed AST');
                            }
                            const propertyIndex = parent.children.indexOf(existing.parent);
                            let removeBegin;
                            let removeEnd = existing.parent.offset + existing.parent.length;
                            if (propertyIndex > 0) {
                                // remove the comma of the previous node
                                let previous = parent.children[propertyIndex - 1];
                                removeBegin = previous.offset + previous.length;
                            } else {
                                removeBegin = parent.offset + 1;
                                if (parent.children.length > 1) {
                                    // remove the comma of the next node
                                    let next = parent.children[1];
                                    removeEnd = next.offset;
                                }
                            }
                            return withFormatting(text, {
                                offset: removeBegin,
                                length: removeEnd - removeBegin,
                                content: ''
                            }, options);
                        } else {
                            // set value of existing property
                            return withFormatting(text, {
                                offset: existing.offset,
                                length: existing.length,
                                content: JSON.stringify(value)
                            }, options);
                        }
                    } else {
                        if (value === void 0) {
                            return []; // property does not exist, nothing to do
                        }
                        const newProperty = `${JSON.stringify(lastSegment)}: ${JSON.stringify(value)}`;
                        const index = options.getInsertionIndex ? options.getInsertionIndex(parent.children.map((p)=>p.children[0].value)) : parent.children.length;
                        let edit1;
                        if (index > 0) {
                            let previous = parent.children[index - 1];
                            edit1 = {
                                offset: previous.offset + previous.length,
                                length: 0,
                                content: ',' + newProperty
                            };
                        } else if (parent.children.length === 0) {
                            edit1 = {
                                offset: parent.offset + 1,
                                length: 0,
                                content: newProperty
                            };
                        } else {
                            edit1 = {
                                offset: parent.offset + 1,
                                length: 0,
                                content: newProperty + ','
                            };
                        }
                        return withFormatting(text, edit1, options);
                    }
                } else if (parent.type === 'array' && typeof lastSegment === 'number' && Array.isArray(parent.children)) {
                    const insertIndex = lastSegment;
                    if (insertIndex === -1) {
                        // Insert
                        const newProperty = `${JSON.stringify(value)}`;
                        let edit1;
                        if (parent.children.length === 0) {
                            edit1 = {
                                offset: parent.offset + 1,
                                length: 0,
                                content: newProperty
                            };
                        } else {
                            const previous = parent.children[parent.children.length - 1];
                            edit1 = {
                                offset: previous.offset + previous.length,
                                length: 0,
                                content: ',' + newProperty
                            };
                        }
                        return withFormatting(text, edit1, options);
                    } else if (value === void 0 && parent.children.length >= 0) {
                        // Removal
                        const removalIndex = lastSegment;
                        const toRemove = parent.children[removalIndex];
                        let edit1;
                        if (parent.children.length === 1) {
                            // only item
                            edit1 = {
                                offset: parent.offset + 1,
                                length: parent.length - 2,
                                content: ''
                            };
                        } else if (parent.children.length - 1 === removalIndex) {
                            // last item
                            let previous = parent.children[removalIndex - 1];
                            let offset = previous.offset + previous.length;
                            let parentEndOffset = parent.offset + parent.length;
                            edit1 = {
                                offset,
                                length: parentEndOffset - 2 - offset,
                                content: ''
                            };
                        } else {
                            edit1 = {
                                offset: toRemove.offset,
                                length: parent.children[removalIndex + 1].offset - toRemove.offset,
                                content: ''
                            };
                        }
                        return withFormatting(text, edit1, options);
                    } else if (value !== void 0) {
                        let edit1;
                        const newProperty = `${JSON.stringify(value)}`;
                        if (!options.isArrayInsertion && parent.children.length > lastSegment) {
                            const toModify = parent.children[lastSegment];
                            edit1 = {
                                offset: toModify.offset,
                                length: toModify.length,
                                content: newProperty
                            };
                        } else if (parent.children.length === 0 || lastSegment === 0) {
                            edit1 = {
                                offset: parent.offset + 1,
                                length: 0,
                                content: parent.children.length === 0 ? newProperty : newProperty + ','
                            };
                        } else {
                            const index = lastSegment > parent.children.length ? parent.children.length : lastSegment;
                            const previous = parent.children[index - 1];
                            edit1 = {
                                offset: previous.offset + previous.length,
                                length: 0,
                                content: ',' + newProperty
                            };
                        }
                        return withFormatting(text, edit1, options);
                    } else {
                        throw new Error(`Can not ${value === void 0 ? 'remove' : options.isArrayInsertion ? 'insert' : 'modify'} Array index ${insertIndex} as length is not sufficient`);
                    }
                } else {
                    throw new Error(`Can not add ${typeof lastSegment !== 'number' ? 'index' : 'property'} to parent of type ${parent.type}`);
                }
            }
            function withFormatting(text, edit1, options) {
                if (!options.formattingOptions) {
                    return [
                        edit1
                    ];
                }
                // apply the edit
                let newText = applyEdit(text, edit1);
                // format the new text
                let begin = edit1.offset;
                let end = edit1.offset + edit1.content.length;
                if (edit1.length === 0 || edit1.content.length === 0) {
                    while(begin > 0 && !isEOL(newText, begin - 1)){
                        begin--;
                    }
                    while(end < newText.length && !isEOL(newText, end)){
                        end++;
                    }
                }
                const edits = format(newText, {
                    offset: begin,
                    length: end - begin
                }, {
                    ...options.formattingOptions,
                    keepLines: false
                });
                // apply the formatting edits and track the begin and end offsets of the changes
                for(let i = edits.length - 1; i >= 0; i--){
                    const edit1 = edits[i];
                    newText = applyEdit(newText, edit1);
                    begin = Math.min(begin, edit1.offset);
                    end = Math.max(end, edit1.offset + edit1.length);
                    end += edit1.content.length - edit1.length;
                }
                // create a single edit with all changes
                const editLength = text.length - (newText.length - end) - begin;
                return [
                    {
                        offset: begin,
                        length: editLength,
                        content: newText.substring(begin, end)
                    }
                ];
            }
            function applyEdit(text, edit1) {
                return text.substring(0, edit1.offset) + edit1.content + text.substring(edit1.offset + edit1.length);
            }
            function isWS(text, offset) {
                return '\r\n \t'.indexOf(text.charAt(offset)) !== -1;
            }
            ; // CONCATENATED MODULE: ../../node_modules/jsonc-parser/lib/esm/main.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ /**
 * Creates a JSON scanner on the given text.
 * If ignoreTrivia is set, whitespaces or comments are ignored.
 */ const main_createScanner = createScanner;
            var ScanError;
            (function(ScanError) {
                ScanError[ScanError["None"] = 0] = "None";
                ScanError[ScanError["UnexpectedEndOfComment"] = 1] = "UnexpectedEndOfComment";
                ScanError[ScanError["UnexpectedEndOfString"] = 2] = "UnexpectedEndOfString";
                ScanError[ScanError["UnexpectedEndOfNumber"] = 3] = "UnexpectedEndOfNumber";
                ScanError[ScanError["InvalidUnicode"] = 4] = "InvalidUnicode";
                ScanError[ScanError["InvalidEscapeCharacter"] = 5] = "InvalidEscapeCharacter";
                ScanError[ScanError["InvalidCharacter"] = 6] = "InvalidCharacter";
            })(ScanError || (ScanError = {}));
            var SyntaxKind;
            (function(SyntaxKind) {
                SyntaxKind[SyntaxKind["OpenBraceToken"] = 1] = "OpenBraceToken";
                SyntaxKind[SyntaxKind["CloseBraceToken"] = 2] = "CloseBraceToken";
                SyntaxKind[SyntaxKind["OpenBracketToken"] = 3] = "OpenBracketToken";
                SyntaxKind[SyntaxKind["CloseBracketToken"] = 4] = "CloseBracketToken";
                SyntaxKind[SyntaxKind["CommaToken"] = 5] = "CommaToken";
                SyntaxKind[SyntaxKind["ColonToken"] = 6] = "ColonToken";
                SyntaxKind[SyntaxKind["NullKeyword"] = 7] = "NullKeyword";
                SyntaxKind[SyntaxKind["TrueKeyword"] = 8] = "TrueKeyword";
                SyntaxKind[SyntaxKind["FalseKeyword"] = 9] = "FalseKeyword";
                SyntaxKind[SyntaxKind["StringLiteral"] = 10] = "StringLiteral";
                SyntaxKind[SyntaxKind["NumericLiteral"] = 11] = "NumericLiteral";
                SyntaxKind[SyntaxKind["LineCommentTrivia"] = 12] = "LineCommentTrivia";
                SyntaxKind[SyntaxKind["BlockCommentTrivia"] = 13] = "BlockCommentTrivia";
                SyntaxKind[SyntaxKind["LineBreakTrivia"] = 14] = "LineBreakTrivia";
                SyntaxKind[SyntaxKind["Trivia"] = 15] = "Trivia";
                SyntaxKind[SyntaxKind["Unknown"] = 16] = "Unknown";
                SyntaxKind[SyntaxKind["EOF"] = 17] = "EOF";
            })(SyntaxKind || (SyntaxKind = {}));
            /**
 * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.
 */ const main_getLocation = getLocation;
            /**
 * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 * Therefore, always check the errors list to find out if the input was valid.
 */ const main_parse = parse;
            /**
 * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 */ const main_parseTree = parser_parseTree;
            /**
 * Finds the node at the given path in a JSON DOM.
 */ const main_findNodeAtLocation = parser_findNodeAtLocation;
            /**
 * Finds the innermost node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.
 */ const main_findNodeAtOffset = findNodeAtOffset;
            /**
 * Gets the JSON path of the given JSON DOM node
 */ const main_getNodePath = getNodePath;
            /**
 * Evaluates the JavaScript object of the given JSON DOM node
 */ const main_getNodeValue = getNodeValue;
            /**
 * Parses the given text and invokes the visitor functions for each object, array and literal reached.
 */ const main_visit = visit;
            /**
 * Takes JSON with JavaScript-style comments and remove
 * them. Optionally replaces every none-newline character
 * of comments with a replaceCharacter
 */ const main_stripComments = stripComments;
            var ParseErrorCode;
            (function(ParseErrorCode) {
                ParseErrorCode[ParseErrorCode["InvalidSymbol"] = 1] = "InvalidSymbol";
                ParseErrorCode[ParseErrorCode["InvalidNumberFormat"] = 2] = "InvalidNumberFormat";
                ParseErrorCode[ParseErrorCode["PropertyNameExpected"] = 3] = "PropertyNameExpected";
                ParseErrorCode[ParseErrorCode["ValueExpected"] = 4] = "ValueExpected";
                ParseErrorCode[ParseErrorCode["ColonExpected"] = 5] = "ColonExpected";
                ParseErrorCode[ParseErrorCode["CommaExpected"] = 6] = "CommaExpected";
                ParseErrorCode[ParseErrorCode["CloseBraceExpected"] = 7] = "CloseBraceExpected";
                ParseErrorCode[ParseErrorCode["CloseBracketExpected"] = 8] = "CloseBracketExpected";
                ParseErrorCode[ParseErrorCode["EndOfFileExpected"] = 9] = "EndOfFileExpected";
                ParseErrorCode[ParseErrorCode["InvalidCommentToken"] = 10] = "InvalidCommentToken";
                ParseErrorCode[ParseErrorCode["UnexpectedEndOfComment"] = 11] = "UnexpectedEndOfComment";
                ParseErrorCode[ParseErrorCode["UnexpectedEndOfString"] = 12] = "UnexpectedEndOfString";
                ParseErrorCode[ParseErrorCode["UnexpectedEndOfNumber"] = 13] = "UnexpectedEndOfNumber";
                ParseErrorCode[ParseErrorCode["InvalidUnicode"] = 14] = "InvalidUnicode";
                ParseErrorCode[ParseErrorCode["InvalidEscapeCharacter"] = 15] = "InvalidEscapeCharacter";
                ParseErrorCode[ParseErrorCode["InvalidCharacter"] = 16] = "InvalidCharacter";
            })(ParseErrorCode || (ParseErrorCode = {}));
            function printParseErrorCode(code) {
                switch(code){
                    case 1 /* ParseErrorCode.InvalidSymbol */ :
                        return 'InvalidSymbol';
                    case 2 /* ParseErrorCode.InvalidNumberFormat */ :
                        return 'InvalidNumberFormat';
                    case 3 /* ParseErrorCode.PropertyNameExpected */ :
                        return 'PropertyNameExpected';
                    case 4 /* ParseErrorCode.ValueExpected */ :
                        return 'ValueExpected';
                    case 5 /* ParseErrorCode.ColonExpected */ :
                        return 'ColonExpected';
                    case 6 /* ParseErrorCode.CommaExpected */ :
                        return 'CommaExpected';
                    case 7 /* ParseErrorCode.CloseBraceExpected */ :
                        return 'CloseBraceExpected';
                    case 8 /* ParseErrorCode.CloseBracketExpected */ :
                        return 'CloseBracketExpected';
                    case 9 /* ParseErrorCode.EndOfFileExpected */ :
                        return 'EndOfFileExpected';
                    case 10 /* ParseErrorCode.InvalidCommentToken */ :
                        return 'InvalidCommentToken';
                    case 11 /* ParseErrorCode.UnexpectedEndOfComment */ :
                        return 'UnexpectedEndOfComment';
                    case 12 /* ParseErrorCode.UnexpectedEndOfString */ :
                        return 'UnexpectedEndOfString';
                    case 13 /* ParseErrorCode.UnexpectedEndOfNumber */ :
                        return 'UnexpectedEndOfNumber';
                    case 14 /* ParseErrorCode.InvalidUnicode */ :
                        return 'InvalidUnicode';
                    case 15 /* ParseErrorCode.InvalidEscapeCharacter */ :
                        return 'InvalidEscapeCharacter';
                    case 16 /* ParseErrorCode.InvalidCharacter */ :
                        return 'InvalidCharacter';
                }
                return '<unknown ParseErrorCode>';
            }
            /**
 * Computes the edit operations needed to format a JSON document.
 *
 * @param documentText The input text
 * @param range The range to format or `undefined` to format the full content
 * @param options The formatting options
 * @returns The edit operations describing the formatting changes to the original document following the format described in {@linkcode EditResult}.
 * To apply the edit operations to the input, use {@linkcode applyEdits}.
 */ function main_format(documentText, range, options) {
                return format_format(documentText, range, options);
            }
            /**
 * Computes the edit operations needed to modify a value in the JSON document.
 *
 * @param documentText The input text
 * @param path The path of the value to change. The path represents either to the document root, a property or an array item.
 * If the path points to an non-existing property or item, it will be created.
 * @param value The new value for the specified property or item. If the value is undefined,
 * the property or item will be removed.
 * @param options Options
 * @returns The edit operations describing the changes to the original document, following the format described in {@linkcode EditResult}.
 * To apply the edit operations to the input, use {@linkcode applyEdits}.
 */ function modify(text, path, value, options) {
                return edit.setProperty(text, path, value, options);
            }
            /**
 * Applies edits to an input string.
 * @param text The input text
 * @param edits Edit operations following the format described in {@linkcode EditResult}.
 * @returns The text with the applied edits.
 * @throws An error if the edit operations are not well-formed as described in {@linkcode EditResult}.
 */ function applyEdits(text, edits) {
                let sortedEdits = edits.slice(0).sort((a, b)=>{
                    const diff = a.offset - b.offset;
                    if (diff === 0) {
                        return a.length - b.length;
                    }
                    return diff;
                });
                let lastModifiedOffset = text.length;
                for(let i = sortedEdits.length - 1; i >= 0; i--){
                    let e = sortedEdits[i];
                    if (e.offset + e.length <= lastModifiedOffset) {
                        text = edit.applyEdit(text, e);
                    } else {
                        throw new Error('Overlapping edit');
                    }
                    lastModifiedOffset = e.offset;
                }
                return text;
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/utils/objects.js
            /*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/ function equals(one, other) {
                if (one === other) {
                    return true;
                }
                if (one === null || one === undefined || other === null || other === undefined) {
                    return false;
                }
                if (typeof one !== typeof other) {
                    return false;
                }
                if (typeof one !== 'object') {
                    return false;
                }
                if (Array.isArray(one) !== Array.isArray(other)) {
                    return false;
                }
                let i, key;
                if (Array.isArray(one)) {
                    if (one.length !== other.length) {
                        return false;
                    }
                    for(i = 0; i < one.length; i++){
                        if (!equals(one[i], other[i])) {
                            return false;
                        }
                    }
                } else {
                    const oneKeys = [];
                    for(key in one){
                        oneKeys.push(key);
                    }
                    oneKeys.sort();
                    const otherKeys = [];
                    for(key in other){
                        otherKeys.push(key);
                    }
                    otherKeys.sort();
                    if (!equals(oneKeys, otherKeys)) {
                        return false;
                    }
                    for(i = 0; i < oneKeys.length; i++){
                        if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {
                            return false;
                        }
                    }
                }
                return true;
            }
            function isNumber(val) {
                return typeof val === 'number';
            }
            function isDefined(val) {
                return typeof val !== 'undefined';
            }
            function isBoolean(val) {
                return typeof val === 'boolean';
            }
            function isString(val) {
                return typeof val === 'string';
            }
            function isObject(val) {
                return typeof val === 'object' && val !== null && !Array.isArray(val);
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/utils/strings.js
            /*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/ function startsWith(haystack, needle) {
                if (haystack.length < needle.length) {
                    return false;
                }
                for(let i = 0; i < needle.length; i++){
                    if (haystack[i] !== needle[i]) {
                        return false;
                    }
                }
                return true;
            }
            /**
 * Determines if haystack ends with needle.
 */ function endsWith(haystack, needle) {
                const diff = haystack.length - needle.length;
                if (diff > 0) {
                    return haystack.lastIndexOf(needle) === diff;
                } else if (diff === 0) {
                    return haystack === needle;
                } else {
                    return false;
                }
            }
            function convertSimple2RegExpPattern(pattern) {
                return pattern.replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, '\\$&').replace(/[\*]/g, '.*');
            }
            function strings_repeat(value, count) {
                let s = '';
                while(count > 0){
                    if ((count & 1) === 1) {
                        s += value;
                    }
                    value += value;
                    count = count >>> 1;
                }
                return s;
            }
            function extendedRegExp(pattern) {
                let flags = '';
                if (startsWith(pattern, '(?i)')) {
                    pattern = pattern.substring(4);
                    flags = 'i';
                }
                try {
                    return new RegExp(pattern, flags + 'u');
                } catch (e) {
                    // could be an exception due to the 'u ' flag
                    try {
                        return new RegExp(pattern, flags);
                    } catch (e) {
                        // invalid pattern
                        return undefined;
                    }
                }
            }
            // from https://tanishiking.github.io/posts/count-unicode-codepoint/#work-hard-with-for-statements
            function stringLength(str) {
                let count = 0;
                for(let i = 0; i < str.length; i++){
                    count++;
                    // obtain the i-th 16-bit
                    const code = str.charCodeAt(i);
                    if (0xD800 <= code && code <= 0xDBFF) {
                        // if the i-th 16bit is an upper surrogate
                        // skip the next 16 bits (lower surrogate)
                        i++;
                    }
                }
                return count;
            }
            // EXTERNAL MODULE: ../../node_modules/vscode-languageserver-types/lib/esm/main.js
            var main = __nested_webpack_require_701519__(4767);
            // EXTERNAL MODULE: ../../node_modules/vscode-languageserver-textdocument/lib/esm/main.js
            var esm_main = __nested_webpack_require_701519__(4881);
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/jsonLanguageTypes.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ /**
 * Error codes used by diagnostics
 */ var ErrorCode;
            (function(ErrorCode) {
                ErrorCode[ErrorCode["Undefined"] = 0] = "Undefined";
                ErrorCode[ErrorCode["EnumValueMismatch"] = 1] = "EnumValueMismatch";
                ErrorCode[ErrorCode["Deprecated"] = 2] = "Deprecated";
                ErrorCode[ErrorCode["UnexpectedEndOfComment"] = 257] = "UnexpectedEndOfComment";
                ErrorCode[ErrorCode["UnexpectedEndOfString"] = 258] = "UnexpectedEndOfString";
                ErrorCode[ErrorCode["UnexpectedEndOfNumber"] = 259] = "UnexpectedEndOfNumber";
                ErrorCode[ErrorCode["InvalidUnicode"] = 260] = "InvalidUnicode";
                ErrorCode[ErrorCode["InvalidEscapeCharacter"] = 261] = "InvalidEscapeCharacter";
                ErrorCode[ErrorCode["InvalidCharacter"] = 262] = "InvalidCharacter";
                ErrorCode[ErrorCode["PropertyExpected"] = 513] = "PropertyExpected";
                ErrorCode[ErrorCode["CommaExpected"] = 514] = "CommaExpected";
                ErrorCode[ErrorCode["ColonExpected"] = 515] = "ColonExpected";
                ErrorCode[ErrorCode["ValueExpected"] = 516] = "ValueExpected";
                ErrorCode[ErrorCode["CommaOrCloseBacketExpected"] = 517] = "CommaOrCloseBacketExpected";
                ErrorCode[ErrorCode["CommaOrCloseBraceExpected"] = 518] = "CommaOrCloseBraceExpected";
                ErrorCode[ErrorCode["TrailingComma"] = 519] = "TrailingComma";
                ErrorCode[ErrorCode["DuplicateKey"] = 520] = "DuplicateKey";
                ErrorCode[ErrorCode["CommentNotPermitted"] = 521] = "CommentNotPermitted";
                ErrorCode[ErrorCode["SchemaResolveError"] = 768] = "SchemaResolveError";
                ErrorCode[ErrorCode["SchemaUnsupportedFeature"] = 769] = "SchemaUnsupportedFeature";
            })(ErrorCode || (ErrorCode = {}));
            var SchemaDraft;
            (function(SchemaDraft) {
                SchemaDraft[SchemaDraft["v3"] = 3] = "v3";
                SchemaDraft[SchemaDraft["v4"] = 4] = "v4";
                SchemaDraft[SchemaDraft["v6"] = 6] = "v6";
                SchemaDraft[SchemaDraft["v7"] = 7] = "v7";
                SchemaDraft[SchemaDraft["v2019_09"] = 19] = "v2019_09";
                SchemaDraft[SchemaDraft["v2020_12"] = 20] = "v2020_12";
            })(SchemaDraft || (SchemaDraft = {}));
            var ClientCapabilities;
            (function(ClientCapabilities) {
                ClientCapabilities.LATEST = {
                    textDocument: {
                        completion: {
                            completionItem: {
                                documentationFormat: [
                                    main.MarkupKind.Markdown,
                                    main.MarkupKind.PlainText
                                ],
                                commitCharactersSupport: true,
                                labelDetailsSupport: true
                            }
                        }
                    }
                };
            })(ClientCapabilities || (ClientCapabilities = {}));
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/node_modules/@vscode/l10n/dist/browser.js
            // src/browser/reader.ts
            async function readFileFromUri(uri) {
                if (uri.protocol === "http:" || uri.protocol === "https:") {
                    const res = await fetch(uri);
                    return await res.text();
                }
                throw new Error("Unsupported protocol");
            }
            function readFileFromFsPath(_) {
                throw new Error("Unsupported in browser");
            }
            // src/main.ts
            var bundle;
            function config(config2) {
                if ("contents" in config2) {
                    if (typeof config2.contents === "string") {
                        bundle = JSON.parse(config2.contents);
                    } else {
                        bundle = config2.contents;
                    }
                    return;
                }
                if ("fsPath" in config2) {
                    const fileContent = readFileFromFsPath(config2.fsPath);
                    const content = JSON.parse(fileContent);
                    bundle = isBuiltinExtension(content) ? content.contents.bundle : content;
                    return;
                }
                if (config2.uri) {
                    let uri = config2.uri;
                    if (typeof config2.uri === "string") {
                        uri = new URL(config2.uri);
                    }
                    return new Promise((resolve, reject)=>{
                        const p = readFileFromUri(uri).then((uriContent)=>{
                            try {
                                const content = JSON.parse(uriContent);
                                bundle = isBuiltinExtension(content) ? content.contents.bundle : content;
                            } catch (err) {
                                reject(err);
                            }
                        }).catch((err)=>{
                            reject(err);
                        });
                        resolve(p);
                    });
                }
            }
            function t(...args) {
                const firstArg = args[0];
                let key;
                let message;
                let formatArgs;
                if (typeof firstArg === "string") {
                    key = firstArg;
                    message = firstArg;
                    args.splice(0, 1);
                    formatArgs = !args || typeof args[0] !== "object" ? args : args[0];
                } else {
                    message = firstArg.message;
                    key = message;
                    if (firstArg.comment && firstArg.comment.length > 0) {
                        key += `/${Array.isArray(firstArg.comment) ? firstArg.comment.join("") : firstArg.comment}`;
                    }
                    var _firstArg_args;
                    formatArgs = (_firstArg_args = firstArg.args) !== null && _firstArg_args !== void 0 ? _firstArg_args : {};
                }
                if (!bundle) {
                    return browser_format(message, formatArgs);
                }
                const messageFromBundle = bundle[key];
                if (!messageFromBundle) {
                    return browser_format(message, formatArgs);
                }
                if (typeof messageFromBundle === "string") {
                    return browser_format(messageFromBundle, formatArgs);
                }
                if (messageFromBundle.comment) {
                    return browser_format(messageFromBundle.message, formatArgs);
                }
                return browser_format(message, formatArgs);
            }
            var _format2Regexp = /{([^}]+)}/g;
            function browser_format(template, values) {
                var _values_group;
                return template.replace(_format2Regexp, (match, group)=>(_values_group = values[group]) !== null && _values_group !== void 0 ? _values_group : match);
            }
            function isBuiltinExtension(json) {
                var _json_contents, _json, _json1;
                return !!(typeof ((_json = json) === null || _json === void 0 ? void 0 : (_json_contents = _json.contents) === null || _json_contents === void 0 ? void 0 : _json_contents.bundle) === "object" && typeof ((_json1 = json) === null || _json1 === void 0 ? void 0 : _json1.version) === "string");
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/parser/jsonParser.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ const formats = {
                'color-hex': {
                    errorMessage: t('Invalid color format. Use #RGB, #RGBA, #RRGGBB or #RRGGBBAA.'),
                    pattern: /^#([0-9A-Fa-f]{3,4}|([0-9A-Fa-f]{2}){3,4})$/
                },
                'date-time': {
                    errorMessage: t('String is not a RFC3339 date-time.'),
                    pattern: /^(\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i
                },
                'date': {
                    errorMessage: t('String is not a RFC3339 date.'),
                    pattern: /^(\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/i
                },
                'time': {
                    errorMessage: t('String is not a RFC3339 time.'),
                    pattern: /^([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i
                },
                'email': {
                    errorMessage: t('String is not an e-mail address.'),
                    pattern: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}))$/
                },
                'hostname': {
                    errorMessage: t('String is not a hostname.'),
                    pattern: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i
                },
                'ipv4': {
                    errorMessage: t('String is not an IPv4 address.'),
                    pattern: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/
                },
                'ipv6': {
                    errorMessage: t('String is not an IPv6 address.'),
                    pattern: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i
                }
            };
            class ASTNodeImpl {
                get children() {
                    return [];
                }
                toString() {
                    return 'type: ' + this.type + ' (' + this.offset + '/' + this.length + ')' + (this.parent ? ' parent: {' + this.parent.toString() + '}' : '');
                }
                constructor(parent, offset, length = 0){
                    this.offset = offset;
                    this.length = length;
                    this.parent = parent;
                }
            }
            class NullASTNodeImpl extends ASTNodeImpl {
                constructor(parent, offset){
                    super(parent, offset);
                    this.type = 'null';
                    this.value = null;
                }
            }
            class BooleanASTNodeImpl extends ASTNodeImpl {
                constructor(parent, boolValue, offset){
                    super(parent, offset);
                    this.type = 'boolean';
                    this.value = boolValue;
                }
            }
            class ArrayASTNodeImpl extends ASTNodeImpl {
                get children() {
                    return this.items;
                }
                constructor(parent, offset){
                    super(parent, offset);
                    this.type = 'array';
                    this.items = [];
                }
            }
            class NumberASTNodeImpl extends ASTNodeImpl {
                constructor(parent, offset){
                    super(parent, offset);
                    this.type = 'number';
                    this.isInteger = true;
                    this.value = Number.NaN;
                }
            }
            class StringASTNodeImpl extends ASTNodeImpl {
                constructor(parent, offset, length){
                    super(parent, offset, length);
                    this.type = 'string';
                    this.value = '';
                }
            }
            class PropertyASTNodeImpl extends ASTNodeImpl {
                get children() {
                    return this.valueNode ? [
                        this.keyNode,
                        this.valueNode
                    ] : [
                        this.keyNode
                    ];
                }
                constructor(parent, offset, keyNode){
                    super(parent, offset);
                    this.type = 'property';
                    this.colonOffset = -1;
                    this.keyNode = keyNode;
                }
            }
            class ObjectASTNodeImpl extends ASTNodeImpl {
                get children() {
                    return this.properties;
                }
                constructor(parent, offset){
                    super(parent, offset);
                    this.type = 'object';
                    this.properties = [];
                }
            }
            function asSchema(schema) {
                if (isBoolean(schema)) {
                    return schema ? {} : {
                        "not": {}
                    };
                }
                return schema;
            }
            var EnumMatch;
            (function(EnumMatch) {
                EnumMatch[EnumMatch["Key"] = 0] = "Key";
                EnumMatch[EnumMatch["Enum"] = 1] = "Enum";
            })(EnumMatch || (EnumMatch = {}));
            const schemaDraftFromId = {
                'http://json-schema.org/draft-03/schema#': SchemaDraft.v3,
                'http://json-schema.org/draft-04/schema#': SchemaDraft.v4,
                'http://json-schema.org/draft-06/schema#': SchemaDraft.v6,
                'http://json-schema.org/draft-07/schema#': SchemaDraft.v7,
                'https://json-schema.org/draft/2019-09/schema': SchemaDraft.v2019_09,
                'https://json-schema.org/draft/2020-12/schema': SchemaDraft.v2020_12
            };
            class EvaluationContext {
                constructor(schemaDraft){
                    this.schemaDraft = schemaDraft;
                }
            }
            class SchemaCollector {
                add(schema) {
                    this.schemas.push(schema);
                }
                merge(other) {
                    Array.prototype.push.apply(this.schemas, other.schemas);
                }
                include(node) {
                    return (this.focusOffset === -1 || jsonParser_contains(node, this.focusOffset)) && node !== this.exclude;
                }
                newSub() {
                    return new SchemaCollector(-1, this.exclude);
                }
                constructor(focusOffset = -1, exclude){
                    this.focusOffset = focusOffset;
                    this.exclude = exclude;
                    this.schemas = [];
                }
            }
            class NoOpSchemaCollector {
                get schemas() {
                    return [];
                }
                add(_schema) {}
                merge(_other) {}
                include(_node) {
                    return true;
                }
                newSub() {
                    return this;
                }
                constructor(){}
            }
            NoOpSchemaCollector.instance = new NoOpSchemaCollector();
            class ValidationResult {
                hasProblems() {
                    return !!this.problems.length;
                }
                merge(validationResult) {
                    this.problems = this.problems.concat(validationResult.problems);
                    this.propertiesMatches += validationResult.propertiesMatches;
                    this.propertiesValueMatches += validationResult.propertiesValueMatches;
                    this.mergeProcessedProperties(validationResult);
                }
                mergeEnumValues(validationResult) {
                    if (!this.enumValueMatch && !validationResult.enumValueMatch && this.enumValues && validationResult.enumValues) {
                        this.enumValues = this.enumValues.concat(validationResult.enumValues);
                        for (const error of this.problems){
                            if (error.code === ErrorCode.EnumValueMismatch) {
                                error.message = t('Value is not accepted. Valid values: {0}.', this.enumValues.map((v)=>JSON.stringify(v)).join(', '));
                            }
                        }
                    }
                }
                mergePropertyMatch(propertyValidationResult) {
                    this.problems = this.problems.concat(propertyValidationResult.problems);
                    this.propertiesMatches++;
                    if (propertyValidationResult.enumValueMatch || !propertyValidationResult.hasProblems() && propertyValidationResult.propertiesMatches) {
                        this.propertiesValueMatches++;
                    }
                    if (propertyValidationResult.enumValueMatch && propertyValidationResult.enumValues && propertyValidationResult.enumValues.length === 1) {
                        this.primaryValueMatches++;
                    }
                }
                mergeProcessedProperties(validationResult) {
                    validationResult.processedProperties.forEach((p)=>this.processedProperties.add(p));
                }
                compare(other) {
                    const hasProblems = this.hasProblems();
                    if (hasProblems !== other.hasProblems()) {
                        return hasProblems ? -1 : 1;
                    }
                    if (this.enumValueMatch !== other.enumValueMatch) {
                        return other.enumValueMatch ? -1 : 1;
                    }
                    if (this.primaryValueMatches !== other.primaryValueMatches) {
                        return this.primaryValueMatches - other.primaryValueMatches;
                    }
                    if (this.propertiesValueMatches !== other.propertiesValueMatches) {
                        return this.propertiesValueMatches - other.propertiesValueMatches;
                    }
                    return this.propertiesMatches - other.propertiesMatches;
                }
                constructor(){
                    this.problems = [];
                    this.propertiesMatches = 0;
                    this.processedProperties = new Set();
                    this.propertiesValueMatches = 0;
                    this.primaryValueMatches = 0;
                    this.enumValueMatch = false;
                    this.enumValues = undefined;
                }
            }
            function newJSONDocument(root, diagnostics = []) {
                return new JSONDocument(root, diagnostics, []);
            }
            function jsonParser_getNodeValue(node) {
                return main_getNodeValue(node);
            }
            function jsonParser_getNodePath(node) {
                return main_getNodePath(node);
            }
            function jsonParser_contains(node, offset, includeRightBound = false) {
                return offset >= node.offset && offset < node.offset + node.length || includeRightBound && offset === node.offset + node.length;
            }
            class JSONDocument {
                getNodeFromOffset(offset, includeRightBound = false) {
                    if (this.root) {
                        return main_findNodeAtOffset(this.root, offset, includeRightBound);
                    }
                    return undefined;
                }
                visit(visitor) {
                    if (this.root) {
                        const doVisit = (node)=>{
                            let ctn = visitor(node);
                            const children = node.children;
                            if (Array.isArray(children)) {
                                for(let i = 0; i < children.length && ctn; i++){
                                    ctn = doVisit(children[i]);
                                }
                            }
                            return ctn;
                        };
                        doVisit(this.root);
                    }
                }
                validate(textDocument, schema, severity = main.DiagnosticSeverity.Warning, schemaDraft) {
                    if (this.root && schema) {
                        const validationResult = new ValidationResult();
                        validate(this.root, schema, validationResult, NoOpSchemaCollector.instance, new EvaluationContext(schemaDraft !== null && schemaDraft !== void 0 ? schemaDraft : getSchemaDraft(schema)));
                        return validationResult.problems.map((p)=>{
                            const range = main.Range.create(textDocument.positionAt(p.location.offset), textDocument.positionAt(p.location.offset + p.location.length));
                            var _p_severity;
                            return main.Diagnostic.create(range, p.message, (_p_severity = p.severity) !== null && _p_severity !== void 0 ? _p_severity : severity, p.code);
                        });
                    }
                    return undefined;
                }
                getMatchingSchemas(schema, focusOffset = -1, exclude) {
                    if (this.root && schema) {
                        const matchingSchemas = new SchemaCollector(focusOffset, exclude);
                        const schemaDraft = getSchemaDraft(schema);
                        const context = new EvaluationContext(schemaDraft);
                        validate(this.root, schema, new ValidationResult(), matchingSchemas, context);
                        return matchingSchemas.schemas;
                    }
                    return [];
                }
                constructor(root, syntaxErrors = [], comments = []){
                    this.root = root;
                    this.syntaxErrors = syntaxErrors;
                    this.comments = comments;
                }
            }
            function getSchemaDraft(schema, fallBack = SchemaDraft.v2020_12) {
                let schemaId = schema.$schema;
                if (schemaId) {
                    var _schemaDraftFromId_schemaId;
                    return (_schemaDraftFromId_schemaId = schemaDraftFromId[schemaId]) !== null && _schemaDraftFromId_schemaId !== void 0 ? _schemaDraftFromId_schemaId : fallBack;
                }
                return fallBack;
            }
            function validate(n, schema, validationResult, matchingSchemas, context) {
                if (!n || !matchingSchemas.include(n)) {
                    return;
                }
                if (n.type === 'property') {
                    return validate(n.valueNode, schema, validationResult, matchingSchemas, context);
                }
                const node = n;
                _validateNode();
                switch(node.type){
                    case 'object':
                        _validateObjectNode(node);
                        break;
                    case 'array':
                        _validateArrayNode(node);
                        break;
                    case 'string':
                        _validateStringNode(node);
                        break;
                    case 'number':
                        _validateNumberNode(node);
                        break;
                }
                matchingSchemas.add({
                    node: node,
                    schema: schema
                });
                function _validateNode() {
                    function matchesType(type) {
                        return node.type === type || type === 'integer' && node.type === 'number' && node.isInteger;
                    }
                    if (Array.isArray(schema.type)) {
                        if (!schema.type.some(matchesType)) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: schema.errorMessage || t('Incorrect type. Expected one of {0}.', schema.type.join(', '))
                            });
                        }
                    } else if (schema.type) {
                        if (!matchesType(schema.type)) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: schema.errorMessage || t('Incorrect type. Expected "{0}".', schema.type)
                            });
                        }
                    }
                    if (Array.isArray(schema.allOf)) {
                        for (const subSchemaRef of schema.allOf){
                            const subValidationResult = new ValidationResult();
                            const subMatchingSchemas = matchingSchemas.newSub();
                            validate(node, asSchema(subSchemaRef), subValidationResult, subMatchingSchemas, context);
                            validationResult.merge(subValidationResult);
                            matchingSchemas.merge(subMatchingSchemas);
                        }
                    }
                    const notSchema = asSchema(schema.not);
                    if (notSchema) {
                        const subValidationResult = new ValidationResult();
                        const subMatchingSchemas = matchingSchemas.newSub();
                        validate(node, notSchema, subValidationResult, subMatchingSchemas, context);
                        if (!subValidationResult.hasProblems()) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: schema.errorMessage || t("Matches a schema that is not allowed.")
                            });
                        }
                        for (const ms of subMatchingSchemas.schemas){
                            ms.inverted = !ms.inverted;
                            matchingSchemas.add(ms);
                        }
                    }
                    const testAlternatives = (alternatives, maxOneMatch)=>{
                        const matches = [];
                        // remember the best match that is used for error messages
                        let bestMatch = undefined;
                        for (const subSchemaRef of alternatives){
                            const subSchema = asSchema(subSchemaRef);
                            const subValidationResult = new ValidationResult();
                            const subMatchingSchemas = matchingSchemas.newSub();
                            validate(node, subSchema, subValidationResult, subMatchingSchemas, context);
                            if (!subValidationResult.hasProblems()) {
                                matches.push(subSchema);
                            }
                            if (!bestMatch) {
                                bestMatch = {
                                    schema: subSchema,
                                    validationResult: subValidationResult,
                                    matchingSchemas: subMatchingSchemas
                                };
                            } else {
                                if (!maxOneMatch && !subValidationResult.hasProblems() && !bestMatch.validationResult.hasProblems()) {
                                    // no errors, both are equally good matches
                                    bestMatch.matchingSchemas.merge(subMatchingSchemas);
                                    bestMatch.validationResult.propertiesMatches += subValidationResult.propertiesMatches;
                                    bestMatch.validationResult.propertiesValueMatches += subValidationResult.propertiesValueMatches;
                                    bestMatch.validationResult.mergeProcessedProperties(subValidationResult);
                                } else {
                                    const compareResult = subValidationResult.compare(bestMatch.validationResult);
                                    if (compareResult > 0) {
                                        // our node is the best matching so far
                                        bestMatch = {
                                            schema: subSchema,
                                            validationResult: subValidationResult,
                                            matchingSchemas: subMatchingSchemas
                                        };
                                    } else if (compareResult === 0) {
                                        // there's already a best matching but we are as good
                                        bestMatch.matchingSchemas.merge(subMatchingSchemas);
                                        bestMatch.validationResult.mergeEnumValues(subValidationResult);
                                    }
                                }
                            }
                        }
                        if (matches.length > 1 && maxOneMatch) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: 1
                                },
                                message: t("Matches multiple schemas when only one must validate.")
                            });
                        }
                        if (bestMatch) {
                            validationResult.merge(bestMatch.validationResult);
                            matchingSchemas.merge(bestMatch.matchingSchemas);
                        }
                        return matches.length;
                    };
                    if (Array.isArray(schema.anyOf)) {
                        testAlternatives(schema.anyOf, false);
                    }
                    if (Array.isArray(schema.oneOf)) {
                        testAlternatives(schema.oneOf, true);
                    }
                    const testBranch = (schema)=>{
                        const subValidationResult = new ValidationResult();
                        const subMatchingSchemas = matchingSchemas.newSub();
                        validate(node, asSchema(schema), subValidationResult, subMatchingSchemas, context);
                        validationResult.merge(subValidationResult);
                        matchingSchemas.merge(subMatchingSchemas);
                    };
                    const testCondition = (ifSchema, thenSchema, elseSchema)=>{
                        const subSchema = asSchema(ifSchema);
                        const subValidationResult = new ValidationResult();
                        const subMatchingSchemas = matchingSchemas.newSub();
                        validate(node, subSchema, subValidationResult, subMatchingSchemas, context);
                        matchingSchemas.merge(subMatchingSchemas);
                        validationResult.mergeProcessedProperties(subValidationResult);
                        if (!subValidationResult.hasProblems()) {
                            if (thenSchema) {
                                testBranch(thenSchema);
                            }
                        } else if (elseSchema) {
                            testBranch(elseSchema);
                        }
                    };
                    const ifSchema = asSchema(schema.if);
                    if (ifSchema) {
                        testCondition(ifSchema, asSchema(schema.then), asSchema(schema.else));
                    }
                    if (Array.isArray(schema.enum)) {
                        const val = jsonParser_getNodeValue(node);
                        let enumValueMatch = false;
                        for (const e of schema.enum){
                            if (equals(val, e)) {
                                enumValueMatch = true;
                                break;
                            }
                        }
                        validationResult.enumValues = schema.enum;
                        validationResult.enumValueMatch = enumValueMatch;
                        if (!enumValueMatch) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                code: ErrorCode.EnumValueMismatch,
                                message: schema.errorMessage || t('Value is not accepted. Valid values: {0}.', schema.enum.map((v)=>JSON.stringify(v)).join(', '))
                            });
                        }
                    }
                    if (isDefined(schema.const)) {
                        const val = jsonParser_getNodeValue(node);
                        if (!equals(val, schema.const)) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                code: ErrorCode.EnumValueMismatch,
                                message: schema.errorMessage || t('Value must be {0}.', JSON.stringify(schema.const))
                            });
                            validationResult.enumValueMatch = false;
                        } else {
                            validationResult.enumValueMatch = true;
                        }
                        validationResult.enumValues = [
                            schema.const
                        ];
                    }
                    let deprecationMessage = schema.deprecationMessage;
                    if ((deprecationMessage || schema.deprecated) && node.parent) {
                        deprecationMessage = deprecationMessage || t('Value is deprecated');
                        validationResult.problems.push({
                            location: {
                                offset: node.parent.offset,
                                length: node.parent.length
                            },
                            severity: main.DiagnosticSeverity.Warning,
                            message: deprecationMessage,
                            code: ErrorCode.Deprecated
                        });
                    }
                }
                function _validateNumberNode(node) {
                    const val = node.value;
                    function normalizeFloats(float) {
                        var _parts_;
                        const parts = /^(-?\d+)(?:\.(\d+))?(?:e([-+]\d+))?$/.exec(float.toString());
                        return parts && {
                            value: Number(parts[1] + (parts[2] || '')),
                            multiplier: (((_parts_ = parts[2]) === null || _parts_ === void 0 ? void 0 : _parts_.length) || 0) - (parseInt(parts[3]) || 0)
                        };
                    }
                    ;
                    if (isNumber(schema.multipleOf)) {
                        let remainder = -1;
                        if (Number.isInteger(schema.multipleOf)) {
                            remainder = val % schema.multipleOf;
                        } else {
                            let normMultipleOf = normalizeFloats(schema.multipleOf);
                            let normValue = normalizeFloats(val);
                            if (normMultipleOf && normValue) {
                                const multiplier = 10 ** Math.abs(normValue.multiplier - normMultipleOf.multiplier);
                                if (normValue.multiplier < normMultipleOf.multiplier) {
                                    normValue.value *= multiplier;
                                } else {
                                    normMultipleOf.value *= multiplier;
                                }
                                remainder = normValue.value % normMultipleOf.value;
                            }
                        }
                        if (remainder !== 0) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: t('Value is not divisible by {0}.', schema.multipleOf)
                            });
                        }
                    }
                    function getExclusiveLimit(limit, exclusive) {
                        if (isNumber(exclusive)) {
                            return exclusive;
                        }
                        if (isBoolean(exclusive) && exclusive) {
                            return limit;
                        }
                        return undefined;
                    }
                    function getLimit(limit, exclusive) {
                        if (!isBoolean(exclusive) || !exclusive) {
                            return limit;
                        }
                        return undefined;
                    }
                    const exclusiveMinimum = getExclusiveLimit(schema.minimum, schema.exclusiveMinimum);
                    if (isNumber(exclusiveMinimum) && val <= exclusiveMinimum) {
                        validationResult.problems.push({
                            location: {
                                offset: node.offset,
                                length: node.length
                            },
                            message: t('Value is below the exclusive minimum of {0}.', exclusiveMinimum)
                        });
                    }
                    const exclusiveMaximum = getExclusiveLimit(schema.maximum, schema.exclusiveMaximum);
                    if (isNumber(exclusiveMaximum) && val >= exclusiveMaximum) {
                        validationResult.problems.push({
                            location: {
                                offset: node.offset,
                                length: node.length
                            },
                            message: t('Value is above the exclusive maximum of {0}.', exclusiveMaximum)
                        });
                    }
                    const minimum = getLimit(schema.minimum, schema.exclusiveMinimum);
                    if (isNumber(minimum) && val < minimum) {
                        validationResult.problems.push({
                            location: {
                                offset: node.offset,
                                length: node.length
                            },
                            message: t('Value is below the minimum of {0}.', minimum)
                        });
                    }
                    const maximum = getLimit(schema.maximum, schema.exclusiveMaximum);
                    if (isNumber(maximum) && val > maximum) {
                        validationResult.problems.push({
                            location: {
                                offset: node.offset,
                                length: node.length
                            },
                            message: t('Value is above the maximum of {0}.', maximum)
                        });
                    }
                }
                function _validateStringNode(node) {
                    if (isNumber(schema.minLength) && stringLength(node.value) < schema.minLength) {
                        validationResult.problems.push({
                            location: {
                                offset: node.offset,
                                length: node.length
                            },
                            message: t('String is shorter than the minimum length of {0}.', schema.minLength)
                        });
                    }
                    if (isNumber(schema.maxLength) && stringLength(node.value) > schema.maxLength) {
                        validationResult.problems.push({
                            location: {
                                offset: node.offset,
                                length: node.length
                            },
                            message: t('String is longer than the maximum length of {0}.', schema.maxLength)
                        });
                    }
                    if (isString(schema.pattern)) {
                        var _regex;
                        const regex = extendedRegExp(schema.pattern);
                        if (!((_regex = regex) === null || _regex === void 0 ? void 0 : _regex.test(node.value))) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: schema.patternErrorMessage || schema.errorMessage || t('String does not match the pattern of "{0}".', schema.pattern)
                            });
                        }
                    }
                    if (schema.format) {
                        switch(schema.format){
                            case 'uri':
                            case 'uri-reference':
                                {
                                    let errorMessage;
                                    if (!node.value) {
                                        errorMessage = t('URI expected.');
                                    } else {
                                        const match = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/.exec(node.value);
                                        if (!match) {
                                            errorMessage = t('URI is expected.');
                                        } else if (!match[2] && schema.format === 'uri') {
                                            errorMessage = t('URI with a scheme is expected.');
                                        }
                                    }
                                    if (errorMessage) {
                                        validationResult.problems.push({
                                            location: {
                                                offset: node.offset,
                                                length: node.length
                                            },
                                            message: schema.patternErrorMessage || schema.errorMessage || t('String is not a URI: {0}', errorMessage)
                                        });
                                    }
                                }
                                break;
                            case 'color-hex':
                            case 'date-time':
                            case 'date':
                            case 'time':
                            case 'email':
                            case 'hostname':
                            case 'ipv4':
                            case 'ipv6':
                                const format1 = formats[schema.format];
                                if (!node.value || !format1.pattern.exec(node.value)) {
                                    validationResult.problems.push({
                                        location: {
                                            offset: node.offset,
                                            length: node.length
                                        },
                                        message: schema.patternErrorMessage || schema.errorMessage || format1.errorMessage
                                    });
                                }
                            default:
                        }
                    }
                }
                function _validateArrayNode(node) {
                    let prefixItemsSchemas;
                    let additionalItemSchema;
                    if (context.schemaDraft >= SchemaDraft.v2020_12) {
                        prefixItemsSchemas = schema.prefixItems;
                        additionalItemSchema = !Array.isArray(schema.items) ? schema.items : undefined;
                    } else {
                        prefixItemsSchemas = Array.isArray(schema.items) ? schema.items : undefined;
                        additionalItemSchema = !Array.isArray(schema.items) ? schema.items : schema.additionalItems;
                    }
                    let index = 0;
                    if (prefixItemsSchemas !== undefined) {
                        const max = Math.min(prefixItemsSchemas.length, node.items.length);
                        for(; index < max; index++){
                            const subSchemaRef = prefixItemsSchemas[index];
                            const subSchema = asSchema(subSchemaRef);
                            const itemValidationResult = new ValidationResult();
                            const item = node.items[index];
                            if (item) {
                                validate(item, subSchema, itemValidationResult, matchingSchemas, context);
                                validationResult.mergePropertyMatch(itemValidationResult);
                            }
                            validationResult.processedProperties.add(String(index));
                        }
                    }
                    if (additionalItemSchema !== undefined && index < node.items.length) {
                        if (typeof additionalItemSchema === 'boolean') {
                            if (additionalItemSchema === false) {
                                validationResult.problems.push({
                                    location: {
                                        offset: node.offset,
                                        length: node.length
                                    },
                                    message: t('Array has too many items according to schema. Expected {0} or fewer.', index)
                                });
                            }
                            for(; index < node.items.length; index++){
                                validationResult.processedProperties.add(String(index));
                                validationResult.propertiesValueMatches++;
                            }
                        } else {
                            for(; index < node.items.length; index++){
                                const itemValidationResult = new ValidationResult();
                                validate(node.items[index], additionalItemSchema, itemValidationResult, matchingSchemas, context);
                                validationResult.mergePropertyMatch(itemValidationResult);
                                validationResult.processedProperties.add(String(index));
                            }
                        }
                    }
                    const containsSchema = asSchema(schema.contains);
                    if (containsSchema) {
                        let containsCount = 0;
                        for(let index = 0; index < node.items.length; index++){
                            const item = node.items[index];
                            const itemValidationResult = new ValidationResult();
                            validate(item, containsSchema, itemValidationResult, NoOpSchemaCollector.instance, context);
                            if (!itemValidationResult.hasProblems()) {
                                containsCount++;
                                if (context.schemaDraft >= SchemaDraft.v2020_12) {
                                    validationResult.processedProperties.add(String(index));
                                }
                            }
                        }
                        if (containsCount === 0 && !isNumber(schema.minContains)) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: schema.errorMessage || t('Array does not contain required item.')
                            });
                        }
                        if (isNumber(schema.minContains) && containsCount < schema.minContains) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: t('Array has too few items that match the contains contraint. Expected {0} or more.', schema.minContains)
                            });
                        }
                        if (isNumber(schema.maxContains) && containsCount > schema.maxContains) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: t('Array has too many items that match the contains contraint. Expected {0} or less.', schema.maxContains)
                            });
                        }
                    }
                    const unevaluatedItems = schema.unevaluatedItems;
                    if (unevaluatedItems !== undefined) {
                        for(let i = 0; i < node.items.length; i++){
                            if (!validationResult.processedProperties.has(String(i))) {
                                if (unevaluatedItems === false) {
                                    validationResult.problems.push({
                                        location: {
                                            offset: node.offset,
                                            length: node.length
                                        },
                                        message: t('Item does not match any validation rule from the array.')
                                    });
                                } else {
                                    const itemValidationResult = new ValidationResult();
                                    validate(node.items[i], schema.unevaluatedItems, itemValidationResult, matchingSchemas, context);
                                    validationResult.mergePropertyMatch(itemValidationResult);
                                }
                            }
                            validationResult.processedProperties.add(String(i));
                            validationResult.propertiesValueMatches++;
                        }
                    }
                    if (isNumber(schema.minItems) && node.items.length < schema.minItems) {
                        validationResult.problems.push({
                            location: {
                                offset: node.offset,
                                length: node.length
                            },
                            message: t('Array has too few items. Expected {0} or more.', schema.minItems)
                        });
                    }
                    if (isNumber(schema.maxItems) && node.items.length > schema.maxItems) {
                        validationResult.problems.push({
                            location: {
                                offset: node.offset,
                                length: node.length
                            },
                            message: t('Array has too many items. Expected {0} or fewer.', schema.maxItems)
                        });
                    }
                    if (schema.uniqueItems === true) {
                        const values = jsonParser_getNodeValue(node);
                        const duplicates = values.some((value, index)=>{
                            return index !== values.lastIndexOf(value);
                        });
                        if (duplicates) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: t('Array has duplicate items.')
                            });
                        }
                    }
                }
                function _validateObjectNode(node) {
                    const seenKeys = Object.create(null);
                    const unprocessedProperties = new Set();
                    for (const propertyNode of node.properties){
                        const key = propertyNode.keyNode.value;
                        seenKeys[key] = propertyNode.valueNode;
                        unprocessedProperties.add(key);
                    }
                    if (Array.isArray(schema.required)) {
                        for (const propertyName of schema.required){
                            if (!seenKeys[propertyName]) {
                                const keyNode = node.parent && node.parent.type === 'property' && node.parent.keyNode;
                                const location = keyNode ? {
                                    offset: keyNode.offset,
                                    length: keyNode.length
                                } : {
                                    offset: node.offset,
                                    length: 1
                                };
                                validationResult.problems.push({
                                    location: location,
                                    message: t('Missing property "{0}".', propertyName)
                                });
                            }
                        }
                    }
                    const propertyProcessed = (prop)=>{
                        unprocessedProperties.delete(prop);
                        validationResult.processedProperties.add(prop);
                    };
                    if (schema.properties) {
                        for (const propertyName of Object.keys(schema.properties)){
                            propertyProcessed(propertyName);
                            const propertySchema = schema.properties[propertyName];
                            const child = seenKeys[propertyName];
                            if (child) {
                                if (isBoolean(propertySchema)) {
                                    if (!propertySchema) {
                                        const propertyNode = child.parent;
                                        validationResult.problems.push({
                                            location: {
                                                offset: propertyNode.keyNode.offset,
                                                length: propertyNode.keyNode.length
                                            },
                                            message: schema.errorMessage || t('Property {0} is not allowed.', propertyName)
                                        });
                                    } else {
                                        validationResult.propertiesMatches++;
                                        validationResult.propertiesValueMatches++;
                                    }
                                } else {
                                    const propertyValidationResult = new ValidationResult();
                                    validate(child, propertySchema, propertyValidationResult, matchingSchemas, context);
                                    validationResult.mergePropertyMatch(propertyValidationResult);
                                }
                            }
                        }
                    }
                    if (schema.patternProperties) {
                        for (const propertyPattern of Object.keys(schema.patternProperties)){
                            const regex = extendedRegExp(propertyPattern);
                            if (regex) {
                                const processed = [];
                                for (const propertyName of unprocessedProperties){
                                    if (regex.test(propertyName)) {
                                        processed.push(propertyName);
                                        const child = seenKeys[propertyName];
                                        if (child) {
                                            const propertySchema = schema.patternProperties[propertyPattern];
                                            if (isBoolean(propertySchema)) {
                                                if (!propertySchema) {
                                                    const propertyNode = child.parent;
                                                    validationResult.problems.push({
                                                        location: {
                                                            offset: propertyNode.keyNode.offset,
                                                            length: propertyNode.keyNode.length
                                                        },
                                                        message: schema.errorMessage || t('Property {0} is not allowed.', propertyName)
                                                    });
                                                } else {
                                                    validationResult.propertiesMatches++;
                                                    validationResult.propertiesValueMatches++;
                                                }
                                            } else {
                                                const propertyValidationResult = new ValidationResult();
                                                validate(child, propertySchema, propertyValidationResult, matchingSchemas, context);
                                                validationResult.mergePropertyMatch(propertyValidationResult);
                                            }
                                        }
                                    }
                                }
                                processed.forEach(propertyProcessed);
                            }
                        }
                    }
                    const additionalProperties = schema.additionalProperties;
                    if (additionalProperties !== undefined) {
                        for (const propertyName of unprocessedProperties){
                            propertyProcessed(propertyName);
                            const child = seenKeys[propertyName];
                            if (child) {
                                if (additionalProperties === false) {
                                    const propertyNode = child.parent;
                                    validationResult.problems.push({
                                        location: {
                                            offset: propertyNode.keyNode.offset,
                                            length: propertyNode.keyNode.length
                                        },
                                        message: schema.errorMessage || t('Property {0} is not allowed.', propertyName)
                                    });
                                } else if (additionalProperties !== true) {
                                    const propertyValidationResult = new ValidationResult();
                                    validate(child, additionalProperties, propertyValidationResult, matchingSchemas, context);
                                    validationResult.mergePropertyMatch(propertyValidationResult);
                                }
                            }
                        }
                    }
                    const unevaluatedProperties = schema.unevaluatedProperties;
                    if (unevaluatedProperties !== undefined) {
                        const processed = [];
                        for (const propertyName of unprocessedProperties){
                            if (!validationResult.processedProperties.has(propertyName)) {
                                processed.push(propertyName);
                                const child = seenKeys[propertyName];
                                if (child) {
                                    if (unevaluatedProperties === false) {
                                        const propertyNode = child.parent;
                                        validationResult.problems.push({
                                            location: {
                                                offset: propertyNode.keyNode.offset,
                                                length: propertyNode.keyNode.length
                                            },
                                            message: schema.errorMessage || t('Property {0} is not allowed.', propertyName)
                                        });
                                    } else if (unevaluatedProperties !== true) {
                                        const propertyValidationResult = new ValidationResult();
                                        validate(child, unevaluatedProperties, propertyValidationResult, matchingSchemas, context);
                                        validationResult.mergePropertyMatch(propertyValidationResult);
                                    }
                                }
                            }
                        }
                        processed.forEach(propertyProcessed);
                    }
                    if (isNumber(schema.maxProperties)) {
                        if (node.properties.length > schema.maxProperties) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: t('Object has more properties than limit of {0}.', schema.maxProperties)
                            });
                        }
                    }
                    if (isNumber(schema.minProperties)) {
                        if (node.properties.length < schema.minProperties) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: t('Object has fewer properties than the required number of {0}', schema.minProperties)
                            });
                        }
                    }
                    if (schema.dependentRequired) {
                        for(const key in schema.dependentRequired){
                            const prop = seenKeys[key];
                            const propertyDeps = schema.dependentRequired[key];
                            if (prop && Array.isArray(propertyDeps)) {
                                _validatePropertyDependencies(key, propertyDeps);
                            }
                        }
                    }
                    if (schema.dependentSchemas) {
                        for(const key in schema.dependentSchemas){
                            const prop = seenKeys[key];
                            const propertyDeps = schema.dependentSchemas[key];
                            if (prop && isObject(propertyDeps)) {
                                _validatePropertyDependencies(key, propertyDeps);
                            }
                        }
                    }
                    if (schema.dependencies) {
                        for(const key in schema.dependencies){
                            const prop = seenKeys[key];
                            if (prop) {
                                _validatePropertyDependencies(key, schema.dependencies[key]);
                            }
                        }
                    }
                    const propertyNames = asSchema(schema.propertyNames);
                    if (propertyNames) {
                        for (const f of node.properties){
                            const key = f.keyNode;
                            if (key) {
                                validate(key, propertyNames, validationResult, NoOpSchemaCollector.instance, context);
                            }
                        }
                    }
                    function _validatePropertyDependencies(key, propertyDep) {
                        if (Array.isArray(propertyDep)) {
                            for (const requiredProp of propertyDep){
                                if (!seenKeys[requiredProp]) {
                                    validationResult.problems.push({
                                        location: {
                                            offset: node.offset,
                                            length: node.length
                                        },
                                        message: t('Object is missing property {0} required by property {1}.', requiredProp, key)
                                    });
                                } else {
                                    validationResult.propertiesValueMatches++;
                                }
                            }
                        } else {
                            const propertySchema = asSchema(propertyDep);
                            if (propertySchema) {
                                const propertyValidationResult = new ValidationResult();
                                validate(node, propertySchema, propertyValidationResult, matchingSchemas, context);
                                validationResult.mergePropertyMatch(propertyValidationResult);
                            }
                        }
                    }
                }
            }
            function jsonParser_parse(textDocument, config) {
                const problems = [];
                let lastProblemOffset = -1;
                const text = textDocument.getText();
                const scanner = main_createScanner(text, false);
                const commentRanges = config && config.collectComments ? [] : undefined;
                function _scanNext() {
                    while(true){
                        const token = scanner.scan();
                        _checkScanError();
                        switch(token){
                            case 12 /* Json.SyntaxKind.LineCommentTrivia */ :
                            case 13 /* Json.SyntaxKind.BlockCommentTrivia */ :
                                if (Array.isArray(commentRanges)) {
                                    commentRanges.push(main.Range.create(textDocument.positionAt(scanner.getTokenOffset()), textDocument.positionAt(scanner.getTokenOffset() + scanner.getTokenLength())));
                                }
                                break;
                            case 15 /* Json.SyntaxKind.Trivia */ :
                            case 14 /* Json.SyntaxKind.LineBreakTrivia */ :
                                break;
                            default:
                                return token;
                        }
                    }
                }
                function _accept(token) {
                    if (scanner.getToken() === token) {
                        _scanNext();
                        return true;
                    }
                    return false;
                }
                function _errorAtRange(message, code, startOffset, endOffset, severity = main.DiagnosticSeverity.Error) {
                    if (problems.length === 0 || startOffset !== lastProblemOffset) {
                        const range = main.Range.create(textDocument.positionAt(startOffset), textDocument.positionAt(endOffset));
                        problems.push(main.Diagnostic.create(range, message, severity, code, textDocument.languageId));
                        lastProblemOffset = startOffset;
                    }
                }
                function _error(message, code, node = undefined, skipUntilAfter = [], skipUntil = []) {
                    let start = scanner.getTokenOffset();
                    let end = scanner.getTokenOffset() + scanner.getTokenLength();
                    if (start === end && start > 0) {
                        start--;
                        while(start > 0 && /\s/.test(text.charAt(start))){
                            start--;
                        }
                        end = start + 1;
                    }
                    _errorAtRange(message, code, start, end);
                    if (node) {
                        _finalize(node, false);
                    }
                    if (skipUntilAfter.length + skipUntil.length > 0) {
                        let token = scanner.getToken();
                        while(token !== 17 /* Json.SyntaxKind.EOF */ ){
                            if (skipUntilAfter.indexOf(token) !== -1) {
                                _scanNext();
                                break;
                            } else if (skipUntil.indexOf(token) !== -1) {
                                break;
                            }
                            token = _scanNext();
                        }
                    }
                    return node;
                }
                function _checkScanError() {
                    switch(scanner.getTokenError()){
                        case 4 /* Json.ScanError.InvalidUnicode */ :
                            _error(t('Invalid unicode sequence in string.'), ErrorCode.InvalidUnicode);
                            return true;
                        case 5 /* Json.ScanError.InvalidEscapeCharacter */ :
                            _error(t('Invalid escape character in string.'), ErrorCode.InvalidEscapeCharacter);
                            return true;
                        case 3 /* Json.ScanError.UnexpectedEndOfNumber */ :
                            _error(t('Unexpected end of number.'), ErrorCode.UnexpectedEndOfNumber);
                            return true;
                        case 1 /* Json.ScanError.UnexpectedEndOfComment */ :
                            _error(t('Unexpected end of comment.'), ErrorCode.UnexpectedEndOfComment);
                            return true;
                        case 2 /* Json.ScanError.UnexpectedEndOfString */ :
                            _error(t('Unexpected end of string.'), ErrorCode.UnexpectedEndOfString);
                            return true;
                        case 6 /* Json.ScanError.InvalidCharacter */ :
                            _error(t('Invalid characters in string. Control characters must be escaped.'), ErrorCode.InvalidCharacter);
                            return true;
                    }
                    return false;
                }
                function _finalize(node, scanNext) {
                    node.length = scanner.getTokenOffset() + scanner.getTokenLength() - node.offset;
                    if (scanNext) {
                        _scanNext();
                    }
                    return node;
                }
                function _parseArray(parent) {
                    if (scanner.getToken() !== 3 /* Json.SyntaxKind.OpenBracketToken */ ) {
                        return undefined;
                    }
                    const node = new ArrayASTNodeImpl(parent, scanner.getTokenOffset());
                    _scanNext(); // consume OpenBracketToken
                    const count = 0;
                    let needsComma = false;
                    while(scanner.getToken() !== 4 /* Json.SyntaxKind.CloseBracketToken */  && scanner.getToken() !== 17 /* Json.SyntaxKind.EOF */ ){
                        if (scanner.getToken() === 5 /* Json.SyntaxKind.CommaToken */ ) {
                            if (!needsComma) {
                                _error(t('Value expected'), ErrorCode.ValueExpected);
                            }
                            const commaOffset = scanner.getTokenOffset();
                            _scanNext(); // consume comma
                            if (scanner.getToken() === 4 /* Json.SyntaxKind.CloseBracketToken */ ) {
                                if (needsComma) {
                                    _errorAtRange(t('Trailing comma'), ErrorCode.TrailingComma, commaOffset, commaOffset + 1);
                                }
                                continue;
                            }
                        } else if (needsComma) {
                            _error(t('Expected comma'), ErrorCode.CommaExpected);
                        }
                        const item = _parseValue(node);
                        if (!item) {
                            _error(t('Value expected'), ErrorCode.ValueExpected, undefined, [], [
                                4 /* Json.SyntaxKind.CloseBracketToken */ ,
                                5 /* Json.SyntaxKind.CommaToken */ 
                            ]);
                        } else {
                            node.items.push(item);
                        }
                        needsComma = true;
                    }
                    if (scanner.getToken() !== 4 /* Json.SyntaxKind.CloseBracketToken */ ) {
                        return _error(t('Expected comma or closing bracket'), ErrorCode.CommaOrCloseBacketExpected, node);
                    }
                    return _finalize(node, true);
                }
                const keyPlaceholder = new StringASTNodeImpl(undefined, 0, 0);
                function _parseProperty(parent, keysSeen) {
                    const node = new PropertyASTNodeImpl(parent, scanner.getTokenOffset(), keyPlaceholder);
                    let key = _parseString(node);
                    if (!key) {
                        if (scanner.getToken() === 16 /* Json.SyntaxKind.Unknown */ ) {
                            // give a more helpful error message
                            _error(t('Property keys must be doublequoted'), ErrorCode.Undefined);
                            const keyNode = new StringASTNodeImpl(node, scanner.getTokenOffset(), scanner.getTokenLength());
                            keyNode.value = scanner.getTokenValue();
                            key = keyNode;
                            _scanNext(); // consume Unknown
                        } else {
                            return undefined;
                        }
                    }
                    node.keyNode = key;
                    // For JSON files that forbid code comments, there is a convention to use the key name "//" to add comments.
                    // Multiple instances of "//" are okay.
                    if (key.value !== "//") {
                        const seen = keysSeen[key.value];
                        if (seen) {
                            _errorAtRange(t("Duplicate object key"), ErrorCode.DuplicateKey, node.keyNode.offset, node.keyNode.offset + node.keyNode.length, main.DiagnosticSeverity.Warning);
                            if (isObject(seen)) {
                                _errorAtRange(t("Duplicate object key"), ErrorCode.DuplicateKey, seen.keyNode.offset, seen.keyNode.offset + seen.keyNode.length, main.DiagnosticSeverity.Warning);
                            }
                            keysSeen[key.value] = true; // if the same key is duplicate again, avoid duplicate error reporting
                        } else {
                            keysSeen[key.value] = node;
                        }
                    }
                    if (scanner.getToken() === 6 /* Json.SyntaxKind.ColonToken */ ) {
                        node.colonOffset = scanner.getTokenOffset();
                        _scanNext(); // consume ColonToken
                    } else {
                        _error(t('Colon expected'), ErrorCode.ColonExpected);
                        if (scanner.getToken() === 10 /* Json.SyntaxKind.StringLiteral */  && textDocument.positionAt(key.offset + key.length).line < textDocument.positionAt(scanner.getTokenOffset()).line) {
                            node.length = key.length;
                            return node;
                        }
                    }
                    const value = _parseValue(node);
                    if (!value) {
                        return _error(t('Value expected'), ErrorCode.ValueExpected, node, [], [
                            2 /* Json.SyntaxKind.CloseBraceToken */ ,
                            5 /* Json.SyntaxKind.CommaToken */ 
                        ]);
                    }
                    node.valueNode = value;
                    node.length = value.offset + value.length - node.offset;
                    return node;
                }
                function _parseObject(parent) {
                    if (scanner.getToken() !== 1 /* Json.SyntaxKind.OpenBraceToken */ ) {
                        return undefined;
                    }
                    const node = new ObjectASTNodeImpl(parent, scanner.getTokenOffset());
                    const keysSeen = Object.create(null);
                    _scanNext(); // consume OpenBraceToken
                    let needsComma = false;
                    while(scanner.getToken() !== 2 /* Json.SyntaxKind.CloseBraceToken */  && scanner.getToken() !== 17 /* Json.SyntaxKind.EOF */ ){
                        if (scanner.getToken() === 5 /* Json.SyntaxKind.CommaToken */ ) {
                            if (!needsComma) {
                                _error(t('Property expected'), ErrorCode.PropertyExpected);
                            }
                            const commaOffset = scanner.getTokenOffset();
                            _scanNext(); // consume comma
                            if (scanner.getToken() === 2 /* Json.SyntaxKind.CloseBraceToken */ ) {
                                if (needsComma) {
                                    _errorAtRange(t('Trailing comma'), ErrorCode.TrailingComma, commaOffset, commaOffset + 1);
                                }
                                continue;
                            }
                        } else if (needsComma) {
                            _error(t('Expected comma'), ErrorCode.CommaExpected);
                        }
                        const property = _parseProperty(node, keysSeen);
                        if (!property) {
                            _error(t('Property expected'), ErrorCode.PropertyExpected, undefined, [], [
                                2 /* Json.SyntaxKind.CloseBraceToken */ ,
                                5 /* Json.SyntaxKind.CommaToken */ 
                            ]);
                        } else {
                            node.properties.push(property);
                        }
                        needsComma = true;
                    }
                    if (scanner.getToken() !== 2 /* Json.SyntaxKind.CloseBraceToken */ ) {
                        return _error(t('Expected comma or closing brace'), ErrorCode.CommaOrCloseBraceExpected, node);
                    }
                    return _finalize(node, true);
                }
                function _parseString(parent) {
                    if (scanner.getToken() !== 10 /* Json.SyntaxKind.StringLiteral */ ) {
                        return undefined;
                    }
                    const node = new StringASTNodeImpl(parent, scanner.getTokenOffset());
                    node.value = scanner.getTokenValue();
                    return _finalize(node, true);
                }
                function _parseNumber(parent) {
                    if (scanner.getToken() !== 11 /* Json.SyntaxKind.NumericLiteral */ ) {
                        return undefined;
                    }
                    const node = new NumberASTNodeImpl(parent, scanner.getTokenOffset());
                    if (scanner.getTokenError() === 0 /* Json.ScanError.None */ ) {
                        const tokenValue = scanner.getTokenValue();
                        try {
                            const numberValue = JSON.parse(tokenValue);
                            if (!isNumber(numberValue)) {
                                return _error(t('Invalid number format.'), ErrorCode.Undefined, node);
                            }
                            node.value = numberValue;
                        } catch (e) {
                            return _error(t('Invalid number format.'), ErrorCode.Undefined, node);
                        }
                        node.isInteger = tokenValue.indexOf('.') === -1;
                    }
                    return _finalize(node, true);
                }
                function _parseLiteral(parent) {
                    let node;
                    switch(scanner.getToken()){
                        case 7 /* Json.SyntaxKind.NullKeyword */ :
                            return _finalize(new NullASTNodeImpl(parent, scanner.getTokenOffset()), true);
                        case 8 /* Json.SyntaxKind.TrueKeyword */ :
                            return _finalize(new BooleanASTNodeImpl(parent, true, scanner.getTokenOffset()), true);
                        case 9 /* Json.SyntaxKind.FalseKeyword */ :
                            return _finalize(new BooleanASTNodeImpl(parent, false, scanner.getTokenOffset()), true);
                        default:
                            return undefined;
                    }
                }
                function _parseValue(parent) {
                    return _parseArray(parent) || _parseObject(parent) || _parseString(parent) || _parseNumber(parent) || _parseLiteral(parent);
                }
                let _root = undefined;
                const token = _scanNext();
                if (token !== 17 /* Json.SyntaxKind.EOF */ ) {
                    _root = _parseValue(_root);
                    if (!_root) {
                        _error(t('Expected a JSON object, array or literal.'), ErrorCode.Undefined);
                    } else if (scanner.getToken() !== 17 /* Json.SyntaxKind.EOF */ ) {
                        _error(t('End of file expected.'), ErrorCode.Undefined);
                    }
                }
                return new JSONDocument(_root, problems, commentRanges);
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/utils/json.js
            /*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/ function stringifyObject(obj, indent, stringifyLiteral) {
                if (obj !== null && typeof obj === 'object') {
                    const newIndent = indent + '\t';
                    if (Array.isArray(obj)) {
                        if (obj.length === 0) {
                            return '[]';
                        }
                        let result = '[\n';
                        for(let i = 0; i < obj.length; i++){
                            result += newIndent + stringifyObject(obj[i], newIndent, stringifyLiteral);
                            if (i < obj.length - 1) {
                                result += ',';
                            }
                            result += '\n';
                        }
                        result += indent + ']';
                        return result;
                    } else {
                        const keys = Object.keys(obj);
                        if (keys.length === 0) {
                            return '{}';
                        }
                        let result = '{\n';
                        for(let i = 0; i < keys.length; i++){
                            const key = keys[i];
                            result += newIndent + JSON.stringify(key) + ': ' + stringifyObject(obj[key], newIndent, stringifyLiteral);
                            if (i < keys.length - 1) {
                                result += ',';
                            }
                            result += '\n';
                        }
                        result += indent + '}';
                        return result;
                    }
                }
                return stringifyLiteral(obj);
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/services/jsonCompletion.js
            /* provided dependency */ var console = __nested_webpack_require_701519__(3716);
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ const valueCommitCharacters = [
                ',',
                '}',
                ']'
            ];
            const propertyCommitCharacters = [
                ':'
            ];
            class JSONCompletion {
                doResolve(item) {
                    for(let i = this.contributions.length - 1; i >= 0; i--){
                        const resolveCompletion = this.contributions[i].resolveCompletion;
                        if (resolveCompletion) {
                            const resolver = resolveCompletion(item);
                            if (resolver) {
                                return resolver;
                            }
                        }
                    }
                    return this.promiseConstructor.resolve(item);
                }
                doComplete(document1, position, doc) {
                    const result = {
                        items: [],
                        isIncomplete: false
                    };
                    const text = document1.getText();
                    const offset = document1.offsetAt(position);
                    let node = doc.getNodeFromOffset(offset, true);
                    if (this.isInComment(document1, node ? node.offset : 0, offset)) {
                        return Promise.resolve(result);
                    }
                    if (node && offset === node.offset + node.length && offset > 0) {
                        const ch = text[offset - 1];
                        if (node.type === 'object' && ch === '}' || node.type === 'array' && ch === ']') {
                            // after ] or }
                            node = node.parent;
                        }
                    }
                    const currentWord = this.getCurrentWord(document1, offset);
                    let overwriteRange;
                    if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {
                        overwriteRange = main.Range.create(document1.positionAt(node.offset), document1.positionAt(node.offset + node.length));
                    } else {
                        let overwriteStart = offset - currentWord.length;
                        if (overwriteStart > 0 && text[overwriteStart - 1] === '"') {
                            overwriteStart--;
                        }
                        overwriteRange = main.Range.create(document1.positionAt(overwriteStart), position);
                    }
                    const supportsCommitCharacters = false; //this.doesSupportsCommitCharacters(); disabled for now, waiting for new API: https://github.com/microsoft/vscode/issues/42544
                    const proposed = new Map();
                    const collector = {
                        add: (suggestion)=>{
                            let label = suggestion.label;
                            const existing = proposed.get(label);
                            if (!existing) {
                                label = label.replace(/[\n]/g, '↵');
                                if (label.length > 60) {
                                    const shortendedLabel = label.substr(0, 57).trim() + '...';
                                    if (!proposed.has(shortendedLabel)) {
                                        label = shortendedLabel;
                                    }
                                }
                                suggestion.textEdit = main.TextEdit.replace(overwriteRange, suggestion.insertText);
                                if (supportsCommitCharacters) {
                                    suggestion.commitCharacters = suggestion.kind === main.CompletionItemKind.Property ? propertyCommitCharacters : valueCommitCharacters;
                                }
                                suggestion.label = label;
                                proposed.set(label, suggestion);
                                result.items.push(suggestion);
                            } else {
                                if (!existing.documentation) {
                                    existing.documentation = suggestion.documentation;
                                }
                                if (!existing.detail) {
                                    existing.detail = suggestion.detail;
                                }
                                if (!existing.labelDetails) {
                                    existing.labelDetails = suggestion.labelDetails;
                                }
                            }
                        },
                        setAsIncomplete: ()=>{
                            result.isIncomplete = true;
                        },
                        error: (message)=>{
                            console.error(message);
                        },
                        getNumberOfProposals: ()=>{
                            return result.items.length;
                        }
                    };
                    return this.schemaService.getSchemaForResource(document1.uri, doc).then((schema)=>{
                        const collectionPromises = [];
                        let addValue = true;
                        let currentKey = '';
                        let currentProperty = undefined;
                        if (node) {
                            if (node.type === 'string') {
                                const parent = node.parent;
                                if (parent && parent.type === 'property' && parent.keyNode === node) {
                                    addValue = !parent.valueNode;
                                    currentProperty = parent;
                                    currentKey = text.substr(node.offset + 1, node.length - 2);
                                    if (parent) {
                                        node = parent.parent;
                                    }
                                }
                            }
                        }
                        // proposals for properties
                        if (node && node.type === 'object') {
                            // don't suggest keys when the cursor is just before the opening curly brace
                            if (node.offset === offset) {
                                return result;
                            }
                            // don't suggest properties that are already present
                            const properties = node.properties;
                            properties.forEach((p)=>{
                                if (!currentProperty || currentProperty !== p) {
                                    proposed.set(p.keyNode.value, main.CompletionItem.create('__'));
                                }
                            });
                            let separatorAfter = '';
                            if (addValue) {
                                separatorAfter = this.evaluateSeparatorAfter(document1, document1.offsetAt(overwriteRange.end));
                            }
                            if (schema) {
                                // property proposals with schema
                                this.getPropertyCompletions(schema, doc, node, addValue, separatorAfter, collector);
                            } else {
                                // property proposals without schema
                                this.getSchemaLessPropertyCompletions(doc, node, currentKey, collector);
                            }
                            const location = jsonParser_getNodePath(node);
                            this.contributions.forEach((contribution)=>{
                                const collectPromise = contribution.collectPropertyCompletions(document1.uri, location, currentWord, addValue, separatorAfter === '', collector);
                                if (collectPromise) {
                                    collectionPromises.push(collectPromise);
                                }
                            });
                            if (!schema && currentWord.length > 0 && text.charAt(offset - currentWord.length - 1) !== '"') {
                                collector.add({
                                    kind: main.CompletionItemKind.Property,
                                    label: this.getLabelForValue(currentWord),
                                    insertText: this.getInsertTextForProperty(currentWord, undefined, false, separatorAfter),
                                    insertTextFormat: main.InsertTextFormat.Snippet,
                                    documentation: ''
                                });
                                collector.setAsIncomplete();
                            }
                        }
                        // proposals for values
                        const types = {};
                        if (schema) {
                            // value proposals with schema
                            this.getValueCompletions(schema, doc, node, offset, document1, collector, types);
                        } else {
                            // value proposals without schema
                            this.getSchemaLessValueCompletions(doc, node, offset, document1, collector);
                        }
                        if (this.contributions.length > 0) {
                            this.getContributedValueCompletions(doc, node, offset, document1, collector, collectionPromises);
                        }
                        return this.promiseConstructor.all(collectionPromises).then(()=>{
                            if (collector.getNumberOfProposals() === 0) {
                                let offsetForSeparator = offset;
                                if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {
                                    offsetForSeparator = node.offset + node.length;
                                }
                                const separatorAfter = this.evaluateSeparatorAfter(document1, offsetForSeparator);
                                this.addFillerValueCompletions(types, separatorAfter, collector);
                            }
                            return result;
                        });
                    });
                }
                getPropertyCompletions(schema, doc, node, addValue, separatorAfter, collector) {
                    const matchingSchemas = doc.getMatchingSchemas(schema.schema, node.offset);
                    matchingSchemas.forEach((s)=>{
                        if (s.node === node && !s.inverted) {
                            const schemaProperties = s.schema.properties;
                            if (schemaProperties) {
                                Object.keys(schemaProperties).forEach((key)=>{
                                    const propertySchema = schemaProperties[key];
                                    if (typeof propertySchema === 'object' && !propertySchema.deprecationMessage && !propertySchema.doNotSuggest) {
                                        const proposal = {
                                            kind: main.CompletionItemKind.Property,
                                            label: key,
                                            insertText: this.getInsertTextForProperty(key, propertySchema, addValue, separatorAfter),
                                            insertTextFormat: main.InsertTextFormat.Snippet,
                                            filterText: this.getFilterTextForValue(key),
                                            documentation: this.fromMarkup(propertySchema.markdownDescription) || propertySchema.description || ''
                                        };
                                        if (propertySchema.suggestSortText !== undefined) {
                                            proposal.sortText = propertySchema.suggestSortText;
                                        }
                                        if (proposal.insertText && endsWith(proposal.insertText, `$1${separatorAfter}`)) {
                                            proposal.command = {
                                                title: 'Suggest',
                                                command: 'editor.action.triggerSuggest'
                                            };
                                        }
                                        collector.add(proposal);
                                    }
                                });
                            }
                            const schemaPropertyNames = s.schema.propertyNames;
                            if (typeof schemaPropertyNames === 'object' && !schemaPropertyNames.deprecationMessage && !schemaPropertyNames.doNotSuggest) {
                                const propertyNameCompletionItem = (name, enumDescription = undefined)=>{
                                    const proposal = {
                                        kind: main.CompletionItemKind.Property,
                                        label: name,
                                        insertText: this.getInsertTextForProperty(name, undefined, addValue, separatorAfter),
                                        insertTextFormat: main.InsertTextFormat.Snippet,
                                        filterText: this.getFilterTextForValue(name),
                                        documentation: enumDescription || this.fromMarkup(schemaPropertyNames.markdownDescription) || schemaPropertyNames.description || ''
                                    };
                                    if (schemaPropertyNames.suggestSortText !== undefined) {
                                        proposal.sortText = schemaPropertyNames.suggestSortText;
                                    }
                                    if (proposal.insertText && endsWith(proposal.insertText, `$1${separatorAfter}`)) {
                                        proposal.command = {
                                            title: 'Suggest',
                                            command: 'editor.action.triggerSuggest'
                                        };
                                    }
                                    collector.add(proposal);
                                };
                                if (schemaPropertyNames.enum) {
                                    for(let i = 0; i < schemaPropertyNames.enum.length; i++){
                                        let enumDescription = undefined;
                                        if (schemaPropertyNames.markdownEnumDescriptions && i < schemaPropertyNames.markdownEnumDescriptions.length) {
                                            enumDescription = this.fromMarkup(schemaPropertyNames.markdownEnumDescriptions[i]);
                                        } else if (schemaPropertyNames.enumDescriptions && i < schemaPropertyNames.enumDescriptions.length) {
                                            enumDescription = schemaPropertyNames.enumDescriptions[i];
                                        }
                                        propertyNameCompletionItem(schemaPropertyNames.enum[i], enumDescription);
                                    }
                                }
                                if (schemaPropertyNames.const) {
                                    propertyNameCompletionItem(schemaPropertyNames.const);
                                }
                            }
                        }
                    });
                }
                getSchemaLessPropertyCompletions(doc, node, currentKey, collector) {
                    const collectCompletionsForSimilarObject = (obj)=>{
                        obj.properties.forEach((p)=>{
                            const key = p.keyNode.value;
                            collector.add({
                                kind: main.CompletionItemKind.Property,
                                label: key,
                                insertText: this.getInsertTextForValue(key, ''),
                                insertTextFormat: main.InsertTextFormat.Snippet,
                                filterText: this.getFilterTextForValue(key),
                                documentation: ''
                            });
                        });
                    };
                    if (node.parent) {
                        if (node.parent.type === 'property') {
                            // if the object is a property value, check the tree for other objects that hang under a property of the same name
                            const parentKey = node.parent.keyNode.value;
                            doc.visit((n)=>{
                                if (n.type === 'property' && n !== node.parent && n.keyNode.value === parentKey && n.valueNode && n.valueNode.type === 'object') {
                                    collectCompletionsForSimilarObject(n.valueNode);
                                }
                                return true;
                            });
                        } else if (node.parent.type === 'array') {
                            // if the object is in an array, use all other array elements as similar objects
                            node.parent.items.forEach((n)=>{
                                if (n.type === 'object' && n !== node) {
                                    collectCompletionsForSimilarObject(n);
                                }
                            });
                        }
                    } else if (node.type === 'object') {
                        collector.add({
                            kind: main.CompletionItemKind.Property,
                            label: '$schema',
                            insertText: this.getInsertTextForProperty('$schema', undefined, true, ''),
                            insertTextFormat: main.InsertTextFormat.Snippet,
                            documentation: '',
                            filterText: this.getFilterTextForValue("$schema")
                        });
                    }
                }
                getSchemaLessValueCompletions(doc, node, offset, document1, collector) {
                    let offsetForSeparator = offset;
                    if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {
                        offsetForSeparator = node.offset + node.length;
                        node = node.parent;
                    }
                    if (!node) {
                        collector.add({
                            kind: this.getSuggestionKind('object'),
                            label: 'Empty object',
                            insertText: this.getInsertTextForValue({}, ''),
                            insertTextFormat: main.InsertTextFormat.Snippet,
                            documentation: ''
                        });
                        collector.add({
                            kind: this.getSuggestionKind('array'),
                            label: 'Empty array',
                            insertText: this.getInsertTextForValue([], ''),
                            insertTextFormat: main.InsertTextFormat.Snippet,
                            documentation: ''
                        });
                        return;
                    }
                    const separatorAfter = this.evaluateSeparatorAfter(document1, offsetForSeparator);
                    const collectSuggestionsForValues = (value)=>{
                        if (value.parent && !jsonParser_contains(value.parent, offset, true)) {
                            collector.add({
                                kind: this.getSuggestionKind(value.type),
                                label: this.getLabelTextForMatchingNode(value, document1),
                                insertText: this.getInsertTextForMatchingNode(value, document1, separatorAfter),
                                insertTextFormat: main.InsertTextFormat.Snippet,
                                documentation: ''
                            });
                        }
                        if (value.type === 'boolean') {
                            this.addBooleanValueCompletion(!value.value, separatorAfter, collector);
                        }
                    };
                    if (node.type === 'property') {
                        if (offset > (node.colonOffset || 0)) {
                            const valueNode = node.valueNode;
                            if (valueNode && (offset > valueNode.offset + valueNode.length || valueNode.type === 'object' || valueNode.type === 'array')) {
                                return;
                            }
                            // suggest values at the same key
                            const parentKey = node.keyNode.value;
                            doc.visit((n)=>{
                                if (n.type === 'property' && n.keyNode.value === parentKey && n.valueNode) {
                                    collectSuggestionsForValues(n.valueNode);
                                }
                                return true;
                            });
                            if (parentKey === '$schema' && node.parent && !node.parent.parent) {
                                this.addDollarSchemaCompletions(separatorAfter, collector);
                            }
                        }
                    }
                    if (node.type === 'array') {
                        if (node.parent && node.parent.type === 'property') {
                            // suggest items of an array at the same key
                            const parentKey = node.parent.keyNode.value;
                            doc.visit((n)=>{
                                if (n.type === 'property' && n.keyNode.value === parentKey && n.valueNode && n.valueNode.type === 'array') {
                                    n.valueNode.items.forEach(collectSuggestionsForValues);
                                }
                                return true;
                            });
                        } else {
                            // suggest items in the same array
                            node.items.forEach(collectSuggestionsForValues);
                        }
                    }
                }
                getValueCompletions(schema, doc, node, offset, document1, collector, types) {
                    let offsetForSeparator = offset;
                    let parentKey = undefined;
                    let valueNode = undefined;
                    if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {
                        offsetForSeparator = node.offset + node.length;
                        valueNode = node;
                        node = node.parent;
                    }
                    if (!node) {
                        this.addSchemaValueCompletions(schema.schema, '', collector, types);
                        return;
                    }
                    if (node.type === 'property' && offset > (node.colonOffset || 0)) {
                        const valueNode = node.valueNode;
                        if (valueNode && offset > valueNode.offset + valueNode.length) {
                            return; // we are past the value node
                        }
                        parentKey = node.keyNode.value;
                        node = node.parent;
                    }
                    if (node && (parentKey !== undefined || node.type === 'array')) {
                        const separatorAfter = this.evaluateSeparatorAfter(document1, offsetForSeparator);
                        const matchingSchemas = doc.getMatchingSchemas(schema.schema, node.offset, valueNode);
                        for (const s of matchingSchemas){
                            if (s.node === node && !s.inverted && s.schema) {
                                if (node.type === 'array' && s.schema.items) {
                                    let c = collector;
                                    if (s.schema.uniqueItems) {
                                        const existingValues = new Set();
                                        node.children.forEach((n)=>{
                                            if (n.type !== 'array' && n.type !== 'object') {
                                                existingValues.add(this.getLabelForValue(jsonParser_getNodeValue(n)));
                                            }
                                        });
                                        c = {
                                            ...collector,
                                            add (suggestion) {
                                                if (!existingValues.has(suggestion.label)) {
                                                    collector.add(suggestion);
                                                }
                                            }
                                        };
                                    }
                                    if (Array.isArray(s.schema.items)) {
                                        const index = this.findItemAtOffset(node, document1, offset);
                                        if (index < s.schema.items.length) {
                                            this.addSchemaValueCompletions(s.schema.items[index], separatorAfter, c, types);
                                        }
                                    } else {
                                        this.addSchemaValueCompletions(s.schema.items, separatorAfter, c, types);
                                    }
                                }
                                if (parentKey !== undefined) {
                                    let propertyMatched = false;
                                    if (s.schema.properties) {
                                        const propertySchema = s.schema.properties[parentKey];
                                        if (propertySchema) {
                                            propertyMatched = true;
                                            this.addSchemaValueCompletions(propertySchema, separatorAfter, collector, types);
                                        }
                                    }
                                    if (s.schema.patternProperties && !propertyMatched) {
                                        for (const pattern of Object.keys(s.schema.patternProperties)){
                                            var _regex;
                                            const regex = extendedRegExp(pattern);
                                            if ((_regex = regex) === null || _regex === void 0 ? void 0 : _regex.test(parentKey)) {
                                                propertyMatched = true;
                                                const propertySchema = s.schema.patternProperties[pattern];
                                                this.addSchemaValueCompletions(propertySchema, separatorAfter, collector, types);
                                            }
                                        }
                                    }
                                    if (s.schema.additionalProperties && !propertyMatched) {
                                        const propertySchema = s.schema.additionalProperties;
                                        this.addSchemaValueCompletions(propertySchema, separatorAfter, collector, types);
                                    }
                                }
                            }
                        }
                        if (parentKey === '$schema' && !node.parent) {
                            this.addDollarSchemaCompletions(separatorAfter, collector);
                        }
                        if (types['boolean']) {
                            this.addBooleanValueCompletion(true, separatorAfter, collector);
                            this.addBooleanValueCompletion(false, separatorAfter, collector);
                        }
                        if (types['null']) {
                            this.addNullValueCompletion(separatorAfter, collector);
                        }
                    }
                }
                getContributedValueCompletions(doc, node, offset, document1, collector, collectionPromises) {
                    if (!node) {
                        this.contributions.forEach((contribution)=>{
                            const collectPromise = contribution.collectDefaultCompletions(document1.uri, collector);
                            if (collectPromise) {
                                collectionPromises.push(collectPromise);
                            }
                        });
                    } else {
                        if (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null') {
                            node = node.parent;
                        }
                        if (node && node.type === 'property' && offset > (node.colonOffset || 0)) {
                            const parentKey = node.keyNode.value;
                            const valueNode = node.valueNode;
                            if ((!valueNode || offset <= valueNode.offset + valueNode.length) && node.parent) {
                                const location = jsonParser_getNodePath(node.parent);
                                this.contributions.forEach((contribution)=>{
                                    const collectPromise = contribution.collectValueCompletions(document1.uri, location, parentKey, collector);
                                    if (collectPromise) {
                                        collectionPromises.push(collectPromise);
                                    }
                                });
                            }
                        }
                    }
                }
                addSchemaValueCompletions(schema, separatorAfter, collector, types) {
                    if (typeof schema === 'object') {
                        this.addEnumValueCompletions(schema, separatorAfter, collector);
                        this.addDefaultValueCompletions(schema, separatorAfter, collector);
                        this.collectTypes(schema, types);
                        if (Array.isArray(schema.allOf)) {
                            schema.allOf.forEach((s)=>this.addSchemaValueCompletions(s, separatorAfter, collector, types));
                        }
                        if (Array.isArray(schema.anyOf)) {
                            schema.anyOf.forEach((s)=>this.addSchemaValueCompletions(s, separatorAfter, collector, types));
                        }
                        if (Array.isArray(schema.oneOf)) {
                            schema.oneOf.forEach((s)=>this.addSchemaValueCompletions(s, separatorAfter, collector, types));
                        }
                    }
                }
                addDefaultValueCompletions(schema, separatorAfter, collector, arrayDepth = 0) {
                    let hasProposals = false;
                    if (isDefined(schema.default)) {
                        let type = schema.type;
                        let value = schema.default;
                        for(let i = arrayDepth; i > 0; i--){
                            value = [
                                value
                            ];
                            type = 'array';
                        }
                        const completionItem = {
                            kind: this.getSuggestionKind(type),
                            label: this.getLabelForValue(value),
                            insertText: this.getInsertTextForValue(value, separatorAfter),
                            insertTextFormat: main.InsertTextFormat.Snippet
                        };
                        if (this.doesSupportsLabelDetails()) {
                            completionItem.labelDetails = {
                                description: t('Default value')
                            };
                        } else {
                            completionItem.detail = t('Default value');
                        }
                        collector.add(completionItem);
                        hasProposals = true;
                    }
                    if (Array.isArray(schema.examples)) {
                        schema.examples.forEach((example)=>{
                            let type = schema.type;
                            let value = example;
                            for(let i = arrayDepth; i > 0; i--){
                                value = [
                                    value
                                ];
                                type = 'array';
                            }
                            collector.add({
                                kind: this.getSuggestionKind(type),
                                label: this.getLabelForValue(value),
                                insertText: this.getInsertTextForValue(value, separatorAfter),
                                insertTextFormat: main.InsertTextFormat.Snippet
                            });
                            hasProposals = true;
                        });
                    }
                    if (Array.isArray(schema.defaultSnippets)) {
                        schema.defaultSnippets.forEach((s)=>{
                            let type = schema.type;
                            let value = s.body;
                            let label = s.label;
                            let insertText;
                            let filterText;
                            if (isDefined(value)) {
                                let type = schema.type;
                                for(let i = arrayDepth; i > 0; i--){
                                    value = [
                                        value
                                    ];
                                    type = 'array';
                                }
                                insertText = this.getInsertTextForSnippetValue(value, separatorAfter);
                                filterText = this.getFilterTextForSnippetValue(value);
                                label = label || this.getLabelForSnippetValue(value);
                            } else if (typeof s.bodyText === 'string') {
                                let prefix = '', suffix = '', indent = '';
                                for(let i = arrayDepth; i > 0; i--){
                                    prefix = prefix + indent + '[\n';
                                    suffix = suffix + '\n' + indent + ']';
                                    indent += '\t';
                                    type = 'array';
                                }
                                insertText = prefix + indent + s.bodyText.split('\n').join('\n' + indent) + suffix + separatorAfter;
                                label = label || insertText, filterText = insertText.replace(/[\n]/g, ''); // remove new lines
                            } else {
                                return;
                            }
                            collector.add({
                                kind: this.getSuggestionKind(type),
                                label,
                                documentation: this.fromMarkup(s.markdownDescription) || s.description,
                                insertText,
                                insertTextFormat: main.InsertTextFormat.Snippet,
                                filterText
                            });
                            hasProposals = true;
                        });
                    }
                    if (!hasProposals && typeof schema.items === 'object' && !Array.isArray(schema.items) && arrayDepth < 5 /* beware of recursion */ ) {
                        this.addDefaultValueCompletions(schema.items, separatorAfter, collector, arrayDepth + 1);
                    }
                }
                addEnumValueCompletions(schema, separatorAfter, collector) {
                    if (isDefined(schema.const)) {
                        collector.add({
                            kind: this.getSuggestionKind(schema.type),
                            label: this.getLabelForValue(schema.const),
                            insertText: this.getInsertTextForValue(schema.const, separatorAfter),
                            insertTextFormat: main.InsertTextFormat.Snippet,
                            documentation: this.fromMarkup(schema.markdownDescription) || schema.description
                        });
                    }
                    if (Array.isArray(schema.enum)) {
                        for(let i = 0, length = schema.enum.length; i < length; i++){
                            const enm = schema.enum[i];
                            let documentation = this.fromMarkup(schema.markdownDescription) || schema.description;
                            if (schema.markdownEnumDescriptions && i < schema.markdownEnumDescriptions.length && this.doesSupportMarkdown()) {
                                documentation = this.fromMarkup(schema.markdownEnumDescriptions[i]);
                            } else if (schema.enumDescriptions && i < schema.enumDescriptions.length) {
                                documentation = schema.enumDescriptions[i];
                            }
                            collector.add({
                                kind: this.getSuggestionKind(schema.type),
                                label: this.getLabelForValue(enm),
                                insertText: this.getInsertTextForValue(enm, separatorAfter),
                                insertTextFormat: main.InsertTextFormat.Snippet,
                                documentation
                            });
                        }
                    }
                }
                collectTypes(schema, types) {
                    if (Array.isArray(schema.enum) || isDefined(schema.const)) {
                        return;
                    }
                    const type = schema.type;
                    if (Array.isArray(type)) {
                        type.forEach((t)=>types[t] = true);
                    } else if (type) {
                        types[type] = true;
                    }
                }
                addFillerValueCompletions(types, separatorAfter, collector) {
                    if (types['object']) {
                        collector.add({
                            kind: this.getSuggestionKind('object'),
                            label: '{}',
                            insertText: this.getInsertTextForGuessedValue({}, separatorAfter),
                            insertTextFormat: main.InsertTextFormat.Snippet,
                            detail: t('New object'),
                            documentation: ''
                        });
                    }
                    if (types['array']) {
                        collector.add({
                            kind: this.getSuggestionKind('array'),
                            label: '[]',
                            insertText: this.getInsertTextForGuessedValue([], separatorAfter),
                            insertTextFormat: main.InsertTextFormat.Snippet,
                            detail: t('New array'),
                            documentation: ''
                        });
                    }
                }
                addBooleanValueCompletion(value, separatorAfter, collector) {
                    collector.add({
                        kind: this.getSuggestionKind('boolean'),
                        label: value ? 'true' : 'false',
                        insertText: this.getInsertTextForValue(value, separatorAfter),
                        insertTextFormat: main.InsertTextFormat.Snippet,
                        documentation: ''
                    });
                }
                addNullValueCompletion(separatorAfter, collector) {
                    collector.add({
                        kind: this.getSuggestionKind('null'),
                        label: 'null',
                        insertText: 'null' + separatorAfter,
                        insertTextFormat: main.InsertTextFormat.Snippet,
                        documentation: ''
                    });
                }
                addDollarSchemaCompletions(separatorAfter, collector) {
                    const schemaIds = this.schemaService.getRegisteredSchemaIds((schema)=>schema === 'http' || schema === 'https');
                    schemaIds.forEach((schemaId)=>collector.add({
                            kind: main.CompletionItemKind.Module,
                            label: this.getLabelForValue(schemaId),
                            filterText: this.getFilterTextForValue(schemaId),
                            insertText: this.getInsertTextForValue(schemaId, separatorAfter),
                            insertTextFormat: main.InsertTextFormat.Snippet,
                            documentation: ''
                        }));
                }
                getLabelForValue(value) {
                    return JSON.stringify(value);
                }
                getValueFromLabel(value) {
                    return JSON.parse(value);
                }
                getFilterTextForValue(value) {
                    return JSON.stringify(value);
                }
                getFilterTextForSnippetValue(value) {
                    return JSON.stringify(value).replace(/\$\{\d+:([^}]+)\}|\$\d+/g, '$1');
                }
                getLabelForSnippetValue(value) {
                    const label = JSON.stringify(value);
                    return label.replace(/\$\{\d+:([^}]+)\}|\$\d+/g, '$1');
                }
                getInsertTextForPlainText(text) {
                    return text.replace(/[\\\$\}]/g, '\\$&'); // escape $, \ and }
                }
                getInsertTextForValue(value, separatorAfter) {
                    const text = JSON.stringify(value, null, '\t');
                    if (text === '{}') {
                        return '{$1}' + separatorAfter;
                    } else if (text === '[]') {
                        return '[$1]' + separatorAfter;
                    }
                    return this.getInsertTextForPlainText(text + separatorAfter);
                }
                getInsertTextForSnippetValue(value, separatorAfter) {
                    const replacer = (value)=>{
                        if (typeof value === 'string') {
                            if (value[0] === '^') {
                                return value.substr(1);
                            }
                        }
                        return JSON.stringify(value);
                    };
                    return stringifyObject(value, '', replacer) + separatorAfter;
                }
                getInsertTextForGuessedValue(value, separatorAfter) {
                    switch(typeof value){
                        case 'object':
                            if (value === null) {
                                return '${1:null}' + separatorAfter;
                            }
                            return this.getInsertTextForValue(value, separatorAfter);
                        case 'string':
                            let snippetValue = JSON.stringify(value);
                            snippetValue = snippetValue.substr(1, snippetValue.length - 2); // remove quotes
                            snippetValue = this.getInsertTextForPlainText(snippetValue); // escape \ and }
                            return '"${1:' + snippetValue + '}"' + separatorAfter;
                        case 'number':
                        case 'boolean':
                            return '${1:' + JSON.stringify(value) + '}' + separatorAfter;
                    }
                    return this.getInsertTextForValue(value, separatorAfter);
                }
                getSuggestionKind(type) {
                    if (Array.isArray(type)) {
                        const array = type;
                        type = array.length > 0 ? array[0] : undefined;
                    }
                    if (!type) {
                        return main.CompletionItemKind.Value;
                    }
                    switch(type){
                        case 'string':
                            return main.CompletionItemKind.Value;
                        case 'object':
                            return main.CompletionItemKind.Module;
                        case 'property':
                            return main.CompletionItemKind.Property;
                        default:
                            return main.CompletionItemKind.Value;
                    }
                }
                getLabelTextForMatchingNode(node, document1) {
                    switch(node.type){
                        case 'array':
                            return '[]';
                        case 'object':
                            return '{}';
                        default:
                            const content = document1.getText().substr(node.offset, node.length);
                            return content;
                    }
                }
                getInsertTextForMatchingNode(node, document1, separatorAfter) {
                    switch(node.type){
                        case 'array':
                            return this.getInsertTextForValue([], separatorAfter);
                        case 'object':
                            return this.getInsertTextForValue({}, separatorAfter);
                        default:
                            const content = document1.getText().substr(node.offset, node.length) + separatorAfter;
                            return this.getInsertTextForPlainText(content);
                    }
                }
                getInsertTextForProperty(key, propertySchema, addValue, separatorAfter) {
                    const propertyText = this.getInsertTextForValue(key, '');
                    if (!addValue) {
                        return propertyText;
                    }
                    const resultText = propertyText + ': ';
                    let value;
                    let nValueProposals = 0;
                    if (propertySchema) {
                        if (Array.isArray(propertySchema.defaultSnippets)) {
                            if (propertySchema.defaultSnippets.length === 1) {
                                const body = propertySchema.defaultSnippets[0].body;
                                if (isDefined(body)) {
                                    value = this.getInsertTextForSnippetValue(body, '');
                                }
                            }
                            nValueProposals += propertySchema.defaultSnippets.length;
                        }
                        if (propertySchema.enum) {
                            if (!value && propertySchema.enum.length === 1) {
                                value = this.getInsertTextForGuessedValue(propertySchema.enum[0], '');
                            }
                            nValueProposals += propertySchema.enum.length;
                        }
                        if (isDefined(propertySchema.const)) {
                            if (!value) {
                                value = this.getInsertTextForGuessedValue(propertySchema.const, '');
                            }
                            nValueProposals++;
                        }
                        if (isDefined(propertySchema.default)) {
                            if (!value) {
                                value = this.getInsertTextForGuessedValue(propertySchema.default, '');
                            }
                            nValueProposals++;
                        }
                        if (Array.isArray(propertySchema.examples) && propertySchema.examples.length) {
                            if (!value) {
                                value = this.getInsertTextForGuessedValue(propertySchema.examples[0], '');
                            }
                            nValueProposals += propertySchema.examples.length;
                        }
                        if (nValueProposals === 0) {
                            let type = Array.isArray(propertySchema.type) ? propertySchema.type[0] : propertySchema.type;
                            if (!type) {
                                if (propertySchema.properties) {
                                    type = 'object';
                                } else if (propertySchema.items) {
                                    type = 'array';
                                }
                            }
                            switch(type){
                                case 'boolean':
                                    value = '$1';
                                    break;
                                case 'string':
                                    value = '"$1"';
                                    break;
                                case 'object':
                                    value = '{$1}';
                                    break;
                                case 'array':
                                    value = '[$1]';
                                    break;
                                case 'number':
                                case 'integer':
                                    value = '${1:0}';
                                    break;
                                case 'null':
                                    value = '${1:null}';
                                    break;
                                default:
                                    return propertyText;
                            }
                        }
                    }
                    if (!value || nValueProposals > 1) {
                        value = '$1';
                    }
                    return resultText + value + separatorAfter;
                }
                getCurrentWord(document1, offset) {
                    let i = offset - 1;
                    const text = document1.getText();
                    while(i >= 0 && ' \t\n\r\v":{[,]}'.indexOf(text.charAt(i)) === -1){
                        i--;
                    }
                    return text.substring(i + 1, offset);
                }
                evaluateSeparatorAfter(document1, offset) {
                    const scanner = main_createScanner(document1.getText(), true);
                    scanner.setPosition(offset);
                    const token = scanner.scan();
                    switch(token){
                        case 5 /* Json.SyntaxKind.CommaToken */ :
                        case 2 /* Json.SyntaxKind.CloseBraceToken */ :
                        case 4 /* Json.SyntaxKind.CloseBracketToken */ :
                        case 17 /* Json.SyntaxKind.EOF */ :
                            return '';
                        default:
                            return ',';
                    }
                }
                findItemAtOffset(node, document1, offset) {
                    const scanner = main_createScanner(document1.getText(), true);
                    const children = node.items;
                    for(let i = children.length - 1; i >= 0; i--){
                        const child = children[i];
                        if (offset > child.offset + child.length) {
                            scanner.setPosition(child.offset + child.length);
                            const token = scanner.scan();
                            if (token === 5 /* Json.SyntaxKind.CommaToken */  && offset >= scanner.getTokenOffset() + scanner.getTokenLength()) {
                                return i + 1;
                            }
                            return i;
                        } else if (offset >= child.offset) {
                            return i;
                        }
                    }
                    return 0;
                }
                isInComment(document1, start, offset) {
                    const scanner = main_createScanner(document1.getText(), false);
                    scanner.setPosition(start);
                    let token = scanner.scan();
                    while(token !== 17 /* Json.SyntaxKind.EOF */  && scanner.getTokenOffset() + scanner.getTokenLength() < offset){
                        token = scanner.scan();
                    }
                    return (token === 12 /* Json.SyntaxKind.LineCommentTrivia */  || token === 13 /* Json.SyntaxKind.BlockCommentTrivia */ ) && scanner.getTokenOffset() <= offset;
                }
                fromMarkup(markupString) {
                    if (markupString && this.doesSupportMarkdown()) {
                        return {
                            kind: main.MarkupKind.Markdown,
                            value: markupString
                        };
                    }
                    return undefined;
                }
                doesSupportMarkdown() {
                    if (!isDefined(this.supportsMarkdown)) {
                        var _this_clientCapabilities_textDocument_completion_completionItem, _this_clientCapabilities_textDocument_completion, _this_clientCapabilities_textDocument;
                        const documentationFormat = (_this_clientCapabilities_textDocument = this.clientCapabilities.textDocument) === null || _this_clientCapabilities_textDocument === void 0 ? void 0 : (_this_clientCapabilities_textDocument_completion = _this_clientCapabilities_textDocument.completion) === null || _this_clientCapabilities_textDocument_completion === void 0 ? void 0 : (_this_clientCapabilities_textDocument_completion_completionItem = _this_clientCapabilities_textDocument_completion.completionItem) === null || _this_clientCapabilities_textDocument_completion_completionItem === void 0 ? void 0 : _this_clientCapabilities_textDocument_completion_completionItem.documentationFormat;
                        this.supportsMarkdown = Array.isArray(documentationFormat) && documentationFormat.indexOf(main.MarkupKind.Markdown) !== -1;
                    }
                    return this.supportsMarkdown;
                }
                doesSupportsCommitCharacters() {
                    if (!isDefined(this.supportsCommitCharacters)) {
                        var _this_clientCapabilities_textDocument_completion_completionItem, _this_clientCapabilities_textDocument_completion, _this_clientCapabilities_textDocument;
                        this.labelDetailsSupport = (_this_clientCapabilities_textDocument = this.clientCapabilities.textDocument) === null || _this_clientCapabilities_textDocument === void 0 ? void 0 : (_this_clientCapabilities_textDocument_completion = _this_clientCapabilities_textDocument.completion) === null || _this_clientCapabilities_textDocument_completion === void 0 ? void 0 : (_this_clientCapabilities_textDocument_completion_completionItem = _this_clientCapabilities_textDocument_completion.completionItem) === null || _this_clientCapabilities_textDocument_completion_completionItem === void 0 ? void 0 : _this_clientCapabilities_textDocument_completion_completionItem.commitCharactersSupport;
                    }
                    return this.supportsCommitCharacters;
                }
                doesSupportsLabelDetails() {
                    if (!isDefined(this.labelDetailsSupport)) {
                        var _this_clientCapabilities_textDocument_completion_completionItem, _this_clientCapabilities_textDocument_completion, _this_clientCapabilities_textDocument;
                        this.labelDetailsSupport = (_this_clientCapabilities_textDocument = this.clientCapabilities.textDocument) === null || _this_clientCapabilities_textDocument === void 0 ? void 0 : (_this_clientCapabilities_textDocument_completion = _this_clientCapabilities_textDocument.completion) === null || _this_clientCapabilities_textDocument_completion === void 0 ? void 0 : (_this_clientCapabilities_textDocument_completion_completionItem = _this_clientCapabilities_textDocument_completion.completionItem) === null || _this_clientCapabilities_textDocument_completion_completionItem === void 0 ? void 0 : _this_clientCapabilities_textDocument_completion_completionItem.labelDetailsSupport;
                    }
                    return this.labelDetailsSupport;
                }
                constructor(schemaService, contributions = [], promiseConstructor = Promise, clientCapabilities = {}){
                    this.schemaService = schemaService;
                    this.contributions = contributions;
                    this.promiseConstructor = promiseConstructor;
                    this.clientCapabilities = clientCapabilities;
                }
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/services/jsonHover.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ class JSONHover {
                doHover(document1, position, doc) {
                    const offset = document1.offsetAt(position);
                    let node = doc.getNodeFromOffset(offset);
                    if (!node || (node.type === 'object' || node.type === 'array') && offset > node.offset + 1 && offset < node.offset + node.length - 1) {
                        return this.promise.resolve(null);
                    }
                    const hoverRangeNode = node;
                    // use the property description when hovering over an object key
                    if (node.type === 'string') {
                        const parent = node.parent;
                        if (parent && parent.type === 'property' && parent.keyNode === node) {
                            node = parent.valueNode;
                            if (!node) {
                                return this.promise.resolve(null);
                            }
                        }
                    }
                    const hoverRange = main.Range.create(document1.positionAt(hoverRangeNode.offset), document1.positionAt(hoverRangeNode.offset + hoverRangeNode.length));
                    const createHover = (contents)=>{
                        const result = {
                            contents: contents,
                            range: hoverRange
                        };
                        return result;
                    };
                    const location = jsonParser_getNodePath(node);
                    for(let i = this.contributions.length - 1; i >= 0; i--){
                        const contribution = this.contributions[i];
                        const promise = contribution.getInfoContribution(document1.uri, location);
                        if (promise) {
                            return promise.then((htmlContent)=>createHover(htmlContent));
                        }
                    }
                    return this.schemaService.getSchemaForResource(document1.uri, doc).then((schema)=>{
                        if (schema && node) {
                            const matchingSchemas = doc.getMatchingSchemas(schema.schema, node.offset);
                            let title = undefined;
                            let markdownDescription = undefined;
                            let markdownEnumValueDescription = undefined, enumValue = undefined;
                            matchingSchemas.every((s)=>{
                                if (s.node === node && !s.inverted && s.schema) {
                                    title = title || s.schema.title;
                                    markdownDescription = markdownDescription || s.schema.markdownDescription || toMarkdown(s.schema.description);
                                    if (s.schema.enum) {
                                        const idx = s.schema.enum.indexOf(jsonParser_getNodeValue(node));
                                        if (s.schema.markdownEnumDescriptions) {
                                            markdownEnumValueDescription = s.schema.markdownEnumDescriptions[idx];
                                        } else if (s.schema.enumDescriptions) {
                                            markdownEnumValueDescription = toMarkdown(s.schema.enumDescriptions[idx]);
                                        }
                                        if (markdownEnumValueDescription) {
                                            enumValue = s.schema.enum[idx];
                                            if (typeof enumValue !== 'string') {
                                                enumValue = JSON.stringify(enumValue);
                                            }
                                        }
                                    }
                                }
                                return true;
                            });
                            let result = '';
                            if (title) {
                                result = toMarkdown(title);
                            }
                            if (markdownDescription) {
                                if (result.length > 0) {
                                    result += "\n\n";
                                }
                                result += markdownDescription;
                            }
                            if (markdownEnumValueDescription) {
                                if (result.length > 0) {
                                    result += "\n\n";
                                }
                                result += `\`${toMarkdownCodeBlock(enumValue)}\`: ${markdownEnumValueDescription}`;
                            }
                            return createHover([
                                result
                            ]);
                        }
                        return null;
                    });
                }
                constructor(schemaService, contributions = [], promiseConstructor){
                    this.schemaService = schemaService;
                    this.contributions = contributions;
                    this.promise = promiseConstructor || Promise;
                }
            }
            function toMarkdown(plain) {
                if (plain) {
                    const res = plain.replace(/([^\n\r])(\r?\n)([^\n\r])/gm, '$1\n\n$3'); // single new lines to \n\n (Markdown paragraph)
                    return res.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&"); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
                }
                return undefined;
            }
            function toMarkdownCodeBlock(content) {
                // see https://daringfireball.net/projects/markdown/syntax#precode
                if (content.indexOf('`') !== -1) {
                    return '`` ' + content + ' ``';
                }
                return content;
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/services/jsonValidation.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ class JSONValidation {
                configure(raw) {
                    if (raw) {
                        this.validationEnabled = raw.validate !== false;
                        this.commentSeverity = raw.allowComments ? undefined : main.DiagnosticSeverity.Error;
                    }
                }
                doValidation(textDocument, jsonDocument, documentSettings, schema) {
                    if (!this.validationEnabled) {
                        return this.promise.resolve([]);
                    }
                    const diagnostics = [];
                    const added = {};
                    const addProblem = (problem)=>{
                        // remove duplicated messages
                        const signature = problem.range.start.line + ' ' + problem.range.start.character + ' ' + problem.message;
                        if (!added[signature]) {
                            added[signature] = true;
                            diagnostics.push(problem);
                        }
                    };
                    const getDiagnostics = (schema)=>{
                        var _documentSettings, _documentSettings1, _documentSettings2, _documentSettings3;
                        let trailingCommaSeverity = ((_documentSettings = documentSettings) === null || _documentSettings === void 0 ? void 0 : _documentSettings.trailingCommas) ? toDiagnosticSeverity(documentSettings.trailingCommas) : main.DiagnosticSeverity.Error;
                        let commentSeverity = ((_documentSettings1 = documentSettings) === null || _documentSettings1 === void 0 ? void 0 : _documentSettings1.comments) ? toDiagnosticSeverity(documentSettings.comments) : this.commentSeverity;
                        let schemaValidation = ((_documentSettings2 = documentSettings) === null || _documentSettings2 === void 0 ? void 0 : _documentSettings2.schemaValidation) ? toDiagnosticSeverity(documentSettings.schemaValidation) : main.DiagnosticSeverity.Warning;
                        let schemaRequest = ((_documentSettings3 = documentSettings) === null || _documentSettings3 === void 0 ? void 0 : _documentSettings3.schemaRequest) ? toDiagnosticSeverity(documentSettings.schemaRequest) : main.DiagnosticSeverity.Warning;
                        if (schema) {
                            const addSchemaProblem = (errorMessage, errorCode)=>{
                                if (jsonDocument.root && schemaRequest) {
                                    const astRoot = jsonDocument.root;
                                    const property = astRoot.type === 'object' ? astRoot.properties[0] : undefined;
                                    if (property && property.keyNode.value === '$schema') {
                                        const node = property.valueNode || property;
                                        const range = main.Range.create(textDocument.positionAt(node.offset), textDocument.positionAt(node.offset + node.length));
                                        addProblem(main.Diagnostic.create(range, errorMessage, schemaRequest, errorCode));
                                    } else {
                                        const range = main.Range.create(textDocument.positionAt(astRoot.offset), textDocument.positionAt(astRoot.offset + 1));
                                        addProblem(main.Diagnostic.create(range, errorMessage, schemaRequest, errorCode));
                                    }
                                }
                            };
                            if (schema.errors.length) {
                                addSchemaProblem(schema.errors[0], ErrorCode.SchemaResolveError);
                            } else if (schemaValidation) {
                                var _documentSettings4;
                                for (const warning of schema.warnings){
                                    addSchemaProblem(warning, ErrorCode.SchemaUnsupportedFeature);
                                }
                                const semanticErrors = jsonDocument.validate(textDocument, schema.schema, schemaValidation, (_documentSettings4 = documentSettings) === null || _documentSettings4 === void 0 ? void 0 : _documentSettings4.schemaDraft);
                                if (semanticErrors) {
                                    semanticErrors.forEach(addProblem);
                                }
                            }
                            if (schemaAllowsComments(schema.schema)) {
                                commentSeverity = undefined;
                            }
                            if (schemaAllowsTrailingCommas(schema.schema)) {
                                trailingCommaSeverity = undefined;
                            }
                        }
                        for (const p of jsonDocument.syntaxErrors){
                            if (p.code === ErrorCode.TrailingComma) {
                                if (typeof trailingCommaSeverity !== 'number') {
                                    continue;
                                }
                                p.severity = trailingCommaSeverity;
                            }
                            addProblem(p);
                        }
                        if (typeof commentSeverity === 'number') {
                            const message = t('Comments are not permitted in JSON.');
                            jsonDocument.comments.forEach((c)=>{
                                addProblem(main.Diagnostic.create(c, message, commentSeverity, ErrorCode.CommentNotPermitted));
                            });
                        }
                        return diagnostics;
                    };
                    if (schema) {
                        const uri = schema.id || 'schemaservice://untitled/' + idCounter++;
                        const handle = this.jsonSchemaService.registerExternalSchema({
                            uri,
                            schema
                        });
                        return handle.getResolvedSchema().then((resolvedSchema)=>{
                            return getDiagnostics(resolvedSchema);
                        });
                    }
                    return this.jsonSchemaService.getSchemaForResource(textDocument.uri, jsonDocument).then((schema)=>{
                        return getDiagnostics(schema);
                    });
                }
                getLanguageStatus(textDocument, jsonDocument) {
                    return {
                        schemas: this.jsonSchemaService.getSchemaURIsForResource(textDocument.uri, jsonDocument)
                    };
                }
                constructor(jsonSchemaService, promiseConstructor){
                    this.jsonSchemaService = jsonSchemaService;
                    this.promise = promiseConstructor;
                    this.validationEnabled = true;
                }
            }
            let idCounter = 0;
            function schemaAllowsComments(schemaRef) {
                if (schemaRef && typeof schemaRef === 'object') {
                    if (isBoolean(schemaRef.allowComments)) {
                        return schemaRef.allowComments;
                    }
                    if (schemaRef.allOf) {
                        for (const schema of schemaRef.allOf){
                            const allow = schemaAllowsComments(schema);
                            if (isBoolean(allow)) {
                                return allow;
                            }
                        }
                    }
                }
                return undefined;
            }
            function schemaAllowsTrailingCommas(schemaRef) {
                if (schemaRef && typeof schemaRef === 'object') {
                    if (isBoolean(schemaRef.allowTrailingCommas)) {
                        return schemaRef.allowTrailingCommas;
                    }
                    const deprSchemaRef = schemaRef;
                    if (isBoolean(deprSchemaRef['allowsTrailingCommas'])) {
                        return deprSchemaRef['allowsTrailingCommas'];
                    }
                    if (schemaRef.allOf) {
                        for (const schema of schemaRef.allOf){
                            const allow = schemaAllowsTrailingCommas(schema);
                            if (isBoolean(allow)) {
                                return allow;
                            }
                        }
                    }
                }
                return undefined;
            }
            function toDiagnosticSeverity(severityLevel) {
                switch(severityLevel){
                    case 'error':
                        return main.DiagnosticSeverity.Error;
                    case 'warning':
                        return main.DiagnosticSeverity.Warning;
                    case 'ignore':
                        return undefined;
                }
                return undefined;
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/utils/colors.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ const Digit0 = 48;
            const Digit9 = 57;
            const A = 65;
            const a = 97;
            const f = 102;
            function hexDigit(charCode) {
                if (charCode < Digit0) {
                    return 0;
                }
                if (charCode <= Digit9) {
                    return charCode - Digit0;
                }
                if (charCode < a) {
                    charCode += a - A;
                }
                if (charCode >= a && charCode <= f) {
                    return charCode - a + 10;
                }
                return 0;
            }
            function colorFromHex(text) {
                if (text[0] !== '#') {
                    return undefined;
                }
                switch(text.length){
                    case 4:
                        return {
                            red: hexDigit(text.charCodeAt(1)) * 0x11 / 255.0,
                            green: hexDigit(text.charCodeAt(2)) * 0x11 / 255.0,
                            blue: hexDigit(text.charCodeAt(3)) * 0x11 / 255.0,
                            alpha: 1
                        };
                    case 5:
                        return {
                            red: hexDigit(text.charCodeAt(1)) * 0x11 / 255.0,
                            green: hexDigit(text.charCodeAt(2)) * 0x11 / 255.0,
                            blue: hexDigit(text.charCodeAt(3)) * 0x11 / 255.0,
                            alpha: hexDigit(text.charCodeAt(4)) * 0x11 / 255.0
                        };
                    case 7:
                        return {
                            red: (hexDigit(text.charCodeAt(1)) * 0x10 + hexDigit(text.charCodeAt(2))) / 255.0,
                            green: (hexDigit(text.charCodeAt(3)) * 0x10 + hexDigit(text.charCodeAt(4))) / 255.0,
                            blue: (hexDigit(text.charCodeAt(5)) * 0x10 + hexDigit(text.charCodeAt(6))) / 255.0,
                            alpha: 1
                        };
                    case 9:
                        return {
                            red: (hexDigit(text.charCodeAt(1)) * 0x10 + hexDigit(text.charCodeAt(2))) / 255.0,
                            green: (hexDigit(text.charCodeAt(3)) * 0x10 + hexDigit(text.charCodeAt(4))) / 255.0,
                            blue: (hexDigit(text.charCodeAt(5)) * 0x10 + hexDigit(text.charCodeAt(6))) / 255.0,
                            alpha: (hexDigit(text.charCodeAt(7)) * 0x10 + hexDigit(text.charCodeAt(8))) / 255.0
                        };
                }
                return undefined;
            }
            function colorFrom256RGB(red, green, blue, alpha = 1.0) {
                return {
                    red: red / 255.0,
                    green: green / 255.0,
                    blue: blue / 255.0,
                    alpha
                };
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/services/jsonDocumentSymbols.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ class JSONDocumentSymbols {
                findDocumentSymbols(document1, doc, context = {
                    resultLimit: Number.MAX_VALUE
                }) {
                    const root = doc.root;
                    if (!root) {
                        return [];
                    }
                    let limit = context.resultLimit || Number.MAX_VALUE;
                    // special handling for key bindings
                    const resourceString = document1.uri;
                    if (resourceString === 'vscode://defaultsettings/keybindings.json' || endsWith(resourceString.toLowerCase(), '/user/keybindings.json')) {
                        if (root.type === 'array') {
                            const result = [];
                            for (const item of root.items){
                                if (item.type === 'object') {
                                    for (const property of item.properties){
                                        if (property.keyNode.value === 'key' && property.valueNode) {
                                            const location = main.Location.create(document1.uri, getRange(document1, item));
                                            result.push({
                                                name: getName(property.valueNode),
                                                kind: main.SymbolKind.Function,
                                                location: location
                                            });
                                            limit--;
                                            if (limit <= 0) {
                                                if (context && context.onResultLimitExceeded) {
                                                    context.onResultLimitExceeded(resourceString);
                                                }
                                                return result;
                                            }
                                        }
                                    }
                                }
                            }
                            return result;
                        }
                    }
                    const toVisit = [
                        {
                            node: root,
                            containerName: ''
                        }
                    ];
                    let nextToVisit = 0;
                    let limitExceeded = false;
                    const result = [];
                    const collectOutlineEntries = (node, containerName)=>{
                        if (node.type === 'array') {
                            node.items.forEach((node)=>{
                                if (node) {
                                    toVisit.push({
                                        node,
                                        containerName
                                    });
                                }
                            });
                        } else if (node.type === 'object') {
                            node.properties.forEach((property)=>{
                                const valueNode = property.valueNode;
                                if (valueNode) {
                                    if (limit > 0) {
                                        limit--;
                                        const location = main.Location.create(document1.uri, getRange(document1, property));
                                        const childContainerName = containerName ? containerName + '.' + property.keyNode.value : property.keyNode.value;
                                        result.push({
                                            name: this.getKeyLabel(property),
                                            kind: this.getSymbolKind(valueNode.type),
                                            location: location,
                                            containerName: containerName
                                        });
                                        toVisit.push({
                                            node: valueNode,
                                            containerName: childContainerName
                                        });
                                    } else {
                                        limitExceeded = true;
                                    }
                                }
                            });
                        }
                    };
                    // breath first traversal
                    while(nextToVisit < toVisit.length){
                        const next = toVisit[nextToVisit++];
                        collectOutlineEntries(next.node, next.containerName);
                    }
                    if (limitExceeded && context && context.onResultLimitExceeded) {
                        context.onResultLimitExceeded(resourceString);
                    }
                    return result;
                }
                findDocumentSymbols2(document1, doc, context = {
                    resultLimit: Number.MAX_VALUE
                }) {
                    const root = doc.root;
                    if (!root) {
                        return [];
                    }
                    let limit = context.resultLimit || Number.MAX_VALUE;
                    // special handling for key bindings
                    const resourceString = document1.uri;
                    if (resourceString === 'vscode://defaultsettings/keybindings.json' || endsWith(resourceString.toLowerCase(), '/user/keybindings.json')) {
                        if (root.type === 'array') {
                            const result = [];
                            for (const item of root.items){
                                if (item.type === 'object') {
                                    for (const property of item.properties){
                                        if (property.keyNode.value === 'key' && property.valueNode) {
                                            const range = getRange(document1, item);
                                            const selectionRange = getRange(document1, property.keyNode);
                                            result.push({
                                                name: getName(property.valueNode),
                                                kind: main.SymbolKind.Function,
                                                range,
                                                selectionRange
                                            });
                                            limit--;
                                            if (limit <= 0) {
                                                if (context && context.onResultLimitExceeded) {
                                                    context.onResultLimitExceeded(resourceString);
                                                }
                                                return result;
                                            }
                                        }
                                    }
                                }
                            }
                            return result;
                        }
                    }
                    const result = [];
                    const toVisit = [
                        {
                            node: root,
                            result
                        }
                    ];
                    let nextToVisit = 0;
                    let limitExceeded = false;
                    const collectOutlineEntries = (node, result)=>{
                        if (node.type === 'array') {
                            node.items.forEach((node, index)=>{
                                if (node) {
                                    if (limit > 0) {
                                        limit--;
                                        const range = getRange(document1, node);
                                        const selectionRange = range;
                                        const name = String(index);
                                        const symbol = {
                                            name,
                                            kind: this.getSymbolKind(node.type),
                                            range,
                                            selectionRange,
                                            children: []
                                        };
                                        result.push(symbol);
                                        toVisit.push({
                                            result: symbol.children,
                                            node
                                        });
                                    } else {
                                        limitExceeded = true;
                                    }
                                }
                            });
                        } else if (node.type === 'object') {
                            node.properties.forEach((property)=>{
                                const valueNode = property.valueNode;
                                if (valueNode) {
                                    if (limit > 0) {
                                        limit--;
                                        const range = getRange(document1, property);
                                        const selectionRange = getRange(document1, property.keyNode);
                                        const children = [];
                                        const symbol = {
                                            name: this.getKeyLabel(property),
                                            kind: this.getSymbolKind(valueNode.type),
                                            range,
                                            selectionRange,
                                            children,
                                            detail: this.getDetail(valueNode)
                                        };
                                        result.push(symbol);
                                        toVisit.push({
                                            result: children,
                                            node: valueNode
                                        });
                                    } else {
                                        limitExceeded = true;
                                    }
                                }
                            });
                        }
                    };
                    // breath first traversal
                    while(nextToVisit < toVisit.length){
                        const next = toVisit[nextToVisit++];
                        collectOutlineEntries(next.node, next.result);
                    }
                    if (limitExceeded && context && context.onResultLimitExceeded) {
                        context.onResultLimitExceeded(resourceString);
                    }
                    return result;
                }
                getSymbolKind(nodeType) {
                    switch(nodeType){
                        case 'object':
                            return main.SymbolKind.Module;
                        case 'string':
                            return main.SymbolKind.String;
                        case 'number':
                            return main.SymbolKind.Number;
                        case 'array':
                            return main.SymbolKind.Array;
                        case 'boolean':
                            return main.SymbolKind.Boolean;
                        default:
                            return main.SymbolKind.Variable;
                    }
                }
                getKeyLabel(property) {
                    let name = property.keyNode.value;
                    if (name) {
                        name = name.replace(/[\n]/g, '↵');
                    }
                    if (name && name.trim()) {
                        return name;
                    }
                    return `"${name}"`;
                }
                getDetail(node) {
                    if (!node) {
                        return undefined;
                    }
                    if (node.type === 'boolean' || node.type === 'number' || node.type === 'null' || node.type === 'string') {
                        return String(node.value);
                    } else {
                        if (node.type === 'array') {
                            return node.children.length ? undefined : '[]';
                        } else if (node.type === 'object') {
                            return node.children.length ? undefined : '{}';
                        }
                    }
                    return undefined;
                }
                findDocumentColors(document1, doc, context) {
                    return this.schemaService.getSchemaForResource(document1.uri, doc).then((schema)=>{
                        const result = [];
                        if (schema) {
                            let limit = context && typeof context.resultLimit === 'number' ? context.resultLimit : Number.MAX_VALUE;
                            const matchingSchemas = doc.getMatchingSchemas(schema.schema);
                            const visitedNode = {};
                            for (const s of matchingSchemas){
                                if (!s.inverted && s.schema && (s.schema.format === 'color' || s.schema.format === 'color-hex') && s.node && s.node.type === 'string') {
                                    const nodeId = String(s.node.offset);
                                    if (!visitedNode[nodeId]) {
                                        const color = colorFromHex(jsonParser_getNodeValue(s.node));
                                        if (color) {
                                            const range = getRange(document1, s.node);
                                            result.push({
                                                color,
                                                range
                                            });
                                        }
                                        visitedNode[nodeId] = true;
                                        limit--;
                                        if (limit <= 0) {
                                            if (context && context.onResultLimitExceeded) {
                                                context.onResultLimitExceeded(document1.uri);
                                            }
                                            return result;
                                        }
                                    }
                                }
                            }
                        }
                        return result;
                    });
                }
                getColorPresentations(document1, doc, color, range) {
                    const result = [];
                    const red256 = Math.round(color.red * 255), green256 = Math.round(color.green * 255), blue256 = Math.round(color.blue * 255);
                    function toTwoDigitHex(n) {
                        const r = n.toString(16);
                        return r.length !== 2 ? '0' + r : r;
                    }
                    let label;
                    if (color.alpha === 1) {
                        label = `#${toTwoDigitHex(red256)}${toTwoDigitHex(green256)}${toTwoDigitHex(blue256)}`;
                    } else {
                        label = `#${toTwoDigitHex(red256)}${toTwoDigitHex(green256)}${toTwoDigitHex(blue256)}${toTwoDigitHex(Math.round(color.alpha * 255))}`;
                    }
                    result.push({
                        label: label,
                        textEdit: main.TextEdit.replace(range, JSON.stringify(label))
                    });
                    return result;
                }
                constructor(schemaService){
                    this.schemaService = schemaService;
                }
            }
            function getRange(document1, node) {
                return main.Range.create(document1.positionAt(node.offset), document1.positionAt(node.offset + node.length));
            }
            function getName(node) {
                return jsonParser_getNodeValue(node) || t('<empty>');
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/services/configuration.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ const schemaContributions = {
                schemaAssociations: [],
                schemas: {
                    // refer to the latest schema
                    'http://json-schema.org/schema#': {
                        $ref: 'http://json-schema.org/draft-07/schema#'
                    },
                    // bundle the schema-schema to include (localized) descriptions
                    'http://json-schema.org/draft-04/schema#': {
                        '$schema': 'http://json-schema.org/draft-04/schema#',
                        'definitions': {
                            'schemaArray': {
                                'type': 'array',
                                'minItems': 1,
                                'items': {
                                    '$ref': '#'
                                }
                            },
                            'positiveInteger': {
                                'type': 'integer',
                                'minimum': 0
                            },
                            'positiveIntegerDefault0': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/positiveInteger'
                                    },
                                    {
                                        'default': 0
                                    }
                                ]
                            },
                            'simpleTypes': {
                                'type': 'string',
                                'enum': [
                                    'array',
                                    'boolean',
                                    'integer',
                                    'null',
                                    'number',
                                    'object',
                                    'string'
                                ]
                            },
                            'stringArray': {
                                'type': 'array',
                                'items': {
                                    'type': 'string'
                                },
                                'minItems': 1,
                                'uniqueItems': true
                            }
                        },
                        'type': 'object',
                        'properties': {
                            'id': {
                                'type': 'string',
                                'format': 'uri'
                            },
                            '$schema': {
                                'type': 'string',
                                'format': 'uri'
                            },
                            'title': {
                                'type': 'string'
                            },
                            'description': {
                                'type': 'string'
                            },
                            'default': {},
                            'multipleOf': {
                                'type': 'number',
                                'minimum': 0,
                                'exclusiveMinimum': true
                            },
                            'maximum': {
                                'type': 'number'
                            },
                            'exclusiveMaximum': {
                                'type': 'boolean',
                                'default': false
                            },
                            'minimum': {
                                'type': 'number'
                            },
                            'exclusiveMinimum': {
                                'type': 'boolean',
                                'default': false
                            },
                            'maxLength': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/positiveInteger'
                                    }
                                ]
                            },
                            'minLength': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/positiveIntegerDefault0'
                                    }
                                ]
                            },
                            'pattern': {
                                'type': 'string',
                                'format': 'regex'
                            },
                            'additionalItems': {
                                'anyOf': [
                                    {
                                        'type': 'boolean'
                                    },
                                    {
                                        '$ref': '#'
                                    }
                                ],
                                'default': {}
                            },
                            'items': {
                                'anyOf': [
                                    {
                                        '$ref': '#'
                                    },
                                    {
                                        '$ref': '#/definitions/schemaArray'
                                    }
                                ],
                                'default': {}
                            },
                            'maxItems': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/positiveInteger'
                                    }
                                ]
                            },
                            'minItems': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/positiveIntegerDefault0'
                                    }
                                ]
                            },
                            'uniqueItems': {
                                'type': 'boolean',
                                'default': false
                            },
                            'maxProperties': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/positiveInteger'
                                    }
                                ]
                            },
                            'minProperties': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/positiveIntegerDefault0'
                                    }
                                ]
                            },
                            'required': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/stringArray'
                                    }
                                ]
                            },
                            'additionalProperties': {
                                'anyOf': [
                                    {
                                        'type': 'boolean'
                                    },
                                    {
                                        '$ref': '#'
                                    }
                                ],
                                'default': {}
                            },
                            'definitions': {
                                'type': 'object',
                                'additionalProperties': {
                                    '$ref': '#'
                                },
                                'default': {}
                            },
                            'properties': {
                                'type': 'object',
                                'additionalProperties': {
                                    '$ref': '#'
                                },
                                'default': {}
                            },
                            'patternProperties': {
                                'type': 'object',
                                'additionalProperties': {
                                    '$ref': '#'
                                },
                                'default': {}
                            },
                            'dependencies': {
                                'type': 'object',
                                'additionalProperties': {
                                    'anyOf': [
                                        {
                                            '$ref': '#'
                                        },
                                        {
                                            '$ref': '#/definitions/stringArray'
                                        }
                                    ]
                                }
                            },
                            'enum': {
                                'type': 'array',
                                'minItems': 1,
                                'uniqueItems': true
                            },
                            'type': {
                                'anyOf': [
                                    {
                                        '$ref': '#/definitions/simpleTypes'
                                    },
                                    {
                                        'type': 'array',
                                        'items': {
                                            '$ref': '#/definitions/simpleTypes'
                                        },
                                        'minItems': 1,
                                        'uniqueItems': true
                                    }
                                ]
                            },
                            'format': {
                                'anyOf': [
                                    {
                                        'type': 'string',
                                        'enum': [
                                            'date-time',
                                            'uri',
                                            'email',
                                            'hostname',
                                            'ipv4',
                                            'ipv6',
                                            'regex'
                                        ]
                                    },
                                    {
                                        'type': 'string'
                                    }
                                ]
                            },
                            'allOf': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/schemaArray'
                                    }
                                ]
                            },
                            'anyOf': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/schemaArray'
                                    }
                                ]
                            },
                            'oneOf': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/schemaArray'
                                    }
                                ]
                            },
                            'not': {
                                'allOf': [
                                    {
                                        '$ref': '#'
                                    }
                                ]
                            }
                        },
                        'dependencies': {
                            'exclusiveMaximum': [
                                'maximum'
                            ],
                            'exclusiveMinimum': [
                                'minimum'
                            ]
                        },
                        'default': {}
                    },
                    'http://json-schema.org/draft-07/schema#': {
                        'definitions': {
                            'schemaArray': {
                                'type': 'array',
                                'minItems': 1,
                                'items': {
                                    '$ref': '#'
                                }
                            },
                            'nonNegativeInteger': {
                                'type': 'integer',
                                'minimum': 0
                            },
                            'nonNegativeIntegerDefault0': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/nonNegativeInteger'
                                    },
                                    {
                                        'default': 0
                                    }
                                ]
                            },
                            'simpleTypes': {
                                'enum': [
                                    'array',
                                    'boolean',
                                    'integer',
                                    'null',
                                    'number',
                                    'object',
                                    'string'
                                ]
                            },
                            'stringArray': {
                                'type': 'array',
                                'items': {
                                    'type': 'string'
                                },
                                'uniqueItems': true,
                                'default': []
                            }
                        },
                        'type': [
                            'object',
                            'boolean'
                        ],
                        'properties': {
                            '$id': {
                                'type': 'string',
                                'format': 'uri-reference'
                            },
                            '$schema': {
                                'type': 'string',
                                'format': 'uri'
                            },
                            '$ref': {
                                'type': 'string',
                                'format': 'uri-reference'
                            },
                            '$comment': {
                                'type': 'string'
                            },
                            'title': {
                                'type': 'string'
                            },
                            'description': {
                                'type': 'string'
                            },
                            'default': true,
                            'readOnly': {
                                'type': 'boolean',
                                'default': false
                            },
                            'examples': {
                                'type': 'array',
                                'items': true
                            },
                            'multipleOf': {
                                'type': 'number',
                                'exclusiveMinimum': 0
                            },
                            'maximum': {
                                'type': 'number'
                            },
                            'exclusiveMaximum': {
                                'type': 'number'
                            },
                            'minimum': {
                                'type': 'number'
                            },
                            'exclusiveMinimum': {
                                'type': 'number'
                            },
                            'maxLength': {
                                '$ref': '#/definitions/nonNegativeInteger'
                            },
                            'minLength': {
                                '$ref': '#/definitions/nonNegativeIntegerDefault0'
                            },
                            'pattern': {
                                'type': 'string',
                                'format': 'regex'
                            },
                            'additionalItems': {
                                '$ref': '#'
                            },
                            'items': {
                                'anyOf': [
                                    {
                                        '$ref': '#'
                                    },
                                    {
                                        '$ref': '#/definitions/schemaArray'
                                    }
                                ],
                                'default': true
                            },
                            'maxItems': {
                                '$ref': '#/definitions/nonNegativeInteger'
                            },
                            'minItems': {
                                '$ref': '#/definitions/nonNegativeIntegerDefault0'
                            },
                            'uniqueItems': {
                                'type': 'boolean',
                                'default': false
                            },
                            'contains': {
                                '$ref': '#'
                            },
                            'maxProperties': {
                                '$ref': '#/definitions/nonNegativeInteger'
                            },
                            'minProperties': {
                                '$ref': '#/definitions/nonNegativeIntegerDefault0'
                            },
                            'required': {
                                '$ref': '#/definitions/stringArray'
                            },
                            'additionalProperties': {
                                '$ref': '#'
                            },
                            'definitions': {
                                'type': 'object',
                                'additionalProperties': {
                                    '$ref': '#'
                                },
                                'default': {}
                            },
                            'properties': {
                                'type': 'object',
                                'additionalProperties': {
                                    '$ref': '#'
                                },
                                'default': {}
                            },
                            'patternProperties': {
                                'type': 'object',
                                'additionalProperties': {
                                    '$ref': '#'
                                },
                                'propertyNames': {
                                    'format': 'regex'
                                },
                                'default': {}
                            },
                            'dependencies': {
                                'type': 'object',
                                'additionalProperties': {
                                    'anyOf': [
                                        {
                                            '$ref': '#'
                                        },
                                        {
                                            '$ref': '#/definitions/stringArray'
                                        }
                                    ]
                                }
                            },
                            'propertyNames': {
                                '$ref': '#'
                            },
                            'const': true,
                            'enum': {
                                'type': 'array',
                                'items': true,
                                'minItems': 1,
                                'uniqueItems': true
                            },
                            'type': {
                                'anyOf': [
                                    {
                                        '$ref': '#/definitions/simpleTypes'
                                    },
                                    {
                                        'type': 'array',
                                        'items': {
                                            '$ref': '#/definitions/simpleTypes'
                                        },
                                        'minItems': 1,
                                        'uniqueItems': true
                                    }
                                ]
                            },
                            'format': {
                                'type': 'string'
                            },
                            'contentMediaType': {
                                'type': 'string'
                            },
                            'contentEncoding': {
                                'type': 'string'
                            },
                            'if': {
                                '$ref': '#'
                            },
                            'then': {
                                '$ref': '#'
                            },
                            'else': {
                                '$ref': '#'
                            },
                            'allOf': {
                                '$ref': '#/definitions/schemaArray'
                            },
                            'anyOf': {
                                '$ref': '#/definitions/schemaArray'
                            },
                            'oneOf': {
                                '$ref': '#/definitions/schemaArray'
                            },
                            'not': {
                                '$ref': '#'
                            }
                        },
                        'default': true
                    }
                }
            };
            const descriptions = {
                id: t("A unique identifier for the schema."),
                $schema: t("The schema to verify this document against."),
                title: t("A descriptive title of the element."),
                description: t("A long description of the element. Used in hover menus and suggestions."),
                default: t("A default value. Used by suggestions."),
                multipleOf: t("A number that should cleanly divide the current value (i.e. have no remainder)."),
                maximum: t("The maximum numerical value, inclusive by default."),
                exclusiveMaximum: t("Makes the maximum property exclusive."),
                minimum: t("The minimum numerical value, inclusive by default."),
                exclusiveMinimum: t("Makes the minimum property exclusive."),
                maxLength: t("The maximum length of a string."),
                minLength: t("The minimum length of a string."),
                pattern: t("A regular expression to match the string against. It is not implicitly anchored."),
                additionalItems: t("For arrays, only when items is set as an array. If it is a schema, then this schema validates items after the ones specified by the items array. If it is false, then additional items will cause validation to fail."),
                items: t("For arrays. Can either be a schema to validate every element against or an array of schemas to validate each item against in order (the first schema will validate the first element, the second schema will validate the second element, and so on."),
                maxItems: t("The maximum number of items that can be inside an array. Inclusive."),
                minItems: t("The minimum number of items that can be inside an array. Inclusive."),
                uniqueItems: t("If all of the items in the array must be unique. Defaults to false."),
                maxProperties: t("The maximum number of properties an object can have. Inclusive."),
                minProperties: t("The minimum number of properties an object can have. Inclusive."),
                required: t("An array of strings that lists the names of all properties required on this object."),
                additionalProperties: t("Either a schema or a boolean. If a schema, then used to validate all properties not matched by 'properties' or 'patternProperties'. If false, then any properties not matched by either will cause this schema to fail."),
                definitions: t("Not used for validation. Place subschemas here that you wish to reference inline with $ref."),
                properties: t("A map of property names to schemas for each property."),
                patternProperties: t("A map of regular expressions on property names to schemas for matching properties."),
                dependencies: t("A map of property names to either an array of property names or a schema. An array of property names means the property named in the key depends on the properties in the array being present in the object in order to be valid. If the value is a schema, then the schema is only applied to the object if the property in the key exists on the object."),
                enum: t("The set of literal values that are valid."),
                type: t("Either a string of one of the basic schema types (number, integer, null, array, object, boolean, string) or an array of strings specifying a subset of those types."),
                format: t("Describes the format expected for the value."),
                allOf: t("An array of schemas, all of which must match."),
                anyOf: t("An array of schemas, where at least one must match."),
                oneOf: t("An array of schemas, exactly one of which must match."),
                not: t("A schema which must not match."),
                $id: t("A unique identifier for the schema."),
                $ref: t("Reference a definition hosted on any location."),
                $comment: t("Comments from schema authors to readers or maintainers of the schema."),
                readOnly: t("Indicates that the value of the instance is managed exclusively by the owning authority."),
                examples: t("Sample JSON values associated with a particular schema, for the purpose of illustrating usage."),
                contains: t("An array instance is valid against \"contains\" if at least one of its elements is valid against the given schema."),
                propertyNames: t("If the instance is an object, this keyword validates if every property name in the instance validates against the provided schema."),
                const: t("An instance validates successfully against this keyword if its value is equal to the value of the keyword."),
                contentMediaType: t("Describes the media type of a string property."),
                contentEncoding: t("Describes the content encoding of a string property."),
                if: t("The validation outcome of the \"if\" subschema controls which of the \"then\" or \"else\" keywords are evaluated."),
                then: t("The \"if\" subschema is used for validation when the \"if\" subschema succeeds."),
                else: t("The \"else\" subschema is used for validation when the \"if\" subschema fails.")
            };
            for(const schemaName in schemaContributions.schemas){
                const schema = schemaContributions.schemas[schemaName];
                for(const property in schema.properties){
                    let propertyObject = schema.properties[property];
                    if (typeof propertyObject === 'boolean') {
                        propertyObject = schema.properties[property] = {};
                    }
                    const description = descriptions[property];
                    if (description) {
                        propertyObject['description'] = description;
                    }
                }
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-uri/lib/esm/index.js
            /* provided dependency */ var process = __nested_webpack_require_701519__(4406);
            var LIB;
            (()=>{
                "use strict";
                var t = {
                    470: (t)=>{
                        function e(t) {
                            if ("string" != typeof t) throw new TypeError("Path must be a string. Received " + JSON.stringify(t));
                        }
                        function r(t, e) {
                            for(var r, n = "", o = 0, i = -1, a = 0, h = 0; h <= t.length; ++h){
                                if (h < t.length) r = t.charCodeAt(h);
                                else {
                                    if (47 === r) break;
                                    r = 47;
                                }
                                if (47 === r) {
                                    if (i === h - 1 || 1 === a) ;
                                    else if (i !== h - 1 && 2 === a) {
                                        if (n.length < 2 || 2 !== o || 46 !== n.charCodeAt(n.length - 1) || 46 !== n.charCodeAt(n.length - 2)) {
                                            if (n.length > 2) {
                                                var s = n.lastIndexOf("/");
                                                if (s !== n.length - 1) {
                                                    -1 === s ? (n = "", o = 0) : o = (n = n.slice(0, s)).length - 1 - n.lastIndexOf("/"), i = h, a = 0;
                                                    continue;
                                                }
                                            } else if (2 === n.length || 1 === n.length) {
                                                n = "", o = 0, i = h, a = 0;
                                                continue;
                                            }
                                        }
                                        e && (n.length > 0 ? n += "/.." : n = "..", o = 2);
                                    } else n.length > 0 ? n += "/" + t.slice(i + 1, h) : n = t.slice(i + 1, h), o = h - i - 1;
                                    i = h, a = 0;
                                } else 46 === r && -1 !== a ? ++a : a = -1;
                            }
                            return n;
                        }
                        var n = {
                            resolve: function() {
                                for(var t, n = "", o = !1, i = arguments.length - 1; i >= -1 && !o; i--){
                                    var a;
                                    i >= 0 ? a = arguments[i] : (void 0 === t && (t = process.cwd()), a = t), e(a), 0 !== a.length && (n = a + "/" + n, o = 47 === a.charCodeAt(0));
                                }
                                return n = r(n, !o), o ? n.length > 0 ? "/" + n : "/" : n.length > 0 ? n : ".";
                            },
                            normalize: function(t) {
                                if (e(t), 0 === t.length) return ".";
                                var n = 47 === t.charCodeAt(0), o = 47 === t.charCodeAt(t.length - 1);
                                return 0 !== (t = r(t, !n)).length || n || (t = "."), t.length > 0 && o && (t += "/"), n ? "/" + t : t;
                            },
                            isAbsolute: function(t) {
                                return e(t), t.length > 0 && 47 === t.charCodeAt(0);
                            },
                            join: function() {
                                if (0 === arguments.length) return ".";
                                for(var t, r = 0; r < arguments.length; ++r){
                                    var o = arguments[r];
                                    e(o), o.length > 0 && (void 0 === t ? t = o : t += "/" + o);
                                }
                                return void 0 === t ? "." : n.normalize(t);
                            },
                            relative: function(t, r) {
                                if (e(t), e(r), t === r) return "";
                                if ((t = n.resolve(t)) === (r = n.resolve(r))) return "";
                                for(var o = 1; o < t.length && 47 === t.charCodeAt(o); ++o);
                                for(var i = t.length, a = i - o, h = 1; h < r.length && 47 === r.charCodeAt(h); ++h);
                                for(var s = r.length - h, c = a < s ? a : s, f = -1, u = 0; u <= c; ++u){
                                    if (u === c) {
                                        if (s > c) {
                                            if (47 === r.charCodeAt(h + u)) return r.slice(h + u + 1);
                                            if (0 === u) return r.slice(h + u);
                                        } else a > c && (47 === t.charCodeAt(o + u) ? f = u : 0 === u && (f = 0));
                                        break;
                                    }
                                    var l = t.charCodeAt(o + u);
                                    if (l !== r.charCodeAt(h + u)) break;
                                    47 === l && (f = u);
                                }
                                var p = "";
                                for(u = o + f + 1; u <= i; ++u)u !== i && 47 !== t.charCodeAt(u) || (0 === p.length ? p += ".." : p += "/..");
                                return p.length > 0 ? p + r.slice(h + f) : (h += f, 47 === r.charCodeAt(h) && ++h, r.slice(h));
                            },
                            _makeLong: function(t) {
                                return t;
                            },
                            dirname: function(t) {
                                if (e(t), 0 === t.length) return ".";
                                for(var r = t.charCodeAt(0), n = 47 === r, o = -1, i = !0, a = t.length - 1; a >= 1; --a)if (47 === (r = t.charCodeAt(a))) {
                                    if (!i) {
                                        o = a;
                                        break;
                                    }
                                } else i = !1;
                                return -1 === o ? n ? "/" : "." : n && 1 === o ? "//" : t.slice(0, o);
                            },
                            basename: function(t, r) {
                                if (void 0 !== r && "string" != typeof r) throw new TypeError('"ext" argument must be a string');
                                e(t);
                                var n, o = 0, i = -1, a = !0;
                                if (void 0 !== r && r.length > 0 && r.length <= t.length) {
                                    if (r.length === t.length && r === t) return "";
                                    var h = r.length - 1, s = -1;
                                    for(n = t.length - 1; n >= 0; --n){
                                        var c = t.charCodeAt(n);
                                        if (47 === c) {
                                            if (!a) {
                                                o = n + 1;
                                                break;
                                            }
                                        } else -1 === s && (a = !1, s = n + 1), h >= 0 && (c === r.charCodeAt(h) ? -1 == --h && (i = n) : (h = -1, i = s));
                                    }
                                    return o === i ? i = s : -1 === i && (i = t.length), t.slice(o, i);
                                }
                                for(n = t.length - 1; n >= 0; --n)if (47 === t.charCodeAt(n)) {
                                    if (!a) {
                                        o = n + 1;
                                        break;
                                    }
                                } else -1 === i && (a = !1, i = n + 1);
                                return -1 === i ? "" : t.slice(o, i);
                            },
                            extname: function(t) {
                                e(t);
                                for(var r = -1, n = 0, o = -1, i = !0, a = 0, h = t.length - 1; h >= 0; --h){
                                    var s = t.charCodeAt(h);
                                    if (47 !== s) -1 === o && (i = !1, o = h + 1), 46 === s ? -1 === r ? r = h : 1 !== a && (a = 1) : -1 !== r && (a = -1);
                                    else if (!i) {
                                        n = h + 1;
                                        break;
                                    }
                                }
                                return -1 === r || -1 === o || 0 === a || 1 === a && r === o - 1 && r === n + 1 ? "" : t.slice(r, o);
                            },
                            format: function(t) {
                                if (null === t || "object" != typeof t) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t);
                                return function(t, e) {
                                    var r = e.dir || e.root, n = e.base || (e.name || "") + (e.ext || "");
                                    return r ? r === e.root ? r + n : r + "/" + n : n;
                                }(0, t);
                            },
                            parse: function(t) {
                                e(t);
                                var r = {
                                    root: "",
                                    dir: "",
                                    base: "",
                                    ext: "",
                                    name: ""
                                };
                                if (0 === t.length) return r;
                                var n, o = t.charCodeAt(0), i = 47 === o;
                                i ? (r.root = "/", n = 1) : n = 0;
                                for(var a = -1, h = 0, s = -1, c = !0, f = t.length - 1, u = 0; f >= n; --f)if (47 !== (o = t.charCodeAt(f))) -1 === s && (c = !1, s = f + 1), 46 === o ? -1 === a ? a = f : 1 !== u && (u = 1) : -1 !== a && (u = -1);
                                else if (!c) {
                                    h = f + 1;
                                    break;
                                }
                                return -1 === a || -1 === s || 0 === u || 1 === u && a === s - 1 && a === h + 1 ? -1 !== s && (r.base = r.name = 0 === h && i ? t.slice(1, s) : t.slice(h, s)) : (0 === h && i ? (r.name = t.slice(1, a), r.base = t.slice(1, s)) : (r.name = t.slice(h, a), r.base = t.slice(h, s)), r.ext = t.slice(a, s)), h > 0 ? r.dir = t.slice(0, h - 1) : i && (r.dir = "/"), r;
                            },
                            sep: "/",
                            delimiter: ":",
                            win32: null,
                            posix: null
                        };
                        n.posix = n, t.exports = n;
                    }
                }, e = {};
                function r(n) {
                    var o = e[n];
                    if (void 0 !== o) return o.exports;
                    var i = e[n] = {
                        exports: {}
                    };
                    return t[n](i, i.exports, r), i.exports;
                }
                r.d = (t, e)=>{
                    for(var n in e)r.o(e, n) && !r.o(t, n) && Object.defineProperty(t, n, {
                        enumerable: !0,
                        get: e[n]
                    });
                }, r.o = (t, e)=>Object.prototype.hasOwnProperty.call(t, e), r.r = (t)=>{
                    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
                        value: "Module"
                    }), Object.defineProperty(t, "__esModule", {
                        value: !0
                    });
                };
                var n = {};
                (()=>{
                    var t;
                    if (r.r(n), r.d(n, {
                        URI: ()=>g,
                        Utils: ()=>O
                    }), "object" == typeof process) t = "win32" === process.platform;
                    else if ("object" == typeof navigator) {
                        var e = navigator.userAgent;
                        t = e.indexOf("Windows") >= 0;
                    }
                    var o, i, a = (o = function(t, e) {
                        return o = Object.setPrototypeOf || ({
                            __proto__: []
                        }) instanceof Array && function(t, e) {
                            t.__proto__ = e;
                        } || function(t, e) {
                            for(var r in e)Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
                        }, o(t, e);
                    }, function(t, e) {
                        if ("function" != typeof e && null !== e) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
                        function r() {
                            this.constructor = t;
                        }
                        o(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r);
                    }), h = /^\w[\w\d+.-]*$/, s = /^\//, c = /^\/\//;
                    function f(t, e) {
                        if (!t.scheme && e) throw new Error('[UriError]: Scheme is missing: {scheme: "", authority: "'.concat(t.authority, '", path: "').concat(t.path, '", query: "').concat(t.query, '", fragment: "').concat(t.fragment, '"}'));
                        if (t.scheme && !h.test(t.scheme)) throw new Error("[UriError]: Scheme contains illegal characters.");
                        if (t.path) {
                            if (t.authority) {
                                if (!s.test(t.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
                            } else if (c.test(t.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
                        }
                    }
                    var u = "", l = "/", p = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/, g = function() {
                        function e(t, e, r, n, o, i) {
                            void 0 === i && (i = !1), "object" == typeof t ? (this.scheme = t.scheme || u, this.authority = t.authority || u, this.path = t.path || u, this.query = t.query || u, this.fragment = t.fragment || u) : (this.scheme = function(t, e) {
                                return t || e ? t : "file";
                            }(t, i), this.authority = e || u, this.path = function(t, e) {
                                switch(t){
                                    case "https":
                                    case "http":
                                    case "file":
                                        e ? e[0] !== l && (e = l + e) : e = l;
                                }
                                return e;
                            }(this.scheme, r || u), this.query = n || u, this.fragment = o || u, f(this, i));
                        }
                        return e.isUri = function(t) {
                            return t instanceof e || !!t && "string" == typeof t.authority && "string" == typeof t.fragment && "string" == typeof t.path && "string" == typeof t.query && "string" == typeof t.scheme && "string" == typeof t.fsPath && "function" == typeof t.with && "function" == typeof t.toString;
                        }, Object.defineProperty(e.prototype, "fsPath", {
                            get: function() {
                                return C(this, !1);
                            },
                            enumerable: !1,
                            configurable: !0
                        }), e.prototype.with = function(t) {
                            if (!t) return this;
                            var e = t.scheme, r = t.authority, n = t.path, o = t.query, i = t.fragment;
                            return void 0 === e ? e = this.scheme : null === e && (e = u), void 0 === r ? r = this.authority : null === r && (r = u), void 0 === n ? n = this.path : null === n && (n = u), void 0 === o ? o = this.query : null === o && (o = u), void 0 === i ? i = this.fragment : null === i && (i = u), e === this.scheme && r === this.authority && n === this.path && o === this.query && i === this.fragment ? this : new v(e, r, n, o, i);
                        }, e.parse = function(t, e) {
                            void 0 === e && (e = !1);
                            var r = p.exec(t);
                            return r ? new v(r[2] || u, _(r[4] || u), _(r[5] || u), _(r[7] || u), _(r[9] || u), e) : new v(u, u, u, u, u);
                        }, e.file = function(e) {
                            var r = u;
                            if (t && (e = e.replace(/\\/g, l)), e[0] === l && e[1] === l) {
                                var n = e.indexOf(l, 2);
                                -1 === n ? (r = e.substring(2), e = l) : (r = e.substring(2, n), e = e.substring(n) || l);
                            }
                            return new v("file", r, e, u, u);
                        }, e.from = function(t) {
                            var e = new v(t.scheme, t.authority, t.path, t.query, t.fragment);
                            return f(e, !0), e;
                        }, e.prototype.toString = function(t) {
                            return void 0 === t && (t = !1), A(this, t);
                        }, e.prototype.toJSON = function() {
                            return this;
                        }, e.revive = function(t) {
                            if (t) {
                                if (t instanceof e) return t;
                                var r = new v(t);
                                return r._formatted = t.external, r._fsPath = t._sep === d ? t.fsPath : null, r;
                            }
                            return t;
                        }, e;
                    }(), d = t ? 1 : void 0, v = function(t) {
                        function e() {
                            var e = null !== t && t.apply(this, arguments) || this;
                            return e._formatted = null, e._fsPath = null, e;
                        }
                        return a(e, t), Object.defineProperty(e.prototype, "fsPath", {
                            get: function() {
                                return this._fsPath || (this._fsPath = C(this, !1)), this._fsPath;
                            },
                            enumerable: !1,
                            configurable: !0
                        }), e.prototype.toString = function(t) {
                            return void 0 === t && (t = !1), t ? A(this, !0) : (this._formatted || (this._formatted = A(this, !1)), this._formatted);
                        }, e.prototype.toJSON = function() {
                            var t = {
                                $mid: 1
                            };
                            return this._fsPath && (t.fsPath = this._fsPath, t._sep = d), this._formatted && (t.external = this._formatted), this.path && (t.path = this.path), this.scheme && (t.scheme = this.scheme), this.authority && (t.authority = this.authority), this.query && (t.query = this.query), this.fragment && (t.fragment = this.fragment), t;
                        }, e;
                    }(g), y = ((i = {})[58] = "%3A", i[47] = "%2F", i[63] = "%3F", i[35] = "%23", i[91] = "%5B", i[93] = "%5D", i[64] = "%40", i[33] = "%21", i[36] = "%24", i[38] = "%26", i[39] = "%27", i[40] = "%28", i[41] = "%29", i[42] = "%2A", i[43] = "%2B", i[44] = "%2C", i[59] = "%3B", i[61] = "%3D", i[32] = "%20", i);
                    function m(t, e, r) {
                        for(var n = void 0, o = -1, i = 0; i < t.length; i++){
                            var a = t.charCodeAt(i);
                            if (a >= 97 && a <= 122 || a >= 65 && a <= 90 || a >= 48 && a <= 57 || 45 === a || 46 === a || 95 === a || 126 === a || e && 47 === a || r && 91 === a || r && 93 === a || r && 58 === a) -1 !== o && (n += encodeURIComponent(t.substring(o, i)), o = -1), void 0 !== n && (n += t.charAt(i));
                            else {
                                void 0 === n && (n = t.substr(0, i));
                                var h = y[a];
                                void 0 !== h ? (-1 !== o && (n += encodeURIComponent(t.substring(o, i)), o = -1), n += h) : -1 === o && (o = i);
                            }
                        }
                        return -1 !== o && (n += encodeURIComponent(t.substring(o))), void 0 !== n ? n : t;
                    }
                    function b(t) {
                        for(var e = void 0, r = 0; r < t.length; r++){
                            var n = t.charCodeAt(r);
                            35 === n || 63 === n ? (void 0 === e && (e = t.substr(0, r)), e += y[n]) : void 0 !== e && (e += t[r]);
                        }
                        return void 0 !== e ? e : t;
                    }
                    function C(e, r) {
                        var n;
                        return n = e.authority && e.path.length > 1 && "file" === e.scheme ? "//".concat(e.authority).concat(e.path) : 47 === e.path.charCodeAt(0) && (e.path.charCodeAt(1) >= 65 && e.path.charCodeAt(1) <= 90 || e.path.charCodeAt(1) >= 97 && e.path.charCodeAt(1) <= 122) && 58 === e.path.charCodeAt(2) ? r ? e.path.substr(1) : e.path[1].toLowerCase() + e.path.substr(2) : e.path, t && (n = n.replace(/\//g, "\\")), n;
                    }
                    function A(t, e) {
                        var r = e ? b : m, n = "", o = t.scheme, i = t.authority, a = t.path, h = t.query, s = t.fragment;
                        if (o && (n += o, n += ":"), (i || "file" === o) && (n += l, n += l), i) {
                            var c = i.indexOf("@");
                            if (-1 !== c) {
                                var f = i.substr(0, c);
                                i = i.substr(c + 1), -1 === (c = f.lastIndexOf(":")) ? n += r(f, !1, !1) : (n += r(f.substr(0, c), !1, !1), n += ":", n += r(f.substr(c + 1), !1, !0)), n += "@";
                            }
                            -1 === (c = (i = i.toLowerCase()).lastIndexOf(":")) ? n += r(i, !1, !0) : (n += r(i.substr(0, c), !1, !0), n += i.substr(c));
                        }
                        if (a) {
                            if (a.length >= 3 && 47 === a.charCodeAt(0) && 58 === a.charCodeAt(2)) (u = a.charCodeAt(1)) >= 65 && u <= 90 && (a = "/".concat(String.fromCharCode(u + 32), ":").concat(a.substr(3)));
                            else if (a.length >= 2 && 58 === a.charCodeAt(1)) {
                                var u;
                                (u = a.charCodeAt(0)) >= 65 && u <= 90 && (a = "".concat(String.fromCharCode(u + 32), ":").concat(a.substr(2)));
                            }
                            n += r(a, !0, !1);
                        }
                        return h && (n += "?", n += r(h, !1, !1)), s && (n += "#", n += e ? s : m(s, !1, !1)), n;
                    }
                    function w(t) {
                        try {
                            return decodeURIComponent(t);
                        } catch (e) {
                            return t.length > 3 ? t.substr(0, 3) + w(t.substr(3)) : t;
                        }
                    }
                    var x = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
                    function _(t) {
                        return t.match(x) ? t.replace(x, function(t) {
                            return w(t);
                        }) : t;
                    }
                    var O, P = r(470), j = function(t, e, r) {
                        if (r || 2 === arguments.length) for(var n, o = 0, i = e.length; o < i; o++)!n && o in e || (n || (n = Array.prototype.slice.call(e, 0, o)), n[o] = e[o]);
                        return t.concat(n || Array.prototype.slice.call(e));
                    }, I = P.posix || P, U = "/";
                    !function(t) {
                        t.joinPath = function(t) {
                            for(var e = [], r = 1; r < arguments.length; r++)e[r - 1] = arguments[r];
                            return t.with({
                                path: I.join.apply(I, j([
                                    t.path
                                ], e, !1))
                            });
                        }, t.resolvePath = function(t) {
                            for(var e = [], r = 1; r < arguments.length; r++)e[r - 1] = arguments[r];
                            var n = t.path, o = !1;
                            n[0] !== U && (n = U + n, o = !0);
                            var i = I.resolve.apply(I, j([
                                n
                            ], e, !1));
                            return o && i[0] === U && !t.authority && (i = i.substring(1)), t.with({
                                path: i
                            });
                        }, t.dirname = function(t) {
                            if (0 === t.path.length || t.path === U) return t;
                            var e = I.dirname(t.path);
                            return 1 === e.length && 46 === e.charCodeAt(0) && (e = ""), t.with({
                                path: e
                            });
                        }, t.basename = function(t) {
                            return I.basename(t.path);
                        }, t.extname = function(t) {
                            return I.extname(t.path);
                        };
                    }(O || (O = {}));
                })(), LIB = n;
            })();
            const { URI, Utils } = LIB;
            //# sourceMappingURL=index.js.map
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/utils/glob.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Copyright (c) 2013, Nick Fitzgerald
 *  Licensed under the MIT License. See LICENCE.md in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ function createRegex(glob, opts) {
                if (typeof glob !== 'string') {
                    throw new TypeError('Expected a string');
                }
                const str = String(glob);
                // The regexp we are building, as a string.
                let reStr = "";
                // Whether we are matching so called "extended" globs (like bash) and should
                // support single character matching, matching ranges of characters, group
                // matching, etc.
                const extended = opts ? !!opts.extended : false;
                // When globstar is _false_ (default), '/foo/*' is translated a regexp like
                // '^\/foo\/.*$' which will match any string beginning with '/foo/'
                // When globstar is _true_, '/foo/*' is translated to regexp like
                // '^\/foo\/[^/]*$' which will match any string beginning with '/foo/' BUT
                // which does not have a '/' to the right of it.
                // E.g. with '/foo/*' these will match: '/foo/bar', '/foo/bar.txt' but
                // these will not '/foo/bar/baz', '/foo/bar/baz.txt'
                // Lastely, when globstar is _true_, '/foo/**' is equivelant to '/foo/*' when
                // globstar is _false_
                const globstar = opts ? !!opts.globstar : false;
                // If we are doing extended matching, this boolean is true when we are inside
                // a group (eg {*.html,*.js}), and false otherwise.
                let inGroup = false;
                // RegExp flags (eg "i" ) to pass in to RegExp constructor.
                const flags = opts && typeof opts.flags === "string" ? opts.flags : "";
                let c;
                for(let i = 0, len = str.length; i < len; i++){
                    c = str[i];
                    switch(c){
                        case "/":
                        case "$":
                        case "^":
                        case "+":
                        case ".":
                        case "(":
                        case ")":
                        case "=":
                        case "!":
                        case "|":
                            reStr += "\\" + c;
                            break;
                        case "?":
                            if (extended) {
                                reStr += ".";
                                break;
                            }
                        case "[":
                        case "]":
                            if (extended) {
                                reStr += c;
                                break;
                            }
                        case "{":
                            if (extended) {
                                inGroup = true;
                                reStr += "(";
                                break;
                            }
                        case "}":
                            if (extended) {
                                inGroup = false;
                                reStr += ")";
                                break;
                            }
                        case ",":
                            if (inGroup) {
                                reStr += "|";
                                break;
                            }
                            reStr += "\\" + c;
                            break;
                        case "*":
                            // Move over all consecutive "*"'s.
                            // Also store the previous and next characters
                            const prevChar = str[i - 1];
                            let starCount = 1;
                            while(str[i + 1] === "*"){
                                starCount++;
                                i++;
                            }
                            const nextChar = str[i + 1];
                            if (!globstar) {
                                // globstar is disabled, so treat any number of "*" as one
                                reStr += ".*";
                            } else {
                                // globstar is enabled, so determine if this is a globstar segment
                                const isGlobstar = starCount > 1 // multiple "*"'s
                                 && (prevChar === "/" || prevChar === undefined || prevChar === '{' || prevChar === ',' // from the start of the segment
                                ) && (nextChar === "/" || nextChar === undefined || nextChar === ',' || nextChar === '}'); // to the end of the segment
                                if (isGlobstar) {
                                    if (nextChar === "/") {
                                        i++; // move over the "/"
                                    } else if (prevChar === '/' && reStr.endsWith('\\/')) {
                                        reStr = reStr.substr(0, reStr.length - 2);
                                    }
                                    // it's a globstar, so match zero or more path segments
                                    reStr += "((?:[^/]*(?:\/|$))*)";
                                } else {
                                    // it's not a globstar, so only match one path segment
                                    reStr += "([^/]*)";
                                }
                            }
                            break;
                        default:
                            reStr += c;
                    }
                }
                // When regexp 'g' flag is specified don't
                // constrain the regular expression with ^ & $
                if (!flags || !~flags.indexOf('g')) {
                    reStr = "^" + reStr + "$";
                }
                return new RegExp(reStr, flags);
            }
            ;
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/services/jsonSchemaService.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ const BANG = '!';
            const PATH_SEP = '/';
            class FilePatternAssociation {
                matchesPattern(fileName) {
                    if (this.folderUri && !fileName.startsWith(this.folderUri)) {
                        return false;
                    }
                    let match = false;
                    for (const { regexp, include } of this.globWrappers){
                        if (regexp.test(fileName)) {
                            match = include;
                        }
                    }
                    return match;
                }
                getURIs() {
                    return this.uris;
                }
                constructor(pattern, folderUri, uris){
                    this.folderUri = folderUri;
                    this.uris = uris;
                    this.globWrappers = [];
                    try {
                        for (let patternString of pattern){
                            const include = patternString[0] !== BANG;
                            if (!include) {
                                patternString = patternString.substring(1);
                            }
                            if (patternString.length > 0) {
                                if (patternString[0] === PATH_SEP) {
                                    patternString = patternString.substring(1);
                                }
                                this.globWrappers.push({
                                    regexp: createRegex('**/' + patternString, {
                                        extended: true,
                                        globstar: true
                                    }),
                                    include: include
                                });
                            }
                        }
                        ;
                        if (folderUri) {
                            folderUri = normalizeResourceForMatching(folderUri);
                            if (!folderUri.endsWith('/')) {
                                folderUri = folderUri + '/';
                            }
                            this.folderUri = folderUri;
                        }
                    } catch (e) {
                        this.globWrappers.length = 0;
                        this.uris = [];
                    }
                }
            }
            class SchemaHandle {
                getUnresolvedSchema() {
                    if (!this.unresolvedSchema) {
                        this.unresolvedSchema = this.service.loadSchema(this.uri);
                    }
                    return this.unresolvedSchema;
                }
                getResolvedSchema() {
                    if (!this.resolvedSchema) {
                        this.resolvedSchema = this.getUnresolvedSchema().then((unresolved)=>{
                            return this.service.resolveSchemaContent(unresolved, this);
                        });
                    }
                    return this.resolvedSchema;
                }
                clearSchema() {
                    const hasChanges = !!this.unresolvedSchema;
                    this.resolvedSchema = undefined;
                    this.unresolvedSchema = undefined;
                    this.dependencies.clear();
                    this.anchors = undefined;
                    return hasChanges;
                }
                constructor(service, uri, unresolvedSchemaContent){
                    this.service = service;
                    this.uri = uri;
                    this.dependencies = new Set();
                    this.anchors = undefined;
                    if (unresolvedSchemaContent) {
                        this.unresolvedSchema = this.service.promise.resolve(new UnresolvedSchema(unresolvedSchemaContent));
                    }
                }
            }
            class UnresolvedSchema {
                constructor(schema, errors = []){
                    this.schema = schema;
                    this.errors = errors;
                }
            }
            class ResolvedSchema {
                getSection(path) {
                    const schemaRef = this.getSectionRecursive(path, this.schema);
                    if (schemaRef) {
                        return asSchema(schemaRef);
                    }
                    return undefined;
                }
                getSectionRecursive(path, schema) {
                    if (!schema || typeof schema === 'boolean' || path.length === 0) {
                        return schema;
                    }
                    const next = path.shift();
                    if (schema.properties && typeof schema.properties[next]) {
                        return this.getSectionRecursive(path, schema.properties[next]);
                    } else if (schema.patternProperties) {
                        for (const pattern of Object.keys(schema.patternProperties)){
                            var _regex;
                            const regex = extendedRegExp(pattern);
                            if ((_regex = regex) === null || _regex === void 0 ? void 0 : _regex.test(next)) {
                                return this.getSectionRecursive(path, schema.patternProperties[pattern]);
                            }
                        }
                    } else if (typeof schema.additionalProperties === 'object') {
                        return this.getSectionRecursive(path, schema.additionalProperties);
                    } else if (next.match('[0-9]+')) {
                        if (Array.isArray(schema.items)) {
                            const index = parseInt(next, 10);
                            if (!isNaN(index) && schema.items[index]) {
                                return this.getSectionRecursive(path, schema.items[index]);
                            }
                        } else if (schema.items) {
                            return this.getSectionRecursive(path, schema.items);
                        }
                    }
                    return undefined;
                }
                constructor(schema, errors = [], warnings = [], schemaDraft){
                    this.schema = schema;
                    this.errors = errors;
                    this.warnings = warnings;
                    this.schemaDraft = schemaDraft;
                }
            }
            class JSONSchemaService {
                getRegisteredSchemaIds(filter) {
                    return Object.keys(this.registeredSchemasIds).filter((id)=>{
                        const scheme = URI.parse(id).scheme;
                        return scheme !== 'schemaservice' && (!filter || filter(scheme));
                    });
                }
                get promise() {
                    return this.promiseConstructor;
                }
                dispose() {
                    while(this.callOnDispose.length > 0){
                        this.callOnDispose.pop()();
                    }
                }
                onResourceChange(uri) {
                    // always clear this local cache when a resource changes
                    this.cachedSchemaForResource = undefined;
                    let hasChanges = false;
                    uri = normalizeId(uri);
                    const toWalk = [
                        uri
                    ];
                    const all = Object.keys(this.schemasById).map((key)=>this.schemasById[key]);
                    while(toWalk.length){
                        const curr = toWalk.pop();
                        for(let i = 0; i < all.length; i++){
                            const handle = all[i];
                            if (handle && (handle.uri === curr || handle.dependencies.has(curr))) {
                                if (handle.uri !== curr) {
                                    toWalk.push(handle.uri);
                                }
                                if (handle.clearSchema()) {
                                    hasChanges = true;
                                }
                                all[i] = undefined;
                            }
                        }
                    }
                    return hasChanges;
                }
                setSchemaContributions(schemaContributions) {
                    if (schemaContributions.schemas) {
                        const schemas = schemaContributions.schemas;
                        for(const id in schemas){
                            const normalizedId = normalizeId(id);
                            this.contributionSchemas[normalizedId] = this.addSchemaHandle(normalizedId, schemas[id]);
                        }
                    }
                    if (Array.isArray(schemaContributions.schemaAssociations)) {
                        const schemaAssociations = schemaContributions.schemaAssociations;
                        for (let schemaAssociation of schemaAssociations){
                            const uris = schemaAssociation.uris.map(normalizeId);
                            const association = this.addFilePatternAssociation(schemaAssociation.pattern, schemaAssociation.folderUri, uris);
                            this.contributionAssociations.push(association);
                        }
                    }
                }
                addSchemaHandle(id, unresolvedSchemaContent) {
                    const schemaHandle = new SchemaHandle(this, id, unresolvedSchemaContent);
                    this.schemasById[id] = schemaHandle;
                    return schemaHandle;
                }
                getOrAddSchemaHandle(id, unresolvedSchemaContent) {
                    return this.schemasById[id] || this.addSchemaHandle(id, unresolvedSchemaContent);
                }
                addFilePatternAssociation(pattern, folderUri, uris) {
                    const fpa = new FilePatternAssociation(pattern, folderUri, uris);
                    this.filePatternAssociations.push(fpa);
                    return fpa;
                }
                registerExternalSchema(config) {
                    const id = normalizeId(config.uri);
                    this.registeredSchemasIds[id] = true;
                    this.cachedSchemaForResource = undefined;
                    if (config.fileMatch && config.fileMatch.length) {
                        this.addFilePatternAssociation(config.fileMatch, config.folderUri, [
                            id
                        ]);
                    }
                    return config.schema ? this.addSchemaHandle(id, config.schema) : this.getOrAddSchemaHandle(id);
                }
                clearExternalSchemas() {
                    this.schemasById = {};
                    this.filePatternAssociations = [];
                    this.registeredSchemasIds = {};
                    this.cachedSchemaForResource = undefined;
                    for(const id in this.contributionSchemas){
                        this.schemasById[id] = this.contributionSchemas[id];
                        this.registeredSchemasIds[id] = true;
                    }
                    for (const contributionAssociation of this.contributionAssociations){
                        this.filePatternAssociations.push(contributionAssociation);
                    }
                }
                getResolvedSchema(schemaId) {
                    const id = normalizeId(schemaId);
                    const schemaHandle = this.schemasById[id];
                    if (schemaHandle) {
                        return schemaHandle.getResolvedSchema();
                    }
                    return this.promise.resolve(undefined);
                }
                loadSchema(url) {
                    if (!this.requestService) {
                        const errorMessage = t('Unable to load schema from \'{0}\'. No schema request service available', toDisplayString(url));
                        return this.promise.resolve(new UnresolvedSchema({}, [
                            errorMessage
                        ]));
                    }
                    return this.requestService(url).then((content)=>{
                        if (!content) {
                            const errorMessage = t('Unable to load schema from \'{0}\': No content.', toDisplayString(url));
                            return new UnresolvedSchema({}, [
                                errorMessage
                            ]);
                        }
                        const errors = [];
                        if (content.charCodeAt(0) === 65279) {
                            errors.push(t('Problem reading content from \'{0}\': UTF-8 with BOM detected, only UTF 8 is allowed.', toDisplayString(url)));
                            content = content.trimStart();
                        }
                        let schemaContent = {};
                        const jsonErrors = [];
                        schemaContent = main_parse(content, jsonErrors);
                        if (jsonErrors.length) {
                            errors.push(t('Unable to parse content from \'{0}\': Parse error at offset {1}.', toDisplayString(url), jsonErrors[0].offset));
                        }
                        return new UnresolvedSchema(schemaContent, errors);
                    }, (error)=>{
                        let errorMessage = error.toString();
                        const errorSplit = error.toString().split('Error: ');
                        if (errorSplit.length > 1) {
                            // more concise error message, URL and context are attached by caller anyways
                            errorMessage = errorSplit[1];
                        }
                        if (endsWith(errorMessage, '.')) {
                            errorMessage = errorMessage.substr(0, errorMessage.length - 1);
                        }
                        return new UnresolvedSchema({}, [
                            t('Unable to load schema from \'{0}\': {1}.', toDisplayString(url), errorMessage)
                        ]);
                    });
                }
                resolveSchemaContent(schemaToResolve, handle) {
                    const resolveErrors = schemaToResolve.errors.slice(0);
                    const schema = schemaToResolve.schema;
                    let schemaDraft = schema.$schema ? normalizeId(schema.$schema) : undefined;
                    if (schemaDraft === 'http://json-schema.org/draft-03/schema') {
                        return this.promise.resolve(new ResolvedSchema({}, [
                            t("Draft-03 schemas are not supported.")
                        ], [], schemaDraft));
                    }
                    let usesUnsupportedFeatures = new Set();
                    const contextService = this.contextService;
                    const findSectionByJSONPointer = (schema, path)=>{
                        path = decodeURIComponent(path);
                        let current = schema;
                        if (path[0] === '/') {
                            path = path.substring(1);
                        }
                        path.split('/').some((part)=>{
                            part = part.replace(/~1/g, '/').replace(/~0/g, '~');
                            current = current[part];
                            return !current;
                        });
                        return current;
                    };
                    const findSchemaById = (schema, handle, id)=>{
                        if (!handle.anchors) {
                            handle.anchors = collectAnchors(schema);
                        }
                        return handle.anchors.get(id);
                    };
                    const merge = (target, section)=>{
                        for(const key in section){
                            if (section.hasOwnProperty(key) && key !== 'id' && key !== '$id') {
                                target[key] = section[key];
                            }
                        }
                    };
                    const mergeRef = (target, sourceRoot, sourceHandle, refSegment)=>{
                        let section;
                        if (refSegment === undefined || refSegment.length === 0) {
                            section = sourceRoot;
                        } else if (refSegment.charAt(0) === '/') {
                            // A $ref to a JSON Pointer (i.e #/definitions/foo)
                            section = findSectionByJSONPointer(sourceRoot, refSegment);
                        } else {
                            // A $ref to a sub-schema with an $id (i.e #hello)
                            section = findSchemaById(sourceRoot, sourceHandle, refSegment);
                        }
                        if (section) {
                            merge(target, section);
                        } else {
                            resolveErrors.push(t('$ref \'{0}\' in \'{1}\' can not be resolved.', refSegment || '', sourceHandle.uri));
                        }
                    };
                    const resolveExternalLink = (node, uri, refSegment, parentHandle)=>{
                        if (contextService && !/^[A-Za-z][A-Za-z0-9+\-.+]*:\/\/.*/.test(uri)) {
                            uri = contextService.resolveRelativePath(uri, parentHandle.uri);
                        }
                        uri = normalizeId(uri);
                        const referencedHandle = this.getOrAddSchemaHandle(uri);
                        return referencedHandle.getUnresolvedSchema().then((unresolvedSchema)=>{
                            parentHandle.dependencies.add(uri);
                            if (unresolvedSchema.errors.length) {
                                const loc = refSegment ? uri + '#' + refSegment : uri;
                                resolveErrors.push(t('Problems loading reference \'{0}\': {1}', loc, unresolvedSchema.errors[0]));
                            }
                            mergeRef(node, unresolvedSchema.schema, referencedHandle, refSegment);
                            return resolveRefs(node, unresolvedSchema.schema, referencedHandle);
                        });
                    };
                    const resolveRefs = (node, parentSchema, parentHandle)=>{
                        const openPromises = [];
                        this.traverseNodes(node, (next)=>{
                            const seenRefs = new Set();
                            while(next.$ref){
                                const ref = next.$ref;
                                const segments = ref.split('#', 2);
                                delete next.$ref;
                                if (segments[0].length > 0) {
                                    // This is a reference to an external schema
                                    openPromises.push(resolveExternalLink(next, segments[0], segments[1], parentHandle));
                                    return;
                                } else {
                                    // This is a reference inside the current schema
                                    if (!seenRefs.has(ref)) {
                                        const id = segments[1];
                                        mergeRef(next, parentSchema, parentHandle, id);
                                        seenRefs.add(ref);
                                    }
                                }
                            }
                            if (next.$recursiveRef) {
                                usesUnsupportedFeatures.add('$recursiveRef');
                            }
                            if (next.$dynamicRef) {
                                usesUnsupportedFeatures.add('$dynamicRef');
                            }
                        });
                        return this.promise.all(openPromises);
                    };
                    const collectAnchors = (root)=>{
                        const result = new Map();
                        this.traverseNodes(root, (next)=>{
                            const id = next.$id || next.id;
                            const anchor = isString(id) && id.charAt(0) === '#' ? id.substring(1) : next.$anchor;
                            if (anchor) {
                                if (result.has(anchor)) {
                                    resolveErrors.push(t('Duplicate anchor declaration: \'{0}\'', anchor));
                                } else {
                                    result.set(anchor, next);
                                }
                            }
                            if (next.$recursiveAnchor) {
                                usesUnsupportedFeatures.add('$recursiveAnchor');
                            }
                            if (next.$dynamicAnchor) {
                                usesUnsupportedFeatures.add('$dynamicAnchor');
                            }
                        });
                        return result;
                    };
                    return resolveRefs(schema, schema, handle).then((_)=>{
                        let resolveWarnings = [];
                        if (usesUnsupportedFeatures.size) {
                            resolveWarnings.push(t('The schema uses meta-schema features ({0}) that are not yet supported by the validator.', Array.from(usesUnsupportedFeatures.keys()).join(', ')));
                        }
                        return new ResolvedSchema(schema, resolveErrors, resolveWarnings, schemaDraft);
                    });
                }
                traverseNodes(root, handle) {
                    if (!root || typeof root !== 'object') {
                        return Promise.resolve(null);
                    }
                    const seen = new Set();
                    const collectEntries = (...entries)=>{
                        for (const entry of entries){
                            if (isObject(entry)) {
                                toWalk.push(entry);
                            }
                        }
                    };
                    const collectMapEntries = (...maps)=>{
                        for (const map of maps){
                            if (isObject(map)) {
                                for(const k in map){
                                    const key = k;
                                    const entry = map[key];
                                    if (isObject(entry)) {
                                        toWalk.push(entry);
                                    }
                                }
                            }
                        }
                    };
                    const collectArrayEntries = (...arrays)=>{
                        for (const array of arrays){
                            if (Array.isArray(array)) {
                                for (const entry of array){
                                    if (isObject(entry)) {
                                        toWalk.push(entry);
                                    }
                                }
                            }
                        }
                    };
                    const collectEntryOrArrayEntries = (items)=>{
                        if (Array.isArray(items)) {
                            for (const entry of items){
                                if (isObject(entry)) {
                                    toWalk.push(entry);
                                }
                            }
                        } else if (isObject(items)) {
                            toWalk.push(items);
                        }
                    };
                    const toWalk = [
                        root
                    ];
                    let next = toWalk.pop();
                    while(next){
                        if (!seen.has(next)) {
                            seen.add(next);
                            handle(next);
                            collectEntries(next.additionalItems, next.additionalProperties, next.not, next.contains, next.propertyNames, next.if, next.then, next.else, next.unevaluatedItems, next.unevaluatedProperties);
                            collectMapEntries(next.definitions, next.$defs, next.properties, next.patternProperties, next.dependencies, next.dependentSchemas);
                            collectArrayEntries(next.anyOf, next.allOf, next.oneOf, next.prefixItems);
                            collectEntryOrArrayEntries(next.items);
                        }
                        next = toWalk.pop();
                    }
                }
                getSchemaFromProperty(resource, document1) {
                    var _document_root;
                    if (((_document_root = document1.root) === null || _document_root === void 0 ? void 0 : _document_root.type) === 'object') {
                        for (const p of document1.root.properties){
                            var _p_valueNode;
                            if (p.keyNode.value === '$schema' && ((_p_valueNode = p.valueNode) === null || _p_valueNode === void 0 ? void 0 : _p_valueNode.type) === 'string') {
                                let schemaId = p.valueNode.value;
                                if (this.contextService && !/^\w[\w\d+.-]*:/.test(schemaId)) {
                                    schemaId = this.contextService.resolveRelativePath(schemaId, resource);
                                }
                                return schemaId;
                            }
                        }
                    }
                    return undefined;
                }
                getAssociatedSchemas(resource) {
                    const seen = Object.create(null);
                    const schemas = [];
                    const normalizedResource = normalizeResourceForMatching(resource);
                    for (const entry of this.filePatternAssociations){
                        if (entry.matchesPattern(normalizedResource)) {
                            for (const schemaId of entry.getURIs()){
                                if (!seen[schemaId]) {
                                    schemas.push(schemaId);
                                    seen[schemaId] = true;
                                }
                            }
                        }
                    }
                    return schemas;
                }
                getSchemaURIsForResource(resource, document1) {
                    let schemeId = document1 && this.getSchemaFromProperty(resource, document1);
                    if (schemeId) {
                        return [
                            schemeId
                        ];
                    }
                    return this.getAssociatedSchemas(resource);
                }
                getSchemaForResource(resource, document1) {
                    if (document1) {
                        // first use $schema if present
                        let schemeId = this.getSchemaFromProperty(resource, document1);
                        if (schemeId) {
                            const id = normalizeId(schemeId);
                            return this.getOrAddSchemaHandle(id).getResolvedSchema();
                        }
                    }
                    if (this.cachedSchemaForResource && this.cachedSchemaForResource.resource === resource) {
                        return this.cachedSchemaForResource.resolvedSchema;
                    }
                    const schemas = this.getAssociatedSchemas(resource);
                    const resolvedSchema = schemas.length > 0 ? this.createCombinedSchema(resource, schemas).getResolvedSchema() : this.promise.resolve(undefined);
                    this.cachedSchemaForResource = {
                        resource,
                        resolvedSchema
                    };
                    return resolvedSchema;
                }
                createCombinedSchema(resource, schemaIds) {
                    if (schemaIds.length === 1) {
                        return this.getOrAddSchemaHandle(schemaIds[0]);
                    } else {
                        const combinedSchemaId = 'schemaservice://combinedSchema/' + encodeURIComponent(resource);
                        const combinedSchema = {
                            allOf: schemaIds.map((schemaId)=>({
                                    $ref: schemaId
                                }))
                        };
                        return this.addSchemaHandle(combinedSchemaId, combinedSchema);
                    }
                }
                getMatchingSchemas(document1, jsonDocument, schema) {
                    if (schema) {
                        const id = schema.id || 'schemaservice://untitled/matchingSchemas/' + jsonSchemaService_idCounter++;
                        const handle = this.addSchemaHandle(id, schema);
                        return handle.getResolvedSchema().then((resolvedSchema)=>{
                            return jsonDocument.getMatchingSchemas(resolvedSchema.schema).filter((s)=>!s.inverted);
                        });
                    }
                    return this.getSchemaForResource(document1.uri, jsonDocument).then((schema)=>{
                        if (schema) {
                            return jsonDocument.getMatchingSchemas(schema.schema).filter((s)=>!s.inverted);
                        }
                        return [];
                    });
                }
                constructor(requestService, contextService, promiseConstructor){
                    this.contextService = contextService;
                    this.requestService = requestService;
                    this.promiseConstructor = promiseConstructor || Promise;
                    this.callOnDispose = [];
                    this.contributionSchemas = {};
                    this.contributionAssociations = [];
                    this.schemasById = {};
                    this.filePatternAssociations = [];
                    this.registeredSchemasIds = {};
                }
            }
            let jsonSchemaService_idCounter = 0;
            function normalizeId(id) {
                // remove trailing '#', normalize drive capitalization
                try {
                    return URI.parse(id).toString(true);
                } catch (e) {
                    return id;
                }
            }
            function normalizeResourceForMatching(resource) {
                // remove queries and fragments, normalize drive capitalization
                try {
                    return URI.parse(resource).with({
                        fragment: null,
                        query: null
                    }).toString(true);
                } catch (e) {
                    return resource;
                }
            }
            function toDisplayString(url) {
                try {
                    const uri = URI.parse(url);
                    if (uri.scheme === 'file') {
                        return uri.fsPath;
                    }
                } catch (e) {
                // ignore
                }
                return url;
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/services/jsonFolding.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ function getFoldingRanges(document1, context) {
                const ranges = [];
                const nestingLevels = [];
                const stack = [];
                let prevStart = -1;
                const scanner = main_createScanner(document1.getText(), false);
                let token = scanner.scan();
                function addRange(range) {
                    ranges.push(range);
                    nestingLevels.push(stack.length);
                }
                while(token !== 17 /* SyntaxKind.EOF */ ){
                    switch(token){
                        case 1 /* SyntaxKind.OpenBraceToken */ :
                        case 3 /* SyntaxKind.OpenBracketToken */ :
                            {
                                const startLine = document1.positionAt(scanner.getTokenOffset()).line;
                                const range = {
                                    startLine,
                                    endLine: startLine,
                                    kind: token === 1 /* SyntaxKind.OpenBraceToken */  ? 'object' : 'array'
                                };
                                stack.push(range);
                                break;
                            }
                        case 2 /* SyntaxKind.CloseBraceToken */ :
                        case 4 /* SyntaxKind.CloseBracketToken */ :
                            {
                                const kind = token === 2 /* SyntaxKind.CloseBraceToken */  ? 'object' : 'array';
                                if (stack.length > 0 && stack[stack.length - 1].kind === kind) {
                                    const range = stack.pop();
                                    const line = document1.positionAt(scanner.getTokenOffset()).line;
                                    if (range && line > range.startLine + 1 && prevStart !== range.startLine) {
                                        range.endLine = line - 1;
                                        addRange(range);
                                        prevStart = range.startLine;
                                    }
                                }
                                break;
                            }
                        case 13 /* SyntaxKind.BlockCommentTrivia */ :
                            {
                                const startLine = document1.positionAt(scanner.getTokenOffset()).line;
                                const endLine = document1.positionAt(scanner.getTokenOffset() + scanner.getTokenLength()).line;
                                if (scanner.getTokenError() === 1 /* ScanError.UnexpectedEndOfComment */  && startLine + 1 < document1.lineCount) {
                                    scanner.setPosition(document1.offsetAt(main.Position.create(startLine + 1, 0)));
                                } else {
                                    if (startLine < endLine) {
                                        addRange({
                                            startLine,
                                            endLine,
                                            kind: main.FoldingRangeKind.Comment
                                        });
                                        prevStart = startLine;
                                    }
                                }
                                break;
                            }
                        case 12 /* SyntaxKind.LineCommentTrivia */ :
                            {
                                const text = document1.getText().substr(scanner.getTokenOffset(), scanner.getTokenLength());
                                const m = text.match(/^\/\/\s*#(region\b)|(endregion\b)/);
                                if (m) {
                                    const line = document1.positionAt(scanner.getTokenOffset()).line;
                                    if (m[1]) {
                                        const range = {
                                            startLine: line,
                                            endLine: line,
                                            kind: main.FoldingRangeKind.Region
                                        };
                                        stack.push(range);
                                    } else {
                                        let i = stack.length - 1;
                                        while(i >= 0 && stack[i].kind !== main.FoldingRangeKind.Region){
                                            i--;
                                        }
                                        if (i >= 0) {
                                            const range = stack[i];
                                            stack.length = i;
                                            if (line > range.startLine && prevStart !== range.startLine) {
                                                range.endLine = line;
                                                addRange(range);
                                                prevStart = range.startLine;
                                            }
                                        }
                                    }
                                }
                                break;
                            }
                    }
                    token = scanner.scan();
                }
                const rangeLimit = context && context.rangeLimit;
                if (typeof rangeLimit !== 'number' || ranges.length <= rangeLimit) {
                    return ranges;
                }
                if (context && context.onRangeLimitExceeded) {
                    context.onRangeLimitExceeded(document1.uri);
                }
                const counts = [];
                for (let level of nestingLevels){
                    if (level < 30) {
                        counts[level] = (counts[level] || 0) + 1;
                    }
                }
                let entries = 0;
                let maxLevel = 0;
                for(let i = 0; i < counts.length; i++){
                    const n = counts[i];
                    if (n) {
                        if (n + entries > rangeLimit) {
                            maxLevel = i;
                            break;
                        }
                        entries += n;
                    }
                }
                const result = [];
                for(let i = 0; i < ranges.length; i++){
                    const level = nestingLevels[i];
                    if (typeof level === 'number') {
                        if (level < maxLevel || level === maxLevel && entries++ < rangeLimit) {
                            result.push(ranges[i]);
                        }
                    }
                }
                return result;
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/services/jsonSelectionRanges.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ function getSelectionRanges(document1, positions, doc) {
                function getSelectionRange(position) {
                    let offset = document1.offsetAt(position);
                    let node = doc.getNodeFromOffset(offset, true);
                    const result = [];
                    while(node){
                        switch(node.type){
                            case 'string':
                            case 'object':
                            case 'array':
                                // range without ", [ or {
                                const cStart = node.offset + 1, cEnd = node.offset + node.length - 1;
                                if (cStart < cEnd && offset >= cStart && offset <= cEnd) {
                                    result.push(newRange(cStart, cEnd));
                                }
                                result.push(newRange(node.offset, node.offset + node.length));
                                break;
                            case 'number':
                            case 'boolean':
                            case 'null':
                            case 'property':
                                result.push(newRange(node.offset, node.offset + node.length));
                                break;
                        }
                        if (node.type === 'property' || node.parent && node.parent.type === 'array') {
                            const afterCommaOffset = getOffsetAfterNextToken(node.offset + node.length, 5 /* SyntaxKind.CommaToken */ );
                            if (afterCommaOffset !== -1) {
                                result.push(newRange(node.offset, afterCommaOffset));
                            }
                        }
                        node = node.parent;
                    }
                    let current = undefined;
                    for(let index = result.length - 1; index >= 0; index--){
                        current = main.SelectionRange.create(result[index], current);
                    }
                    if (!current) {
                        current = main.SelectionRange.create(main.Range.create(position, position));
                    }
                    return current;
                }
                function newRange(start, end) {
                    return main.Range.create(document1.positionAt(start), document1.positionAt(end));
                }
                const scanner = main_createScanner(document1.getText(), true);
                function getOffsetAfterNextToken(offset, expectedToken) {
                    scanner.setPosition(offset);
                    let token = scanner.scan();
                    if (token === expectedToken) {
                        return scanner.getTokenOffset() + scanner.getTokenLength();
                    }
                    return -1;
                }
                return positions.map(getSelectionRange);
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/utils/format.js
            function utils_format_format(documentToFormat, formattingOptions, formattingRange) {
                var _formattingOptions, _formattingOptions1, _formattingOptions2;
                let range = undefined;
                if (formattingRange) {
                    const offset = documentToFormat.offsetAt(formattingRange.start);
                    const length = documentToFormat.offsetAt(formattingRange.end) - offset;
                    range = {
                        offset,
                        length
                    };
                }
                const options = {
                    tabSize: formattingOptions ? formattingOptions.tabSize : 4,
                    insertSpaces: ((_formattingOptions = formattingOptions) === null || _formattingOptions === void 0 ? void 0 : _formattingOptions.insertSpaces) === true,
                    insertFinalNewline: ((_formattingOptions1 = formattingOptions) === null || _formattingOptions1 === void 0 ? void 0 : _formattingOptions1.insertFinalNewline) === true,
                    eol: '\n',
                    keepLines: ((_formattingOptions2 = formattingOptions) === null || _formattingOptions2 === void 0 ? void 0 : _formattingOptions2.keepLines) === true
                };
                return main_format(documentToFormat.getText(), range, options).map((edit1)=>{
                    return main.TextEdit.replace(main.Range.create(documentToFormat.positionAt(edit1.offset), documentToFormat.positionAt(edit1.offset + edit1.length)), edit1.content);
                });
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/utils/propertyTree.js
            /*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/ var Container;
            (function(Container) {
                Container[Container["Object"] = 0] = "Object";
                Container[Container["Array"] = 1] = "Array";
            })(Container || (Container = {}));
            class PropertyTree {
                addChildProperty(childProperty) {
                    childProperty.parent = this;
                    if (this.childrenProperties.length > 0) {
                        let insertionIndex = 0;
                        if (childProperty.noKeyName) {
                            insertionIndex = this.childrenProperties.length;
                        } else {
                            insertionIndex = binarySearchOnPropertyArray(this.childrenProperties, childProperty, compareProperties);
                        }
                        if (insertionIndex < 0) {
                            insertionIndex = insertionIndex * -1 - 1;
                        }
                        this.childrenProperties.splice(insertionIndex, 0, childProperty);
                    } else {
                        this.childrenProperties.push(childProperty);
                    }
                    return childProperty;
                }
                constructor(propertyName, beginningLineNumber){
                    this.propertyName = propertyName !== null && propertyName !== void 0 ? propertyName : '';
                    this.beginningLineNumber = beginningLineNumber;
                    this.childrenProperties = [];
                    this.lastProperty = false;
                    this.noKeyName = false;
                }
            }
            function compareProperties(propertyTree1, propertyTree2) {
                const propertyName1 = propertyTree1.propertyName.toLowerCase();
                const propertyName2 = propertyTree2.propertyName.toLowerCase();
                if (propertyName1 < propertyName2) {
                    return -1;
                } else if (propertyName1 > propertyName2) {
                    return 1;
                }
                return 0;
            }
            function binarySearchOnPropertyArray(propertyTreeArray, propertyTree, compare_fn) {
                const propertyName = propertyTree.propertyName.toLowerCase();
                const firstPropertyInArrayName = propertyTreeArray[0].propertyName.toLowerCase();
                const lastPropertyInArrayName = propertyTreeArray[propertyTreeArray.length - 1].propertyName.toLowerCase();
                if (propertyName < firstPropertyInArrayName) {
                    return 0;
                }
                if (propertyName > lastPropertyInArrayName) {
                    return propertyTreeArray.length;
                }
                let m = 0;
                let n = propertyTreeArray.length - 1;
                while(m <= n){
                    let k = n + m >> 1;
                    let cmp = compare_fn(propertyTree, propertyTreeArray[k]);
                    if (cmp > 0) {
                        m = k + 1;
                    } else if (cmp < 0) {
                        n = k - 1;
                    } else {
                        return k;
                    }
                }
                return -m - 1;
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/utils/sort.js
            /*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/ // import { TextEdit} from 'vscode-languageserver-textdocument';
            function sort(documentToSort, formattingOptions) {
                const options = {
                    ...formattingOptions,
                    keepLines: false
                };
                const formattedJsonString = esm_main /* TextDocument */ .n.applyEdits(documentToSort, utils_format_format(documentToSort, options, undefined));
                const formattedJsonDocument = esm_main /* TextDocument */ .n.create('test://test.json', 'json', 0, formattedJsonString);
                const jsonPropertyTree = findJsoncPropertyTree(formattedJsonDocument);
                const sortedJsonDocument = sortJsoncDocument(formattedJsonDocument, jsonPropertyTree);
                const edits = utils_format_format(sortedJsonDocument, options, undefined);
                const sortedAndFormattedJsonDocument = esm_main /* TextDocument */ .n.applyEdits(sortedJsonDocument, edits);
                return [
                    main.TextEdit.replace(main.Range.create(main.Position.create(0, 0), documentToSort.positionAt(documentToSort.getText().length)), sortedAndFormattedJsonDocument)
                ];
            }
            function findJsoncPropertyTree(formattedDocument) {
                const formattedString = formattedDocument.getText();
                const scanner = main_createScanner(formattedString, false);
                // The tree that will be returned
                let rootTree = new PropertyTree();
                // The tree where the current properties can be added as children
                let currentTree = rootTree;
                // The tree representing the current property analyzed
                let currentProperty = rootTree;
                // The tree representing the previous property analyzed
                let lastProperty = rootTree;
                // The current scanned token
                let token = undefined;
                // Line number of the last token found
                let lastTokenLine = 0;
                // Total number of characters on the lines prior to current line 
                let numberOfCharactersOnPreviousLines = 0;
                // The last token scanned that is not trivial, nor a comment
                let lastNonTriviaNonCommentToken = undefined;
                // The second to last token scanned that is not trivial, nor a comment
                let secondToLastNonTriviaNonCommentToken = undefined;
                // Line number of last token that is not trivial, nor a comment
                let lineOfLastNonTriviaNonCommentToken = -1;
                // End index on its line of last token that is not trivial, nor a comment
                let endIndexOfLastNonTriviaNonCommentToken = -1;
                // Line number of the start of the range of current/next property
                let beginningLineNumber = 0;
                // Line number of the end of the range of current/next property
                let endLineNumber = 0;
                // Stack indicating whether we are inside of an object or an array
                let currentContainerStack = [];
                // Boolean indicating that the current property end line number needs to be updated. Used only when block comments are encountered.
                let updateLastPropertyEndLineNumber = false;
                // Boolean indicating that the beginning line number should be updated. Used only when block comments are encountered. 
                let updateBeginningLineNumber = false;
                while((token = scanner.scan()) !== 17 /* SyntaxKind.EOF */ ){
                    // In the case when a block comment has been encountered that starts on the same line as the comma ending a property, update the end line of that
                    // property so that it covers the block comment. For example, if we have: 
                    // 1. "key" : {}, /* some block
                    // 2. comment */
                    // Then, the end line of the property "key" should be line 2 not line 1
                    if (updateLastPropertyEndLineNumber === true && token !== 14 /* SyntaxKind.LineBreakTrivia */  && token !== 15 /* SyntaxKind.Trivia */  && token !== 12 /* SyntaxKind.LineCommentTrivia */  && token !== 13 /* SyntaxKind.BlockCommentTrivia */  && currentProperty.endLineNumber === undefined) {
                        let endLineNumber = scanner.getTokenStartLine();
                        // Update the end line number in the case when the last property visited is a container (object or array)
                        if (secondToLastNonTriviaNonCommentToken === 2 /* SyntaxKind.CloseBraceToken */  || secondToLastNonTriviaNonCommentToken === 4 /* SyntaxKind.CloseBracketToken */ ) {
                            lastProperty.endLineNumber = endLineNumber - 1;
                        } else {
                            currentProperty.endLineNumber = endLineNumber - 1;
                        }
                        beginningLineNumber = endLineNumber;
                        updateLastPropertyEndLineNumber = false;
                    }
                    // When a block comment follows an open brace or an open bracket, that block comment should be associated to that brace or bracket, not the property below it. For example, for:
                    // 1. { /*
                    // 2. ... */
                    // 3. "key" : {}
                    // 4. }
                    // Instead of associating the block comment to the property on line 3, it is associate to the property on line 1
                    if (updateBeginningLineNumber === true && token !== 14 /* SyntaxKind.LineBreakTrivia */  && token !== 15 /* SyntaxKind.Trivia */  && token !== 12 /* SyntaxKind.LineCommentTrivia */  && token !== 13 /* SyntaxKind.BlockCommentTrivia */ ) {
                        beginningLineNumber = scanner.getTokenStartLine();
                        updateBeginningLineNumber = false;
                    }
                    // Update the number of characters on all the previous lines each time the new token is on a different line to the previous token
                    if (scanner.getTokenStartLine() !== lastTokenLine) {
                        for(let i = lastTokenLine; i < scanner.getTokenStartLine(); i++){
                            const lengthOfLine = formattedDocument.getText(main.Range.create(main.Position.create(i, 0), main.Position.create(i + 1, 0))).length;
                            numberOfCharactersOnPreviousLines = numberOfCharactersOnPreviousLines + lengthOfLine;
                        }
                        lastTokenLine = scanner.getTokenStartLine();
                    }
                    switch(token){
                        // When a string is found, if it follows an open brace or a comma token and it is within an object, then it corresponds to a key name, not a simple string
                        case 10 /* SyntaxKind.StringLiteral */ :
                            {
                                if (lastNonTriviaNonCommentToken === undefined || lastNonTriviaNonCommentToken === 1 /* SyntaxKind.OpenBraceToken */  || lastNonTriviaNonCommentToken === 5 /* SyntaxKind.CommaToken */  && currentContainerStack[currentContainerStack.length - 1] === Container.Object) {
                                    // In that case create the child property which starts at beginningLineNumber, add it to the current tree
                                    const childProperty = new PropertyTree(scanner.getTokenValue(), beginningLineNumber);
                                    lastProperty = currentProperty;
                                    currentProperty = currentTree.addChildProperty(childProperty);
                                }
                                break;
                            }
                        // When the token is an open bracket, then we enter into an array
                        case 3 /* SyntaxKind.OpenBracketToken */ :
                            {
                                // If the root tree beginning line number is not defined, then this open bracket is the first open bracket in the document
                                if (rootTree.beginningLineNumber === undefined) {
                                    rootTree.beginningLineNumber = scanner.getTokenStartLine();
                                }
                                // Suppose we are inside of an object, then the current array is associated to a key, and has already been created
                                // We have the following configuration: {"a": "val", "array": [...], "b": "val"}
                                // In that case navigate down to the child property
                                if (currentContainerStack[currentContainerStack.length - 1] === Container.Object) {
                                    currentTree = currentProperty;
                                } else if (currentContainerStack[currentContainerStack.length - 1] === Container.Array) {
                                    const childProperty = new PropertyTree(scanner.getTokenValue(), beginningLineNumber);
                                    childProperty.noKeyName = true;
                                    lastProperty = currentProperty;
                                    currentProperty = currentTree.addChildProperty(childProperty);
                                    currentTree = currentProperty;
                                }
                                currentContainerStack.push(Container.Array);
                                currentProperty.type = Container.Array;
                                beginningLineNumber = scanner.getTokenStartLine();
                                beginningLineNumber++;
                                break;
                            }
                        // When the token is an open brace, then we enter into an object
                        case 1 /* SyntaxKind.OpenBraceToken */ :
                            {
                                // If the root tree beginning line number is not defined, then this open brace is the first open brace in the document
                                if (rootTree.beginningLineNumber === undefined) {
                                    rootTree.beginningLineNumber = scanner.getTokenStartLine();
                                } else if (currentContainerStack[currentContainerStack.length - 1] === Container.Array) {
                                    const childProperty = new PropertyTree(scanner.getTokenValue(), beginningLineNumber);
                                    childProperty.noKeyName = true;
                                    lastProperty = currentProperty;
                                    currentProperty = currentTree.addChildProperty(childProperty);
                                }
                                currentProperty.type = Container.Object;
                                currentContainerStack.push(Container.Object);
                                currentTree = currentProperty;
                                beginningLineNumber = scanner.getTokenStartLine();
                                beginningLineNumber++;
                                break;
                            }
                        case 4 /* SyntaxKind.CloseBracketToken */ :
                            {
                                endLineNumber = scanner.getTokenStartLine();
                                currentContainerStack.pop();
                                // If the last non-trivial non-comment token is a closing brace or bracket, then the currentProperty end line number has not been set yet so set it
                                // The configuration considered is: [..., {}] or [..., []]
                                if (currentProperty.endLineNumber === undefined && (lastNonTriviaNonCommentToken === 2 /* SyntaxKind.CloseBraceToken */  || lastNonTriviaNonCommentToken === 4 /* SyntaxKind.CloseBracketToken */ )) {
                                    currentProperty.endLineNumber = endLineNumber - 1;
                                    currentProperty.lastProperty = true;
                                    currentProperty.lineWhereToAddComma = lineOfLastNonTriviaNonCommentToken;
                                    currentProperty.indexWhereToAddComa = endIndexOfLastNonTriviaNonCommentToken;
                                    lastProperty = currentProperty;
                                    currentProperty = currentProperty ? currentProperty.parent : undefined;
                                    currentTree = currentProperty;
                                }
                                rootTree.endLineNumber = endLineNumber;
                                beginningLineNumber = endLineNumber + 1;
                                break;
                            }
                        case 2 /* SyntaxKind.CloseBraceToken */ :
                            {
                                endLineNumber = scanner.getTokenStartLine();
                                currentContainerStack.pop();
                                // If we are not inside of an empty object and current property end line number has not yet been defined, define it
                                if (lastNonTriviaNonCommentToken !== 1 /* SyntaxKind.OpenBraceToken */  && currentProperty.endLineNumber === undefined) {
                                    currentProperty.endLineNumber = endLineNumber - 1;
                                    // The current property is also the last property
                                    currentProperty.lastProperty = true;
                                    // The last property of an object is associated with the line and index of where to add the comma, in case after sorting, it is no longer the last property
                                    currentProperty.lineWhereToAddComma = lineOfLastNonTriviaNonCommentToken;
                                    currentProperty.indexWhereToAddComa = endIndexOfLastNonTriviaNonCommentToken;
                                    lastProperty = currentProperty;
                                    currentProperty = currentProperty ? currentProperty.parent : undefined;
                                    currentTree = currentProperty;
                                }
                                rootTree.endLineNumber = scanner.getTokenStartLine();
                                beginningLineNumber = endLineNumber + 1;
                                break;
                            }
                        case 5 /* SyntaxKind.CommaToken */ :
                            {
                                endLineNumber = scanner.getTokenStartLine();
                                // If the current container is an object or the current container is an array and the last non-trivia non-comment token is a closing brace or a closing bracket
                                // Then update the end line number of the current property
                                if (currentProperty.endLineNumber === undefined && (currentContainerStack[currentContainerStack.length - 1] === Container.Object || currentContainerStack[currentContainerStack.length - 1] === Container.Array && (lastNonTriviaNonCommentToken === 2 /* SyntaxKind.CloseBraceToken */  || lastNonTriviaNonCommentToken === 4 /* SyntaxKind.CloseBracketToken */ ))) {
                                    currentProperty.endLineNumber = endLineNumber;
                                    // Store the line and the index of the comma in case it needs to be removed during the sorting
                                    currentProperty.commaIndex = scanner.getTokenOffset() - numberOfCharactersOnPreviousLines;
                                    currentProperty.commaLine = endLineNumber;
                                }
                                if (lastNonTriviaNonCommentToken === 2 /* SyntaxKind.CloseBraceToken */  || lastNonTriviaNonCommentToken === 4 /* SyntaxKind.CloseBracketToken */ ) {
                                    lastProperty = currentProperty;
                                    currentProperty = currentProperty ? currentProperty.parent : undefined;
                                    currentTree = currentProperty;
                                }
                                beginningLineNumber = endLineNumber + 1;
                                break;
                            }
                        case 13 /* SyntaxKind.BlockCommentTrivia */ :
                            {
                                // If the last non trivia non-comment token is a comma and the block comment starts on the same line as the comma, then update the end line number of the current property. For example if:
                                // 1. {}, /* ...
                                // 2. ..*/
                                // The the property on line 1 shoud end on line 2, not line 1
                                // In the case we are in an array we update the end line number only if the second to last non-trivia non-comment token is a closing brace or bracket
                                if (lastNonTriviaNonCommentToken === 5 /* SyntaxKind.CommaToken */  && lineOfLastNonTriviaNonCommentToken === scanner.getTokenStartLine() && (currentContainerStack[currentContainerStack.length - 1] === Container.Array && (secondToLastNonTriviaNonCommentToken === 2 /* SyntaxKind.CloseBraceToken */  || secondToLastNonTriviaNonCommentToken === 4 /* SyntaxKind.CloseBracketToken */ ) || currentContainerStack[currentContainerStack.length - 1] === Container.Object)) {
                                    if (currentContainerStack[currentContainerStack.length - 1] === Container.Array && (secondToLastNonTriviaNonCommentToken === 2 /* SyntaxKind.CloseBraceToken */  || secondToLastNonTriviaNonCommentToken === 4 /* SyntaxKind.CloseBracketToken */ ) || currentContainerStack[currentContainerStack.length - 1] === Container.Object) {
                                        currentProperty.endLineNumber = undefined;
                                        updateLastPropertyEndLineNumber = true;
                                    }
                                }
                                // When the block comment follows an open brace or an open token, we have the following scenario:
                                // { /**
                                // ../
                                // }
                                // The block comment should be assigned to the open brace not the first property below it
                                if ((lastNonTriviaNonCommentToken === 1 /* SyntaxKind.OpenBraceToken */  || lastNonTriviaNonCommentToken === 3 /* SyntaxKind.OpenBracketToken */ ) && lineOfLastNonTriviaNonCommentToken === scanner.getTokenStartLine()) {
                                    updateBeginningLineNumber = true;
                                }
                                break;
                            }
                    }
                    // Update the last and second to last non-trivia non-comment tokens
                    if (token !== 14 /* SyntaxKind.LineBreakTrivia */  && token !== 13 /* SyntaxKind.BlockCommentTrivia */  && token !== 12 /* SyntaxKind.LineCommentTrivia */  && token !== 15 /* SyntaxKind.Trivia */ ) {
                        secondToLastNonTriviaNonCommentToken = lastNonTriviaNonCommentToken;
                        lastNonTriviaNonCommentToken = token;
                        lineOfLastNonTriviaNonCommentToken = scanner.getTokenStartLine();
                        endIndexOfLastNonTriviaNonCommentToken = scanner.getTokenOffset() + scanner.getTokenLength() - numberOfCharactersOnPreviousLines;
                    }
                }
                return rootTree;
            }
            function sortJsoncDocument(jsonDocument, propertyTree) {
                if (propertyTree.childrenProperties.length === 0) {
                    return jsonDocument;
                }
                const sortedJsonDocument = esm_main /* TextDocument */ .n.create('test://test.json', 'json', 0, jsonDocument.getText());
                const queueToSort = [];
                updateSortingQueue(queueToSort, propertyTree, propertyTree.beginningLineNumber);
                while(queueToSort.length > 0){
                    const dataToSort = queueToSort.shift();
                    const propertyTreeArray = dataToSort.propertyTreeArray;
                    let beginningLineNumber = dataToSort.beginningLineNumber;
                    for(let i = 0; i < propertyTreeArray.length; i++){
                        const propertyTree = propertyTreeArray[i];
                        const range = main.Range.create(main.Position.create(propertyTree.beginningLineNumber, 0), main.Position.create(propertyTree.endLineNumber + 1, 0));
                        const jsonContentToReplace = jsonDocument.getText(range);
                        const jsonDocumentToReplace = esm_main /* TextDocument */ .n.create('test://test.json', 'json', 0, jsonContentToReplace);
                        if (propertyTree.lastProperty === true && i !== propertyTreeArray.length - 1) {
                            const lineWhereToAddComma = propertyTree.lineWhereToAddComma - propertyTree.beginningLineNumber;
                            const indexWhereToAddComma = propertyTree.indexWhereToAddComa;
                            const edit1 = {
                                range: main.Range.create(main.Position.create(lineWhereToAddComma, indexWhereToAddComma), main.Position.create(lineWhereToAddComma, indexWhereToAddComma)),
                                text: ','
                            };
                            esm_main /* TextDocument */ .n.update(jsonDocumentToReplace, [
                                edit1
                            ], 1);
                        } else if (propertyTree.lastProperty === false && i === propertyTreeArray.length - 1) {
                            const commaIndex = propertyTree.commaIndex;
                            const commaLine = propertyTree.commaLine;
                            const lineWhereToRemoveComma = commaLine - propertyTree.beginningLineNumber;
                            const edit1 = {
                                range: main.Range.create(main.Position.create(lineWhereToRemoveComma, commaIndex), main.Position.create(lineWhereToRemoveComma, commaIndex + 1)),
                                text: ''
                            };
                            esm_main /* TextDocument */ .n.update(jsonDocumentToReplace, [
                                edit1
                            ], 1);
                        }
                        const length = propertyTree.endLineNumber - propertyTree.beginningLineNumber + 1;
                        const edit1 = {
                            range: main.Range.create(main.Position.create(beginningLineNumber, 0), main.Position.create(beginningLineNumber + length, 0)),
                            text: jsonDocumentToReplace.getText()
                        };
                        esm_main /* TextDocument */ .n.update(sortedJsonDocument, [
                            edit1
                        ], 1);
                        updateSortingQueue(queueToSort, propertyTree, beginningLineNumber);
                        beginningLineNumber = beginningLineNumber + length;
                    }
                }
                return sortedJsonDocument;
            }
            function updateSortingQueue(queue, propertyTree, beginningLineNumber) {
                if (propertyTree.childrenProperties.length === 0) {
                    return;
                }
                if (propertyTree.type === Container.Object) {
                    let minimumBeginningLineNumber = Infinity;
                    for (const childProperty of propertyTree.childrenProperties){
                        if (childProperty.beginningLineNumber < minimumBeginningLineNumber) {
                            minimumBeginningLineNumber = childProperty.beginningLineNumber;
                        }
                    }
                    const diff = minimumBeginningLineNumber - propertyTree.beginningLineNumber;
                    beginningLineNumber = beginningLineNumber + diff;
                    queue.push(new SortingRange(beginningLineNumber, propertyTree.childrenProperties));
                } else if (propertyTree.type === Container.Array) {
                    updateSortingQueueForArrayProperties(queue, propertyTree, beginningLineNumber);
                }
            }
            function updateSortingQueueForArrayProperties(queue, propertyTree, beginningLineNumber) {
                for (const subObject of propertyTree.childrenProperties){
                    // If the child property of the array is an object, then you can sort the properties within this object
                    if (subObject.type === Container.Object) {
                        let minimumBeginningLineNumber = Infinity;
                        for (const childProperty of subObject.childrenProperties){
                            if (childProperty.beginningLineNumber < minimumBeginningLineNumber) {
                                minimumBeginningLineNumber = childProperty.beginningLineNumber;
                            }
                        }
                        const diff = minimumBeginningLineNumber - subObject.beginningLineNumber;
                        queue.push(new SortingRange(beginningLineNumber + subObject.beginningLineNumber - propertyTree.beginningLineNumber + diff, subObject.childrenProperties));
                    }
                    // If the child property of the array is an array, then you need to recurse on the children properties, until you find an object to sort
                    if (subObject.type === Container.Array) {
                        updateSortingQueueForArrayProperties(queue, subObject, beginningLineNumber + subObject.beginningLineNumber - propertyTree.beginningLineNumber);
                    }
                }
            }
            class SortingRange {
                constructor(beginningLineNumber, propertyTreeArray){
                    this.beginningLineNumber = beginningLineNumber;
                    this.propertyTreeArray = propertyTreeArray;
                }
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/services/jsonLinks.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ function findLinks(document1, doc) {
                const links = [];
                doc.visit((node)=>{
                    var _node_valueNode;
                    if (node.type === "property" && node.keyNode.value === "$ref" && ((_node_valueNode = node.valueNode) === null || _node_valueNode === void 0 ? void 0 : _node_valueNode.type) === 'string') {
                        const path = node.valueNode.value;
                        const targetNode = findTargetNode(doc, path);
                        if (targetNode) {
                            const targetPos = document1.positionAt(targetNode.offset);
                            links.push({
                                target: `${document1.uri}#${targetPos.line + 1},${targetPos.character + 1}`,
                                range: createRange(document1, node.valueNode)
                            });
                        }
                    }
                    return true;
                });
                return Promise.resolve(links);
            }
            function createRange(document1, node) {
                return main.Range.create(document1.positionAt(node.offset + 1), document1.positionAt(node.offset + node.length - 1));
            }
            function findTargetNode(doc, path) {
                const tokens = parseJSONPointer(path);
                if (!tokens) {
                    return null;
                }
                return findNode(tokens, doc.root);
            }
            function findNode(pointer, node) {
                if (!node) {
                    return null;
                }
                if (pointer.length === 0) {
                    return node;
                }
                const token = pointer.shift();
                if (node && node.type === 'object') {
                    const propertyNode = node.properties.find((propertyNode)=>propertyNode.keyNode.value === token);
                    if (!propertyNode) {
                        return null;
                    }
                    return findNode(pointer, propertyNode.valueNode);
                } else if (node && node.type === 'array') {
                    if (token.match(/^(0|[1-9][0-9]*)$/)) {
                        const index = Number.parseInt(token);
                        const arrayItem = node.items[index];
                        if (!arrayItem) {
                            return null;
                        }
                        return findNode(pointer, arrayItem);
                    }
                }
                return null;
            }
            function parseJSONPointer(path) {
                if (path === "#") {
                    return [];
                }
                if (path[0] !== '#' || path[1] !== '/') {
                    return null;
                }
                return path.substring(2).split(/\//).map(jsonLinks_unescape);
            }
            function jsonLinks_unescape(str) {
                return str.replace(/~1/g, '/').replace(/~0/g, '~');
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/jsonLanguageService.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ function getLanguageService(params) {
                const promise = params.promiseConstructor || Promise;
                const jsonSchemaService = new JSONSchemaService(params.schemaRequestService, params.workspaceContext, promise);
                jsonSchemaService.setSchemaContributions(schemaContributions);
                const jsonCompletion = new JSONCompletion(jsonSchemaService, params.contributions, promise, params.clientCapabilities);
                const jsonHover = new JSONHover(jsonSchemaService, params.contributions, promise);
                const jsonDocumentSymbols = new JSONDocumentSymbols(jsonSchemaService);
                const jsonValidation = new JSONValidation(jsonSchemaService, promise);
                return {
                    configure: (settings)=>{
                        var _settings_schemas;
                        jsonSchemaService.clearExternalSchemas();
                        (_settings_schemas = settings.schemas) === null || _settings_schemas === void 0 ? void 0 : _settings_schemas.forEach(jsonSchemaService.registerExternalSchema.bind(jsonSchemaService));
                        jsonValidation.configure(settings);
                    },
                    resetSchema: (uri)=>jsonSchemaService.onResourceChange(uri),
                    doValidation: jsonValidation.doValidation.bind(jsonValidation),
                    getLanguageStatus: jsonValidation.getLanguageStatus.bind(jsonValidation),
                    parseJSONDocument: (document1)=>jsonParser_parse(document1, {
                            collectComments: true
                        }),
                    newJSONDocument: (root, diagnostics)=>newJSONDocument(root, diagnostics),
                    getMatchingSchemas: jsonSchemaService.getMatchingSchemas.bind(jsonSchemaService),
                    doResolve: jsonCompletion.doResolve.bind(jsonCompletion),
                    doComplete: jsonCompletion.doComplete.bind(jsonCompletion),
                    findDocumentSymbols: jsonDocumentSymbols.findDocumentSymbols.bind(jsonDocumentSymbols),
                    findDocumentSymbols2: jsonDocumentSymbols.findDocumentSymbols2.bind(jsonDocumentSymbols),
                    findDocumentColors: jsonDocumentSymbols.findDocumentColors.bind(jsonDocumentSymbols),
                    getColorPresentations: jsonDocumentSymbols.getColorPresentations.bind(jsonDocumentSymbols),
                    doHover: jsonHover.doHover.bind(jsonHover),
                    getFoldingRanges: getFoldingRanges,
                    getSelectionRanges: getSelectionRanges,
                    findDefinition: ()=>Promise.resolve([]),
                    findLinks: findLinks,
                    format: (document1, range, options)=>utils_format_format(document1, options, range),
                    sort: (document1, options)=>sort(document1, options)
                };
            }
            // EXTERNAL MODULE: ../../node_modules/vscode-languageserver-protocol/lib/browser/main.js
            var browser_main = __nested_webpack_require_701519__(294);
            // EXTERNAL MODULE: ./src/utils.ts
            var utils = __nested_webpack_require_701519__(6297);
            ; // CONCATENATED MODULE: ./src/ace/range-singleton.ts
            function _define_property(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                } else {
                    obj[key] = value;
                }
                return obj;
            }
            class AceRange {
                static getConstructor(editor) {
                    if (!AceRange._instance && editor) {
                        AceRange._instance = editor.getSelectionRange().constructor;
                    }
                    return AceRange._instance;
                }
            }
            _define_property(AceRange, "_instance", void 0);
            ; // CONCATENATED MODULE: ./src/type-converters/common-converters.ts
            var common_converters_CommonConverter;
            (function(CommonConverter1) {
                function normalizeRanges(completions) {
                    return completions && completions.map((el)=>{
                        if (el["range"]) {
                            el["range"] = toRange(el["range"]);
                        }
                        return el;
                    });
                }
                CommonConverter1.normalizeRanges = normalizeRanges;
                function cleanHtml(html) {
                    return html.replace(/<a\s/, "<a target='_blank' ");
                }
                CommonConverter1.cleanHtml = cleanHtml;
                function toRange(range) {
                    if (!range || !range.start || !range.end) {
                        return;
                    }
                    let Range = AceRange.getConstructor();
                    // @ts-ignore
                    return Range.fromPoints(range.start, range.end);
                }
                CommonConverter1.toRange = toRange;
                function convertKind(kind) {
                    switch(kind){
                        case "primitiveType":
                        case "keyword":
                            return browser_main.CompletionItemKind.Keyword;
                        case "variable":
                        case "localVariable":
                            return browser_main.CompletionItemKind.Variable;
                        case "memberVariable":
                        case "memberGetAccessor":
                        case "memberSetAccessor":
                            return browser_main.CompletionItemKind.Field;
                        case "function":
                        case "memberFunction":
                        case "constructSignature":
                        case "callSignature":
                        case "indexSignature":
                            return browser_main.CompletionItemKind.Function;
                        case "enum":
                            return browser_main.CompletionItemKind.Enum;
                        case "module":
                            return browser_main.CompletionItemKind.Module;
                        case "class":
                            return browser_main.CompletionItemKind.Class;
                        case "interface":
                            return browser_main.CompletionItemKind.Interface;
                        case "warning":
                            return browser_main.CompletionItemKind.File;
                    }
                    return browser_main.CompletionItemKind.Property;
                }
                CommonConverter1.convertKind = convertKind;
                function excludeByErrorMessage(diagnostics, errorMessagesToIgnore, fieldName = "message") {
                    if (!errorMessagesToIgnore) return diagnostics;
                    return diagnostics.filter((el)=>!(0, utils /* checkValueAgainstRegexpArray */ .$p)(el[fieldName], errorMessagesToIgnore));
                }
                CommonConverter1.excludeByErrorMessage = excludeByErrorMessage;
            })(common_converters_CommonConverter || (common_converters_CommonConverter = {}));
            ; // CONCATENATED MODULE: ./src/type-converters/lsp-converters.ts
            function fromRange(range) {
                return {
                    start: {
                        line: range.start.row,
                        character: range.start.column
                    },
                    end: {
                        line: range.end.row,
                        character: range.end.column
                    }
                };
            }
            function rangeFromPositions(start, end) {
                return {
                    start: start,
                    end: end
                };
            }
            function toRange(range) {
                return {
                    start: {
                        row: range.start.line,
                        column: range.start.character
                    },
                    end: {
                        row: range.end.line,
                        column: range.end.character
                    }
                };
            }
            function fromPoint(point) {
                return {
                    line: point.row,
                    character: point.column
                };
            }
            function toPoint(position) {
                return {
                    row: position.line,
                    column: position.character
                };
            }
            function toAnnotations(diagnostics) {
                var _diagnostics;
                return (_diagnostics = diagnostics) === null || _diagnostics === void 0 ? void 0 : _diagnostics.map((el)=>{
                    return {
                        row: el.range.start.line,
                        column: el.range.start.character,
                        text: el.message,
                        type: el.severity === 1 ? "error" : el.severity === 2 ? "warning" : "info"
                    };
                });
            }
            function toCompletion(item) {
                var _item_textEdit, _item_command;
                let itemKind = item.kind;
                let kind = itemKind ? Object.keys(CompletionItemKind)[Object.values(CompletionItemKind).indexOf(itemKind)] : undefined;
                var _item_textEdit_newText, _ref;
                let text = (_ref = (_item_textEdit_newText = (_item_textEdit = item.textEdit) === null || _item_textEdit === void 0 ? void 0 : _item_textEdit.newText) !== null && _item_textEdit_newText !== void 0 ? _item_textEdit_newText : item.insertText) !== null && _ref !== void 0 ? _ref : item.label;
                let command = ((_item_command = item.command) === null || _item_command === void 0 ? void 0 : _item_command.command) == "editor.action.triggerSuggest" ? "startAutocomplete" : undefined;
                let range = item.textEdit ? getTextEditRange(item.textEdit) : undefined;
                let completion = {
                    meta: kind,
                    caption: item.label,
                    score: undefined
                };
                completion["command"] = command;
                completion["range"] = range;
                completion["item"] = item;
                if (item.insertTextFormat == InsertTextFormat.Snippet) {
                    completion["snippet"] = text;
                } else {
                    completion["value"] = text !== null && text !== void 0 ? text : "";
                }
                completion["documentation"] = item.documentation; //TODO: this is workaround for services with instant completion
                completion["position"] = item["position"];
                completion["service"] = item["service"]; //TODO: since we have multiple servers, we need to determine which
                // server to use for resolving
                return completion;
            }
            function toCompletions(completions) {
                if (completions.length > 0) {
                    let combinedCompletions = completions.map((el)=>{
                        if (!el.completions) {
                            return [];
                        }
                        let allCompletions;
                        if (Array.isArray(el.completions)) {
                            allCompletions = el.completions;
                        } else {
                            allCompletions = el.completions.items;
                        }
                        return allCompletions.map((item)=>{
                            item["service"] = el.service;
                            return item;
                        });
                    }).flat();
                    return combinedCompletions.map((item)=>toCompletion(item));
                }
                return [];
            }
            function toResolvedCompletion(completion, item) {
                completion["docMarkdown"] = fromMarkupContent(item.documentation);
                return completion;
            }
            function toCompletionItem(completion) {
                let command;
                if (completion["command"]) {
                    command = {
                        title: "triggerSuggest",
                        command: completion["command"]
                    };
                }
                var _completion_caption;
                let completionItem = {
                    label: (_completion_caption = completion.caption) !== null && _completion_caption !== void 0 ? _completion_caption : "",
                    kind: CommonConverter.convertKind(completion.meta),
                    command: command,
                    insertTextFormat: completion["snippet"] ? InsertTextFormat.Snippet : InsertTextFormat.PlainText,
                    documentation: completion["documentation"]
                };
                if (completion["range"]) {
                    var _completion_snippet;
                    completionItem.textEdit = {
                        range: fromRange(completion["range"]),
                        newText: (_completion_snippet = completion["snippet"]) !== null && _completion_snippet !== void 0 ? _completion_snippet : completion["value"]
                    };
                } else {
                    var _completion_snippet1;
                    completionItem.insertText = (_completion_snippet1 = completion["snippet"]) !== null && _completion_snippet1 !== void 0 ? _completion_snippet1 : completion["value"];
                }
                completionItem["fileName"] = completion["fileName"];
                completionItem["position"] = completion["position"];
                completionItem["item"] = completion["item"];
                completionItem["service"] = completion["service"]; //TODO:
                return completionItem;
            }
            function getTextEditRange(textEdit) {
                if (textEdit.hasOwnProperty("insert") && textEdit.hasOwnProperty("replace")) {
                    textEdit = textEdit;
                    let mergedRanges = mergeRanges([
                        toRange(textEdit.insert),
                        toRange(textEdit.replace)
                    ]);
                    return mergedRanges[0];
                } else {
                    textEdit = textEdit;
                    return toRange(textEdit.range);
                }
            }
            function toTooltip(hover) {
                var _hover_find;
                if (!hover) return;
                let content = hover.map((el)=>{
                    if (!el || !el.contents) return;
                    if (MarkupContent.is(el.contents)) {
                        return fromMarkupContent(el.contents);
                    } else if (MarkedString.is(el.contents)) {
                        if (typeof el.contents === "string") {
                            return el.contents;
                        }
                        return "```" + el.contents.value + "```";
                    } else {
                        let contents = el.contents.map((el)=>{
                            if (typeof el !== "string") {
                                return `\`\`\`${el.value}\`\`\``;
                            } else {
                                return el;
                            }
                        });
                        return contents.join("\n\n");
                    }
                }).filter(notEmpty);
                if (content.length === 0) return;
                //TODO: it could be merged within all ranges in future
                let lspRange = (_hover_find = hover.find((el)=>{
                    var _el;
                    return (_el = el) === null || _el === void 0 ? void 0 : _el.range;
                })) === null || _hover_find === void 0 ? void 0 : _hover_find.range;
                let range;
                if (lspRange) range = toRange(lspRange);
                return {
                    content: {
                        type: "markdown",
                        text: content.join("\n\n")
                    },
                    range: range
                };
            }
            function fromSignatureHelp(signatureHelp) {
                if (!signatureHelp) return;
                let content = signatureHelp.map((el)=>{
                    var _el, _el1;
                    if (!el) return;
                    let signatureIndex = ((_el = el) === null || _el === void 0 ? void 0 : _el.activeSignature) || 0;
                    let activeSignature = el.signatures[signatureIndex];
                    if (!activeSignature) return;
                    let activeParam = (_el1 = el) === null || _el1 === void 0 ? void 0 : _el1.activeParameter;
                    let contents = activeSignature.label;
                    if (activeParam != undefined && activeSignature.parameters && activeSignature.parameters[activeParam]) {
                        let param = activeSignature.parameters[activeParam].label;
                        if (typeof param == "string") {
                            contents = contents.replace(param, `**${param}**`);
                        }
                    }
                    if (activeSignature.documentation) {
                        if (MarkupContent.is(activeSignature.documentation)) {
                            return contents + "\n\n" + fromMarkupContent(activeSignature.documentation);
                        } else {
                            contents += "\n\n" + activeSignature.documentation;
                            return contents;
                        }
                    } else {
                        return contents;
                    }
                }).filter(notEmpty);
                if (content.length === 0) return;
                return {
                    content: {
                        type: "markdown",
                        text: content.join("\n\n")
                    }
                };
            }
            function fromMarkupContent(content) {
                if (!content) return;
                if (typeof content === "string") {
                    return content;
                } else {
                    return content.value;
                }
            }
            function fromAceDelta(delta, eol) {
                const text = delta.lines.length > 1 ? delta.lines.join(eol) : delta.lines[0];
                return {
                    range: delta.action === "insert" ? rangeFromPositions(fromPoint(delta.start), fromPoint(delta.start)) : rangeFromPositions(fromPoint(delta.start), fromPoint(delta.end)),
                    text: delta.action === "insert" ? text : ""
                };
            }
            function filterDiagnostics(diagnostics, filterErrors) {
                return common_converters_CommonConverter.excludeByErrorMessage(diagnostics, filterErrors.errorMessagesToIgnore).map((el)=>{
                    if ((0, utils /* checkValueAgainstRegexpArray */ .$p)(el.message, filterErrors.errorMessagesToTreatAsWarning)) {
                        el.severity = browser_main.DiagnosticSeverity.Warning;
                    } else if ((0, utils /* checkValueAgainstRegexpArray */ .$p)(el.message, filterErrors.errorMessagesToTreatAsInfo)) {
                        el.severity = browser_main.DiagnosticSeverity.Information;
                    }
                    return el;
                });
            }
            function fromDocumentHighlights(documentHighlights) {
                return documentHighlights.map(function(el) {
                    let className = el.kind == 2 ? "language_highlight_read" : el.kind == 3 ? "language_highlight_write" : "language_highlight_text";
                    return toMarkerGroupItem(CommonConverter.toRange(toRange(el.range)), className);
                });
            }
            function toMarkerGroupItem(range, className, tooltipText) {
                let markerGroupItem = {
                    range: range,
                    className: className
                };
                if (tooltipText) {
                    markerGroupItem["tooltipText"] = tooltipText;
                }
                return markerGroupItem;
            }
            ; // CONCATENATED MODULE: ./src/services/json/json-service.ts
            function json_service_define_property(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                } else {
                    obj[key] = value;
                }
                return obj;
            }
            class JsonService extends base_service.BaseService {
                $getJsonSchemaUri(sessionID) {
                    return this.getOption(sessionID, "schemaUri");
                }
                addDocument(document1) {
                    super.addDocument(document1);
                    this.$configureService(document1.uri);
                }
                $configureService(sessionID) {
                    var _schemas;
                    let schemas = this.getOption(sessionID !== null && sessionID !== void 0 ? sessionID : "", "schemas");
                    let sessionIDs = sessionID ? [] : Object.keys(this.documents);
                    (_schemas = schemas) === null || _schemas === void 0 ? void 0 : _schemas.forEach((el)=>{
                        if (sessionID) {
                            if (this.$getJsonSchemaUri(sessionID) == el.uri) {
                                var _el;
                                var _fileMatch;
                                (_fileMatch = (_el = el).fileMatch) !== null && _fileMatch !== void 0 ? _fileMatch : _el.fileMatch = [];
                                el.fileMatch.push(sessionID);
                            }
                        } else {
                            el.fileMatch = sessionIDs.filter((sessionID)=>this.$getJsonSchemaUri(sessionID) == el.uri);
                        }
                        var _el_schema;
                        let schema = (_el_schema = el.schema) !== null && _el_schema !== void 0 ? _el_schema : this.schemas[el.uri];
                        if (schema) this.schemas[el.uri] = schema;
                        this.$service.resetSchema(el.uri);
                        el.schema = undefined;
                    });
                    this.$service.configure({
                        schemas: schemas,
                        allowComments: this.mode === "json5"
                    });
                }
                removeDocument(document1) {
                    var _schemas;
                    super.removeDocument(document1);
                    let schemas = this.getOption(document1.uri, "schemas");
                    (_schemas = schemas) === null || _schemas === void 0 ? void 0 : _schemas.forEach((el)=>{
                        if (el.uri === this.$getJsonSchemaUri(document1.uri)) {
                            var _el_fileMatch;
                            el.fileMatch = (_el_fileMatch = el.fileMatch) === null || _el_fileMatch === void 0 ? void 0 : _el_fileMatch.filter((pattern)=>pattern != document1.uri);
                        }
                    });
                    this.$service.configure({
                        schemas: schemas,
                        allowComments: this.mode === "json5"
                    });
                }
                setOptions(sessionID, options, merge = false) {
                    super.setOptions(sessionID, options, merge);
                    this.$configureService(sessionID);
                }
                setGlobalOptions(options) {
                    super.setGlobalOptions(options);
                    this.$configureService();
                }
                format(document1, range, options) {
                    let fullDocument = this.getDocument(document1.uri);
                    if (!fullDocument) return Promise.resolve([]);
                    return Promise.resolve(this.$service.format(fullDocument, range, options));
                }
                async doHover(document1, position) {
                    let fullDocument = this.getDocument(document1.uri);
                    if (!fullDocument) return null;
                    let jsonDocument = this.$service.parseJSONDocument(fullDocument);
                    return this.$service.doHover(fullDocument, position, jsonDocument);
                }
                async doValidation(document1) {
                    let fullDocument = this.getDocument(document1.uri);
                    if (!fullDocument) return [];
                    let jsonDocument = this.$service.parseJSONDocument(fullDocument);
                    let diagnostics = await this.$service.doValidation(fullDocument, jsonDocument, {
                        trailingCommas: this.mode === "json5" ? "ignore" : "error"
                    });
                    return filterDiagnostics(diagnostics, this.optionsToFilterDiagnostics);
                }
                async doComplete(document1, position) {
                    let fullDocument = this.getDocument(document1.uri);
                    if (!fullDocument) return null;
                    let jsonDocument = this.$service.parseJSONDocument(fullDocument);
                    return this.$service.doComplete(fullDocument, position, jsonDocument);
                }
                async doResolve(item) {
                    return this.$service.doResolve(item);
                }
                constructor(mode){
                    super(mode);
                    json_service_define_property(this, "$service", void 0);
                    json_service_define_property(this, "schemas", {});
                    json_service_define_property(this, "serviceCapabilities", {
                        completionProvider: {
                            triggerCharacters: [
                                '"',
                                ':'
                            ]
                        },
                        diagnosticProvider: {
                            interFileDependencies: true,
                            workspaceDiagnostics: true
                        },
                        documentRangeFormattingProvider: true,
                        documentFormattingProvider: true,
                        hoverProvider: true
                    });
                    this.$service = getLanguageService({
                        schemaRequestService: (uri)=>{
                            uri = uri.replace("file:///", "");
                            let jsonSchema = this.schemas[uri];
                            if (jsonSchema) return Promise.resolve(jsonSchema);
                            return Promise.reject(`Unable to load schema at ${uri}`);
                        }
                    });
                }
            }
        })();
        /******/ return __nested_webpack_exports__;
    /******/ })();
});


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LElBQUksR0FBRyxJQUFJLEdBQUc7Z0JBQzVDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxHQUFHO2dCQUM1Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLElBQUksR0FBRztnQkFDNUNBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxJQUFJLEdBQUc7Z0JBQzVDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxHQUFHO2dCQUM1Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLElBQUksR0FBRztnQkFDNUNBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxJQUFJLEdBQUc7Z0JBQzVDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxHQUFHO2dCQUM1Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLElBQUksR0FBRztnQkFDNUNBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxJQUFJLEdBQUc7Z0JBQzVDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxHQUFHO2dCQUM1Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLElBQUksR0FBRztnQkFDNUNBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxJQUFJLEdBQUc7Z0JBQzVDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxHQUFHO2dCQUM1Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLElBQUksR0FBRztnQkFDNUNBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxJQUFJLEdBQUc7Z0JBQzVDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxHQUFHO2dCQUM1Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLElBQUksR0FBRztnQkFDNUNBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxJQUFJLEdBQUc7Z0JBQzVDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxHQUFHO2dCQUM1Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRztnQkFDM0NBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUc7Z0JBQzNDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHO2dCQUMzQ0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRztnQkFDM0NBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUc7Z0JBQzNDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHO2dCQUMzQ0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRztnQkFDM0NBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUc7Z0JBQzNDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHO2dCQUMzQ0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRztnQkFDM0NBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUc7Z0JBQzNDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHO2dCQUMzQ0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRztnQkFDM0NBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUc7Z0JBQzNDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHO2dCQUMzQ0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRztnQkFDM0NBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUc7Z0JBQzNDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHO2dCQUMzQ0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRztnQkFDM0NBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUc7Z0JBQzNDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHO2dCQUMzQ0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRztnQkFDM0NBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUc7Z0JBQzNDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHO2dCQUMzQ0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRztnQkFDM0NBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUc7Z0JBQzNDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxXQUFXLEdBQUcsR0FBRyxHQUFHO2dCQUNsREEsY0FBYyxDQUFDQSxjQUFjLENBQUMsWUFBWSxHQUFHLEdBQUcsR0FBRztnQkFDbkRBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLGFBQWEsR0FBRyxJQUFJLEdBQUc7Z0JBQ3JEQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxlQUFlLEdBQUcsR0FBRyxHQUFHO2dCQUN0REEsY0FBYyxDQUFDQSxjQUFjLENBQUMsUUFBUSxHQUFHLEdBQUcsR0FBRztnQkFDL0NBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLFFBQVEsR0FBRyxHQUFHLEdBQUc7Z0JBQy9DQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxNQUFNLEdBQUcsR0FBRyxHQUFHO2dCQUM3Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsY0FBYyxHQUFHLEdBQUcsR0FBRztnQkFDckRBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLFFBQVEsR0FBRyxHQUFHLEdBQUc7Z0JBQy9DQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxZQUFZ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NEJBQ2hCQyx1QkFBdUI7NEJBQ3ZCQyxzQkFBc0I7d0JBQzFCO3dCQUNBQyxpQ0FBaUM7d0JBQ2pDQyw0QkFBNEI7d0JBQzVCQyxlQUFlO29CQUNuQjtvQkFDQSxJQUFJLENBQUNWLFFBQVEsR0FBR3hGLG1CQUFtQjt3QkFDL0JDLHNCQUFzQixDQUFDbCtEOzRCQUNuQkEsTUFBTUEsSUFBSTdhLE9BQU8sQ0FBQyxZQUFZOzRCQUM5QixJQUFJaS9FLGFBQWEsSUFBSSxDQUFDenNCLE9BQU8sQ0FBQzMzQyxJQUFJOzRCQUNsQyxJQUFJb2tFLFlBQVksT0FBT25xRixRQUFRQyxPQUFPLENBQUNrcUY7NEJBQ3ZDLE9BQU9ucUYsUUFBUXF4QixNQUFNLENBQUMsQ0FBQyx5QkFBeUIsRUFBRXRMLElBQUksQ0FBQzt3QkFDM0Q7b0JBQ0o7Z0JBQ0o7WUFDSjtRQUVBO1FBRUEsTUFBTSxHQUFJLE9BQU9SLDBCQUFtQkE7SUFDcEMsTUFBTSxHQUFHO0FBRVQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2UtbGludGVycy1yb290Ly4vcGFja2FnZXMvYWNlLWxpbnRlcnMvYnVpbGQvanNvbi1zZXJ2aWNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSB7XG5cdFx0dmFyIGEgPSBmYWN0b3J5KCk7XG5cdFx0Zm9yKHZhciBpIGluIGEpICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBleHBvcnRzIDogcm9vdClbaV0gPSBhW2ldO1xuXHR9XG59KSh0aGlzLCAoKSA9PiB7XG5yZXR1cm4gLyoqKioqKi8gKCgpID0+IHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIDE2OTY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgcHJvY2VzcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDQwNik7XG4vKiBwcm92aWRlZCBkZXBlbmRlbmN5ICovIHZhciBjb25zb2xlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNzE2KTtcbi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvYXNzZXJ0LmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzJhNTFhZTQyNGE1MTNlYzlhNmFhMzQ2NmJhYTBjYzFkNTVkZDRmM2Jcbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1MTUpLFxuICAgIF9yZXF1aXJlJGNvZGVzID0gX3JlcXVpcmUuY29kZXMsXG4gICAgRVJSX0FNQklHVU9VU19BUkdVTUVOVCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9BTUJJR1VPVVNfQVJHVU1FTlQsXG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVkFMVUUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVkFMVUUsXG4gICAgRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFLFxuICAgIEVSUl9NSVNTSU5HX0FSR1MgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUlTU0lOR19BUkdTO1xuXG52YXIgQXNzZXJ0aW9uRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwODIpO1xuXG52YXIgX3JlcXVpcmUyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMzM1KSxcbiAgICBpbnNwZWN0ID0gX3JlcXVpcmUyLmluc3BlY3Q7XG5cbnZhciBfcmVxdWlyZSR0eXBlcyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDMzMzUpLnR5cGVzKSxcbiAgICBpc1Byb21pc2UgPSBfcmVxdWlyZSR0eXBlcy5pc1Byb21pc2UsXG4gICAgaXNSZWdFeHAgPSBfcmVxdWlyZSR0eXBlcy5pc1JlZ0V4cDtcblxudmFyIG9iamVjdEFzc2lnbiA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduIDogKF9fd2VicGFja19yZXF1aXJlX18oNDk1NikuYXNzaWduKTtcbnZhciBvYmplY3RJcyA9IE9iamVjdC5pcyA/IE9iamVjdC5pcyA6IF9fd2VicGFja19yZXF1aXJlX18oNDY3OSk7XG52YXIgZXJyb3JDYWNoZSA9IG5ldyBNYXAoKTtcbnZhciBpc0RlZXBFcXVhbDtcbnZhciBpc0RlZXBTdHJpY3RFcXVhbDtcbnZhciBwYXJzZUV4cHJlc3Npb25BdDtcbnZhciBmaW5kTm9kZUFyb3VuZDtcbnZhciBkZWNvZGVyO1xuXG5mdW5jdGlvbiBsYXp5TG9hZENvbXBhcmlzb24oKSB7XG4gIHZhciBjb21wYXJpc29uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nzk2KTtcblxuICBpc0RlZXBFcXVhbCA9IGNvbXBhcmlzb24uaXNEZWVwRXF1YWw7XG4gIGlzRGVlcFN0cmljdEVxdWFsID0gY29tcGFyaXNvbi5pc0RlZXBTdHJpY3RFcXVhbDtcbn0gLy8gRXNjYXBlIGNvbnRyb2wgY2hhcmFjdGVycyBidXQgbm90IFxcbiBhbmQgXFx0IHRvIGtlZXAgdGhlIGxpbmUgYnJlYWtzIGFuZFxuLy8gaW5kZW50YXRpb24gaW50YWN0LlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcblxuXG52YXIgZXNjYXBlU2VxdWVuY2VzUmVnRXhwID0gL1tcXHgwMC1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZl0vZztcbnZhciBtZXRhID0gKC8qIHVudXNlZCBwdXJlIGV4cHJlc3Npb24gb3Igc3VwZXIgKi8gbnVsbCAmJiAoW1wiXFxcXHUwMDAwXCIsIFwiXFxcXHUwMDAxXCIsIFwiXFxcXHUwMDAyXCIsIFwiXFxcXHUwMDAzXCIsIFwiXFxcXHUwMDA0XCIsIFwiXFxcXHUwMDA1XCIsIFwiXFxcXHUwMDA2XCIsIFwiXFxcXHUwMDA3XCIsICdcXFxcYicsICcnLCAnJywgXCJcXFxcdTAwMGJcIiwgJ1xcXFxmJywgJycsIFwiXFxcXHUwMDBlXCIsIFwiXFxcXHUwMDBmXCIsIFwiXFxcXHUwMDEwXCIsIFwiXFxcXHUwMDExXCIsIFwiXFxcXHUwMDEyXCIsIFwiXFxcXHUwMDEzXCIsIFwiXFxcXHUwMDE0XCIsIFwiXFxcXHUwMDE1XCIsIFwiXFxcXHUwMDE2XCIsIFwiXFxcXHUwMDE3XCIsIFwiXFxcXHUwMDE4XCIsIFwiXFxcXHUwMDE5XCIsIFwiXFxcXHUwMDFhXCIsIFwiXFxcXHUwMDFiXCIsIFwiXFxcXHUwMDFjXCIsIFwiXFxcXHUwMDFkXCIsIFwiXFxcXHUwMDFlXCIsIFwiXFxcXHUwMDFmXCJdKSk7XG5cbnZhciBlc2NhcGVGbiA9IGZ1bmN0aW9uIGVzY2FwZUZuKHN0cikge1xuICByZXR1cm4gbWV0YVtzdHIuY2hhckNvZGVBdCgwKV07XG59O1xuXG52YXIgd2FybmVkID0gZmFsc2U7IC8vIFRoZSBhc3NlcnQgbW9kdWxlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0aGF0IHRocm93XG4vLyBBc3NlcnRpb25FcnJvcidzIHdoZW4gcGFydGljdWxhciBjb25kaXRpb25zIGFyZSBub3QgbWV0LiBUaGVcbi8vIGFzc2VydCBtb2R1bGUgbXVzdCBjb25mb3JtIHRvIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlLlxuXG52YXIgYXNzZXJ0ID0gbW9kdWxlLmV4cG9ydHMgPSBvaztcbnZhciBOT19FWENFUFRJT05fU0VOVElORUwgPSB7fTsgLy8gQWxsIG9mIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIG11c3QgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3Jcbi8vIHdoZW4gYSBjb3JyZXNwb25kaW5nIGNvbmRpdGlvbiBpcyBub3QgbWV0LCB3aXRoIGEgbWVzc2FnZSB0aGF0XG4vLyBtYXkgYmUgdW5kZWZpbmVkIGlmIG5vdCBwcm92aWRlZC4gQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBpbm5lckZhaWwob2JqKSB7XG4gIGlmIChvYmoubWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB0aHJvdyBvYmoubWVzc2FnZTtcbiAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKG9iaik7XG59XG5cbmZ1bmN0aW9uIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IsIHN0YWNrU3RhcnRGbikge1xuICB2YXIgYXJnc0xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbnRlcm5hbE1lc3NhZ2U7XG5cbiAgaWYgKGFyZ3NMZW4gPT09IDApIHtcbiAgICBpbnRlcm5hbE1lc3NhZ2UgPSAnRmFpbGVkJztcbiAgfSBlbHNlIGlmIChhcmdzTGVuID09PSAxKSB7XG4gICAgbWVzc2FnZSA9IGFjdHVhbDtcbiAgICBhY3R1YWwgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHdhcm5lZCA9PT0gZmFsc2UpIHtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICB2YXIgd2FybiA9IHByb2Nlc3MuZW1pdFdhcm5pbmcgPyBwcm9jZXNzLmVtaXRXYXJuaW5nIDogY29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7XG4gICAgICB3YXJuKCdhc3NlcnQuZmFpbCgpIHdpdGggbW9yZSB0aGFuIG9uZSBhcmd1bWVudCBpcyBkZXByZWNhdGVkLiAnICsgJ1BsZWFzZSB1c2UgYXNzZXJ0LnN0cmljdEVxdWFsKCkgaW5zdGVhZCBvciBvbmx5IHBhc3MgYSBtZXNzYWdlLicsICdEZXByZWNhdGlvbldhcm5pbmcnLCAnREVQMDA5NCcpO1xuICAgIH1cblxuICAgIGlmIChhcmdzTGVuID09PSAyKSBvcGVyYXRvciA9ICchPSc7XG4gIH1cblxuICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB0aHJvdyBtZXNzYWdlO1xuICB2YXIgZXJyQXJncyA9IHtcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yID09PSB1bmRlZmluZWQgPyAnZmFpbCcgOiBvcGVyYXRvcixcbiAgICBzdGFja1N0YXJ0Rm46IHN0YWNrU3RhcnRGbiB8fCBmYWlsXG4gIH07XG5cbiAgaWYgKG1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgIGVyckFyZ3MubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cblxuICB2YXIgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKGVyckFyZ3MpO1xuXG4gIGlmIChpbnRlcm5hbE1lc3NhZ2UpIHtcbiAgICBlcnIubWVzc2FnZSA9IGludGVybmFsTWVzc2FnZTtcbiAgICBlcnIuZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gIH1cblxuICB0aHJvdyBlcnI7XG59XG5cbmFzc2VydC5mYWlsID0gZmFpbDsgLy8gVGhlIEFzc2VydGlvbkVycm9yIGlzIGRlZmluZWQgaW4gaW50ZXJuYWwvZXJyb3IuXG5cbmFzc2VydC5Bc3NlcnRpb25FcnJvciA9IEFzc2VydGlvbkVycm9yO1xuXG5mdW5jdGlvbiBpbm5lck9rKGZuLCBhcmdMZW4sIHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICB2YXIgZ2VuZXJhdGVkTWVzc2FnZSA9IGZhbHNlO1xuXG4gICAgaWYgKGFyZ0xlbiA9PT0gMCkge1xuICAgICAgZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gICAgICBtZXNzYWdlID0gJ05vIHZhbHVlIGFyZ3VtZW50IHBhc3NlZCB0byBgYXNzZXJ0Lm9rKClgJztcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgbWVzc2FnZTtcbiAgICB9XG5cbiAgICB2YXIgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICAgIGFjdHVhbDogdmFsdWUsXG4gICAgICBleHBlY3RlZDogdHJ1ZSxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJz09JyxcbiAgICAgIHN0YWNrU3RhcnRGbjogZm5cbiAgICB9KTtcbiAgICBlcnIuZ2VuZXJhdGVkTWVzc2FnZSA9IGdlbmVyYXRlZE1lc3NhZ2U7XG4gICAgdGhyb3cgZXJyO1xuICB9XG59IC8vIFB1cmUgYXNzZXJ0aW9uIHRlc3RzIHdoZXRoZXIgYSB2YWx1ZSBpcyB0cnV0aHksIGFzIGRldGVybWluZWRcbi8vIGJ5ICEhdmFsdWUuXG5cblxuZnVuY3Rpb24gb2soKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpbm5lck9rLmFwcGx5KHZvaWQgMCwgW29rLCBhcmdzLmxlbmd0aF0uY29uY2F0KGFyZ3MpKTtcbn1cblxuYXNzZXJ0Lm9rID0gb2s7IC8vIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aCA9PS5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzICovXG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblxuXG4gIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICc9PScsXG4gICAgICBzdGFja1N0YXJ0Rm46IGVxdWFsXG4gICAgfSk7XG4gIH1cbn07IC8vIFRoZSBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciB3aGV0aGVyIHR3byBvYmplY3RzIGFyZSBub3Rcbi8vIGVxdWFsIHdpdGggIT0uXG5cblxuYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXG5cbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJyE9JyxcbiAgICAgIHN0YWNrU3RhcnRGbjogbm90RXF1YWxcbiAgICB9KTtcbiAgfVxufTsgLy8gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG5cblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKTtcblxuICBpZiAoIWlzRGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnZGVlcEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogZGVlcEVxdWFsXG4gICAgfSk7XG4gIH1cbn07IC8vIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuXG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG5cbiAgaWYgKGlzRGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnbm90RGVlcEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogbm90RGVlcEVxdWFsXG4gICAgfSk7XG4gIH1cbn07XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cblxuYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIGRlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKTtcblxuICBpZiAoIWlzRGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnZGVlcFN0cmljdEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogZGVlcFN0cmljdEVxdWFsXG4gICAgfSk7XG4gIH1cbn07XG5cbmFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWwgPSBub3REZWVwU3RyaWN0RXF1YWw7XG5cbmZ1bmN0aW9uIG5vdERlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKTtcblxuICBpZiAoaXNEZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdub3REZWVwU3RyaWN0RXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBub3REZWVwU3RyaWN0RXF1YWxcbiAgICB9KTtcbiAgfVxufVxuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmICghb2JqZWN0SXMoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdzdHJpY3RFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IHN0cmljdEVxdWFsXG4gICAgfSk7XG4gIH1cbn07XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKG9iamVjdElzKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnbm90U3RyaWN0RXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBub3RTdHJpY3RFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgQ29tcGFyaXNvbiA9IGZ1bmN0aW9uIENvbXBhcmlzb24ob2JqLCBrZXlzLCBhY3R1YWwpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tcGFyaXNvbik7XG5cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgaWYgKGFjdHVhbCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBhY3R1YWxba2V5XSA9PT0gJ3N0cmluZycgJiYgaXNSZWdFeHAob2JqW2tleV0pICYmIG9ialtrZXldLnRlc3QoYWN0dWFsW2tleV0pKSB7XG4gICAgICAgIF90aGlzW2tleV0gPSBhY3R1YWxba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzW2tleV0gPSBvYmpba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gY29tcGFyZUV4Y2VwdGlvbktleShhY3R1YWwsIGV4cGVjdGVkLCBrZXksIG1lc3NhZ2UsIGtleXMsIGZuKSB7XG4gIGlmICghKGtleSBpbiBhY3R1YWwpIHx8ICFpc0RlZXBTdHJpY3RFcXVhbChhY3R1YWxba2V5XSwgZXhwZWN0ZWRba2V5XSkpIHtcbiAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgIC8vIENyZWF0ZSBwbGFjZWhvbGRlciBvYmplY3RzIHRvIGNyZWF0ZSBhIG5pY2Ugb3V0cHV0LlxuICAgICAgdmFyIGEgPSBuZXcgQ29tcGFyaXNvbihhY3R1YWwsIGtleXMpO1xuICAgICAgdmFyIGIgPSBuZXcgQ29tcGFyaXNvbihleHBlY3RlZCwga2V5cywgYWN0dWFsKTtcbiAgICAgIHZhciBlcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgICBhY3R1YWw6IGEsXG4gICAgICAgIGV4cGVjdGVkOiBiLFxuICAgICAgICBvcGVyYXRvcjogJ2RlZXBTdHJpY3RFcXVhbCcsXG4gICAgICAgIHN0YWNrU3RhcnRGbjogZm5cbiAgICAgIH0pO1xuICAgICAgZXJyLmFjdHVhbCA9IGFjdHVhbDtcbiAgICAgIGVyci5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICAgICAgZXJyLm9wZXJhdG9yID0gZm4ubmFtZTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG5cbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6IGZuLm5hbWUsXG4gICAgICBzdGFja1N0YXJ0Rm46IGZuXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCwgbXNnLCBmbikge1xuICBpZiAodHlwZW9mIGV4cGVjdGVkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGlzUmVnRXhwKGV4cGVjdGVkKSkgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTsgLy8gYXNzZXJ0LmRvZXNOb3RUaHJvdyBkb2VzIG5vdCBhY2NlcHQgb2JqZWN0cy5cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2V4cGVjdGVkJywgWydGdW5jdGlvbicsICdSZWdFeHAnXSwgZXhwZWN0ZWQpO1xuICAgIH0gLy8gSGFuZGxlIHByaW1pdGl2ZXMgcHJvcGVybHkuXG5cblxuICAgIGlmIChfdHlwZW9mKGFjdHVhbCkgIT09ICdvYmplY3QnIHx8IGFjdHVhbCA9PT0gbnVsbCkge1xuICAgICAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICAgIG1lc3NhZ2U6IG1zZyxcbiAgICAgICAgb3BlcmF0b3I6ICdkZWVwU3RyaWN0RXF1YWwnLFxuICAgICAgICBzdGFja1N0YXJ0Rm46IGZuXG4gICAgICB9KTtcbiAgICAgIGVyci5vcGVyYXRvciA9IGZuLm5hbWU7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhleHBlY3RlZCk7IC8vIFNwZWNpYWwgaGFuZGxlIGVycm9ycyB0byBtYWtlIHN1cmUgdGhlIG5hbWUgYW5kIHRoZSBtZXNzYWdlIGFyZSBjb21wYXJlZFxuICAgIC8vIGFzIHdlbGwuXG5cbiAgICBpZiAoZXhwZWN0ZWQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAga2V5cy5wdXNoKCduYW1lJywgJ21lc3NhZ2UnKTtcbiAgICB9IGVsc2UgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKCdlcnJvcicsIGV4cGVjdGVkLCAnbWF5IG5vdCBiZSBhbiBlbXB0eSBvYmplY3QnKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmICh0eXBlb2YgYWN0dWFsW2tleV0gPT09ICdzdHJpbmcnICYmIGlzUmVnRXhwKGV4cGVjdGVkW2tleV0pICYmIGV4cGVjdGVkW2tleV0udGVzdChhY3R1YWxba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb21wYXJlRXhjZXB0aW9uS2V5KGFjdHVhbCwgZXhwZWN0ZWQsIGtleSwgbXNnLCBrZXlzLCBmbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gR3VhcmQgaW5zdGFuY2VvZiBhZ2FpbnN0IGFycm93IGZ1bmN0aW9ucyBhcyB0aGV5IGRvbid0IGhhdmUgYSBwcm90b3R5cGUuXG5cblxuICBpZiAoZXhwZWN0ZWQucHJvdG90eXBlICE9PSB1bmRlZmluZWQgJiYgYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChFcnJvci5pc1Byb3RvdHlwZU9mKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXRBY3R1YWwoZm4pIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZm4nLCAnRnVuY3Rpb24nLCBmbik7XG4gIH1cblxuICB0cnkge1xuICAgIGZuKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxuXG4gIHJldHVybiBOT19FWENFUFRJT05fU0VOVElORUw7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSXNQcm9taXNlKG9iaikge1xuICAvLyBBY2NlcHQgbmF0aXZlIEVTNiBwcm9taXNlcyBhbmQgcHJvbWlzZXMgdGhhdCBhcmUgaW1wbGVtZW50ZWQgaW4gYSBzaW1pbGFyXG4gIC8vIHdheS4gRG8gbm90IGFjY2VwdCB0aGVuYWJsZXMgdGhhdCB1c2UgYSBmdW5jdGlvbiBhcyBgb2JqYCBhbmQgdGhhdCBoYXZlIG5vXG4gIC8vIGBjYXRjaGAgaGFuZGxlci5cbiAgLy8gVE9ETzogdGhlbmFibGVzIGFyZSBjaGVja2VkIHVwIHVudGlsIHRoZXkgaGF2ZSB0aGUgY29ycmVjdCBtZXRob2RzLFxuICAvLyBidXQgYWNjb3JkaW5nIHRvIGRvY3VtZW50YXRpb24sIHRoZSBgdGhlbmAgbWV0aG9kIHNob3VsZCByZWNlaXZlXG4gIC8vIHRoZSBgZnVsZmlsbGAgYW5kIGByZWplY3RgIGFyZ3VtZW50cyBhcyB3ZWxsIG9yIGl0IG1heSBiZSBuZXZlciByZXNvbHZlZC5cbiAgcmV0dXJuIGlzUHJvbWlzZShvYmopIHx8IG9iaiAhPT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmoudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLmNhdGNoID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiB3YWl0Rm9yQWN0dWFsKHByb21pc2VGbikge1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdFByb21pc2U7XG5cbiAgICBpZiAodHlwZW9mIHByb21pc2VGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gUmV0dXJuIGEgcmVqZWN0ZWQgcHJvbWlzZSBpZiBgcHJvbWlzZUZuYCB0aHJvd3Mgc3luY2hyb25vdXNseS5cbiAgICAgIHJlc3VsdFByb21pc2UgPSBwcm9taXNlRm4oKTsgLy8gRmFpbCBpbiBjYXNlIG5vIHByb21pc2UgaXMgcmV0dXJuZWQuXG5cbiAgICAgIGlmICghY2hlY2tJc1Byb21pc2UocmVzdWx0UHJvbWlzZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSgnaW5zdGFuY2Ugb2YgUHJvbWlzZScsICdwcm9taXNlRm4nLCByZXN1bHRQcm9taXNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoZWNrSXNQcm9taXNlKHByb21pc2VGbikpIHtcbiAgICAgIHJlc3VsdFByb21pc2UgPSBwcm9taXNlRm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgncHJvbWlzZUZuJywgWydGdW5jdGlvbicsICdQcm9taXNlJ10sIHByb21pc2VGbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlc3VsdFByb21pc2U7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gTk9fRVhDRVBUSU9OX1NFTlRJTkVMO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gZTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGV4cGVjdHNFcnJvcihzdGFja1N0YXJ0Rm4sIGFjdHVhbCwgZXJyb3IsIG1lc3NhZ2UpIHtcbiAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdlcnJvcicsIFsnT2JqZWN0JywgJ0Vycm9yJywgJ0Z1bmN0aW9uJywgJ1JlZ0V4cCddLCBlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgYWN0dWFsICE9PSBudWxsKSB7XG4gICAgICBpZiAoYWN0dWFsLm1lc3NhZ2UgPT09IGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFUlJfQU1CSUdVT1VTX0FSR1VNRU5UKCdlcnJvci9tZXNzYWdlJywgXCJUaGUgZXJyb3IgbWVzc2FnZSBcXFwiXCIuY29uY2F0KGFjdHVhbC5tZXNzYWdlLCBcIlxcXCIgaXMgaWRlbnRpY2FsIHRvIHRoZSBtZXNzYWdlLlwiKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhY3R1YWwgPT09IGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0FNQklHVU9VU19BUkdVTUVOVCgnZXJyb3IvbWVzc2FnZScsIFwiVGhlIGVycm9yIFxcXCJcIi5jb25jYXQoYWN0dWFsLCBcIlxcXCIgaXMgaWRlbnRpY2FsIHRvIHRoZSBtZXNzYWdlLlwiKSk7XG4gICAgfVxuXG4gICAgbWVzc2FnZSA9IGVycm9yO1xuICAgIGVycm9yID0gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKGVycm9yICE9IG51bGwgJiYgX3R5cGVvZihlcnJvcikgIT09ICdvYmplY3QnICYmIHR5cGVvZiBlcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZXJyb3InLCBbJ09iamVjdCcsICdFcnJvcicsICdGdW5jdGlvbicsICdSZWdFeHAnXSwgZXJyb3IpO1xuICB9XG5cbiAgaWYgKGFjdHVhbCA9PT0gTk9fRVhDRVBUSU9OX1NFTlRJTkVMKSB7XG4gICAgdmFyIGRldGFpbHMgPSAnJztcblxuICAgIGlmIChlcnJvciAmJiBlcnJvci5uYW1lKSB7XG4gICAgICBkZXRhaWxzICs9IFwiIChcIi5jb25jYXQoZXJyb3IubmFtZSwgXCIpXCIpO1xuICAgIH1cblxuICAgIGRldGFpbHMgKz0gbWVzc2FnZSA/IFwiOiBcIi5jb25jYXQobWVzc2FnZSkgOiAnLic7XG4gICAgdmFyIGZuVHlwZSA9IHN0YWNrU3RhcnRGbi5uYW1lID09PSAncmVqZWN0cycgPyAncmVqZWN0aW9uJyA6ICdleGNlcHRpb24nO1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IHVuZGVmaW5lZCxcbiAgICAgIGV4cGVjdGVkOiBlcnJvcixcbiAgICAgIG9wZXJhdG9yOiBzdGFja1N0YXJ0Rm4ubmFtZSxcbiAgICAgIG1lc3NhZ2U6IFwiTWlzc2luZyBleHBlY3RlZCBcIi5jb25jYXQoZm5UeXBlKS5jb25jYXQoZGV0YWlscyksXG4gICAgICBzdGFja1N0YXJ0Rm46IHN0YWNrU3RhcnRGblxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGVycm9yICYmICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGVycm9yLCBtZXNzYWdlLCBzdGFja1N0YXJ0Rm4pKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4cGVjdHNOb0Vycm9yKHN0YWNrU3RhcnRGbiwgYWN0dWFsLCBlcnJvciwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09PSBOT19FWENFUFRJT05fU0VOVElORUwpIHJldHVybjtcblxuICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSBlcnJvcjtcbiAgICBlcnJvciA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICghZXJyb3IgfHwgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBlcnJvcikpIHtcbiAgICB2YXIgZGV0YWlscyA9IG1lc3NhZ2UgPyBcIjogXCIuY29uY2F0KG1lc3NhZ2UpIDogJy4nO1xuICAgIHZhciBmblR5cGUgPSBzdGFja1N0YXJ0Rm4ubmFtZSA9PT0gJ2RvZXNOb3RSZWplY3QnID8gJ3JlamVjdGlvbicgOiAnZXhjZXB0aW9uJztcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXJyb3IsXG4gICAgICBvcGVyYXRvcjogc3RhY2tTdGFydEZuLm5hbWUsXG4gICAgICBtZXNzYWdlOiBcIkdvdCB1bndhbnRlZCBcIi5jb25jYXQoZm5UeXBlKS5jb25jYXQoZGV0YWlscywgXCJcXG5cIikgKyBcIkFjdHVhbCBtZXNzYWdlOiBcXFwiXCIuY29uY2F0KGFjdHVhbCAmJiBhY3R1YWwubWVzc2FnZSwgXCJcXFwiXCIpLFxuICAgICAgc3RhY2tTdGFydEZuOiBzdGFja1N0YXJ0Rm5cbiAgICB9KTtcbiAgfVxuXG4gIHRocm93IGFjdHVhbDtcbn1cblxuYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uIHRocm93cyhwcm9taXNlRm4pIHtcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG5cbiAgZXhwZWN0c0Vycm9yLmFwcGx5KHZvaWQgMCwgW3Rocm93cywgZ2V0QWN0dWFsKHByb21pc2VGbildLmNvbmNhdChhcmdzKSk7XG59O1xuXG5hc3NlcnQucmVqZWN0cyA9IGZ1bmN0aW9uIHJlamVjdHMocHJvbWlzZUZuKSB7XG4gIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSwgX2tleTMgPSAxOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgYXJnc1tfa2V5MyAtIDFdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgfVxuXG4gIHJldHVybiB3YWl0Rm9yQWN0dWFsKHByb21pc2VGbikudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIGV4cGVjdHNFcnJvci5hcHBseSh2b2lkIDAsIFtyZWplY3RzLCByZXN1bHRdLmNvbmNhdChhcmdzKSk7XG4gIH0pO1xufTtcblxuYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uIGRvZXNOb3RUaHJvdyhmbikge1xuICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQgPiAxID8gX2xlbjQgLSAxIDogMCksIF9rZXk0ID0gMTsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgIGFyZ3NbX2tleTQgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gIH1cblxuICBleHBlY3RzTm9FcnJvci5hcHBseSh2b2lkIDAsIFtkb2VzTm90VGhyb3csIGdldEFjdHVhbChmbildLmNvbmNhdChhcmdzKSk7XG59O1xuXG5hc3NlcnQuZG9lc05vdFJlamVjdCA9IGZ1bmN0aW9uIGRvZXNOb3RSZWplY3QoZm4pIHtcbiAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41ID4gMSA/IF9sZW41IC0gMSA6IDApLCBfa2V5NSA9IDE7IF9rZXk1IDwgX2xlbjU7IF9rZXk1KyspIHtcbiAgICBhcmdzW19rZXk1IC0gMV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICB9XG5cbiAgcmV0dXJuIHdhaXRGb3JBY3R1YWwoZm4pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiBleHBlY3RzTm9FcnJvci5hcHBseSh2b2lkIDAsIFtkb2VzTm90UmVqZWN0LCByZXN1bHRdLmNvbmNhdChhcmdzKSk7XG4gIH0pO1xufTtcblxuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbiBpZkVycm9yKGVycikge1xuICBpZiAoZXJyICE9PSBudWxsICYmIGVyciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnaWZFcnJvciBnb3QgdW53YW50ZWQgZXhjZXB0aW9uOiAnO1xuXG4gICAgaWYgKF90eXBlb2YoZXJyKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGVyci5tZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKGVyci5tZXNzYWdlLmxlbmd0aCA9PT0gMCAmJiBlcnIuY29uc3RydWN0b3IpIHtcbiAgICAgICAgbWVzc2FnZSArPSBlcnIuY29uc3RydWN0b3IubmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gZXJyLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UgKz0gaW5zcGVjdChlcnIpO1xuICAgIH1cblxuICAgIHZhciBuZXdFcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgYWN0dWFsOiBlcnIsXG4gICAgICBleHBlY3RlZDogbnVsbCxcbiAgICAgIG9wZXJhdG9yOiAnaWZFcnJvcicsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgc3RhY2tTdGFydEZuOiBpZkVycm9yXG4gICAgfSk7IC8vIE1ha2Ugc3VyZSB3ZSBhY3R1YWxseSBoYXZlIGEgc3RhY2sgdHJhY2UhXG5cbiAgICB2YXIgb3JpZ1N0YWNrID0gZXJyLnN0YWNrO1xuXG4gICAgaWYgKHR5cGVvZiBvcmlnU3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIHdpbGwgcmVtb3ZlIGFueSBkdXBsaWNhdGVkIGZyYW1lcyBmcm9tIHRoZSBlcnJvciBmcmFtZXMgdGFrZW5cbiAgICAgIC8vIGZyb20gd2l0aGluIGBpZkVycm9yYCBhbmQgYWRkIHRoZSBvcmlnaW5hbCBlcnJvciBmcmFtZXMgdG8gdGhlIG5ld2x5XG4gICAgICAvLyBjcmVhdGVkIG9uZXMuXG4gICAgICB2YXIgdG1wMiA9IG9yaWdTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB0bXAyLnNoaWZ0KCk7IC8vIEZpbHRlciBhbGwgZnJhbWVzIGV4aXN0aW5nIGluIGVyci5zdGFjay5cblxuICAgICAgdmFyIHRtcDEgPSBuZXdFcnIuc3RhY2suc3BsaXQoJ1xcbicpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRtcDIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRmluZCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiB0aGUgZnJhbWUuXG4gICAgICAgIHZhciBwb3MgPSB0bXAxLmluZGV4T2YodG1wMltpXSk7XG5cbiAgICAgICAgaWYgKHBvcyAhPT0gLTEpIHtcbiAgICAgICAgICAvLyBPbmx5IGtlZXAgbmV3IGZyYW1lcy5cbiAgICAgICAgICB0bXAxID0gdG1wMS5zbGljZSgwLCBwb3MpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5ld0Vyci5zdGFjayA9IFwiXCIuY29uY2F0KHRtcDEuam9pbignXFxuJyksIFwiXFxuXCIpLmNvbmNhdCh0bXAyLmpvaW4oJ1xcbicpKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXdFcnI7XG4gIH1cbn07IC8vIEV4cG9zZSBhIHN0cmljdCBvbmx5IHZhcmlhbnQgb2YgYXNzZXJ0XG5cblxuZnVuY3Rpb24gc3RyaWN0KCkge1xuICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYpLCBfa2V5NiA9IDA7IF9rZXk2IDwgX2xlbjY7IF9rZXk2KyspIHtcbiAgICBhcmdzW19rZXk2XSA9IGFyZ3VtZW50c1tfa2V5Nl07XG4gIH1cblxuICBpbm5lck9rLmFwcGx5KHZvaWQgMCwgW3N0cmljdCwgYXJncy5sZW5ndGhdLmNvbmNhdChhcmdzKSk7XG59XG5cbmFzc2VydC5zdHJpY3QgPSBvYmplY3RBc3NpZ24oc3RyaWN0LCBhc3NlcnQsIHtcbiAgZXF1YWw6IGFzc2VydC5zdHJpY3RFcXVhbCxcbiAgZGVlcEVxdWFsOiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsLFxuICBub3RFcXVhbDogYXNzZXJ0Lm5vdFN0cmljdEVxdWFsLFxuICBub3REZWVwRXF1YWw6IGFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWxcbn0pO1xuYXNzZXJ0LnN0cmljdC5zdHJpY3QgPSBhc3NlcnQuc3RyaWN0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNDA4Mjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBwcm92aWRlZCBkZXBlbmRlbmN5ICovIHZhciBwcm9jZXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NDA2KTtcbi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvaW50ZXJuYWwvYXNzZXJ0L2Fzc2VydGlvbl9lcnJvci5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8wODE3ODQwZjc3NTAzMjE2OWRkZDcwYzg1YWMwNTlmMThmZmNjODFjXG5cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7IG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7IH0pKTsgfSBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDsgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzczsgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikgeyBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTsgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7IH0gZnVuY3Rpb24gV3JhcHBlcigpIHsgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTsgfSBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBXcmFwcGVyLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTsgfTsgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDsgfSBlbHNlIHsgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyB2YXIgYSA9IFtudWxsXTsgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpOyB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7IHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpOyBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTsgcmV0dXJuIGluc3RhbmNlOyB9OyB9IHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHsgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzMzNSksXG4gICAgaW5zcGVjdCA9IF9yZXF1aXJlLmluc3BlY3Q7XG5cbnZhciBfcmVxdWlyZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1MTUpLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUyLmNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFOyAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZW5kc1dpdGhcblxuXG5mdW5jdGlvbiBlbmRzV2l0aChzdHIsIHNlYXJjaCwgdGhpc19sZW4pIHtcbiAgaWYgKHRoaXNfbGVuID09PSB1bmRlZmluZWQgfHwgdGhpc19sZW4gPiBzdHIubGVuZ3RoKSB7XG4gICAgdGhpc19sZW4gPSBzdHIubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcodGhpc19sZW4gLSBzZWFyY2gubGVuZ3RoLCB0aGlzX2xlbikgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3JlcGVhdFxuXG5cbmZ1bmN0aW9uIHJlcGVhdChzdHIsIGNvdW50KSB7XG4gIGNvdW50ID0gTWF0aC5mbG9vcihjb3VudCk7XG4gIGlmIChzdHIubGVuZ3RoID09IDAgfHwgY291bnQgPT0gMCkgcmV0dXJuICcnO1xuICB2YXIgbWF4Q291bnQgPSBzdHIubGVuZ3RoICogY291bnQ7XG4gIGNvdW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZyhjb3VudCkgLyBNYXRoLmxvZygyKSk7XG5cbiAgd2hpbGUgKGNvdW50KSB7XG4gICAgc3RyICs9IHN0cjtcbiAgICBjb3VudC0tO1xuICB9XG5cbiAgc3RyICs9IHN0ci5zdWJzdHJpbmcoMCwgbWF4Q291bnQgLSBzdHIubGVuZ3RoKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxudmFyIGJsdWUgPSAnJztcbnZhciBncmVlbiA9ICcnO1xudmFyIHJlZCA9ICcnO1xudmFyIHdoaXRlID0gJyc7XG52YXIga1JlYWRhYmxlT3BlcmF0b3IgPSB7XG4gIGRlZXBTdHJpY3RFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBzdHJpY3RseSBkZWVwLWVxdWFsOicsXG4gIHN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIHN0cmljdGx5IGVxdWFsOicsXG4gIHN0cmljdEVxdWFsT2JqZWN0OiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSByZWZlcmVuY2UtZXF1YWwgdG8gXCJleHBlY3RlZFwiOicsXG4gIGRlZXBFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBsb29zZWx5IGRlZXAtZXF1YWw6JyxcbiAgZXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgbG9vc2VseSBlcXVhbDonLFxuICBub3REZWVwU3RyaWN0RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSBzdHJpY3RseSBkZWVwLWVxdWFsIHRvOicsXG4gIG5vdFN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSBzdHJpY3RseSB1bmVxdWFsIHRvOicsXG4gIG5vdFN0cmljdEVxdWFsT2JqZWN0OiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiBub3QgdG8gYmUgcmVmZXJlbmNlLWVxdWFsIHRvIFwiZXhwZWN0ZWRcIjonLFxuICBub3REZWVwRXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSBsb29zZWx5IGRlZXAtZXF1YWwgdG86JyxcbiAgbm90RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIHRvIGJlIGxvb3NlbHkgdW5lcXVhbCB0bzonLFxuICBub3RJZGVudGljYWw6ICdWYWx1ZXMgaWRlbnRpY2FsIGJ1dCBub3QgcmVmZXJlbmNlLWVxdWFsOidcbn07IC8vIENvbXBhcmluZyBzaG9ydCBwcmltaXRpdmVzIHNob3VsZCBqdXN0IHNob3cgPT09IC8gIT09IGluc3RlYWQgb2YgdXNpbmcgdGhlXG4vLyBkaWZmLlxuXG52YXIga01heFNob3J0TGVuZ3RoID0gMTA7XG5cbmZ1bmN0aW9uIGNvcHlFcnJvcihzb3VyY2UpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIgdGFyZ2V0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc291cmNlKSk7XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsICdtZXNzYWdlJywge1xuICAgIHZhbHVlOiBzb3VyY2UubWVzc2FnZVxuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gaW5zcGVjdFZhbHVlKHZhbCkge1xuICAvLyBUaGUgdXRpbC5pbnNwZWN0IGRlZmF1bHQgdmFsdWVzIGNvdWxkIGJlIGNoYW5nZWQuIFRoaXMgbWFrZXMgc3VyZSB0aGVcbiAgLy8gZXJyb3IgbWVzc2FnZXMgY29udGFpbiB0aGUgbmVjZXNzYXJ5IGluZm9ybWF0aW9uIG5ldmVydGhlbGVzcy5cbiAgcmV0dXJuIGluc3BlY3QodmFsLCB7XG4gICAgY29tcGFjdDogZmFsc2UsXG4gICAgY3VzdG9tSW5zcGVjdDogZmFsc2UsXG4gICAgZGVwdGg6IDEwMDAsXG4gICAgbWF4QXJyYXlMZW5ndGg6IEluZmluaXR5LFxuICAgIC8vIEFzc2VydCBjb21wYXJlcyBvbmx5IGVudW1lcmFibGUgcHJvcGVydGllcyAod2l0aCBhIGZldyBleGNlcHRpb25zKS5cbiAgICBzaG93SGlkZGVuOiBmYWxzZSxcbiAgICAvLyBIYXZpbmcgYSBsb25nIGxpbmUgYXMgZXJyb3IgaXMgYmV0dGVyIHRoYW4gd3JhcHBpbmcgdGhlIGxpbmUgZm9yXG4gICAgLy8gY29tcGFyaXNvbiBmb3Igbm93LlxuICAgIC8vIFRPRE8oQnJpZGdlQVIpOiBgYnJlYWtMZW5ndGhgIHNob3VsZCBiZSBsaW1pdGVkIGFzIHNvb24gYXMgc29vbiBhcyB3ZVxuICAgIC8vIGhhdmUgbWV0YSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaW5zcGVjdGVkIHByb3BlcnRpZXMgKGkuZS4sIGtub3cgd2hlcmVcbiAgICAvLyBpbiB3aGF0IGxpbmUgdGhlIHByb3BlcnR5IHN0YXJ0cyBhbmQgZW5kcykuXG4gICAgYnJlYWtMZW5ndGg6IEluZmluaXR5LFxuICAgIC8vIEFzc2VydCBkb2VzIG5vdCBkZXRlY3QgcHJveGllcyBjdXJyZW50bHkuXG4gICAgc2hvd1Byb3h5OiBmYWxzZSxcbiAgICBzb3J0ZWQ6IHRydWUsXG4gICAgLy8gSW5zcGVjdCBnZXR0ZXJzIGFzIHdlIGFsc28gY2hlY2sgdGhlbSB3aGVuIGNvbXBhcmluZyBlbnRyaWVzLlxuICAgIGdldHRlcnM6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVyckRpZmYoYWN0dWFsLCBleHBlY3RlZCwgb3BlcmF0b3IpIHtcbiAgdmFyIG90aGVyID0gJyc7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIGxhc3RQb3MgPSAwO1xuICB2YXIgZW5kID0gJyc7XG4gIHZhciBza2lwcGVkID0gZmFsc2U7XG4gIHZhciBhY3R1YWxJbnNwZWN0ZWQgPSBpbnNwZWN0VmFsdWUoYWN0dWFsKTtcbiAgdmFyIGFjdHVhbExpbmVzID0gYWN0dWFsSW5zcGVjdGVkLnNwbGl0KCdcXG4nKTtcbiAgdmFyIGV4cGVjdGVkTGluZXMgPSBpbnNwZWN0VmFsdWUoZXhwZWN0ZWQpLnNwbGl0KCdcXG4nKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgaW5kaWNhdG9yID0gJyc7IC8vIEluIGNhc2UgYm90aCB2YWx1ZXMgYXJlIG9iamVjdHMgZXhwbGljaXRseSBtYXJrIHRoZW0gYXMgbm90IHJlZmVyZW5jZSBlcXVhbFxuICAvLyBmb3IgdGhlIGBzdHJpY3RFcXVhbGAgb3BlcmF0b3IuXG5cbiAgaWYgKG9wZXJhdG9yID09PSAnc3RyaWN0RXF1YWwnICYmIF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgX3R5cGVvZihleHBlY3RlZCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCAmJiBleHBlY3RlZCAhPT0gbnVsbCkge1xuICAgIG9wZXJhdG9yID0gJ3N0cmljdEVxdWFsT2JqZWN0JztcbiAgfSAvLyBJZiBcImFjdHVhbFwiIGFuZCBcImV4cGVjdGVkXCIgZml0IG9uIGEgc2luZ2xlIGxpbmUgYW5kIHRoZXkgYXJlIG5vdCBzdHJpY3RseVxuICAvLyBlcXVhbCwgY2hlY2sgZnVydGhlciBzcGVjaWFsIGhhbmRsaW5nLlxuXG5cbiAgaWYgKGFjdHVhbExpbmVzLmxlbmd0aCA9PT0gMSAmJiBleHBlY3RlZExpbmVzLmxlbmd0aCA9PT0gMSAmJiBhY3R1YWxMaW5lc1swXSAhPT0gZXhwZWN0ZWRMaW5lc1swXSkge1xuICAgIHZhciBpbnB1dExlbmd0aCA9IGFjdHVhbExpbmVzWzBdLmxlbmd0aCArIGV4cGVjdGVkTGluZXNbMF0ubGVuZ3RoOyAvLyBJZiB0aGUgY2hhcmFjdGVyIGxlbmd0aCBvZiBcImFjdHVhbFwiIGFuZCBcImV4cGVjdGVkXCIgdG9nZXRoZXIgaXMgbGVzcyB0aGFuXG4gICAgLy8ga01heFNob3J0TGVuZ3RoIGFuZCBpZiBuZWl0aGVyIGlzIGFuIG9iamVjdCBhbmQgYXQgbGVhc3Qgb25lIG9mIHRoZW0gaXNcbiAgICAvLyBub3QgYHplcm9gLCB1c2UgdGhlIHN0cmljdCBlcXVhbCBjb21wYXJpc29uIHRvIHZpc3VhbGl6ZSB0aGUgb3V0cHV0LlxuXG4gICAgaWYgKGlucHV0TGVuZ3RoIDw9IGtNYXhTaG9ydExlbmd0aCkge1xuICAgICAgaWYgKChfdHlwZW9mKGFjdHVhbCkgIT09ICdvYmplY3QnIHx8IGFjdHVhbCA9PT0gbnVsbCkgJiYgKF90eXBlb2YoZXhwZWN0ZWQpICE9PSAnb2JqZWN0JyB8fCBleHBlY3RlZCA9PT0gbnVsbCkgJiYgKGFjdHVhbCAhPT0gMCB8fCBleHBlY3RlZCAhPT0gMCkpIHtcbiAgICAgICAgLy8gLTAgPT09ICswXG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl0sIFwiXFxuXFxuXCIpICsgXCJcIi5jb25jYXQoYWN0dWFsTGluZXNbMF0sIFwiICE9PSBcIikuY29uY2F0KGV4cGVjdGVkTGluZXNbMF0sIFwiXFxuXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgIT09ICdzdHJpY3RFcXVhbE9iamVjdCcpIHtcbiAgICAgIC8vIElmIHRoZSBzdGRlcnIgaXMgYSB0dHkgYW5kIHRoZSBpbnB1dCBsZW5ndGggaXMgbG93ZXIgdGhhbiB0aGUgY3VycmVudFxuICAgICAgLy8gY29sdW1ucyBwZXIgbGluZSwgYWRkIGEgbWlzbWF0Y2ggaW5kaWNhdG9yIGJlbG93IHRoZSBvdXRwdXQuIElmIGl0IGlzXG4gICAgICAvLyBub3QgYSB0dHksIHVzZSBhIGRlZmF1bHQgdmFsdWUgb2YgODAgY2hhcmFjdGVycy5cbiAgICAgIHZhciBtYXhMZW5ndGggPSBwcm9jZXNzLnN0ZGVyciAmJiBwcm9jZXNzLnN0ZGVyci5pc1RUWSA/IHByb2Nlc3Muc3RkZXJyLmNvbHVtbnMgOiA4MDtcblxuICAgICAgaWYgKGlucHV0TGVuZ3RoIDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgIHdoaWxlIChhY3R1YWxMaW5lc1swXVtpXSA9PT0gZXhwZWN0ZWRMaW5lc1swXVtpXSkge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfSAvLyBJZ25vcmUgdGhlIGZpcnN0IGNoYXJhY3RlcnMuXG5cblxuICAgICAgICBpZiAoaSA+IDIpIHtcbiAgICAgICAgICAvLyBBZGQgcG9zaXRpb24gaW5kaWNhdG9yIGZvciB0aGUgZmlyc3QgbWlzbWF0Y2ggaW4gY2FzZSBpdCBpcyBhXG4gICAgICAgICAgLy8gc2luZ2xlIGxpbmUgYW5kIHRoZSBpbnB1dCBsZW5ndGggaXMgbGVzcyB0aGFuIHRoZSBjb2x1bW4gbGVuZ3RoLlxuICAgICAgICAgIGluZGljYXRvciA9IFwiXFxuICBcIi5jb25jYXQocmVwZWF0KCcgJywgaSksIFwiXlwiKTtcbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBSZW1vdmUgYWxsIGVuZGluZyBsaW5lcyB0aGF0IG1hdGNoICh0aGlzIG9wdGltaXplcyB0aGUgb3V0cHV0IGZvclxuICAvLyByZWFkYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgbnVtYmVyIG9mIHRvdGFsIGNoYW5nZWQgbGluZXMpLlxuXG5cbiAgdmFyIGEgPSBhY3R1YWxMaW5lc1thY3R1YWxMaW5lcy5sZW5ndGggLSAxXTtcbiAgdmFyIGIgPSBleHBlY3RlZExpbmVzW2V4cGVjdGVkTGluZXMubGVuZ3RoIC0gMV07XG5cbiAgd2hpbGUgKGEgPT09IGIpIHtcbiAgICBpZiAoaSsrIDwgMikge1xuICAgICAgZW5kID0gXCJcXG4gIFwiLmNvbmNhdChhKS5jb25jYXQoZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3RoZXIgPSBhO1xuICAgIH1cblxuICAgIGFjdHVhbExpbmVzLnBvcCgpO1xuICAgIGV4cGVjdGVkTGluZXMucG9wKCk7XG4gICAgaWYgKGFjdHVhbExpbmVzLmxlbmd0aCA9PT0gMCB8fCBleHBlY3RlZExpbmVzLmxlbmd0aCA9PT0gMCkgYnJlYWs7XG4gICAgYSA9IGFjdHVhbExpbmVzW2FjdHVhbExpbmVzLmxlbmd0aCAtIDFdO1xuICAgIGIgPSBleHBlY3RlZExpbmVzW2V4cGVjdGVkTGluZXMubGVuZ3RoIC0gMV07XG4gIH1cblxuICB2YXIgbWF4TGluZXMgPSBNYXRoLm1heChhY3R1YWxMaW5lcy5sZW5ndGgsIGV4cGVjdGVkTGluZXMubGVuZ3RoKTsgLy8gU3RyaWN0IGVxdWFsIHdpdGggaWRlbnRpY2FsIG9iamVjdHMgdGhhdCBhcmUgbm90IGlkZW50aWNhbCBieSByZWZlcmVuY2UuXG4gIC8vIEUuZy4sIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoeyBhOiBTeW1ib2woKSB9LCB7IGE6IFN5bWJvbCgpIH0pXG5cbiAgaWYgKG1heExpbmVzID09PSAwKSB7XG4gICAgLy8gV2UgaGF2ZSB0byBnZXQgdGhlIHJlc3VsdCBhZ2Fpbi4gVGhlIGxpbmVzIHdlcmUgYWxsIHJlbW92ZWQgYmVmb3JlLlxuICAgIHZhciBfYWN0dWFsTGluZXMgPSBhY3R1YWxJbnNwZWN0ZWQuc3BsaXQoJ1xcbicpOyAvLyBPbmx5IHJlbW92ZSBsaW5lcyBpbiBjYXNlIGl0IG1ha2VzIHNlbnNlIHRvIGNvbGxhcHNlIHRob3NlLlxuICAgIC8vIFRPRE86IEFjY2VwdCBlbnYgdG8gYWx3YXlzIHNob3cgdGhlIGZ1bGwgZXJyb3IuXG5cblxuICAgIGlmIChfYWN0dWFsTGluZXMubGVuZ3RoID4gMzApIHtcbiAgICAgIF9hY3R1YWxMaW5lc1syNl0gPSBcIlwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuXG4gICAgICB3aGlsZSAoX2FjdHVhbExpbmVzLmxlbmd0aCA+IDI3KSB7XG4gICAgICAgIF9hY3R1YWxMaW5lcy5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gXCJcIi5jb25jYXQoa1JlYWRhYmxlT3BlcmF0b3Iubm90SWRlbnRpY2FsLCBcIlxcblxcblwiKS5jb25jYXQoX2FjdHVhbExpbmVzLmpvaW4oJ1xcbicpLCBcIlxcblwiKTtcbiAgfVxuXG4gIGlmIChpID4gMykge1xuICAgIGVuZCA9IFwiXFxuXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSkuY29uY2F0KGVuZCk7XG4gICAgc2tpcHBlZCA9IHRydWU7XG4gIH1cblxuICBpZiAob3RoZXIgIT09ICcnKSB7XG4gICAgZW5kID0gXCJcXG4gIFwiLmNvbmNhdChvdGhlcikuY29uY2F0KGVuZCk7XG4gICAgb3RoZXIgPSAnJztcbiAgfVxuXG4gIHZhciBwcmludGVkTGluZXMgPSAwO1xuICB2YXIgbXNnID0ga1JlYWRhYmxlT3BlcmF0b3Jbb3BlcmF0b3JdICsgXCJcXG5cIi5jb25jYXQoZ3JlZW4sIFwiKyBhY3R1YWxcIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KHJlZCwgXCItIGV4cGVjdGVkXCIpLmNvbmNhdCh3aGl0ZSk7XG4gIHZhciBza2lwcGVkTXNnID0gXCIgXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSwgXCIgTGluZXMgc2tpcHBlZFwiKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbWF4TGluZXM7IGkrKykge1xuICAgIC8vIE9ubHkgZXh0cmEgZXhwZWN0ZWQgbGluZXMgZXhpc3RcbiAgICB2YXIgY3VyID0gaSAtIGxhc3RQb3M7XG5cbiAgICBpZiAoYWN0dWFsTGluZXMubGVuZ3RoIDwgaSArIDEpIHtcbiAgICAgIC8vIElmIHRoZSBsYXN0IGRpdmVyZ2luZyBsaW5lIGlzIG1vcmUgdGhhbiBvbmUgbGluZSBhYm92ZSBhbmQgdGhlXG4gICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYXQgbGVhc3QgbGluZSB0aHJlZSwgYWRkIHNvbWUgb2YgdGhlIGZvcm1lciBsaW5lcyBhbmRcbiAgICAgIC8vIGFsc28gYWRkIGRvdHMgdG8gaW5kaWNhdGUgc2tpcHBlZCBlbnRyaWVzLlxuICAgICAgaWYgKGN1ciA+IDEgJiYgaSA+IDIpIHtcbiAgICAgICAgaWYgKGN1ciA+IDQpIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG5cIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcbiAgICAgICAgICBza2lwcGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXIgPiAzKSB7XG4gICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoZXhwZWN0ZWRMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoZXhwZWN0ZWRMaW5lc1tpIC0gMV0pO1xuICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgIH0gLy8gTWFyayB0aGUgY3VycmVudCBsaW5lIGFzIHRoZSBsYXN0IGRpdmVyZ2luZyBvbmUuXG5cblxuICAgICAgbGFzdFBvcyA9IGk7IC8vIEFkZCB0aGUgZXhwZWN0ZWQgbGluZSB0byB0aGUgY2FjaGUuXG5cbiAgICAgIG90aGVyICs9IFwiXFxuXCIuY29uY2F0KHJlZCwgXCItXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChleHBlY3RlZExpbmVzW2ldKTtcbiAgICAgIHByaW50ZWRMaW5lcysrOyAvLyBPbmx5IGV4dHJhIGFjdHVhbCBsaW5lcyBleGlzdFxuICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWRMaW5lcy5sZW5ndGggPCBpICsgMSkge1xuICAgICAgLy8gSWYgdGhlIGxhc3QgZGl2ZXJnaW5nIGxpbmUgaXMgbW9yZSB0aGFuIG9uZSBsaW5lIGFib3ZlIGFuZCB0aGVcbiAgICAgIC8vIGN1cnJlbnQgbGluZSBpcyBhdCBsZWFzdCBsaW5lIHRocmVlLCBhZGQgc29tZSBvZiB0aGUgZm9ybWVyIGxpbmVzIGFuZFxuICAgICAgLy8gYWxzbyBhZGQgZG90cyB0byBpbmRpY2F0ZSBza2lwcGVkIGVudHJpZXMuXG4gICAgICBpZiAoY3VyID4gMSAmJiBpID4gMikge1xuICAgICAgICBpZiAoY3VyID4gNCkge1xuICAgICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgICAgICAgIHNraXBwZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGN1ciA+IDMpIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDFdKTtcbiAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICB9IC8vIE1hcmsgdGhlIGN1cnJlbnQgbGluZSBhcyB0aGUgbGFzdCBkaXZlcmdpbmcgb25lLlxuXG5cbiAgICAgIGxhc3RQb3MgPSBpOyAvLyBBZGQgdGhlIGFjdHVhbCBsaW5lIHRvIHRoZSByZXN1bHQuXG5cbiAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChncmVlbiwgXCIrXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChhY3R1YWxMaW5lc1tpXSk7XG4gICAgICBwcmludGVkTGluZXMrKzsgLy8gTGluZXMgZGl2ZXJnZVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXhwZWN0ZWRMaW5lID0gZXhwZWN0ZWRMaW5lc1tpXTtcbiAgICAgIHZhciBhY3R1YWxMaW5lID0gYWN0dWFsTGluZXNbaV07IC8vIElmIHRoZSBsaW5lcyBkaXZlcmdlLCBzcGVjaWZpY2FsbHkgY2hlY2sgZm9yIGxpbmVzIHRoYXQgb25seSBkaXZlcmdlIGJ5XG4gICAgICAvLyBhIHRyYWlsaW5nIGNvbW1hLiBJbiB0aGF0IGNhc2UgaXQgaXMgYWN0dWFsbHkgaWRlbnRpY2FsIGFuZCB3ZSBzaG91bGRcbiAgICAgIC8vIG1hcmsgaXQgYXMgc3VjaC5cblxuICAgICAgdmFyIGRpdmVyZ2luZ0xpbmVzID0gYWN0dWFsTGluZSAhPT0gZXhwZWN0ZWRMaW5lICYmICghZW5kc1dpdGgoYWN0dWFsTGluZSwgJywnKSB8fCBhY3R1YWxMaW5lLnNsaWNlKDAsIC0xKSAhPT0gZXhwZWN0ZWRMaW5lKTsgLy8gSWYgdGhlIGV4cGVjdGVkIGxpbmUgaGFzIGEgdHJhaWxpbmcgY29tbWEgYnV0IGlzIG90aGVyd2lzZSBpZGVudGljYWwsXG4gICAgICAvLyBhZGQgYSBjb21tYSBhdCB0aGUgZW5kIG9mIHRoZSBhY3R1YWwgbGluZS4gT3RoZXJ3aXNlIHRoZSBvdXRwdXQgY291bGRcbiAgICAgIC8vIGxvb2sgd2VpcmQgYXMgaW46XG4gICAgICAvL1xuICAgICAgLy8gICBbXG4gICAgICAvLyAgICAgMSAgICAgICAgIC8vIE5vIGNvbW1hIGF0IHRoZSBlbmQhXG4gICAgICAvLyArICAgMlxuICAgICAgLy8gICBdXG4gICAgICAvL1xuXG4gICAgICBpZiAoZGl2ZXJnaW5nTGluZXMgJiYgZW5kc1dpdGgoZXhwZWN0ZWRMaW5lLCAnLCcpICYmIGV4cGVjdGVkTGluZS5zbGljZSgwLCAtMSkgPT09IGFjdHVhbExpbmUpIHtcbiAgICAgICAgZGl2ZXJnaW5nTGluZXMgPSBmYWxzZTtcbiAgICAgICAgYWN0dWFsTGluZSArPSAnLCc7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXZlcmdpbmdMaW5lcykge1xuICAgICAgICAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBtb3JlIHRoYW4gb25lIGxpbmUgYWJvdmUgYW5kIHRoZVxuICAgICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYXQgbGVhc3QgbGluZSB0aHJlZSwgYWRkIHNvbWUgb2YgdGhlIGZvcm1lciBsaW5lcyBhbmRcbiAgICAgICAgLy8gYWxzbyBhZGQgZG90cyB0byBpbmRpY2F0ZSBza2lwcGVkIGVudHJpZXMuXG4gICAgICAgIGlmIChjdXIgPiAxICYmIGkgPiAyKSB7XG4gICAgICAgICAgaWYgKGN1ciA+IDQpIHtcbiAgICAgICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgICAgICAgICAgc2tpcHBlZCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXIgPiAzKSB7XG4gICAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDFdKTtcbiAgICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgICAgfSAvLyBNYXJrIHRoZSBjdXJyZW50IGxpbmUgYXMgdGhlIGxhc3QgZGl2ZXJnaW5nIG9uZS5cblxuXG4gICAgICAgIGxhc3RQb3MgPSBpOyAvLyBBZGQgdGhlIGFjdHVhbCBsaW5lIHRvIHRoZSByZXN1bHQgYW5kIGNhY2hlIHRoZSBleHBlY3RlZCBkaXZlcmdpbmdcbiAgICAgICAgLy8gbGluZSBzbyBjb25zZWN1dGl2ZSBkaXZlcmdpbmcgbGluZXMgc2hvdyB1cCBhcyArKystLS0gYW5kIG5vdCArLSstKy0uXG5cbiAgICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGdyZWVuLCBcIitcIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KGFjdHVhbExpbmUpO1xuICAgICAgICBvdGhlciArPSBcIlxcblwiLmNvbmNhdChyZWQsIFwiLVwiKS5jb25jYXQod2hpdGUsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRMaW5lKTtcbiAgICAgICAgcHJpbnRlZExpbmVzICs9IDI7IC8vIExpbmVzIGFyZSBpZGVudGljYWxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFkZCBhbGwgY2FjaGVkIGluZm9ybWF0aW9uIHRvIHRoZSByZXN1bHQgYmVmb3JlIGFkZGluZyBvdGhlciB0aGluZ3NcbiAgICAgICAgLy8gYW5kIHJlc2V0IHRoZSBjYWNoZS5cbiAgICAgICAgcmVzICs9IG90aGVyO1xuICAgICAgICBvdGhlciA9ICcnOyAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBleGFjdGx5IG9uZSBsaW5lIGFib3ZlIG9yIGlmIGl0IGlzIHRoZVxuICAgICAgICAvLyB2ZXJ5IGZpcnN0IGxpbmUsIGFkZCB0aGUgbGluZSB0byB0aGUgcmVzdWx0LlxuXG4gICAgICAgIGlmIChjdXIgPT09IDEgfHwgaSA9PT0gMCkge1xuICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmUpO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBJbnNwZWN0ZWQgb2JqZWN0IHRvIGJpZyAoU2hvdyB+MjAgcm93cyBtYXgpXG5cblxuICAgIGlmIChwcmludGVkTGluZXMgPiAyMCAmJiBpIDwgbWF4TGluZXMgLSAyKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQobXNnKS5jb25jYXQoc2tpcHBlZE1zZywgXCJcXG5cIikuY29uY2F0KHJlcywgXCJcXG5cIikuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSkuY29uY2F0KG90aGVyLCBcIlxcblwiKSArIFwiXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFwiXCIuY29uY2F0KG1zZykuY29uY2F0KHNraXBwZWQgPyBza2lwcGVkTXNnIDogJycsIFwiXFxuXCIpLmNvbmNhdChyZXMpLmNvbmNhdChvdGhlcikuY29uY2F0KGVuZCkuY29uY2F0KGluZGljYXRvcik7XG59XG5cbnZhciBBc3NlcnRpb25FcnJvciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Vycm9yKSB7XG4gIF9pbmhlcml0cyhBc3NlcnRpb25FcnJvciwgX0Vycm9yKTtcblxuICBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFzc2VydGlvbkVycm9yKTtcblxuICAgIGlmIChfdHlwZW9mKG9wdGlvbnMpICE9PSAnb2JqZWN0JyB8fCBvcHRpb25zID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ29wdGlvbnMnLCAnT2JqZWN0Jywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdmFyIG1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UsXG4gICAgICAgIG9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcixcbiAgICAgICAgc3RhY2tTdGFydEZuID0gb3B0aW9ucy5zdGFja1N0YXJ0Rm47XG4gICAgdmFyIGFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsLFxuICAgICAgICBleHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gICAgdmFyIGxpbWl0ID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0O1xuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IDA7XG5cbiAgICBpZiAobWVzc2FnZSAhPSBudWxsKSB7XG4gICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBc3NlcnRpb25FcnJvcikuY2FsbCh0aGlzLCBTdHJpbmcobWVzc2FnZSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3Muc3RkZXJyICYmIHByb2Nlc3Muc3RkZXJyLmlzVFRZKSB7XG4gICAgICAgIC8vIFJlc2V0IG9uIGVhY2ggY2FsbCB0byBtYWtlIHN1cmUgd2UgaGFuZGxlIGR5bmFtaWNhbGx5IHNldCBlbnZpcm9ubWVudFxuICAgICAgICAvLyB2YXJpYWJsZXMgY29ycmVjdC5cbiAgICAgICAgaWYgKHByb2Nlc3Muc3RkZXJyICYmIHByb2Nlc3Muc3RkZXJyLmdldENvbG9yRGVwdGggJiYgcHJvY2Vzcy5zdGRlcnIuZ2V0Q29sb3JEZXB0aCgpICE9PSAxKSB7XG4gICAgICAgICAgYmx1ZSA9IFwiXFx4MUJbMzRtXCI7XG4gICAgICAgICAgZ3JlZW4gPSBcIlxceDFCWzMybVwiO1xuICAgICAgICAgIHdoaXRlID0gXCJcXHgxQlszOW1cIjtcbiAgICAgICAgICByZWQgPSBcIlxceDFCWzMxbVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJsdWUgPSAnJztcbiAgICAgICAgICBncmVlbiA9ICcnO1xuICAgICAgICAgIHdoaXRlID0gJyc7XG4gICAgICAgICAgcmVkID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUHJldmVudCB0aGUgZXJyb3Igc3RhY2sgZnJvbSBiZWluZyB2aXNpYmxlIGJ5IGR1cGxpY2F0aW5nIHRoZSBlcnJvclxuICAgICAgLy8gaW4gYSB2ZXJ5IGNsb3NlIHdheSB0byB0aGUgb3JpZ2luYWwgaW4gY2FzZSBib3RoIHNpZGVzIGFyZSBhY3R1YWxseVxuICAgICAgLy8gaW5zdGFuY2VzIG9mIEVycm9yLlxuXG5cbiAgICAgIGlmIChfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCAmJiBfdHlwZW9mKGV4cGVjdGVkKSA9PT0gJ29iamVjdCcgJiYgZXhwZWN0ZWQgIT09IG51bGwgJiYgJ3N0YWNrJyBpbiBhY3R1YWwgJiYgYWN0dWFsIGluc3RhbmNlb2YgRXJyb3IgJiYgJ3N0YWNrJyBpbiBleHBlY3RlZCAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGFjdHVhbCA9IGNvcHlFcnJvcihhY3R1YWwpO1xuICAgICAgICBleHBlY3RlZCA9IGNvcHlFcnJvcihleHBlY3RlZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcGVyYXRvciA9PT0gJ2RlZXBTdHJpY3RFcXVhbCcgfHwgb3BlcmF0b3IgPT09ICdzdHJpY3RFcXVhbCcpIHtcbiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgY3JlYXRlRXJyRGlmZihhY3R1YWwsIGV4cGVjdGVkLCBvcGVyYXRvcikpKTtcbiAgICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgPT09ICdub3REZWVwU3RyaWN0RXF1YWwnIHx8IG9wZXJhdG9yID09PSAnbm90U3RyaWN0RXF1YWwnKSB7XG4gICAgICAgIC8vIEluIGNhc2UgdGhlIG9iamVjdHMgYXJlIGVxdWFsIGJ1dCB0aGUgb3BlcmF0b3IgcmVxdWlyZXMgdW5lcXVhbCwgc2hvd1xuICAgICAgICAvLyB0aGUgZmlyc3Qgb2JqZWN0IGFuZCBzYXkgQSBlcXVhbHMgQlxuICAgICAgICB2YXIgYmFzZSA9IGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXTtcbiAgICAgICAgdmFyIHJlcyA9IGluc3BlY3RWYWx1ZShhY3R1YWwpLnNwbGl0KCdcXG4nKTsgLy8gSW4gY2FzZSBcImFjdHVhbFwiIGlzIGFuIG9iamVjdCwgaXQgc2hvdWxkIG5vdCBiZSByZWZlcmVuY2UgZXF1YWwuXG5cbiAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnbm90U3RyaWN0RXF1YWwnICYmIF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgYWN0dWFsICE9PSBudWxsKSB7XG4gICAgICAgICAgYmFzZSA9IGtSZWFkYWJsZU9wZXJhdG9yLm5vdFN0cmljdEVxdWFsT2JqZWN0O1xuICAgICAgICB9IC8vIE9ubHkgcmVtb3ZlIGxpbmVzIGluIGNhc2UgaXQgbWFrZXMgc2Vuc2UgdG8gY29sbGFwc2UgdGhvc2UuXG4gICAgICAgIC8vIFRPRE86IEFjY2VwdCBlbnYgdG8gYWx3YXlzIHNob3cgdGhlIGZ1bGwgZXJyb3IuXG5cblxuICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDMwKSB7XG4gICAgICAgICAgcmVzWzI2XSA9IFwiXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG5cbiAgICAgICAgICB3aGlsZSAocmVzLmxlbmd0aCA+IDI3KSB7XG4gICAgICAgICAgICByZXMucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIE9ubHkgcHJpbnQgYSBzaW5nbGUgaW5wdXQuXG5cblxuICAgICAgICBpZiAocmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIFwiXCIuY29uY2F0KGJhc2UsIFwiIFwiKS5jb25jYXQocmVzWzBdKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIFwiXCIuY29uY2F0KGJhc2UsIFwiXFxuXFxuXCIpLmNvbmNhdChyZXMuam9pbignXFxuJyksIFwiXFxuXCIpKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfcmVzID0gaW5zcGVjdFZhbHVlKGFjdHVhbCk7XG5cbiAgICAgICAgdmFyIG90aGVyID0gJyc7XG4gICAgICAgIHZhciBrbm93bk9wZXJhdG9ycyA9IGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXTtcblxuICAgICAgICBpZiAob3BlcmF0b3IgPT09ICdub3REZWVwRXF1YWwnIHx8IG9wZXJhdG9yID09PSAnbm90RXF1YWwnKSB7XG4gICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXSwgXCJcXG5cXG5cIikuY29uY2F0KF9yZXMpO1xuXG4gICAgICAgICAgaWYgKF9yZXMubGVuZ3RoID4gMTAyNCkge1xuICAgICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KF9yZXMuc2xpY2UoMCwgMTAyMSksIFwiLi4uXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdGhlciA9IFwiXCIuY29uY2F0KGluc3BlY3RWYWx1ZShleHBlY3RlZCkpO1xuXG4gICAgICAgICAgaWYgKF9yZXMubGVuZ3RoID4gNTEyKSB7XG4gICAgICAgICAgICBfcmVzID0gXCJcIi5jb25jYXQoX3Jlcy5zbGljZSgwLCA1MDkpLCBcIi4uLlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3RoZXIubGVuZ3RoID4gNTEyKSB7XG4gICAgICAgICAgICBvdGhlciA9IFwiXCIuY29uY2F0KG90aGVyLnNsaWNlKDAsIDUwOSksIFwiLi4uXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcGVyYXRvciA9PT0gJ2RlZXBFcXVhbCcgfHwgb3BlcmF0b3IgPT09ICdlcXVhbCcpIHtcbiAgICAgICAgICAgIF9yZXMgPSBcIlwiLmNvbmNhdChrbm93bk9wZXJhdG9ycywgXCJcXG5cXG5cIikuY29uY2F0KF9yZXMsIFwiXFxuXFxuc2hvdWxkIGVxdWFsXFxuXFxuXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdGhlciA9IFwiIFwiLmNvbmNhdChvcGVyYXRvciwgXCIgXCIpLmNvbmNhdChvdGhlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgXCJcIi5jb25jYXQoX3JlcykuY29uY2F0KG90aGVyKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IGxpbWl0O1xuICAgIF90aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSAhbWVzc2FnZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksICduYW1lJywge1xuICAgICAgdmFsdWU6ICdBc3NlcnRpb25FcnJvciBbRVJSX0FTU0VSVElPTl0nLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIF90aGlzLmNvZGUgPSAnRVJSX0FTU0VSVElPTic7XG4gICAgX3RoaXMuYWN0dWFsID0gYWN0dWFsO1xuICAgIF90aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgX3RoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcblxuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgc3RhY2tTdGFydEZuKTtcbiAgICB9IC8vIENyZWF0ZSBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyB0aGUgZXJyb3IgY29kZSBpbiB0aGUgbmFtZS5cblxuXG4gICAgX3RoaXMuc3RhY2s7IC8vIFJlc2V0IHRoZSBuYW1lLlxuXG4gICAgX3RoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBc3NlcnRpb25FcnJvciwgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5uYW1lLCBcIiBbXCIpLmNvbmNhdCh0aGlzLmNvZGUsIFwiXTogXCIpLmNvbmNhdCh0aGlzLm1lc3NhZ2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogaW5zcGVjdC5jdXN0b20sXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHJlY3Vyc2VUaW1lcywgY3R4KSB7XG4gICAgICAvLyBUaGlzIGxpbWl0cyB0aGUgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAgcHJvcGVydHkgZGVmYXVsdCBpbnNwZWN0aW9uIHRvXG4gICAgICAvLyB0aGUgbWluaW11bSBkZXB0aC4gT3RoZXJ3aXNlIHRob3NlIHZhbHVlcyB3b3VsZCBiZSB0b28gdmVyYm9zZSBjb21wYXJlZFxuICAgICAgLy8gdG8gdGhlIGFjdHVhbCBlcnJvciBtZXNzYWdlIHdoaWNoIGNvbnRhaW5zIGEgY29tYmluZWQgdmlldyBvZiB0aGVzZSB0d29cbiAgICAgIC8vIGlucHV0IHZhbHVlcy5cbiAgICAgIHJldHVybiBpbnNwZWN0KHRoaXMsIF9vYmplY3RTcHJlYWQoe30sIGN0eCwge1xuICAgICAgICBjdXN0b21JbnNwZWN0OiBmYWxzZSxcbiAgICAgICAgZGVwdGg6IDBcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXNzZXJ0aW9uRXJyb3I7XG59KF93cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBc3NlcnRpb25FcnJvcjtcblxuLyoqKi8gfSksXG5cbi8qKiovIDc1MTU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC9lcnJvcnMuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvM2IwNDQ5NjJjNDhmZTMxMzkwNTg3N2E5NmI1ZDA4OTRhNTQwNGY2ZlxuXG4vKiBlc2xpbnQgbm9kZS1jb3JlL2RvY3VtZW50ZWQtZXJyb3JzOiBcImVycm9yXCIgKi9cblxuLyogZXNsaW50IG5vZGUtY29yZS9hbHBoYWJldGl6ZS1lcnJvcnM6IFwiZXJyb3JcIiAqL1xuXG4vKiBlc2xpbnQgbm9kZS1jb3JlL3ByZWZlci11dGlsLWZvcm1hdC1lcnJvcnM6IFwiZXJyb3JcIiAqL1xuIC8vIFRoZSB3aG9sZSBwb2ludCBiZWhpbmQgdGhpcyBpbnRlcm5hbCBtb2R1bGUgaXMgdG8gYWxsb3cgTm9kZS5qcyB0byBub1xuLy8gbG9uZ2VyIGJlIGZvcmNlZCB0byB0cmVhdCBldmVyeSBlcnJvciBtZXNzYWdlIGNoYW5nZSBhcyBhIHNlbXZlci1tYWpvclxuLy8gY2hhbmdlLiBUaGUgTm9kZUVycm9yIGNsYXNzZXMgaGVyZSBhbGwgZXhwb3NlIGEgYGNvZGVgIHByb3BlcnR5IHdob3NlXG4vLyB2YWx1ZSBzdGF0aWNhbGx5IGFuZCBwZXJtYW5lbnRseSBpZGVudGlmaWVzIHRoZSBlcnJvci4gV2hpbGUgdGhlIGVycm9yXG4vLyBtZXNzYWdlIG1heSBjaGFuZ2UsIHRoZSBjb2RlIHNob3VsZCBub3QuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIGNvZGVzID0ge307IC8vIExhenkgbG9hZGVkXG5cbnZhciBhc3NlcnQ7XG52YXIgdXRpbDtcblxuZnVuY3Rpb24gY3JlYXRlRXJyb3JUeXBlKGNvZGUsIG1lc3NhZ2UsIEJhc2UpIHtcbiAgaWYgKCFCYXNlKSB7XG4gICAgQmFzZSA9IEVycm9yO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBOb2RlRXJyb3IgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfQmFzZSkge1xuICAgIF9pbmhlcml0cyhOb2RlRXJyb3IsIF9CYXNlKTtcblxuICAgIGZ1bmN0aW9uIE5vZGVFcnJvcihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlRXJyb3IpO1xuXG4gICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihOb2RlRXJyb3IpLmNhbGwodGhpcywgZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSkpO1xuICAgICAgX3RoaXMuY29kZSA9IGNvZGU7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIE5vZGVFcnJvcjtcbiAgfShCYXNlKTtcblxuICBjb2Rlc1tjb2RlXSA9IE5vZGVFcnJvcjtcbn0gLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEwLjguMC9saWIvaW50ZXJuYWwvZXJyb3JzLmpzXG5cblxuZnVuY3Rpb24gb25lT2YoZXhwZWN0ZWQsIHRoaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdGVkKSkge1xuICAgIHZhciBsZW4gPSBleHBlY3RlZC5sZW5ndGg7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaSk7XG4gICAgfSk7XG5cbiAgICBpZiAobGVuID4gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZC5zbGljZSgwLCBsZW4gLSAxKS5qb2luKCcsICcpLCBcIiwgb3IgXCIpICsgZXhwZWN0ZWRbbGVuIC0gMV07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0sIFwiIG9yIFwiKS5jb25jYXQoZXhwZWN0ZWRbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoU3RyaW5nKGV4cGVjdGVkKSk7XG4gIH1cbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N0YXJ0c1dpdGhcblxuXG5mdW5jdGlvbiBzdGFydHNXaXRoKHN0ciwgc2VhcmNoLCBwb3MpIHtcbiAgcmV0dXJuIHN0ci5zdWJzdHIoIXBvcyB8fCBwb3MgPCAwID8gMCA6ICtwb3MsIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9lbmRzV2l0aFxuXG5cbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoLCB0aGlzX2xlbikge1xuICBpZiAodGhpc19sZW4gPT09IHVuZGVmaW5lZCB8fCB0aGlzX2xlbiA+IHN0ci5sZW5ndGgpIHtcbiAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cmluZyh0aGlzX2xlbiAtIHNlYXJjaC5sZW5ndGgsIHRoaXNfbGVuKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvaW5jbHVkZXNcblxuXG5mdW5jdGlvbiBpbmNsdWRlcyhzdHIsIHNlYXJjaCwgc3RhcnQpIHtcbiAgaWYgKHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicpIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cblxuICBpZiAoc3RhcnQgKyBzZWFyY2gubGVuZ3RoID4gc3RyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2Yoc2VhcmNoLCBzdGFydCkgIT09IC0xO1xuICB9XG59XG5cbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0FNQklHVU9VU19BUkdVTUVOVCcsICdUaGUgXCIlc1wiIGFyZ3VtZW50IGlzIGFtYmlndW91cy4gJXMnLCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsIGZ1bmN0aW9uIChuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSB7XG4gIGlmIChhc3NlcnQgPT09IHVuZGVmaW5lZCkgYXNzZXJ0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjk2KTtcbiAgYXNzZXJ0KHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJywgXCInbmFtZScgbXVzdCBiZSBhIHN0cmluZ1wiKTsgLy8gZGV0ZXJtaW5lcjogJ211c3QgYmUnIG9yICdtdXN0IG5vdCBiZSdcblxuICB2YXIgZGV0ZXJtaW5lcjtcblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJyAmJiBzdGFydHNXaXRoKGV4cGVjdGVkLCAnbm90ICcpKSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IG5vdCBiZSc7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5yZXBsYWNlKC9ebm90IC8sICcnKTtcbiAgfSBlbHNlIHtcbiAgICBkZXRlcm1pbmVyID0gJ211c3QgYmUnO1xuICB9XG5cbiAgdmFyIG1zZztcblxuICBpZiAoZW5kc1dpdGgobmFtZSwgJyBhcmd1bWVudCcpKSB7XG4gICAgLy8gRm9yIGNhc2VzIGxpa2UgJ2ZpcnN0IGFyZ3VtZW50J1xuICAgIG1zZyA9IFwiVGhlIFwiLmNvbmNhdChuYW1lLCBcIiBcIikuY29uY2F0KGRldGVybWluZXIsIFwiIFwiKS5jb25jYXQob25lT2YoZXhwZWN0ZWQsICd0eXBlJykpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0eXBlID0gaW5jbHVkZXMobmFtZSwgJy4nKSA/ICdwcm9wZXJ0eScgOiAnYXJndW1lbnQnO1xuICAgIG1zZyA9IFwiVGhlIFxcXCJcIi5jb25jYXQobmFtZSwgXCJcXFwiIFwiKS5jb25jYXQodHlwZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfSAvLyBUT0RPKEJyaWRnZUFSKTogSW1wcm92ZSB0aGUgb3V0cHV0IGJ5IHNob3dpbmcgYG51bGxgIGFuZCBzaW1pbGFyLlxuXG5cbiAgbXNnICs9IFwiLiBSZWNlaXZlZCB0eXBlIFwiLmNvbmNhdChfdHlwZW9mKGFjdHVhbCkpO1xuICByZXR1cm4gbXNnO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfQVJHX1ZBTFVFJywgZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIHZhciByZWFzb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICdpcyBpbnZhbGlkJztcbiAgaWYgKHV0aWwgPT09IHVuZGVmaW5lZCkgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMzMzNSk7XG4gIHZhciBpbnNwZWN0ZWQgPSB1dGlsLmluc3BlY3QodmFsdWUpO1xuXG4gIGlmIChpbnNwZWN0ZWQubGVuZ3RoID4gMTI4KSB7XG4gICAgaW5zcGVjdGVkID0gXCJcIi5jb25jYXQoaW5zcGVjdGVkLnNsaWNlKDAsIDEyOCksIFwiLi4uXCIpO1xuICB9XG5cbiAgcmV0dXJuIFwiVGhlIGFyZ3VtZW50ICdcIi5jb25jYXQobmFtZSwgXCInIFwiKS5jb25jYXQocmVhc29uLCBcIi4gUmVjZWl2ZWQgXCIpLmNvbmNhdChpbnNwZWN0ZWQpO1xufSwgVHlwZUVycm9yLCBSYW5nZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFJywgZnVuY3Rpb24gKGlucHV0LCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgdHlwZTtcblxuICBpZiAodmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgIHR5cGUgPSBcImluc3RhbmNlIG9mIFwiLmNvbmNhdCh2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgfSBlbHNlIHtcbiAgICB0eXBlID0gXCJ0eXBlIFwiLmNvbmNhdChfdHlwZW9mKHZhbHVlKSk7XG4gIH1cblxuICByZXR1cm4gXCJFeHBlY3RlZCBcIi5jb25jYXQoaW5wdXQsIFwiIHRvIGJlIHJldHVybmVkIGZyb20gdGhlIFxcXCJcIikuY29uY2F0KG5hbWUsIFwiXFxcIlwiKSArIFwiIGZ1bmN0aW9uIGJ1dCBnb3QgXCIuY29uY2F0KHR5cGUsIFwiLlwiKTtcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9NSVNTSU5HX0FSR1MnLCBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAoYXNzZXJ0ID09PSB1bmRlZmluZWQpIGFzc2VydCA9IF9fd2VicGFja19yZXF1aXJlX18oMTY5Nik7XG4gIGFzc2VydChhcmdzLmxlbmd0aCA+IDAsICdBdCBsZWFzdCBvbmUgYXJnIG5lZWRzIHRvIGJlIHNwZWNpZmllZCcpO1xuICB2YXIgbXNnID0gJ1RoZSAnO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIGFyZ3MgPSBhcmdzLm1hcChmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBcIlxcXCJcIi5jb25jYXQoYSwgXCJcXFwiXCIpO1xuICB9KTtcblxuICBzd2l0Y2ggKGxlbikge1xuICAgIGNhc2UgMTpcbiAgICAgIG1zZyArPSBcIlwiLmNvbmNhdChhcmdzWzBdLCBcIiBhcmd1bWVudFwiKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAyOlxuICAgICAgbXNnICs9IFwiXCIuY29uY2F0KGFyZ3NbMF0sIFwiIGFuZCBcIikuY29uY2F0KGFyZ3NbMV0sIFwiIGFyZ3VtZW50c1wiKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIG1zZyArPSBhcmdzLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oJywgJyk7XG4gICAgICBtc2cgKz0gXCIsIGFuZCBcIi5jb25jYXQoYXJnc1tsZW4gLSAxXSwgXCIgYXJndW1lbnRzXCIpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gXCJcIi5jb25jYXQobXNnLCBcIiBtdXN0IGJlIHNwZWNpZmllZFwiKTtcbn0sIFR5cGVFcnJvcik7XG5tb2R1bGUuZXhwb3J0cy5jb2RlcyA9IGNvZGVzO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNjc5Njpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL3V0aWwvY29tcGFyaXNvbnMuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMTEyY2M3YzI3NTUxMjU0YWEyYjE3MDk4ZmI3NzQ4NjdmMDVlZDBkOVxuXG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG52YXIgcmVnZXhGbGFnc1N1cHBvcnRlZCA9IC9hL2cuZmxhZ3MgIT09IHVuZGVmaW5lZDtcblxudmFyIGFycmF5RnJvbVNldCA9IGZ1bmN0aW9uIGFycmF5RnJvbVNldChzZXQpIHtcbiAgdmFyIGFycmF5ID0gW107XG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBhcnJheS5wdXNoKHZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiBhcnJheTtcbn07XG5cbnZhciBhcnJheUZyb21NYXAgPSBmdW5jdGlvbiBhcnJheUZyb21NYXAobWFwKSB7XG4gIHZhciBhcnJheSA9IFtdO1xuICBtYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIHJldHVybiBhcnJheS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0pO1xuICByZXR1cm4gYXJyYXk7XG59O1xuXG52YXIgb2JqZWN0SXMgPSBPYmplY3QuaXMgPyBPYmplY3QuaXMgOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2NzkpO1xudmFyIG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gW107XG59O1xudmFyIG51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOID8gTnVtYmVyLmlzTmFOIDogX193ZWJwYWNrX3JlcXVpcmVfXyg0NzgyKTtcblxuZnVuY3Rpb24gdW5jdXJyeVRoaXMoZikge1xuICByZXR1cm4gZi5jYWxsLmJpbmQoZik7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSk7XG52YXIgb2JqZWN0VG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcblxudmFyIF9yZXF1aXJlJHR5cGVzID0gKF9fd2VicGFja19yZXF1aXJlX18oMzMzNSkudHlwZXMpLFxuICAgIGlzQW55QXJyYXlCdWZmZXIgPSBfcmVxdWlyZSR0eXBlcy5pc0FueUFycmF5QnVmZmVyLFxuICAgIGlzQXJyYXlCdWZmZXJWaWV3ID0gX3JlcXVpcmUkdHlwZXMuaXNBcnJheUJ1ZmZlclZpZXcsXG4gICAgaXNEYXRlID0gX3JlcXVpcmUkdHlwZXMuaXNEYXRlLFxuICAgIGlzTWFwID0gX3JlcXVpcmUkdHlwZXMuaXNNYXAsXG4gICAgaXNSZWdFeHAgPSBfcmVxdWlyZSR0eXBlcy5pc1JlZ0V4cCxcbiAgICBpc1NldCA9IF9yZXF1aXJlJHR5cGVzLmlzU2V0LFxuICAgIGlzTmF0aXZlRXJyb3IgPSBfcmVxdWlyZSR0eXBlcy5pc05hdGl2ZUVycm9yLFxuICAgIGlzQm94ZWRQcmltaXRpdmUgPSBfcmVxdWlyZSR0eXBlcy5pc0JveGVkUHJpbWl0aXZlLFxuICAgIGlzTnVtYmVyT2JqZWN0ID0gX3JlcXVpcmUkdHlwZXMuaXNOdW1iZXJPYmplY3QsXG4gICAgaXNTdHJpbmdPYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc1N0cmluZ09iamVjdCxcbiAgICBpc0Jvb2xlYW5PYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc0Jvb2xlYW5PYmplY3QsXG4gICAgaXNCaWdJbnRPYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc0JpZ0ludE9iamVjdCxcbiAgICBpc1N5bWJvbE9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzU3ltYm9sT2JqZWN0LFxuICAgIGlzRmxvYXQzMkFycmF5ID0gX3JlcXVpcmUkdHlwZXMuaXNGbG9hdDMyQXJyYXksXG4gICAgaXNGbG9hdDY0QXJyYXkgPSBfcmVxdWlyZSR0eXBlcy5pc0Zsb2F0NjRBcnJheTtcblxuZnVuY3Rpb24gaXNOb25JbmRleChrZXkpIHtcbiAgaWYgKGtleS5sZW5ndGggPT09IDAgfHwga2V5Lmxlbmd0aCA+IDEwKSByZXR1cm4gdHJ1ZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb2RlID0ga2V5LmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gNTcpIHJldHVybiB0cnVlO1xuICB9IC8vIFRoZSBtYXhpbXVtIHNpemUgZm9yIGFuIGFycmF5IGlzIDIgKiogMzIgLTEuXG5cblxuICByZXR1cm4ga2V5Lmxlbmd0aCA9PT0gMTAgJiYga2V5ID49IE1hdGgucG93KDIsIDMyKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkuZmlsdGVyKGlzTm9uSW5kZXgpLmNvbmNhdChvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpLmZpbHRlcihPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmJpbmQodmFsdWUpKSk7XG59IC8vIFRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi82ODBlOWU1ZTQ4OGYyMmFhYzI3NTk5YTU3ZGM4NDRhNjMxNTkyOGRkL2luZGV4LmpzXG4vLyBvcmlnaW5hbCBub3RpY2U6XG5cbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciB4ID0gYS5sZW5ndGg7XG4gIHZhciB5ID0gYi5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV07XG4gICAgICB5ID0gYltpXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGlmICh5IDwgeCkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbnZhciBPTkxZX0VOVU1FUkFCTEUgPSB1bmRlZmluZWQ7XG52YXIga1N0cmljdCA9IHRydWU7XG52YXIga0xvb3NlID0gZmFsc2U7XG52YXIga05vSXRlcmF0b3IgPSAwO1xudmFyIGtJc0FycmF5ID0gMTtcbnZhciBrSXNTZXQgPSAyO1xudmFyIGtJc01hcCA9IDM7IC8vIENoZWNrIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSBzb3VyY2UgYW5kIGZsYWdzXG5cbmZ1bmN0aW9uIGFyZVNpbWlsYXJSZWdFeHBzKGEsIGIpIHtcbiAgcmV0dXJuIHJlZ2V4RmxhZ3NTdXBwb3J0ZWQgPyBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncyA6IFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKSA9PT0gUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGIpO1xufVxuXG5mdW5jdGlvbiBhcmVTaW1pbGFyRmxvYXRBcnJheXMoYSwgYikge1xuICBpZiAoYS5ieXRlTGVuZ3RoICE9PSBiLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBhLmJ5dGVMZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgaWYgKGFbb2Zmc2V0XSAhPT0gYltvZmZzZXRdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGFyZVNpbWlsYXJUeXBlZEFycmF5cyhhLCBiKSB7XG4gIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBjb21wYXJlKG5ldyBVaW50OEFycmF5KGEuYnVmZmVyLCBhLmJ5dGVPZmZzZXQsIGEuYnl0ZUxlbmd0aCksIG5ldyBVaW50OEFycmF5KGIuYnVmZmVyLCBiLmJ5dGVPZmZzZXQsIGIuYnl0ZUxlbmd0aCkpID09PSAwO1xufVxuXG5mdW5jdGlvbiBhcmVFcXVhbEFycmF5QnVmZmVycyhidWYxLCBidWYyKSB7XG4gIHJldHVybiBidWYxLmJ5dGVMZW5ndGggPT09IGJ1ZjIuYnl0ZUxlbmd0aCAmJiBjb21wYXJlKG5ldyBVaW50OEFycmF5KGJ1ZjEpLCBuZXcgVWludDhBcnJheShidWYyKSkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGlzRXF1YWxCb3hlZFByaW1pdGl2ZSh2YWwxLCB2YWwyKSB7XG4gIGlmIChpc051bWJlck9iamVjdCh2YWwxKSkge1xuICAgIHJldHVybiBpc051bWJlck9iamVjdCh2YWwyKSAmJiBvYmplY3RJcyhOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSwgTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMikpO1xuICB9XG5cbiAgaWYgKGlzU3RyaW5nT2JqZWN0KHZhbDEpKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nT2JqZWN0KHZhbDIpICYmIFN0cmluZy5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKTtcbiAgfVxuXG4gIGlmIChpc0Jvb2xlYW5PYmplY3QodmFsMSkpIHtcbiAgICByZXR1cm4gaXNCb29sZWFuT2JqZWN0KHZhbDIpICYmIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSA9PT0gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpO1xuICB9XG5cbiAgaWYgKGlzQmlnSW50T2JqZWN0KHZhbDEpKSB7XG4gICAgcmV0dXJuIGlzQmlnSW50T2JqZWN0KHZhbDIpICYmIEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKTtcbiAgfVxuXG4gIHJldHVybiBpc1N5bWJvbE9iamVjdCh2YWwyKSAmJiBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSA9PT0gU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMik7XG59IC8vIE5vdGVzOiBUeXBlIHRhZ3MgYXJlIGhpc3RvcmljYWwgW1tDbGFzc11dIHByb3BlcnRpZXMgdGhhdCBjYW4gYmUgc2V0IGJ5XG4vLyBGdW5jdGlvblRlbXBsYXRlOjpTZXRDbGFzc05hbWUoKSBpbiBDKysgb3IgU3ltYm9sLnRvU3RyaW5nVGFnIGluIEpTXG4vLyBhbmQgcmV0cmlldmVkIHVzaW5nIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopIGluIEpTXG4vLyBTZWUgaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xuLy8gZm9yIGEgbGlzdCBvZiB0YWdzIHByZS1kZWZpbmVkIGluIHRoZSBzcGVjLlxuLy8gVGhlcmUgYXJlIHNvbWUgdW5zcGVjaWZpZWQgdGFncyBpbiB0aGUgd2lsZCB0b28gKGUuZy4gdHlwZWQgYXJyYXkgdGFncykuXG4vLyBTaW5jZSB0YWdzIGNhbiBiZSBhbHRlcmVkLCB0aGV5IG9ubHkgc2VydmUgZmFzdCBmYWlsdXJlc1xuLy9cbi8vIFR5cGVkIGFycmF5cyBhbmQgYnVmZmVycyBhcmUgY2hlY2tlZCBieSBjb21wYXJpbmcgdGhlIGNvbnRlbnQgaW4gdGhlaXJcbi8vIHVuZGVybHlpbmcgQXJyYXlCdWZmZXIuIFRoaXMgb3B0aW1pemF0aW9uIHJlcXVpcmVzIHRoYXQgaXQnc1xuLy8gcmVhc29uYWJsZSB0byBpbnRlcnByZXQgdGhlaXIgdW5kZXJseWluZyBtZW1vcnkgaW4gdGhlIHNhbWUgd2F5LFxuLy8gd2hpY2ggaXMgY2hlY2tlZCBieSBjb21wYXJpbmcgdGhlaXIgdHlwZSB0YWdzLlxuLy8gKGUuZy4gYSBVaW50OEFycmF5IGFuZCBhIFVpbnQxNkFycmF5IHdpdGggdGhlIHNhbWUgbWVtb3J5IGNvbnRlbnRcbi8vIGNvdWxkIHN0aWxsIGJlIGRpZmZlcmVudCBiZWNhdXNlIHRoZXkgd2lsbCBiZSBpbnRlcnByZXRlZCBkaWZmZXJlbnRseSkuXG4vL1xuLy8gRm9yIHN0cmljdCBjb21wYXJpc29uLCBvYmplY3RzIHNob3VsZCBoYXZlXG4vLyBhKSBUaGUgc2FtZSBidWlsdC1pbiB0eXBlIHRhZ3Ncbi8vIGIpIFRoZSBzYW1lIHByb3RvdHlwZXMuXG5cblxuZnVuY3Rpb24gaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcykge1xuICAvLyBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmICh2YWwxID09PSB2YWwyKSB7XG4gICAgaWYgKHZhbDEgIT09IDApIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBzdHJpY3QgPyBvYmplY3RJcyh2YWwxLCB2YWwyKSA6IHRydWU7XG4gIH0gLy8gQ2hlY2sgbW9yZSBjbG9zZWx5IGlmIHZhbDEgYW5kIHZhbDIgYXJlIGVxdWFsLlxuXG5cbiAgaWYgKHN0cmljdCkge1xuICAgIGlmIChfdHlwZW9mKHZhbDEpICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWwxID09PSAnbnVtYmVyJyAmJiBudW1iZXJJc05hTih2YWwxKSAmJiBudW1iZXJJc05hTih2YWwyKTtcbiAgICB9XG5cbiAgICBpZiAoX3R5cGVvZih2YWwyKSAhPT0gJ29iamVjdCcgfHwgdmFsMSA9PT0gbnVsbCB8fCB2YWwyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWwxKSAhPT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2YWwxID09PSBudWxsIHx8IF90eXBlb2YodmFsMSkgIT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAodmFsMiA9PT0gbnVsbCB8fCBfdHlwZW9mKHZhbDIpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gICAgICAgIHJldHVybiB2YWwxID09IHZhbDI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodmFsMiA9PT0gbnVsbCB8fCBfdHlwZW9mKHZhbDIpICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHZhciB2YWwxVGFnID0gb2JqZWN0VG9TdHJpbmcodmFsMSk7XG4gIHZhciB2YWwyVGFnID0gb2JqZWN0VG9TdHJpbmcodmFsMik7XG5cbiAgaWYgKHZhbDFUYWcgIT09IHZhbDJUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwxKSkge1xuICAgIC8vIENoZWNrIGZvciBzcGFyc2UgYXJyYXlzIGFuZCBnZW5lcmFsIGZhc3QgcGF0aFxuICAgIGlmICh2YWwxLmxlbmd0aCAhPT0gdmFsMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIga2V5czEgPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsMSwgT05MWV9FTlVNRVJBQkxFKTtcbiAgICB2YXIga2V5czIgPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsMiwgT05MWV9FTlVNRVJBQkxFKTtcblxuICAgIGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrSXNBcnJheSwga2V5czEpO1xuICB9IC8vIFticm93c2VyaWZ5XSBUaGlzIHRyaWdnZXJzIG9uIGNlcnRhaW4gdHlwZXMgaW4gSUUgKE1hcC9TZXQpIHNvIHdlIGRvbid0XG4gIC8vIHdhbid0IHRvIGVhcmx5IHJldHVybiBvdXQgb2YgdGhlIHJlc3Qgb2YgdGhlIGNoZWNrcy4gSG93ZXZlciB3ZSBjYW4gY2hlY2tcbiAgLy8gaWYgdGhlIHNlY29uZCB2YWx1ZSBpcyBvbmUgb2YgdGhlc2UgdmFsdWVzIGFuZCB0aGUgZmlyc3QgaXNuJ3QuXG5cblxuICBpZiAodmFsMVRhZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAvLyByZXR1cm4ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywga05vSXRlcmF0b3IpO1xuICAgIGlmICghaXNNYXAodmFsMSkgJiYgaXNNYXAodmFsMikgfHwgIWlzU2V0KHZhbDEpICYmIGlzU2V0KHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzRGF0ZSh2YWwxKSkge1xuICAgIGlmICghaXNEYXRlKHZhbDIpIHx8IERhdGUucHJvdG90eXBlLmdldFRpbWUuY2FsbCh2YWwxKSAhPT0gRGF0ZS5wcm90b3R5cGUuZ2V0VGltZS5jYWxsKHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHZhbDEpKSB7XG4gICAgaWYgKCFpc1JlZ0V4cCh2YWwyKSB8fCAhYXJlU2ltaWxhclJlZ0V4cHModmFsMSwgdmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNOYXRpdmVFcnJvcih2YWwxKSB8fCB2YWwxIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAvLyBEbyBub3QgY29tcGFyZSB0aGUgc3RhY2sgYXMgaXQgbWlnaHQgZGlmZmVyIGV2ZW4gdGhvdWdoIHRoZSBlcnJvciBpdHNlbGZcbiAgICAvLyBpcyBvdGhlcndpc2UgaWRlbnRpY2FsLlxuICAgIGlmICh2YWwxLm1lc3NhZ2UgIT09IHZhbDIubWVzc2FnZSB8fCB2YWwxLm5hbWUgIT09IHZhbDIubmFtZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0FycmF5QnVmZmVyVmlldyh2YWwxKSkge1xuICAgIGlmICghc3RyaWN0ICYmIChpc0Zsb2F0MzJBcnJheSh2YWwxKSB8fCBpc0Zsb2F0NjRBcnJheSh2YWwxKSkpIHtcbiAgICAgIGlmICghYXJlU2ltaWxhckZsb2F0QXJyYXlzKHZhbDEsIHZhbDIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhcmVTaW1pbGFyVHlwZWRBcnJheXModmFsMSwgdmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIEJ1ZmZlci5jb21wYXJlIHJldHVybnMgdHJ1ZSwgc28gdmFsMS5sZW5ndGggPT09IHZhbDIubGVuZ3RoLiBJZiB0aGV5IGJvdGhcbiAgICAvLyBvbmx5IGNvbnRhaW4gbnVtZXJpYyBrZXlzLCB3ZSBkb24ndCBuZWVkIHRvIGV4YW0gZnVydGhlciB0aGFuIGNoZWNraW5nXG4gICAgLy8gdGhlIHN5bWJvbHMuXG5cblxuICAgIHZhciBfa2V5cyA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwxLCBPTkxZX0VOVU1FUkFCTEUpO1xuXG4gICAgdmFyIF9rZXlzMiA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwyLCBPTkxZX0VOVU1FUkFCTEUpO1xuXG4gICAgaWYgKF9rZXlzLmxlbmd0aCAhPT0gX2tleXMyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrTm9JdGVyYXRvciwgX2tleXMpO1xuICB9IGVsc2UgaWYgKGlzU2V0KHZhbDEpKSB7XG4gICAgaWYgKCFpc1NldCh2YWwyKSB8fCB2YWwxLnNpemUgIT09IHZhbDIuc2l6ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrSXNTZXQpO1xuICB9IGVsc2UgaWYgKGlzTWFwKHZhbDEpKSB7XG4gICAgaWYgKCFpc01hcCh2YWwyKSB8fCB2YWwxLnNpemUgIT09IHZhbDIuc2l6ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrSXNNYXApO1xuICB9IGVsc2UgaWYgKGlzQW55QXJyYXlCdWZmZXIodmFsMSkpIHtcbiAgICBpZiAoIWFyZUVxdWFsQXJyYXlCdWZmZXJzKHZhbDEsIHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQm94ZWRQcmltaXRpdmUodmFsMSkgJiYgIWlzRXF1YWxCb3hlZFByaW1pdGl2ZSh2YWwxLCB2YWwyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrTm9JdGVyYXRvcik7XG59XG5cbmZ1bmN0aW9uIGdldEVudW1lcmFibGVzKHZhbCwga2V5cykge1xuICByZXR1cm4ga2V5cy5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUodmFsLCBrKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGl0ZXJhdGlvblR5cGUsIGFLZXlzKSB7XG4gIC8vIEZvciBhbGwgcmVtYWluaW5nIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5LCBvYmplY3RzIGFuZCBNYXBzLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5IGhhdmluZzpcbiAgLy8gYSkgVGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIGVudW1lcmFibGUgcHJvcGVydGllc1xuICAvLyBiKSBUaGUgc2FtZSBzZXQgb2Yga2V5cy9pbmRleGVzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpXG4gIC8vIGMpIEVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleS9pbmRleFxuICAvLyBkKSBGb3IgU2V0cyBhbmQgTWFwcywgZXF1YWwgY29udGVudHNcbiAgLy8gTm90ZTogdGhpcyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDUpIHtcbiAgICBhS2V5cyA9IE9iamVjdC5rZXlzKHZhbDEpO1xuICAgIHZhciBiS2V5cyA9IE9iamVjdC5rZXlzKHZhbDIpOyAvLyBUaGUgcGFpciBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMuXG5cbiAgICBpZiAoYUtleXMubGVuZ3RoICE9PSBiS2V5cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gLy8gQ2hlYXAga2V5IHRlc3RcblxuXG4gIHZhciBpID0gMDtcblxuICBmb3IgKDsgaSA8IGFLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2YWwyLCBhS2V5c1tpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RyaWN0ICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDUpIHtcbiAgICB2YXIgc3ltYm9sS2V5c0EgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsMSk7XG5cbiAgICBpZiAoc3ltYm9sS2V5c0EubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgY291bnQgPSAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc3ltYm9sS2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHN5bWJvbEtleXNBW2ldO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwxLCBrZXkpKSB7XG4gICAgICAgICAgaWYgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwyLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYUtleXMucHVzaChrZXkpO1xuICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJc0VudW1lcmFibGUodmFsMiwga2V5KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc3ltYm9sS2V5c0IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsMik7XG5cbiAgICAgIGlmIChzeW1ib2xLZXlzQS5sZW5ndGggIT09IHN5bWJvbEtleXNCLmxlbmd0aCAmJiBnZXRFbnVtZXJhYmxlcyh2YWwyLCBzeW1ib2xLZXlzQikubGVuZ3RoICE9PSBjb3VudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfc3ltYm9sS2V5c0IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsMik7XG5cbiAgICAgIGlmIChfc3ltYm9sS2V5c0IubGVuZ3RoICE9PSAwICYmIGdldEVudW1lcmFibGVzKHZhbDIsIF9zeW1ib2xLZXlzQikubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYUtleXMubGVuZ3RoID09PSAwICYmIChpdGVyYXRpb25UeXBlID09PSBrTm9JdGVyYXRvciB8fCBpdGVyYXRpb25UeXBlID09PSBrSXNBcnJheSAmJiB2YWwxLmxlbmd0aCA9PT0gMCB8fCB2YWwxLnNpemUgPT09IDApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gVXNlIG1lbW9zIHRvIGhhbmRsZSBjeWNsZXMuXG5cblxuICBpZiAobWVtb3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG1lbW9zID0ge1xuICAgICAgdmFsMTogbmV3IE1hcCgpLFxuICAgICAgdmFsMjogbmV3IE1hcCgpLFxuICAgICAgcG9zaXRpb246IDBcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIHByZXZlbnQgdXAgdG8gdHdvIG1hcC5oYXMoeCkgY2FsbHMgYnkgZGlyZWN0bHkgcmV0cmlldmluZyB0aGUgdmFsdWVcbiAgICAvLyBhbmQgY2hlY2tpbmcgZm9yIHVuZGVmaW5lZC4gVGhlIG1hcCBjYW4gb25seSBjb250YWluIG51bWJlcnMsIHNvIGl0IGlzXG4gICAgLy8gc2FmZSB0byBjaGVjayBmb3IgdW5kZWZpbmVkIG9ubHkuXG4gICAgdmFyIHZhbDJNZW1vQSA9IG1lbW9zLnZhbDEuZ2V0KHZhbDEpO1xuXG4gICAgaWYgKHZhbDJNZW1vQSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgdmFsMk1lbW9CID0gbWVtb3MudmFsMi5nZXQodmFsMik7XG5cbiAgICAgIGlmICh2YWwyTWVtb0IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsMk1lbW9BID09PSB2YWwyTWVtb0I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWVtb3MucG9zaXRpb24rKztcbiAgfVxuXG4gIG1lbW9zLnZhbDEuc2V0KHZhbDEsIG1lbW9zLnBvc2l0aW9uKTtcbiAgbWVtb3MudmFsMi5zZXQodmFsMiwgbWVtb3MucG9zaXRpb24pO1xuICB2YXIgYXJlRXEgPSBvYmpFcXVpdih2YWwxLCB2YWwyLCBzdHJpY3QsIGFLZXlzLCBtZW1vcywgaXRlcmF0aW9uVHlwZSk7XG4gIG1lbW9zLnZhbDEuZGVsZXRlKHZhbDEpO1xuICBtZW1vcy52YWwyLmRlbGV0ZSh2YWwyKTtcbiAgcmV0dXJuIGFyZUVxO1xufVxuXG5mdW5jdGlvbiBzZXRIYXNFcXVhbEVsZW1lbnQoc2V0LCB2YWwxLCBzdHJpY3QsIG1lbW8pIHtcbiAgLy8gR28gbG9va2luZy5cbiAgdmFyIHNldFZhbHVlcyA9IGFycmF5RnJvbVNldChzZXQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHZhbDIgPSBzZXRWYWx1ZXNbaV07XG5cbiAgICBpZiAoaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vKSkge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBtYXRjaGluZyBlbGVtZW50IHRvIG1ha2Ugc3VyZSB3ZSBkbyBub3QgY2hlY2sgdGhhdCBhZ2Fpbi5cbiAgICAgIHNldC5kZWxldGUodmFsMik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59IC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L0VxdWFsaXR5X2NvbXBhcmlzb25zX2FuZF9zYW1lbmVzcyNMb29zZV9lcXVhbGl0eV91c2luZ1xuLy8gU2FkbHkgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGRldGVjdCBjb3JyZXNwb25kaW5nIHZhbHVlcyBwcm9wZXJseSBpbiBjYXNlIHRoZVxuLy8gdHlwZSBpcyBhIHN0cmluZywgbnVtYmVyLCBiaWdpbnQgb3IgYm9vbGVhbi4gVGhlIHJlYXNvbiBpcyB0aGF0IHRob3NlIHZhbHVlc1xuLy8gY2FuIG1hdGNoIGxvdHMgb2YgZGlmZmVyZW50IHN0cmluZyB2YWx1ZXMgKGUuZy4sIDFuID09ICcrMDAwMDEnKS5cblxuXG5mdW5jdGlvbiBmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMocHJpbSkge1xuICBzd2l0Y2ggKF90eXBlb2YocHJpbSkpIHtcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgLy8gT25seSBwYXNzIGluIG51bGwgYXMgb2JqZWN0IVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcHJpbSA9ICtwcmltO1xuICAgIC8vIExvb3NlIGVxdWFsIGVudHJpZXMgZXhpc3Qgb25seSBpZiB0aGUgc3RyaW5nIGlzIHBvc3NpYmxlIHRvIGNvbnZlcnQgdG9cbiAgICAvLyBhIHJlZ3VsYXIgbnVtYmVyIGFuZCBub3QgTmFOLlxuICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGlmIChudW1iZXJJc05hTihwcmltKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBzZXRNaWdodEhhdmVMb29zZVByaW0oYSwgYiwgcHJpbSkge1xuICB2YXIgYWx0VmFsdWUgPSBmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMocHJpbSk7XG4gIGlmIChhbHRWYWx1ZSAhPSBudWxsKSByZXR1cm4gYWx0VmFsdWU7XG4gIHJldHVybiBiLmhhcyhhbHRWYWx1ZSkgJiYgIWEuaGFzKGFsdFZhbHVlKTtcbn1cblxuZnVuY3Rpb24gbWFwTWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIHByaW0sIGl0ZW0sIG1lbW8pIHtcbiAgdmFyIGFsdFZhbHVlID0gZmluZExvb3NlTWF0Y2hpbmdQcmltaXRpdmVzKHByaW0pO1xuXG4gIGlmIChhbHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGFsdFZhbHVlO1xuICB9XG5cbiAgdmFyIGN1ckIgPSBiLmdldChhbHRWYWx1ZSk7XG5cbiAgaWYgKGN1ckIgPT09IHVuZGVmaW5lZCAmJiAhYi5oYXMoYWx0VmFsdWUpIHx8ICFpbm5lckRlZXBFcXVhbChpdGVtLCBjdXJCLCBmYWxzZSwgbWVtbykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gIWEuaGFzKGFsdFZhbHVlKSAmJiBpbm5lckRlZXBFcXVhbChpdGVtLCBjdXJCLCBmYWxzZSwgbWVtbyk7XG59XG5cbmZ1bmN0aW9uIHNldEVxdWl2KGEsIGIsIHN0cmljdCwgbWVtbykge1xuICAvLyBUaGlzIGlzIGEgbGF6aWx5IGluaXRpYXRlZCBTZXQgb2YgZW50cmllcyB3aGljaCBoYXZlIHRvIGJlIGNvbXBhcmVkXG4gIC8vIHBhaXJ3aXNlLlxuICB2YXIgc2V0ID0gbnVsbDtcbiAgdmFyIGFWYWx1ZXMgPSBhcnJheUZyb21TZXQoYSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHZhbCA9IGFWYWx1ZXNbaV07IC8vIE5vdGU6IENoZWNraW5nIGZvciB0aGUgb2JqZWN0cyBmaXJzdCBpbXByb3ZlcyB0aGUgcGVyZm9ybWFuY2UgZm9yIG9iamVjdFxuICAgIC8vIGhlYXZ5IHNldHMgYnV0IGl0IGlzIGEgbWlub3Igc2xvdyBkb3duIGZvciBwcmltaXRpdmVzLiBBcyB0aGV5IGFyZSBmYXN0XG4gICAgLy8gdG8gY2hlY2sgdGhpcyBpbXByb3ZlcyB0aGUgd29yc3QgY2FzZSBzY2VuYXJpbyBpbnN0ZWFkLlxuXG4gICAgaWYgKF90eXBlb2YodmFsKSA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICBpZiAoc2V0ID09PSBudWxsKSB7XG4gICAgICAgIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgIH0gLy8gSWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBkb2Vzbid0IGV4aXN0IGluIHRoZSBzZWNvbmQgc2V0IGl0cyBhbiBub3QgbnVsbFxuICAgICAgLy8gb2JqZWN0IChvciBub24gc3RyaWN0IG9ubHk6IGEgbm90IG1hdGNoaW5nIHByaW1pdGl2ZSkgd2UnbGwgbmVlZCB0byBnb1xuICAgICAgLy8gaHVudGluZyBmb3Igc29tZXRoaW5nIHRoYXRzIGRlZXAtKHN0cmljdC0pZXF1YWwgdG8gaXQuIFRvIG1ha2UgdGhpc1xuICAgICAgLy8gTyhuIGxvZyBuKSBjb21wbGV4aXR5IHdlIGhhdmUgdG8gY29weSB0aGVzZSB2YWx1ZXMgaW4gYSBuZXcgc2V0IGZpcnN0LlxuXG5cbiAgICAgIHNldC5hZGQodmFsKTtcbiAgICB9IGVsc2UgaWYgKCFiLmhhcyh2YWwpKSB7XG4gICAgICBpZiAoc3RyaWN0KSByZXR1cm4gZmFsc2U7IC8vIEZhc3QgcGF0aCB0byBkZXRlY3QgbWlzc2luZyBzdHJpbmcsIHN5bWJvbCwgdW5kZWZpbmVkIGFuZCBudWxsIHZhbHVlcy5cblxuICAgICAgaWYgKCFzZXRNaWdodEhhdmVMb29zZVByaW0oYSwgYiwgdmFsKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZXQgPT09IG51bGwpIHtcbiAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgfVxuXG4gICAgICBzZXQuYWRkKHZhbCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNldCAhPT0gbnVsbCkge1xuICAgIHZhciBiVmFsdWVzID0gYXJyYXlGcm9tU2V0KGIpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGJWYWx1ZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX3ZhbCA9IGJWYWx1ZXNbX2ldOyAvLyBXZSBoYXZlIHRvIGNoZWNrIGlmIGEgcHJpbWl0aXZlIHZhbHVlIGlzIGFscmVhZHlcbiAgICAgIC8vIG1hdGNoaW5nIGFuZCBvbmx5IGlmIGl0J3Mgbm90LCBnbyBodW50aW5nIGZvciBpdC5cblxuICAgICAgaWYgKF90eXBlb2YoX3ZhbCkgPT09ICdvYmplY3QnICYmIF92YWwgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCFzZXRIYXNFcXVhbEVsZW1lbnQoc2V0LCBfdmFsLCBzdHJpY3QsIG1lbW8pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgIWEuaGFzKF92YWwpICYmICFzZXRIYXNFcXVhbEVsZW1lbnQoc2V0LCBfdmFsLCBzdHJpY3QsIG1lbW8pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2V0LnNpemUgPT09IDA7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbWFwSGFzRXF1YWxFbnRyeShzZXQsIG1hcCwga2V5MSwgaXRlbTEsIHN0cmljdCwgbWVtbykge1xuICAvLyBUbyBiZSBhYmxlIHRvIGhhbmRsZSBjYXNlcyBsaWtlOlxuICAvLyAgIE1hcChbW3t9LCAnYSddLCBbe30sICdiJ11dKSB2cyBNYXAoW1t7fSwgJ2InXSwgW3t9LCAnYSddXSlcbiAgLy8gLi4uIHdlIG5lZWQgdG8gY29uc2lkZXIgKmFsbCogbWF0Y2hpbmcga2V5cywgbm90IGp1c3QgdGhlIGZpcnN0IHdlIGZpbmQuXG4gIHZhciBzZXRWYWx1ZXMgPSBhcnJheUZyb21TZXQoc2V0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNldFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkyID0gc2V0VmFsdWVzW2ldO1xuXG4gICAgaWYgKGlubmVyRGVlcEVxdWFsKGtleTEsIGtleTIsIHN0cmljdCwgbWVtbykgJiYgaW5uZXJEZWVwRXF1YWwoaXRlbTEsIG1hcC5nZXQoa2V5MiksIHN0cmljdCwgbWVtbykpIHtcbiAgICAgIHNldC5kZWxldGUoa2V5Mik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG1hcEVxdWl2KGEsIGIsIHN0cmljdCwgbWVtbykge1xuICB2YXIgc2V0ID0gbnVsbDtcbiAgdmFyIGFFbnRyaWVzID0gYXJyYXlGcm9tTWFwKGEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYUVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX2FFbnRyaWVzJGkgPSBfc2xpY2VkVG9BcnJheShhRW50cmllc1tpXSwgMiksXG4gICAgICAgIGtleSA9IF9hRW50cmllcyRpWzBdLFxuICAgICAgICBpdGVtMSA9IF9hRW50cmllcyRpWzFdO1xuXG4gICAgaWYgKF90eXBlb2Yoa2V5KSA9PT0gJ29iamVjdCcgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICBpZiAoc2V0ID09PSBudWxsKSB7XG4gICAgICAgIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgIH1cblxuICAgICAgc2V0LmFkZChrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCeSBkaXJlY3RseSByZXRyaWV2aW5nIHRoZSB2YWx1ZSB3ZSBwcmV2ZW50IGFub3RoZXIgYi5oYXMoa2V5KSBjaGVjayBpblxuICAgICAgLy8gYWxtb3N0IGFsbCBwb3NzaWJsZSBjYXNlcy5cbiAgICAgIHZhciBpdGVtMiA9IGIuZ2V0KGtleSk7XG5cbiAgICAgIGlmIChpdGVtMiA9PT0gdW5kZWZpbmVkICYmICFiLmhhcyhrZXkpIHx8ICFpbm5lckRlZXBFcXVhbChpdGVtMSwgaXRlbTIsIHN0cmljdCwgbWVtbykpIHtcbiAgICAgICAgaWYgKHN0cmljdCkgcmV0dXJuIGZhbHNlOyAvLyBGYXN0IHBhdGggdG8gZGV0ZWN0IG1pc3Npbmcgc3RyaW5nLCBzeW1ib2wsIHVuZGVmaW5lZCBhbmQgbnVsbFxuICAgICAgICAvLyBrZXlzLlxuXG4gICAgICAgIGlmICghbWFwTWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIGtleSwgaXRlbTEsIG1lbW8pKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNldCA9PT0gbnVsbCkge1xuICAgICAgICAgIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldC5hZGQoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoc2V0ICE9PSBudWxsKSB7XG4gICAgdmFyIGJFbnRyaWVzID0gYXJyYXlGcm9tTWFwKGIpO1xuXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgYkVudHJpZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgdmFyIF9iRW50cmllcyRfaSA9IF9zbGljZWRUb0FycmF5KGJFbnRyaWVzW19pMl0sIDIpLFxuICAgICAgICAgIGtleSA9IF9iRW50cmllcyRfaVswXSxcbiAgICAgICAgICBpdGVtID0gX2JFbnRyaWVzJF9pWzFdO1xuXG4gICAgICBpZiAoX3R5cGVvZihrZXkpID09PSAnb2JqZWN0JyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCFtYXBIYXNFcXVhbEVudHJ5KHNldCwgYSwga2V5LCBpdGVtLCBzdHJpY3QsIG1lbW8pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgKCFhLmhhcyhrZXkpIHx8ICFpbm5lckRlZXBFcXVhbChhLmdldChrZXkpLCBpdGVtLCBmYWxzZSwgbWVtbykpICYmICFtYXBIYXNFcXVhbEVudHJ5KHNldCwgYSwga2V5LCBpdGVtLCBmYWxzZSwgbWVtbykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZXQuc2l6ZSA9PT0gMDtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBzdHJpY3QsIGtleXMsIG1lbW9zLCBpdGVyYXRpb25UeXBlKSB7XG4gIC8vIFNldHMgYW5kIG1hcHMgZG9uJ3QgaGF2ZSB0aGVpciBlbnRyaWVzIGFjY2Vzc2libGUgdmlhIG5vcm1hbCBvYmplY3RcbiAgLy8gcHJvcGVydGllcy5cbiAgdmFyIGkgPSAwO1xuXG4gIGlmIChpdGVyYXRpb25UeXBlID09PSBrSXNTZXQpIHtcbiAgICBpZiAoIXNldEVxdWl2KGEsIGIsIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGl0ZXJhdGlvblR5cGUgPT09IGtJc01hcCkge1xuICAgIGlmICghbWFwRXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXRlcmF0aW9uVHlwZSA9PT0ga0lzQXJyYXkpIHtcbiAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShhLCBpKSkge1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5KGIsIGkpIHx8ICFpbm5lckRlZXBFcXVhbChhW2ldLCBiW2ldLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChoYXNPd25Qcm9wZXJ0eShiLCBpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBcnJheSBpcyBzcGFyc2UuXG4gICAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xuXG4gICAgICAgIGZvciAoOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIga2V5ID0ga2V5c0FbaV07XG5cbiAgICAgICAgICBpZiAoIWhhc093blByb3BlcnR5KGIsIGtleSkgfHwgIWlubmVyRGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXlzQS5sZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBUaGUgcGFpciBtdXN0IGhhdmUgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LlxuICAvLyBQb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0OlxuXG5cbiAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX2tleSA9IGtleXNbaV07XG5cbiAgICBpZiAoIWlubmVyRGVlcEVxdWFsKGFbX2tleV0sIGJbX2tleV0sIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzRGVlcEVxdWFsKHZhbDEsIHZhbDIpIHtcbiAgcmV0dXJuIGlubmVyRGVlcEVxdWFsKHZhbDEsIHZhbDIsIGtMb29zZSk7XG59XG5cbmZ1bmN0aW9uIGlzRGVlcFN0cmljdEVxdWFsKHZhbDEsIHZhbDIpIHtcbiAgcmV0dXJuIGlubmVyRGVlcEVxdWFsKHZhbDEsIHZhbDIsIGtTdHJpY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNEZWVwRXF1YWw6IGlzRGVlcEVxdWFsLFxuICBpc0RlZXBTdHJpY3RFcXVhbDogaXNEZWVwU3RyaWN0RXF1YWxcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyAyNjgwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgR2V0SW50cmluc2ljID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Mjg2KTtcblxudmFyIGNhbGxCaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NDI5KTtcblxudmFyICRpbmRleE9mID0gY2FsbEJpbmQoR2V0SW50cmluc2ljKCdTdHJpbmcucHJvdG90eXBlLmluZGV4T2YnKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FsbEJvdW5kSW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHR2YXIgaW50cmluc2ljID0gR2V0SW50cmluc2ljKG5hbWUsICEhYWxsb3dNaXNzaW5nKTtcblx0aWYgKHR5cGVvZiBpbnRyaW5zaWMgPT09ICdmdW5jdGlvbicgJiYgJGluZGV4T2YobmFtZSwgJy5wcm90b3R5cGUuJykgPiAtMSkge1xuXHRcdHJldHVybiBjYWxsQmluZChpbnRyaW5zaWMpO1xuXHR9XG5cdHJldHVybiBpbnRyaW5zaWM7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5NDI5OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oNDA5MCk7XG52YXIgR2V0SW50cmluc2ljID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Mjg2KTtcblxudmFyICRhcHBseSA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSUnKTtcbnZhciAkY2FsbCA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsJScpO1xudmFyICRyZWZsZWN0QXBwbHkgPSBHZXRJbnRyaW5zaWMoJyVSZWZsZWN0LmFwcGx5JScsIHRydWUpIHx8IGJpbmQuY2FsbCgkY2FsbCwgJGFwcGx5KTtcblxudmFyICRnT1BEID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciUnLCB0cnVlKTtcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZGVmaW5lUHJvcGVydHklJywgdHJ1ZSk7XG52YXIgJG1heCA9IEdldEludHJpbnNpYygnJU1hdGgubWF4JScpO1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdCRkZWZpbmVQcm9wZXJ0eSA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQmluZChvcmlnaW5hbEZ1bmN0aW9uKSB7XG5cdHZhciBmdW5jID0gJHJlZmxlY3RBcHBseShiaW5kLCAkY2FsbCwgYXJndW1lbnRzKTtcblx0aWYgKCRnT1BEICYmICRkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdHZhciBkZXNjID0gJGdPUEQoZnVuYywgJ2xlbmd0aCcpO1xuXHRcdGlmIChkZXNjLmNvbmZpZ3VyYWJsZSkge1xuXHRcdFx0Ly8gb3JpZ2luYWwgbGVuZ3RoLCBwbHVzIHRoZSByZWNlaXZlciwgbWludXMgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIChhZnRlciB0aGUgcmVjZWl2ZXIpXG5cdFx0XHQkZGVmaW5lUHJvcGVydHkoXG5cdFx0XHRcdGZ1bmMsXG5cdFx0XHRcdCdsZW5ndGgnLFxuXHRcdFx0XHR7IHZhbHVlOiAxICsgJG1heCgwLCBvcmlnaW5hbEZ1bmN0aW9uLmxlbmd0aCAtIChhcmd1bWVudHMubGVuZ3RoIC0gMSkpIH1cblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmdW5jO1xufTtcblxudmFyIGFwcGx5QmluZCA9IGZ1bmN0aW9uIGFwcGx5QmluZCgpIHtcblx0cmV0dXJuICRyZWZsZWN0QXBwbHkoYmluZCwgJGFwcGx5LCBhcmd1bWVudHMpO1xufTtcblxuaWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHQkZGVmaW5lUHJvcGVydHkobW9kdWxlLmV4cG9ydHMsICdhcHBseScsIHsgdmFsdWU6IGFwcGx5QmluZCB9KTtcbn0gZWxzZSB7XG5cdG1vZHVsZS5leHBvcnRzLmFwcGx5ID0gYXBwbHlCaW5kO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNzE2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vKmdsb2JhbCB3aW5kb3csIGdsb2JhbCovXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMzMzNSlcbnZhciBhc3NlcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2OTYpXG5mdW5jdGlvbiBub3coKSB7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKSB9XG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZVxudmFyIGNvbnNvbGVcbnZhciB0aW1lcyA9IHt9XG5cbmlmICh0eXBlb2YgX193ZWJwYWNrX3JlcXVpcmVfXy5nICE9PSBcInVuZGVmaW5lZFwiICYmIF9fd2VicGFja19yZXF1aXJlX18uZy5jb25zb2xlKSB7XG4gICAgY29uc29sZSA9IF9fd2VicGFja19yZXF1aXJlX18uZy5jb25zb2xlXG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmNvbnNvbGUpIHtcbiAgICBjb25zb2xlID0gd2luZG93LmNvbnNvbGVcbn0gZWxzZSB7XG4gICAgY29uc29sZSA9IHt9XG59XG5cbnZhciBmdW5jdGlvbnMgPSBbXG4gICAgW2xvZywgXCJsb2dcIl0sXG4gICAgW2luZm8sIFwiaW5mb1wiXSxcbiAgICBbd2FybiwgXCJ3YXJuXCJdLFxuICAgIFtlcnJvciwgXCJlcnJvclwiXSxcbiAgICBbdGltZSwgXCJ0aW1lXCJdLFxuICAgIFt0aW1lRW5kLCBcInRpbWVFbmRcIl0sXG4gICAgW3RyYWNlLCBcInRyYWNlXCJdLFxuICAgIFtkaXIsIFwiZGlyXCJdLFxuICAgIFtjb25zb2xlQXNzZXJ0LCBcImFzc2VydFwiXVxuXVxuXG5mb3IgKHZhciBpID0gMDsgaSA8IGZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0dXBsZSA9IGZ1bmN0aW9uc1tpXVxuICAgIHZhciBmID0gdHVwbGVbMF1cbiAgICB2YXIgbmFtZSA9IHR1cGxlWzFdXG5cbiAgICBpZiAoIWNvbnNvbGVbbmFtZV0pIHtcbiAgICAgICAgY29uc29sZVtuYW1lXSA9IGZcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29uc29sZVxuXG5mdW5jdGlvbiBsb2coKSB7fVxuXG5mdW5jdGlvbiBpbmZvKCkge1xuICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbn1cblxuZnVuY3Rpb24gd2FybigpIHtcbiAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG59XG5cbmZ1bmN0aW9uIGVycm9yKCkge1xuICAgIGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG59XG5cbmZ1bmN0aW9uIHRpbWUobGFiZWwpIHtcbiAgICB0aW1lc1tsYWJlbF0gPSBub3coKVxufVxuXG5mdW5jdGlvbiB0aW1lRW5kKGxhYmVsKSB7XG4gICAgdmFyIHRpbWUgPSB0aW1lc1tsYWJlbF1cbiAgICBpZiAoIXRpbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3VjaCBsYWJlbDogXCIgKyBsYWJlbClcbiAgICB9XG5cbiAgICBkZWxldGUgdGltZXNbbGFiZWxdXG4gICAgdmFyIGR1cmF0aW9uID0gbm93KCkgLSB0aW1lXG4gICAgY29uc29sZS5sb2cobGFiZWwgKyBcIjogXCIgKyBkdXJhdGlvbiArIFwibXNcIilcbn1cblxuZnVuY3Rpb24gdHJhY2UoKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcigpXG4gICAgZXJyLm5hbWUgPSBcIlRyYWNlXCJcbiAgICBlcnIubWVzc2FnZSA9IHV0aWwuZm9ybWF0LmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICBjb25zb2xlLmVycm9yKGVyci5zdGFjaylcbn1cblxuZnVuY3Rpb24gZGlyKG9iamVjdCkge1xuICAgIGNvbnNvbGUubG9nKHV0aWwuaW5zcGVjdChvYmplY3QpICsgXCJcXG5cIilcbn1cblxuZnVuY3Rpb24gY29uc29sZUFzc2VydChleHByZXNzaW9uKSB7XG4gICAgaWYgKCFleHByZXNzaW9uKSB7XG4gICAgICAgIHZhciBhcnIgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICAgICAgYXNzZXJ0Lm9rKGZhbHNlLCB1dGlsLmZvcm1hdC5hcHBseShudWxsLCBhcnIpKVxuICAgIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDkyNjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0NjQpO1xudmFyIGhhc1N5bWJvbHMgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2woJ2ZvbycpID09PSAnc3ltYm9sJztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBjb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0O1xudmFyIG9yaWdEZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAoZm4pIHtcblx0cmV0dXJuIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyAmJiB0b1N0ci5jYWxsKGZuKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTgxKSgpO1xuXG52YXIgc3VwcG9ydHNEZXNjcmlwdG9ycyA9IG9yaWdEZWZpbmVQcm9wZXJ0eSAmJiBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCB2YWx1ZSwgcHJlZGljYXRlKSB7XG5cdGlmIChuYW1lIGluIG9iamVjdCkge1xuXHRcdGlmIChwcmVkaWNhdGUgPT09IHRydWUpIHtcblx0XHRcdGlmIChvYmplY3RbbmFtZV0gPT09IHZhbHVlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKCFpc0Z1bmN0aW9uKHByZWRpY2F0ZSkgfHwgIXByZWRpY2F0ZSgpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG5cdGlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XG5cdFx0b3JpZ0RlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHR3cml0YWJsZTogdHJ1ZVxuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdG9iamVjdFtuYW1lXSA9IHZhbHVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG5cdH1cbn07XG5cbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iamVjdCwgbWFwKSB7XG5cdHZhciBwcmVkaWNhdGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB7fTtcblx0dmFyIHByb3BzID0ga2V5cyhtYXApO1xuXHRpZiAoaGFzU3ltYm9scykge1xuXHRcdHByb3BzID0gY29uY2F0LmNhbGwocHJvcHMsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobWFwKSk7XG5cdH1cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcHNbaV0sIG1hcFtwcm9wc1tpXV0sIHByZWRpY2F0ZXNbcHJvcHNbaV1dKTtcblx0fVxufTtcblxuZGVmaW5lUHJvcGVydGllcy5zdXBwb3J0c0Rlc2NyaXB0b3JzID0gISFzdXBwb3J0c0Rlc2NyaXB0b3JzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnRpZXM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ5NTY6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29kZSByZWZhY3RvcmVkIGZyb20gTW96aWxsYSBEZXZlbG9wZXIgTmV0d29yazpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ25cbiAqL1xuXG5cblxuZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgZmlyc3RTb3VyY2UpIHtcbiAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGZpcnN0IGFyZ3VtZW50IHRvIG9iamVjdCcpO1xuICB9XG5cbiAgdmFyIHRvID0gT2JqZWN0KHRhcmdldCk7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5leHRTb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgaWYgKG5leHRTb3VyY2UgPT09IHVuZGVmaW5lZCB8fCBuZXh0U291cmNlID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIga2V5c0FycmF5ID0gT2JqZWN0LmtleXMoT2JqZWN0KG5leHRTb3VyY2UpKTtcbiAgICBmb3IgKHZhciBuZXh0SW5kZXggPSAwLCBsZW4gPSBrZXlzQXJyYXkubGVuZ3RoOyBuZXh0SW5kZXggPCBsZW47IG5leHRJbmRleCsrKSB7XG4gICAgICB2YXIgbmV4dEtleSA9IGtleXNBcnJheVtuZXh0SW5kZXhdO1xuICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5leHRTb3VyY2UsIG5leHRLZXkpO1xuICAgICAgaWYgKGRlc2MgIT09IHVuZGVmaW5lZCAmJiBkZXNjLmVudW1lcmFibGUpIHtcbiAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdG87XG59XG5cbmZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuICBpZiAoIU9iamVjdC5hc3NpZ24pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LCAnYXNzaWduJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBhc3NpZ25cbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXNzaWduOiBhc3NpZ24sXG4gIHBvbHlmaWxsOiBwb2x5ZmlsbFxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzI0Mzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk2ODApO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGZvckVhY2hBcnJheSA9IGZ1bmN0aW9uIGZvckVhY2hBcnJheShhcnJheSwgaXRlcmF0b3IsIHJlY2VpdmVyKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCBpKSkge1xuICAgICAgICAgICAgaWYgKHJlY2VpdmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvcihhcnJheVtpXSwgaSwgYXJyYXkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5jYWxsKHJlY2VpdmVyLCBhcnJheVtpXSwgaSwgYXJyYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIGZvckVhY2hTdHJpbmcgPSBmdW5jdGlvbiBmb3JFYWNoU3RyaW5nKHN0cmluZywgaXRlcmF0b3IsIHJlY2VpdmVyKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAvLyBubyBzdWNoIHRoaW5nIGFzIGEgc3BhcnNlIHN0cmluZy5cbiAgICAgICAgaWYgKHJlY2VpdmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHN0cmluZy5jaGFyQXQoaSksIGksIHN0cmluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVyYXRvci5jYWxsKHJlY2VpdmVyLCBzdHJpbmcuY2hhckF0KGkpLCBpLCBzdHJpbmcpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIGZvckVhY2hPYmplY3QgPSBmdW5jdGlvbiBmb3JFYWNoT2JqZWN0KG9iamVjdCwgaXRlcmF0b3IsIHJlY2VpdmVyKSB7XG4gICAgZm9yICh2YXIgayBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrKSkge1xuICAgICAgICAgICAgaWYgKHJlY2VpdmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvcihvYmplY3Rba10sIGssIG9iamVjdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwocmVjZWl2ZXIsIG9iamVjdFtrXSwgaywgb2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChsaXN0LCBpdGVyYXRvciwgdGhpc0FyZykge1xuICAgIGlmICghaXNDYWxsYWJsZShpdGVyYXRvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgdmFyIHJlY2VpdmVyO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIHtcbiAgICAgICAgcmVjZWl2ZXIgPSB0aGlzQXJnO1xuICAgIH1cblxuICAgIGlmICh0b1N0ci5jYWxsKGxpc3QpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgIGZvckVhY2hBcnJheShsaXN0LCBpdGVyYXRvciwgcmVjZWl2ZXIpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZvckVhY2hTdHJpbmcobGlzdCwgaXRlcmF0b3IsIHJlY2VpdmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3JFYWNoT2JqZWN0KGxpc3QsIGl0ZXJhdG9yLCByZWNlaXZlcik7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3Nzk1OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyogZXNsaW50IG5vLWludmFsaWQtdGhpczogMSAqL1xuXG52YXIgRVJST1JfTUVTU0FHRSA9ICdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlICc7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZ1bmNUeXBlID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKHRoYXQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJyB8fCB0b1N0ci5jYWxsKHRhcmdldCkgIT09IGZ1bmNUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJST1JfTUVTU0FHRSArIHRhcmdldCk7XG4gICAgfVxuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgdmFyIGJvdW5kO1xuICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgYm91bmRMZW5ndGggPSBNYXRoLm1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuICAgIHZhciBib3VuZEFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYm91bmRBcmdzLnB1c2goJyQnICsgaSk7XG4gICAgfVxuXG4gICAgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGJvdW5kQXJncy5qb2luKCcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7IH0nKShiaW5kZXIpO1xuXG4gICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgdmFyIEVtcHR5ID0gZnVuY3Rpb24gRW1wdHkoKSB7fTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvdW5kO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDA5MDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGltcGxlbWVudGF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nzk1KTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBpbXBsZW1lbnRhdGlvbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzI4Njpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHVuZGVmaW5lZDtcblxudmFyICRTeW50YXhFcnJvciA9IFN5bnRheEVycm9yO1xudmFyICRGdW5jdGlvbiA9IEZ1bmN0aW9uO1xudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxudmFyIGdldEV2YWxsZWRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChleHByZXNzaW9uU3ludGF4KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuICRGdW5jdGlvbignXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAoJyArIGV4cHJlc3Npb25TeW50YXggKyAnKS5jb25zdHJ1Y3RvcjsnKSgpO1xuXHR9IGNhdGNoIChlKSB7fVxufTtcblxudmFyICRnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbmlmICgkZ09QRCkge1xuXHR0cnkge1xuXHRcdCRnT1BEKHt9LCAnJyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQkZ09QRCA9IG51bGw7IC8vIHRoaXMgaXMgSUUgOCwgd2hpY2ggaGFzIGEgYnJva2VuIGdPUERcblx0fVxufVxuXG52YXIgdGhyb3dUeXBlRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdHRocm93IG5ldyAkVHlwZUVycm9yKCk7XG59O1xudmFyIFRocm93VHlwZUVycm9yID0gJGdPUERcblx0PyAoZnVuY3Rpb24gKCkge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zLCBuby1jYWxsZXIsIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xuXHRcdFx0YXJndW1lbnRzLmNhbGxlZTsgLy8gSUUgOCBkb2VzIG5vdCB0aHJvdyBoZXJlXG5cdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0fSBjYXRjaCAoY2FsbGVlVGhyb3dzKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyBJRSA4IHRocm93cyBvbiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGFyZ3VtZW50cywgJycpXG5cdFx0XHRcdHJldHVybiAkZ09QRChhcmd1bWVudHMsICdjYWxsZWUnKS5nZXQ7XG5cdFx0XHR9IGNhdGNoIChnT1BEdGhyb3dzKSB7XG5cdFx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH0oKSlcblx0OiB0aHJvd1R5cGVFcnJvcjtcblxudmFyIGhhc1N5bWJvbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2MzYpKCk7XG52YXIgaGFzUHJvdG8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0ODYpKCk7XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCAoXG5cdGhhc1Byb3RvXG5cdFx0PyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5fX3Byb3RvX187IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xuXHRcdDogbnVsbFxuKTtcblxudmFyIG5lZWRzRXZhbCA9IHt9O1xuXG52YXIgVHlwZWRBcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyB8fCAhZ2V0UHJvdG8gPyB1bmRlZmluZWQgOiBnZXRQcm90byhVaW50OEFycmF5KTtcblxudmFyIElOVFJJTlNJQ1MgPSB7XG5cdCclQWdncmVnYXRlRXJyb3IlJzogdHlwZW9mIEFnZ3JlZ2F0ZUVycm9yID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFnZ3JlZ2F0ZUVycm9yLFxuXHQnJUFycmF5JSc6IEFycmF5LFxuXHQnJUFycmF5QnVmZmVyJSc6IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBcnJheUJ1ZmZlcixcblx0JyVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgJiYgZ2V0UHJvdG8gPyBnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJUFzeW5jRnJvbVN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3IlJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogbmVlZHNFdmFsLFxuXHQnJUF0b21pY3MlJzogdHlwZW9mIEF0b21pY3MgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXRvbWljcyxcblx0JyVCaWdJbnQlJzogdHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdJbnQsXG5cdCclQmlnSW50NjRBcnJheSUnOiB0eXBlb2YgQmlnSW50NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdJbnQ2NEFycmF5LFxuXHQnJUJpZ1VpbnQ2NEFycmF5JSc6IHR5cGVvZiBCaWdVaW50NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdVaW50NjRBcnJheSxcblx0JyVCb29sZWFuJSc6IEJvb2xlYW4sXG5cdCclRGF0YVZpZXclJzogdHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IERhdGFWaWV3LFxuXHQnJURhdGUlJzogRGF0ZSxcblx0JyVkZWNvZGVVUkklJzogZGVjb2RlVVJJLFxuXHQnJWRlY29kZVVSSUNvbXBvbmVudCUnOiBkZWNvZGVVUklDb21wb25lbnQsXG5cdCclZW5jb2RlVVJJJSc6IGVuY29kZVVSSSxcblx0JyVlbmNvZGVVUklDb21wb25lbnQlJzogZW5jb2RlVVJJQ29tcG9uZW50LFxuXHQnJUVycm9yJSc6IEVycm9yLFxuXHQnJWV2YWwlJzogZXZhbCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXG5cdCclRXZhbEVycm9yJSc6IEV2YWxFcnJvcixcblx0JyVGbG9hdDMyQXJyYXklJzogdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDMyQXJyYXksXG5cdCclRmxvYXQ2NEFycmF5JSc6IHR5cGVvZiBGbG9hdDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQ2NEFycmF5LFxuXHQnJUZpbmFsaXphdGlvblJlZ2lzdHJ5JSc6IHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGaW5hbGl6YXRpb25SZWdpc3RyeSxcblx0JyVGdW5jdGlvbiUnOiAkRnVuY3Rpb24sXG5cdCclR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUludDhBcnJheSUnOiB0eXBlb2YgSW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDhBcnJheSxcblx0JyVJbnQxNkFycmF5JSc6IHR5cGVvZiBJbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDE2QXJyYXksXG5cdCclSW50MzJBcnJheSUnOiB0eXBlb2YgSW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQzMkFycmF5LFxuXHQnJWlzRmluaXRlJSc6IGlzRmluaXRlLFxuXHQnJWlzTmFOJSc6IGlzTmFOLFxuXHQnJUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgJiYgZ2V0UHJvdG8gPyBnZXRQcm90byhnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKSA6IHVuZGVmaW5lZCxcblx0JyVKU09OJSc6IHR5cGVvZiBKU09OID09PSAnb2JqZWN0JyA/IEpTT04gOiB1bmRlZmluZWQsXG5cdCclTWFwJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogTWFwLFxuXHQnJU1hcEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzIHx8ICFnZXRQcm90byA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBNYXAoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJU1hdGglJzogTWF0aCxcblx0JyVOdW1iZXIlJzogTnVtYmVyLFxuXHQnJU9iamVjdCUnOiBPYmplY3QsXG5cdCclcGFyc2VGbG9hdCUnOiBwYXJzZUZsb2F0LFxuXHQnJXBhcnNlSW50JSc6IHBhcnNlSW50LFxuXHQnJVByb21pc2UlJzogdHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJvbWlzZSxcblx0JyVQcm94eSUnOiB0eXBlb2YgUHJveHkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJveHksXG5cdCclUmFuZ2VFcnJvciUnOiBSYW5nZUVycm9yLFxuXHQnJVJlZmVyZW5jZUVycm9yJSc6IFJlZmVyZW5jZUVycm9yLFxuXHQnJVJlZmxlY3QlJzogdHlwZW9mIFJlZmxlY3QgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUmVmbGVjdCxcblx0JyVSZWdFeHAlJzogUmVnRXhwLFxuXHQnJVNldCUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNldCxcblx0JyVTZXRJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyB8fCAhZ2V0UHJvdG8gPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgU2V0KClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlciUnOiB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2hhcmVkQXJyYXlCdWZmZXIsXG5cdCclU3RyaW5nJSc6IFN0cmluZyxcblx0JyVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzICYmIGdldFByb3RvID8gZ2V0UHJvdG8oJydbU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyVTeW1ib2wlJzogaGFzU3ltYm9scyA/IFN5bWJvbCA6IHVuZGVmaW5lZCxcblx0JyVTeW50YXhFcnJvciUnOiAkU3ludGF4RXJyb3IsXG5cdCclVGhyb3dUeXBlRXJyb3IlJzogVGhyb3dUeXBlRXJyb3IsXG5cdCclVHlwZWRBcnJheSUnOiBUeXBlZEFycmF5LFxuXHQnJVR5cGVFcnJvciUnOiAkVHlwZUVycm9yLFxuXHQnJVVpbnQ4QXJyYXklJzogdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhBcnJheSxcblx0JyVVaW50OENsYW1wZWRBcnJheSUnOiB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhDbGFtcGVkQXJyYXksXG5cdCclVWludDE2QXJyYXklJzogdHlwZW9mIFVpbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQxNkFycmF5LFxuXHQnJVVpbnQzMkFycmF5JSc6IHR5cGVvZiBVaW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MzJBcnJheSxcblx0JyVVUklFcnJvciUnOiBVUklFcnJvcixcblx0JyVXZWFrTWFwJSc6IHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtNYXAsXG5cdCclV2Vha1JlZiUnOiB0eXBlb2YgV2Vha1JlZiA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrUmVmLFxuXHQnJVdlYWtTZXQlJzogdHlwZW9mIFdlYWtTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1NldFxufTtcblxuaWYgKGdldFByb3RvKSB7XG5cdHRyeSB7XG5cdFx0bnVsbC5lcnJvcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXNoYWRvd3JlYWxtL3B1bGwvMzg0I2lzc3VlY29tbWVudC0xMzY0MjY0MjI5XG5cdFx0dmFyIGVycm9yUHJvdG8gPSBnZXRQcm90byhnZXRQcm90byhlKSk7XG5cdFx0SU5UUklOU0lDU1snJUVycm9yLnByb3RvdHlwZSUnXSA9IGVycm9yUHJvdG87XG5cdH1cbn1cblxudmFyIGRvRXZhbCA9IGZ1bmN0aW9uIGRvRXZhbChuYW1lKSB7XG5cdHZhciB2YWx1ZTtcblx0aWYgKG5hbWUgPT09ICclQXN5bmNGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2Z1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3IlJykge1xuXHRcdHZhciBmbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJyk7XG5cdFx0aWYgKGZuKSB7XG5cdFx0XHR2YWx1ZSA9IGZuLnByb3RvdHlwZTtcblx0XHR9XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJScpIHtcblx0XHR2YXIgZ2VuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3IlJyk7XG5cdFx0aWYgKGdlbiAmJiBnZXRQcm90bykge1xuXHRcdFx0dmFsdWUgPSBnZXRQcm90byhnZW4ucHJvdG90eXBlKTtcblx0XHR9XG5cdH1cblxuXHRJTlRSSU5TSUNTW25hbWVdID0gdmFsdWU7XG5cblx0cmV0dXJuIHZhbHVlO1xufTtcblxudmFyIExFR0FDWV9BTElBU0VTID0ge1xuXHQnJUFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXG5cdCclQXJyYXlQcm90b3R5cGUlJzogWydBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvX2VudHJpZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZW50cmllcyddLFxuXHQnJUFycmF5UHJvdG9fZm9yRWFjaCUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdmb3JFYWNoJ10sXG5cdCclQXJyYXlQcm90b19rZXlzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2tleXMnXSxcblx0JyVBcnJheVByb3RvX3ZhbHVlcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICd2YWx1ZXMnXSxcblx0JyVBc3luY0Z1bmN0aW9uUHJvdG90eXBlJSc6IFsnQXN5bmNGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclQXN5bmNHZW5lcmF0b3JQcm90b3R5cGUlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVCb29sZWFuUHJvdG90eXBlJSc6IFsnQm9vbGVhbicsICdwcm90b3R5cGUnXSxcblx0JyVEYXRhVmlld1Byb3RvdHlwZSUnOiBbJ0RhdGFWaWV3JywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGVQcm90b3R5cGUlJzogWydEYXRlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUVycm9yUHJvdG90eXBlJSc6IFsnRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRXZhbEVycm9yUHJvdG90eXBlJSc6IFsnRXZhbEVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0MzJBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGbG9hdDY0QXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDY0QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclRnVuY3Rpb25Qcm90b3R5cGUlJzogWydGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3IlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3JQcm90b3R5cGUlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXG5cdCclSW50OEFycmF5UHJvdG90eXBlJSc6IFsnSW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDE2QXJyYXlQcm90b3R5cGUlJzogWydJbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDMyQXJyYXlQcm90b3R5cGUlJzogWydJbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUpTT05QYXJzZSUnOiBbJ0pTT04nLCAncGFyc2UnXSxcblx0JyVKU09OU3RyaW5naWZ5JSc6IFsnSlNPTicsICdzdHJpbmdpZnknXSxcblx0JyVNYXBQcm90b3R5cGUlJzogWydNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclTnVtYmVyUHJvdG90eXBlJSc6IFsnTnVtYmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJU9iamVjdFByb3RvdHlwZSUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnXSxcblx0JyVPYmpQcm90b190b1N0cmluZyUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndG9TdHJpbmcnXSxcblx0JyVPYmpQcm90b192YWx1ZU9mJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd2YWx1ZU9mJ10sXG5cdCclUHJvbWlzZVByb3RvdHlwZSUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJ10sXG5cdCclUHJvbWlzZVByb3RvX3RoZW4lJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZScsICd0aGVuJ10sXG5cdCclUHJvbWlzZV9hbGwlJzogWydQcm9taXNlJywgJ2FsbCddLFxuXHQnJVByb21pc2VfcmVqZWN0JSc6IFsnUHJvbWlzZScsICdyZWplY3QnXSxcblx0JyVQcm9taXNlX3Jlc29sdmUlJzogWydQcm9taXNlJywgJ3Jlc29sdmUnXSxcblx0JyVSYW5nZUVycm9yUHJvdG90eXBlJSc6IFsnUmFuZ2VFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVSZWZlcmVuY2VFcnJvclByb3RvdHlwZSUnOiBbJ1JlZmVyZW5jZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZ0V4cFByb3RvdHlwZSUnOiBbJ1JlZ0V4cCcsICdwcm90b3R5cGUnXSxcblx0JyVTZXRQcm90b3R5cGUlJzogWydTZXQnLCAncHJvdG90eXBlJ10sXG5cdCclU2hhcmVkQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydTaGFyZWRBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVTdHJpbmdQcm90b3R5cGUlJzogWydTdHJpbmcnLCAncHJvdG90eXBlJ10sXG5cdCclU3ltYm9sUHJvdG90eXBlJSc6IFsnU3ltYm9sJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN5bnRheEVycm9yUHJvdG90eXBlJSc6IFsnU3ludGF4RXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZWRBcnJheVByb3RvdHlwZSUnOiBbJ1R5cGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZUVycm9yUHJvdG90eXBlJSc6IFsnVHlwZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4QXJyYXlQcm90b3R5cGUlJzogWydVaW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhDbGFtcGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDE2QXJyYXlQcm90b3R5cGUlJzogWydVaW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVSSUVycm9yUHJvdG90eXBlJSc6IFsnVVJJRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha01hcFByb3RvdHlwZSUnOiBbJ1dlYWtNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha1NldFByb3RvdHlwZSUnOiBbJ1dlYWtTZXQnLCAncHJvdG90eXBlJ11cbn07XG5cbnZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MDkwKTtcbnZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxOTgpO1xudmFyICRjb25jYXQgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgQXJyYXkucHJvdG90eXBlLmNvbmNhdCk7XG52YXIgJHNwbGljZUFwcGx5ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmFwcGx5LCBBcnJheS5wcm90b3R5cGUuc3BsaWNlKTtcbnZhciAkcmVwbGFjZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xudmFyICRzdHJTbGljZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnNsaWNlKTtcbnZhciAkZXhlYyA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBSZWdFeHAucHJvdG90eXBlLmV4ZWMpO1xuXG4vKiBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi80LjE3LjE1L2Rpc3QvbG9kYXNoLmpzI0w2NzM1LUw2NzQ0ICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXiUuW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JSQpKS9nO1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nOyAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBmdW5jdGlvbiBzdHJpbmdUb1BhdGgoc3RyaW5nKSB7XG5cdHZhciBmaXJzdCA9ICRzdHJTbGljZShzdHJpbmcsIDAsIDEpO1xuXHR2YXIgbGFzdCA9ICRzdHJTbGljZShzdHJpbmcsIC0xKTtcblx0aWYgKGZpcnN0ID09PSAnJScgJiYgbGFzdCAhPT0gJyUnKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBjbG9zaW5nIGAlYCcpO1xuXHR9IGVsc2UgaWYgKGxhc3QgPT09ICclJyAmJiBmaXJzdCAhPT0gJyUnKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBvcGVuaW5nIGAlYCcpO1xuXHR9XG5cdHZhciByZXN1bHQgPSBbXTtcblx0JHJlcGxhY2Uoc3RyaW5nLCByZVByb3BOYW1lLCBmdW5jdGlvbiAobWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuXHRcdHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHF1b3RlID8gJHJlcGxhY2Uoc3ViU3RyaW5nLCByZUVzY2FwZUNoYXIsICckMScpIDogbnVtYmVyIHx8IG1hdGNoO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG4vKiBlbmQgYWRhcHRhdGlvbiAqL1xuXG52YXIgZ2V0QmFzZUludHJpbnNpYyA9IGZ1bmN0aW9uIGdldEJhc2VJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWNOYW1lID0gbmFtZTtcblx0dmFyIGFsaWFzO1xuXHRpZiAoaGFzT3duKExFR0FDWV9BTElBU0VTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdGFsaWFzID0gTEVHQUNZX0FMSUFTRVNbaW50cmluc2ljTmFtZV07XG5cdFx0aW50cmluc2ljTmFtZSA9ICclJyArIGFsaWFzWzBdICsgJyUnO1xuXHR9XG5cblx0aWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdHZhciB2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljTmFtZV07XG5cdFx0aWYgKHZhbHVlID09PSBuZWVkc0V2YWwpIHtcblx0XHRcdHZhbHVlID0gZG9FdmFsKGludHJpbnNpY05hbWUpO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyAmJiAhYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSEnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YWxpYXM6IGFsaWFzLFxuXHRcdFx0bmFtZTogaW50cmluc2ljTmFtZSxcblx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdH07XG5cdH1cblxuXHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGRvZXMgbm90IGV4aXN0IScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBHZXRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgbmFtZS5sZW5ndGggPT09IDApIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIGFsbG93TWlzc2luZyAhPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ1wiYWxsb3dNaXNzaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblx0fVxuXG5cdGlmICgkZXhlYygvXiU/W14lXSolPyQvLCBuYW1lKSA9PT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2AlYCBtYXkgbm90IGJlIHByZXNlbnQgYW55d2hlcmUgYnV0IGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgaW50cmluc2ljIG5hbWUnKTtcblx0fVxuXHR2YXIgcGFydHMgPSBzdHJpbmdUb1BhdGgobmFtZSk7XG5cdHZhciBpbnRyaW5zaWNCYXNlTmFtZSA9IHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0c1swXSA6ICcnO1xuXG5cdHZhciBpbnRyaW5zaWMgPSBnZXRCYXNlSW50cmluc2ljKCclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnLCBhbGxvd01pc3NpbmcpO1xuXHR2YXIgaW50cmluc2ljUmVhbE5hbWUgPSBpbnRyaW5zaWMubmFtZTtcblx0dmFyIHZhbHVlID0gaW50cmluc2ljLnZhbHVlO1xuXHR2YXIgc2tpcEZ1cnRoZXJDYWNoaW5nID0gZmFsc2U7XG5cblx0dmFyIGFsaWFzID0gaW50cmluc2ljLmFsaWFzO1xuXHRpZiAoYWxpYXMpIHtcblx0XHRpbnRyaW5zaWNCYXNlTmFtZSA9IGFsaWFzWzBdO1xuXHRcdCRzcGxpY2VBcHBseShwYXJ0cywgJGNvbmNhdChbMCwgMV0sIGFsaWFzKSk7XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMSwgaXNPd24gPSB0cnVlOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHR2YXIgcGFydCA9IHBhcnRzW2ldO1xuXHRcdHZhciBmaXJzdCA9ICRzdHJTbGljZShwYXJ0LCAwLCAxKTtcblx0XHR2YXIgbGFzdCA9ICRzdHJTbGljZShwYXJ0LCAtMSk7XG5cdFx0aWYgKFxuXHRcdFx0KFxuXHRcdFx0XHQoZmlyc3QgPT09ICdcIicgfHwgZmlyc3QgPT09IFwiJ1wiIHx8IGZpcnN0ID09PSAnYCcpXG5cdFx0XHRcdHx8IChsYXN0ID09PSAnXCInIHx8IGxhc3QgPT09IFwiJ1wiIHx8IGxhc3QgPT09ICdgJylcblx0XHRcdClcblx0XHRcdCYmIGZpcnN0ICE9PSBsYXN0XG5cdFx0KSB7XG5cdFx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdwcm9wZXJ0eSBuYW1lcyB3aXRoIHF1b3RlcyBtdXN0IGhhdmUgbWF0Y2hpbmcgcXVvdGVzJyk7XG5cdFx0fVxuXHRcdGlmIChwYXJ0ID09PSAnY29uc3RydWN0b3InIHx8ICFpc093bikge1xuXHRcdFx0c2tpcEZ1cnRoZXJDYWNoaW5nID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpbnRyaW5zaWNCYXNlTmFtZSArPSAnLicgKyBwYXJ0O1xuXHRcdGludHJpbnNpY1JlYWxOYW1lID0gJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJSc7XG5cblx0XHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY1JlYWxOYW1lKSkge1xuXHRcdFx0dmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0XHRcdGlmICghKHBhcnQgaW4gdmFsdWUpKSB7XG5cdFx0XHRcdGlmICghYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Jhc2UgaW50cmluc2ljIGZvciAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZvaWQgdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCRnT1BEICYmIChpICsgMSkgPj0gcGFydHMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBkZXNjID0gJGdPUEQodmFsdWUsIHBhcnQpO1xuXHRcdFx0XHRpc093biA9ICEhZGVzYztcblxuXHRcdFx0XHQvLyBCeSBjb252ZW50aW9uLCB3aGVuIGEgZGF0YSBwcm9wZXJ0eSBpcyBjb252ZXJ0ZWQgdG8gYW4gYWNjZXNzb3Jcblx0XHRcdFx0Ly8gcHJvcGVydHkgdG8gZW11bGF0ZSBhIGRhdGEgcHJvcGVydHkgdGhhdCBkb2VzIG5vdCBzdWZmZXIgZnJvbVxuXHRcdFx0XHQvLyB0aGUgb3ZlcnJpZGUgbWlzdGFrZSwgdGhhdCBhY2Nlc3NvcidzIGdldHRlciBpcyBtYXJrZWQgd2l0aFxuXHRcdFx0XHQvLyBhbiBgb3JpZ2luYWxWYWx1ZWAgcHJvcGVydHkuIEhlcmUsIHdoZW4gd2UgZGV0ZWN0IHRoaXMsIHdlXG5cdFx0XHRcdC8vIHVwaG9sZCB0aGUgaWxsdXNpb24gYnkgcHJldGVuZGluZyB0byBzZWUgdGhhdCBvcmlnaW5hbCBkYXRhXG5cdFx0XHRcdC8vIHByb3BlcnR5LCBpLmUuLCByZXR1cm5pbmcgdGhlIHZhbHVlIHJhdGhlciB0aGFuIHRoZSBnZXR0ZXJcblx0XHRcdFx0Ly8gaXRzZWxmLlxuXHRcdFx0XHRpZiAoaXNPd24gJiYgJ2dldCcgaW4gZGVzYyAmJiAhKCdvcmlnaW5hbFZhbHVlJyBpbiBkZXNjLmdldCkpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGRlc2MuZ2V0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlzT3duID0gaGFzT3duKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzT3duICYmICFza2lwRnVydGhlckNhY2hpbmcpIHtcblx0XHRcdFx0SU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHZhbHVlO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzI2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgR2V0SW50cmluc2ljID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Mjg2KTtcblxudmFyICRnT1BEID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciUnLCB0cnVlKTtcblxuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoW10sICdsZW5ndGgnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGdPUERcblx0XHQkZ09QRCA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAkZ09QRDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTE4MTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEdldEludHJpbnNpYyA9IF9fd2VicGFja19yZXF1aXJlX18oNzI4Nik7XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZGVmaW5lUHJvcGVydHklJywgdHJ1ZSk7XG5cbnZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzID0gZnVuY3Rpb24gaGFzUHJvcGVydHlEZXNjcmlwdG9ycygpIHtcblx0aWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdHRyeSB7XG5cdFx0XHQkZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyB2YWx1ZTogMSB9KTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGRlZmluZVByb3BlcnR5XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbmhhc1Byb3BlcnR5RGVzY3JpcHRvcnMuaGFzQXJyYXlMZW5ndGhEZWZpbmVCdWcgPSBmdW5jdGlvbiBoYXNBcnJheUxlbmd0aERlZmluZUJ1ZygpIHtcblx0Ly8gbm9kZSB2MC42IGhhcyBhIGJ1ZyB3aGVyZSBhcnJheSBsZW5ndGhzIGNhbiBiZSBTZXQgYnV0IG5vdCBEZWZpbmVkXG5cdGlmICghaGFzUHJvcGVydHlEZXNjcmlwdG9ycygpKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0dHJ5IHtcblx0XHRyZXR1cm4gJGRlZmluZVByb3BlcnR5KFtdLCAnbGVuZ3RoJywgeyB2YWx1ZTogMSB9KS5sZW5ndGggIT09IDE7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJbiBGaXJlZm94IDQtMjIsIGRlZmluaW5nIGxlbmd0aCBvbiBhbiBhcnJheSB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvcnM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg0ODY6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgdGVzdCA9IHtcblx0Zm9vOiB7fVxufTtcblxudmFyICRPYmplY3QgPSBPYmplY3Q7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzUHJvdG8oKSB7XG5cdHJldHVybiB7IF9fcHJvdG9fXzogdGVzdCB9LmZvbyA9PT0gdGVzdC5mb28gJiYgISh7IF9fcHJvdG9fXzogbnVsbCB9IGluc3RhbmNlb2YgJE9iamVjdCk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyNjM2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgb3JpZ1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbDtcbnZhciBoYXNTeW1ib2xTaGFtID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Njc5KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2woJ2ZvbycpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2woJ2JhcicpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRyZXR1cm4gaGFzU3ltYm9sU2hhbSgpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjY3OTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qIGVzbGludCBjb21wbGV4aXR5OiBbMiwgMThdLCBtYXgtc3RhdGVtZW50czogWzIsIDMzXSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7IHJldHVybiB0cnVlOyB9XG5cblx0dmFyIG9iaiA9IHt9O1xuXHR2YXIgc3ltID0gU3ltYm9sKCd0ZXN0Jyk7XG5cdHZhciBzeW1PYmogPSBPYmplY3Qoc3ltKTtcblx0aWYgKHR5cGVvZiBzeW0gPT09ICdzdHJpbmcnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltT2JqKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9vYmplY3QuYXNzaWduL2lzc3Vlcy8xN1xuXHQvLyBpZiAoc3ltIGluc3RhbmNlb2YgU3ltYm9sKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMvaXNzdWVzLzRcblx0Ly8gaWYgKCEoc3ltT2JqIGluc3RhbmNlb2YgU3ltYm9sKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyBpZiAodHlwZW9mIFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIGlmIChTdHJpbmcoc3ltKSAhPT0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bVZhbCA9IDQyO1xuXHRvYmpbc3ltXSA9IHN5bVZhbDtcblx0Zm9yIChzeW0gaW4gb2JqKSB7IHJldHVybiBmYWxzZTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby11bnJlYWNoYWJsZS1sb29wXG5cdGlmICh0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmtleXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKTtcblx0aWYgKHN5bXMubGVuZ3RoICE9PSAxIHx8IHN5bXNbMF0gIT09IHN5bSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgc3ltKTtcblx0XHRpZiAoZGVzY3JpcHRvci52YWx1ZSAhPT0gc3ltVmFsIHx8IGRlc2NyaXB0b3IuZW51bWVyYWJsZSAhPT0gdHJ1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzIyNjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGhhc1N5bWJvbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2NzkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1RvU3RyaW5nVGFnU2hhbXMoKSB7XG5cdHJldHVybiBoYXNTeW1ib2xzKCkgJiYgISFTeW1ib2wudG9TdHJpbmdUYWc7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzMTk4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oNDA5MCk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMjg1OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICAgIH1cbiAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyNjM1OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaGFzVG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyMjYpKCk7XG52YXIgY2FsbEJvdW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjgwKTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xuXG52YXIgaXNTdGFuZGFyZEFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdGlmIChoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gJHRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59O1xuXG52YXIgaXNMZWdhY3lBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHRpZiAoaXNTdGFuZGFyZEFyZ3VtZW50cyh2YWx1ZSkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gdmFsdWUgIT09IG51bGwgJiZcblx0XHR0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG5cdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcblx0XHR2YWx1ZS5sZW5ndGggPj0gMCAmJlxuXHRcdCR0b1N0cmluZyh2YWx1ZSkgIT09ICdbb2JqZWN0IEFycmF5XScgJiZcblx0XHQkdG9TdHJpbmcodmFsdWUuY2FsbGVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnZhciBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIGlzU3RhbmRhcmRBcmd1bWVudHMoYXJndW1lbnRzKTtcbn0oKSk7XG5cbmlzU3RhbmRhcmRBcmd1bWVudHMuaXNMZWdhY3lBcmd1bWVudHMgPSBpc0xlZ2FjeUFyZ3VtZW50czsgLy8gZm9yIHRlc3RzXG5cbm1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA/IGlzU3RhbmRhcmRBcmd1bWVudHMgOiBpc0xlZ2FjeUFyZ3VtZW50cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTY4MDpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBmblRvU3RyID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHJlZmxlY3RBcHBseSA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0ICE9PSBudWxsICYmIFJlZmxlY3QuYXBwbHk7XG52YXIgYmFkQXJyYXlMaWtlO1xudmFyIGlzQ2FsbGFibGVNYXJrZXI7XG5pZiAodHlwZW9mIHJlZmxlY3RBcHBseSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG5cdHRyeSB7XG5cdFx0YmFkQXJyYXlMaWtlID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnbGVuZ3RoJywge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRocm93IGlzQ2FsbGFibGVNYXJrZXI7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0aXNDYWxsYWJsZU1hcmtlciA9IHt9O1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG5cdFx0cmVmbGVjdEFwcGx5KGZ1bmN0aW9uICgpIHsgdGhyb3cgNDI7IH0sIG51bGwsIGJhZEFycmF5TGlrZSk7XG5cdH0gY2F0Y2ggKF8pIHtcblx0XHRpZiAoXyAhPT0gaXNDYWxsYWJsZU1hcmtlcikge1xuXHRcdFx0cmVmbGVjdEFwcGx5ID0gbnVsbDtcblx0XHR9XG5cdH1cbn0gZWxzZSB7XG5cdHJlZmxlY3RBcHBseSA9IG51bGw7XG59XG5cbnZhciBjb25zdHJ1Y3RvclJlZ2V4ID0gL15cXHMqY2xhc3NcXGIvO1xudmFyIGlzRVM2Q2xhc3NGbiA9IGZ1bmN0aW9uIGlzRVM2Q2xhc3NGdW5jdGlvbih2YWx1ZSkge1xuXHR0cnkge1xuXHRcdHZhciBmblN0ciA9IGZuVG9TdHIuY2FsbCh2YWx1ZSk7XG5cdFx0cmV0dXJuIGNvbnN0cnVjdG9yUmVnZXgudGVzdChmblN0cik7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7IC8vIG5vdCBhIGZ1bmN0aW9uXG5cdH1cbn07XG5cbnZhciB0cnlGdW5jdGlvbk9iamVjdCA9IGZ1bmN0aW9uIHRyeUZ1bmN0aW9uVG9TdHIodmFsdWUpIHtcblx0dHJ5IHtcblx0XHRpZiAoaXNFUzZDbGFzc0ZuKHZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRmblRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBvYmplY3RDbGFzcyA9ICdbb2JqZWN0IE9iamVjdF0nO1xudmFyIGZuQ2xhc3MgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xudmFyIGdlbkNsYXNzID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcbnZhciBkZGFDbGFzcyA9ICdbb2JqZWN0IEhUTUxBbGxDb2xsZWN0aW9uXSc7IC8vIElFIDExXG52YXIgZGRhQ2xhc3MyID0gJ1tvYmplY3QgSFRNTCBkb2N1bWVudC5hbGwgY2xhc3NdJztcbnZhciBkZGFDbGFzczMgPSAnW29iamVjdCBIVE1MQ29sbGVjdGlvbl0nOyAvLyBJRSA5LTEwXG52YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmICEhU3ltYm9sLnRvU3RyaW5nVGFnOyAvLyBiZXR0ZXI6IHVzZSBgaGFzLXRvc3RyaW5ndGFnYFxuXG52YXIgaXNJRTY4ID0gISgwIGluIFssXSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc3BhcnNlLWFycmF5cywgY29tbWEtc3BhY2luZ1xuXG52YXIgaXNEREEgPSBmdW5jdGlvbiBpc0RvY3VtZW50RG90QWxsKCkgeyByZXR1cm4gZmFsc2U7IH07XG5pZiAodHlwZW9mIGRvY3VtZW50ID09PSAnb2JqZWN0Jykge1xuXHQvLyBGaXJlZm94IDMgY2Fub25pY2FsaXplcyBEREEgdG8gdW5kZWZpbmVkIHdoZW4gaXQncyBub3QgYWNjZXNzZWQgZGlyZWN0bHlcblx0dmFyIGFsbCA9IGRvY3VtZW50LmFsbDtcblx0aWYgKHRvU3RyLmNhbGwoYWxsKSA9PT0gdG9TdHIuY2FsbChkb2N1bWVudC5hbGwpKSB7XG5cdFx0aXNEREEgPSBmdW5jdGlvbiBpc0RvY3VtZW50RG90QWxsKHZhbHVlKSB7XG5cdFx0XHQvKiBnbG9iYWxzIGRvY3VtZW50OiBmYWxzZSAqL1xuXHRcdFx0Ly8gaW4gSUUgNi04LCB0eXBlb2YgZG9jdW1lbnQuYWxsIGlzIFwib2JqZWN0XCIgYW5kIGl0J3MgdHJ1dGh5XG5cdFx0XHRpZiAoKGlzSUU2OCB8fCAhdmFsdWUpICYmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dmFyIHN0ciA9IHRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0XHRzdHIgPT09IGRkYUNsYXNzXG5cdFx0XHRcdFx0XHR8fCBzdHIgPT09IGRkYUNsYXNzMlxuXHRcdFx0XHRcdFx0fHwgc3RyID09PSBkZGFDbGFzczMgLy8gb3BlcmEgMTIuMTZcblx0XHRcdFx0XHRcdHx8IHN0ciA9PT0gb2JqZWN0Q2xhc3MgLy8gSUUgNi04XG5cdFx0XHRcdFx0KSAmJiB2YWx1ZSgnJykgPT0gbnVsbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcblx0XHRcdFx0fSBjYXRjaCAoZSkgeyAvKiovIH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVmbGVjdEFwcGx5XG5cdD8gZnVuY3Rpb24gaXNDYWxsYWJsZSh2YWx1ZSkge1xuXHRcdGlmIChpc0REQSh2YWx1ZSkpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRpZiAoIXZhbHVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR0cnkge1xuXHRcdFx0cmVmbGVjdEFwcGx5KHZhbHVlLCBudWxsLCBiYWRBcnJheUxpa2UpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGlmIChlICE9PSBpc0NhbGxhYmxlTWFya2VyKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdH1cblx0XHRyZXR1cm4gIWlzRVM2Q2xhc3NGbih2YWx1ZSkgJiYgdHJ5RnVuY3Rpb25PYmplY3QodmFsdWUpO1xuXHR9XG5cdDogZnVuY3Rpb24gaXNDYWxsYWJsZSh2YWx1ZSkge1xuXHRcdGlmIChpc0REQSh2YWx1ZSkpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRpZiAoIXZhbHVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRpZiAoaGFzVG9TdHJpbmdUYWcpIHsgcmV0dXJuIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKTsgfVxuXHRcdGlmIChpc0VTNkNsYXNzRm4odmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdHZhciBzdHJDbGFzcyA9IHRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdGlmIChzdHJDbGFzcyAhPT0gZm5DbGFzcyAmJiBzdHJDbGFzcyAhPT0gZ2VuQ2xhc3MgJiYgISgvXlxcW29iamVjdCBIVE1MLykudGVzdChzdHJDbGFzcykpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0cmV0dXJuIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKTtcblx0fTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzEzODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmblRvU3RyID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGlzRm5SZWdleCA9IC9eXFxzKig/OmZ1bmN0aW9uKT9cXCovO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MjI2KSgpO1xudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIGdldEdlbmVyYXRvckZ1bmMgPSBmdW5jdGlvbiAoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHR0cnkge1xuXHRcdHJldHVybiBGdW5jdGlvbigncmV0dXJuIGZ1bmN0aW9uKigpIHt9JykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHR9XG59O1xudmFyIEdlbmVyYXRvckZ1bmN0aW9uO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzR2VuZXJhdG9yRnVuY3Rpb24oZm4pIHtcblx0aWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRpZiAoaXNGblJlZ2V4LnRlc3QoZm5Ub1N0ci5jYWxsKGZuKSkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnKSB7XG5cdFx0dmFyIHN0ciA9IHRvU3RyLmNhbGwoZm4pO1xuXHRcdHJldHVybiBzdHIgPT09ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7XG5cdH1cblx0aWYgKCFnZXRQcm90bykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRpZiAodHlwZW9mIEdlbmVyYXRvckZ1bmN0aW9uID09PSAndW5kZWZpbmVkJykge1xuXHRcdHZhciBnZW5lcmF0b3JGdW5jID0gZ2V0R2VuZXJhdG9yRnVuYygpO1xuXHRcdEdlbmVyYXRvckZ1bmN0aW9uID0gZ2VuZXJhdG9yRnVuYyA/IGdldFByb3RvKGdlbmVyYXRvckZ1bmMpIDogZmFsc2U7XG5cdH1cblx0cmV0dXJuIGdldFByb3RvKGZuKSA9PT0gR2VuZXJhdG9yRnVuY3Rpb247XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3MDUzOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5pc25hbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzTmFOKHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NzgyOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgY2FsbEJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk0MjkpO1xudmFyIGRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkyNik7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNzA1Myk7XG52YXIgZ2V0UG9seWZpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1NSk7XG52YXIgc2hpbSA9IF9fd2VicGFja19yZXF1aXJlX18oNTM0Nik7XG5cbnZhciBwb2x5ZmlsbCA9IGNhbGxCaW5kKGdldFBvbHlmaWxsKCksIE51bWJlcik7XG5cbi8qIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIuaXNuYW4gKi9cblxuZGVmaW5lKHBvbHlmaWxsLCB7XG5cdGdldFBvbHlmaWxsOiBnZXRQb2x5ZmlsbCxcblx0aW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uLFxuXHRzaGltOiBzaGltXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwb2x5ZmlsbDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzU1OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaW1wbGVtZW50YXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwNTMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuXHRpZiAoTnVtYmVyLmlzTmFOICYmIE51bWJlci5pc05hTihOYU4pICYmICFOdW1iZXIuaXNOYU4oJ2EnKSkge1xuXHRcdHJldHVybiBOdW1iZXIuaXNOYU47XG5cdH1cblx0cmV0dXJuIGltcGxlbWVudGF0aW9uO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTM0Njpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkyNik7XG52YXIgZ2V0UG9seWZpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1NSk7XG5cbi8qIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIuaXNuYW4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGltTnVtYmVySXNOYU4oKSB7XG5cdHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XG5cdGRlZmluZShOdW1iZXIsIHsgaXNOYU46IHBvbHlmaWxsIH0sIHtcblx0XHRpc05hTjogZnVuY3Rpb24gdGVzdElzTmFOKCkge1xuXHRcdFx0cmV0dXJuIE51bWJlci5pc05hTiAhPT0gcG9seWZpbGw7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIHBvbHlmaWxsO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTk4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgd2hpY2hUeXBlZEFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMDk0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1R5cGVkQXJyYXkodmFsdWUpIHtcblx0cmV0dXJuICEhd2hpY2hUeXBlZEFycmF5KHZhbHVlKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDgxNjk6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgbnVtYmVySXNOYU4gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXMoYSwgYikge1xuXHRpZiAoYSA9PT0gMCAmJiBiID09PSAwKSB7XG5cdFx0cmV0dXJuIDEgLyBhID09PSAxIC8gYjtcblx0fVxuXHRpZiAoYSA9PT0gYikge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdGlmIChudW1iZXJJc05hTihhKSAmJiBudW1iZXJJc05hTihiKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDY3OTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkyNik7XG52YXIgY2FsbEJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk0MjkpO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxNjkpO1xudmFyIGdldFBvbHlmaWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MDcwKTtcbnZhciBzaGltID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTEpO1xuXG52YXIgcG9seWZpbGwgPSBjYWxsQmluZChnZXRQb2x5ZmlsbCgpLCBPYmplY3QpO1xuXG5kZWZpbmUocG9seWZpbGwsIHtcblx0Z2V0UG9seWZpbGw6IGdldFBvbHlmaWxsLFxuXHRpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb24sXG5cdHNoaW06IHNoaW1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvbHlmaWxsO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4MDcwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaW1wbGVtZW50YXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxNjkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuXHRyZXR1cm4gdHlwZW9mIE9iamVjdC5pcyA9PT0gJ2Z1bmN0aW9uJyA/IE9iamVjdC5pcyA6IGltcGxlbWVudGF0aW9uO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTkxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgZ2V0UG9seWZpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwNzApO1xudmFyIGRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkyNik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hpbU9iamVjdElzKCkge1xuXHR2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuXHRkZWZpbmUoT2JqZWN0LCB7IGlzOiBwb2x5ZmlsbCB9LCB7XG5cdFx0aXM6IGZ1bmN0aW9uIHRlc3RPYmplY3RJcygpIHtcblx0XHRcdHJldHVybiBPYmplY3QuaXMgIT09IHBvbHlmaWxsO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDU2OTE6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBrZXlzU2hpbTtcbmlmICghT2JqZWN0LmtleXMpIHtcblx0Ly8gbW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW1cblx0dmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cdHZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cdHZhciBpc0FyZ3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwMSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZ2xvYmFsLXJlcXVpcmVcblx0dmFyIGlzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cdHZhciBoYXNEb250RW51bUJ1ZyA9ICFpc0VudW1lcmFibGUuY2FsbCh7IHRvU3RyaW5nOiBudWxsIH0sICd0b1N0cmluZycpO1xuXHR2YXIgaGFzUHJvdG9FbnVtQnVnID0gaXNFbnVtZXJhYmxlLmNhbGwoZnVuY3Rpb24gKCkge30sICdwcm90b3R5cGUnKTtcblx0dmFyIGRvbnRFbnVtcyA9IFtcblx0XHQndG9TdHJpbmcnLFxuXHRcdCd0b0xvY2FsZVN0cmluZycsXG5cdFx0J3ZhbHVlT2YnLFxuXHRcdCdoYXNPd25Qcm9wZXJ0eScsXG5cdFx0J2lzUHJvdG90eXBlT2YnLFxuXHRcdCdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG5cdFx0J2NvbnN0cnVjdG9yJ1xuXHRdO1xuXHR2YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUgPSBmdW5jdGlvbiAobykge1xuXHRcdHZhciBjdG9yID0gby5jb25zdHJ1Y3Rvcjtcblx0XHRyZXR1cm4gY3RvciAmJiBjdG9yLnByb3RvdHlwZSA9PT0gbztcblx0fTtcblx0dmFyIGV4Y2x1ZGVkS2V5cyA9IHtcblx0XHQkYXBwbGljYXRpb25DYWNoZTogdHJ1ZSxcblx0XHQkY29uc29sZTogdHJ1ZSxcblx0XHQkZXh0ZXJuYWw6IHRydWUsXG5cdFx0JGZyYW1lOiB0cnVlLFxuXHRcdCRmcmFtZUVsZW1lbnQ6IHRydWUsXG5cdFx0JGZyYW1lczogdHJ1ZSxcblx0XHQkaW5uZXJIZWlnaHQ6IHRydWUsXG5cdFx0JGlubmVyV2lkdGg6IHRydWUsXG5cdFx0JG9ubW96ZnVsbHNjcmVlbmNoYW5nZTogdHJ1ZSxcblx0XHQkb25tb3pmdWxsc2NyZWVuZXJyb3I6IHRydWUsXG5cdFx0JG91dGVySGVpZ2h0OiB0cnVlLFxuXHRcdCRvdXRlcldpZHRoOiB0cnVlLFxuXHRcdCRwYWdlWE9mZnNldDogdHJ1ZSxcblx0XHQkcGFnZVlPZmZzZXQ6IHRydWUsXG5cdFx0JHBhcmVudDogdHJ1ZSxcblx0XHQkc2Nyb2xsTGVmdDogdHJ1ZSxcblx0XHQkc2Nyb2xsVG9wOiB0cnVlLFxuXHRcdCRzY3JvbGxYOiB0cnVlLFxuXHRcdCRzY3JvbGxZOiB0cnVlLFxuXHRcdCRzZWxmOiB0cnVlLFxuXHRcdCR3ZWJraXRJbmRleGVkREI6IHRydWUsXG5cdFx0JHdlYmtpdFN0b3JhZ2VJbmZvOiB0cnVlLFxuXHRcdCR3aW5kb3c6IHRydWVcblx0fTtcblx0dmFyIGhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1ZyA9IChmdW5jdGlvbiAoKSB7XG5cdFx0LyogZ2xvYmFsIHdpbmRvdyAqL1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRmb3IgKHZhciBrIGluIHdpbmRvdykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKCFleGNsdWRlZEtleXNbJyQnICsga10gJiYgaGFzLmNhbGwod2luZG93LCBrKSAmJiB3aW5kb3dba10gIT09IG51bGwgJiYgdHlwZW9mIHdpbmRvd1trXSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0ZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUod2luZG93W2tdKTtcblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSgpKTtcblx0dmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneSA9IGZ1bmN0aW9uIChvKSB7XG5cdFx0LyogZ2xvYmFsIHdpbmRvdyAqL1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnKSB7XG5cdFx0XHRyZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUobyk7XG5cdFx0fVxuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUobyk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fTtcblxuXHRrZXlzU2hpbSA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG5cdFx0dmFyIGlzT2JqZWN0ID0gb2JqZWN0ICE9PSBudWxsICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnO1xuXHRcdHZhciBpc0Z1bmN0aW9uID0gdG9TdHIuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXHRcdHZhciBpc0FyZ3VtZW50cyA9IGlzQXJncyhvYmplY3QpO1xuXHRcdHZhciBpc1N0cmluZyA9IGlzT2JqZWN0ICYmIHRvU3RyLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cdFx0dmFyIHRoZUtleXMgPSBbXTtcblxuXHRcdGlmICghaXNPYmplY3QgJiYgIWlzRnVuY3Rpb24gJiYgIWlzQXJndW1lbnRzKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qua2V5cyBjYWxsZWQgb24gYSBub24tb2JqZWN0Jyk7XG5cdFx0fVxuXG5cdFx0dmFyIHNraXBQcm90byA9IGhhc1Byb3RvRW51bUJ1ZyAmJiBpc0Z1bmN0aW9uO1xuXHRcdGlmIChpc1N0cmluZyAmJiBvYmplY3QubGVuZ3RoID4gMCAmJiAhaGFzLmNhbGwob2JqZWN0LCAwKSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhpKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGlzQXJndW1lbnRzICYmIG9iamVjdC5sZW5ndGggPiAwKSB7XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IG9iamVjdC5sZW5ndGg7ICsraikge1xuXHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKGopKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcblx0XHRcdFx0aWYgKCEoc2tpcFByb3RvICYmIG5hbWUgPT09ICdwcm90b3R5cGUnKSAmJiBoYXMuY2FsbChvYmplY3QsIG5hbWUpKSB7XG5cdFx0XHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhuYW1lKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaGFzRG9udEVudW1CdWcpIHtcblx0XHRcdHZhciBza2lwQ29uc3RydWN0b3IgPSBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kob2JqZWN0KTtcblxuXHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBkb250RW51bXMubGVuZ3RoOyArK2spIHtcblx0XHRcdFx0aWYgKCEoc2tpcENvbnN0cnVjdG9yICYmIGRvbnRFbnVtc1trXSA9PT0gJ2NvbnN0cnVjdG9yJykgJiYgaGFzLmNhbGwob2JqZWN0LCBkb250RW51bXNba10pKSB7XG5cdFx0XHRcdFx0dGhlS2V5cy5wdXNoKGRvbnRFbnVtc1trXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoZUtleXM7XG5cdH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGtleXNTaGltO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNDY0OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaXNBcmdzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MDEpO1xuXG52YXIgb3JpZ0tleXMgPSBPYmplY3Qua2V5cztcbnZhciBrZXlzU2hpbSA9IG9yaWdLZXlzID8gZnVuY3Rpb24ga2V5cyhvKSB7IHJldHVybiBvcmlnS2V5cyhvKTsgfSA6IF9fd2VicGFja19yZXF1aXJlX18oNTY5MSk7XG5cbnZhciBvcmlnaW5hbEtleXMgPSBPYmplY3Qua2V5cztcblxua2V5c1NoaW0uc2hpbSA9IGZ1bmN0aW9uIHNoaW1PYmplY3RLZXlzKCkge1xuXHRpZiAoT2JqZWN0LmtleXMpIHtcblx0XHR2YXIga2V5c1dvcmtzV2l0aEFyZ3VtZW50cyA9IChmdW5jdGlvbiAoKSB7XG5cdFx0XHQvLyBTYWZhcmkgNS4wIGJ1Z1xuXHRcdFx0dmFyIGFyZ3MgPSBPYmplY3Qua2V5cyhhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIGFyZ3MgJiYgYXJncy5sZW5ndGggPT09IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0fSgxLCAyKSk7XG5cdFx0aWYgKCFrZXlzV29ya3NXaXRoQXJndW1lbnRzKSB7XG5cdFx0XHRPYmplY3Qua2V5cyA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG5cdFx0XHRcdGlmIChpc0FyZ3Mob2JqZWN0KSkge1xuXHRcdFx0XHRcdHJldHVybiBvcmlnaW5hbEtleXMoc2xpY2UuY2FsbChvYmplY3QpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxLZXlzKG9iamVjdCk7XG5cdFx0XHR9O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRPYmplY3Qua2V5cyA9IGtleXNTaGltO1xuXHR9XG5cdHJldHVybiBPYmplY3Qua2V5cyB8fCBrZXlzU2hpbTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c1NoaW07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDgwMTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0dmFyIHN0ciA9IHRvU3RyLmNhbGwodmFsdWUpO1xuXHR2YXIgaXNBcmdzID0gc3RyID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcblx0aWYgKCFpc0FyZ3MpIHtcblx0XHRpc0FyZ3MgPSBzdHIgIT09ICdbb2JqZWN0IEFycmF5XScgJiZcblx0XHRcdHZhbHVlICE9PSBudWxsICYmXG5cdFx0XHR0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG5cdFx0XHR0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuXHRcdFx0dmFsdWUubGVuZ3RoID49IDAgJiZcblx0XHRcdHRvU3RyLmNhbGwodmFsdWUuY2FsbGVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0fVxuXHRyZXR1cm4gaXNBcmdzO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDQwNjpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ0ODc6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQmFzZVNlcnZpY2U6ICgpID0+ICgvKiBiaW5kaW5nICovIEJhc2VTZXJ2aWNlKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYyOTcpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZzY29kZV9sYW5ndWFnZXNlcnZlcl90ZXh0ZG9jdW1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDg4MSk7XG5mdW5jdGlvbiBfZGVmaW5lX3Byb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5cblxuY2xhc3MgQmFzZVNlcnZpY2Uge1xuICAgIGFkZERvY3VtZW50KGRvY3VtZW50KSB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRzW2RvY3VtZW50LnVyaV0gPSB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdGV4dGRvY3VtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18vKiAuVGV4dERvY3VtZW50ICovIC5uLmNyZWF0ZShkb2N1bWVudC51cmksIGRvY3VtZW50Lmxhbmd1YWdlSWQsIGRvY3VtZW50LnZlcnNpb24sIGRvY3VtZW50LnRleHQpO1xuICAgIC8vVE9ETzpcbiAgICAvKmlmIChvcHRpb25zKVxuICAgICAgICAgICAgdGhpcy5zZXRTZXNzaW9uT3B0aW9ucyhzZXNzaW9uSUQsIG9wdGlvbnMpOyovIH1cbiAgICBnZXREb2N1bWVudCh1cmkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRzW3VyaV07XG4gICAgfVxuICAgIHJlbW92ZURvY3VtZW50KGRvY3VtZW50KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmRvY3VtZW50c1tkb2N1bWVudC51cmldO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zW2RvY3VtZW50LnVyaV0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnNbZG9jdW1lbnQudXJpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXREb2N1bWVudFZhbHVlKHVyaSkge1xuICAgICAgICB2YXIgX3RoaXNfZ2V0RG9jdW1lbnQ7XG4gICAgICAgIHJldHVybiAoX3RoaXNfZ2V0RG9jdW1lbnQgPSB0aGlzLmdldERvY3VtZW50KHVyaSkpID09PSBudWxsIHx8IF90aGlzX2dldERvY3VtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19nZXREb2N1bWVudC5nZXRUZXh0KCk7XG4gICAgfVxuICAgIHNldFZhbHVlKGlkZW50aWZpZXIsIHZhbHVlKSB7XG4gICAgICAgIGxldCBkb2N1bWVudCA9IHRoaXMuZ2V0RG9jdW1lbnQoaWRlbnRpZmllci51cmkpO1xuICAgICAgICBpZiAoZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50ID0gdnNjb2RlX2xhbmd1YWdlc2VydmVyX3RleHRkb2N1bWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLlRleHREb2N1bWVudCAqLyAubi5jcmVhdGUoZG9jdW1lbnQudXJpLCBkb2N1bWVudC5sYW5ndWFnZUlkLCBkb2N1bWVudC52ZXJzaW9uLCB2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50c1tkb2N1bWVudC51cmldID0gZG9jdW1lbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0R2xvYmFsT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsT3B0aW9ucyA9IG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9O1xuICAgIH1cbiAgICBzZXRPcHRpb25zKHNlc3Npb25JRCwgb3B0aW9ucywgbWVyZ2UgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLm9wdGlvbnNbc2Vzc2lvbklEXSA9IG1lcmdlID8gKDAsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18vKiAubWVyZ2VPYmplY3RzICovIC5QTSkob3B0aW9ucywgdGhpcy5vcHRpb25zW3Nlc3Npb25JRF0pIDogb3B0aW9ucztcbiAgICB9XG4gICAgZ2V0T3B0aW9uKHNlc3Npb25JRCwgb3B0aW9uTmFtZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zW3Nlc3Npb25JRF0gJiYgdGhpcy5vcHRpb25zW3Nlc3Npb25JRF1bb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbc2Vzc2lvbklEXVtvcHRpb25OYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdsb2JhbE9wdGlvbnNbb3B0aW9uTmFtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwbHlEZWx0YXMoaWRlbnRpZmllciwgZGVsdGFzKSB7XG4gICAgICAgIGxldCBkb2N1bWVudCA9IHRoaXMuZ2V0RG9jdW1lbnQoaWRlbnRpZmllci51cmkpO1xuICAgICAgICBpZiAoZG9jdW1lbnQpIHZzY29kZV9sYW5ndWFnZXNlcnZlcl90ZXh0ZG9jdW1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5UZXh0RG9jdW1lbnQgKi8gLm4udXBkYXRlKGRvY3VtZW50LCBkZWx0YXMsIGlkZW50aWZpZXIudmVyc2lvbik7XG4gICAgfVxuICAgIGFzeW5jIGRvQ29tcGxldGUoZG9jdW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyBkb0hvdmVyKGRvY3VtZW50LCBwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgZG9SZXNvbHZlKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGRvVmFsaWRhdGlvbihkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGZvcm1hdChkb2N1bWVudCwgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgfVxuICAgIGFzeW5jIHByb3ZpZGVTaWduYXR1cmVIZWxwKGRvY3VtZW50LCBwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgZmluZERvY3VtZW50SGlnaGxpZ2h0cyhkb2N1bWVudCwgcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBnZXQgb3B0aW9uc1RvRmlsdGVyRGlhZ25vc3RpY3MoKSB7XG4gICAgICAgIHZhciBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb0lnbm9yZSwgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9UcmVhdEFzV2FybmluZywgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9UcmVhdEFzSW5mbywgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9JZ25vcmUsIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcsIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc0luZm87XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvckNvZGVzVG9JZ25vcmU6IChfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb0lnbm9yZSA9IHRoaXMuZ2xvYmFsT3B0aW9ucy5lcnJvckNvZGVzVG9JZ25vcmUpICE9PSBudWxsICYmIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvSWdub3JlICE9PSB2b2lkIDAgPyBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb0lnbm9yZSA6IFtdLFxuICAgICAgICAgICAgZXJyb3JDb2Rlc1RvVHJlYXRBc1dhcm5pbmc6IChfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nID0gdGhpcy5nbG9iYWxPcHRpb25zLmVycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nKSAhPT0gbnVsbCAmJiBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nICE9PSB2b2lkIDAgPyBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nIDogW10sXG4gICAgICAgICAgICBlcnJvckNvZGVzVG9UcmVhdEFzSW5mbzogKF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm8gPSB0aGlzLmdsb2JhbE9wdGlvbnMuZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm8pICE9PSBudWxsICYmIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm8gIT09IHZvaWQgMCA/IF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm8gOiBbXSxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZXNUb0lnbm9yZTogKF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvSWdub3JlID0gdGhpcy5nbG9iYWxPcHRpb25zLmVycm9yTWVzc2FnZXNUb0lnbm9yZSkgIT09IG51bGwgJiYgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9JZ25vcmUgIT09IHZvaWQgMCA/IF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvSWdub3JlIDogW10sXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2VzVG9UcmVhdEFzV2FybmluZzogKF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcgPSB0aGlzLmdsb2JhbE9wdGlvbnMuZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcpICE9PSBudWxsICYmIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcgIT09IHZvaWQgMCA/IF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcgOiBbXSxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZXNUb1RyZWF0QXNJbmZvOiAoX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbyA9IHRoaXMuZ2xvYmFsT3B0aW9ucy5lcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbykgIT09IG51bGwgJiYgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbyAhPT0gdm9pZCAwID8gX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbyA6IFtdXG4gICAgICAgIH07XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobW9kZSl7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJtb2RlXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJkb2N1bWVudHNcIiwge30pO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwib3B0aW9uc1wiLCB7fSk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJnbG9iYWxPcHRpb25zXCIsIHt9KTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInNlcnZpY2VEYXRhXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJzZXJ2aWNlQ2FwYWJpbGl0aWVzXCIsIHt9KTtcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICB9XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDYyOTc6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgJHA6ICgpID0+ICgvKiBiaW5kaW5nICovIGNoZWNrVmFsdWVBZ2FpbnN0UmVnZXhwQXJyYXkpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBQTTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gbWVyZ2VPYmplY3RzKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnRzIG5vdEVtcHR5LCBtZXJnZVJhbmdlcyAqL1xuZnVuY3Rpb24gbWVyZ2VPYmplY3RzKG9iajEsIG9iajIpIHtcbiAgICBpZiAoIW9iajEpIHJldHVybiBvYmoyO1xuICAgIGlmICghb2JqMikgcmV0dXJuIG9iajE7XG4gICAgY29uc3QgbWVyZ2VkT2JqZWN0cyA9IHtcbiAgICAgICAgLi4ub2JqMixcbiAgICAgICAgLi4ub2JqMVxuICAgIH07IC8vIEdpdmUgcHJpb3JpdHkgdG8gb2JqMSB2YWx1ZXMgYnkgc3ByZWFkaW5nIG9iajIgZmlyc3QsIHRoZW4gb2JqMVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG1lcmdlZE9iamVjdHMpKXtcbiAgICAgICAgaWYgKG9iajFba2V5XSAmJiBvYmoyW2tleV0pIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iajFba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRPYmplY3RzW2tleV0gPSBvYmoxW2tleV0uY29uY2F0KG9iajJba2V5XSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqMltrZXldKSkge1xuICAgICAgICAgICAgICAgIG1lcmdlZE9iamVjdHNba2V5XSA9IG9iajJba2V5XS5jb25jYXQob2JqMVtrZXldKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iajFba2V5XSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iajJba2V5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRPYmplY3RzW2tleV0gPSBtZXJnZU9iamVjdHMob2JqMVtrZXldLCBvYmoyW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWRPYmplY3RzO1xufVxuZnVuY3Rpb24gbm90RW1wdHkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbi8vdGFrZW4gd2l0aCBzbWFsbCBjaGFuZ2VzIGZyb20gYWNlLWNvZGVcbmZ1bmN0aW9uIG1lcmdlUmFuZ2VzKHJhbmdlcykge1xuICAgIHZhciBsaXN0ID0gcmFuZ2VzO1xuICAgIGxpc3QgPSBsaXN0LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gY29tcGFyZVBvaW50cyhhLnN0YXJ0LCBiLnN0YXJ0KTtcbiAgICB9KTtcbiAgICB2YXIgbmV4dCA9IGxpc3RbMF0sIHJhbmdlO1xuICAgIGZvcih2YXIgaSA9IDE7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgcmFuZ2UgPSBuZXh0O1xuICAgICAgICBuZXh0ID0gbGlzdFtpXTtcbiAgICAgICAgdmFyIGNtcCA9IGNvbXBhcmVQb2ludHMocmFuZ2UuZW5kLCBuZXh0LnN0YXJ0KTtcbiAgICAgICAgaWYgKGNtcCA8IDApIGNvbnRpbnVlO1xuICAgICAgICBpZiAoY21wID09IDAgJiYgIXJhbmdlLmlzRW1wdHkoKSAmJiAhbmV4dC5pc0VtcHR5KCkpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoY29tcGFyZVBvaW50cyhyYW5nZS5lbmQsIG5leHQuZW5kKSA8IDApIHtcbiAgICAgICAgICAgIHJhbmdlLmVuZC5yb3cgPSBuZXh0LmVuZC5yb3c7XG4gICAgICAgICAgICByYW5nZS5lbmQuY29sdW1uID0gbmV4dC5lbmQuY29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICBuZXh0ID0gcmFuZ2U7XG4gICAgICAgIGktLTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG59XG5mdW5jdGlvbiBjb21wYXJlUG9pbnRzKHAxLCBwMikge1xuICAgIHJldHVybiBwMS5yb3cgLSBwMi5yb3cgfHwgcDEuY29sdW1uIC0gcDIuY29sdW1uO1xufVxuZnVuY3Rpb24gY2hlY2tWYWx1ZUFnYWluc3RSZWdleHBBcnJheSh2YWx1ZSwgcmVnZXhwQXJyYXkpIHtcbiAgICBpZiAoIXJlZ2V4cEFycmF5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHJlZ2V4cEFycmF5Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgaWYgKHJlZ2V4cEFycmF5W2ldLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDgyOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDg5NTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL3V0aWwvdHlwZXMuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMTEyY2M3YzI3NTUxMjU0YWEyYjE3MDk4ZmI3NzQ4NjdmMDVlZDBkOVxuXG5cblxudmFyIGlzQXJndW1lbnRzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjM1KTtcbnZhciBpc0dlbmVyYXRvckZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMTM4KTtcbnZhciB3aGljaFR5cGVkQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwOTQpO1xudmFyIGlzVHlwZWRBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oMTk4KTtcblxuZnVuY3Rpb24gdW5jdXJyeVRoaXMoZikge1xuICByZXR1cm4gZi5jYWxsLmJpbmQoZik7XG59XG5cbnZhciBCaWdJbnRTdXBwb3J0ZWQgPSB0eXBlb2YgQmlnSW50ICE9PSAndW5kZWZpbmVkJztcbnZhciBTeW1ib2xTdXBwb3J0ZWQgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJztcblxudmFyIE9iamVjdFRvU3RyaW5nID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG5cbnZhciBudW1iZXJWYWx1ZSA9IHVuY3VycnlUaGlzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZik7XG52YXIgc3RyaW5nVmFsdWUgPSB1bmN1cnJ5VGhpcyhTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YpO1xudmFyIGJvb2xlYW5WYWx1ZSA9IHVuY3VycnlUaGlzKEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YpO1xuXG5pZiAoQmlnSW50U3VwcG9ydGVkKSB7XG4gIHZhciBiaWdJbnRWYWx1ZSA9IHVuY3VycnlUaGlzKEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZik7XG59XG5cbmlmIChTeW1ib2xTdXBwb3J0ZWQpIHtcbiAgdmFyIHN5bWJvbFZhbHVlID0gdW5jdXJyeVRoaXMoU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgcHJvdG90eXBlVmFsdWVPZikge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIHByb3RvdHlwZVZhbHVlT2YodmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0cy5pc0FyZ3VtZW50c09iamVjdCA9IGlzQXJndW1lbnRzT2JqZWN0O1xuZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gaXNHZW5lcmF0b3JGdW5jdGlvbjtcbmV4cG9ydHMuaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuXG4vLyBUYWtlbiBmcm9tIGhlcmUgYW5kIG1vZGlmaWVkIGZvciBiZXR0ZXIgYnJvd3NlciBzdXBwb3J0XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3AtaXMtcHJvbWlzZS9ibG9iL2NkYTM1YTUxM2JkYTAzZjk3N2FkNWNkZTNhMDc5ZDIzN2U4MmQ3ZWYvaW5kZXguanNcbmZ1bmN0aW9uIGlzUHJvbWlzZShpbnB1dCkge1xuXHRyZXR1cm4gKFxuXHRcdChcblx0XHRcdHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJlxuXHRcdFx0aW5wdXQgaW5zdGFuY2VvZiBQcm9taXNlXG5cdFx0KSB8fFxuXHRcdChcblx0XHRcdGlucHV0ICE9PSBudWxsICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdFx0dHlwZW9mIGlucHV0LmNhdGNoID09PSAnZnVuY3Rpb24nXG5cdFx0KVxuXHQpO1xufVxuZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIEFycmF5QnVmZmVyLmlzVmlldykge1xuICAgIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICBpc1R5cGVkQXJyYXkodmFsdWUpIHx8XG4gICAgaXNEYXRhVmlldyh2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNBcnJheUJ1ZmZlclZpZXcgPSBpc0FycmF5QnVmZmVyVmlldztcblxuXG5mdW5jdGlvbiBpc1VpbnQ4QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50OEFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50OEFycmF5ID0gaXNVaW50OEFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQ4Q2xhbXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDhDbGFtcGVkQXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQ4Q2xhbXBlZEFycmF5ID0gaXNVaW50OENsYW1wZWRBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQxNkFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50MTZBcnJheSA9IGlzVWludDE2QXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50MzJBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDMyQXJyYXkgPSBpc1VpbnQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDhBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDhBcnJheSc7XG59XG5leHBvcnRzLmlzSW50OEFycmF5ID0gaXNJbnQ4QXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDE2QXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDE2QXJyYXkgPSBpc0ludDE2QXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDMyQXJyYXkgPSBpc0ludDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzRmxvYXQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnRmxvYXQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNGbG9hdDMyQXJyYXkgPSBpc0Zsb2F0MzJBcnJheTtcblxuZnVuY3Rpb24gaXNGbG9hdDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdGbG9hdDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0Zsb2F0NjRBcnJheSA9IGlzRmxvYXQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc0JpZ0ludDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdCaWdJbnQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNCaWdJbnQ2NEFycmF5ID0gaXNCaWdJbnQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc0JpZ1VpbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnQmlnVWludDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0JpZ1VpbnQ2NEFycmF5ID0gaXNCaWdVaW50NjRBcnJheTtcblxuZnVuY3Rpb24gaXNNYXBUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBNYXBdJztcbn1cbmlzTWFwVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNNYXBUb1N0cmluZyhuZXcgTWFwKCkpXG4pO1xuXG5mdW5jdGlvbiBpc01hcCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNNYXBUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc01hcFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBNYXA7XG59XG5leHBvcnRzLmlzTWFwID0gaXNNYXA7XG5cbmZ1bmN0aW9uIGlzU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2V0XSc7XG59XG5pc1NldFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzU2V0VG9TdHJpbmcobmV3IFNldCgpKVxuKTtcbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc1NldFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzU2V0VG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNldDtcbn1cbmV4cG9ydHMuaXNTZXQgPSBpc1NldDtcblxuZnVuY3Rpb24gaXNXZWFrTWFwVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha01hcF0nO1xufVxuaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzV2Vha01hcFRvU3RyaW5nKG5ldyBXZWFrTWFwKCkpXG4pO1xuZnVuY3Rpb24gaXNXZWFrTWFwKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNXZWFrTWFwVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFdlYWtNYXA7XG59XG5leHBvcnRzLmlzV2Vha01hcCA9IGlzV2Vha01hcDtcblxuZnVuY3Rpb24gaXNXZWFrU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha1NldF0nO1xufVxuaXNXZWFrU2V0VG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFdlYWtTZXQgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzV2Vha1NldFRvU3RyaW5nKG5ldyBXZWFrU2V0KCkpXG4pO1xuZnVuY3Rpb24gaXNXZWFrU2V0KHZhbHVlKSB7XG4gIHJldHVybiBpc1dlYWtTZXRUb1N0cmluZyh2YWx1ZSk7XG59XG5leHBvcnRzLmlzV2Vha1NldCA9IGlzV2Vha1NldDtcblxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG59XG5pc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc0FycmF5QnVmZmVyVG9TdHJpbmcobmV3IEFycmF5QnVmZmVyKCkpXG4pO1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbn1cbmV4cG9ydHMuaXNBcnJheUJ1ZmZlciA9IGlzQXJyYXlCdWZmZXI7XG5cbmZ1bmN0aW9uIGlzRGF0YVZpZXdUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBEYXRhVmlld10nO1xufVxuaXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIERhdGFWaWV3ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc0RhdGFWaWV3VG9TdHJpbmcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSwgMCwgMSkpXG4pO1xuZnVuY3Rpb24gaXNEYXRhVmlldyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0RhdGFWaWV3VG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNEYXRhVmlld1RvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBEYXRhVmlldztcbn1cbmV4cG9ydHMuaXNEYXRhVmlldyA9IGlzRGF0YVZpZXc7XG5cbi8vIFN0b3JlIGEgY29weSBvZiBTaGFyZWRBcnJheUJ1ZmZlciBpbiBjYXNlIGl0J3MgZGVsZXRlZCBlbHNld2hlcmVcbnZhciBTaGFyZWRBcnJheUJ1ZmZlckNvcHkgPSB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnID8gU2hhcmVkQXJyYXlCdWZmZXIgOiB1bmRlZmluZWQ7XG5mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2hhcmVkQXJyYXlCdWZmZXJdJztcbn1cbmZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlckNvcHkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9IGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgU2hhcmVkQXJyYXlCdWZmZXJDb3B5KCkpO1xuICB9XG5cbiAgcmV0dXJuIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyQ29weTtcbn1cbmV4cG9ydHMuaXNTaGFyZWRBcnJheUJ1ZmZlciA9IGlzU2hhcmVkQXJyYXlCdWZmZXI7XG5cbmZ1bmN0aW9uIGlzQXN5bmNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXSc7XG59XG5leHBvcnRzLmlzQXN5bmNGdW5jdGlvbiA9IGlzQXN5bmNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNNYXBJdGVyYXRvcih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBNYXAgSXRlcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNNYXBJdGVyYXRvciA9IGlzTWFwSXRlcmF0b3I7XG5cbmZ1bmN0aW9uIGlzU2V0SXRlcmF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2V0IEl0ZXJhdG9yXSc7XG59XG5leHBvcnRzLmlzU2V0SXRlcmF0b3IgPSBpc1NldEl0ZXJhdG9yO1xuXG5mdW5jdGlvbiBpc0dlbmVyYXRvck9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBHZW5lcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNHZW5lcmF0b3JPYmplY3QgPSBpc0dlbmVyYXRvck9iamVjdDtcblxuZnVuY3Rpb24gaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYkFzc2VtYmx5Lk1vZHVsZV0nO1xufVxuZXhwb3J0cy5pc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUgPSBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGU7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBudW1iZXJWYWx1ZSk7XG59XG5leHBvcnRzLmlzTnVtYmVyT2JqZWN0ID0gaXNOdW1iZXJPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzdHJpbmdWYWx1ZSk7XG59XG5leHBvcnRzLmlzU3RyaW5nT2JqZWN0ID0gaXNTdHJpbmdPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgYm9vbGVhblZhbHVlKTtcbn1cbmV4cG9ydHMuaXNCb29sZWFuT2JqZWN0ID0gaXNCb29sZWFuT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0JpZ0ludE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gQmlnSW50U3VwcG9ydGVkICYmIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIGJpZ0ludFZhbHVlKTtcbn1cbmV4cG9ydHMuaXNCaWdJbnRPYmplY3QgPSBpc0JpZ0ludE9iamVjdDtcblxuZnVuY3Rpb24gaXNTeW1ib2xPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIFN5bWJvbFN1cHBvcnRlZCAmJiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzeW1ib2xWYWx1ZSk7XG59XG5leHBvcnRzLmlzU3ltYm9sT2JqZWN0ID0gaXNTeW1ib2xPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQm94ZWRQcmltaXRpdmUodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICBpc051bWJlck9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc1N0cmluZ09iamVjdCh2YWx1ZSkgfHxcbiAgICBpc0Jvb2xlYW5PYmplY3QodmFsdWUpIHx8XG4gICAgaXNCaWdJbnRPYmplY3QodmFsdWUpIHx8XG4gICAgaXNTeW1ib2xPYmplY3QodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQm94ZWRQcmltaXRpdmUgPSBpc0JveGVkUHJpbWl0aXZlO1xuXG5mdW5jdGlvbiBpc0FueUFycmF5QnVmZmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICAgIGlzQXJyYXlCdWZmZXIodmFsdWUpIHx8XG4gICAgaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNBbnlBcnJheUJ1ZmZlciA9IGlzQW55QXJyYXlCdWZmZXI7XG5cblsnaXNQcm94eScsICdpc0V4dGVybmFsJywgJ2lzTW9kdWxlTmFtZXNwYWNlT2JqZWN0J10uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG1ldGhvZCwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXRob2QgKyAnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdXNlcmxhbmQnKTtcbiAgICB9XG4gIH0pO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDMzMzU6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qIHByb3ZpZGVkIGRlcGVuZGVuY3kgKi8gdmFyIHByb2Nlc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0MDYpO1xuLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgY29uc29sZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzcxNik7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyB8fFxuICBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgZGVzY3JpcHRvcnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc2NyaXB0b3JzW2tleXNbaV1dID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVzY3JpcHRvcnM7XG4gIH07XG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52UmVnZXggPSAvXiQvO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRykge1xuICB2YXIgZGVidWdFbnYgPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHO1xuICBkZWJ1Z0VudiA9IGRlYnVnRW52LnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrPy5dL2csICdcXFxcJCYnKVxuICAgIC5yZXBsYWNlKC9cXCovZywgJy4qJylcbiAgICAucmVwbGFjZSgvLC9nLCAnJHxeJylcbiAgICAudG9VcHBlckNhc2UoKTtcbiAgZGVidWdFbnZSZWdleCA9IG5ldyBSZWdFeHAoJ14nICsgZGVidWdFbnYgKyAnJCcsICdpJyk7XG59XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKGRlYnVnRW52UmVnZXgudGVzdChzZXQpKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnNsaWNlKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmV4cG9ydHMudHlwZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4OTUpO1xuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuZXhwb3J0cy50eXBlcy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcbmV4cG9ydHMudHlwZXMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5leHBvcnRzLnR5cGVzLmlzTmF0aXZlRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Mik7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTI4NSk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG52YXIga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgPyBTeW1ib2woJ3V0aWwucHJvbWlzaWZ5LmN1c3RvbScpIDogdW5kZWZpbmVkO1xuXG5leHBvcnRzLnByb21pc2lmeSA9IGZ1bmN0aW9uIHByb21pc2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCAmJiBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdKSB7XG4gICAgdmFyIGZuID0gb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ1dGlsLnByb21pc2lmeS5jdXN0b21cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgZnVuY3Rpb24gZm4oKSB7XG4gICAgdmFyIHByb21pc2VSZXNvbHZlLCBwcm9taXNlUmVqZWN0O1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgcHJvbWlzZVJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcblxuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cbiAgICBhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgdmFsdWUpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZVJlc29sdmUodmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGZuLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoXG4gICAgZm4sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbClcbiAgKTtcbn1cblxuZXhwb3J0cy5wcm9taXNpZnkuY3VzdG9tID0ga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5T25SZWplY3RlZChyZWFzb24sIGNiKSB7XG4gIC8vIGAhcmVhc29uYCBndWFyZCBpbnNwaXJlZCBieSBibHVlYmlyZCAoUmVmOiBodHRwczovL2dvby5nbC90NUlTNk0pLlxuICAvLyBCZWNhdXNlIGBudWxsYCBpcyBhIHNwZWNpYWwgZXJyb3IgdmFsdWUgaW4gY2FsbGJhY2tzIHdoaWNoIG1lYW5zIFwibm8gZXJyb3JcbiAgLy8gb2NjdXJyZWRcIiwgd2UgZXJyb3Itd3JhcCBzbyB0aGUgY2FsbGJhY2sgY29uc3VtZXIgY2FuIGRpc3Rpbmd1aXNoIGJldHdlZW5cbiAgLy8gXCJ0aGUgcHJvbWlzZSByZWplY3RlZCB3aXRoIG51bGxcIiBvciBcInRoZSBwcm9taXNlIGZ1bGZpbGxlZCB3aXRoIHVuZGVmaW5lZFwiLlxuICBpZiAoIXJlYXNvbikge1xuICAgIHZhciBuZXdSZWFzb24gPSBuZXcgRXJyb3IoJ1Byb21pc2Ugd2FzIHJlamVjdGVkIHdpdGggYSBmYWxzeSB2YWx1ZScpO1xuICAgIG5ld1JlYXNvbi5yZWFzb24gPSByZWFzb247XG4gICAgcmVhc29uID0gbmV3UmVhc29uO1xuICB9XG4gIHJldHVybiBjYihyZWFzb24pO1xufVxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIC8vIFdlIERPIE5PVCByZXR1cm4gdGhlIHByb21pc2UgYXMgaXQgZ2l2ZXMgdGhlIHVzZXIgYSBmYWxzZSBzZW5zZSB0aGF0XG4gIC8vIHRoZSBwcm9taXNlIGlzIGFjdHVhbGx5IHNvbWVob3cgcmVsYXRlZCB0byB0aGUgY2FsbGJhY2sncyBleGVjdXRpb25cbiAgLy8gYW5kIHRoYXQgdGhlIGNhbGxiYWNrIHRocm93aW5nIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlLlxuICBmdW5jdGlvbiBjYWxsYmFja2lmaWVkKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIHZhciBtYXliZUNiID0gYXJncy5wb3AoKTtcbiAgICBpZiAodHlwZW9mIG1heWJlQ2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsYXN0IGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNiID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbWF5YmVDYi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgLy8gSW4gdHJ1ZSBub2RlIHN0eWxlIHdlIHByb2Nlc3MgdGhlIGNhbGxiYWNrIG9uIGBuZXh0VGlja2Agd2l0aCBhbGwgdGhlXG4gICAgLy8gaW1wbGljYXRpb25zIChzdGFjaywgYHVuY2F1Z2h0RXhjZXB0aW9uYCwgYGFzeW5jX2hvb2tzYClcbiAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmV0KSB7IHByb2Nlc3MubmV4dFRpY2soY2IuYmluZChudWxsLCBudWxsLCByZXQpKSB9LFxuICAgICAgICAgICAgZnVuY3Rpb24ocmVqKSB7IHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2tpZnlPblJlamVjdGVkLmJpbmQobnVsbCwgcmVqLCBjYikpIH0pO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNhbGxiYWNraWZpZWQsIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjYWxsYmFja2lmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKSk7XG4gIHJldHVybiBjYWxsYmFja2lmaWVkO1xufVxuZXhwb3J0cy5jYWxsYmFja2lmeSA9IGNhbGxiYWNraWZ5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMjAwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OTUzKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDU5NTM6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uID0gZXhwb3J0cy5Ccm93c2VyTWVzc2FnZVdyaXRlciA9IGV4cG9ydHMuQnJvd3Nlck1lc3NhZ2VSZWFkZXIgPSB2b2lkIDA7XG5jb25zdCByaWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzYzMik7XG4vLyBJbnN0YWxsIHRoZSBicm93c2VyIHJ1bnRpbWUgYWJzdHJhY3QuXG5yaWxfMS5kZWZhdWx0Lmluc3RhbGwoKTtcbmNvbnN0IGFwaV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MjQ3KTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDUyNDcpLCBleHBvcnRzKTtcbmNsYXNzIEJyb3dzZXJNZXNzYWdlUmVhZGVyIGV4dGVuZHMgYXBpXzEuQWJzdHJhY3RNZXNzYWdlUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3J0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX29uRGF0YSA9IG5ldyBhcGlfMS5FbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VMaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fb25EYXRhLmZpcmUoZXZlbnQuZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHBvcnQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXZlbnQpID0+IHRoaXMuZmlyZUVycm9yKGV2ZW50KSk7XG4gICAgICAgIHBvcnQub25tZXNzYWdlID0gdGhpcy5fbWVzc2FnZUxpc3RlbmVyO1xuICAgIH1cbiAgICBsaXN0ZW4oY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uRGF0YS5ldmVudChjYWxsYmFjayk7XG4gICAgfVxufVxuZXhwb3J0cy5Ccm93c2VyTWVzc2FnZVJlYWRlciA9IEJyb3dzZXJNZXNzYWdlUmVhZGVyO1xuY2xhc3MgQnJvd3Nlck1lc3NhZ2VXcml0ZXIgZXh0ZW5kcyBhcGlfMS5BYnN0cmFjdE1lc3NhZ2VXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHBvcnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wb3J0ID0gcG9ydDtcbiAgICAgICAgdGhpcy5lcnJvckNvdW50ID0gMDtcbiAgICAgICAgcG9ydC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIChldmVudCkgPT4gdGhpcy5maXJlRXJyb3IoZXZlbnQpKTtcbiAgICB9XG4gICAgd3JpdGUobXNnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnBvcnQucG9zdE1lc3NhZ2UobXNnKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IsIG1zZyk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUVycm9yKGVycm9yLCBtc2cpIHtcbiAgICAgICAgdGhpcy5lcnJvckNvdW50Kys7XG4gICAgICAgIHRoaXMuZmlyZUVycm9yKGVycm9yLCBtc2csIHRoaXMuZXJyb3JDb3VudCk7XG4gICAgfVxuICAgIGVuZCgpIHtcbiAgICB9XG59XG5leHBvcnRzLkJyb3dzZXJNZXNzYWdlV3JpdGVyID0gQnJvd3Nlck1lc3NhZ2VXcml0ZXI7XG5mdW5jdGlvbiBjcmVhdGVNZXNzYWdlQ29ubmVjdGlvbihyZWFkZXIsIHdyaXRlciwgbG9nZ2VyLCBvcHRpb25zKSB7XG4gICAgaWYgKGxvZ2dlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvZ2dlciA9IGFwaV8xLk51bGxMb2dnZXI7XG4gICAgfVxuICAgIGlmIChhcGlfMS5Db25uZWN0aW9uU3RyYXRlZ3kuaXMob3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsgY29ubmVjdGlvblN0cmF0ZWd5OiBvcHRpb25zIH07XG4gICAgfVxuICAgIHJldHVybiAoMCwgYXBpXzEuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24pKHJlYWRlciwgd3JpdGVyLCBsb2dnZXIsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiA9IGNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNjMyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIHByb3ZpZGVkIGRlcGVuZGVuY3kgKi8gdmFyIGNvbnNvbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3MTYpO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmNvbnN0IGFwaV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MjQ3KTtcbmNsYXNzIE1lc3NhZ2VCdWZmZXIgZXh0ZW5kcyBhcGlfMS5BYnN0cmFjdE1lc3NhZ2VCdWZmZXIge1xuICAgIGNvbnN0cnVjdG9yKGVuY29kaW5nID0gJ3V0Zi04Jykge1xuICAgICAgICBzdXBlcihlbmNvZGluZyk7XG4gICAgICAgIHRoaXMuYXNjaWlEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCdhc2NpaScpO1xuICAgIH1cbiAgICBlbXB0eUJ1ZmZlcigpIHtcbiAgICAgICAgcmV0dXJuIE1lc3NhZ2VCdWZmZXIuZW1wdHlCdWZmZXI7XG4gICAgfVxuICAgIGZyb21TdHJpbmcodmFsdWUsIF9lbmNvZGluZykge1xuICAgICAgICByZXR1cm4gKG5ldyBUZXh0RW5jb2RlcigpKS5lbmNvZGUodmFsdWUpO1xuICAgIH1cbiAgICB0b1N0cmluZyh2YWx1ZSwgZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAnYXNjaWknKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hc2NpaURlY29kZXIuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAobmV3IFRleHREZWNvZGVyKGVuY29kaW5nKSkuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc05hdGl2ZShidWZmZXIsIGxlbmd0aCkge1xuICAgICAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWxsb2NOYXRpdmUobGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIH1cbn1cbk1lc3NhZ2VCdWZmZXIuZW1wdHlCdWZmZXIgPSBuZXcgVWludDhBcnJheSgwKTtcbmNsYXNzIFJlYWRhYmxlU3RyZWFtV3JhcHBlciB7XG4gICAgY29uc3RydWN0b3Ioc29ja2V0KSB7XG4gICAgICAgIHRoaXMuc29ja2V0ID0gc29ja2V0O1xuICAgICAgICB0aGlzLl9vbkRhdGEgPSBuZXcgYXBpXzEuRW1pdHRlcigpO1xuICAgICAgICB0aGlzLl9tZXNzYWdlTGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgYmxvYi5hcnJheUJ1ZmZlcigpLnRoZW4oKGJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRGF0YS5maXJlKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpO1xuICAgICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICgwLCBhcGlfMS5SQUwpKCkuY29uc29sZS5lcnJvcihgQ29udmVydGluZyBibG9iIHRvIGFycmF5IGJ1ZmZlciBmYWlsZWQuYCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuX21lc3NhZ2VMaXN0ZW5lcik7XG4gICAgfVxuICAgIG9uQ2xvc2UobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBhcGlfMS5EaXNwb3NhYmxlLmNyZWF0ZSgoKSA9PiB0aGlzLnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbG9zZScsIGxpc3RlbmVyKSk7XG4gICAgfVxuICAgIG9uRXJyb3IobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBhcGlfMS5EaXNwb3NhYmxlLmNyZWF0ZSgoKSA9PiB0aGlzLnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGxpc3RlbmVyKSk7XG4gICAgfVxuICAgIG9uRW5kKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2VuZCcsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGFwaV8xLkRpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHRoaXMuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZCcsIGxpc3RlbmVyKSk7XG4gICAgfVxuICAgIG9uRGF0YShsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fb25EYXRhLmV2ZW50KGxpc3RlbmVyKTtcbiAgICB9XG59XG5jbGFzcyBXcml0YWJsZVN0cmVhbVdyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKHNvY2tldCkge1xuICAgICAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgICB9XG4gICAgb25DbG9zZShsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGFwaV8xLkRpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHRoaXMuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgb25FcnJvcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGFwaV8xLkRpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHRoaXMuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgb25FbmQobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZW5kJywgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gYXBpXzEuRGlzcG9zYWJsZS5jcmVhdGUoKCkgPT4gdGhpcy5zb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgd3JpdGUoZGF0YSwgZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgZW5jb2RpbmcgIT09ICd1dGYtOCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluIGEgQnJvd3NlciBlbnZpcm9ubWVudHMgb25seSB1dGYtOCB0ZXh0IGVuY29kaW5nIGlzIHN1cHBvcnRlZC4gQnV0IGdvdCBlbmNvZGluZzogJHtlbmNvZGluZ31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5zZW5kKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZW5kKCkge1xuICAgICAgICB0aGlzLnNvY2tldC5jbG9zZSgpO1xuICAgIH1cbn1cbmNvbnN0IF90ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgX3JpbCA9IE9iamVjdC5mcmVlemUoe1xuICAgIG1lc3NhZ2VCdWZmZXI6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBjcmVhdGU6IChlbmNvZGluZykgPT4gbmV3IE1lc3NhZ2VCdWZmZXIoZW5jb2RpbmcpXG4gICAgfSksXG4gICAgYXBwbGljYXRpb25Kc29uOiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgZW5jb2RlcjogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICBuYW1lOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICBlbmNvZGU6IChtc2csIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jaGFyc2V0ICE9PSAndXRmLTgnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW4gYSBCcm93c2VyIGVudmlyb25tZW50cyBvbmx5IHV0Zi04IHRleHQgZW5jb2RpbmcgaXMgc3VwcG9ydGVkLiBCdXQgZ290IGVuY29kaW5nOiAke29wdGlvbnMuY2hhcnNldH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShfdGV4dEVuY29kZXIuZW5jb2RlKEpTT04uc3RyaW5naWZ5KG1zZywgdW5kZWZpbmVkLCAwKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgZGVjb2RlcjogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICBuYW1lOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICBkZWNvZGU6IChidWZmZXIsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIShidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluIGEgQnJvd3NlciBlbnZpcm9ubWVudHMgb25seSBVaW50OEFycmF5cyBhcmUgc3VwcG9ydGVkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKEpTT04ucGFyc2UobmV3IFRleHREZWNvZGVyKG9wdGlvbnMuY2hhcnNldCkuZGVjb2RlKGJ1ZmZlcikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9KSxcbiAgICBzdHJlYW06IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBhc1JlYWRhYmxlU3RyZWFtOiAoc29ja2V0KSA9PiBuZXcgUmVhZGFibGVTdHJlYW1XcmFwcGVyKHNvY2tldCksXG4gICAgICAgIGFzV3JpdGFibGVTdHJlYW06IChzb2NrZXQpID0+IG5ldyBXcml0YWJsZVN0cmVhbVdyYXBwZXIoc29ja2V0KVxuICAgIH0pLFxuICAgIGNvbnNvbGU6IGNvbnNvbGUsXG4gICAgdGltZXI6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCBtcywgLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dChjYWxsYmFjaywgbXMsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZGlzcG9zZTogKCkgPT4gY2xlYXJUaW1lb3V0KGhhbmRsZSkgfTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KGNhbGxiYWNrLCAwLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB7IGRpc3Bvc2U6ICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpIH07XG4gICAgICAgIH0sXG4gICAgICAgIHNldEludGVydmFsKGNhbGxiYWNrLCBtcywgLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0SW50ZXJ2YWwoY2FsbGJhY2ssIG1zLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB7IGRpc3Bvc2U6ICgpID0+IGNsZWFySW50ZXJ2YWwoaGFuZGxlKSB9O1xuICAgICAgICB9LFxuICAgIH0pXG59KTtcbmZ1bmN0aW9uIFJJTCgpIHtcbiAgICByZXR1cm4gX3JpbDtcbn1cbihmdW5jdGlvbiAoUklMKSB7XG4gICAgZnVuY3Rpb24gaW5zdGFsbCgpIHtcbiAgICAgICAgYXBpXzEuUkFMLmluc3RhbGwoX3JpbCk7XG4gICAgfVxuICAgIFJJTC5pbnN0YWxsID0gaW5zdGFsbDtcbn0pKFJJTCB8fCAoUklMID0ge30pKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUklMO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MjQ3OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uL3R5cGluZ3MvdGhlbmFibGUuZC50c1wiIC8+XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuUHJvZ3Jlc3NUeXBlID0gZXhwb3J0cy5Qcm9ncmVzc1Rva2VuID0gZXhwb3J0cy5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiA9IGV4cG9ydHMuTnVsbExvZ2dlciA9IGV4cG9ydHMuQ29ubmVjdGlvbk9wdGlvbnMgPSBleHBvcnRzLkNvbm5lY3Rpb25TdHJhdGVneSA9IGV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlQnVmZmVyID0gZXhwb3J0cy5Xcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyID0gZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLk1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLlJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlciA9IGV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5NZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5TaGFyZWRBcnJheVJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLlNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblRva2VuID0gZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSA9IGV4cG9ydHMuRW1pdHRlciA9IGV4cG9ydHMuRXZlbnQgPSBleHBvcnRzLkRpc3Bvc2FibGUgPSBleHBvcnRzLkxSVUNhY2hlID0gZXhwb3J0cy5Ub3VjaCA9IGV4cG9ydHMuTGlua2VkTWFwID0gZXhwb3J0cy5QYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlOSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTggPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU3ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNiA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTUgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU0ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMyA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTIgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUxID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMCA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZSA9IGV4cG9ydHMuRXJyb3JDb2RlcyA9IGV4cG9ydHMuUmVzcG9uc2VFcnJvciA9IGV4cG9ydHMuUmVxdWVzdFR5cGU5ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTggPSBleHBvcnRzLlJlcXVlc3RUeXBlNyA9IGV4cG9ydHMuUmVxdWVzdFR5cGU2ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTUgPSBleHBvcnRzLlJlcXVlc3RUeXBlNCA9IGV4cG9ydHMuUmVxdWVzdFR5cGUzID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTIgPSBleHBvcnRzLlJlcXVlc3RUeXBlMSA9IGV4cG9ydHMuUmVxdWVzdFR5cGUwID0gZXhwb3J0cy5SZXF1ZXN0VHlwZSA9IGV4cG9ydHMuTWVzc2FnZSA9IGV4cG9ydHMuUkFMID0gdm9pZCAwO1xuZXhwb3J0cy5NZXNzYWdlU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSA9IGV4cG9ydHMuQ29ubmVjdGlvbkVycm9yID0gZXhwb3J0cy5Db25uZWN0aW9uRXJyb3JzID0gZXhwb3J0cy5Mb2dUcmFjZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuU2V0VHJhY2VOb3RpZmljYXRpb24gPSBleHBvcnRzLlRyYWNlRm9ybWF0ID0gZXhwb3J0cy5UcmFjZVZhbHVlcyA9IGV4cG9ydHMuVHJhY2UgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MTQxKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lc3NhZ2VcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk1lc3NhZ2U7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLlJlcXVlc3RUeXBlOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlMFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGUwOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlMVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGUxOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlMlwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGUyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlM1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGUzOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlNFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlNVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU1OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlNlwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU2OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlN1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU3OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlOFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU4OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlOVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlc3BvbnNlRXJyb3JcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3I7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXJyb3JDb2Rlc1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuRXJyb3JDb2RlczsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGUwXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlMDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlMVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTE7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGUzXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlMzsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlNFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU1OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGU2XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlNjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlN1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTc7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZThcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU4OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGU5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlOTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQYXJhbWV0ZXJTdHJ1Y3R1cmVzXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzOyB9IH0pKTtcbmNvbnN0IGxpbmtlZE1hcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MDQwKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxpbmtlZE1hcFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpbmtlZE1hcF8xLkxpbmtlZE1hcDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMUlVDYWNoZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpbmtlZE1hcF8xLkxSVUNhY2hlOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRvdWNoXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGlua2VkTWFwXzEuVG91Y2g7IH0gfSkpO1xuY29uc3QgZGlzcG9zYWJsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDM3KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpc3Bvc2FibGVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkaXNwb3NhYmxlXzEuRGlzcG9zYWJsZTsgfSB9KSk7XG5jb25zdCBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTE2NSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdmVudFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV2ZW50c18xLkV2ZW50OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVtaXR0ZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldmVudHNfMS5FbWl0dGVyOyB9IH0pKTtcbmNvbnN0IGNhbmNlbGxhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MTUpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2VcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYW5jZWxsYXRpb25fMS5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYW5jZWxsYXRpb25Ub2tlblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbmNlbGxhdGlvbl8xLkNhbmNlbGxhdGlvblRva2VuOyB9IH0pKTtcbmNvbnN0IHNoYXJlZEFycmF5Q2FuY2VsbGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3OCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTaGFyZWRBcnJheVNlbmRlclN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhcmVkQXJyYXlDYW5jZWxsYXRpb25fMS5TaGFyZWRBcnJheVNlbmRlclN0cmF0ZWd5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNoYXJlZEFycmF5UmVjZWl2ZXJTdHJhdGVneVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNoYXJlZEFycmF5Q2FuY2VsbGF0aW9uXzEuU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5OyB9IH0pKTtcbmNvbnN0IG1lc3NhZ2VSZWFkZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDUxKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lc3NhZ2VSZWFkZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlUmVhZGVyXzEuTWVzc2FnZVJlYWRlcjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBYnN0cmFjdE1lc3NhZ2VSZWFkZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlUmVhZGVyXzEuQWJzdHJhY3RNZXNzYWdlUmVhZGVyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VSZWFkZXJfMS5SZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXI7IH0gfSkpO1xuY29uc3QgbWVzc2FnZVdyaXRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjUxKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lc3NhZ2VXcml0ZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlV3JpdGVyXzEuTWVzc2FnZVdyaXRlcjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBYnN0cmFjdE1lc3NhZ2VXcml0ZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlV3JpdGVyXzEuQWJzdHJhY3RNZXNzYWdlV3JpdGVyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldyaXRlYWJsZVN0cmVhbU1lc3NhZ2VXcml0ZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlV3JpdGVyXzEuV3JpdGVhYmxlU3RyZWFtTWVzc2FnZVdyaXRlcjsgfSB9KSk7XG5jb25zdCBtZXNzYWdlQnVmZmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg2NTIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWJzdHJhY3RNZXNzYWdlQnVmZmVyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZUJ1ZmZlcl8xLkFic3RyYWN0TWVzc2FnZUJ1ZmZlcjsgfSB9KSk7XG5jb25zdCBjb25uZWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5MDgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29ubmVjdGlvblN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNvbm5lY3Rpb25TdHJhdGVneTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb25uZWN0aW9uT3B0aW9uc1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Db25uZWN0aW9uT3B0aW9uczsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOdWxsTG9nZ2VyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLk51bGxMb2dnZXI7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb247IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUHJvZ3Jlc3NUb2tlblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Qcm9ncmVzc1Rva2VuOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlByb2dyZXNzVHlwZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Qcm9ncmVzc1R5cGU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhY2VcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuVHJhY2U7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhY2VWYWx1ZXNcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuVHJhY2VWYWx1ZXM7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhY2VGb3JtYXRcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuVHJhY2VGb3JtYXQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2V0VHJhY2VOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuU2V0VHJhY2VOb3RpZmljYXRpb247IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTG9nVHJhY2VOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuTG9nVHJhY2VOb3RpZmljYXRpb247IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29ubmVjdGlvbkVycm9yc1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Db25uZWN0aW9uRXJyb3JzOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbm5lY3Rpb25FcnJvclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Db25uZWN0aW9uRXJyb3I7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5DYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbmNlbGxhdGlvblN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNhbmNlbGxhdGlvblN0cmF0ZWd5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lc3NhZ2VTdHJhdGVneVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5NZXNzYWdlU3RyYXRlZ3k7IH0gfSkpO1xuY29uc3QgcmFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3MDYpO1xuZXhwb3J0cy5SQUwgPSByYWxfMS5kZWZhdWx0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MTU6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW4gPSB2b2lkIDA7XG5jb25zdCByYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTcwNik7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oODgxMSk7XG5jb25zdCBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTE2NSk7XG52YXIgQ2FuY2VsbGF0aW9uVG9rZW47XG4oZnVuY3Rpb24gKENhbmNlbGxhdGlvblRva2VuKSB7XG4gICAgQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBpc0NhbmNlbGxhdGlvblJlcXVlc3RlZDogZmFsc2UsXG4gICAgICAgIG9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkOiBldmVudHNfMS5FdmVudC5Ob25lXG4gICAgfSk7XG4gICAgQ2FuY2VsbGF0aW9uVG9rZW4uQ2FuY2VsbGVkID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIGlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkOiB0cnVlLFxuICAgICAgICBvbkNhbmNlbGxhdGlvblJlcXVlc3RlZDogZXZlbnRzXzEuRXZlbnQuTm9uZVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIChjYW5kaWRhdGUgPT09IENhbmNlbGxhdGlvblRva2VuLk5vbmVcbiAgICAgICAgICAgIHx8IGNhbmRpZGF0ZSA9PT0gQ2FuY2VsbGF0aW9uVG9rZW4uQ2FuY2VsbGVkXG4gICAgICAgICAgICB8fCAoSXMuYm9vbGVhbihjYW5kaWRhdGUuaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQpICYmICEhY2FuZGlkYXRlLm9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKSk7XG4gICAgfVxuICAgIENhbmNlbGxhdGlvblRva2VuLmlzID0gaXM7XG59KShDYW5jZWxsYXRpb25Ub2tlbiA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW4gfHwgKGV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW4gPSB7fSkpO1xuY29uc3Qgc2hvcnRjdXRFdmVudCA9IE9iamVjdC5mcmVlemUoZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgY29uc3QgaGFuZGxlID0gKDAsIHJhbF8xLmRlZmF1bHQpKCkudGltZXIuc2V0VGltZW91dChjYWxsYmFjay5iaW5kKGNvbnRleHQpLCAwKTtcbiAgICByZXR1cm4geyBkaXNwb3NlKCkgeyBoYW5kbGUuZGlzcG9zZSgpOyB9IH07XG59KTtcbmNsYXNzIE11dGFibGVUb2tlbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0NhbmNlbGxlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0NhbmNlbGxlZDtcbiAgICB9XG4gICAgZ2V0IG9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCkge1xuICAgICAgICBpZiAodGhpcy5faXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzaG9ydGN1dEV2ZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZW1pdHRlcikge1xuICAgICAgICAgICAgdGhpcy5fZW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9lbWl0dGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2VtaXR0ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSB7XG4gICAgZ2V0IHRva2VuKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Rva2VuKSB7XG4gICAgICAgICAgICAvLyBiZSBsYXp5IGFuZCBjcmVhdGUgdGhlIHRva2VuIG9ubHkgd2hlblxuICAgICAgICAgICAgLy8gYWN0dWFsbHkgbmVlZGVkXG4gICAgICAgICAgICB0aGlzLl90b2tlbiA9IG5ldyBNdXRhYmxlVG9rZW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW47XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90b2tlbikge1xuICAgICAgICAgICAgLy8gc2F2ZSBhbiBvYmplY3QgYnkgcmV0dXJuaW5nIHRoZSBkZWZhdWx0XG4gICAgICAgICAgICAvLyBjYW5jZWxsZWQgdG9rZW4gd2hlbiBjYW5jZWxsYXRpb24gaGFwcGVuc1xuICAgICAgICAgICAgLy8gYmVmb3JlIHNvbWVvbmUgYXNrcyBmb3IgdGhlIHRva2VuXG4gICAgICAgICAgICB0aGlzLl90b2tlbiA9IENhbmNlbGxhdGlvblRva2VuLkNhbmNlbGxlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdG9rZW4pIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSB0byBpbml0aWFsaXplIHdpdGggYW4gZW1wdHkgdG9rZW4gaWYgd2UgaGFkIG5vbmVcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl90b2tlbiBpbnN0YW5jZW9mIE11dGFibGVUb2tlbikge1xuICAgICAgICAgICAgLy8gYWN0dWFsbHkgZGlzcG9zZVxuICAgICAgICAgICAgdGhpcy5fdG9rZW4uZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSA9IENhbmNlbGxhdGlvblRva2VuU291cmNlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxOTA4OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uID0gZXhwb3J0cy5Db25uZWN0aW9uT3B0aW9ucyA9IGV4cG9ydHMuTWVzc2FnZVN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25TdHJhdGVneSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLlJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0gZXhwb3J0cy5JZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLkNvbm5lY3Rpb25TdHJhdGVneSA9IGV4cG9ydHMuQ29ubmVjdGlvbkVycm9yID0gZXhwb3J0cy5Db25uZWN0aW9uRXJyb3JzID0gZXhwb3J0cy5Mb2dUcmFjZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuU2V0VHJhY2VOb3RpZmljYXRpb24gPSBleHBvcnRzLlRyYWNlRm9ybWF0ID0gZXhwb3J0cy5UcmFjZVZhbHVlcyA9IGV4cG9ydHMuVHJhY2UgPSBleHBvcnRzLk51bGxMb2dnZXIgPSBleHBvcnRzLlByb2dyZXNzVHlwZSA9IGV4cG9ydHMuUHJvZ3Jlc3NUb2tlbiA9IHZvaWQgMDtcbmNvbnN0IHJhbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NzA2KTtcbmNvbnN0IElzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4ODExKTtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxNDEpO1xuY29uc3QgbGlua2VkTWFwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwNDApO1xuY29uc3QgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxNjUpO1xuY29uc3QgY2FuY2VsbGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxNSk7XG52YXIgQ2FuY2VsTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChDYW5jZWxOb3RpZmljYXRpb24pIHtcbiAgICBDYW5jZWxOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUoJyQvY2FuY2VsUmVxdWVzdCcpO1xufSkoQ2FuY2VsTm90aWZpY2F0aW9uIHx8IChDYW5jZWxOb3RpZmljYXRpb24gPSB7fSkpO1xudmFyIFByb2dyZXNzVG9rZW47XG4oZnVuY3Rpb24gKFByb2dyZXNzVG9rZW4pIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xuICAgIH1cbiAgICBQcm9ncmVzc1Rva2VuLmlzID0gaXM7XG59KShQcm9ncmVzc1Rva2VuID0gZXhwb3J0cy5Qcm9ncmVzc1Rva2VuIHx8IChleHBvcnRzLlByb2dyZXNzVG9rZW4gPSB7fSkpO1xudmFyIFByb2dyZXNzTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChQcm9ncmVzc05vdGlmaWNhdGlvbikge1xuICAgIFByb2dyZXNzTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlKCckL3Byb2dyZXNzJyk7XG59KShQcm9ncmVzc05vdGlmaWNhdGlvbiB8fCAoUHJvZ3Jlc3NOb3RpZmljYXRpb24gPSB7fSkpO1xuY2xhc3MgUHJvZ3Jlc3NUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICB9XG59XG5leHBvcnRzLlByb2dyZXNzVHlwZSA9IFByb2dyZXNzVHlwZTtcbnZhciBTdGFyUmVxdWVzdEhhbmRsZXI7XG4oZnVuY3Rpb24gKFN0YXJSZXF1ZXN0SGFuZGxlcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBJcy5mdW5jKHZhbHVlKTtcbiAgICB9XG4gICAgU3RhclJlcXVlc3RIYW5kbGVyLmlzID0gaXM7XG59KShTdGFyUmVxdWVzdEhhbmRsZXIgfHwgKFN0YXJSZXF1ZXN0SGFuZGxlciA9IHt9KSk7XG5leHBvcnRzLk51bGxMb2dnZXIgPSBPYmplY3QuZnJlZXplKHtcbiAgICBlcnJvcjogKCkgPT4geyB9LFxuICAgIHdhcm46ICgpID0+IHsgfSxcbiAgICBpbmZvOiAoKSA9PiB7IH0sXG4gICAgbG9nOiAoKSA9PiB7IH1cbn0pO1xudmFyIFRyYWNlO1xuKGZ1bmN0aW9uIChUcmFjZSkge1xuICAgIFRyYWNlW1RyYWNlW1wiT2ZmXCJdID0gMF0gPSBcIk9mZlwiO1xuICAgIFRyYWNlW1RyYWNlW1wiTWVzc2FnZXNcIl0gPSAxXSA9IFwiTWVzc2FnZXNcIjtcbiAgICBUcmFjZVtUcmFjZVtcIkNvbXBhY3RcIl0gPSAyXSA9IFwiQ29tcGFjdFwiO1xuICAgIFRyYWNlW1RyYWNlW1wiVmVyYm9zZVwiXSA9IDNdID0gXCJWZXJib3NlXCI7XG59KShUcmFjZSA9IGV4cG9ydHMuVHJhY2UgfHwgKGV4cG9ydHMuVHJhY2UgPSB7fSkpO1xudmFyIFRyYWNlVmFsdWVzO1xuKGZ1bmN0aW9uIChUcmFjZVZhbHVlcykge1xuICAgIC8qKlxuICAgICAqIFR1cm4gdHJhY2luZyBvZmYuXG4gICAgICovXG4gICAgVHJhY2VWYWx1ZXMuT2ZmID0gJ29mZic7XG4gICAgLyoqXG4gICAgICogVHJhY2UgbWVzc2FnZXMgb25seS5cbiAgICAgKi9cbiAgICBUcmFjZVZhbHVlcy5NZXNzYWdlcyA9ICdtZXNzYWdlcyc7XG4gICAgLyoqXG4gICAgICogQ29tcGFjdCBtZXNzYWdlIHRyYWNpbmcuXG4gICAgICovXG4gICAgVHJhY2VWYWx1ZXMuQ29tcGFjdCA9ICdjb21wYWN0JztcbiAgICAvKipcbiAgICAgKiBWZXJib3NlIG1lc3NhZ2UgdHJhY2luZy5cbiAgICAgKi9cbiAgICBUcmFjZVZhbHVlcy5WZXJib3NlID0gJ3ZlcmJvc2UnO1xufSkoVHJhY2VWYWx1ZXMgPSBleHBvcnRzLlRyYWNlVmFsdWVzIHx8IChleHBvcnRzLlRyYWNlVmFsdWVzID0ge30pKTtcbihmdW5jdGlvbiAoVHJhY2UpIHtcbiAgICBmdW5jdGlvbiBmcm9tU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGlmICghSXMuc3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFRyYWNlLk9mZjtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ29mZic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYWNlLk9mZjtcbiAgICAgICAgICAgIGNhc2UgJ21lc3NhZ2VzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhY2UuTWVzc2FnZXM7XG4gICAgICAgICAgICBjYXNlICdjb21wYWN0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhY2UuQ29tcGFjdDtcbiAgICAgICAgICAgIGNhc2UgJ3ZlcmJvc2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBUcmFjZS5WZXJib3NlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhY2UuT2ZmO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRyYWNlLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgVHJhY2UuT2ZmOlxuICAgICAgICAgICAgICAgIHJldHVybiAnb2ZmJztcbiAgICAgICAgICAgIGNhc2UgVHJhY2UuTWVzc2FnZXM6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdtZXNzYWdlcyc7XG4gICAgICAgICAgICBjYXNlIFRyYWNlLkNvbXBhY3Q6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdjb21wYWN0JztcbiAgICAgICAgICAgIGNhc2UgVHJhY2UuVmVyYm9zZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3ZlcmJvc2UnO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ29mZic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVHJhY2UudG9TdHJpbmcgPSB0b1N0cmluZztcbn0pKFRyYWNlID0gZXhwb3J0cy5UcmFjZSB8fCAoZXhwb3J0cy5UcmFjZSA9IHt9KSk7XG52YXIgVHJhY2VGb3JtYXQ7XG4oZnVuY3Rpb24gKFRyYWNlRm9ybWF0KSB7XG4gICAgVHJhY2VGb3JtYXRbXCJUZXh0XCJdID0gXCJ0ZXh0XCI7XG4gICAgVHJhY2VGb3JtYXRbXCJKU09OXCJdID0gXCJqc29uXCI7XG59KShUcmFjZUZvcm1hdCA9IGV4cG9ydHMuVHJhY2VGb3JtYXQgfHwgKGV4cG9ydHMuVHJhY2VGb3JtYXQgPSB7fSkpO1xuKGZ1bmN0aW9uIChUcmFjZUZvcm1hdCkge1xuICAgIGZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgaWYgKCFJcy5zdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gVHJhY2VGb3JtYXQuVGV4dDtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJ2pzb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gVHJhY2VGb3JtYXQuSlNPTjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBUcmFjZUZvcm1hdC5UZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIFRyYWNlRm9ybWF0LmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xufSkoVHJhY2VGb3JtYXQgPSBleHBvcnRzLlRyYWNlRm9ybWF0IHx8IChleHBvcnRzLlRyYWNlRm9ybWF0ID0ge30pKTtcbnZhciBTZXRUcmFjZU5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoU2V0VHJhY2VOb3RpZmljYXRpb24pIHtcbiAgICBTZXRUcmFjZU5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZSgnJC9zZXRUcmFjZScpO1xufSkoU2V0VHJhY2VOb3RpZmljYXRpb24gPSBleHBvcnRzLlNldFRyYWNlTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLlNldFRyYWNlTm90aWZpY2F0aW9uID0ge30pKTtcbnZhciBMb2dUcmFjZU5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoTG9nVHJhY2VOb3RpZmljYXRpb24pIHtcbiAgICBMb2dUcmFjZU5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZSgnJC9sb2dUcmFjZScpO1xufSkoTG9nVHJhY2VOb3RpZmljYXRpb24gPSBleHBvcnRzLkxvZ1RyYWNlTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkxvZ1RyYWNlTm90aWZpY2F0aW9uID0ge30pKTtcbnZhciBDb25uZWN0aW9uRXJyb3JzO1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uRXJyb3JzKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbm5lY3Rpb24gaXMgY2xvc2VkLlxuICAgICAqL1xuICAgIENvbm5lY3Rpb25FcnJvcnNbQ29ubmVjdGlvbkVycm9yc1tcIkNsb3NlZFwiXSA9IDFdID0gXCJDbG9zZWRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgY29ubmVjdGlvbiBnb3QgZGlzcG9zZWQuXG4gICAgICovXG4gICAgQ29ubmVjdGlvbkVycm9yc1tDb25uZWN0aW9uRXJyb3JzW1wiRGlzcG9zZWRcIl0gPSAyXSA9IFwiRGlzcG9zZWRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgY29ubmVjdGlvbiBpcyBhbHJlYWR5IGluIGxpc3RlbmluZyBtb2RlLlxuICAgICAqL1xuICAgIENvbm5lY3Rpb25FcnJvcnNbQ29ubmVjdGlvbkVycm9yc1tcIkFscmVhZHlMaXN0ZW5pbmdcIl0gPSAzXSA9IFwiQWxyZWFkeUxpc3RlbmluZ1wiO1xufSkoQ29ubmVjdGlvbkVycm9ycyA9IGV4cG9ydHMuQ29ubmVjdGlvbkVycm9ycyB8fCAoZXhwb3J0cy5Db25uZWN0aW9uRXJyb3JzID0ge30pKTtcbmNsYXNzIENvbm5lY3Rpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQ29ubmVjdGlvbkVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Db25uZWN0aW9uRXJyb3IgPSBDb25uZWN0aW9uRXJyb3I7XG52YXIgQ29ubmVjdGlvblN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uU3RyYXRlZ3kpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5jYW5jZWxVbmRpc3BhdGNoZWQpO1xuICAgIH1cbiAgICBDb25uZWN0aW9uU3RyYXRlZ3kuaXMgPSBpcztcbn0pKENvbm5lY3Rpb25TdHJhdGVneSA9IGV4cG9ydHMuQ29ubmVjdGlvblN0cmF0ZWd5IHx8IChleHBvcnRzLkNvbm5lY3Rpb25TdHJhdGVneSA9IHt9KSk7XG52YXIgSWRDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChJZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiAoY2FuZGlkYXRlLmtpbmQgPT09IHVuZGVmaW5lZCB8fCBjYW5kaWRhdGUua2luZCA9PT0gJ2lkJykgJiYgSXMuZnVuYyhjYW5kaWRhdGUuY3JlYXRlQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UpICYmIChjYW5kaWRhdGUuZGlzcG9zZSA9PT0gdW5kZWZpbmVkIHx8IElzLmZ1bmMoY2FuZGlkYXRlLmRpc3Bvc2UpKTtcbiAgICB9XG4gICAgSWRDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5LmlzID0gaXM7XG59KShJZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLklkQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSB8fCAoZXhwb3J0cy5JZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSB7fSkpO1xudmFyIFJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChSZXF1ZXN0Q2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSkge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGNhbmRpZGF0ZS5raW5kID09PSAncmVxdWVzdCcgJiYgSXMuZnVuYyhjYW5kaWRhdGUuY3JlYXRlQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UpICYmIChjYW5kaWRhdGUuZGlzcG9zZSA9PT0gdW5kZWZpbmVkIHx8IElzLmZ1bmMoY2FuZGlkYXRlLmRpc3Bvc2UpKTtcbiAgICB9XG4gICAgUmVxdWVzdENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuaXMgPSBpcztcbn0pKFJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0gZXhwb3J0cy5SZXF1ZXN0Q2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSB8fCAoZXhwb3J0cy5SZXF1ZXN0Q2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSA9IHt9KSk7XG52YXIgQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneTtcbihmdW5jdGlvbiAoQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSkge1xuICAgIENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuTWVzc2FnZSA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBjcmVhdGVDYW5jZWxsYXRpb25Ub2tlblNvdXJjZShfKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGNhbmNlbGxhdGlvbl8xLkNhbmNlbGxhdGlvblRva2VuU291cmNlKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gSWRDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5LmlzKHZhbHVlKSB8fCBSZXF1ZXN0Q2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneS5pcyh2YWx1ZSk7XG4gICAgfVxuICAgIENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuaXMgPSBpcztcbn0pKENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgfHwgKGV4cG9ydHMuQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSA9IHt9KSk7XG52YXIgQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3k7XG4oZnVuY3Rpb24gKENhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5KSB7XG4gICAgQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kuTWVzc2FnZSA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBzZW5kQ2FuY2VsbGF0aW9uKGNvbm4sIGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gY29ubi5zZW5kTm90aWZpY2F0aW9uKENhbmNlbE5vdGlmaWNhdGlvbi50eXBlLCB7IGlkIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhbnVwKF8pIHsgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLmZ1bmMoY2FuZGlkYXRlLnNlbmRDYW5jZWxsYXRpb24pICYmIElzLmZ1bmMoY2FuZGlkYXRlLmNsZWFudXApO1xuICAgIH1cbiAgICBDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneS5pcyA9IGlzO1xufSkoQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5IHx8IChleHBvcnRzLkNhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5ID0ge30pKTtcbnZhciBDYW5jZWxsYXRpb25TdHJhdGVneTtcbihmdW5jdGlvbiAoQ2FuY2VsbGF0aW9uU3RyYXRlZ3kpIHtcbiAgICBDYW5jZWxsYXRpb25TdHJhdGVneS5NZXNzYWdlID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIHJlY2VpdmVyOiBDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5Lk1lc3NhZ2UsXG4gICAgICAgIHNlbmRlcjogQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kuTWVzc2FnZVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuaXMoY2FuZGlkYXRlLnJlY2VpdmVyKSAmJiBDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneS5pcyhjYW5kaWRhdGUuc2VuZGVyKTtcbiAgICB9XG4gICAgQ2FuY2VsbGF0aW9uU3RyYXRlZ3kuaXMgPSBpcztcbn0pKENhbmNlbGxhdGlvblN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25TdHJhdGVneSB8fCAoZXhwb3J0cy5DYW5jZWxsYXRpb25TdHJhdGVneSA9IHt9KSk7XG52YXIgTWVzc2FnZVN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChNZXNzYWdlU3RyYXRlZ3kpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5oYW5kbGVNZXNzYWdlKTtcbiAgICB9XG4gICAgTWVzc2FnZVN0cmF0ZWd5LmlzID0gaXM7XG59KShNZXNzYWdlU3RyYXRlZ3kgPSBleHBvcnRzLk1lc3NhZ2VTdHJhdGVneSB8fCAoZXhwb3J0cy5NZXNzYWdlU3RyYXRlZ3kgPSB7fSkpO1xudmFyIENvbm5lY3Rpb25PcHRpb25zO1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIChDYW5jZWxsYXRpb25TdHJhdGVneS5pcyhjYW5kaWRhdGUuY2FuY2VsbGF0aW9uU3RyYXRlZ3kpIHx8IENvbm5lY3Rpb25TdHJhdGVneS5pcyhjYW5kaWRhdGUuY29ubmVjdGlvblN0cmF0ZWd5KSB8fCBNZXNzYWdlU3RyYXRlZ3kuaXMoY2FuZGlkYXRlLm1lc3NhZ2VTdHJhdGVneSkpO1xuICAgIH1cbiAgICBDb25uZWN0aW9uT3B0aW9ucy5pcyA9IGlzO1xufSkoQ29ubmVjdGlvbk9wdGlvbnMgPSBleHBvcnRzLkNvbm5lY3Rpb25PcHRpb25zIHx8IChleHBvcnRzLkNvbm5lY3Rpb25PcHRpb25zID0ge30pKTtcbnZhciBDb25uZWN0aW9uU3RhdGU7XG4oZnVuY3Rpb24gKENvbm5lY3Rpb25TdGF0ZSkge1xuICAgIENvbm5lY3Rpb25TdGF0ZVtDb25uZWN0aW9uU3RhdGVbXCJOZXdcIl0gPSAxXSA9IFwiTmV3XCI7XG4gICAgQ29ubmVjdGlvblN0YXRlW0Nvbm5lY3Rpb25TdGF0ZVtcIkxpc3RlbmluZ1wiXSA9IDJdID0gXCJMaXN0ZW5pbmdcIjtcbiAgICBDb25uZWN0aW9uU3RhdGVbQ29ubmVjdGlvblN0YXRlW1wiQ2xvc2VkXCJdID0gM10gPSBcIkNsb3NlZFwiO1xuICAgIENvbm5lY3Rpb25TdGF0ZVtDb25uZWN0aW9uU3RhdGVbXCJEaXNwb3NlZFwiXSA9IDRdID0gXCJEaXNwb3NlZFwiO1xufSkoQ29ubmVjdGlvblN0YXRlIHx8IChDb25uZWN0aW9uU3RhdGUgPSB7fSkpO1xuZnVuY3Rpb24gY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24obWVzc2FnZVJlYWRlciwgbWVzc2FnZVdyaXRlciwgX2xvZ2dlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGxvZ2dlciA9IF9sb2dnZXIgIT09IHVuZGVmaW5lZCA/IF9sb2dnZXIgOiBleHBvcnRzLk51bGxMb2dnZXI7XG4gICAgbGV0IHNlcXVlbmNlTnVtYmVyID0gMDtcbiAgICBsZXQgbm90aWZpY2F0aW9uU2VxdWVuY2VOdW1iZXIgPSAwO1xuICAgIGxldCB1bmtub3duUmVzcG9uc2VTZXF1ZW5jZU51bWJlciA9IDA7XG4gICAgY29uc3QgdmVyc2lvbiA9ICcyLjAnO1xuICAgIGxldCBzdGFyUmVxdWVzdEhhbmRsZXIgPSB1bmRlZmluZWQ7XG4gICAgY29uc3QgcmVxdWVzdEhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgIGxldCBzdGFyTm90aWZpY2F0aW9uSGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBub3RpZmljYXRpb25IYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBwcm9ncmVzc0hhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgIGxldCB0aW1lcjtcbiAgICBsZXQgbWVzc2FnZVF1ZXVlID0gbmV3IGxpbmtlZE1hcF8xLkxpbmtlZE1hcCgpO1xuICAgIGxldCByZXNwb25zZVByb21pc2VzID0gbmV3IE1hcCgpO1xuICAgIGxldCBrbm93bkNhbmNlbGVkUmVxdWVzdHMgPSBuZXcgU2V0KCk7XG4gICAgbGV0IHJlcXVlc3RUb2tlbnMgPSBuZXcgTWFwKCk7XG4gICAgbGV0IHRyYWNlID0gVHJhY2UuT2ZmO1xuICAgIGxldCB0cmFjZUZvcm1hdCA9IFRyYWNlRm9ybWF0LlRleHQ7XG4gICAgbGV0IHRyYWNlcjtcbiAgICBsZXQgc3RhdGUgPSBDb25uZWN0aW9uU3RhdGUuTmV3O1xuICAgIGNvbnN0IGVycm9yRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgY29uc3QgY2xvc2VFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICBjb25zdCB1bmhhbmRsZWROb3RpZmljYXRpb25FbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICBjb25zdCB1bmhhbmRsZWRQcm9ncmVzc0VtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgIGNvbnN0IGRpc3Bvc2VFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICBjb25zdCBjYW5jZWxsYXRpb25TdHJhdGVneSA9IChvcHRpb25zICYmIG9wdGlvbnMuY2FuY2VsbGF0aW9uU3RyYXRlZ3kpID8gb3B0aW9ucy5jYW5jZWxsYXRpb25TdHJhdGVneSA6IENhbmNlbGxhdGlvblN0cmF0ZWd5Lk1lc3NhZ2U7XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVxdWVzdFF1ZXVlS2V5KGlkKSB7XG4gICAgICAgIGlmIChpZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBzZW5kIHJlcXVlc3RzIHdpdGggaWQgbnVsbCBzaW5jZSB0aGUgcmVzcG9uc2UgY2FuJ3QgYmUgY29ycmVsYXRlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ3JlcS0nICsgaWQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2VRdWV1ZUtleShpZCkge1xuICAgICAgICBpZiAoaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAncmVzLXVua25vd24tJyArICgrK3Vua25vd25SZXNwb25zZVNlcXVlbmNlTnVtYmVyKS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdyZXMtJyArIGlkLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlTm90aWZpY2F0aW9uUXVldWVLZXkoKSB7XG4gICAgICAgIHJldHVybiAnbm90LScgKyAoKytub3RpZmljYXRpb25TZXF1ZW5jZU51bWJlcikudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkTWVzc2FnZVRvUXVldWUocXVldWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc1JlcXVlc3QobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIHF1ZXVlLnNldChjcmVhdGVSZXF1ZXN0UXVldWVLZXkobWVzc2FnZS5pZCksIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc1Jlc3BvbnNlKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBxdWV1ZS5zZXQoY3JlYXRlUmVzcG9uc2VRdWV1ZUtleShtZXNzYWdlLmlkKSwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBxdWV1ZS5zZXQoY3JlYXRlTm90aWZpY2F0aW9uUXVldWVLZXkoKSwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2FuY2VsVW5kaXNwYXRjaGVkKF9tZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTGlzdGVuaW5nKCkge1xuICAgICAgICByZXR1cm4gc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5MaXN0ZW5pbmc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzQ2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5DbG9zZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzRGlzcG9zZWQoKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkRpc3Bvc2VkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbG9zZUhhbmRsZXIoKSB7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLk5ldyB8fCBzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkxpc3RlbmluZykge1xuICAgICAgICAgICAgc3RhdGUgPSBDb25uZWN0aW9uU3RhdGUuQ2xvc2VkO1xuICAgICAgICAgICAgY2xvc2VFbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgY29ubmVjdGlvbiBpcyBkaXNwb3NlZCBkb24ndCBzZW50IGNsb3NlIGV2ZW50cy5cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZEVycm9ySGFuZGxlcihlcnJvcikge1xuICAgICAgICBlcnJvckVtaXR0ZXIuZmlyZShbZXJyb3IsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlRXJyb3JIYW5kbGVyKGRhdGEpIHtcbiAgICAgICAgZXJyb3JFbWl0dGVyLmZpcmUoZGF0YSk7XG4gICAgfVxuICAgIG1lc3NhZ2VSZWFkZXIub25DbG9zZShjbG9zZUhhbmRsZXIpO1xuICAgIG1lc3NhZ2VSZWFkZXIub25FcnJvcihyZWFkRXJyb3JIYW5kbGVyKTtcbiAgICBtZXNzYWdlV3JpdGVyLm9uQ2xvc2UoY2xvc2VIYW5kbGVyKTtcbiAgICBtZXNzYWdlV3JpdGVyLm9uRXJyb3Iod3JpdGVFcnJvckhhbmRsZXIpO1xuICAgIGZ1bmN0aW9uIHRyaWdnZXJNZXNzYWdlUXVldWUoKSB7XG4gICAgICAgIGlmICh0aW1lciB8fCBtZXNzYWdlUXVldWUuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVyID0gKDAsIHJhbF8xLmRlZmF1bHQpKCkudGltZXIuc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgIHRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcHJvY2Vzc01lc3NhZ2VRdWV1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNSZXF1ZXN0KG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBoYW5kbGVSZXF1ZXN0KG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc05vdGlmaWNhdGlvbihtZXNzYWdlKSkge1xuICAgICAgICAgICAgaGFuZGxlTm90aWZpY2F0aW9uKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc1Jlc3BvbnNlKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBoYW5kbGVSZXNwb25zZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZUludmFsaWRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb2Nlc3NNZXNzYWdlUXVldWUoKSB7XG4gICAgICAgIGlmIChtZXNzYWdlUXVldWUuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlUXVldWUuc2hpZnQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VTdHJhdGVneSA9IG9wdGlvbnM/Lm1lc3NhZ2VTdHJhdGVneTtcbiAgICAgICAgICAgIGlmIChNZXNzYWdlU3RyYXRlZ3kuaXMobWVzc2FnZVN0cmF0ZWd5KSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VTdHJhdGVneS5oYW5kbGVNZXNzYWdlKG1lc3NhZ2UsIGhhbmRsZU1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyaWdnZXJNZXNzYWdlUXVldWUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjYWxsYmFjayA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIHJlY2VpdmVkIGEgY2FuY2VsbGF0aW9uIG1lc3NhZ2UuIENoZWNrIGlmIHRoZSBtZXNzYWdlIGlzIHN0aWxsIGluIHRoZSBxdWV1ZVxuICAgICAgICAgICAgLy8gYW5kIGNhbmNlbCBpdCBpZiBhbGxvd2VkIHRvIGRvIHNvLlxuICAgICAgICAgICAgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc05vdGlmaWNhdGlvbihtZXNzYWdlKSAmJiBtZXNzYWdlLm1ldGhvZCA9PT0gQ2FuY2VsTm90aWZpY2F0aW9uLnR5cGUubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsSWQgPSBtZXNzYWdlLnBhcmFtcy5pZDtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBjcmVhdGVSZXF1ZXN0UXVldWVLZXkoY2FuY2VsSWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvQ2FuY2VsID0gbWVzc2FnZVF1ZXVlLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNSZXF1ZXN0KHRvQ2FuY2VsKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJhdGVneSA9IG9wdGlvbnM/LmNvbm5lY3Rpb25TdHJhdGVneTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSAoc3RyYXRlZ3kgJiYgc3RyYXRlZ3kuY2FuY2VsVW5kaXNwYXRjaGVkKSA/IHN0cmF0ZWd5LmNhbmNlbFVuZGlzcGF0Y2hlZCh0b0NhbmNlbCwgY2FuY2VsVW5kaXNwYXRjaGVkKSA6IGNhbmNlbFVuZGlzcGF0Y2hlZCh0b0NhbmNlbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiAocmVzcG9uc2UuZXJyb3IgIT09IHVuZGVmaW5lZCB8fCByZXNwb25zZS5yZXN1bHQgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VRdWV1ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuZGVsZXRlKGNhbmNlbElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmlkID0gdG9DYW5jZWwuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjZVNlbmRpbmdSZXNwb25zZShyZXNwb25zZSwgbWVzc2FnZS5tZXRob2QsIERhdGUubm93KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVdyaXRlci53cml0ZShyZXNwb25zZSkuY2F0Y2goKCkgPT4gbG9nZ2VyLmVycm9yKGBTZW5kaW5nIHJlc3BvbnNlIGZvciBjYW5jZWxlZCBtZXNzYWdlIGZhaWxlZC5gKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsbGF0aW9uVG9rZW4gPSByZXF1ZXN0VG9rZW5zLmdldChjYW5jZWxJZCk7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHJlcXVlc3QgaXMgYWxyZWFkeSBydW5uaW5nLiBDYW5jZWwgdGhlIHRva2VuXG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbGxhdGlvblRva2VuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uVG9rZW4uY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlUmVjZWl2ZWROb3RpZmljYXRpb24obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoZSBjYW5jZWwgYnV0IHN0aWxsIHF1ZXVlIHRoZSBtZXNzYWdlIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGNsZWFuIHVwIHN0YXRlIGluIHByb2Nlc3MgbWVzc2FnZS5cbiAgICAgICAgICAgICAgICAgICAga25vd25DYW5jZWxlZFJlcXVlc3RzLmFkZChjYW5jZWxJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkTWVzc2FnZVRvUXVldWUobWVzc2FnZVF1ZXVlLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyaWdnZXJNZXNzYWdlUXVldWUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gaGFuZGxlUmVxdWVzdChyZXF1ZXN0TWVzc2FnZSkge1xuICAgICAgICBpZiAoaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICAvLyB3ZSByZXR1cm4gaGVyZSBzaWxlbnRseSBzaW5jZSB3ZSBmaXJlZCBhbiBldmVudCB3aGVuIHRoZVxuICAgICAgICAgICAgLy8gY29ubmVjdGlvbiBnb3QgZGlzcG9zZWQuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVwbHkocmVzdWx0T3JFcnJvciwgbWV0aG9kLCBzdGFydFRpbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAganNvbnJwYzogdmVyc2lvbixcbiAgICAgICAgICAgICAgICBpZDogcmVxdWVzdE1lc3NhZ2UuaWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocmVzdWx0T3JFcnJvciBpbnN0YW5jZW9mIG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXJyb3IgPSByZXN1bHRPckVycm9yLnRvSnNvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5yZXN1bHQgPSByZXN1bHRPckVycm9yID09PSB1bmRlZmluZWQgPyBudWxsIDogcmVzdWx0T3JFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNlU2VuZGluZ1Jlc3BvbnNlKG1lc3NhZ2UsIG1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIG1lc3NhZ2VXcml0ZXIud3JpdGUobWVzc2FnZSkuY2F0Y2goKCkgPT4gbG9nZ2VyLmVycm9yKGBTZW5kaW5nIHJlc3BvbnNlIGZhaWxlZC5gKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVwbHlFcnJvcihlcnJvciwgbWV0aG9kLCBzdGFydFRpbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAganNvbnJwYzogdmVyc2lvbixcbiAgICAgICAgICAgICAgICBpZDogcmVxdWVzdE1lc3NhZ2UuaWQsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLnRvSnNvbigpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJhY2VTZW5kaW5nUmVzcG9uc2UobWVzc2FnZSwgbWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgbWVzc2FnZVdyaXRlci53cml0ZShtZXNzYWdlKS5jYXRjaCgoKSA9PiBsb2dnZXIuZXJyb3IoYFNlbmRpbmcgcmVzcG9uc2UgZmFpbGVkLmApKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXBseVN1Y2Nlc3MocmVzdWx0LCBtZXRob2QsIHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgLy8gVGhlIEpTT04gUlBDIGRlZmluZXMgdGhhdCBhIHJlc3BvbnNlIG11c3QgZWl0aGVyIGhhdmUgYSByZXN1bHQgb3IgYW4gZXJyb3JcbiAgICAgICAgICAgIC8vIFNvIHdlIGNhbid0IHRyZWF0IHVuZGVmaW5lZCBhcyBhIHZhbGlkIHJlc3BvbnNlIHJlc3VsdC5cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGpzb25ycGM6IHZlcnNpb24sXG4gICAgICAgICAgICAgICAgaWQ6IHJlcXVlc3RNZXNzYWdlLmlkLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJhY2VTZW5kaW5nUmVzcG9uc2UobWVzc2FnZSwgbWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgbWVzc2FnZVdyaXRlci53cml0ZShtZXNzYWdlKS5jYXRjaCgoKSA9PiBsb2dnZXIuZXJyb3IoYFNlbmRpbmcgcmVzcG9uc2UgZmFpbGVkLmApKTtcbiAgICAgICAgfVxuICAgICAgICB0cmFjZVJlY2VpdmVkUmVxdWVzdChyZXF1ZXN0TWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSByZXF1ZXN0SGFuZGxlcnMuZ2V0KHJlcXVlc3RNZXNzYWdlLm1ldGhvZCk7XG4gICAgICAgIGxldCB0eXBlO1xuICAgICAgICBsZXQgcmVxdWVzdEhhbmRsZXI7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICB0eXBlID0gZWxlbWVudC50eXBlO1xuICAgICAgICAgICAgcmVxdWVzdEhhbmRsZXIgPSBlbGVtZW50LmhhbmRsZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKHJlcXVlc3RIYW5kbGVyIHx8IHN0YXJSZXF1ZXN0SGFuZGxlcikge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5LZXkgPSByZXF1ZXN0TWVzc2FnZS5pZCA/PyBTdHJpbmcoRGF0ZS5ub3coKSk7IC8vXG4gICAgICAgICAgICBjb25zdCBjYW5jZWxsYXRpb25Tb3VyY2UgPSBJZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuaXMoY2FuY2VsbGF0aW9uU3RyYXRlZ3kucmVjZWl2ZXIpXG4gICAgICAgICAgICAgICAgPyBjYW5jZWxsYXRpb25TdHJhdGVneS5yZWNlaXZlci5jcmVhdGVDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSh0b2tlbktleSlcbiAgICAgICAgICAgICAgICA6IGNhbmNlbGxhdGlvblN0cmF0ZWd5LnJlY2VpdmVyLmNyZWF0ZUNhbmNlbGxhdGlvblRva2VuU291cmNlKHJlcXVlc3RNZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0TWVzc2FnZS5pZCAhPT0gbnVsbCAmJiBrbm93bkNhbmNlbGVkUmVxdWVzdHMuaGFzKHJlcXVlc3RNZXNzYWdlLmlkKSkge1xuICAgICAgICAgICAgICAgIGNhbmNlbGxhdGlvblNvdXJjZS5jYW5jZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0TWVzc2FnZS5pZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuc2V0KHRva2VuS2V5LCBjYW5jZWxsYXRpb25Tb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgaGFuZGxlclJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RNZXNzYWdlLnBhcmFtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUubnVtYmVyT2ZQYXJhbXMgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLkludmFsaWRQYXJhbXMsIGBSZXF1ZXN0ICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfSBkZWZpbmVzICR7dHlwZS5udW1iZXJPZlBhcmFtc30gcGFyYW1zIGJ1dCByZWNlaXZlZCBub25lLmApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlclJlc3VsdCA9IHJlcXVlc3RIYW5kbGVyKGNhbmNlbGxhdGlvblNvdXJjZS50b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXF1ZXN0TWVzc2FnZS5wYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUucGFyYW1ldGVyU3RydWN0dXJlcyA9PT0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuSW52YWxpZFBhcmFtcywgYFJlcXVlc3QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9IGRlZmluZXMgcGFyYW1ldGVycyBieSBuYW1lIGJ1dCByZWNlaXZlZCBwYXJhbWV0ZXJzIGJ5IHBvc2l0aW9uYCksIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyUmVzdWx0ID0gcmVxdWVzdEhhbmRsZXIoLi4ucmVxdWVzdE1lc3NhZ2UucGFyYW1zLCBjYW5jZWxsYXRpb25Tb3VyY2UudG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLnBhcmFtZXRlclN0cnVjdHVyZXMgPT09IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieVBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnZhbGlkUGFyYW1zLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZGVmaW5lcyBwYXJhbWV0ZXJzIGJ5IHBvc2l0aW9uIGJ1dCByZWNlaXZlZCBwYXJhbWV0ZXJzIGJ5IG5hbWVgKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJSZXN1bHQgPSByZXF1ZXN0SGFuZGxlcihyZXF1ZXN0TWVzc2FnZS5wYXJhbXMsIGNhbmNlbGxhdGlvblNvdXJjZS50b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhclJlcXVlc3RIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJSZXN1bHQgPSBzdGFyUmVxdWVzdEhhbmRsZXIocmVxdWVzdE1lc3NhZ2UubWV0aG9kLCByZXF1ZXN0TWVzc2FnZS5wYXJhbXMsIGNhbmNlbGxhdGlvblNvdXJjZS50b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBoYW5kbGVyUmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmICghaGFuZGxlclJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW5zLmRlbGV0ZSh0b2tlbktleSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcGx5U3VjY2VzcyhoYW5kbGVyUmVzdWx0LCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb21pc2UudGhlbikge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oKHJlc3VsdE9yRXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuZGVsZXRlKHRva2VuS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5KHJlc3VsdE9yRXJyb3IsIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFRva2Vucy5kZWxldGUodG9rZW5LZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihlcnJvciwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IgJiYgSXMuc3RyaW5nKGVycm9yLm1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnRlcm5hbEVycm9yLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZmFpbGVkIHdpdGggbWVzc2FnZTogJHtlcnJvci5tZXNzYWdlfWApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLkludGVybmFsRXJyb3IsIGBSZXF1ZXN0ICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfSBmYWlsZWQgdW5leHBlY3RlZGx5IHdpdGhvdXQgcHJvdmlkaW5nIGFueSBkZXRhaWxzLmApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFRva2Vucy5kZWxldGUodG9rZW5LZXkpO1xuICAgICAgICAgICAgICAgICAgICByZXBseShoYW5kbGVyUmVzdWx0LCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFRva2Vucy5kZWxldGUodG9rZW5LZXkpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXBseShlcnJvciwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnJvciAmJiBJcy5zdHJpbmcoZXJyb3IubWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnRlcm5hbEVycm9yLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZmFpbGVkIHdpdGggbWVzc2FnZTogJHtlcnJvci5tZXNzYWdlfWApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLkludGVybmFsRXJyb3IsIGBSZXF1ZXN0ICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfSBmYWlsZWQgdW5leHBlY3RlZGx5IHdpdGhvdXQgcHJvdmlkaW5nIGFueSBkZXRhaWxzLmApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5NZXRob2ROb3RGb3VuZCwgYFVuaGFuZGxlZCBtZXRob2QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9YCksIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVSZXNwb25zZShyZXNwb25zZU1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGlzRGlzcG9zZWQoKSkge1xuICAgICAgICAgICAgLy8gU2VlIGhhbmRsZSByZXF1ZXN0LlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNwb25zZU1lc3NhZ2UuaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZU1lc3NhZ2UuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFJlY2VpdmVkIHJlc3BvbnNlIG1lc3NhZ2Ugd2l0aG91dCBpZDogRXJyb3IgaXM6IFxcbiR7SlNPTi5zdHJpbmdpZnkocmVzcG9uc2VNZXNzYWdlLmVycm9yLCB1bmRlZmluZWQsIDQpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBSZWNlaXZlZCByZXNwb25zZSBtZXNzYWdlIHdpdGhvdXQgaWQuIE5vIGZ1cnRoZXIgZXJyb3IgaW5mb3JtYXRpb24gcHJvdmlkZWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSByZXNwb25zZU1lc3NhZ2UuaWQ7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSByZXNwb25zZVByb21pc2VzLmdldChrZXkpO1xuICAgICAgICAgICAgdHJhY2VSZWNlaXZlZFJlc3BvbnNlKHJlc3BvbnNlTWVzc2FnZSwgcmVzcG9uc2VQcm9taXNlKTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVByb21pc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSByZXNwb25zZU1lc3NhZ2UuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVqZWN0KG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IoZXJyb3IuY29kZSwgZXJyb3IubWVzc2FnZSwgZXJyb3IuZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlTWVzc2FnZS5yZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlc29sdmUocmVzcG9uc2VNZXNzYWdlLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBuZXZlciBoYXBwZW4uJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFJlc3BvbnNlIGhhbmRsZXIgJyR7cmVzcG9uc2VQcm9taXNlLm1ldGhvZH0nIGZhaWxlZCB3aXRoIG1lc3NhZ2U6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgUmVzcG9uc2UgaGFuZGxlciAnJHtyZXNwb25zZVByb21pc2UubWV0aG9kfScgZmFpbGVkIHVuZXhwZWN0ZWRseS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVOb3RpZmljYXRpb24obWVzc2FnZSkge1xuICAgICAgICBpZiAoaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICAvLyBTZWUgaGFuZGxlIHJlcXVlc3QuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHR5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBub3RpZmljYXRpb25IYW5kbGVyO1xuICAgICAgICBpZiAobWVzc2FnZS5tZXRob2QgPT09IENhbmNlbE5vdGlmaWNhdGlvbi50eXBlLm1ldGhvZCkge1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsSWQgPSBtZXNzYWdlLnBhcmFtcy5pZDtcbiAgICAgICAgICAgIGtub3duQ2FuY2VsZWRSZXF1ZXN0cy5kZWxldGUoY2FuY2VsSWQpO1xuICAgICAgICAgICAgdHJhY2VSZWNlaXZlZE5vdGlmaWNhdGlvbihtZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBub3RpZmljYXRpb25IYW5kbGVycy5nZXQobWVzc2FnZS5tZXRob2QpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVyID0gZWxlbWVudC5oYW5kbGVyO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vdGlmaWNhdGlvbkhhbmRsZXIgfHwgc3Rhck5vdGlmaWNhdGlvbkhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdHJhY2VSZWNlaXZlZE5vdGlmaWNhdGlvbihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBpZiAobm90aWZpY2F0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5wYXJhbXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlLm51bWJlck9mUGFyYW1zICE9PSAwICYmIHR5cGUucGFyYW1ldGVyU3RydWN0dXJlcyAhPT0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE5vdGlmaWNhdGlvbiAke21lc3NhZ2UubWV0aG9kfSBkZWZpbmVzICR7dHlwZS5udW1iZXJPZlBhcmFtc30gcGFyYW1zIGJ1dCByZWNlaXZlZCBub25lLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG1lc3NhZ2UucGFyYW1zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgYXJlIEpTT04tUlBDIGxpYnJhcmllcyB0aGF0IHNlbmQgcHJvZ3Jlc3MgbWVzc2FnZSBhcyBwb3NpdGlvbmFsIHBhcmFtcyBhbHRob3VnaFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGFzIG5hbWVkLiBTbyBjb252ZXJ0IHRoZW0gaWYgdGhpcyBpcyB0aGUgY2FzZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IG1lc3NhZ2UucGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBQcm9ncmVzc05vdGlmaWNhdGlvbi50eXBlLm1ldGhvZCAmJiBwYXJhbXMubGVuZ3RoID09PSAyICYmIFByb2dyZXNzVG9rZW4uaXMocGFyYW1zWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXIoeyB0b2tlbjogcGFyYW1zWzBdLCB2YWx1ZTogcGFyYW1zWzFdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZS5wYXJhbWV0ZXJTdHJ1Y3R1cmVzID09PSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE5vdGlmaWNhdGlvbiAke21lc3NhZ2UubWV0aG9kfSBkZWZpbmVzIHBhcmFtZXRlcnMgYnkgbmFtZSBidXQgcmVjZWl2ZWQgcGFyYW1ldGVycyBieSBwb3NpdGlvbmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlLm51bWJlck9mUGFyYW1zICE9PSBtZXNzYWdlLnBhcmFtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTm90aWZpY2F0aW9uICR7bWVzc2FnZS5tZXRob2R9IGRlZmluZXMgJHt0eXBlLm51bWJlck9mUGFyYW1zfSBwYXJhbXMgYnV0IHJlY2VpdmVkICR7cGFyYW1zLmxlbmd0aH0gYXJndW1lbnRzYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlciguLi5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLnBhcmFtZXRlclN0cnVjdHVyZXMgPT09IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieVBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBOb3RpZmljYXRpb24gJHttZXNzYWdlLm1ldGhvZH0gZGVmaW5lcyBwYXJhbWV0ZXJzIGJ5IHBvc2l0aW9uIGJ1dCByZWNlaXZlZCBwYXJhbWV0ZXJzIGJ5IG5hbWVgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXIobWVzc2FnZS5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJOb3RpZmljYXRpb25IYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJOb3RpZmljYXRpb25IYW5kbGVyKG1lc3NhZ2UubWV0aG9kLCBtZXNzYWdlLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBOb3RpZmljYXRpb24gaGFuZGxlciAnJHttZXNzYWdlLm1ldGhvZH0nIGZhaWxlZCB3aXRoIG1lc3NhZ2U6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTm90aWZpY2F0aW9uIGhhbmRsZXIgJyR7bWVzc2FnZS5tZXRob2R9JyBmYWlsZWQgdW5leHBlY3RlZGx5LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVuaGFuZGxlZE5vdGlmaWNhdGlvbkVtaXR0ZXIuZmlyZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVJbnZhbGlkTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdSZWNlaXZlZCBlbXB0eSBtZXNzYWdlLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5lcnJvcihgUmVjZWl2ZWQgbWVzc2FnZSB3aGljaCBpcyBuZWl0aGVyIGEgcmVzcG9uc2Ugbm9yIGEgbm90aWZpY2F0aW9uIG1lc3NhZ2U6XFxuJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlLCBudWxsLCA0KX1gKTtcbiAgICAgICAgLy8gVGVzdCB3aGV0aGVyIHdlIGZpbmQgYW4gaWQgdG8gcmVqZWN0IHRoZSBwcm9taXNlXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIGlmIChJcy5zdHJpbmcocmVzcG9uc2VNZXNzYWdlLmlkKSB8fCBJcy5udW1iZXIocmVzcG9uc2VNZXNzYWdlLmlkKSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gcmVzcG9uc2VNZXNzYWdlLmlkO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VIYW5kbGVyID0gcmVzcG9uc2VQcm9taXNlcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZUhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZUhhbmRsZXIucmVqZWN0KG5ldyBFcnJvcignVGhlIHJlY2VpdmVkIHJlc3BvbnNlIGhhcyBuZWl0aGVyIGEgcmVzdWx0IG5vciBhbiBlcnJvciBwcm9wZXJ0eS4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RyaW5naWZ5VHJhY2UocGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMgPT09IHVuZGVmaW5lZCB8fCBwYXJhbXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0cmFjZSkge1xuICAgICAgICAgICAgY2FzZSBUcmFjZS5WZXJib3NlOlxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXJhbXMsIG51bGwsIDQpO1xuICAgICAgICAgICAgY2FzZSBUcmFjZS5Db21wYWN0OlxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXJhbXMpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYWNlU2VuZGluZ1JlcXVlc3QobWVzc2FnZSkge1xuICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLk9mZiB8fCAhdHJhY2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNlRm9ybWF0ID09PSBUcmFjZUZvcm1hdC5UZXh0KSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICgodHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3QpICYmIG1lc3NhZ2UucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGBQYXJhbXM6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5wYXJhbXMpfVxcblxcbmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZXIubG9nKGBTZW5kaW5nIHJlcXVlc3QgJyR7bWVzc2FnZS5tZXRob2R9IC0gKCR7bWVzc2FnZS5pZH0pJy5gLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0xTUE1lc3NhZ2UoJ3NlbmQtcmVxdWVzdCcsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYWNlU2VuZGluZ05vdGlmaWNhdGlvbihtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2VGb3JtYXQgPT09IFRyYWNlRm9ybWF0LlRleHQpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5WZXJib3NlIHx8IHRyYWNlID09PSBUcmFjZS5Db21wYWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBgUGFyYW1zOiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UucGFyYW1zKX1cXG5cXG5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICdObyBwYXJhbWV0ZXJzIHByb3ZpZGVkLlxcblxcbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2VyLmxvZyhgU2VuZGluZyBub3RpZmljYXRpb24gJyR7bWVzc2FnZS5tZXRob2R9Jy5gLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0xTUE1lc3NhZ2UoJ3NlbmQtbm90aWZpY2F0aW9uJywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhY2VTZW5kaW5nUmVzcG9uc2UobWVzc2FnZSwgbWV0aG9kLCBzdGFydFRpbWUpIHtcbiAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYgfHwgIXRyYWNlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZUZvcm1hdCA9PT0gVHJhY2VGb3JtYXQuVGV4dCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5lcnJvciAmJiBtZXNzYWdlLmVycm9yLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGBFcnJvciBkYXRhOiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UuZXJyb3IuZGF0YSl9XFxuXFxuYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGBSZXN1bHQ6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5yZXN1bHQpfVxcblxcbmA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWVzc2FnZS5lcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gJ05vIHJlc3VsdCByZXR1cm5lZC5cXG5cXG4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2VyLmxvZyhgU2VuZGluZyByZXNwb25zZSAnJHttZXRob2R9IC0gKCR7bWVzc2FnZS5pZH0pJy4gUHJvY2Vzc2luZyByZXF1ZXN0IHRvb2sgJHtEYXRlLm5vdygpIC0gc3RhcnRUaW1lfW1zYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdzZW5kLXJlc3BvbnNlJywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhY2VSZWNlaXZlZFJlcXVlc3QobWVzc2FnZSkge1xuICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLk9mZiB8fCAhdHJhY2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNlRm9ybWF0ID09PSBUcmFjZUZvcm1hdC5UZXh0KSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICgodHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3QpICYmIG1lc3NhZ2UucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGBQYXJhbXM6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5wYXJhbXMpfVxcblxcbmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZXIubG9nKGBSZWNlaXZlZCByZXF1ZXN0ICcke21lc3NhZ2UubWV0aG9kfSAtICgke21lc3NhZ2UuaWR9KScuYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdyZWNlaXZlLXJlcXVlc3QnLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFjZVJlY2VpdmVkTm90aWZpY2F0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYgfHwgIXRyYWNlciB8fCBtZXNzYWdlLm1ldGhvZCA9PT0gTG9nVHJhY2VOb3RpZmljYXRpb24udHlwZS5tZXRob2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2VGb3JtYXQgPT09IFRyYWNlRm9ybWF0LlRleHQpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5WZXJib3NlIHx8IHRyYWNlID09PSBUcmFjZS5Db21wYWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBgUGFyYW1zOiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UucGFyYW1zKX1cXG5cXG5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICdObyBwYXJhbWV0ZXJzIHByb3ZpZGVkLlxcblxcbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2VyLmxvZyhgUmVjZWl2ZWQgbm90aWZpY2F0aW9uICcke21lc3NhZ2UubWV0aG9kfScuYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdyZWNlaXZlLW5vdGlmaWNhdGlvbicsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYWNlUmVjZWl2ZWRSZXNwb25zZShtZXNzYWdlLCByZXNwb25zZVByb21pc2UpIHtcbiAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYgfHwgIXRyYWNlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZUZvcm1hdCA9PT0gVHJhY2VGb3JtYXQuVGV4dCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5lcnJvciAmJiBtZXNzYWdlLmVycm9yLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGBFcnJvciBkYXRhOiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UuZXJyb3IuZGF0YSl9XFxuXFxuYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGBSZXN1bHQ6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5yZXN1bHQpfVxcblxcbmA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWVzc2FnZS5lcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gJ05vIHJlc3VsdCByZXR1cm5lZC5cXG5cXG4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbWVzc2FnZS5lcnJvciA/IGAgUmVxdWVzdCBmYWlsZWQ6ICR7bWVzc2FnZS5lcnJvci5tZXNzYWdlfSAoJHttZXNzYWdlLmVycm9yLmNvZGV9KS5gIDogJyc7XG4gICAgICAgICAgICAgICAgdHJhY2VyLmxvZyhgUmVjZWl2ZWQgcmVzcG9uc2UgJyR7cmVzcG9uc2VQcm9taXNlLm1ldGhvZH0gLSAoJHttZXNzYWdlLmlkfSknIGluICR7RGF0ZS5ub3coKSAtIHJlc3BvbnNlUHJvbWlzZS50aW1lclN0YXJ0fW1zLiR7ZXJyb3J9YCwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFjZXIubG9nKGBSZWNlaXZlZCByZXNwb25zZSAke21lc3NhZ2UuaWR9IHdpdGhvdXQgYWN0aXZlIHJlc3BvbnNlIHByb21pc2UuYCwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdyZWNlaXZlLXJlc3BvbnNlJywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbG9nTFNQTWVzc2FnZSh0eXBlLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICghdHJhY2VyIHx8IHRyYWNlID09PSBUcmFjZS5PZmYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsc3BNZXNzYWdlID0ge1xuICAgICAgICAgICAgaXNMU1BNZXNzYWdlOiB0cnVlLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgICAgfTtcbiAgICAgICAgdHJhY2VyLmxvZyhsc3BNZXNzYWdlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGhyb3dJZkNsb3NlZE9yRGlzcG9zZWQoKSB7XG4gICAgICAgIGlmIChpc0Nsb3NlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKENvbm5lY3Rpb25FcnJvcnMuQ2xvc2VkLCAnQ29ubmVjdGlvbiBpcyBjbG9zZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGlzcG9zZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihDb25uZWN0aW9uRXJyb3JzLkRpc3Bvc2VkLCAnQ29ubmVjdGlvbiBpcyBkaXNwb3NlZC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0aHJvd0lmTGlzdGVuaW5nKCkge1xuICAgICAgICBpZiAoaXNMaXN0ZW5pbmcoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihDb25uZWN0aW9uRXJyb3JzLkFscmVhZHlMaXN0ZW5pbmcsICdDb25uZWN0aW9uIGlzIGFscmVhZHkgbGlzdGVuaW5nJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdGhyb3dJZk5vdExpc3RlbmluZygpIHtcbiAgICAgICAgaWYgKCFpc0xpc3RlbmluZygpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGwgbGlzdGVuKCkgZmlyc3QuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdW5kZWZpbmVkVG9OdWxsKHBhcmFtKSB7XG4gICAgICAgIGlmIChwYXJhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBudWxsVG9VbmRlZmluZWQocGFyYW0pIHtcbiAgICAgICAgaWYgKHBhcmFtID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTmFtZWRQYXJhbShwYXJhbSkge1xuICAgICAgICByZXR1cm4gcGFyYW0gIT09IHVuZGVmaW5lZCAmJiBwYXJhbSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShwYXJhbSkgJiYgdHlwZW9mIHBhcmFtID09PSAnb2JqZWN0JztcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcHV0ZVNpbmdsZVBhcmFtKHBhcmFtZXRlclN0cnVjdHVyZXMsIHBhcmFtKSB7XG4gICAgICAgIHN3aXRjaCAocGFyYW1ldGVyU3RydWN0dXJlcykge1xuICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYXV0bzpcbiAgICAgICAgICAgICAgICBpZiAoaXNOYW1lZFBhcmFtKHBhcmFtKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFRvVW5kZWZpbmVkKHBhcmFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdW5kZWZpbmVkVG9OdWxsKHBhcmFtKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lOlxuICAgICAgICAgICAgICAgIGlmICghaXNOYW1lZFBhcmFtKHBhcmFtKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlY2VpdmVkIHBhcmFtZXRlcnMgYnkgbmFtZSBidXQgcGFyYW0gaXMgbm90IGFuIG9iamVjdCBsaXRlcmFsLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFRvVW5kZWZpbmVkKHBhcmFtKTtcbiAgICAgICAgICAgIGNhc2UgbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5UG9zaXRpb246XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWRUb051bGwocGFyYW0pXTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHBhcmFtZXRlciBzdHJ1Y3R1cmUgJHtwYXJhbWV0ZXJTdHJ1Y3R1cmVzLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcHV0ZU1lc3NhZ2VQYXJhbXModHlwZSwgcGFyYW1zKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGNvbnN0IG51bWJlck9mUGFyYW1zID0gdHlwZS5udW1iZXJPZlBhcmFtcztcbiAgICAgICAgc3dpdGNoIChudW1iZXJPZlBhcmFtcykge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjb21wdXRlU2luZ2xlUGFyYW0odHlwZS5wYXJhbWV0ZXJTdHJ1Y3R1cmVzLCBwYXJhbXNbMF0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGggJiYgaSA8IG51bWJlck9mUGFyYW1zOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godW5kZWZpbmVkVG9OdWxsKHBhcmFtc1tpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA8IG51bWJlck9mUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBwYXJhbXMubGVuZ3RoOyBpIDwgbnVtYmVyT2ZQYXJhbXM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgY29ubmVjdGlvbiA9IHtcbiAgICAgICAgc2VuZE5vdGlmaWNhdGlvbjogKHR5cGUsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCk7XG4gICAgICAgICAgICBsZXQgbWV0aG9kO1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2VQYXJhbXM7XG4gICAgICAgICAgICBpZiAoSXMuc3RyaW5nKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdCA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtU3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBwYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG87XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5pcyhmaXJzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1TdGFydCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlclN0cnVjdHVyZXMgPSBmaXJzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtRW5kID0gYXJncy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtYmVyT2ZQYXJhbXMgPSBwYXJhbUVuZCAtIHBhcmFtU3RhcnQ7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChudW1iZXJPZlBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSBjb21wdXRlU2luZ2xlUGFyYW0ocGFyYW1ldGVyU3RydWN0dXJlcywgYXJnc1twYXJhbVN0YXJ0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJTdHJ1Y3R1cmVzID09PSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWNlaXZlZCAke251bWJlck9mUGFyYW1zfSBwYXJhbWV0ZXJzIGZvciAnYnkgTmFtZScgbm90aWZpY2F0aW9uIHBhcmFtZXRlciBzdHJ1Y3R1cmUuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gYXJncy5zbGljZShwYXJhbVN0YXJ0LCBwYXJhbUVuZCkubWFwKHZhbHVlID0+IHVuZGVmaW5lZFRvTnVsbCh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gYXJncztcbiAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlLm1ldGhvZDtcbiAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gY29tcHV0ZU1lc3NhZ2VQYXJhbXModHlwZSwgcGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbk1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAganNvbnJwYzogdmVyc2lvbixcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IG1lc3NhZ2VQYXJhbXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cmFjZVNlbmRpbmdOb3RpZmljYXRpb24obm90aWZpY2F0aW9uTWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZVdyaXRlci53cml0ZShub3RpZmljYXRpb25NZXNzYWdlKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFNlbmRpbmcgbm90aWZpY2F0aW9uIGZhaWxlZC5gKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbk5vdGlmaWNhdGlvbjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCk7XG4gICAgICAgICAgICBsZXQgbWV0aG9kO1xuICAgICAgICAgICAgaWYgKElzLmZ1bmModHlwZSkpIHtcbiAgICAgICAgICAgICAgICBzdGFyTm90aWZpY2F0aW9uSGFuZGxlciA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKElzLnN0cmluZyh0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVycy5zZXQodHlwZSwgeyB0eXBlOiB1bmRlZmluZWQsIGhhbmRsZXIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlLm1ldGhvZDtcbiAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlcnMuc2V0KHR5cGUubWV0aG9kLCB7IHR5cGUsIGhhbmRsZXIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlcnMuZGVsZXRlKG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFyTm90aWZpY2F0aW9uSGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIG9uUHJvZ3Jlc3M6IChfdHlwZSwgdG9rZW4sIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChwcm9ncmVzc0hhbmRsZXJzLmhhcyh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb2dyZXNzIGhhbmRsZXIgZm9yIHRva2VuICR7dG9rZW59IGFscmVhZHkgcmVnaXN0ZXJlZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvZ3Jlc3NIYW5kbGVycy5zZXQodG9rZW4sIGhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzSGFuZGxlcnMuZGVsZXRlKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBzZW5kUHJvZ3Jlc3M6IChfdHlwZSwgdG9rZW4sIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgYXdhaXQgYnV0IHNpbXBsZSByZXR1cm4gdG8gZW5zdXJlIHRoYXQgd2UgZG9uJ3QgaGF2ZSBhbm90aGVyXG4gICAgICAgICAgICAvLyBhc3luYyBzY2hlZHVsaW5nLiBPdGhlcndpc2Ugb25lIHNlbmQgY291bGQgb3ZlcnRha2UgYW5vdGhlciBzZW5kLlxuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uc2VuZE5vdGlmaWNhdGlvbihQcm9ncmVzc05vdGlmaWNhdGlvbi50eXBlLCB7IHRva2VuLCB2YWx1ZSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25VbmhhbmRsZWRQcm9ncmVzczogdW5oYW5kbGVkUHJvZ3Jlc3NFbWl0dGVyLmV2ZW50LFxuICAgICAgICBzZW5kUmVxdWVzdDogKHR5cGUsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCk7XG4gICAgICAgICAgICB0aHJvd0lmTm90TGlzdGVuaW5nKCk7XG4gICAgICAgICAgICBsZXQgbWV0aG9kO1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2VQYXJhbXM7XG4gICAgICAgICAgICBsZXQgdG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoSXMuc3RyaW5nKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdCA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1TdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtZXRlclN0cnVjdHVyZXMgPSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYXV0bztcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmlzKGZpcnN0KSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbVN0YXJ0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyU3RydWN0dXJlcyA9IGZpcnN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1FbmQgPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoY2FuY2VsbGF0aW9uXzEuQ2FuY2VsbGF0aW9uVG9rZW4uaXMobGFzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1FbmQgPSBwYXJhbUVuZCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gbGFzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtYmVyT2ZQYXJhbXMgPSBwYXJhbUVuZCAtIHBhcmFtU3RhcnQ7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChudW1iZXJPZlBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSBjb21wdXRlU2luZ2xlUGFyYW0ocGFyYW1ldGVyU3RydWN0dXJlcywgYXJnc1twYXJhbVN0YXJ0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJTdHJ1Y3R1cmVzID09PSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWNlaXZlZCAke251bWJlck9mUGFyYW1zfSBwYXJhbWV0ZXJzIGZvciAnYnkgTmFtZScgcmVxdWVzdCBwYXJhbWV0ZXIgc3RydWN0dXJlLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IGFyZ3Muc2xpY2UocGFyYW1TdGFydCwgcGFyYW1FbmQpLm1hcCh2YWx1ZSA9PiB1bmRlZmluZWRUb051bGwodmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZS5tZXRob2Q7XG4gICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IGNvbXB1dGVNZXNzYWdlUGFyYW1zKHR5cGUsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtYmVyT2ZQYXJhbXMgPSB0eXBlLm51bWJlck9mUGFyYW1zO1xuICAgICAgICAgICAgICAgIHRva2VuID0gY2FuY2VsbGF0aW9uXzEuQ2FuY2VsbGF0aW9uVG9rZW4uaXMocGFyYW1zW251bWJlck9mUGFyYW1zXSkgPyBwYXJhbXNbbnVtYmVyT2ZQYXJhbXNdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaWQgPSBzZXF1ZW5jZU51bWJlcisrO1xuICAgICAgICAgICAgbGV0IGRpc3Bvc2FibGU7XG4gICAgICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NhYmxlID0gdG9rZW4ub25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gY2FuY2VsbGF0aW9uU3RyYXRlZ3kuc2VuZGVyLnNlbmRDYW5jZWxsYXRpb24oY29ubmVjdGlvbiwgaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBSZWNlaXZlZCBubyBwcm9taXNlIGZyb20gY2FuY2VsbGF0aW9uIHN0cmF0ZWd5IHdoZW4gY2FuY2VsbGluZyBpZCAke2lkfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYFNlbmRpbmcgY2FuY2VsbGF0aW9uIG1lc3NhZ2VzIGZvciBpZCAke2lkfSBmYWlsZWRgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0TWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICBqc29ucnBjOiB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IG1lc3NhZ2VQYXJhbXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cmFjZVNlbmRpbmdSZXF1ZXN0KHJlcXVlc3RNZXNzYWdlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FuY2VsbGF0aW9uU3RyYXRlZ3kuc2VuZGVyLmVuYWJsZUNhbmNlbGxhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNhbmNlbGxhdGlvblN0cmF0ZWd5LnNlbmRlci5lbmFibGVDYW5jZWxsYXRpb24ocmVxdWVzdE1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlV2l0aENsZWFudXAgPSAocikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHIpO1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25TdHJhdGVneS5zZW5kZXIuY2xlYW51cChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FibGU/LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlamVjdFdpdGhDbGVhbnVwID0gKHIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHIpO1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25TdHJhdGVneS5zZW5kZXIuY2xlYW51cChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FibGU/LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IHsgbWV0aG9kOiBtZXRob2QsIHRpbWVyU3RhcnQ6IERhdGUubm93KCksIHJlc29sdmU6IHJlc29sdmVXaXRoQ2xlYW51cCwgcmVqZWN0OiByZWplY3RXaXRoQ2xlYW51cCB9O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG1lc3NhZ2VXcml0ZXIud3JpdGUocmVxdWVzdE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2VzLnNldChpZCwgcmVzcG9uc2VQcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgU2VuZGluZyByZXF1ZXN0IGZhaWxlZC5gKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV3JpdGluZyB0aGUgbWVzc2FnZSBmYWlsZWQuIFNvIHdlIG5lZWQgdG8gcmVqZWN0IHRoZSBwcm9taXNlLlxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVqZWN0KG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLk1lc3NhZ2VXcml0ZUVycm9yLCBlcnJvci5tZXNzYWdlID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIHJlYXNvbicpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUmVxdWVzdDogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCk7XG4gICAgICAgICAgICBsZXQgbWV0aG9kID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChTdGFyUmVxdWVzdEhhbmRsZXIuaXModHlwZSkpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgc3RhclJlcXVlc3RIYW5kbGVyID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKElzLnN0cmluZyh0eXBlKSkge1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SGFuZGxlcnMuc2V0KHR5cGUsIHsgaGFuZGxlcjogaGFuZGxlciwgdHlwZTogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZS5tZXRob2Q7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIYW5kbGVycy5zZXQodHlwZS5tZXRob2QsIHsgdHlwZSwgaGFuZGxlciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhhbmRsZXJzLmRlbGV0ZShtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhclJlcXVlc3RIYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzUGVuZGluZ1Jlc3BvbnNlOiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VQcm9taXNlcy5zaXplID4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhY2U6IGFzeW5jIChfdmFsdWUsIF90cmFjZXIsIHNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgbGV0IF9zZW5kTm90aWZpY2F0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgX3RyYWNlRm9ybWF0ID0gVHJhY2VGb3JtYXQuVGV4dDtcbiAgICAgICAgICAgIGlmIChzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChJcy5ib29sZWFuKHNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgX3NlbmROb3RpZmljYXRpb24gPSBzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfc2VuZE5vdGlmaWNhdGlvbiA9IHNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucy5zZW5kTm90aWZpY2F0aW9uIHx8IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBfdHJhY2VGb3JtYXQgPSBzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMudHJhY2VGb3JtYXQgfHwgVHJhY2VGb3JtYXQuVGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZSA9IF92YWx1ZTtcbiAgICAgICAgICAgIHRyYWNlRm9ybWF0ID0gX3RyYWNlRm9ybWF0O1xuICAgICAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYpIHtcbiAgICAgICAgICAgICAgICB0cmFjZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFjZXIgPSBfdHJhY2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9zZW5kTm90aWZpY2F0aW9uICYmICFpc0Nsb3NlZCgpICYmICFpc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uZWN0aW9uLnNlbmROb3RpZmljYXRpb24oU2V0VHJhY2VOb3RpZmljYXRpb24udHlwZSwgeyB2YWx1ZTogVHJhY2UudG9TdHJpbmcoX3ZhbHVlKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogZXJyb3JFbWl0dGVyLmV2ZW50LFxuICAgICAgICBvbkNsb3NlOiBjbG9zZUVtaXR0ZXIuZXZlbnQsXG4gICAgICAgIG9uVW5oYW5kbGVkTm90aWZpY2F0aW9uOiB1bmhhbmRsZWROb3RpZmljYXRpb25FbWl0dGVyLmV2ZW50LFxuICAgICAgICBvbkRpc3Bvc2U6IGRpc3Bvc2VFbWl0dGVyLmV2ZW50LFxuICAgICAgICBlbmQ6ICgpID0+IHtcbiAgICAgICAgICAgIG1lc3NhZ2VXcml0ZXIuZW5kKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZSA9IENvbm5lY3Rpb25TdGF0ZS5EaXNwb3NlZDtcbiAgICAgICAgICAgIGRpc3Bvc2VFbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuUGVuZGluZ1Jlc3BvbnNlUmVqZWN0ZWQsICdQZW5kaW5nIHJlc3BvbnNlIHJlamVjdGVkIHNpbmNlIGNvbm5lY3Rpb24gZ290IGRpc3Bvc2VkJyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb21pc2Ugb2YgcmVzcG9uc2VQcm9taXNlcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIHByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICByZXF1ZXN0VG9rZW5zID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAga25vd25DYW5jZWxlZFJlcXVlc3RzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgbWVzc2FnZVF1ZXVlID0gbmV3IGxpbmtlZE1hcF8xLkxpbmtlZE1hcCgpO1xuICAgICAgICAgICAgLy8gVGVzdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIGlmIChJcy5mdW5jKG1lc3NhZ2VXcml0ZXIuZGlzcG9zZSkpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlV3JpdGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChJcy5mdW5jKG1lc3NhZ2VSZWFkZXIuZGlzcG9zZSkpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlUmVhZGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbGlzdGVuOiAoKSA9PiB7XG4gICAgICAgICAgICB0aHJvd0lmQ2xvc2VkT3JEaXNwb3NlZCgpO1xuICAgICAgICAgICAgdGhyb3dJZkxpc3RlbmluZygpO1xuICAgICAgICAgICAgc3RhdGUgPSBDb25uZWN0aW9uU3RhdGUuTGlzdGVuaW5nO1xuICAgICAgICAgICAgbWVzc2FnZVJlYWRlci5saXN0ZW4oY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICBpbnNwZWN0OiAoKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgKDAsIHJhbF8xLmRlZmF1bHQpKCkuY29uc29sZS5sb2coJ2luc3BlY3QnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29ubmVjdGlvbi5vbk5vdGlmaWNhdGlvbihMb2dUcmFjZU5vdGlmaWNhdGlvbi50eXBlLCAocGFyYW1zKSA9PiB7XG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ZXJib3NlID0gdHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3Q7XG4gICAgICAgIHRyYWNlci5sb2cocGFyYW1zLm1lc3NhZ2UsIHZlcmJvc2UgPyBwYXJhbXMudmVyYm9zZSA6IHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gICAgY29ubmVjdGlvbi5vbk5vdGlmaWNhdGlvbihQcm9ncmVzc05vdGlmaWNhdGlvbi50eXBlLCAocGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBwcm9ncmVzc0hhbmRsZXJzLmdldChwYXJhbXMudG9rZW4pO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgaGFuZGxlcihwYXJhbXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdW5oYW5kbGVkUHJvZ3Jlc3NFbWl0dGVyLmZpcmUocGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb25uZWN0aW9uO1xufVxuZXhwb3J0cy5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiA9IGNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NDM3OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuRGlzcG9zYWJsZSA9IHZvaWQgMDtcbnZhciBEaXNwb3NhYmxlO1xuKGZ1bmN0aW9uIChEaXNwb3NhYmxlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpc3Bvc2U6IGZ1bmNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgRGlzcG9zYWJsZS5jcmVhdGUgPSBjcmVhdGU7XG59KShEaXNwb3NhYmxlID0gZXhwb3J0cy5EaXNwb3NhYmxlIHx8IChleHBvcnRzLkRpc3Bvc2FibGUgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MTY1OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkVtaXR0ZXIgPSBleHBvcnRzLkV2ZW50ID0gdm9pZCAwO1xuY29uc3QgcmFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3MDYpO1xudmFyIEV2ZW50O1xuKGZ1bmN0aW9uIChFdmVudCkge1xuICAgIGNvbnN0IF9kaXNwb3NhYmxlID0geyBkaXNwb3NlKCkgeyB9IH07XG4gICAgRXZlbnQuTm9uZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9kaXNwb3NhYmxlOyB9O1xufSkoRXZlbnQgPSBleHBvcnRzLkV2ZW50IHx8IChleHBvcnRzLkV2ZW50ID0ge30pKTtcbmNsYXNzIENhbGxiYWNrTGlzdCB7XG4gICAgYWRkKGNhbGxiYWNrLCBjb250ZXh0ID0gbnVsbCwgYnVja2V0KSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICB0aGlzLl9jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShidWNrZXQpKSB7XG4gICAgICAgICAgICBidWNrZXQucHVzaCh7IGRpc3Bvc2U6ICgpID0+IHRoaXMucmVtb3ZlKGNhbGxiYWNrLCBjb250ZXh0KSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUoY2FsbGJhY2ssIGNvbnRleHQgPSBudWxsKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZvdW5kQ2FsbGJhY2tXaXRoRGlmZmVyZW50Q29udGV4dCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5fY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2FsbGJhY2tzW2ldID09PSBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jb250ZXh0c1tpXSA9PT0gY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsYmFjayAmIGNvbnRleHQgbWF0Y2ggPT4gcmVtb3ZlIGl0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRDYWxsYmFja1dpdGhEaWZmZXJlbnRDb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kQ2FsbGJhY2tXaXRoRGlmZmVyZW50Q29udGV4dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaGVuIGFkZGluZyBhIGxpc3RlbmVyIHdpdGggYSBjb250ZXh0LCB5b3Ugc2hvdWxkIHJlbW92ZSBpdCB3aXRoIHRoZSBzYW1lIGNvbnRleHQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnZva2UoLi4uYXJncykge1xuICAgICAgICBpZiAoIXRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IFtdLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3Muc2xpY2UoMCksIGNvbnRleHRzID0gdGhpcy5fY29udGV4dHMuc2xpY2UoMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goY2FsbGJhY2tzW2ldLmFwcGx5KGNvbnRleHRzW2ldLCBhcmdzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgKDAsIHJhbF8xLmRlZmF1bHQpKCkuY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuX2NhbGxiYWNrcyB8fCB0aGlzLl9jYWxsYmFja3MubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2NvbnRleHRzID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmNsYXNzIEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKF9vcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBfb3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9yIHRoZSBwdWJsaWMgdG8gYWxsb3cgdG8gc3Vic2NyaWJlXG4gICAgICogdG8gZXZlbnRzIGZyb20gdGhpcyBFbWl0dGVyXG4gICAgICovXG4gICAgZ2V0IGV2ZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudCA9IChsaXN0ZW5lciwgdGhpc0FyZ3MsIGRpc3Bvc2FibGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gbmV3IENhbGxiYWNrTGlzdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucyAmJiB0aGlzLl9vcHRpb25zLm9uRmlyc3RMaXN0ZW5lckFkZCAmJiB0aGlzLl9jYWxsYmFja3MuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMub25GaXJzdExpc3RlbmVyQWRkKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MuYWRkKGxpc3RlbmVyLCB0aGlzQXJncyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpc3Bvc2FibGUgaXMgZGlzcG9zZWQgYWZ0ZXIgZW1pdHRlciBpcyBkaXNwb3NlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MucmVtb3ZlKGxpc3RlbmVyLCB0aGlzQXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZGlzcG9zZSA9IEVtaXR0ZXIuX25vb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucyAmJiB0aGlzLl9vcHRpb25zLm9uTGFzdExpc3RlbmVyUmVtb3ZlICYmIHRoaXMuX2NhbGxiYWNrcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLm9uTGFzdExpc3RlbmVyUmVtb3ZlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkaXNwb3NhYmxlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zYWJsZXMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvIGJlIGtlcHQgcHJpdmF0ZSB0byBmaXJlIGFuIGV2ZW50IHRvXG4gICAgICogc3Vic2NyaWJlcnNcbiAgICAgKi9cbiAgICBmaXJlKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5pbnZva2UuY2FsbCh0aGlzLl9jYWxsYmFja3MsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5FbWl0dGVyID0gRW1pdHRlcjtcbkVtaXR0ZXIuX25vb3AgPSBmdW5jdGlvbiAoKSB7IH07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg4MTE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuc3RyaW5nQXJyYXkgPSBleHBvcnRzLmFycmF5ID0gZXhwb3J0cy5mdW5jID0gZXhwb3J0cy5lcnJvciA9IGV4cG9ydHMubnVtYmVyID0gZXhwb3J0cy5zdHJpbmcgPSBleHBvcnRzLmJvb2xlYW4gPSB2b2lkIDA7XG5mdW5jdGlvbiBib29sZWFuKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZTtcbn1cbmV4cG9ydHMuYm9vbGVhbiA9IGJvb2xlYW47XG5mdW5jdGlvbiBzdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZztcbn1cbmV4cG9ydHMuc3RyaW5nID0gc3RyaW5nO1xuZnVuY3Rpb24gbnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXI7XG59XG5leHBvcnRzLm51bWJlciA9IG51bWJlcjtcbmZ1bmN0aW9uIGVycm9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRXJyb3I7XG59XG5leHBvcnRzLmVycm9yID0gZXJyb3I7XG5mdW5jdGlvbiBmdW5jKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuZnVuYyA9IGZ1bmM7XG5mdW5jdGlvbiBhcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbmV4cG9ydHMuYXJyYXkgPSBhcnJheTtcbmZ1bmN0aW9uIHN0cmluZ0FycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIGFycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShlbGVtID0+IHN0cmluZyhlbGVtKSk7XG59XG5leHBvcnRzLnN0cmluZ0FycmF5ID0gc3RyaW5nQXJyYXk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDcwNDA6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbnZhciBfYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5MUlVDYWNoZSA9IGV4cG9ydHMuTGlua2VkTWFwID0gZXhwb3J0cy5Ub3VjaCA9IHZvaWQgMDtcbnZhciBUb3VjaDtcbihmdW5jdGlvbiAoVG91Y2gpIHtcbiAgICBUb3VjaC5Ob25lID0gMDtcbiAgICBUb3VjaC5GaXJzdCA9IDE7XG4gICAgVG91Y2guQXNPbGQgPSBUb3VjaC5GaXJzdDtcbiAgICBUb3VjaC5MYXN0ID0gMjtcbiAgICBUb3VjaC5Bc05ldyA9IFRvdWNoLkxhc3Q7XG59KShUb3VjaCA9IGV4cG9ydHMuVG91Y2ggfHwgKGV4cG9ydHMuVG91Y2ggPSB7fSkpO1xuY2xhc3MgTGlua2VkTWFwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpc1tfYV0gPSAnTGlua2VkTWFwJztcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9oZWFkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl90YWlsID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9zaXplID0gMDtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSAwO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fbWFwLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2hlYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3RhaWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xuICAgICAgICB0aGlzLl9zdGF0ZSsrO1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuX2hlYWQgJiYgIXRoaXMuX3RhaWw7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVhZD8udmFsdWU7XG4gICAgfVxuICAgIGdldCBsYXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFpbD8udmFsdWU7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5oYXMoa2V5KTtcbiAgICB9XG4gICAgZ2V0KGtleSwgdG91Y2ggPSBUb3VjaC5Ob25lKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG91Y2ggIT09IFRvdWNoLk5vbmUpIHtcbiAgICAgICAgICAgIHRoaXMudG91Y2goaXRlbSwgdG91Y2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSwgdG91Y2ggPSBUb3VjaC5Ob25lKSB7XG4gICAgICAgIGxldCBpdGVtID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgaXRlbS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRvdWNoICE9PSBUb3VjaC5Ob25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b3VjaChpdGVtLCB0b3VjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVtID0geyBrZXksIHZhbHVlLCBuZXh0OiB1bmRlZmluZWQsIHByZXZpb3VzOiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgIHN3aXRjaCAodG91Y2gpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFRvdWNoLk5vbmU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUxhc3QoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVG91Y2guRmlyc3Q6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUZpcnN0KGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRvdWNoLkxhc3Q6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUxhc3QoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUxhc3QoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWFwLnNldChrZXksIGl0ZW0pO1xuICAgICAgICAgICAgdGhpcy5fc2l6ZSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMucmVtb3ZlKGtleSk7XG4gICAgfVxuICAgIHJlbW92ZShrZXkpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgdGhpcy5yZW1vdmVJdGVtKGl0ZW0pO1xuICAgICAgICB0aGlzLl9zaXplLS07XG4gICAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgIH1cbiAgICBzaGlmdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkICYmICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faGVhZCB8fCAhdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5faGVhZDtcbiAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShpdGVtLmtleSk7XG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbShpdGVtKTtcbiAgICAgICAgdGhpcy5fc2l6ZS0tO1xuICAgICAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgICB9XG4gICAgZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5faGVhZDtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzQXJnKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tmbi5iaW5kKHRoaXNBcmcpKGN1cnJlbnQudmFsdWUsIGN1cnJlbnQua2V5LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrZm4oY3VycmVudC52YWx1ZSwgY3VycmVudC5rZXksIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGlua2VkTWFwIGdvdCBtb2RpZmllZCBkdXJpbmcgaXRlcmF0aW9uLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBrZXlzKCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0ge1xuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl06ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaW5rZWRNYXAgZ290IG1vZGlmaWVkIGR1cmluZyBpdGVyYXRpb24uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgdmFsdWU6IGN1cnJlbnQua2V5LCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgIH1cbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5faGVhZDtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB7XG4gICAgICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExpbmtlZE1hcCBnb3QgbW9kaWZpZWQgZHVyaW5nIGl0ZXJhdGlvbi5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyB2YWx1ZTogY3VycmVudC52YWx1ZSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9XG4gICAgZW50cmllcygpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHtcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgIT09IHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGlua2VkTWFwIGdvdCBtb2RpZmllZCBkdXJpbmcgaXRlcmF0aW9uLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHZhbHVlOiBbY3VycmVudC5rZXksIGN1cnJlbnQudmFsdWVdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgIH1cbiAgICBbKF9hID0gU3ltYm9sLnRvU3RyaW5nVGFnLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcygpO1xuICAgIH1cbiAgICB0cmltT2xkKG5ld1NpemUpIHtcbiAgICAgICAgaWYgKG5ld1NpemUgPj0gdGhpcy5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1NpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIGxldCBjdXJyZW50U2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudFNpemUgPiBuZXdTaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGN1cnJlbnQua2V5KTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICBjdXJyZW50U2l6ZS0tO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hlYWQgPSBjdXJyZW50O1xuICAgICAgICB0aGlzLl9zaXplID0gY3VycmVudFNpemU7XG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICBjdXJyZW50LnByZXZpb3VzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgfVxuICAgIGFkZEl0ZW1GaXJzdChpdGVtKSB7XG4gICAgICAgIC8vIEZpcnN0IHRpbWUgSW5zZXJ0XG4gICAgICAgIGlmICghdGhpcy5faGVhZCAmJiAhdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2hlYWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVtLm5leHQgPSB0aGlzLl9oZWFkO1xuICAgICAgICAgICAgdGhpcy5faGVhZC5wcmV2aW91cyA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGVhZCA9IGl0ZW07XG4gICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgfVxuICAgIGFkZEl0ZW1MYXN0KGl0ZW0pIHtcbiAgICAgICAgLy8gRmlyc3QgdGltZSBJbnNlcnRcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkICYmICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMgPSB0aGlzLl90YWlsO1xuICAgICAgICAgICAgdGhpcy5fdGFpbC5uZXh0ID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90YWlsID0gaXRlbTtcbiAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICB9XG4gICAgcmVtb3ZlSXRlbShpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtID09PSB0aGlzLl9oZWFkICYmIGl0ZW0gPT09IHRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGl0ZW0gPT09IHRoaXMuX2hlYWQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuZWQgaWYgc2l6ZSA9PT0gMSB3aGljaCBpcyBoYW5kbGVcbiAgICAgICAgICAgIC8vIGJ5IHRoZSBjYXNlIGFib3ZlLlxuICAgICAgICAgICAgaWYgKCFpdGVtLm5leHQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbS5uZXh0LnByZXZpb3VzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IGl0ZW0ubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpdGVtID09PSB0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbmVkIGlmIHNpemUgPT09IDEgd2hpY2ggaXMgaGFuZGxlXG4gICAgICAgICAgICAvLyBieSB0aGUgY2FzZSBhYm92ZS5cbiAgICAgICAgICAgIGlmICghaXRlbS5wcmV2aW91cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtLnByZXZpb3VzLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gaXRlbS5wcmV2aW91cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBpdGVtLm5leHQ7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IGl0ZW0ucHJldmlvdXM7XG4gICAgICAgICAgICBpZiAoIW5leHQgfHwgIXByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGl0ZW0ubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaXRlbS5wcmV2aW91cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICB9XG4gICAgdG91Y2goaXRlbSwgdG91Y2gpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkIHx8ICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodG91Y2ggIT09IFRvdWNoLkZpcnN0ICYmIHRvdWNoICE9PSBUb3VjaC5MYXN0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3VjaCA9PT0gVG91Y2guRmlyc3QpIHtcbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl9oZWFkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGl0ZW0ubmV4dDtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gaXRlbS5wcmV2aW91cztcbiAgICAgICAgICAgIC8vIFVubGluayB0aGUgaXRlbVxuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IHRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgICAgICAvLyBwcmV2aW91cyBtdXN0IGJlIGRlZmluZWQgc2luY2UgaXRlbSB3YXMgbm90IGhlYWQgYnV0IGlzIHRhaWxcbiAgICAgICAgICAgICAgICAvLyBTbyB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uIGl0ZW0gaW4gdGhlIG1hcFxuICAgICAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFpbCA9IHByZXZpb3VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQm90aCBuZXh0IGFuZCBwcmV2aW91cyBhcmUgbm90IHVuZGVmaW5lZCBzaW5jZSBpdGVtIHdhcyBuZWl0aGVyIGhlYWQgbm9yIHRhaWwuXG4gICAgICAgICAgICAgICAgbmV4dC5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSBub2RlIGF0IGhlYWRcbiAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpdGVtLm5leHQgPSB0aGlzLl9oZWFkO1xuICAgICAgICAgICAgdGhpcy5faGVhZC5wcmV2aW91cyA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gaXRlbTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodG91Y2ggPT09IFRvdWNoLkxhc3QpIHtcbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGl0ZW0ubmV4dDtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gaXRlbS5wcmV2aW91cztcbiAgICAgICAgICAgIC8vIFVubGluayB0aGUgaXRlbS5cbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl9oZWFkKSB7XG4gICAgICAgICAgICAgICAgLy8gbmV4dCBtdXN0IGJlIGRlZmluZWQgc2luY2UgaXRlbSB3YXMgbm90IHRhaWwgYnV0IGlzIGhlYWRcbiAgICAgICAgICAgICAgICAvLyBTbyB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uIGl0ZW0gaW4gdGhlIG1hcFxuICAgICAgICAgICAgICAgIG5leHQucHJldmlvdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5faGVhZCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBCb3RoIG5leHQgYW5kIHByZXZpb3VzIGFyZSBub3QgdW5kZWZpbmVkIHNpbmNlIGl0ZW0gd2FzIG5laXRoZXIgaGVhZCBub3IgdGFpbC5cbiAgICAgICAgICAgICAgICBuZXh0LnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgICAgICAgICAgICAgcHJldmlvdXMubmV4dCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpdGVtLnByZXZpb3VzID0gdGhpcy5fdGFpbDtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwubmV4dCA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gaXRlbTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgIHRoaXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgZnJvbUpTT04oZGF0YSkge1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MaW5rZWRNYXAgPSBMaW5rZWRNYXA7XG5jbGFzcyBMUlVDYWNoZSBleHRlbmRzIExpbmtlZE1hcCB7XG4gICAgY29uc3RydWN0b3IobGltaXQsIHJhdGlvID0gMSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9saW1pdCA9IGxpbWl0O1xuICAgICAgICB0aGlzLl9yYXRpbyA9IE1hdGgubWluKE1hdGgubWF4KDAsIHJhdGlvKSwgMSk7XG4gICAgfVxuICAgIGdldCBsaW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbWl0O1xuICAgIH1cbiAgICBzZXQgbGltaXQobGltaXQpIHtcbiAgICAgICAgdGhpcy5fbGltaXQgPSBsaW1pdDtcbiAgICAgICAgdGhpcy5jaGVja1RyaW0oKTtcbiAgICB9XG4gICAgZ2V0IHJhdGlvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmF0aW87XG4gICAgfVxuICAgIHNldCByYXRpbyhyYXRpbykge1xuICAgICAgICB0aGlzLl9yYXRpbyA9IE1hdGgubWluKE1hdGgubWF4KDAsIHJhdGlvKSwgMSk7XG4gICAgICAgIHRoaXMuY2hlY2tUcmltKCk7XG4gICAgfVxuICAgIGdldChrZXksIHRvdWNoID0gVG91Y2guQXNOZXcpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldChrZXksIHRvdWNoKTtcbiAgICB9XG4gICAgcGVlayhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldChrZXksIFRvdWNoLk5vbmUpO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBzdXBlci5zZXQoa2V5LCB2YWx1ZSwgVG91Y2guTGFzdCk7XG4gICAgICAgIHRoaXMuY2hlY2tUcmltKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjaGVja1RyaW0oKSB7XG4gICAgICAgIGlmICh0aGlzLnNpemUgPiB0aGlzLl9saW1pdCkge1xuICAgICAgICAgICAgdGhpcy50cmltT2xkKE1hdGgucm91bmQodGhpcy5fbGltaXQgKiB0aGlzLl9yYXRpbykpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MUlVDYWNoZSA9IExSVUNhY2hlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NjUyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlQnVmZmVyID0gdm9pZCAwO1xuY29uc3QgQ1IgPSAxMztcbmNvbnN0IExGID0gMTA7XG5jb25zdCBDUkxGID0gJ1xcclxcbic7XG5jbGFzcyBBYnN0cmFjdE1lc3NhZ2VCdWZmZXIge1xuICAgIGNvbnN0cnVjdG9yKGVuY29kaW5nID0gJ3V0Zi04Jykge1xuICAgICAgICB0aGlzLl9lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgICAgICB0aGlzLl9jaHVua3MgPSBbXTtcbiAgICAgICAgdGhpcy5fdG90YWxMZW5ndGggPSAwO1xuICAgIH1cbiAgICBnZXQgZW5jb2RpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmNvZGluZztcbiAgICB9XG4gICAgYXBwZW5kKGNodW5rKSB7XG4gICAgICAgIGNvbnN0IHRvQXBwZW5kID0gdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJyA/IHRoaXMuZnJvbVN0cmluZyhjaHVuaywgdGhpcy5fZW5jb2RpbmcpIDogY2h1bms7XG4gICAgICAgIHRoaXMuX2NodW5rcy5wdXNoKHRvQXBwZW5kKTtcbiAgICAgICAgdGhpcy5fdG90YWxMZW5ndGggKz0gdG9BcHBlbmQuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgdHJ5UmVhZEhlYWRlcnMobG93ZXJDYXNlS2V5cyA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLl9jaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGF0ZSA9IDA7XG4gICAgICAgIGxldCBjaHVua0luZGV4ID0gMDtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGxldCBjaHVua0J5dGVzUmVhZCA9IDA7XG4gICAgICAgIHJvdzogd2hpbGUgKGNodW5rSW5kZXggPCB0aGlzLl9jaHVua3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2NodW5rc1tjaHVua0luZGV4XTtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICBjb2x1bW46IHdoaWxlIChvZmZzZXQgPCBjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNodW5rW29mZnNldF07XG4gICAgICAgICAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENSOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTEY6XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgcm93O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNodW5rQnl0ZXNSZWFkICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBjaHVua0luZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlICE9PSA0KSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBidWZmZXIgY29udGFpbnMgdGhlIHR3byBDUkxGIGF0IHRoZSBlbmQuIFNvIHdlIHdpbGxcbiAgICAgICAgLy8gaGF2ZSB0d28gZW1wdHkgbGluZXMgYWZ0ZXIgdGhlIHNwbGl0IGF0IHRoZSBlbmQgYXMgd2VsbC5cbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5fcmVhZChjaHVua0J5dGVzUmVhZCArIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMudG9TdHJpbmcoYnVmZmVyLCAnYXNjaWknKS5zcGxpdChDUkxGKTtcbiAgICAgICAgaWYgKGhlYWRlcnMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXIgPSBoZWFkZXJzW2ldO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBoZWFkZXIuaW5kZXhPZignOicpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWVzc2FnZSBoZWFkZXIgbXVzdCBzZXBhcmF0ZSBrZXkgYW5kIHZhbHVlIHVzaW5nIDonKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGhlYWRlci5zdWJzdHIoMCwgaW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBoZWFkZXIuc3Vic3RyKGluZGV4ICsgMSkudHJpbSgpO1xuICAgICAgICAgICAgcmVzdWx0LnNldChsb3dlckNhc2VLZXlzID8ga2V5LnRvTG93ZXJDYXNlKCkgOiBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0cnlSZWFkQm9keShsZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RvdGFsTGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkKGxlbmd0aCk7XG4gICAgfVxuICAgIGdldCBudW1iZXJPZkJ5dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG90YWxMZW5ndGg7XG4gICAgfVxuICAgIF9yZWFkKGJ5dGVDb3VudCkge1xuICAgICAgICBpZiAoYnl0ZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbXB0eUJ1ZmZlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChieXRlQ291bnQgPiB0aGlzLl90b3RhbExlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVhZCBzbyBtYW55IGJ5dGVzIWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jaHVua3NbMF0uYnl0ZUxlbmd0aCA9PT0gYnl0ZUNvdW50KSB7XG4gICAgICAgICAgICAvLyBzdXBlciBmYXN0IHBhdGgsIHByZWNpc2VseSBmaXJzdCBjaHVuayBtdXN0IGJlIHJldHVybmVkXG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2NodW5rc1swXTtcbiAgICAgICAgICAgIHRoaXMuX2NodW5rcy5zaGlmdCgpO1xuICAgICAgICAgICAgdGhpcy5fdG90YWxMZW5ndGggLT0gYnl0ZUNvdW50O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXNOYXRpdmUoY2h1bmspO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jaHVua3NbMF0uYnl0ZUxlbmd0aCA+IGJ5dGVDb3VudCkge1xuICAgICAgICAgICAgLy8gZmFzdCBwYXRoLCB0aGUgcmVhZGluZyBpcyBlbnRpcmVseSB3aXRoaW4gdGhlIGZpcnN0IGNodW5rXG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2NodW5rc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYXNOYXRpdmUoY2h1bmssIGJ5dGVDb3VudCk7XG4gICAgICAgICAgICB0aGlzLl9jaHVua3NbMF0gPSBjaHVuay5zbGljZShieXRlQ291bnQpO1xuICAgICAgICAgICAgdGhpcy5fdG90YWxMZW5ndGggLT0gYnl0ZUNvdW50O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmFsbG9jTmF0aXZlKGJ5dGVDb3VudCk7XG4gICAgICAgIGxldCByZXN1bHRPZmZzZXQgPSAwO1xuICAgICAgICBsZXQgY2h1bmtJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChieXRlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2NodW5rc1tjaHVua0luZGV4XTtcbiAgICAgICAgICAgIGlmIChjaHVuay5ieXRlTGVuZ3RoID4gYnl0ZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjaHVuayB3aWxsIHN1cnZpdmVcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVua1BhcnQgPSBjaHVuay5zbGljZSgwLCBieXRlQ291bnQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoY2h1bmtQYXJ0LCByZXN1bHRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdE9mZnNldCArPSBieXRlQ291bnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2h1bmtzW2NodW5rSW5kZXhdID0gY2h1bmsuc2xpY2UoYnl0ZUNvdW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLl90b3RhbExlbmd0aCAtPSBieXRlQ291bnQ7XG4gICAgICAgICAgICAgICAgYnl0ZUNvdW50IC09IGJ5dGVDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgY2h1bmsgd2lsbCBiZSBlbnRpcmVseSByZWFkXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChjaHVuaywgcmVzdWx0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICByZXN1bHRPZmZzZXQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaHVua3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90b3RhbExlbmd0aCAtPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJ5dGVDb3VudCAtPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VCdWZmZXIgPSBBYnN0cmFjdE1lc3NhZ2VCdWZmZXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ1MTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5SZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXIgPSBleHBvcnRzLkFic3RyYWN0TWVzc2FnZVJlYWRlciA9IGV4cG9ydHMuTWVzc2FnZVJlYWRlciA9IHZvaWQgMDtcbmNvbnN0IHJhbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NzA2KTtcbmNvbnN0IElzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4ODExKTtcbmNvbnN0IGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MTY1KTtcbmNvbnN0IHNlbWFwaG9yZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMzM5KTtcbnZhciBNZXNzYWdlUmVhZGVyO1xuKGZ1bmN0aW9uIChNZXNzYWdlUmVhZGVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLmZ1bmMoY2FuZGlkYXRlLmxpc3RlbikgJiYgSXMuZnVuYyhjYW5kaWRhdGUuZGlzcG9zZSkgJiZcbiAgICAgICAgICAgIElzLmZ1bmMoY2FuZGlkYXRlLm9uRXJyb3IpICYmIElzLmZ1bmMoY2FuZGlkYXRlLm9uQ2xvc2UpICYmIElzLmZ1bmMoY2FuZGlkYXRlLm9uUGFydGlhbE1lc3NhZ2UpO1xuICAgIH1cbiAgICBNZXNzYWdlUmVhZGVyLmlzID0gaXM7XG59KShNZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5NZXNzYWdlUmVhZGVyIHx8IChleHBvcnRzLk1lc3NhZ2VSZWFkZXIgPSB7fSkpO1xuY2xhc3MgQWJzdHJhY3RNZXNzYWdlUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lcnJvckVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgICAgICB0aGlzLmNsb3NlRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgICAgIHRoaXMucGFydGlhbE1lc3NhZ2VFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5lcnJvckVtaXR0ZXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmNsb3NlRW1pdHRlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGdldCBvbkVycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvckVtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGZpcmVFcnJvcihlcnJvcikge1xuICAgICAgICB0aGlzLmVycm9yRW1pdHRlci5maXJlKHRoaXMuYXNFcnJvcihlcnJvcikpO1xuICAgIH1cbiAgICBnZXQgb25DbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2VFbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBmaXJlQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VFbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICB9XG4gICAgZ2V0IG9uUGFydGlhbE1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnRpYWxNZXNzYWdlRW1pdHRlci5ldmVudDtcbiAgICB9XG4gICAgZmlyZVBhcnRpYWxNZXNzYWdlKGluZm8pIHtcbiAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZUVtaXR0ZXIuZmlyZShpbmZvKTtcbiAgICB9XG4gICAgYXNFcnJvcihlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgUmVhZGVyIHJlY2VpdmVkIGVycm9yLiBSZWFzb246ICR7SXMuc3RyaW5nKGVycm9yLm1lc3NhZ2UpID8gZXJyb3IubWVzc2FnZSA6ICd1bmtub3duJ31gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlUmVhZGVyID0gQWJzdHJhY3RNZXNzYWdlUmVhZGVyO1xudmFyIFJlc29sdmVkTWVzc2FnZVJlYWRlck9wdGlvbnM7XG4oZnVuY3Rpb24gKFJlc29sdmVkTWVzc2FnZVJlYWRlck9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBmcm9tT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGxldCBjaGFyc2V0O1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBsZXQgY29udGVudERlY29kZXI7XG4gICAgICAgIGNvbnN0IGNvbnRlbnREZWNvZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgbGV0IGNvbnRlbnRUeXBlRGVjb2RlcjtcbiAgICAgICAgY29uc3QgY29udGVudFR5cGVEZWNvZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNoYXJzZXQgPSBvcHRpb25zID8/ICd1dGYtOCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFyc2V0ID0gb3B0aW9ucy5jaGFyc2V0ID8/ICd1dGYtOCc7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb250ZW50RGVjb2RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGVudERlY29kZXIgPSBvcHRpb25zLmNvbnRlbnREZWNvZGVyO1xuICAgICAgICAgICAgICAgIGNvbnRlbnREZWNvZGVycy5zZXQoY29udGVudERlY29kZXIubmFtZSwgY29udGVudERlY29kZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29udGVudERlY29kZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRlY29kZXIgb2Ygb3B0aW9ucy5jb250ZW50RGVjb2RlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudERlY29kZXJzLnNldChkZWNvZGVyLm5hbWUsIGRlY29kZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbnRlbnRUeXBlRGVjb2RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVEZWNvZGVyID0gb3B0aW9ucy5jb250ZW50VHlwZURlY29kZXI7XG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVEZWNvZGVycy5zZXQoY29udGVudFR5cGVEZWNvZGVyLm5hbWUsIGNvbnRlbnRUeXBlRGVjb2Rlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb250ZW50VHlwZURlY29kZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRlY29kZXIgb2Ygb3B0aW9ucy5jb250ZW50VHlwZURlY29kZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlRGVjb2RlcnMuc2V0KGRlY29kZXIubmFtZSwgZGVjb2Rlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZW50VHlwZURlY29kZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGVudFR5cGVEZWNvZGVyID0gKDAsIHJhbF8xLmRlZmF1bHQpKCkuYXBwbGljYXRpb25Kc29uLmRlY29kZXI7XG4gICAgICAgICAgICBjb250ZW50VHlwZURlY29kZXJzLnNldChjb250ZW50VHlwZURlY29kZXIubmFtZSwgY29udGVudFR5cGVEZWNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjaGFyc2V0LCBjb250ZW50RGVjb2RlciwgY29udGVudERlY29kZXJzLCBjb250ZW50VHlwZURlY29kZXIsIGNvbnRlbnRUeXBlRGVjb2RlcnMgfTtcbiAgICB9XG4gICAgUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucy5mcm9tT3B0aW9ucyA9IGZyb21PcHRpb25zO1xufSkoUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucyB8fCAoUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucyA9IHt9KSk7XG5jbGFzcyBSZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXIgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VSZWFkZXIge1xuICAgIGNvbnN0cnVjdG9yKHJlYWRhYmxlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucmVhZGFibGUgPSByZWFkYWJsZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucy5mcm9tT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSAoMCwgcmFsXzEuZGVmYXVsdCkoKS5tZXNzYWdlQnVmZmVyLmNyZWF0ZSh0aGlzLm9wdGlvbnMuY2hhcnNldCk7XG4gICAgICAgIHRoaXMuX3BhcnRpYWxNZXNzYWdlVGltZW91dCA9IDEwMDAwO1xuICAgICAgICB0aGlzLm5leHRNZXNzYWdlTGVuZ3RoID0gLTE7XG4gICAgICAgIHRoaXMubWVzc2FnZVRva2VuID0gMDtcbiAgICAgICAgdGhpcy5yZWFkU2VtYXBob3JlID0gbmV3IHNlbWFwaG9yZV8xLlNlbWFwaG9yZSgxKTtcbiAgICB9XG4gICAgc2V0IHBhcnRpYWxNZXNzYWdlVGltZW91dCh0aW1lb3V0KSB7XG4gICAgICAgIHRoaXMuX3BhcnRpYWxNZXNzYWdlVGltZW91dCA9IHRpbWVvdXQ7XG4gICAgfVxuICAgIGdldCBwYXJ0aWFsTWVzc2FnZVRpbWVvdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJ0aWFsTWVzc2FnZVRpbWVvdXQ7XG4gICAgfVxuICAgIGxpc3RlbihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm5leHRNZXNzYWdlTGVuZ3RoID0gLTE7XG4gICAgICAgIHRoaXMubWVzc2FnZVRva2VuID0gMDtcbiAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucmVhZGFibGUub25EYXRhKChkYXRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uRGF0YShkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVhZGFibGUub25FcnJvcigoZXJyb3IpID0+IHRoaXMuZmlyZUVycm9yKGVycm9yKSk7XG4gICAgICAgIHRoaXMucmVhZGFibGUub25DbG9zZSgoKSA9PiB0aGlzLmZpcmVDbG9zZSgpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgb25EYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5idWZmZXIuYXBwZW5kKGRhdGEpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubmV4dE1lc3NhZ2VMZW5ndGggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuYnVmZmVyLnRyeVJlYWRIZWFkZXJzKHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBoZWFkZXJzLmdldCgnY29udGVudC1sZW5ndGgnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlRXJyb3IobmV3IEVycm9yKCdIZWFkZXIgbXVzdCBwcm92aWRlIGEgQ29udGVudC1MZW5ndGggcHJvcGVydHkuJykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KGNvbnRlbnRMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihsZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZUVycm9yKG5ldyBFcnJvcignQ29udGVudC1MZW5ndGggdmFsdWUgbXVzdCBiZSBhIG51bWJlci4nKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0TWVzc2FnZUxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLmJ1ZmZlci50cnlSZWFkQm9keSh0aGlzLm5leHRNZXNzYWdlTGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChib2R5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvKiogV2UgaGF2ZW4ndCByZWNlaXZlZCB0aGUgZnVsbCBtZXNzYWdlIHlldC4gKi9cbiAgICAgICAgICAgICAgICB0aGlzLnNldFBhcnRpYWxNZXNzYWdlVGltZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsZWFyUGFydGlhbE1lc3NhZ2VUaW1lcigpO1xuICAgICAgICAgICAgdGhpcy5uZXh0TWVzc2FnZUxlbmd0aCA9IC0xO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UgY29udmVydCBvbmUgcmVjZWl2ZWQgbWVzc2FnZSBhZnRlciB0aGVcbiAgICAgICAgICAgIC8vIG90aGVyLiBPdGhlcndpc2UgaXQgY291bGQgaGFwcGVuIHRoYXQgYSBkZWNvZGluZyBvZiBhIHNlY29uZFxuICAgICAgICAgICAgLy8gc21hbGxlciBtZXNzYWdlIGZpbmlzaGVkIGJlZm9yZSB0aGUgZGVjb2Rpbmcgb2YgYSBmaXJzdCBsYXJnZXJcbiAgICAgICAgICAgIC8vIG1lc3NhZ2UgYW5kIHRoZW4gd2Ugd291bGQgZGVsaXZlciB0aGUgc2Vjb25kIG1lc3NhZ2UgZmlyc3QuXG4gICAgICAgICAgICB0aGlzLnJlYWRTZW1hcGhvcmUubG9jayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSB0aGlzLm9wdGlvbnMuY29udGVudERlY29kZXIgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IGF3YWl0IHRoaXMub3B0aW9ucy5jb250ZW50RGVjb2Rlci5kZWNvZGUoYm9keSlcbiAgICAgICAgICAgICAgICAgICAgOiBib2R5O1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCB0aGlzLm9wdGlvbnMuY29udGVudFR5cGVEZWNvZGVyLmRlY29kZShieXRlcywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXJQYXJ0aWFsTWVzc2FnZVRpbWVyKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnRpYWxNZXNzYWdlVGltZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFBhcnRpYWxNZXNzYWdlVGltZXIoKSB7XG4gICAgICAgIHRoaXMuY2xlYXJQYXJ0aWFsTWVzc2FnZVRpbWVyKCk7XG4gICAgICAgIGlmICh0aGlzLl9wYXJ0aWFsTWVzc2FnZVRpbWVvdXQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFydGlhbE1lc3NhZ2VUaW1lciA9ICgwLCByYWxfMS5kZWZhdWx0KSgpLnRpbWVyLnNldFRpbWVvdXQoKHRva2VuLCB0aW1lb3V0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRpYWxNZXNzYWdlVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IHRoaXMubWVzc2FnZVRva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlUGFydGlhbE1lc3NhZ2UoeyBtZXNzYWdlVG9rZW46IHRva2VuLCB3YWl0aW5nVGltZTogdGltZW91dCB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFBhcnRpYWxNZXNzYWdlVGltZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5fcGFydGlhbE1lc3NhZ2VUaW1lb3V0LCB0aGlzLm1lc3NhZ2VUb2tlbiwgdGhpcy5fcGFydGlhbE1lc3NhZ2VUaW1lb3V0KTtcbiAgICB9XG59XG5leHBvcnRzLlJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlciA9IFJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTI1MTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5Xcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyID0gZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLk1lc3NhZ2VXcml0ZXIgPSB2b2lkIDA7XG5jb25zdCByYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTcwNik7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oODgxMSk7XG5jb25zdCBzZW1hcGhvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjMzOSk7XG5jb25zdCBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTE2NSk7XG5jb25zdCBDb250ZW50TGVuZ3RoID0gJ0NvbnRlbnQtTGVuZ3RoOiAnO1xuY29uc3QgQ1JMRiA9ICdcXHJcXG4nO1xudmFyIE1lc3NhZ2VXcml0ZXI7XG4oZnVuY3Rpb24gKE1lc3NhZ2VXcml0ZXIpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuZnVuYyhjYW5kaWRhdGUuZGlzcG9zZSkgJiYgSXMuZnVuYyhjYW5kaWRhdGUub25DbG9zZSkgJiZcbiAgICAgICAgICAgIElzLmZ1bmMoY2FuZGlkYXRlLm9uRXJyb3IpICYmIElzLmZ1bmMoY2FuZGlkYXRlLndyaXRlKTtcbiAgICB9XG4gICAgTWVzc2FnZVdyaXRlci5pcyA9IGlzO1xufSkoTWVzc2FnZVdyaXRlciA9IGV4cG9ydHMuTWVzc2FnZVdyaXRlciB8fCAoZXhwb3J0cy5NZXNzYWdlV3JpdGVyID0ge30pKTtcbmNsYXNzIEFic3RyYWN0TWVzc2FnZVdyaXRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZXJyb3JFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5jbG9zZUVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLmVycm9yRW1pdHRlci5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuY2xvc2VFbWl0dGVyLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgZ2V0IG9uRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yRW1pdHRlci5ldmVudDtcbiAgICB9XG4gICAgZmlyZUVycm9yKGVycm9yLCBtZXNzYWdlLCBjb3VudCkge1xuICAgICAgICB0aGlzLmVycm9yRW1pdHRlci5maXJlKFt0aGlzLmFzRXJyb3IoZXJyb3IpLCBtZXNzYWdlLCBjb3VudF0pO1xuICAgIH1cbiAgICBnZXQgb25DbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2VFbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBmaXJlQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VFbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICB9XG4gICAgYXNFcnJvcihlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgV3JpdGVyIHJlY2VpdmVkIGVycm9yLiBSZWFzb246ICR7SXMuc3RyaW5nKGVycm9yLm1lc3NhZ2UpID8gZXJyb3IubWVzc2FnZSA6ICd1bmtub3duJ31gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlV3JpdGVyID0gQWJzdHJhY3RNZXNzYWdlV3JpdGVyO1xudmFyIFJlc29sdmVkTWVzc2FnZVdyaXRlck9wdGlvbnM7XG4oZnVuY3Rpb24gKFJlc29sdmVkTWVzc2FnZVdyaXRlck9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBmcm9tT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFyc2V0OiBvcHRpb25zID8/ICd1dGYtOCcsIGNvbnRlbnRUeXBlRW5jb2RlcjogKDAsIHJhbF8xLmRlZmF1bHQpKCkuYXBwbGljYXRpb25Kc29uLmVuY29kZXIgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNoYXJzZXQ6IG9wdGlvbnMuY2hhcnNldCA/PyAndXRmLTgnLCBjb250ZW50RW5jb2Rlcjogb3B0aW9ucy5jb250ZW50RW5jb2RlciwgY29udGVudFR5cGVFbmNvZGVyOiBvcHRpb25zLmNvbnRlbnRUeXBlRW5jb2RlciA/PyAoMCwgcmFsXzEuZGVmYXVsdCkoKS5hcHBsaWNhdGlvbkpzb24uZW5jb2RlciB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIFJlc29sdmVkTWVzc2FnZVdyaXRlck9wdGlvbnMuZnJvbU9wdGlvbnMgPSBmcm9tT3B0aW9ucztcbn0pKFJlc29sdmVkTWVzc2FnZVdyaXRlck9wdGlvbnMgfHwgKFJlc29sdmVkTWVzc2FnZVdyaXRlck9wdGlvbnMgPSB7fSkpO1xuY2xhc3MgV3JpdGVhYmxlU3RyZWFtTWVzc2FnZVdyaXRlciBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVdyaXRlciB7XG4gICAgY29uc3RydWN0b3Iod3JpdGFibGUsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IHdyaXRhYmxlO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBSZXNvbHZlZE1lc3NhZ2VXcml0ZXJPcHRpb25zLmZyb21PcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmVycm9yQ291bnQgPSAwO1xuICAgICAgICB0aGlzLndyaXRlU2VtYXBob3JlID0gbmV3IHNlbWFwaG9yZV8xLlNlbWFwaG9yZSgxKTtcbiAgICAgICAgdGhpcy53cml0YWJsZS5vbkVycm9yKChlcnJvcikgPT4gdGhpcy5maXJlRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgdGhpcy53cml0YWJsZS5vbkNsb3NlKCgpID0+IHRoaXMuZmlyZUNsb3NlKCkpO1xuICAgIH1cbiAgICBhc3luYyB3cml0ZShtc2cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVTZW1hcGhvcmUubG9jayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gdGhpcy5vcHRpb25zLmNvbnRlbnRUeXBlRW5jb2Rlci5lbmNvZGUobXNnLCB0aGlzLm9wdGlvbnMpLnRoZW4oKGJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29udGVudEVuY29kZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmNvbnRlbnRFbmNvZGVyLmVuY29kZShidWZmZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkLnRoZW4oKGJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLnB1c2goQ29udGVudExlbmd0aCwgYnVmZmVyLmJ5dGVMZW5ndGgudG9TdHJpbmcoKSwgQ1JMRik7XG4gICAgICAgICAgICAgICAgaGVhZGVycy5wdXNoKENSTEYpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRvV3JpdGUobXNnLCBoZWFkZXJzLCBidWZmZXIpO1xuICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBkb1dyaXRlKG1zZywgaGVhZGVycywgZGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy53cml0YWJsZS53cml0ZShoZWFkZXJzLmpvaW4oJycpLCAnYXNjaWknKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndyaXRhYmxlLndyaXRlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlcnJvciwgbXNnKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlRXJyb3IoZXJyb3IsIG1zZykge1xuICAgICAgICB0aGlzLmVycm9yQ291bnQrKztcbiAgICAgICAgdGhpcy5maXJlRXJyb3IoZXJyb3IsIG1zZywgdGhpcy5lcnJvckNvdW50KTtcbiAgICB9XG4gICAgZW5kKCkge1xuICAgICAgICB0aGlzLndyaXRhYmxlLmVuZCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuV3JpdGVhYmxlU3RyZWFtTWVzc2FnZVdyaXRlciA9IFdyaXRlYWJsZVN0cmVhbU1lc3NhZ2VXcml0ZXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkxNDE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuTWVzc2FnZSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTkgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU4ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNyA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTYgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU1ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNCA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTMgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUyID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTAgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUgPSBleHBvcnRzLlJlcXVlc3RUeXBlOSA9IGV4cG9ydHMuUmVxdWVzdFR5cGU4ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTcgPSBleHBvcnRzLlJlcXVlc3RUeXBlNiA9IGV4cG9ydHMuUmVxdWVzdFR5cGU1ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTQgPSBleHBvcnRzLlJlcXVlc3RUeXBlMyA9IGV4cG9ydHMuUmVxdWVzdFR5cGUyID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTEgPSBleHBvcnRzLlJlcXVlc3RUeXBlID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTAgPSBleHBvcnRzLkFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSA9IGV4cG9ydHMuUGFyYW1ldGVyU3RydWN0dXJlcyA9IGV4cG9ydHMuUmVzcG9uc2VFcnJvciA9IGV4cG9ydHMuRXJyb3JDb2RlcyA9IHZvaWQgMDtcbmNvbnN0IGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4ODExKTtcbi8qKlxuICogUHJlZGVmaW5lZCBlcnJvciBjb2Rlcy5cbiAqL1xudmFyIEVycm9yQ29kZXM7XG4oZnVuY3Rpb24gKEVycm9yQ29kZXMpIHtcbiAgICAvLyBEZWZpbmVkIGJ5IEpTT04gUlBDXG4gICAgRXJyb3JDb2Rlcy5QYXJzZUVycm9yID0gLTMyNzAwO1xuICAgIEVycm9yQ29kZXMuSW52YWxpZFJlcXVlc3QgPSAtMzI2MDA7XG4gICAgRXJyb3JDb2Rlcy5NZXRob2ROb3RGb3VuZCA9IC0zMjYwMTtcbiAgICBFcnJvckNvZGVzLkludmFsaWRQYXJhbXMgPSAtMzI2MDI7XG4gICAgRXJyb3JDb2Rlcy5JbnRlcm5hbEVycm9yID0gLTMyNjAzO1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIHN0YXJ0IHJhbmdlIG9mIEpTT04gUlBDIHJlc2VydmVkIGVycm9yIGNvZGVzLlxuICAgICAqIEl0IGRvZXNuJ3QgZGVub3RlIGEgcmVhbCBlcnJvciBjb2RlLiBObyBhcHBsaWNhdGlvbiBlcnJvciBjb2RlcyBzaG91bGRcbiAgICAgKiBiZSBkZWZpbmVkIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgcmFuZ2UuIEZvciBiYWNrd2FyZHNcbiAgICAgKiBjb21wYXRpYmlsaXR5IHRoZSBgU2VydmVyTm90SW5pdGlhbGl6ZWRgIGFuZCB0aGUgYFVua25vd25FcnJvckNvZGVgXG4gICAgICogYXJlIGxlZnQgaW4gdGhlIHJhbmdlLlxuICAgICAqXG4gICAgICogQHNpbmNlIDMuMTYuMFxuICAgICovXG4gICAgRXJyb3JDb2Rlcy5qc29ucnBjUmVzZXJ2ZWRFcnJvclJhbmdlU3RhcnQgPSAtMzIwOTk7XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSAganNvbnJwY1Jlc2VydmVkRXJyb3JSYW5nZVN0YXJ0ICovXG4gICAgRXJyb3JDb2Rlcy5zZXJ2ZXJFcnJvclN0YXJ0ID0gLTMyMDk5O1xuICAgIC8qKlxuICAgICAqIEFuIGVycm9yIG9jY3VycmVkIHdoZW4gd3JpdGUgYSBtZXNzYWdlIHRvIHRoZSB0cmFuc3BvcnQgbGF5ZXIuXG4gICAgICovXG4gICAgRXJyb3JDb2Rlcy5NZXNzYWdlV3JpdGVFcnJvciA9IC0zMjA5OTtcbiAgICAvKipcbiAgICAgKiBBbiBlcnJvciBvY2N1cnJlZCB3aGVuIHJlYWRpbmcgYSBtZXNzYWdlIGZyb20gdGhlIHRyYW5zcG9ydCBsYXllci5cbiAgICAgKi9cbiAgICBFcnJvckNvZGVzLk1lc3NhZ2VSZWFkRXJyb3IgPSAtMzIwOTg7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbm5lY3Rpb24gZ290IGRpc3Bvc2VkIG9yIGxvc3QgYW5kIGFsbCBwZW5kaW5nIHJlc3BvbnNlcyBnb3RcbiAgICAgKiByZWplY3RlZC5cbiAgICAgKi9cbiAgICBFcnJvckNvZGVzLlBlbmRpbmdSZXNwb25zZVJlamVjdGVkID0gLTMyMDk3O1xuICAgIC8qKlxuICAgICAqIFRoZSBjb25uZWN0aW9uIGlzIGluYWN0aXZlIGFuZCBhIHVzZSBvZiBpdCBmYWlsZWQuXG4gICAgICovXG4gICAgRXJyb3JDb2Rlcy5Db25uZWN0aW9uSW5hY3RpdmUgPSAtMzIwOTY7XG4gICAgLyoqXG4gICAgICogRXJyb3IgY29kZSBpbmRpY2F0aW5nIHRoYXQgYSBzZXJ2ZXIgcmVjZWl2ZWQgYSBub3RpZmljYXRpb24gb3JcbiAgICAgKiByZXF1ZXN0IGJlZm9yZSB0aGUgc2VydmVyIGhhcyByZWNlaXZlZCB0aGUgYGluaXRpYWxpemVgIHJlcXVlc3QuXG4gICAgICovXG4gICAgRXJyb3JDb2Rlcy5TZXJ2ZXJOb3RJbml0aWFsaXplZCA9IC0zMjAwMjtcbiAgICBFcnJvckNvZGVzLlVua25vd25FcnJvckNvZGUgPSAtMzIwMDE7XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgZW5kIHJhbmdlIG9mIEpTT04gUlBDIHJlc2VydmVkIGVycm9yIGNvZGVzLlxuICAgICAqIEl0IGRvZXNuJ3QgZGVub3RlIGEgcmVhbCBlcnJvciBjb2RlLlxuICAgICAqXG4gICAgICogQHNpbmNlIDMuMTYuMFxuICAgICovXG4gICAgRXJyb3JDb2Rlcy5qc29ucnBjUmVzZXJ2ZWRFcnJvclJhbmdlRW5kID0gLTMyMDAwO1xuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgIGpzb25ycGNSZXNlcnZlZEVycm9yUmFuZ2VFbmQgKi9cbiAgICBFcnJvckNvZGVzLnNlcnZlckVycm9yRW5kID0gLTMyMDAwO1xufSkoRXJyb3JDb2RlcyA9IGV4cG9ydHMuRXJyb3JDb2RlcyB8fCAoZXhwb3J0cy5FcnJvckNvZGVzID0ge30pKTtcbi8qKlxuICogQW4gZXJyb3Igb2JqZWN0IHJldHVybiBpbiBhIHJlc3BvbnNlIGluIGNhc2UgYSByZXF1ZXN0XG4gKiBoYXMgZmFpbGVkLlxuICovXG5jbGFzcyBSZXNwb25zZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2UsIGRhdGEpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY29kZSA9IGlzLm51bWJlcihjb2RlKSA/IGNvZGUgOiBFcnJvckNvZGVzLlVua25vd25FcnJvckNvZGU7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBSZXNwb25zZUVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIHRvSnNvbigpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgY29kZTogdGhpcy5jb2RlLFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLlJlc3BvbnNlRXJyb3IgPSBSZXNwb25zZUVycm9yO1xuY2xhc3MgUGFyYW1ldGVyU3RydWN0dXJlcyB7XG4gICAgY29uc3RydWN0b3Ioa2luZCkge1xuICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgIH1cbiAgICBzdGF0aWMgaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG8gfHwgdmFsdWUgPT09IFBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lIHx8IHZhbHVlID09PSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5UG9zaXRpb247XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5raW5kO1xuICAgIH1cbn1cbmV4cG9ydHMuUGFyYW1ldGVyU3RydWN0dXJlcyA9IFBhcmFtZXRlclN0cnVjdHVyZXM7XG4vKipcbiAqIFRoZSBwYXJhbWV0ZXIgc3RydWN0dXJlIGlzIGF1dG9tYXRpY2FsbHkgaW5mZXJyZWQgb24gdGhlIG51bWJlciBvZiBwYXJhbWV0ZXJzXG4gKiBhbmQgdGhlIHBhcmFtZXRlciB0eXBlIGluIGNhc2Ugb2YgYSBzaW5nbGUgcGFyYW0uXG4gKi9cblBhcmFtZXRlclN0cnVjdHVyZXMuYXV0byA9IG5ldyBQYXJhbWV0ZXJTdHJ1Y3R1cmVzKCdhdXRvJyk7XG4vKipcbiAqIEZvcmNlcyBgYnlQb3NpdGlvbmAgcGFyYW1ldGVyIHN0cnVjdHVyZS4gVGhpcyBpcyB1c2VmdWwgaWYgeW91IGhhdmUgYSBzaW5nbGVcbiAqIHBhcmFtZXRlciB3aGljaCBoYXMgYSBsaXRlcmFsIHR5cGUuXG4gKi9cblBhcmFtZXRlclN0cnVjdHVyZXMuYnlQb3NpdGlvbiA9IG5ldyBQYXJhbWV0ZXJTdHJ1Y3R1cmVzKCdieVBvc2l0aW9uJyk7XG4vKipcbiAqIEZvcmNlcyBgYnlOYW1lYCBwYXJhbWV0ZXIgc3RydWN0dXJlLiBUaGlzIGlzIG9ubHkgdXNlZnVsIHdoZW4gaGF2aW5nIGEgc2luZ2xlXG4gKiBwYXJhbWV0ZXIuIFRoZSBsaWJyYXJ5IHdpbGwgcmVwb3J0IGVycm9ycyBpZiB1c2VkIHdpdGggYSBkaWZmZXJlbnQgbnVtYmVyIG9mXG4gKiBwYXJhbWV0ZXJzLlxuICovXG5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSA9IG5ldyBQYXJhbWV0ZXJTdHJ1Y3R1cmVzKCdieU5hbWUnKTtcbi8qKlxuICogQW4gYWJzdHJhY3QgaW1wbGVtZW50YXRpb24gb2YgYSBNZXNzYWdlVHlwZS5cbiAqL1xuY2xhc3MgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QsIG51bWJlck9mUGFyYW1zKSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICB0aGlzLm51bWJlck9mUGFyYW1zID0gbnVtYmVyT2ZQYXJhbXM7XG4gICAgfVxuICAgIGdldCBwYXJhbWV0ZXJTdHJ1Y3R1cmVzKCkge1xuICAgICAgICByZXR1cm4gUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvO1xuICAgIH1cbn1cbmV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlID0gQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlO1xuLyoqXG4gKiBDbGFzc2VzIHRvIHR5cGUgcmVxdWVzdCByZXNwb25zZSBwYWlyc1xuICovXG5jbGFzcyBSZXF1ZXN0VHlwZTAgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDApO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGUwID0gUmVxdWVzdFR5cGUwO1xuY2xhc3MgUmVxdWVzdFR5cGUgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG8pIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAxKTtcbiAgICAgICAgdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcyA9IF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbiAgICBnZXQgcGFyYW1ldGVyU3RydWN0dXJlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZSA9IFJlcXVlc3RUeXBlO1xuY2xhc3MgUmVxdWVzdFR5cGUxIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QsIF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMSk7XG4gICAgICAgIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBfcGFyYW1ldGVyU3RydWN0dXJlcztcbiAgICB9XG4gICAgZ2V0IHBhcmFtZXRlclN0cnVjdHVyZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGUxID0gUmVxdWVzdFR5cGUxO1xuY2xhc3MgUmVxdWVzdFR5cGUyIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAyKTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlMiA9IFJlcXVlc3RUeXBlMjtcbmNsYXNzIFJlcXVlc3RUeXBlMyBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMyk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTMgPSBSZXF1ZXN0VHlwZTM7XG5jbGFzcyBSZXF1ZXN0VHlwZTQgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDQpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGU0ID0gUmVxdWVzdFR5cGU0O1xuY2xhc3MgUmVxdWVzdFR5cGU1IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA1KTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlNSA9IFJlcXVlc3RUeXBlNTtcbmNsYXNzIFJlcXVlc3RUeXBlNiBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNik7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTYgPSBSZXF1ZXN0VHlwZTY7XG5jbGFzcyBSZXF1ZXN0VHlwZTcgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDcpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGU3ID0gUmVxdWVzdFR5cGU3O1xuY2xhc3MgUmVxdWVzdFR5cGU4IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA4KTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlOCA9IFJlcXVlc3RUeXBlODtcbmNsYXNzIFJlcXVlc3RUeXBlOSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgOSk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTkgPSBSZXF1ZXN0VHlwZTk7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QsIF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMSk7XG4gICAgICAgIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBfcGFyYW1ldGVyU3RydWN0dXJlcztcbiAgICB9XG4gICAgZ2V0IHBhcmFtZXRlclN0cnVjdHVyZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZSA9IE5vdGlmaWNhdGlvblR5cGU7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlMCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMCk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMCA9IE5vdGlmaWNhdGlvblR5cGUwO1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTEgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG8pIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAxKTtcbiAgICAgICAgdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcyA9IF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbiAgICBnZXQgcGFyYW1ldGVyU3RydWN0dXJlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMSA9IE5vdGlmaWNhdGlvblR5cGUxO1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTIgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDIpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTIgPSBOb3RpZmljYXRpb25UeXBlMjtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGUzIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAzKTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGUzID0gTm90aWZpY2F0aW9uVHlwZTM7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlNCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNCk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNCA9IE5vdGlmaWNhdGlvblR5cGU0O1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTUgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDUpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTUgPSBOb3RpZmljYXRpb25UeXBlNTtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGU2IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA2KTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGU2ID0gTm90aWZpY2F0aW9uVHlwZTY7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlNyBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNyk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNyA9IE5vdGlmaWNhdGlvblR5cGU3O1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTggZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDgpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTggPSBOb3RpZmljYXRpb25UeXBlODtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGU5IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA5KTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGU5ID0gTm90aWZpY2F0aW9uVHlwZTk7XG52YXIgTWVzc2FnZTtcbihmdW5jdGlvbiAoTWVzc2FnZSkge1xuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoZSBnaXZlbiBtZXNzYWdlIGlzIGEgcmVxdWVzdCBtZXNzYWdlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNSZXF1ZXN0KG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gbWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBpcy5zdHJpbmcoY2FuZGlkYXRlLm1ldGhvZCkgJiYgKGlzLnN0cmluZyhjYW5kaWRhdGUuaWQpIHx8IGlzLm51bWJlcihjYW5kaWRhdGUuaWQpKTtcbiAgICB9XG4gICAgTWVzc2FnZS5pc1JlcXVlc3QgPSBpc1JlcXVlc3Q7XG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhlIGdpdmVuIG1lc3NhZ2UgaXMgYSBub3RpZmljYXRpb24gbWVzc2FnZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTm90aWZpY2F0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gbWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBpcy5zdHJpbmcoY2FuZGlkYXRlLm1ldGhvZCkgJiYgbWVzc2FnZS5pZCA9PT0gdm9pZCAwO1xuICAgIH1cbiAgICBNZXNzYWdlLmlzTm90aWZpY2F0aW9uID0gaXNOb3RpZmljYXRpb247XG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhlIGdpdmVuIG1lc3NhZ2UgaXMgYSByZXNwb25zZSBtZXNzYWdlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNSZXNwb25zZShtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IG1lc3NhZ2U7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgKGNhbmRpZGF0ZS5yZXN1bHQgIT09IHZvaWQgMCB8fCAhIWNhbmRpZGF0ZS5lcnJvcikgJiYgKGlzLnN0cmluZyhjYW5kaWRhdGUuaWQpIHx8IGlzLm51bWJlcihjYW5kaWRhdGUuaWQpIHx8IGNhbmRpZGF0ZS5pZCA9PT0gbnVsbCk7XG4gICAgfVxuICAgIE1lc3NhZ2UuaXNSZXNwb25zZSA9IGlzUmVzcG9uc2U7XG59KShNZXNzYWdlID0gZXhwb3J0cy5NZXNzYWdlIHx8IChleHBvcnRzLk1lc3NhZ2UgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1NzA2OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5sZXQgX3JhbDtcbmZ1bmN0aW9uIFJBTCgpIHtcbiAgICBpZiAoX3JhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gcnVudGltZSBhYnN0cmFjdGlvbiBsYXllciBpbnN0YWxsZWRgKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yYWw7XG59XG4oZnVuY3Rpb24gKFJBTCkge1xuICAgIGZ1bmN0aW9uIGluc3RhbGwocmFsKSB7XG4gICAgICAgIGlmIChyYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBydW50aW1lIGFic3RyYWN0aW9uIGxheWVyIHByb3ZpZGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgX3JhbCA9IHJhbDtcbiAgICB9XG4gICAgUkFMLmluc3RhbGwgPSBpbnN0YWxsO1xufSkoUkFMIHx8IChSQUwgPSB7fSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBSQUw7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDIzMzk6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuU2VtYXBob3JlID0gdm9pZCAwO1xuY29uc3QgcmFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3MDYpO1xuY2xhc3MgU2VtYXBob3JlIHtcbiAgICBjb25zdHJ1Y3RvcihjYXBhY2l0eSA9IDEpIHtcbiAgICAgICAgaWYgKGNhcGFjaXR5IDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FwYWNpdHkgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhcGFjaXR5ID0gY2FwYWNpdHk7XG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IDA7XG4gICAgICAgIHRoaXMuX3dhaXRpbmcgPSBbXTtcbiAgICB9XG4gICAgbG9jayh0aHVuaykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fd2FpdGluZy5wdXNoKHsgdGh1bmssIHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICAgICAgICAgIHRoaXMucnVuTmV4dCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGFjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgICB9XG4gICAgcnVuTmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dhaXRpbmcubGVuZ3RoID09PSAwIHx8IHRoaXMuX2FjdGl2ZSA9PT0gdGhpcy5fY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAoMCwgcmFsXzEuZGVmYXVsdCkoKS50aW1lci5zZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5kb1J1bk5leHQoKSk7XG4gICAgfVxuICAgIGRvUnVuTmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dhaXRpbmcubGVuZ3RoID09PSAwIHx8IHRoaXMuX2FjdGl2ZSA9PT0gdGhpcy5fY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5fd2FpdGluZy5zaGlmdCgpO1xuICAgICAgICB0aGlzLl9hY3RpdmUrKztcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZSA+IHRoaXMuX2NhcGFjaXR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvIG1hbnkgdGh1bmtzIGFjdGl2ZWApO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXh0LnRodW5rKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmUtLTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5OZXh0KCk7XG4gICAgICAgICAgICAgICAgfSwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmUtLTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5OZXh0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmUtLTtcbiAgICAgICAgICAgICAgICBuZXh0LnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bk5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmUtLTtcbiAgICAgICAgICAgIG5leHQucmVqZWN0KGVycik7XG4gICAgICAgICAgICB0aGlzLnJ1bk5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU2VtYXBob3JlID0gU2VtYXBob3JlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNzg6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5ID0gZXhwb3J0cy5TaGFyZWRBcnJheVNlbmRlclN0cmF0ZWd5ID0gdm9pZCAwO1xuY29uc3QgY2FuY2VsbGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxNSk7XG52YXIgQ2FuY2VsbGF0aW9uU3RhdGU7XG4oZnVuY3Rpb24gKENhbmNlbGxhdGlvblN0YXRlKSB7XG4gICAgQ2FuY2VsbGF0aW9uU3RhdGUuQ29udGludWUgPSAwO1xuICAgIENhbmNlbGxhdGlvblN0YXRlLkNhbmNlbGxlZCA9IDE7XG59KShDYW5jZWxsYXRpb25TdGF0ZSB8fCAoQ2FuY2VsbGF0aW9uU3RhdGUgPSB7fSkpO1xuY2xhc3MgU2hhcmVkQXJyYXlTZW5kZXJTdHJhdGVneSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgZW5hYmxlQ2FuY2VsbGF0aW9uKHJlcXVlc3QpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QuaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgU2hhcmVkQXJyYXlCdWZmZXIoNCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgSW50MzJBcnJheShidWZmZXIsIDAsIDEpO1xuICAgICAgICBkYXRhWzBdID0gQ2FuY2VsbGF0aW9uU3RhdGUuQ29udGludWU7XG4gICAgICAgIHRoaXMuYnVmZmVycy5zZXQocmVxdWVzdC5pZCwgYnVmZmVyKTtcbiAgICAgICAgcmVxdWVzdC4kY2FuY2VsbGF0aW9uRGF0YSA9IGJ1ZmZlcjtcbiAgICB9XG4gICAgYXN5bmMgc2VuZENhbmNlbGxhdGlvbihfY29ubiwgaWQpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5idWZmZXJzLmdldChpZCk7XG4gICAgICAgIGlmIChidWZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgSW50MzJBcnJheShidWZmZXIsIDAsIDEpO1xuICAgICAgICBBdG9taWNzLnN0b3JlKGRhdGEsIDAsIENhbmNlbGxhdGlvblN0YXRlLkNhbmNlbGxlZCk7XG4gICAgfVxuICAgIGNsZWFudXAoaWQpIHtcbiAgICAgICAgdGhpcy5idWZmZXJzLmRlbGV0ZShpZCk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuYnVmZmVycy5jbGVhcigpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2hhcmVkQXJyYXlTZW5kZXJTdHJhdGVneSA9IFNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3k7XG5jbGFzcyBTaGFyZWRBcnJheUJ1ZmZlckNhbmNlbGxhdGlvblRva2VuIHtcbiAgICBjb25zdHJ1Y3RvcihidWZmZXIpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IEludDMyQXJyYXkoYnVmZmVyLCAwLCAxKTtcbiAgICB9XG4gICAgZ2V0IGlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCkge1xuICAgICAgICByZXR1cm4gQXRvbWljcy5sb2FkKHRoaXMuZGF0YSwgMCkgPT09IENhbmNlbGxhdGlvblN0YXRlLkNhbmNlbGxlZDtcbiAgICB9XG4gICAgZ2V0IG9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbmNlbGxhdGlvbiBvdmVyIFNoYXJlZEFycmF5QnVmZmVyIGRvZXNuJ3Qgc3VwcG9ydCBjYW5jZWxsYXRpb24gZXZlbnRzYCk7XG4gICAgfVxufVxuY2xhc3MgU2hhcmVkQXJyYXlCdWZmZXJDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyKSB7XG4gICAgICAgIHRoaXMudG9rZW4gPSBuZXcgU2hhcmVkQXJyYXlCdWZmZXJDYW5jZWxsYXRpb25Ub2tlbihidWZmZXIpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgfVxufVxuY2xhc3MgU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5raW5kID0gJ3JlcXVlc3QnO1xuICAgIH1cbiAgICBjcmVhdGVDYW5jZWxsYXRpb25Ub2tlblNvdXJjZShyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHJlcXVlc3QuJGNhbmNlbGxhdGlvbkRhdGE7XG4gICAgICAgIGlmIChidWZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBjYW5jZWxsYXRpb25fMS5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2hhcmVkQXJyYXlCdWZmZXJDYW5jZWxsYXRpb25Ub2tlblNvdXJjZShidWZmZXIpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5ID0gU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyOTQ6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLmNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbiA9IHZvaWQgMDtcbmNvbnN0IGJyb3dzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIwMCk7XG5fX2V4cG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxMjAwKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg5MzcyKSwgZXhwb3J0cyk7XG5mdW5jdGlvbiBjcmVhdGVQcm90b2NvbENvbm5lY3Rpb24ocmVhZGVyLCB3cml0ZXIsIGxvZ2dlciwgb3B0aW9ucykge1xuICAgIHJldHVybiAoMCwgYnJvd3Nlcl8xLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uKShyZWFkZXIsIHdyaXRlciwgbG9nZ2VyLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uID0gY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5MzcyOlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5MU1BFcnJvckNvZGVzID0gZXhwb3J0cy5jcmVhdGVQcm90b2NvbENvbm5lY3Rpb24gPSB2b2lkIDA7XG5fX2V4cG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg1OTUzKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg0NzY3KSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg4NTk5KSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg2NTI1KSwgZXhwb3J0cyk7XG52YXIgY29ubmVjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNzk4KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVByb3RvY29sQ29ubmVjdGlvblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5jcmVhdGVQcm90b2NvbENvbm5lY3Rpb247IH0gfSkpO1xudmFyIExTUEVycm9yQ29kZXM7XG4oZnVuY3Rpb24gKExTUEVycm9yQ29kZXMpIHtcbiAgICAvKipcbiAgICAqIFRoaXMgaXMgdGhlIHN0YXJ0IHJhbmdlIG9mIExTUCByZXNlcnZlZCBlcnJvciBjb2Rlcy5cbiAgICAqIEl0IGRvZXNuJ3QgZGVub3RlIGEgcmVhbCBlcnJvciBjb2RlLlxuICAgICpcbiAgICAqIEBzaW5jZSAzLjE2LjBcbiAgICAqL1xuICAgIExTUEVycm9yQ29kZXMubHNwUmVzZXJ2ZWRFcnJvclJhbmdlU3RhcnQgPSAtMzI4OTk7XG4gICAgLyoqXG4gICAgICogQSByZXF1ZXN0IGZhaWxlZCBidXQgaXQgd2FzIHN5bnRhY3RpY2FsbHkgY29ycmVjdCwgZS5nIHRoZVxuICAgICAqIG1ldGhvZCBuYW1lIHdhcyBrbm93biBhbmQgdGhlIHBhcmFtZXRlcnMgd2VyZSB2YWxpZC4gVGhlIGVycm9yXG4gICAgICogbWVzc2FnZSBzaG91bGQgY29udGFpbiBodW1hbiByZWFkYWJsZSBpbmZvcm1hdGlvbiBhYm91dCB3aHlcbiAgICAgKiB0aGUgcmVxdWVzdCBmYWlsZWQuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMy4xNy4wXG4gICAgICovXG4gICAgTFNQRXJyb3JDb2Rlcy5SZXF1ZXN0RmFpbGVkID0gLTMyODAzO1xuICAgIC8qKlxuICAgICAqIFRoZSBzZXJ2ZXIgY2FuY2VsbGVkIHRoZSByZXF1ZXN0LiBUaGlzIGVycm9yIGNvZGUgc2hvdWxkXG4gICAgICogb25seSBiZSB1c2VkIGZvciByZXF1ZXN0cyB0aGF0IGV4cGxpY2l0bHkgc3VwcG9ydCBiZWluZ1xuICAgICAqIHNlcnZlciBjYW5jZWxsYWJsZS5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAzLjE3LjBcbiAgICAgKi9cbiAgICBMU1BFcnJvckNvZGVzLlNlcnZlckNhbmNlbGxlZCA9IC0zMjgwMjtcbiAgICAvKipcbiAgICAgKiBUaGUgc2VydmVyIGRldGVjdGVkIHRoYXQgdGhlIGNvbnRlbnQgb2YgYSBkb2N1bWVudCBnb3RcbiAgICAgKiBtb2RpZmllZCBvdXRzaWRlIG5vcm1hbCBjb25kaXRpb25zLiBBIHNlcnZlciBzaG91bGRcbiAgICAgKiBOT1Qgc2VuZCB0aGlzIGVycm9yIGNvZGUgaWYgaXQgZGV0ZWN0cyBhIGNvbnRlbnQgY2hhbmdlXG4gICAgICogaW4gaXQgdW5wcm9jZXNzZWQgbWVzc2FnZXMuIFRoZSByZXN1bHQgZXZlbiBjb21wdXRlZFxuICAgICAqIG9uIGFuIG9sZGVyIHN0YXRlIG1pZ2h0IHN0aWxsIGJlIHVzZWZ1bCBmb3IgdGhlIGNsaWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgY2xpZW50IGRlY2lkZXMgdGhhdCBhIHJlc3VsdCBpcyBub3Qgb2YgYW55IHVzZSBhbnltb3JlXG4gICAgICogdGhlIGNsaWVudCBzaG91bGQgY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIExTUEVycm9yQ29kZXMuQ29udGVudE1vZGlmaWVkID0gLTMyODAxO1xuICAgIC8qKlxuICAgICAqIFRoZSBjbGllbnQgaGFzIGNhbmNlbGVkIGEgcmVxdWVzdCBhbmQgYSBzZXJ2ZXIgYXMgZGV0ZWN0ZWRcbiAgICAgKiB0aGUgY2FuY2VsLlxuICAgICAqL1xuICAgIExTUEVycm9yQ29kZXMuUmVxdWVzdENhbmNlbGxlZCA9IC0zMjgwMDtcbiAgICAvKipcbiAgICAqIFRoaXMgaXMgdGhlIGVuZCByYW5nZSBvZiBMU1AgcmVzZXJ2ZWQgZXJyb3IgY29kZXMuXG4gICAgKiBJdCBkb2Vzbid0IGRlbm90ZSBhIHJlYWwgZXJyb3IgY29kZS5cbiAgICAqXG4gICAgKiBAc2luY2UgMy4xNi4wXG4gICAgKi9cbiAgICBMU1BFcnJvckNvZGVzLmxzcFJlc2VydmVkRXJyb3JSYW5nZUVuZCA9IC0zMjgwMDtcbn0pKExTUEVycm9yQ29kZXMgPSBleHBvcnRzLkxTUEVycm9yQ29kZXMgfHwgKGV4cG9ydHMuTFNQRXJyb3JDb2RlcyA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI3OTg6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uID0gdm9pZCAwO1xuY29uc3QgdnNjb2RlX2pzb25ycGNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTk1Myk7XG5mdW5jdGlvbiBjcmVhdGVQcm90b2NvbENvbm5lY3Rpb24oaW5wdXQsIG91dHB1dCwgbG9nZ2VyLCBvcHRpb25zKSB7XG4gICAgaWYgKHZzY29kZV9qc29ucnBjXzEuQ29ubmVjdGlvblN0cmF0ZWd5LmlzKG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7IGNvbm5lY3Rpb25TdHJhdGVneTogb3B0aW9ucyB9O1xuICAgIH1cbiAgICByZXR1cm4gKDAsIHZzY29kZV9qc29ucnBjXzEuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24pKGlucHV0LCBvdXRwdXQsIGxvZ2dlciwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbiA9IGNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODU5OTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUgPSBleHBvcnRzLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZTAgPSBleHBvcnRzLlByb3RvY29sUmVxdWVzdFR5cGUgPSBleHBvcnRzLlByb3RvY29sUmVxdWVzdFR5cGUwID0gZXhwb3J0cy5SZWdpc3RyYXRpb25UeXBlID0gZXhwb3J0cy5NZXNzYWdlRGlyZWN0aW9uID0gdm9pZCAwO1xuY29uc3QgdnNjb2RlX2pzb25ycGNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTk1Myk7XG52YXIgTWVzc2FnZURpcmVjdGlvbjtcbihmdW5jdGlvbiAoTWVzc2FnZURpcmVjdGlvbikge1xuICAgIE1lc3NhZ2VEaXJlY3Rpb25bXCJjbGllbnRUb1NlcnZlclwiXSA9IFwiY2xpZW50VG9TZXJ2ZXJcIjtcbiAgICBNZXNzYWdlRGlyZWN0aW9uW1wic2VydmVyVG9DbGllbnRcIl0gPSBcInNlcnZlclRvQ2xpZW50XCI7XG4gICAgTWVzc2FnZURpcmVjdGlvbltcImJvdGhcIl0gPSBcImJvdGhcIjtcbn0pKE1lc3NhZ2VEaXJlY3Rpb24gPSBleHBvcnRzLk1lc3NhZ2VEaXJlY3Rpb24gfHwgKGV4cG9ydHMuTWVzc2FnZURpcmVjdGlvbiA9IHt9KSk7XG5jbGFzcyBSZWdpc3RyYXRpb25UeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgfVxufVxuZXhwb3J0cy5SZWdpc3RyYXRpb25UeXBlID0gUmVnaXN0cmF0aW9uVHlwZTtcbmNsYXNzIFByb3RvY29sUmVxdWVzdFR5cGUwIGV4dGVuZHMgdnNjb2RlX2pzb25ycGNfMS5SZXF1ZXN0VHlwZTAge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QpO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvdG9jb2xSZXF1ZXN0VHlwZTAgPSBQcm90b2NvbFJlcXVlc3RUeXBlMDtcbmNsYXNzIFByb3RvY29sUmVxdWVzdFR5cGUgZXh0ZW5kcyB2c2NvZGVfanNvbnJwY18xLlJlcXVlc3RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCB2c2NvZGVfanNvbnJwY18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lKTtcbiAgICB9XG59XG5leHBvcnRzLlByb3RvY29sUmVxdWVzdFR5cGUgPSBQcm90b2NvbFJlcXVlc3RUeXBlO1xuY2xhc3MgUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlMCBleHRlbmRzIHZzY29kZV9qc29ucnBjXzEuTm90aWZpY2F0aW9uVHlwZTAge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QpO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlMCA9IFByb3RvY29sTm90aWZpY2F0aW9uVHlwZTA7XG5jbGFzcyBQcm90b2NvbE5vdGlmaWNhdGlvblR5cGUgZXh0ZW5kcyB2c2NvZGVfanNvbnJwY18xLk5vdGlmaWNhdGlvblR5cGUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIHZzY29kZV9qc29ucnBjXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlID0gUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NDM0OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgVHlwZUZveCwgTWljcm9zb2Z0IGFuZCBvdGhlcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0ID0gZXhwb3J0cy5DYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QgPSBleHBvcnRzLkNhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1OTkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzdWx0IGEgYENhbGxIaWVyYXJjaHlJdGVtYCBpbiBhIGRvY3VtZW50IGF0IGEgZ2l2ZW4gcG9zaXRpb24uXG4gKiBDYW4gYmUgdXNlZCBhcyBhbiBpbnB1dCB0byBhbiBpbmNvbWluZyBvciBvdXRnb2luZyBjYWxsIGhpZXJhcmNoeS5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBDYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKENhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCkge1xuICAgIENhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3ByZXBhcmVDYWxsSGllcmFyY2h5JztcbiAgICBDYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBDYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0Lm1ldGhvZCk7XG59KShDYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QgPSBleHBvcnRzLkNhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCB8fCAoZXhwb3J0cy5DYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSB0aGUgaW5jb21pbmcgY2FsbHMgZm9yIGEgZ2l2ZW4gYENhbGxIaWVyYXJjaHlJdGVtYC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKENhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdCkge1xuICAgIENhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdC5tZXRob2QgPSAnY2FsbEhpZXJhcmNoeS9pbmNvbWluZ0NhbGxzJztcbiAgICBDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0Lm1ldGhvZCk7XG59KShDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QgPSBleHBvcnRzLkNhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdCB8fCAoZXhwb3J0cy5DYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSB0aGUgb3V0Z29pbmcgY2FsbHMgZm9yIGEgZ2l2ZW4gYENhbGxIaWVyYXJjaHlJdGVtYC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBDYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKENhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdCkge1xuICAgIENhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdC5tZXRob2QgPSAnY2FsbEhpZXJhcmNoeS9vdXRnb2luZ0NhbGxzJztcbiAgICBDYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBDYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0Lm1ldGhvZCk7XG59KShDYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QgPSBleHBvcnRzLkNhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdCB8fCAoZXhwb3J0cy5DYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3OTA4OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkNvbG9yUHJlc2VudGF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRDb2xvclJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTk5KTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIGxpc3QgYWxsIGNvbG9yIHN5bWJvbHMgZm91bmQgaW4gYSBnaXZlbiB0ZXh0IGRvY3VtZW50LiBUaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgRG9jdW1lbnRDb2xvclBhcmFtc30gdGhlXG4gKiByZXNwb25zZSBpcyBvZiB0eXBlIHtAbGluayBDb2xvckluZm9ybWF0aW9uIENvbG9ySW5mb3JtYXRpb25bXX0gb3IgYSBUaGVuYWJsZVxuICogdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgRG9jdW1lbnRDb2xvclJlcXVlc3Q7XG4oZnVuY3Rpb24gKERvY3VtZW50Q29sb3JSZXF1ZXN0KSB7XG4gICAgRG9jdW1lbnRDb2xvclJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9kb2N1bWVudENvbG9yJztcbiAgICBEb2N1bWVudENvbG9yUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERvY3VtZW50Q29sb3JSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKERvY3VtZW50Q29sb3JSZXF1ZXN0Lm1ldGhvZCk7XG59KShEb2N1bWVudENvbG9yUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRDb2xvclJlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRDb2xvclJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gbGlzdCBhbGwgcHJlc2VudGF0aW9uIGZvciBhIGNvbG9yLiBUaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgQ29sb3JQcmVzZW50YXRpb25QYXJhbXN9IHRoZVxuICogcmVzcG9uc2UgaXMgb2YgdHlwZSB7QGxpbmsgQ29sb3JJbmZvcm1hdGlvbiBDb2xvckluZm9ybWF0aW9uW119IG9yIGEgVGhlbmFibGVcbiAqIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIENvbG9yUHJlc2VudGF0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0KSB7XG4gICAgQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvY29sb3JQcmVzZW50YXRpb24nO1xuICAgIENvbG9yUHJlc2VudGF0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENvbG9yUHJlc2VudGF0aW9uUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDb2xvclByZXNlbnRhdGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKENvbG9yUHJlc2VudGF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLkNvbG9yUHJlc2VudGF0aW9uUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDU0NDI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuQ29uZmlndXJhdGlvblJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTk5KTtcbi8vLS0tLSBHZXQgQ29uZmlndXJhdGlvbiByZXF1ZXN0IC0tLS1cbi8qKlxuICogVGhlICd3b3Jrc3BhY2UvY29uZmlndXJhdGlvbicgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIGZldGNoIGEgY2VydGFpblxuICogY29uZmlndXJhdGlvbiBzZXR0aW5nLlxuICpcbiAqIFRoaXMgcHVsbCBtb2RlbCByZXBsYWNlcyB0aGUgb2xkIHB1c2ggbW9kZWwgd2VyZSB0aGUgY2xpZW50IHNpZ25hbGVkIGNvbmZpZ3VyYXRpb24gY2hhbmdlIHZpYSBhblxuICogZXZlbnQuIElmIHRoZSBzZXJ2ZXIgc3RpbGwgbmVlZHMgdG8gcmVhY3QgdG8gY29uZmlndXJhdGlvbiBjaGFuZ2VzIChzaW5jZSB0aGUgc2VydmVyIGNhY2hlcyB0aGVcbiAqIHJlc3VsdCBvZiBgd29ya3NwYWNlL2NvbmZpZ3VyYXRpb25gIHJlcXVlc3RzKSB0aGUgc2VydmVyIHNob3VsZCByZWdpc3RlciBmb3IgYW4gZW1wdHkgY29uZmlndXJhdGlvblxuICogY2hhbmdlIGV2ZW50IGFuZCBlbXB0eSB0aGUgY2FjaGUgaWYgc3VjaCBhbiBldmVudCBpcyByZWNlaXZlZC5cbiAqL1xudmFyIENvbmZpZ3VyYXRpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChDb25maWd1cmF0aW9uUmVxdWVzdCkge1xuICAgIENvbmZpZ3VyYXRpb25SZXF1ZXN0Lm1ldGhvZCA9ICd3b3Jrc3BhY2UvY29uZmlndXJhdGlvbic7XG4gICAgQ29uZmlndXJhdGlvblJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBDb25maWd1cmF0aW9uUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDb25maWd1cmF0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoQ29uZmlndXJhdGlvblJlcXVlc3QgPSBleHBvcnRzLkNvbmZpZ3VyYXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLkNvbmZpZ3VyYXRpb25SZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzIxMDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5EZWNsYXJhdGlvblJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTk5KTtcbi8vIEB0cy1pZ25vcmU6IHRvIGF2b2lkIGlubGluaW5nIExvY2F0aW9uTGluayBhcyBkeW5hbWljIGltcG9ydFxubGV0IF9fbm9EeW5hbWljSW1wb3J0O1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSB0aGUgdHlwZSBkZWZpbml0aW9uIGxvY2F0aW9ucyBvZiBhIHN5bWJvbCBhdCBhIGdpdmVuIHRleHRcbiAqIGRvY3VtZW50IHBvc2l0aW9uLiBUaGUgcmVxdWVzdCdzIHBhcmFtZXRlciBpcyBvZiB0eXBlIFtUZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtc11cbiAqICgjVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXMpIHRoZSByZXNwb25zZSBpcyBvZiB0eXBlIHtAbGluayBEZWNsYXJhdGlvbn1cbiAqIG9yIGEgdHlwZWQgYXJyYXkgb2Yge0BsaW5rIERlY2xhcmF0aW9uTGlua30gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzXG4gKiB0byBzdWNoLlxuICovXG52YXIgRGVjbGFyYXRpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChEZWNsYXJhdGlvblJlcXVlc3QpIHtcbiAgICBEZWNsYXJhdGlvblJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9kZWNsYXJhdGlvbic7XG4gICAgRGVjbGFyYXRpb25SZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGVjbGFyYXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKERlY2xhcmF0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoRGVjbGFyYXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5EZWNsYXJhdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuRGVjbGFyYXRpb25SZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTY5Mjpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5EaWFnbm9zdGljUmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLldvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudERpYWdub3N0aWNSZXBvcnRLaW5kID0gZXhwb3J0cy5EaWFnbm9zdGljU2VydmVyQ2FuY2VsbGF0aW9uRGF0YSA9IHZvaWQgMDtcbmNvbnN0IHZzY29kZV9qc29ucnBjXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5NTMpO1xuY29uc3QgSXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1MjMpO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODU5OSk7XG4vKipcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIERpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhO1xuKGZ1bmN0aW9uIChEaWFnbm9zdGljU2VydmVyQ2FuY2VsbGF0aW9uRGF0YSkge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLmJvb2xlYW4oY2FuZGlkYXRlLnJldHJpZ2dlclJlcXVlc3QpO1xuICAgIH1cbiAgICBEaWFnbm9zdGljU2VydmVyQ2FuY2VsbGF0aW9uRGF0YS5pcyA9IGlzO1xufSkoRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGEgPSBleHBvcnRzLkRpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhIHx8IChleHBvcnRzLkRpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhID0ge30pKTtcbi8qKlxuICogVGhlIGRvY3VtZW50IGRpYWdub3N0aWMgcmVwb3J0IGtpbmRzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIERvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQ7XG4oZnVuY3Rpb24gKERvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQpIHtcbiAgICAvKipcbiAgICAgKiBBIGRpYWdub3N0aWMgcmVwb3J0IHdpdGggYSBmdWxsXG4gICAgICogc2V0IG9mIHByb2JsZW1zLlxuICAgICAqL1xuICAgIERvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQuRnVsbCA9ICdmdWxsJztcbiAgICAvKipcbiAgICAgKiBBIHJlcG9ydCBpbmRpY2F0aW5nIHRoYXQgdGhlIGxhc3RcbiAgICAgKiByZXR1cm5lZCByZXBvcnQgaXMgc3RpbGwgYWNjdXJhdGUuXG4gICAgICovXG4gICAgRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZC5VbmNoYW5nZWQgPSAndW5jaGFuZ2VkJztcbn0pKERvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQgPSBleHBvcnRzLkRvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQgfHwgKGV4cG9ydHMuRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZCA9IHt9KSk7XG4vKipcbiAqIFRoZSBkb2N1bWVudCBkaWFnbm9zdGljIHJlcXVlc3QgZGVmaW5pdGlvbi5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBEb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0KSB7XG4gICAgRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2RpYWdub3N0aWMnO1xuICAgIERvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKERvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QubWV0aG9kKTtcbiAgICBEb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0LnBhcnRpYWxSZXN1bHQgPSBuZXcgdnNjb2RlX2pzb25ycGNfMS5Qcm9ncmVzc1R5cGUoKTtcbn0pKERvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFRoZSB3b3Jrc3BhY2UgZGlhZ25vc3RpYyByZXF1ZXN0IGRlZmluaXRpb24uXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3Q7XG4oZnVuY3Rpb24gKFdvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0KSB7XG4gICAgV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QubWV0aG9kID0gJ3dvcmtzcGFjZS9kaWFnbm9zdGljJztcbiAgICBXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFdvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0Lm1ldGhvZCk7XG4gICAgV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QucGFydGlhbFJlc3VsdCA9IG5ldyB2c2NvZGVfanNvbnJwY18xLlByb2dyZXNzVHlwZSgpO1xufSkoV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QgPSBleHBvcnRzLldvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0IHx8IChleHBvcnRzLldvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIGRpYWdub3N0aWMgcmVmcmVzaCByZXF1ZXN0IGRlZmluaXRpb24uXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3QpIHtcbiAgICBEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3QubWV0aG9kID0gYHdvcmtzcGFjZS9kaWFnbm9zdGljL3JlZnJlc2hgO1xuICAgIERpYWdub3N0aWNSZWZyZXNoUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIERpYWdub3N0aWNSZWZyZXNoUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0Lm1ldGhvZCk7XG59KShEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLkRpYWdub3N0aWNSZWZyZXNoUmVxdWVzdCB8fCAoZXhwb3J0cy5EaWFnbm9zdGljUmVmcmVzaFJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2MTkwOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLldpbGxEZWxldGVGaWxlc1JlcXVlc3QgPSBleHBvcnRzLkRpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV2lsbFJlbmFtZUZpbGVzUmVxdWVzdCA9IGV4cG9ydHMuRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24gPSBleHBvcnRzLldpbGxDcmVhdGVGaWxlc1JlcXVlc3QgPSBleHBvcnRzLkZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1OTkpO1xuLyoqXG4gKiBBIHBhdHRlcm4ga2luZCBkZXNjcmliaW5nIGlmIGEgZ2xvYiBwYXR0ZXJuIG1hdGNoZXMgYSBmaWxlIGEgZm9sZGVyIG9yXG4gKiBib3RoLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIEZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZDtcbihmdW5jdGlvbiAoRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHBhdHRlcm4gbWF0Y2hlcyBhIGZpbGUgb25seS5cbiAgICAgKi9cbiAgICBGaWxlT3BlcmF0aW9uUGF0dGVybktpbmQuZmlsZSA9ICdmaWxlJztcbiAgICAvKipcbiAgICAgKiBUaGUgcGF0dGVybiBtYXRjaGVzIGEgZm9sZGVyIG9ubHkuXG4gICAgICovXG4gICAgRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kLmZvbGRlciA9ICdmb2xkZXInO1xufSkoRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kID0gZXhwb3J0cy5GaWxlT3BlcmF0aW9uUGF0dGVybktpbmQgfHwgKGV4cG9ydHMuRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kID0ge30pKTtcbi8qKlxuICogVGhlIHdpbGwgY3JlYXRlIGZpbGVzIHJlcXVlc3QgaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciBiZWZvcmUgZmlsZXMgYXJlIGFjdHVhbGx5XG4gKiBjcmVhdGVkIGFzIGxvbmcgYXMgdGhlIGNyZWF0aW9uIGlzIHRyaWdnZXJlZCBmcm9tIHdpdGhpbiB0aGUgY2xpZW50LlxuICpcbiAqIFRoZSByZXF1ZXN0IGNhbiByZXR1cm4gYSBgV29ya3NwYWNlRWRpdGAgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHdvcmtzcGFjZSBiZWZvcmUgdGhlXG4gKiBmaWxlcyBhcmUgY3JlYXRlZC4gSGVuY2UgdGhlIGBXb3Jrc3BhY2VFZGl0YCBjYW4gbm90IG1hbmlwdWxhdGUgdGhlIGNvbnRlbnQgb2YgdGhlIGZpbGVcbiAqIHRvIGJlIGNyZWF0ZWQuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgV2lsbENyZWF0ZUZpbGVzUmVxdWVzdDtcbihmdW5jdGlvbiAoV2lsbENyZWF0ZUZpbGVzUmVxdWVzdCkge1xuICAgIFdpbGxDcmVhdGVGaWxlc1JlcXVlc3QubWV0aG9kID0gJ3dvcmtzcGFjZS93aWxsQ3JlYXRlRmlsZXMnO1xuICAgIFdpbGxDcmVhdGVGaWxlc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBXaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFdpbGxDcmVhdGVGaWxlc1JlcXVlc3QubWV0aG9kKTtcbn0pKFdpbGxDcmVhdGVGaWxlc1JlcXVlc3QgPSBleHBvcnRzLldpbGxDcmVhdGVGaWxlc1JlcXVlc3QgfHwgKGV4cG9ydHMuV2lsbENyZWF0ZUZpbGVzUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFRoZSBkaWQgY3JlYXRlIGZpbGVzIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHdoZW5cbiAqIGZpbGVzIHdlcmUgY3JlYXRlZCBmcm9tIHdpdGhpbiB0aGUgY2xpZW50LlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIERpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRDcmVhdGVGaWxlc05vdGlmaWNhdGlvbikge1xuICAgIERpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3b3Jrc3BhY2UvZGlkQ3JlYXRlRmlsZXMnO1xuICAgIERpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRDcmVhdGVGaWxlc05vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIHdpbGwgcmVuYW1lIGZpbGVzIHJlcXVlc3QgaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciBiZWZvcmUgZmlsZXMgYXJlIGFjdHVhbGx5XG4gKiByZW5hbWVkIGFzIGxvbmcgYXMgdGhlIHJlbmFtZSBpcyB0cmlnZ2VyZWQgZnJvbSB3aXRoaW4gdGhlIGNsaWVudC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBXaWxsUmVuYW1lRmlsZXNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChXaWxsUmVuYW1lRmlsZXNSZXF1ZXN0KSB7XG4gICAgV2lsbFJlbmFtZUZpbGVzUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL3dpbGxSZW5hbWVGaWxlcyc7XG4gICAgV2lsbFJlbmFtZUZpbGVzUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdpbGxSZW5hbWVGaWxlc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV2lsbFJlbmFtZUZpbGVzUmVxdWVzdC5tZXRob2QpO1xufSkoV2lsbFJlbmFtZUZpbGVzUmVxdWVzdCA9IGV4cG9ydHMuV2lsbFJlbmFtZUZpbGVzUmVxdWVzdCB8fCAoZXhwb3J0cy5XaWxsUmVuYW1lRmlsZXNSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIGRpZCByZW5hbWUgZmlsZXMgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgd2hlblxuICogZmlsZXMgd2VyZSByZW5hbWVkIGZyb20gd2l0aGluIHRoZSBjbGllbnQuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uKSB7XG4gICAgRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24ubWV0aG9kID0gJ3dvcmtzcGFjZS9kaWRSZW5hbWVGaWxlcyc7XG4gICAgRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShEaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgd2lsbCBkZWxldGUgZmlsZXMgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIGJlZm9yZSBmaWxlcyBhcmUgYWN0dWFsbHlcbiAqIGRlbGV0ZWQgYXMgbG9uZyBhcyB0aGUgZGVsZXRpb24gaXMgdHJpZ2dlcmVkIGZyb20gd2l0aGluIHRoZSBjbGllbnQuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uKSB7XG4gICAgRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb24ubWV0aG9kID0gJ3dvcmtzcGFjZS9kaWREZWxldGVGaWxlcyc7XG4gICAgRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShEaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgZGlkIGRlbGV0ZSBmaWxlcyBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB3aGVuXG4gKiBmaWxlcyB3ZXJlIGRlbGV0ZWQgZnJvbSB3aXRoaW4gdGhlIGNsaWVudC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBXaWxsRGVsZXRlRmlsZXNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChXaWxsRGVsZXRlRmlsZXNSZXF1ZXN0KSB7XG4gICAgV2lsbERlbGV0ZUZpbGVzUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL3dpbGxEZWxldGVGaWxlcyc7XG4gICAgV2lsbERlbGV0ZUZpbGVzUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdpbGxEZWxldGVGaWxlc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV2lsbERlbGV0ZUZpbGVzUmVxdWVzdC5tZXRob2QpO1xufSkoV2lsbERlbGV0ZUZpbGVzUmVxdWVzdCA9IGV4cG9ydHMuV2lsbERlbGV0ZUZpbGVzUmVxdWVzdCB8fCAoZXhwb3J0cy5XaWxsRGVsZXRlRmlsZXNSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzAyOTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkZvbGRpbmdSYW5nZVJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTk5KTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHByb3ZpZGUgZm9sZGluZyByYW5nZXMgaW4gYSBkb2N1bWVudC4gVGhlIHJlcXVlc3Qnc1xuICogcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIEZvbGRpbmdSYW5nZVBhcmFtc30sIHRoZVxuICogcmVzcG9uc2UgaXMgb2YgdHlwZSB7QGxpbmsgRm9sZGluZ1JhbmdlTGlzdH0gb3IgYSBUaGVuYWJsZVxuICogdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgRm9sZGluZ1JhbmdlUmVxdWVzdDtcbihmdW5jdGlvbiAoRm9sZGluZ1JhbmdlUmVxdWVzdCkge1xuICAgIEZvbGRpbmdSYW5nZVJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9mb2xkaW5nUmFuZ2UnO1xuICAgIEZvbGRpbmdSYW5nZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBGb2xkaW5nUmFuZ2VSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKEZvbGRpbmdSYW5nZVJlcXVlc3QubWV0aG9kKTtcbn0pKEZvbGRpbmdSYW5nZVJlcXVlc3QgPSBleHBvcnRzLkZvbGRpbmdSYW5nZVJlcXVlc3QgfHwgKGV4cG9ydHMuRm9sZGluZ1JhbmdlUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkzODA6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuSW1wbGVtZW50YXRpb25SZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODU5OSk7XG4vLyBAdHMtaWdub3JlOiB0byBhdm9pZCBpbmxpbmluZyBMb2NhdGlvbkxpbmsgYXMgZHluYW1pYyBpbXBvcnRcbmxldCBfX25vRHluYW1pY0ltcG9ydDtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgdGhlIGltcGxlbWVudGF0aW9uIGxvY2F0aW9ucyBvZiBhIHN5bWJvbCBhdCBhIGdpdmVuIHRleHRcbiAqIGRvY3VtZW50IHBvc2l0aW9uLiBUaGUgcmVxdWVzdCdzIHBhcmFtZXRlciBpcyBvZiB0eXBlIFtUZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtc11cbiAqICgjVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXMpIHRoZSByZXNwb25zZSBpcyBvZiB0eXBlIHtAbGluayBEZWZpbml0aW9ufSBvciBhXG4gKiBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBJbXBsZW1lbnRhdGlvblJlcXVlc3Q7XG4oZnVuY3Rpb24gKEltcGxlbWVudGF0aW9uUmVxdWVzdCkge1xuICAgIEltcGxlbWVudGF0aW9uUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2ltcGxlbWVudGF0aW9uJztcbiAgICBJbXBsZW1lbnRhdGlvblJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBJbXBsZW1lbnRhdGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSW1wbGVtZW50YXRpb25SZXF1ZXN0Lm1ldGhvZCk7XG59KShJbXBsZW1lbnRhdGlvblJlcXVlc3QgPSBleHBvcnRzLkltcGxlbWVudGF0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5JbXBsZW1lbnRhdGlvblJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2MzE1OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLklubGF5SGludFJlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5JbmxheUhpbnRSZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODU5OSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBwcm92aWRlIGlubGF5IGhpbnRzIGluIGEgZG9jdW1lbnQuIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mXG4gKiB0eXBlIHtAbGluayBJbmxheUhpbnRzUGFyYW1zfSwgdGhlIHJlc3BvbnNlIGlzIG9mIHR5cGVcbiAqIHtAbGluayBJbmxheUhpbnQgSW5sYXlIaW50W119IG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIElubGF5SGludFJlcXVlc3Q7XG4oZnVuY3Rpb24gKElubGF5SGludFJlcXVlc3QpIHtcbiAgICBJbmxheUhpbnRSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvaW5sYXlIaW50JztcbiAgICBJbmxheUhpbnRSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgSW5sYXlIaW50UmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShJbmxheUhpbnRSZXF1ZXN0Lm1ldGhvZCk7XG59KShJbmxheUhpbnRSZXF1ZXN0ID0gZXhwb3J0cy5JbmxheUhpbnRSZXF1ZXN0IHx8IChleHBvcnRzLklubGF5SGludFJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgZm9yIGFuIGlubGF5IGhpbnQuXG4gKiBUaGUgcmVxdWVzdCdzIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBJbmxheUhpbnR9LCB0aGUgcmVzcG9uc2UgaXNcbiAqIG9mIHR5cGUge0BsaW5rIElubGF5SGludH0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKElubGF5SGludFJlc29sdmVSZXF1ZXN0KSB7XG4gICAgSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QubWV0aG9kID0gJ2lubGF5SGludC9yZXNvbHZlJztcbiAgICBJbmxheUhpbnRSZXNvbHZlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIElubGF5SGludFJlc29sdmVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKElubGF5SGludFJlc29sdmVSZXF1ZXN0Lm1ldGhvZCk7XG59KShJbmxheUhpbnRSZXNvbHZlUmVxdWVzdCA9IGV4cG9ydHMuSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QgfHwgKGV4cG9ydHMuSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBJbmxheUhpbnRSZWZyZXNoUmVxdWVzdDtcbihmdW5jdGlvbiAoSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QpIHtcbiAgICBJbmxheUhpbnRSZWZyZXNoUmVxdWVzdC5tZXRob2QgPSBgd29ya3NwYWNlL2lubGF5SGludC9yZWZyZXNoYDtcbiAgICBJbmxheUhpbnRSZWZyZXNoUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIElubGF5SGludFJlZnJlc2hSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlMChJbmxheUhpbnRSZWZyZXNoUmVxdWVzdC5tZXRob2QpO1xufSkoSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLklubGF5SGludFJlZnJlc2hSZXF1ZXN0IHx8IChleHBvcnRzLklubGF5SGludFJlZnJlc2hSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzQyNTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLklubGluZVZhbHVlUmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLklubGluZVZhbHVlUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1OTkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcHJvdmlkZSBpbmxpbmUgdmFsdWVzIGluIGEgZG9jdW1lbnQuIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mXG4gKiB0eXBlIHtAbGluayBJbmxpbmVWYWx1ZVBhcmFtc30sIHRoZSByZXNwb25zZSBpcyBvZiB0eXBlXG4gKiB7QGxpbmsgSW5saW5lVmFsdWUgSW5saW5lVmFsdWVbXX0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5saW5lVmFsdWVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChJbmxpbmVWYWx1ZVJlcXVlc3QpIHtcbiAgICBJbmxpbmVWYWx1ZVJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9pbmxpbmVWYWx1ZSc7XG4gICAgSW5saW5lVmFsdWVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgSW5saW5lVmFsdWVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKElubGluZVZhbHVlUmVxdWVzdC5tZXRob2QpO1xufSkoSW5saW5lVmFsdWVSZXF1ZXN0ID0gZXhwb3J0cy5JbmxpbmVWYWx1ZVJlcXVlc3QgfHwgKGV4cG9ydHMuSW5saW5lVmFsdWVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdDtcbihmdW5jdGlvbiAoSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdCkge1xuICAgIElubGluZVZhbHVlUmVmcmVzaFJlcXVlc3QubWV0aG9kID0gYHdvcmtzcGFjZS9pbmxpbmVWYWx1ZS9yZWZyZXNoYDtcbiAgICBJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdC5tZXRob2QpO1xufSkoSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdCB8fCAoZXhwb3J0cy5JbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjUyNTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5Xb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0ID0gZXhwb3J0cy5Db2RlQWN0aW9uUmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLkNvZGVBY3Rpb25SZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudFN5bWJvbFJlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50SGlnaGxpZ2h0UmVxdWVzdCA9IGV4cG9ydHMuUmVmZXJlbmNlc1JlcXVlc3QgPSBleHBvcnRzLkRlZmluaXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5TaWduYXR1cmVIZWxwUmVxdWVzdCA9IGV4cG9ydHMuU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kID0gZXhwb3J0cy5Ib3ZlclJlcXVlc3QgPSBleHBvcnRzLkNvbXBsZXRpb25SZXNvbHZlUmVxdWVzdCA9IGV4cG9ydHMuQ29tcGxldGlvblJlcXVlc3QgPSBleHBvcnRzLkNvbXBsZXRpb25UcmlnZ2VyS2luZCA9IGV4cG9ydHMuUHVibGlzaERpYWdub3N0aWNzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5XYXRjaEtpbmQgPSBleHBvcnRzLlJlbGF0aXZlUGF0dGVybiA9IGV4cG9ydHMuRmlsZUNoYW5nZVR5cGUgPSBleHBvcnRzLkRpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0ID0gZXhwb3J0cy5XaWxsU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuVGV4dERvY3VtZW50U2F2ZVJlYXNvbiA9IGV4cG9ydHMuRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENoYW5nZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50ID0gZXhwb3J0cy5EaWRPcGVuVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5UZXh0RG9jdW1lbnRTeW5jS2luZCA9IGV4cG9ydHMuVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkxvZ01lc3NhZ2VOb3RpZmljYXRpb24gPSBleHBvcnRzLlNob3dNZXNzYWdlUmVxdWVzdCA9IGV4cG9ydHMuU2hvd01lc3NhZ2VOb3RpZmljYXRpb24gPSBleHBvcnRzLk1lc3NhZ2VUeXBlID0gZXhwb3J0cy5EaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uID0gZXhwb3J0cy5FeGl0Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5TaHV0ZG93blJlcXVlc3QgPSBleHBvcnRzLkluaXRpYWxpemVkTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Jbml0aWFsaXplRXJyb3JDb2RlcyA9IGV4cG9ydHMuSW5pdGlhbGl6ZVJlcXVlc3QgPSBleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NPcHRpb25zID0gZXhwb3J0cy5UZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zID0gZXhwb3J0cy5TdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zID0gZXhwb3J0cy5Qb3NpdGlvbkVuY29kaW5nS2luZCA9IGV4cG9ydHMuRmFpbHVyZUhhbmRsaW5nS2luZCA9IGV4cG9ydHMuUmVzb3VyY2VPcGVyYXRpb25LaW5kID0gZXhwb3J0cy5VbnJlZ2lzdHJhdGlvblJlcXVlc3QgPSBleHBvcnRzLlJlZ2lzdHJhdGlvblJlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50U2VsZWN0b3IgPSBleHBvcnRzLk5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlciA9IGV4cG9ydHMuTm90ZWJvb2tEb2N1bWVudEZpbHRlciA9IGV4cG9ydHMuVGV4dERvY3VtZW50RmlsdGVyID0gdm9pZCAwO1xuZXhwb3J0cy5UeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0ID0gZXhwb3J0cy5UeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QgPSBleHBvcnRzLk1vbmlrZXJSZXF1ZXN0ID0gZXhwb3J0cy5Nb25pa2VyS2luZCA9IGV4cG9ydHMuVW5pcXVlbmVzc0xldmVsID0gZXhwb3J0cy5XaWxsRGVsZXRlRmlsZXNSZXF1ZXN0ID0gZXhwb3J0cy5EaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV2lsbFJlbmFtZUZpbGVzUmVxdWVzdCA9IGV4cG9ydHMuRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24gPSBleHBvcnRzLldpbGxDcmVhdGVGaWxlc1JlcXVlc3QgPSBleHBvcnRzLkRpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5GaWxlT3BlcmF0aW9uUGF0dGVybktpbmQgPSBleHBvcnRzLkxpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3QgPSBleHBvcnRzLlNob3dEb2N1bWVudFJlcXVlc3QgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZSA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0ID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlcXVlc3QgPSBleHBvcnRzLlRva2VuRm9ybWF0ID0gZXhwb3J0cy5DYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QgPSBleHBvcnRzLkNhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdCA9IGV4cG9ydHMuQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0ID0gZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdCA9IGV4cG9ydHMuV29ya0RvbmVQcm9ncmVzcyA9IGV4cG9ydHMuU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0ID0gZXhwb3J0cy5EZWNsYXJhdGlvblJlcXVlc3QgPSBleHBvcnRzLkZvbGRpbmdSYW5nZVJlcXVlc3QgPSBleHBvcnRzLkNvbG9yUHJlc2VudGF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRDb2xvclJlcXVlc3QgPSBleHBvcnRzLkNvbmZpZ3VyYXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5EaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Xb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCA9IGV4cG9ydHMuVHlwZURlZmluaXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5JbXBsZW1lbnRhdGlvblJlcXVlc3QgPSBleHBvcnRzLkFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3QgPSBleHBvcnRzLkV4ZWN1dGVDb21tYW5kUmVxdWVzdCA9IGV4cG9ydHMuUHJlcGFyZVJlbmFtZVJlcXVlc3QgPSBleHBvcnRzLlJlbmFtZVJlcXVlc3QgPSBleHBvcnRzLlByZXBhcmVTdXBwb3J0RGVmYXVsdEJlaGF2aW9yID0gZXhwb3J0cy5Eb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudExpbmtSZXF1ZXN0ID0gZXhwb3J0cy5Db2RlTGVuc1JlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5Db2RlTGVuc1Jlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5Db2RlTGVuc1JlcXVlc3QgPSBleHBvcnRzLldvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0ID0gdm9pZCAwO1xuZXhwb3J0cy5EaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5Ob3RlYm9va0NlbGxBcnJheUNoYW5nZSA9IGV4cG9ydHMuRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLk5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZSA9IGV4cG9ydHMuTm90ZWJvb2tEb2N1bWVudCA9IGV4cG9ydHMuTm90ZWJvb2tDZWxsID0gZXhwb3J0cy5FeGVjdXRpb25TdW1tYXJ5ID0gZXhwb3J0cy5Ob3RlYm9va0NlbGxLaW5kID0gZXhwb3J0cy5EaWFnbm9zdGljUmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLldvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudERpYWdub3N0aWNSZXBvcnRLaW5kID0gZXhwb3J0cy5EaWFnbm9zdGljU2VydmVyQ2FuY2VsbGF0aW9uRGF0YSA9IGV4cG9ydHMuSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLklubGF5SGludFJlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5JbmxheUhpbnRSZXF1ZXN0ID0gZXhwb3J0cy5JbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5JbmxpbmVWYWx1ZVJlcXVlc3QgPSBleHBvcnRzLlR5cGVIaWVyYXJjaHlTdXBlcnR5cGVzUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1OTkpO1xuY29uc3QgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3R5cGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3NjcpO1xuY29uc3QgSXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1MjMpO1xuY29uc3QgcHJvdG9jb2xfaW1wbGVtZW50YXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oOTM4MCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbXBsZW1lbnRhdGlvblJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbXBsZW1lbnRhdGlvbl8xLkltcGxlbWVudGF0aW9uUmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF90eXBlRGVmaW5pdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NjQyKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVEZWZpbml0aW9uUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3R5cGVEZWZpbml0aW9uXzEuVHlwZURlZmluaXRpb25SZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX3dvcmtzcGFjZUZvbGRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDAyKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfd29ya3NwYWNlRm9sZGVyXzEuV29ya3NwYWNlRm9sZGVyc1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3dvcmtzcGFjZUZvbGRlcl8xLkRpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb247IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfY29uZmlndXJhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NDQyKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbmZpZ3VyYXRpb25SZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfY29uZmlndXJhdGlvbl8xLkNvbmZpZ3VyYXRpb25SZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2NvbG9yUHJvdmlkZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzkwOCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEb2N1bWVudENvbG9yUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2NvbG9yUHJvdmlkZXJfMS5Eb2N1bWVudENvbG9yUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb2xvclByZXNlbnRhdGlvblJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9jb2xvclByb3ZpZGVyXzEuQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2ZvbGRpbmdSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MDI5KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZvbGRpbmdSYW5nZVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9mb2xkaW5nUmFuZ2VfMS5Gb2xkaW5nUmFuZ2VSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2RlY2xhcmF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyMTApO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGVjbGFyYXRpb25SZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfZGVjbGFyYXRpb25fMS5EZWNsYXJhdGlvblJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfc2VsZWN0aW9uUmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjM5Mik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZWxlY3Rpb25SYW5nZVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9zZWxlY3Rpb25SYW5nZV8xLlNlbGVjdGlvblJhbmdlUmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9wcm9ncmVzc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3ODk1KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldvcmtEb25lUHJvZ3Jlc3NcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9wcm9ncmVzc18xLldvcmtEb25lUHJvZ3Jlc3M7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9wcm9ncmVzc18xLldvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9wcm9ncmVzc18xLldvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb247IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfY2FsbEhpZXJhcmNoeV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NDM0KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2NhbGxIaWVyYXJjaHlfMS5DYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfY2FsbEhpZXJhcmNoeV8xLkNhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9jYWxsSGllcmFyY2h5XzEuQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX3NlbWFudGljVG9rZW5zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0ODkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVG9rZW5Gb3JtYXRcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9zZW1hbnRpY1Rva2Vuc18xLlRva2VuRm9ybWF0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlbWFudGljVG9rZW5zUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3NlbWFudGljVG9rZW5zXzEuU2VtYW50aWNUb2tlbnNSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfc2VtYW50aWNUb2tlbnNfMS5TZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3NlbWFudGljVG9rZW5zXzEuU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3NlbWFudGljVG9rZW5zXzEuU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9zZW1hbnRpY1Rva2Vuc18xLlNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZTsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9zaG93RG9jdW1lbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTU0MSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTaG93RG9jdW1lbnRSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfc2hvd0RvY3VtZW50XzEuU2hvd0RvY3VtZW50UmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9saW5rZWRFZGl0aW5nUmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTI3KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9saW5rZWRFZGl0aW5nUmFuZ2VfMS5MaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2ZpbGVPcGVyYXRpb25zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxOTApO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfZmlsZU9wZXJhdGlvbnNfMS5GaWxlT3BlcmF0aW9uUGF0dGVybktpbmQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLkRpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldpbGxDcmVhdGVGaWxlc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLldpbGxDcmVhdGVGaWxlc1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLkRpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldpbGxSZW5hbWVGaWxlc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLldpbGxSZW5hbWVGaWxlc1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLkRpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldpbGxEZWxldGVGaWxlc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLldpbGxEZWxldGVGaWxlc1JlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfbW9uaWtlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTY0KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVuaXF1ZW5lc3NMZXZlbFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX21vbmlrZXJfMS5VbmlxdWVuZXNzTGV2ZWw7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTW9uaWtlcktpbmRcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9tb25pa2VyXzEuTW9uaWtlcktpbmQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTW9uaWtlclJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9tb25pa2VyXzEuTW9uaWtlclJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfdHlwZUhpZXJhcmNoeV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MzE4KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3R5cGVIaWVyYXJjaHlfMS5UeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3R5cGVIaWVyYXJjaHlfMS5UeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVIaWVyYXJjaHlTdXBlcnR5cGVzUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3R5cGVIaWVyYXJjaHlfMS5UeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfaW5saW5lVmFsdWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzQyNSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmxpbmVWYWx1ZVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbmxpbmVWYWx1ZV8xLklubGluZVZhbHVlUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfaW5saW5lVmFsdWVfMS5JbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2lubGF5SGludF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MzE1KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklubGF5SGludFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbmxheUhpbnRfMS5JbmxheUhpbnRSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklubGF5SGludFJlc29sdmVSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfaW5sYXlIaW50XzEuSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5sYXlIaW50UmVmcmVzaFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbmxheUhpbnRfMS5JbmxheUhpbnRSZWZyZXNoUmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9kaWFnbm9zdGljXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2OTIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGFcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kaWFnbm9zdGljXzEuRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGE7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2RpYWdub3N0aWNfMS5Eb2N1bWVudERpYWdub3N0aWNSZXBvcnRLaW5kOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kaWFnbm9zdGljXzEuRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2RpYWdub3N0aWNfMS5Xb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kaWFnbm9zdGljXzEuRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX25vdGVib29rXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0NjApO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90ZWJvb2tDZWxsS2luZFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX25vdGVib29rXzEuTm90ZWJvb2tDZWxsS2luZDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFeGVjdXRpb25TdW1tYXJ5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5FeGVjdXRpb25TdW1tYXJ5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGVib29rQ2VsbFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX25vdGVib29rXzEuTm90ZWJvb2tDZWxsOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGVib29rRG9jdW1lbnRcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9ub3RlYm9va18xLk5vdGVib29rRG9jdW1lbnQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5Ob3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9ub3RlYm9va18xLkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGVib29rQ2VsbEFycmF5Q2hhbmdlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5Ob3RlYm9va0NlbGxBcnJheUNoYW5nZTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5EaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5EaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9ub3RlYm9va18xLkRpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbjsgfSB9KSk7XG4vLyBAdHMtaWdub3JlOiB0byBhdm9pZCBpbmxpbmluZyBMb2NhdGlvbkxpbmsgYXMgZHluYW1pYyBpbXBvcnRcbmxldCBfX25vRHluYW1pY0ltcG9ydDtcbi8qKlxuICogVGhlIFRleHREb2N1bWVudEZpbHRlciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBUZXh0RG9jdW1lbnRGaWx0ZXJ9IGxpdGVyYWxzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIFRleHREb2N1bWVudEZpbHRlcjtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50RmlsdGVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhbmd1YWdlKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLnNjaGVtZSkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5wYXR0ZXJuKTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50RmlsdGVyLmlzID0gaXM7XG59KShUZXh0RG9jdW1lbnRGaWx0ZXIgPSBleHBvcnRzLlRleHREb2N1bWVudEZpbHRlciB8fCAoZXhwb3J0cy5UZXh0RG9jdW1lbnRGaWx0ZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgTm90ZWJvb2tEb2N1bWVudEZpbHRlciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBOb3RlYm9va0RvY3VtZW50RmlsdGVyfSBsaXRlcmFscy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBOb3RlYm9va0RvY3VtZW50RmlsdGVyO1xuKGZ1bmN0aW9uIChOb3RlYm9va0RvY3VtZW50RmlsdGVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUubm90ZWJvb2tUeXBlKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLnNjaGVtZSkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5wYXR0ZXJuKSk7XG4gICAgfVxuICAgIE5vdGVib29rRG9jdW1lbnRGaWx0ZXIuaXMgPSBpcztcbn0pKE5vdGVib29rRG9jdW1lbnRGaWx0ZXIgPSBleHBvcnRzLk5vdGVib29rRG9jdW1lbnRGaWx0ZXIgfHwgKGV4cG9ydHMuTm90ZWJvb2tEb2N1bWVudEZpbHRlciA9IHt9KSk7XG4vKipcbiAqIFRoZSBOb3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgTm90ZWJvb2tDZWxsVGV4dERvY3VtZW50RmlsdGVyfSBsaXRlcmFscy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBOb3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXI7XG4oZnVuY3Rpb24gKE5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5ub3RlYm9vaykgfHwgTm90ZWJvb2tEb2N1bWVudEZpbHRlci5pcyhjYW5kaWRhdGUubm90ZWJvb2spKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5sYW5ndWFnZSA9PT0gdW5kZWZpbmVkIHx8IElzLnN0cmluZyhjYW5kaWRhdGUubGFuZ3VhZ2UpKTtcbiAgICB9XG4gICAgTm90ZWJvb2tDZWxsVGV4dERvY3VtZW50RmlsdGVyLmlzID0gaXM7XG59KShOb3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIgPSBleHBvcnRzLk5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlciB8fCAoZXhwb3J0cy5Ob3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgRG9jdW1lbnRTZWxlY3RvciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBEb2N1bWVudFNlbGVjdG9yfXMuXG4gKi9cbnZhciBEb2N1bWVudFNlbGVjdG9yO1xuKGZ1bmN0aW9uIChEb2N1bWVudFNlbGVjdG9yKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGVsZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghSXMuc3RyaW5nKGVsZW0pICYmICFUZXh0RG9jdW1lbnRGaWx0ZXIuaXMoZWxlbSkgJiYgIU5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlci5pcyhlbGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgRG9jdW1lbnRTZWxlY3Rvci5pcyA9IGlzO1xufSkoRG9jdW1lbnRTZWxlY3RvciA9IGV4cG9ydHMuRG9jdW1lbnRTZWxlY3RvciB8fCAoZXhwb3J0cy5Eb2N1bWVudFNlbGVjdG9yID0ge30pKTtcbi8qKlxuICogVGhlIGBjbGllbnQvcmVnaXN0ZXJDYXBhYmlsaXR5YCByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gcmVnaXN0ZXIgYSBuZXcgY2FwYWJpbGl0eVxuICogaGFuZGxlciBvbiB0aGUgY2xpZW50IHNpZGUuXG4gKi9cbnZhciBSZWdpc3RyYXRpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChSZWdpc3RyYXRpb25SZXF1ZXN0KSB7XG4gICAgUmVnaXN0cmF0aW9uUmVxdWVzdC5tZXRob2QgPSAnY2xpZW50L3JlZ2lzdGVyQ2FwYWJpbGl0eSc7XG4gICAgUmVnaXN0cmF0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIFJlZ2lzdHJhdGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoUmVnaXN0cmF0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoUmVnaXN0cmF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuUmVnaXN0cmF0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5SZWdpc3RyYXRpb25SZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIGBjbGllbnQvdW5yZWdpc3RlckNhcGFiaWxpdHlgIHJlcXVlc3QgaXMgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byB1bnJlZ2lzdGVyIGEgcHJldmlvdXNseSByZWdpc3RlcmVkIGNhcGFiaWxpdHlcbiAqIGhhbmRsZXIgb24gdGhlIGNsaWVudCBzaWRlLlxuICovXG52YXIgVW5yZWdpc3RyYXRpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChVbnJlZ2lzdHJhdGlvblJlcXVlc3QpIHtcbiAgICBVbnJlZ2lzdHJhdGlvblJlcXVlc3QubWV0aG9kID0gJ2NsaWVudC91bnJlZ2lzdGVyQ2FwYWJpbGl0eSc7XG4gICAgVW5yZWdpc3RyYXRpb25SZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgVW5yZWdpc3RyYXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFVucmVnaXN0cmF0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoVW5yZWdpc3RyYXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5VbnJlZ2lzdHJhdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuVW5yZWdpc3RyYXRpb25SZXF1ZXN0ID0ge30pKTtcbnZhciBSZXNvdXJjZU9wZXJhdGlvbktpbmQ7XG4oZnVuY3Rpb24gKFJlc291cmNlT3BlcmF0aW9uS2luZCkge1xuICAgIC8qKlxuICAgICAqIFN1cHBvcnRzIGNyZWF0aW5nIG5ldyBmaWxlcyBhbmQgZm9sZGVycy5cbiAgICAgKi9cbiAgICBSZXNvdXJjZU9wZXJhdGlvbktpbmQuQ3JlYXRlID0gJ2NyZWF0ZSc7XG4gICAgLyoqXG4gICAgICogU3VwcG9ydHMgcmVuYW1pbmcgZXhpc3RpbmcgZmlsZXMgYW5kIGZvbGRlcnMuXG4gICAgICovXG4gICAgUmVzb3VyY2VPcGVyYXRpb25LaW5kLlJlbmFtZSA9ICdyZW5hbWUnO1xuICAgIC8qKlxuICAgICAqIFN1cHBvcnRzIGRlbGV0aW5nIGV4aXN0aW5nIGZpbGVzIGFuZCBmb2xkZXJzLlxuICAgICAqL1xuICAgIFJlc291cmNlT3BlcmF0aW9uS2luZC5EZWxldGUgPSAnZGVsZXRlJztcbn0pKFJlc291cmNlT3BlcmF0aW9uS2luZCA9IGV4cG9ydHMuUmVzb3VyY2VPcGVyYXRpb25LaW5kIHx8IChleHBvcnRzLlJlc291cmNlT3BlcmF0aW9uS2luZCA9IHt9KSk7XG52YXIgRmFpbHVyZUhhbmRsaW5nS2luZDtcbihmdW5jdGlvbiAoRmFpbHVyZUhhbmRsaW5nS2luZCkge1xuICAgIC8qKlxuICAgICAqIEFwcGx5aW5nIHRoZSB3b3Jrc3BhY2UgY2hhbmdlIGlzIHNpbXBseSBhYm9ydGVkIGlmIG9uZSBvZiB0aGUgY2hhbmdlcyBwcm92aWRlZFxuICAgICAqIGZhaWxzLiBBbGwgb3BlcmF0aW9ucyBleGVjdXRlZCBiZWZvcmUgdGhlIGZhaWxpbmcgb3BlcmF0aW9uIHN0YXkgZXhlY3V0ZWQuXG4gICAgICovXG4gICAgRmFpbHVyZUhhbmRsaW5nS2luZC5BYm9ydCA9ICdhYm9ydCc7XG4gICAgLyoqXG4gICAgICogQWxsIG9wZXJhdGlvbnMgYXJlIGV4ZWN1dGVkIHRyYW5zYWN0aW9uYWwuIFRoYXQgbWVhbnMgdGhleSBlaXRoZXIgYWxsXG4gICAgICogc3VjY2VlZCBvciBubyBjaGFuZ2VzIGF0IGFsbCBhcmUgYXBwbGllZCB0byB0aGUgd29ya3NwYWNlLlxuICAgICAqL1xuICAgIEZhaWx1cmVIYW5kbGluZ0tpbmQuVHJhbnNhY3Rpb25hbCA9ICd0cmFuc2FjdGlvbmFsJztcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgd29ya3NwYWNlIGVkaXQgY29udGFpbnMgb25seSB0ZXh0dWFsIGZpbGUgY2hhbmdlcyB0aGV5IGFyZSBleGVjdXRlZCB0cmFuc2FjdGlvbmFsLlxuICAgICAqIElmIHJlc291cmNlIGNoYW5nZXMgKGNyZWF0ZSwgcmVuYW1lIG9yIGRlbGV0ZSBmaWxlKSBhcmUgcGFydCBvZiB0aGUgY2hhbmdlIHRoZSBmYWlsdXJlXG4gICAgICogaGFuZGxpbmcgc3RyYXRlZ3kgaXMgYWJvcnQuXG4gICAgICovXG4gICAgRmFpbHVyZUhhbmRsaW5nS2luZC5UZXh0T25seVRyYW5zYWN0aW9uYWwgPSAndGV4dE9ubHlUcmFuc2FjdGlvbmFsJztcbiAgICAvKipcbiAgICAgKiBUaGUgY2xpZW50IHRyaWVzIHRvIHVuZG8gdGhlIG9wZXJhdGlvbnMgYWxyZWFkeSBleGVjdXRlZC4gQnV0IHRoZXJlIGlzIG5vXG4gICAgICogZ3VhcmFudGVlIHRoYXQgdGhpcyBpcyBzdWNjZWVkaW5nLlxuICAgICAqL1xuICAgIEZhaWx1cmVIYW5kbGluZ0tpbmQuVW5kbyA9ICd1bmRvJztcbn0pKEZhaWx1cmVIYW5kbGluZ0tpbmQgPSBleHBvcnRzLkZhaWx1cmVIYW5kbGluZ0tpbmQgfHwgKGV4cG9ydHMuRmFpbHVyZUhhbmRsaW5nS2luZCA9IHt9KSk7XG4vKipcbiAqIEEgc2V0IG9mIHByZWRlZmluZWQgcG9zaXRpb24gZW5jb2Rpbmcga2luZHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgUG9zaXRpb25FbmNvZGluZ0tpbmQ7XG4oZnVuY3Rpb24gKFBvc2l0aW9uRW5jb2RpbmdLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQ2hhcmFjdGVyIG9mZnNldHMgY291bnQgVVRGLTggY29kZSB1bml0cyAoZS5nLiBieXRlcykuXG4gICAgICovXG4gICAgUG9zaXRpb25FbmNvZGluZ0tpbmQuVVRGOCA9ICd1dGYtOCc7XG4gICAgLyoqXG4gICAgICogQ2hhcmFjdGVyIG9mZnNldHMgY291bnQgVVRGLTE2IGNvZGUgdW5pdHMuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHRoZSBkZWZhdWx0IGFuZCBtdXN0IGFsd2F5cyBiZSBzdXBwb3J0ZWRcbiAgICAgKiBieSBzZXJ2ZXJzXG4gICAgICovXG4gICAgUG9zaXRpb25FbmNvZGluZ0tpbmQuVVRGMTYgPSAndXRmLTE2JztcbiAgICAvKipcbiAgICAgKiBDaGFyYWN0ZXIgb2Zmc2V0cyBjb3VudCBVVEYtMzIgY29kZSB1bml0cy5cbiAgICAgKlxuICAgICAqIEltcGxlbWVudGF0aW9uIG5vdGU6IHRoZXNlIGFyZSB0aGUgc2FtZSBhcyBVbmljb2RlIGNvZGVwb2ludHMsXG4gICAgICogc28gdGhpcyBgUG9zaXRpb25FbmNvZGluZ0tpbmRgIG1heSBhbHNvIGJlIHVzZWQgZm9yIGFuXG4gICAgICogZW5jb2RpbmctYWdub3N0aWMgcmVwcmVzZW50YXRpb24gb2YgY2hhcmFjdGVyIG9mZnNldHMuXG4gICAgICovXG4gICAgUG9zaXRpb25FbmNvZGluZ0tpbmQuVVRGMzIgPSAndXRmLTMyJztcbn0pKFBvc2l0aW9uRW5jb2RpbmdLaW5kID0gZXhwb3J0cy5Qb3NpdGlvbkVuY29kaW5nS2luZCB8fCAoZXhwb3J0cy5Qb3NpdGlvbkVuY29kaW5nS2luZCA9IHt9KSk7XG4vKipcbiAqIFRoZSBTdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFN0YXRpY1JlZ2lzdHJhdGlvbk9wdGlvbnN9IGxpdGVyYWxzLlxuICovXG52YXIgU3RhdGljUmVnaXN0cmF0aW9uT3B0aW9ucztcbihmdW5jdGlvbiAoU3RhdGljUmVnaXN0cmF0aW9uT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGhhc0lkKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLnN0cmluZyhjYW5kaWRhdGUuaWQpICYmIGNhbmRpZGF0ZS5pZC5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBTdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zLmhhc0lkID0gaGFzSWQ7XG59KShTdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zID0gZXhwb3J0cy5TdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zIHx8IChleHBvcnRzLlN0YXRpY1JlZ2lzdHJhdGlvbk9wdGlvbnMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgVGV4dERvY3VtZW50UmVnaXN0cmF0aW9uT3B0aW9ucyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBUZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zfSBsaXRlcmFscy5cbiAqL1xudmFyIFRleHREb2N1bWVudFJlZ2lzdHJhdGlvbk9wdGlvbnM7XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudFJlZ2lzdHJhdGlvbk9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiAoY2FuZGlkYXRlLmRvY3VtZW50U2VsZWN0b3IgPT09IG51bGwgfHwgRG9jdW1lbnRTZWxlY3Rvci5pcyhjYW5kaWRhdGUuZG9jdW1lbnRTZWxlY3RvcikpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zLmlzID0gaXM7XG59KShUZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zID0gZXhwb3J0cy5UZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zIHx8IChleHBvcnRzLlRleHREb2N1bWVudFJlZ2lzdHJhdGlvbk9wdGlvbnMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgV29ya0RvbmVQcm9ncmVzc09wdGlvbnMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgV29ya0RvbmVQcm9ncmVzc09wdGlvbnN9IGxpdGVyYWxzLlxuICovXG52YXIgV29ya0RvbmVQcm9ncmVzc09wdGlvbnM7XG4oZnVuY3Rpb24gKFdvcmtEb25lUHJvZ3Jlc3NPcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgKGNhbmRpZGF0ZS53b3JrRG9uZVByb2dyZXNzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUud29ya0RvbmVQcm9ncmVzcykpO1xuICAgIH1cbiAgICBXb3JrRG9uZVByb2dyZXNzT3B0aW9ucy5pcyA9IGlzO1xuICAgIGZ1bmN0aW9uIGhhc1dvcmtEb25lUHJvZ3Jlc3ModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuYm9vbGVhbihjYW5kaWRhdGUud29ya0RvbmVQcm9ncmVzcyk7XG4gICAgfVxuICAgIFdvcmtEb25lUHJvZ3Jlc3NPcHRpb25zLmhhc1dvcmtEb25lUHJvZ3Jlc3MgPSBoYXNXb3JrRG9uZVByb2dyZXNzO1xufSkoV29ya0RvbmVQcm9ncmVzc09wdGlvbnMgPSBleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NPcHRpb25zIHx8IChleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NPcHRpb25zID0ge30pKTtcbi8qKlxuICogVGhlIGluaXRpYWxpemUgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyLlxuICogSXQgaXMgc2VudCBvbmNlIGFzIHRoZSByZXF1ZXN0IGFmdGVyIHN0YXJ0aW5nIHVwIHRoZSBzZXJ2ZXIuXG4gKiBUaGUgcmVxdWVzdHMgcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIEluaXRpYWxpemVQYXJhbXN9XG4gKiB0aGUgcmVzcG9uc2UgaWYgb2YgdHlwZSB7QGxpbmsgSW5pdGlhbGl6ZVJlc3VsdH0gb2YgYSBUaGVuYWJsZSB0aGF0XG4gKiByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgSW5pdGlhbGl6ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKEluaXRpYWxpemVSZXF1ZXN0KSB7XG4gICAgSW5pdGlhbGl6ZVJlcXVlc3QubWV0aG9kID0gJ2luaXRpYWxpemUnO1xuICAgIEluaXRpYWxpemVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgSW5pdGlhbGl6ZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSW5pdGlhbGl6ZVJlcXVlc3QubWV0aG9kKTtcbn0pKEluaXRpYWxpemVSZXF1ZXN0ID0gZXhwb3J0cy5Jbml0aWFsaXplUmVxdWVzdCB8fCAoZXhwb3J0cy5Jbml0aWFsaXplUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEtub3duIGVycm9yIGNvZGVzIGZvciBhbiBgSW5pdGlhbGl6ZUVycm9yQ29kZXNgO1xuICovXG52YXIgSW5pdGlhbGl6ZUVycm9yQ29kZXM7XG4oZnVuY3Rpb24gKEluaXRpYWxpemVFcnJvckNvZGVzKSB7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHByb3RvY29sIHZlcnNpb24gcHJvdmlkZWQgYnkgdGhlIGNsaWVudCBjYW4ndCBiZSBoYW5kbGVkIGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIGluaXRpYWxpemUgZXJyb3IgZ290IHJlcGxhY2VkIGJ5IGNsaWVudCBjYXBhYmlsaXRpZXMuIFRoZXJlIGlzXG4gICAgICogbm8gdmVyc2lvbiBoYW5kc2hha2UgaW4gdmVyc2lvbiAzLjB4XG4gICAgICovXG4gICAgSW5pdGlhbGl6ZUVycm9yQ29kZXMudW5rbm93blByb3RvY29sVmVyc2lvbiA9IDE7XG59KShJbml0aWFsaXplRXJyb3JDb2RlcyA9IGV4cG9ydHMuSW5pdGlhbGl6ZUVycm9yQ29kZXMgfHwgKGV4cG9ydHMuSW5pdGlhbGl6ZUVycm9yQ29kZXMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgaW5pdGlhbGl6ZWQgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZVxuICogc2VydmVyIGFmdGVyIHRoZSBjbGllbnQgaXMgZnVsbHkgaW5pdGlhbGl6ZWQgYW5kIHRoZSBzZXJ2ZXJcbiAqIGlzIGFsbG93ZWQgdG8gc2VuZCByZXF1ZXN0cyBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudC5cbiAqL1xudmFyIEluaXRpYWxpemVkTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChJbml0aWFsaXplZE5vdGlmaWNhdGlvbikge1xuICAgIEluaXRpYWxpemVkTm90aWZpY2F0aW9uLm1ldGhvZCA9ICdpbml0aWFsaXplZCc7XG4gICAgSW5pdGlhbGl6ZWROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBJbml0aWFsaXplZE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKEluaXRpYWxpemVkTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShJbml0aWFsaXplZE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuSW5pdGlhbGl6ZWROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuSW5pdGlhbGl6ZWROb3RpZmljYXRpb24gPSB7fSkpO1xuLy8tLS0tIFNodXRkb3duIE1ldGhvZCAtLS0tXG4vKipcbiAqIEEgc2h1dGRvd24gcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyLlxuICogSXQgaXMgc2VudCBvbmNlIHdoZW4gdGhlIGNsaWVudCBkZWNpZGVzIHRvIHNodXRkb3duIHRoZVxuICogc2VydmVyLiBUaGUgb25seSBub3RpZmljYXRpb24gdGhhdCBpcyBzZW50IGFmdGVyIGEgc2h1dGRvd24gcmVxdWVzdFxuICogaXMgdGhlIGV4aXQgZXZlbnQuXG4gKi9cbnZhciBTaHV0ZG93blJlcXVlc3Q7XG4oZnVuY3Rpb24gKFNodXRkb3duUmVxdWVzdCkge1xuICAgIFNodXRkb3duUmVxdWVzdC5tZXRob2QgPSAnc2h1dGRvd24nO1xuICAgIFNodXRkb3duUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFNodXRkb3duUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoU2h1dGRvd25SZXF1ZXN0Lm1ldGhvZCk7XG59KShTaHV0ZG93blJlcXVlc3QgPSBleHBvcnRzLlNodXRkb3duUmVxdWVzdCB8fCAoZXhwb3J0cy5TaHV0ZG93blJlcXVlc3QgPSB7fSkpO1xuLy8tLS0tIEV4aXQgTm90aWZpY2F0aW9uIC0tLS1cbi8qKlxuICogVGhlIGV4aXQgZXZlbnQgaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB0b1xuICogYXNrIHRoZSBzZXJ2ZXIgdG8gZXhpdCBpdHMgcHJvY2Vzcy5cbiAqL1xudmFyIEV4aXROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKEV4aXROb3RpZmljYXRpb24pIHtcbiAgICBFeGl0Tm90aWZpY2F0aW9uLm1ldGhvZCA9ICdleGl0JztcbiAgICBFeGl0Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRXhpdE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlMChFeGl0Tm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShFeGl0Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5FeGl0Tm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkV4aXROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXJcbiAqIHdoZW4gdGhlIGNsaWVudCdzIGNvbmZpZ3VyYXRpb24gaGFzIGNoYW5nZWQuIFRoZSBub3RpZmljYXRpb24gY29udGFpbnNcbiAqIHRoZSBjaGFuZ2VkIGNvbmZpZ3VyYXRpb24gYXMgZGVmaW5lZCBieSB0aGUgbGFuZ3VhZ2UgY2xpZW50LlxuICovXG52YXIgRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbikge1xuICAgIERpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24ubWV0aG9kID0gJ3dvcmtzcGFjZS9kaWRDaGFuZ2VDb25maWd1cmF0aW9uJztcbiAgICBEaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vLy0tLS0gTWVzc2FnZSBzaG93IGFuZCBsb2cgbm90aWZpY2F0aW9ucyAtLS0tXG4vKipcbiAqIFRoZSBtZXNzYWdlIHR5cGVcbiAqL1xudmFyIE1lc3NhZ2VUeXBlO1xuKGZ1bmN0aW9uIChNZXNzYWdlVHlwZSkge1xuICAgIC8qKlxuICAgICAqIEFuIGVycm9yIG1lc3NhZ2UuXG4gICAgICovXG4gICAgTWVzc2FnZVR5cGUuRXJyb3IgPSAxO1xuICAgIC8qKlxuICAgICAqIEEgd2FybmluZyBtZXNzYWdlLlxuICAgICAqL1xuICAgIE1lc3NhZ2VUeXBlLldhcm5pbmcgPSAyO1xuICAgIC8qKlxuICAgICAqIEFuIGluZm9ybWF0aW9uIG1lc3NhZ2UuXG4gICAgICovXG4gICAgTWVzc2FnZVR5cGUuSW5mbyA9IDM7XG4gICAgLyoqXG4gICAgICogQSBsb2cgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBNZXNzYWdlVHlwZS5Mb2cgPSA0O1xufSkoTWVzc2FnZVR5cGUgPSBleHBvcnRzLk1lc3NhZ2VUeXBlIHx8IChleHBvcnRzLk1lc3NhZ2VUeXBlID0ge30pKTtcbi8qKlxuICogVGhlIHNob3cgbWVzc2FnZSBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIGEgc2VydmVyIHRvIGEgY2xpZW50IHRvIGFza1xuICogdGhlIGNsaWVudCB0byBkaXNwbGF5IGEgcGFydGljdWxhciBtZXNzYWdlIGluIHRoZSB1c2VyIGludGVyZmFjZS5cbiAqL1xudmFyIFNob3dNZXNzYWdlTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChTaG93TWVzc2FnZU5vdGlmaWNhdGlvbikge1xuICAgIFNob3dNZXNzYWdlTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3aW5kb3cvc2hvd01lc3NhZ2UnO1xuICAgIFNob3dNZXNzYWdlTm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgU2hvd01lc3NhZ2VOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShTaG93TWVzc2FnZU5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoU2hvd01lc3NhZ2VOb3RpZmljYXRpb24gPSBleHBvcnRzLlNob3dNZXNzYWdlTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLlNob3dNZXNzYWdlTm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIHNob3cgbWVzc2FnZSByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gc2hvdyBhIG1lc3NhZ2VcbiAqIGFuZCBhIHNldCBvZiBvcHRpb25zIGFjdGlvbnMgdG8gdGhlIHVzZXIuXG4gKi9cbnZhciBTaG93TWVzc2FnZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKFNob3dNZXNzYWdlUmVxdWVzdCkge1xuICAgIFNob3dNZXNzYWdlUmVxdWVzdC5tZXRob2QgPSAnd2luZG93L3Nob3dNZXNzYWdlUmVxdWVzdCc7XG4gICAgU2hvd01lc3NhZ2VSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgU2hvd01lc3NhZ2VSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFNob3dNZXNzYWdlUmVxdWVzdC5tZXRob2QpO1xufSkoU2hvd01lc3NhZ2VSZXF1ZXN0ID0gZXhwb3J0cy5TaG93TWVzc2FnZVJlcXVlc3QgfHwgKGV4cG9ydHMuU2hvd01lc3NhZ2VSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIGxvZyBtZXNzYWdlIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIGFza1xuICogdGhlIGNsaWVudCB0byBsb2cgYSBwYXJ0aWN1bGFyIG1lc3NhZ2UuXG4gKi9cbnZhciBMb2dNZXNzYWdlTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChMb2dNZXNzYWdlTm90aWZpY2F0aW9uKSB7XG4gICAgTG9nTWVzc2FnZU5vdGlmaWNhdGlvbi5tZXRob2QgPSAnd2luZG93L2xvZ01lc3NhZ2UnO1xuICAgIExvZ01lc3NhZ2VOb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBMb2dNZXNzYWdlTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoTG9nTWVzc2FnZU5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoTG9nTWVzc2FnZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuTG9nTWVzc2FnZU5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5Mb2dNZXNzYWdlTm90aWZpY2F0aW9uID0ge30pKTtcbi8vLS0tLSBUZWxlbWV0cnkgbm90aWZpY2F0aW9uXG4vKipcbiAqIFRoZSB0ZWxlbWV0cnkgZXZlbnQgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gYXNrXG4gKiB0aGUgY2xpZW50IHRvIGxvZyB0ZWxlbWV0cnkgZGF0YS5cbiAqL1xudmFyIFRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChUZWxlbWV0cnlFdmVudE5vdGlmaWNhdGlvbikge1xuICAgIFRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uLm1ldGhvZCA9ICd0ZWxlbWV0cnkvZXZlbnQnO1xuICAgIFRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShUZWxlbWV0cnlFdmVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24gPSBleHBvcnRzLlRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uIHx8IChleHBvcnRzLlRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogRGVmaW5lcyBob3cgdGhlIGhvc3QgKGVkaXRvcikgc2hvdWxkIHN5bmNcbiAqIGRvY3VtZW50IGNoYW5nZXMgdG8gdGhlIGxhbmd1YWdlIHNlcnZlci5cbiAqL1xudmFyIFRleHREb2N1bWVudFN5bmNLaW5kO1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRTeW5jS2luZCkge1xuICAgIC8qKlxuICAgICAqIERvY3VtZW50cyBzaG91bGQgbm90IGJlIHN5bmNlZCBhdCBhbGwuXG4gICAgICovXG4gICAgVGV4dERvY3VtZW50U3luY0tpbmQuTm9uZSA9IDA7XG4gICAgLyoqXG4gICAgICogRG9jdW1lbnRzIGFyZSBzeW5jZWQgYnkgYWx3YXlzIHNlbmRpbmcgdGhlIGZ1bGwgY29udGVudFxuICAgICAqIG9mIHRoZSBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBUZXh0RG9jdW1lbnRTeW5jS2luZC5GdWxsID0gMTtcbiAgICAvKipcbiAgICAgKiBEb2N1bWVudHMgYXJlIHN5bmNlZCBieSBzZW5kaW5nIHRoZSBmdWxsIGNvbnRlbnQgb24gb3Blbi5cbiAgICAgKiBBZnRlciB0aGF0IG9ubHkgaW5jcmVtZW50YWwgdXBkYXRlcyB0byB0aGUgZG9jdW1lbnQgYXJlXG4gICAgICogc2VuZC5cbiAgICAgKi9cbiAgICBUZXh0RG9jdW1lbnRTeW5jS2luZC5JbmNyZW1lbnRhbCA9IDI7XG59KShUZXh0RG9jdW1lbnRTeW5jS2luZCA9IGV4cG9ydHMuVGV4dERvY3VtZW50U3luY0tpbmQgfHwgKGV4cG9ydHMuVGV4dERvY3VtZW50U3luY0tpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZG9jdW1lbnQgb3BlbiBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB0byBzaWduYWxcbiAqIG5ld2x5IG9wZW5lZCB0ZXh0IGRvY3VtZW50cy4gVGhlIGRvY3VtZW50J3MgdHJ1dGggaXMgbm93IG1hbmFnZWQgYnkgdGhlIGNsaWVudFxuICogYW5kIHRoZSBzZXJ2ZXIgbXVzdCBub3QgdHJ5IHRvIHJlYWQgdGhlIGRvY3VtZW50J3MgdHJ1dGggdXNpbmcgdGhlIGRvY3VtZW50J3NcbiAqIHVyaS4gT3BlbiBpbiB0aGlzIHNlbnNlIG1lYW5zIGl0IGlzIG1hbmFnZWQgYnkgdGhlIGNsaWVudC4gSXQgZG9lc24ndCBuZWNlc3NhcmlseVxuICogbWVhbiB0aGF0IGl0cyBjb250ZW50IGlzIHByZXNlbnRlZCBpbiBhbiBlZGl0b3IuIEFuIG9wZW4gbm90aWZpY2F0aW9uIG11c3Qgbm90XG4gKiBiZSBzZW50IG1vcmUgdGhhbiBvbmNlIHdpdGhvdXQgYSBjb3JyZXNwb25kaW5nIGNsb3NlIG5vdGlmaWNhdGlvbiBzZW5kIGJlZm9yZS5cbiAqIFRoaXMgbWVhbnMgb3BlbiBhbmQgY2xvc2Ugbm90aWZpY2F0aW9uIG11c3QgYmUgYmFsYW5jZWQgYW5kIHRoZSBtYXggb3BlbiBjb3VudFxuICogaXMgb25lLlxuICovXG52YXIgRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbikge1xuICAgIERpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kID0gJ3RleHREb2N1bWVudC9kaWRPcGVuJztcbiAgICBEaWRPcGVuVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IHt9KSk7XG52YXIgVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50O1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnQpIHtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgaW5mb3JtYXRpb24gZGVzY3JpYmVzIGEgZGVsdGEgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbmNyZW1lbnRhbChldmVudCkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gZXZlbnQ7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjYW5kaWRhdGUudGV4dCA9PT0gJ3N0cmluZycgJiYgY2FuZGlkYXRlLnJhbmdlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUucmFuZ2VMZW5ndGggPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgY2FuZGlkYXRlLnJhbmdlTGVuZ3RoID09PSAnbnVtYmVyJyk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudENvbnRlbnRDaGFuZ2VFdmVudC5pc0luY3JlbWVudGFsID0gaXNJbmNyZW1lbnRhbDtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgaW5mb3JtYXRpb24gZGVzY3JpYmVzIGEgZnVsbCByZXBsYWNlbWVudCBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bGwoZXZlbnQpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IGV2ZW50O1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgY2FuZGlkYXRlLnRleHQgPT09ICdzdHJpbmcnICYmIGNhbmRpZGF0ZS5yYW5nZSA9PT0gdW5kZWZpbmVkICYmIGNhbmRpZGF0ZS5yYW5nZUxlbmd0aCA9PT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnQuaXNGdWxsID0gaXNGdWxsO1xufSkoVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50ID0gZXhwb3J0cy5UZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnQgfHwgKGV4cG9ydHMuVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50ID0ge30pKTtcbi8qKlxuICogVGhlIGRvY3VtZW50IGNoYW5nZSBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB0byBzaWduYWxcbiAqIGNoYW5nZXMgdG8gYSB0ZXh0IGRvY3VtZW50LlxuICovXG52YXIgRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24pIHtcbiAgICBEaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kID0gJ3RleHREb2N1bWVudC9kaWRDaGFuZ2UnO1xuICAgIERpZENoYW5nZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZENoYW5nZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZENoYW5nZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIGRvY3VtZW50IGNsb3NlIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHdoZW5cbiAqIHRoZSBkb2N1bWVudCBnb3QgY2xvc2VkIGluIHRoZSBjbGllbnQuIFRoZSBkb2N1bWVudCdzIHRydXRoIG5vdyBleGlzdHMgd2hlcmVcbiAqIHRoZSBkb2N1bWVudCdzIHVyaSBwb2ludHMgdG8gKGUuZy4gaWYgdGhlIGRvY3VtZW50J3MgdXJpIGlzIGEgZmlsZSB1cmkgdGhlXG4gKiB0cnV0aCBub3cgZXhpc3RzIG9uIGRpc2spLiBBcyB3aXRoIHRoZSBvcGVuIG5vdGlmaWNhdGlvbiB0aGUgY2xvc2Ugbm90aWZpY2F0aW9uXG4gKiBpcyBhYm91dCBtYW5hZ2luZyB0aGUgZG9jdW1lbnQncyBjb250ZW50LiBSZWNlaXZpbmcgYSBjbG9zZSBub3RpZmljYXRpb25cbiAqIGRvZXNuJ3QgbWVhbiB0aGF0IHRoZSBkb2N1bWVudCB3YXMgb3BlbiBpbiBhbiBlZGl0b3IgYmVmb3JlLiBBIGNsb3NlXG4gKiBub3RpZmljYXRpb24gcmVxdWlyZXMgYSBwcmV2aW91cyBvcGVuIG5vdGlmaWNhdGlvbiB0byBiZSBzZW50LlxuICovXG52YXIgRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kID0gJ3RleHREb2N1bWVudC9kaWRDbG9zZSc7XG4gICAgRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRDbG9zZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShEaWRDbG9zZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgZG9jdW1lbnQgc2F2ZSBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB3aGVuXG4gKiB0aGUgZG9jdW1lbnQgZ290IHNhdmVkIGluIHRoZSBjbGllbnQuXG4gKi9cbnZhciBEaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAndGV4dERvY3VtZW50L2RpZFNhdmUnO1xuICAgIERpZFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogUmVwcmVzZW50cyByZWFzb25zIHdoeSBhIHRleHQgZG9jdW1lbnQgaXMgc2F2ZWQuXG4gKi9cbnZhciBUZXh0RG9jdW1lbnRTYXZlUmVhc29uO1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRTYXZlUmVhc29uKSB7XG4gICAgLyoqXG4gICAgICogTWFudWFsbHkgdHJpZ2dlcmVkLCBlLmcuIGJ5IHRoZSB1c2VyIHByZXNzaW5nIHNhdmUsIGJ5IHN0YXJ0aW5nIGRlYnVnZ2luZyxcbiAgICAgKiBvciBieSBhbiBBUEkgY2FsbC5cbiAgICAgKi9cbiAgICBUZXh0RG9jdW1lbnRTYXZlUmVhc29uLk1hbnVhbCA9IDE7XG4gICAgLyoqXG4gICAgICogQXV0b21hdGljIGFmdGVyIGEgZGVsYXkuXG4gICAgICovXG4gICAgVGV4dERvY3VtZW50U2F2ZVJlYXNvbi5BZnRlckRlbGF5ID0gMjtcbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBlZGl0b3IgbG9zdCBmb2N1cy5cbiAgICAgKi9cbiAgICBUZXh0RG9jdW1lbnRTYXZlUmVhc29uLkZvY3VzT3V0ID0gMztcbn0pKFRleHREb2N1bWVudFNhdmVSZWFzb24gPSBleHBvcnRzLlRleHREb2N1bWVudFNhdmVSZWFzb24gfHwgKGV4cG9ydHMuVGV4dERvY3VtZW50U2F2ZVJlYXNvbiA9IHt9KSk7XG4vKipcbiAqIEEgZG9jdW1lbnQgd2lsbCBzYXZlIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIGJlZm9yZVxuICogdGhlIGRvY3VtZW50IGlzIGFjdHVhbGx5IHNhdmVkLlxuICovXG52YXIgV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKFdpbGxTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kID0gJ3RleHREb2N1bWVudC93aWxsU2F2ZSc7XG4gICAgV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBXaWxsU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKFdpbGxTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShXaWxsU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBBIGRvY3VtZW50IHdpbGwgc2F2ZSByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgYmVmb3JlXG4gKiB0aGUgZG9jdW1lbnQgaXMgYWN0dWFsbHkgc2F2ZWQuIFRoZSByZXF1ZXN0IGNhbiByZXR1cm4gYW4gYXJyYXkgb2YgVGV4dEVkaXRzXG4gKiB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHRleHQgZG9jdW1lbnQgYmVmb3JlIGl0IGlzIHNhdmVkLiBQbGVhc2Ugbm90ZSB0aGF0XG4gKiBjbGllbnRzIG1pZ2h0IGRyb3AgcmVzdWx0cyBpZiBjb21wdXRpbmcgdGhlIHRleHQgZWRpdHMgdG9vayB0b28gbG9uZyBvciBpZiBhXG4gKiBzZXJ2ZXIgY29uc3RhbnRseSBmYWlscyBvbiB0aGlzIHJlcXVlc3QuIFRoaXMgaXMgZG9uZSB0byBrZWVwIHRoZSBzYXZlIGZhc3QgYW5kXG4gKiByZWxpYWJsZS5cbiAqL1xudmFyIFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdDtcbihmdW5jdGlvbiAoV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0KSB7XG4gICAgV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvd2lsbFNhdmVXYWl0VW50aWwnO1xuICAgIFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShXaWxsU2F2ZVRleHREb2N1bWVudFdhaXRVbnRpbFJlcXVlc3QubWV0aG9kKTtcbn0pKFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdCA9IGV4cG9ydHMuV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0IHx8IChleHBvcnRzLldpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFRoZSB3YXRjaGVkIGZpbGVzIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHdoZW5cbiAqIHRoZSBjbGllbnQgZGV0ZWN0cyBjaGFuZ2VzIHRvIGZpbGUgd2F0Y2hlZCBieSB0aGUgbGFuZ3VhZ2UgY2xpZW50LlxuICovXG52YXIgRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24pIHtcbiAgICBEaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24ubWV0aG9kID0gJ3dvcmtzcGFjZS9kaWRDaGFuZ2VXYXRjaGVkRmlsZXMnO1xuICAgIERpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIGZpbGUgZXZlbnQgdHlwZVxuICovXG52YXIgRmlsZUNoYW5nZVR5cGU7XG4oZnVuY3Rpb24gKEZpbGVDaGFuZ2VUeXBlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGZpbGUgZ290IGNyZWF0ZWQuXG4gICAgICovXG4gICAgRmlsZUNoYW5nZVR5cGUuQ3JlYXRlZCA9IDE7XG4gICAgLyoqXG4gICAgICogVGhlIGZpbGUgZ290IGNoYW5nZWQuXG4gICAgICovXG4gICAgRmlsZUNoYW5nZVR5cGUuQ2hhbmdlZCA9IDI7XG4gICAgLyoqXG4gICAgICogVGhlIGZpbGUgZ290IGRlbGV0ZWQuXG4gICAgICovXG4gICAgRmlsZUNoYW5nZVR5cGUuRGVsZXRlZCA9IDM7XG59KShGaWxlQ2hhbmdlVHlwZSA9IGV4cG9ydHMuRmlsZUNoYW5nZVR5cGUgfHwgKGV4cG9ydHMuRmlsZUNoYW5nZVR5cGUgPSB7fSkpO1xudmFyIFJlbGF0aXZlUGF0dGVybjtcbihmdW5jdGlvbiAoUmVsYXRpdmVQYXR0ZXJuKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgKHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLlVSSS5pcyhjYW5kaWRhdGUuYmFzZVVyaSkgfHwgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3R5cGVzXzEuV29ya3NwYWNlRm9sZGVyLmlzKGNhbmRpZGF0ZS5iYXNlVXJpKSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5wYXR0ZXJuKTtcbiAgICB9XG4gICAgUmVsYXRpdmVQYXR0ZXJuLmlzID0gaXM7XG59KShSZWxhdGl2ZVBhdHRlcm4gPSBleHBvcnRzLlJlbGF0aXZlUGF0dGVybiB8fCAoZXhwb3J0cy5SZWxhdGl2ZVBhdHRlcm4gPSB7fSkpO1xudmFyIFdhdGNoS2luZDtcbihmdW5jdGlvbiAoV2F0Y2hLaW5kKSB7XG4gICAgLyoqXG4gICAgICogSW50ZXJlc3RlZCBpbiBjcmVhdGUgZXZlbnRzLlxuICAgICAqL1xuICAgIFdhdGNoS2luZC5DcmVhdGUgPSAxO1xuICAgIC8qKlxuICAgICAqIEludGVyZXN0ZWQgaW4gY2hhbmdlIGV2ZW50c1xuICAgICAqL1xuICAgIFdhdGNoS2luZC5DaGFuZ2UgPSAyO1xuICAgIC8qKlxuICAgICAqIEludGVyZXN0ZWQgaW4gZGVsZXRlIGV2ZW50c1xuICAgICAqL1xuICAgIFdhdGNoS2luZC5EZWxldGUgPSA0O1xufSkoV2F0Y2hLaW5kID0gZXhwb3J0cy5XYXRjaEtpbmQgfHwgKGV4cG9ydHMuV2F0Y2hLaW5kID0ge30pKTtcbi8qKlxuICogRGlhZ25vc3RpY3Mgbm90aWZpY2F0aW9uIGFyZSBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIHNpZ25hbFxuICogcmVzdWx0cyBvZiB2YWxpZGF0aW9uIHJ1bnMuXG4gKi9cbnZhciBQdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKFB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbikge1xuICAgIFB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbi5tZXRob2QgPSAndGV4dERvY3VtZW50L3B1Ymxpc2hEaWFnbm9zdGljcyc7XG4gICAgUHVibGlzaERpYWdub3N0aWNzTm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgUHVibGlzaERpYWdub3N0aWNzTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoUHVibGlzaERpYWdub3N0aWNzTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShQdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24gPSBleHBvcnRzLlB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5QdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBIb3cgYSBjb21wbGV0aW9uIHdhcyB0cmlnZ2VyZWRcbiAqL1xudmFyIENvbXBsZXRpb25UcmlnZ2VyS2luZDtcbihmdW5jdGlvbiAoQ29tcGxldGlvblRyaWdnZXJLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IHR5cGluZyBhbiBpZGVudGlmaWVyICgyNHg3IGNvZGVcbiAgICAgKiBjb21wbGV0ZSksIG1hbnVhbCBpbnZvY2F0aW9uIChlLmcgQ3RybCtTcGFjZSkgb3IgdmlhIEFQSS5cbiAgICAgKi9cbiAgICBDb21wbGV0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCA9IDE7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IGEgdHJpZ2dlciBjaGFyYWN0ZXIgc3BlY2lmaWVkIGJ5XG4gICAgICogdGhlIGB0cmlnZ2VyQ2hhcmFjdGVyc2AgcHJvcGVydGllcyBvZiB0aGUgYENvbXBsZXRpb25SZWdpc3RyYXRpb25PcHRpb25zYC5cbiAgICAgKi9cbiAgICBDb21wbGV0aW9uVHJpZ2dlcktpbmQuVHJpZ2dlckNoYXJhY3RlciA9IDI7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiB3YXMgcmUtdHJpZ2dlcmVkIGFzIGN1cnJlbnQgY29tcGxldGlvbiBsaXN0IGlzIGluY29tcGxldGVcbiAgICAgKi9cbiAgICBDb21wbGV0aW9uVHJpZ2dlcktpbmQuVHJpZ2dlckZvckluY29tcGxldGVDb21wbGV0aW9ucyA9IDM7XG59KShDb21wbGV0aW9uVHJpZ2dlcktpbmQgPSBleHBvcnRzLkNvbXBsZXRpb25UcmlnZ2VyS2luZCB8fCAoZXhwb3J0cy5Db21wbGV0aW9uVHJpZ2dlcktpbmQgPSB7fSkpO1xuLyoqXG4gKiBSZXF1ZXN0IHRvIHJlcXVlc3QgY29tcGxldGlvbiBhdCBhIGdpdmVuIHRleHQgZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBUZXh0RG9jdW1lbnRQb3NpdGlvbn0gdGhlIHJlc3BvbnNlXG4gKiBpcyBvZiB0eXBlIHtAbGluayBDb21wbGV0aW9uSXRlbSBDb21wbGV0aW9uSXRlbVtdfSBvciB7QGxpbmsgQ29tcGxldGlvbkxpc3R9XG4gKiBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqXG4gKiBUaGUgcmVxdWVzdCBjYW4gZGVsYXkgdGhlIGNvbXB1dGF0aW9uIG9mIHRoZSB7QGxpbmsgQ29tcGxldGlvbkl0ZW0uZGV0YWlsIGBkZXRhaWxgfVxuICogYW5kIHtAbGluayBDb21wbGV0aW9uSXRlbS5kb2N1bWVudGF0aW9uIGBkb2N1bWVudGF0aW9uYH0gcHJvcGVydGllcyB0byB0aGUgYGNvbXBsZXRpb25JdGVtL3Jlc29sdmVgXG4gKiByZXF1ZXN0LiBIb3dldmVyLCBwcm9wZXJ0aWVzIHRoYXQgYXJlIG5lZWRlZCBmb3IgdGhlIGluaXRpYWwgc29ydGluZyBhbmQgZmlsdGVyaW5nLCBsaWtlIGBzb3J0VGV4dGAsXG4gKiBgZmlsdGVyVGV4dGAsIGBpbnNlcnRUZXh0YCwgYW5kIGB0ZXh0RWRpdGAsIG11c3Qgbm90IGJlIGNoYW5nZWQgZHVyaW5nIHJlc29sdmUuXG4gKi9cbnZhciBDb21wbGV0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29tcGxldGlvblJlcXVlc3QpIHtcbiAgICBDb21wbGV0aW9uUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2NvbXBsZXRpb24nO1xuICAgIENvbXBsZXRpb25SZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgQ29tcGxldGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoQ29tcGxldGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKENvbXBsZXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5Db21wbGV0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5Db21wbGV0aW9uUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFJlcXVlc3QgdG8gcmVzb2x2ZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGZvciBhIGdpdmVuIGNvbXBsZXRpb24gaXRlbS5UaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgQ29tcGxldGlvbkl0ZW19IHRoZSByZXNwb25zZVxuICogaXMgb2YgdHlwZSB7QGxpbmsgQ29tcGxldGlvbkl0ZW19IG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgQ29tcGxldGlvblJlc29sdmVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uUmVzb2x2ZVJlcXVlc3QpIHtcbiAgICBDb21wbGV0aW9uUmVzb2x2ZVJlcXVlc3QubWV0aG9kID0gJ2NvbXBsZXRpb25JdGVtL3Jlc29sdmUnO1xuICAgIENvbXBsZXRpb25SZXNvbHZlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENvbXBsZXRpb25SZXNvbHZlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDb21wbGV0aW9uUmVzb2x2ZVJlcXVlc3QubWV0aG9kKTtcbn0pKENvbXBsZXRpb25SZXNvbHZlUmVxdWVzdCA9IGV4cG9ydHMuQ29tcGxldGlvblJlc29sdmVSZXF1ZXN0IHx8IChleHBvcnRzLkNvbXBsZXRpb25SZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFJlcXVlc3QgdG8gcmVxdWVzdCBob3ZlciBpbmZvcm1hdGlvbiBhdCBhIGdpdmVuIHRleHQgZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBUZXh0RG9jdW1lbnRQb3NpdGlvbn0gdGhlIHJlc3BvbnNlIGlzIG9mXG4gKiB0eXBlIHtAbGluayBIb3Zlcn0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBIb3ZlclJlcXVlc3Q7XG4oZnVuY3Rpb24gKEhvdmVyUmVxdWVzdCkge1xuICAgIEhvdmVyUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2hvdmVyJztcbiAgICBIb3ZlclJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBIb3ZlclJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSG92ZXJSZXF1ZXN0Lm1ldGhvZCk7XG59KShIb3ZlclJlcXVlc3QgPSBleHBvcnRzLkhvdmVyUmVxdWVzdCB8fCAoZXhwb3J0cy5Ib3ZlclJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBIb3cgYSBzaWduYXR1cmUgaGVscCB3YXMgdHJpZ2dlcmVkLlxuICpcbiAqIEBzaW5jZSAzLjE1LjBcbiAqL1xudmFyIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZDtcbihmdW5jdGlvbiAoU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kKSB7XG4gICAgLyoqXG4gICAgICogU2lnbmF0dXJlIGhlbHAgd2FzIGludm9rZWQgbWFudWFsbHkgYnkgdGhlIHVzZXIgb3IgYnkgYSBjb21tYW5kLlxuICAgICAqL1xuICAgIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZC5JbnZva2VkID0gMTtcbiAgICAvKipcbiAgICAgKiBTaWduYXR1cmUgaGVscCB3YXMgdHJpZ2dlcmVkIGJ5IGEgdHJpZ2dlciBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kLlRyaWdnZXJDaGFyYWN0ZXIgPSAyO1xuICAgIC8qKlxuICAgICAqIFNpZ25hdHVyZSBoZWxwIHdhcyB0cmlnZ2VyZWQgYnkgdGhlIGN1cnNvciBtb3Zpbmcgb3IgYnkgdGhlIGRvY3VtZW50IGNvbnRlbnQgY2hhbmdpbmcuXG4gICAgICovXG4gICAgU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kLkNvbnRlbnRDaGFuZ2UgPSAzO1xufSkoU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kID0gZXhwb3J0cy5TaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQgfHwgKGV4cG9ydHMuU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kID0ge30pKTtcbnZhciBTaWduYXR1cmVIZWxwUmVxdWVzdDtcbihmdW5jdGlvbiAoU2lnbmF0dXJlSGVscFJlcXVlc3QpIHtcbiAgICBTaWduYXR1cmVIZWxwUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3NpZ25hdHVyZUhlbHAnO1xuICAgIFNpZ25hdHVyZUhlbHBSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgU2lnbmF0dXJlSGVscFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoU2lnbmF0dXJlSGVscFJlcXVlc3QubWV0aG9kKTtcbn0pKFNpZ25hdHVyZUhlbHBSZXF1ZXN0ID0gZXhwb3J0cy5TaWduYXR1cmVIZWxwUmVxdWVzdCB8fCAoZXhwb3J0cy5TaWduYXR1cmVIZWxwUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSBkZWZpbml0aW9uIGxvY2F0aW9uIG9mIGEgc3ltYm9sIGF0IGEgZ2l2ZW4gdGV4dFxuICogZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUgW1RleHREb2N1bWVudFBvc2l0aW9uXVxuICogKCNUZXh0RG9jdW1lbnRQb3NpdGlvbikgdGhlIHJlc3BvbnNlIGlzIG9mIGVpdGhlciB0eXBlIHtAbGluayBEZWZpbml0aW9ufVxuICogb3IgYSB0eXBlZCBhcnJheSBvZiB7QGxpbmsgRGVmaW5pdGlvbkxpbmt9IG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlc1xuICogdG8gc3VjaC5cbiAqL1xudmFyIERlZmluaXRpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChEZWZpbml0aW9uUmVxdWVzdCkge1xuICAgIERlZmluaXRpb25SZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvZGVmaW5pdGlvbic7XG4gICAgRGVmaW5pdGlvblJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEZWZpbml0aW9uUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEZWZpbml0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoRGVmaW5pdGlvblJlcXVlc3QgPSBleHBvcnRzLkRlZmluaXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLkRlZmluaXRpb25SZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgcHJvamVjdC13aWRlIHJlZmVyZW5jZXMgZm9yIHRoZSBzeW1ib2wgZGVub3RlZFxuICogYnkgdGhlIGdpdmVuIHRleHQgZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mXG4gKiB0eXBlIHtAbGluayBSZWZlcmVuY2VQYXJhbXN9IHRoZSByZXNwb25zZSBpcyBvZiB0eXBlXG4gKiB7QGxpbmsgTG9jYXRpb24gTG9jYXRpb25bXX0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBSZWZlcmVuY2VzUmVxdWVzdDtcbihmdW5jdGlvbiAoUmVmZXJlbmNlc1JlcXVlc3QpIHtcbiAgICBSZWZlcmVuY2VzUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3JlZmVyZW5jZXMnO1xuICAgIFJlZmVyZW5jZXNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgUmVmZXJlbmNlc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoUmVmZXJlbmNlc1JlcXVlc3QubWV0aG9kKTtcbn0pKFJlZmVyZW5jZXNSZXF1ZXN0ID0gZXhwb3J0cy5SZWZlcmVuY2VzUmVxdWVzdCB8fCAoZXhwb3J0cy5SZWZlcmVuY2VzUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFJlcXVlc3QgdG8gcmVzb2x2ZSBhIHtAbGluayBEb2N1bWVudEhpZ2hsaWdodH0gZm9yIGEgZ2l2ZW5cbiAqIHRleHQgZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUgW1RleHREb2N1bWVudFBvc2l0aW9uXVxuICogKCNUZXh0RG9jdW1lbnRQb3NpdGlvbikgdGhlIHJlcXVlc3QgcmVzcG9uc2UgaXMgb2YgdHlwZSBbRG9jdW1lbnRIaWdobGlnaHRbXV1cbiAqICgjRG9jdW1lbnRIaWdobGlnaHQpIG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QpIHtcbiAgICBEb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9kb2N1bWVudEhpZ2hsaWdodCc7XG4gICAgRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKERvY3VtZW50SGlnaGxpZ2h0UmVxdWVzdC5tZXRob2QpO1xufSkoRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIGxpc3QgYWxsIHN5bWJvbHMgZm91bmQgaW4gYSBnaXZlbiB0ZXh0IGRvY3VtZW50LiBUaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgVGV4dERvY3VtZW50SWRlbnRpZmllcn0gdGhlXG4gKiByZXNwb25zZSBpcyBvZiB0eXBlIHtAbGluayBTeW1ib2xJbmZvcm1hdGlvbiBTeW1ib2xJbmZvcm1hdGlvbltdfSBvciBhIFRoZW5hYmxlXG4gKiB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBEb2N1bWVudFN5bWJvbFJlcXVlc3Q7XG4oZnVuY3Rpb24gKERvY3VtZW50U3ltYm9sUmVxdWVzdCkge1xuICAgIERvY3VtZW50U3ltYm9sUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2RvY3VtZW50U3ltYm9sJztcbiAgICBEb2N1bWVudFN5bWJvbFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudFN5bWJvbFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRTeW1ib2xSZXF1ZXN0Lm1ldGhvZCk7XG59KShEb2N1bWVudFN5bWJvbFJlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50U3ltYm9sUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudFN5bWJvbFJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcHJvdmlkZSBjb21tYW5kcyBmb3IgdGhlIGdpdmVuIHRleHQgZG9jdW1lbnQgYW5kIHJhbmdlLlxuICovXG52YXIgQ29kZUFjdGlvblJlcXVlc3Q7XG4oZnVuY3Rpb24gKENvZGVBY3Rpb25SZXF1ZXN0KSB7XG4gICAgQ29kZUFjdGlvblJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9jb2RlQWN0aW9uJztcbiAgICBDb2RlQWN0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENvZGVBY3Rpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENvZGVBY3Rpb25SZXF1ZXN0Lm1ldGhvZCk7XG59KShDb2RlQWN0aW9uUmVxdWVzdCA9IGV4cG9ydHMuQ29kZUFjdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuQ29kZUFjdGlvblJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBSZXF1ZXN0IHRvIHJlc29sdmUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBmb3IgYSBnaXZlbiBjb2RlIGFjdGlvbi5UaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgQ29kZUFjdGlvbn0gdGhlIHJlc3BvbnNlXG4gKiBpcyBvZiB0eXBlIHtAbGluayBDb2RlQWN0aW9ufSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIENvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0KSB7XG4gICAgQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0Lm1ldGhvZCA9ICdjb2RlQWN0aW9uL3Jlc29sdmUnO1xuICAgIENvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDb2RlQWN0aW9uUmVzb2x2ZVJlcXVlc3QubWV0aG9kKTtcbn0pKENvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdCA9IGV4cG9ydHMuQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0IHx8IChleHBvcnRzLkNvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBsaXN0IHByb2plY3Qtd2lkZSBzeW1ib2xzIG1hdGNoaW5nIHRoZSBxdWVyeSBzdHJpbmcgZ2l2ZW5cbiAqIGJ5IHRoZSB7QGxpbmsgV29ya3NwYWNlU3ltYm9sUGFyYW1zfS4gVGhlIHJlc3BvbnNlIGlzXG4gKiBvZiB0eXBlIHtAbGluayBTeW1ib2xJbmZvcm1hdGlvbiBTeW1ib2xJbmZvcm1hdGlvbltdfSBvciBhIFRoZW5hYmxlIHRoYXRcbiAqIHJlc29sdmVzIHRvIHN1Y2guXG4gKlxuICogQHNpbmNlIDMuMTcuMCAtIHN1cHBvcnQgZm9yIFdvcmtzcGFjZVN5bWJvbCBpbiB0aGUgcmV0dXJuZWQgZGF0YS4gQ2xpZW50c1xuICogIG5lZWQgdG8gYWR2ZXJ0aXNlIHN1cHBvcnQgZm9yIFdvcmtzcGFjZVN5bWJvbHMgdmlhIHRoZSBjbGllbnQgY2FwYWJpbGl0eVxuICogIGB3b3Jrc3BhY2Uuc3ltYm9sLnJlc29sdmVTdXBwb3J0YC5cbiAqXG4gKi9cbnZhciBXb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0O1xuKGZ1bmN0aW9uIChXb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0KSB7XG4gICAgV29ya3NwYWNlU3ltYm9sUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL3N5bWJvbCc7XG4gICAgV29ya3NwYWNlU3ltYm9sUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdvcmtzcGFjZVN5bWJvbFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV29ya3NwYWNlU3ltYm9sUmVxdWVzdC5tZXRob2QpO1xufSkoV29ya3NwYWNlU3ltYm9sUmVxdWVzdCA9IGV4cG9ydHMuV29ya3NwYWNlU3ltYm9sUmVxdWVzdCB8fCAoZXhwb3J0cy5Xb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgdGhlIHJhbmdlIGluc2lkZSB0aGUgd29ya3NwYWNlXG4gKiBzeW1ib2wncyBsb2NhdGlvbi5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBXb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdDtcbihmdW5jdGlvbiAoV29ya3NwYWNlU3ltYm9sUmVzb2x2ZVJlcXVlc3QpIHtcbiAgICBXb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlU3ltYm9sL3Jlc29sdmUnO1xuICAgIFdvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgV29ya3NwYWNlU3ltYm9sUmVzb2x2ZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV29ya3NwYWNlU3ltYm9sUmVzb2x2ZVJlcXVlc3QubWV0aG9kKTtcbn0pKFdvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5Xb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdCB8fCAoZXhwb3J0cy5Xb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBwcm92aWRlIGNvZGUgbGVucyBmb3IgdGhlIGdpdmVuIHRleHQgZG9jdW1lbnQuXG4gKi9cbnZhciBDb2RlTGVuc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKENvZGVMZW5zUmVxdWVzdCkge1xuICAgIENvZGVMZW5zUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2NvZGVMZW5zJztcbiAgICBDb2RlTGVuc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBDb2RlTGVuc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoQ29kZUxlbnNSZXF1ZXN0Lm1ldGhvZCk7XG59KShDb2RlTGVuc1JlcXVlc3QgPSBleHBvcnRzLkNvZGVMZW5zUmVxdWVzdCB8fCAoZXhwb3J0cy5Db2RlTGVuc1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSBhIGNvbW1hbmQgZm9yIGEgZ2l2ZW4gY29kZSBsZW5zLlxuICovXG52YXIgQ29kZUxlbnNSZXNvbHZlUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29kZUxlbnNSZXNvbHZlUmVxdWVzdCkge1xuICAgIENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QubWV0aG9kID0gJ2NvZGVMZW5zL3Jlc29sdmUnO1xuICAgIENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBDb2RlTGVuc1Jlc29sdmVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QubWV0aG9kKTtcbn0pKENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLkNvZGVMZW5zUmVzb2x2ZVJlcXVlc3QgfHwgKGV4cG9ydHMuQ29kZUxlbnNSZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZWZyZXNoIGFsbCBjb2RlIGFjdGlvbnNcbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBDb2RlTGVuc1JlZnJlc2hSZXF1ZXN0O1xuKGZ1bmN0aW9uIChDb2RlTGVuc1JlZnJlc2hSZXF1ZXN0KSB7XG4gICAgQ29kZUxlbnNSZWZyZXNoUmVxdWVzdC5tZXRob2QgPSBgd29ya3NwYWNlL2NvZGVMZW5zL3JlZnJlc2hgO1xuICAgIENvZGVMZW5zUmVmcmVzaFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBDb2RlTGVuc1JlZnJlc2hSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlMChDb2RlTGVuc1JlZnJlc2hSZXF1ZXN0Lm1ldGhvZCk7XG59KShDb2RlTGVuc1JlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5Db2RlTGVuc1JlZnJlc2hSZXF1ZXN0IHx8IChleHBvcnRzLkNvZGVMZW5zUmVmcmVzaFJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcHJvdmlkZSBkb2N1bWVudCBsaW5rc1xuICovXG52YXIgRG9jdW1lbnRMaW5rUmVxdWVzdDtcbihmdW5jdGlvbiAoRG9jdW1lbnRMaW5rUmVxdWVzdCkge1xuICAgIERvY3VtZW50TGlua1JlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9kb2N1bWVudExpbmsnO1xuICAgIERvY3VtZW50TGlua1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudExpbmtSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKERvY3VtZW50TGlua1JlcXVlc3QubWV0aG9kKTtcbn0pKERvY3VtZW50TGlua1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50TGlua1JlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRMaW5rUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFJlcXVlc3QgdG8gcmVzb2x2ZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGZvciBhIGdpdmVuIGRvY3VtZW50IGxpbmsuIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBEb2N1bWVudExpbmt9IHRoZSByZXNwb25zZVxuICogaXMgb2YgdHlwZSB7QGxpbmsgRG9jdW1lbnRMaW5rfSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIERvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdCkge1xuICAgIERvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0Lm1ldGhvZCA9ICdkb2N1bWVudExpbmsvcmVzb2x2ZSc7XG4gICAgRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdC5tZXRob2QpO1xufSkoRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0IHx8IChleHBvcnRzLkRvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHRvIGZvcm1hdCBhIHdob2xlIGRvY3VtZW50LlxuICovXG52YXIgRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdDtcbihmdW5jdGlvbiAoRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdCkge1xuICAgIERvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9mb3JtYXR0aW5nJztcbiAgICBEb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0Lm1ldGhvZCk7XG59KShEb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0IHx8IChleHBvcnRzLkRvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gdG8gZm9ybWF0IGEgcmFuZ2UgaW4gYSBkb2N1bWVudC5cbiAqL1xudmFyIERvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUmVxdWVzdDtcbihmdW5jdGlvbiAoRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdSZXF1ZXN0KSB7XG4gICAgRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvcmFuZ2VGb3JtYXR0aW5nJztcbiAgICBEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdSZXF1ZXN0Lm1ldGhvZCk7XG59KShEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gZm9ybWF0IGEgZG9jdW1lbnQgb24gdHlwZS5cbiAqL1xudmFyIERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3Q7XG4oZnVuY3Rpb24gKERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QpIHtcbiAgICBEb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvb25UeXBlRm9ybWF0dGluZyc7XG4gICAgRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdC5tZXRob2QpO1xufSkoRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0ID0ge30pKTtcbi8vLS0tLSBSZW5hbWUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIFByZXBhcmVTdXBwb3J0RGVmYXVsdEJlaGF2aW9yO1xuKGZ1bmN0aW9uIChQcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvcikge1xuICAgIC8qKlxuICAgICAqIFRoZSBjbGllbnQncyBkZWZhdWx0IGJlaGF2aW9yIGlzIHRvIHNlbGVjdCB0aGUgaWRlbnRpZmllclxuICAgICAqIGFjY29yZGluZyB0aGUgdG8gbGFuZ3VhZ2UncyBzeW50YXggcnVsZS5cbiAgICAgKi9cbiAgICBQcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvci5JZGVudGlmaWVyID0gMTtcbn0pKFByZXBhcmVTdXBwb3J0RGVmYXVsdEJlaGF2aW9yID0gZXhwb3J0cy5QcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvciB8fCAoZXhwb3J0cy5QcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvciA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZW5hbWUgYSBzeW1ib2wuXG4gKi9cbnZhciBSZW5hbWVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChSZW5hbWVSZXF1ZXN0KSB7XG4gICAgUmVuYW1lUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3JlbmFtZSc7XG4gICAgUmVuYW1lUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFJlbmFtZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoUmVuYW1lUmVxdWVzdC5tZXRob2QpO1xufSkoUmVuYW1lUmVxdWVzdCA9IGV4cG9ydHMuUmVuYW1lUmVxdWVzdCB8fCAoZXhwb3J0cy5SZW5hbWVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHRlc3QgYW5kIHBlcmZvcm0gdGhlIHNldHVwIG5lY2Vzc2FyeSBmb3IgYSByZW5hbWUuXG4gKlxuICogQHNpbmNlIDMuMTYgLSBzdXBwb3J0IGZvciBkZWZhdWx0IGJlaGF2aW9yXG4gKi9cbnZhciBQcmVwYXJlUmVuYW1lUmVxdWVzdDtcbihmdW5jdGlvbiAoUHJlcGFyZVJlbmFtZVJlcXVlc3QpIHtcbiAgICBQcmVwYXJlUmVuYW1lUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3ByZXBhcmVSZW5hbWUnO1xuICAgIFByZXBhcmVSZW5hbWVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgUHJlcGFyZVJlbmFtZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoUHJlcGFyZVJlbmFtZVJlcXVlc3QubWV0aG9kKTtcbn0pKFByZXBhcmVSZW5hbWVSZXF1ZXN0ID0gZXhwb3J0cy5QcmVwYXJlUmVuYW1lUmVxdWVzdCB8fCAoZXhwb3J0cy5QcmVwYXJlUmVuYW1lUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCBzZW5kIGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHRvIGV4ZWN1dGUgYSBjb21tYW5kLiBUaGUgcmVxdWVzdCBtaWdodCByZXR1cm5cbiAqIGEgd29ya3NwYWNlIGVkaXQgd2hpY2ggdGhlIGNsaWVudCB3aWxsIGFwcGx5IHRvIHRoZSB3b3Jrc3BhY2UuXG4gKi9cbnZhciBFeGVjdXRlQ29tbWFuZFJlcXVlc3Q7XG4oZnVuY3Rpb24gKEV4ZWN1dGVDb21tYW5kUmVxdWVzdCkge1xuICAgIEV4ZWN1dGVDb21tYW5kUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL2V4ZWN1dGVDb21tYW5kJztcbiAgICBFeGVjdXRlQ29tbWFuZFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBFeGVjdXRlQ29tbWFuZFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRXhlY3V0ZUNvbW1hbmRSZXF1ZXN0Lm1ldGhvZCk7XG59KShFeGVjdXRlQ29tbWFuZFJlcXVlc3QgPSBleHBvcnRzLkV4ZWN1dGVDb21tYW5kUmVxdWVzdCB8fCAoZXhwb3J0cy5FeGVjdXRlQ29tbWFuZFJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3Qgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byBtb2RpZmllZCBjZXJ0YWluIHJlc291cmNlcy5cbiAqL1xudmFyIEFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3Q7XG4oZnVuY3Rpb24gKEFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3QpIHtcbiAgICBBcHBseVdvcmtzcGFjZUVkaXRSZXF1ZXN0Lm1ldGhvZCA9ICd3b3Jrc3BhY2UvYXBwbHlFZGl0JztcbiAgICBBcHBseVdvcmtzcGFjZUVkaXRSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZSgnd29ya3NwYWNlL2FwcGx5RWRpdCcpO1xufSkoQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdCA9IGV4cG9ydHMuQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdCB8fCAoZXhwb3J0cy5BcHBseVdvcmtzcGFjZUVkaXRSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTI3OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1OTkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcHJvdmlkZSByYW5nZXMgdGhhdCBjYW4gYmUgZWRpdGVkIHRvZ2V0aGVyLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIExpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKExpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3QpIHtcbiAgICBMaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvbGlua2VkRWRpdGluZ1JhbmdlJztcbiAgICBMaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShMaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0Lm1ldGhvZCk7XG59KShMaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0ID0gZXhwb3J0cy5MaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0IHx8IChleHBvcnRzLkxpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxOTY0OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLk1vbmlrZXJSZXF1ZXN0ID0gZXhwb3J0cy5Nb25pa2VyS2luZCA9IGV4cG9ydHMuVW5pcXVlbmVzc0xldmVsID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODU5OSk7XG4vKipcbiAqIE1vbmlrZXIgdW5pcXVlbmVzcyBsZXZlbCB0byBkZWZpbmUgc2NvcGUgb2YgdGhlIG1vbmlrZXIuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgVW5pcXVlbmVzc0xldmVsO1xuKGZ1bmN0aW9uIChVbmlxdWVuZXNzTGV2ZWwpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9uaWtlciBpcyBvbmx5IHVuaXF1ZSBpbnNpZGUgYSBkb2N1bWVudFxuICAgICAqL1xuICAgIFVuaXF1ZW5lc3NMZXZlbC5kb2N1bWVudCA9ICdkb2N1bWVudCc7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgaXMgdW5pcXVlIGluc2lkZSBhIHByb2plY3QgZm9yIHdoaWNoIGEgZHVtcCBnb3QgY3JlYXRlZFxuICAgICAqL1xuICAgIFVuaXF1ZW5lc3NMZXZlbC5wcm9qZWN0ID0gJ3Byb2plY3QnO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb25pa2VyIGlzIHVuaXF1ZSBpbnNpZGUgdGhlIGdyb3VwIHRvIHdoaWNoIGEgcHJvamVjdCBiZWxvbmdzXG4gICAgICovXG4gICAgVW5pcXVlbmVzc0xldmVsLmdyb3VwID0gJ2dyb3VwJztcbiAgICAvKipcbiAgICAgKiBUaGUgbW9uaWtlciBpcyB1bmlxdWUgaW5zaWRlIHRoZSBtb25pa2VyIHNjaGVtZS5cbiAgICAgKi9cbiAgICBVbmlxdWVuZXNzTGV2ZWwuc2NoZW1lID0gJ3NjaGVtZSc7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgaXMgZ2xvYmFsbHkgdW5pcXVlXG4gICAgICovXG4gICAgVW5pcXVlbmVzc0xldmVsLmdsb2JhbCA9ICdnbG9iYWwnO1xufSkoVW5pcXVlbmVzc0xldmVsID0gZXhwb3J0cy5VbmlxdWVuZXNzTGV2ZWwgfHwgKGV4cG9ydHMuVW5pcXVlbmVzc0xldmVsID0ge30pKTtcbi8qKlxuICogVGhlIG1vbmlrZXIga2luZC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBNb25pa2VyS2luZDtcbihmdW5jdGlvbiAoTW9uaWtlcktpbmQpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9uaWtlciByZXByZXNlbnQgYSBzeW1ib2wgdGhhdCBpcyBpbXBvcnRlZCBpbnRvIGEgcHJvamVjdFxuICAgICAqL1xuICAgIE1vbmlrZXJLaW5kLiRpbXBvcnQgPSAnaW1wb3J0JztcbiAgICAvKipcbiAgICAgKiBUaGUgbW9uaWtlciByZXByZXNlbnRzIGEgc3ltYm9sIHRoYXQgaXMgZXhwb3J0ZWQgZnJvbSBhIHByb2plY3RcbiAgICAgKi9cbiAgICBNb25pa2VyS2luZC4kZXhwb3J0ID0gJ2V4cG9ydCc7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgcmVwcmVzZW50cyBhIHN5bWJvbCB0aGF0IGlzIGxvY2FsIHRvIGEgcHJvamVjdCAoZS5nLiBhIGxvY2FsXG4gICAgICogdmFyaWFibGUgb2YgYSBmdW5jdGlvbiwgYSBjbGFzcyBub3QgdmlzaWJsZSBvdXRzaWRlIHRoZSBwcm9qZWN0LCAuLi4pXG4gICAgICovXG4gICAgTW9uaWtlcktpbmQubG9jYWwgPSAnbG9jYWwnO1xufSkoTW9uaWtlcktpbmQgPSBleHBvcnRzLk1vbmlrZXJLaW5kIHx8IChleHBvcnRzLk1vbmlrZXJLaW5kID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIGdldCB0aGUgbW9uaWtlciBvZiBhIHN5bWJvbCBhdCBhIGdpdmVuIHRleHQgZG9jdW1lbnQgcG9zaXRpb24uXG4gKiBUaGUgcmVxdWVzdCBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXN9LlxuICogVGhlIHJlc3BvbnNlIGlzIG9mIHR5cGUge0BsaW5rIE1vbmlrZXIgTW9uaWtlcltdfSBvciBgbnVsbGAuXG4gKi9cbnZhciBNb25pa2VyUmVxdWVzdDtcbihmdW5jdGlvbiAoTW9uaWtlclJlcXVlc3QpIHtcbiAgICBNb25pa2VyUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L21vbmlrZXInO1xuICAgIE1vbmlrZXJSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgTW9uaWtlclJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoTW9uaWtlclJlcXVlc3QubWV0aG9kKTtcbn0pKE1vbmlrZXJSZXF1ZXN0ID0gZXhwb3J0cy5Nb25pa2VyUmVxdWVzdCB8fCAoZXhwb3J0cy5Nb25pa2VyUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ0NjA6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2UgPSBleHBvcnRzLkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5Ob3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUgPSBleHBvcnRzLk5vdGVib29rRG9jdW1lbnQgPSBleHBvcnRzLk5vdGVib29rQ2VsbCA9IGV4cG9ydHMuRXhlY3V0aW9uU3VtbWFyeSA9IGV4cG9ydHMuTm90ZWJvb2tDZWxsS2luZCA9IHZvaWQgMDtcbmNvbnN0IHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NzY3KTtcbmNvbnN0IElzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNTIzKTtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1OTkpO1xuLyoqXG4gKiBBIG5vdGVib29rIGNlbGwga2luZC5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBOb3RlYm9va0NlbGxLaW5kO1xuKGZ1bmN0aW9uIChOb3RlYm9va0NlbGxLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQSBtYXJrdXAtY2VsbCBpcyBmb3JtYXR0ZWQgc291cmNlIHRoYXQgaXMgdXNlZCBmb3IgZGlzcGxheS5cbiAgICAgKi9cbiAgICBOb3RlYm9va0NlbGxLaW5kLk1hcmt1cCA9IDE7XG4gICAgLyoqXG4gICAgICogQSBjb2RlLWNlbGwgaXMgc291cmNlIGNvZGUuXG4gICAgICovXG4gICAgTm90ZWJvb2tDZWxsS2luZC5Db2RlID0gMjtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDEgfHwgdmFsdWUgPT09IDI7XG4gICAgfVxuICAgIE5vdGVib29rQ2VsbEtpbmQuaXMgPSBpcztcbn0pKE5vdGVib29rQ2VsbEtpbmQgPSBleHBvcnRzLk5vdGVib29rQ2VsbEtpbmQgfHwgKGV4cG9ydHMuTm90ZWJvb2tDZWxsS2luZCA9IHt9KSk7XG52YXIgRXhlY3V0aW9uU3VtbWFyeTtcbihmdW5jdGlvbiAoRXhlY3V0aW9uU3VtbWFyeSkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShleGVjdXRpb25PcmRlciwgc3VjY2Vzcykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7IGV4ZWN1dGlvbk9yZGVyIH07XG4gICAgICAgIGlmIChzdWNjZXNzID09PSB0cnVlIHx8IHN1Y2Nlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXN1bHQuc3VjY2VzcyA9IHN1Y2Nlc3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRXhlY3V0aW9uU3VtbWFyeS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3R5cGVzXzEudWludGVnZXIuaXMoY2FuZGlkYXRlLmV4ZWN1dGlvbk9yZGVyKSAmJiAoY2FuZGlkYXRlLnN1Y2Nlc3MgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5zdWNjZXNzKSk7XG4gICAgfVxuICAgIEV4ZWN1dGlvblN1bW1hcnkuaXMgPSBpcztcbiAgICBmdW5jdGlvbiBlcXVhbHMob25lLCBvdGhlcikge1xuICAgICAgICBpZiAob25lID09PSBvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uZSA9PT0gbnVsbCB8fCBvbmUgPT09IHVuZGVmaW5lZCB8fCBvdGhlciA9PT0gbnVsbCB8fCBvdGhlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9uZS5leGVjdXRpb25PcmRlciA9PT0gb3RoZXIuZXhlY3V0aW9uT3JkZXIgJiYgb25lLnN1Y2Nlc3MgPT09IG90aGVyLnN1Y2Nlc3M7XG4gICAgfVxuICAgIEV4ZWN1dGlvblN1bW1hcnkuZXF1YWxzID0gZXF1YWxzO1xufSkoRXhlY3V0aW9uU3VtbWFyeSA9IGV4cG9ydHMuRXhlY3V0aW9uU3VtbWFyeSB8fCAoZXhwb3J0cy5FeGVjdXRpb25TdW1tYXJ5ID0ge30pKTtcbnZhciBOb3RlYm9va0NlbGw7XG4oZnVuY3Rpb24gKE5vdGVib29rQ2VsbCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShraW5kLCBkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4geyBraW5kLCBkb2N1bWVudCB9O1xuICAgIH1cbiAgICBOb3RlYm9va0NlbGwuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIE5vdGVib29rQ2VsbEtpbmQuaXMoY2FuZGlkYXRlLmtpbmQpICYmIHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLkRvY3VtZW50VXJpLmlzKGNhbmRpZGF0ZS5kb2N1bWVudCkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUubWV0YWRhdGEgPT09IHVuZGVmaW5lZCB8fCBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZS5tZXRhZGF0YSkpO1xuICAgIH1cbiAgICBOb3RlYm9va0NlbGwuaXMgPSBpcztcbiAgICBmdW5jdGlvbiBkaWZmKG9uZSwgdHdvKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQoKTtcbiAgICAgICAgaWYgKG9uZS5kb2N1bWVudCAhPT0gdHdvLmRvY3VtZW50KSB7XG4gICAgICAgICAgICByZXN1bHQuYWRkKCdkb2N1bWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbmUua2luZCAhPT0gdHdvLmtpbmQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hZGQoJ2tpbmQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25lLmV4ZWN1dGlvblN1bW1hcnkgIT09IHR3by5leGVjdXRpb25TdW1tYXJ5KSB7XG4gICAgICAgICAgICByZXN1bHQuYWRkKCdleGVjdXRpb25TdW1tYXJ5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChvbmUubWV0YWRhdGEgIT09IHVuZGVmaW5lZCB8fCB0d28ubWV0YWRhdGEgIT09IHVuZGVmaW5lZCkgJiYgIWVxdWFsc01ldGFkYXRhKG9uZS5tZXRhZGF0YSwgdHdvLm1ldGFkYXRhKSkge1xuICAgICAgICAgICAgcmVzdWx0LmFkZCgnbWV0YWRhdGEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG9uZS5leGVjdXRpb25TdW1tYXJ5ICE9PSB1bmRlZmluZWQgfHwgdHdvLmV4ZWN1dGlvblN1bW1hcnkgIT09IHVuZGVmaW5lZCkgJiYgIUV4ZWN1dGlvblN1bW1hcnkuZXF1YWxzKG9uZS5leGVjdXRpb25TdW1tYXJ5LCB0d28uZXhlY3V0aW9uU3VtbWFyeSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hZGQoJ2V4ZWN1dGlvblN1bW1hcnknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBOb3RlYm9va0NlbGwuZGlmZiA9IGRpZmY7XG4gICAgZnVuY3Rpb24gZXF1YWxzTWV0YWRhdGEob25lLCBvdGhlcikge1xuICAgICAgICBpZiAob25lID09PSBvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uZSA9PT0gbnVsbCB8fCBvbmUgPT09IHVuZGVmaW5lZCB8fCBvdGhlciA9PT0gbnVsbCB8fCBvdGhlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvbmUgIT09IHR5cGVvZiBvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb25lICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uZUFycmF5ID0gQXJyYXkuaXNBcnJheShvbmUpO1xuICAgICAgICBjb25zdCBvdGhlckFycmF5ID0gQXJyYXkuaXNBcnJheShvdGhlcik7XG4gICAgICAgIGlmIChvbmVBcnJheSAhPT0gb3RoZXJBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbmVBcnJheSAmJiBvdGhlckFycmF5KSB7XG4gICAgICAgICAgICBpZiAob25lLmxlbmd0aCAhPT0gb3RoZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVxdWFsc01ldGFkYXRhKG9uZVtpXSwgb3RoZXJbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLm9iamVjdExpdGVyYWwob25lKSAmJiBJcy5vYmplY3RMaXRlcmFsKG90aGVyKSkge1xuICAgICAgICAgICAgY29uc3Qgb25lS2V5cyA9IE9iamVjdC5rZXlzKG9uZSk7XG4gICAgICAgICAgICBjb25zdCBvdGhlcktleXMgPSBPYmplY3Qua2V5cyhvdGhlcik7XG4gICAgICAgICAgICBpZiAob25lS2V5cy5sZW5ndGggIT09IG90aGVyS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbmVLZXlzLnNvcnQoKTtcbiAgICAgICAgICAgIG90aGVyS2V5cy5zb3J0KCk7XG4gICAgICAgICAgICBpZiAoIWVxdWFsc01ldGFkYXRhKG9uZUtleXMsIG90aGVyS2V5cykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9uZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wID0gb25lS2V5c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIWVxdWFsc01ldGFkYXRhKG9uZVtwcm9wXSwgb3RoZXJbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufSkoTm90ZWJvb2tDZWxsID0gZXhwb3J0cy5Ob3RlYm9va0NlbGwgfHwgKGV4cG9ydHMuTm90ZWJvb2tDZWxsID0ge30pKTtcbnZhciBOb3RlYm9va0RvY3VtZW50O1xuKGZ1bmN0aW9uIChOb3RlYm9va0RvY3VtZW50KSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgbm90ZWJvb2tUeXBlLCB2ZXJzaW9uLCBjZWxscykge1xuICAgICAgICByZXR1cm4geyB1cmksIG5vdGVib29rVHlwZSwgdmVyc2lvbiwgY2VsbHMgfTtcbiAgICB9XG4gICAgTm90ZWJvb2tEb2N1bWVudC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLmludGVnZXIuaXMoY2FuZGlkYXRlLnZlcnNpb24pICYmIElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLmNlbGxzLCBOb3RlYm9va0NlbGwuaXMpO1xuICAgIH1cbiAgICBOb3RlYm9va0RvY3VtZW50LmlzID0gaXM7XG59KShOb3RlYm9va0RvY3VtZW50ID0gZXhwb3J0cy5Ob3RlYm9va0RvY3VtZW50IHx8IChleHBvcnRzLk5vdGVib29rRG9jdW1lbnQgPSB7fSkpO1xudmFyIE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZTtcbihmdW5jdGlvbiAoTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlKSB7XG4gICAgTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZCA9ICdub3RlYm9va0RvY3VtZW50L3N5bmMnO1xuICAgIE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZS5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZS50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUmVnaXN0cmF0aW9uVHlwZShOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUubWV0aG9kKTtcbn0pKE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZSA9IGV4cG9ydHMuTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlIHx8IChleHBvcnRzLk5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZSA9IHt9KSk7XG4vKipcbiAqIEEgbm90aWZpY2F0aW9uIHNlbnQgd2hlbiBhIG5vdGVib29rIG9wZW5zLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIERpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbikge1xuICAgIERpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCA9ICdub3RlYm9va0RvY3VtZW50L2RpZE9wZW4nO1xuICAgIERpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xuICAgIERpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLnJlZ2lzdHJhdGlvbk1ldGhvZCA9IE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZS5tZXRob2Q7XG59KShEaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xudmFyIE5vdGVib29rQ2VsbEFycmF5Q2hhbmdlO1xuKGZ1bmN0aW9uIChOb3RlYm9va0NlbGxBcnJheUNoYW5nZSkge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLnVpbnRlZ2VyLmlzKGNhbmRpZGF0ZS5zdGFydCkgJiYgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3R5cGVzXzEudWludGVnZXIuaXMoY2FuZGlkYXRlLmRlbGV0ZUNvdW50KSAmJiAoY2FuZGlkYXRlLmNlbGxzID09PSB1bmRlZmluZWQgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUuY2VsbHMsIE5vdGVib29rQ2VsbC5pcykpO1xuICAgIH1cbiAgICBOb3RlYm9va0NlbGxBcnJheUNoYW5nZS5pcyA9IGlzO1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShzdGFydCwgZGVsZXRlQ291bnQsIGNlbGxzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgc3RhcnQsIGRlbGV0ZUNvdW50IH07XG4gICAgICAgIGlmIChjZWxscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQuY2VsbHMgPSBjZWxscztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBOb3RlYm9va0NlbGxBcnJheUNoYW5nZS5jcmVhdGUgPSBjcmVhdGU7XG59KShOb3RlYm9va0NlbGxBcnJheUNoYW5nZSA9IGV4cG9ydHMuTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2UgfHwgKGV4cG9ydHMuTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2UgPSB7fSkpO1xudmFyIERpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24pIHtcbiAgICBEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCA9ICdub3RlYm9va0RvY3VtZW50L2RpZENoYW5nZSc7XG4gICAgRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCk7XG4gICAgRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5yZWdpc3RyYXRpb25NZXRob2QgPSBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUubWV0aG9kO1xufSkoRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogQSBub3RpZmljYXRpb24gc2VudCB3aGVuIGEgbm90ZWJvb2sgZG9jdW1lbnQgaXMgc2F2ZWQuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kID0gJ25vdGVib29rRG9jdW1lbnQvZGlkU2F2ZSc7XG4gICAgRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCk7XG4gICAgRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ucmVnaXN0cmF0aW9uTWV0aG9kID0gTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZDtcbn0pKERpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIEEgbm90aWZpY2F0aW9uIHNlbnQgd2hlbiBhIG5vdGVib29rIGNsb3Nlcy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBEaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbikge1xuICAgIERpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAnbm90ZWJvb2tEb2N1bWVudC9kaWRDbG9zZSc7XG4gICAgRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCk7XG4gICAgRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLnJlZ2lzdHJhdGlvbk1ldGhvZCA9IE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZS5tZXRob2Q7XG59KShEaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3ODk1OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24gPSBleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0ID0gZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzID0gdm9pZCAwO1xuY29uc3QgdnNjb2RlX2pzb25ycGNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTk1Myk7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTk5KTtcbnZhciBXb3JrRG9uZVByb2dyZXNzO1xuKGZ1bmN0aW9uIChXb3JrRG9uZVByb2dyZXNzKSB7XG4gICAgV29ya0RvbmVQcm9ncmVzcy50eXBlID0gbmV3IHZzY29kZV9qc29ucnBjXzEuUHJvZ3Jlc3NUeXBlKCk7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBXb3JrRG9uZVByb2dyZXNzLnR5cGU7XG4gICAgfVxuICAgIFdvcmtEb25lUHJvZ3Jlc3MuaXMgPSBpcztcbn0pKFdvcmtEb25lUHJvZ3Jlc3MgPSBleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3MgfHwgKGV4cG9ydHMuV29ya0RvbmVQcm9ncmVzcyA9IHt9KSk7XG4vKipcbiAqIFRoZSBgd2luZG93L3dvcmtEb25lUHJvZ3Jlc3MvY3JlYXRlYCByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gaW5pdGlhdGUgcHJvZ3Jlc3NcbiAqIHJlcG9ydGluZyBmcm9tIHRoZSBzZXJ2ZXIuXG4gKi9cbnZhciBXb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdDtcbihmdW5jdGlvbiAoV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QpIHtcbiAgICBXb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdC5tZXRob2QgPSAnd2luZG93L3dvcmtEb25lUHJvZ3Jlc3MvY3JlYXRlJztcbiAgICBXb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIFdvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFdvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0Lm1ldGhvZCk7XG59KShXb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdCA9IGV4cG9ydHMuV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QgfHwgKGV4cG9ydHMuV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBUaGUgYHdpbmRvdy93b3JrRG9uZVByb2dyZXNzL2NhbmNlbGAgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSAgdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHRvIGNhbmNlbCBhIHByb2dyZXNzXG4gKiBpbml0aWF0ZWQgb24gdGhlIHNlcnZlciBzaWRlLlxuICovXG52YXIgV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbikge1xuICAgIFdvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24ubWV0aG9kID0gJ3dpbmRvdy93b3JrRG9uZVByb2dyZXNzL2NhbmNlbCc7XG4gICAgV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShXb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShXb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24gPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyMzkyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODU5OSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBwcm92aWRlIHNlbGVjdGlvbiByYW5nZXMgaW4gYSBkb2N1bWVudC4gVGhlIHJlcXVlc3Qnc1xuICogcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIFNlbGVjdGlvblJhbmdlUGFyYW1zfSwgdGhlXG4gKiByZXNwb25zZSBpcyBvZiB0eXBlIHtAbGluayBTZWxlY3Rpb25SYW5nZSBTZWxlY3Rpb25SYW5nZVtdfSBvciBhIFRoZW5hYmxlXG4gKiB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBTZWxlY3Rpb25SYW5nZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKFNlbGVjdGlvblJhbmdlUmVxdWVzdCkge1xuICAgIFNlbGVjdGlvblJhbmdlUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3NlbGVjdGlvblJhbmdlJztcbiAgICBTZWxlY3Rpb25SYW5nZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBTZWxlY3Rpb25SYW5nZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0Lm1ldGhvZCk7XG59KShTZWxlY3Rpb25SYW5nZVJlcXVlc3QgPSBleHBvcnRzLlNlbGVjdGlvblJhbmdlUmVxdWVzdCB8fCAoZXhwb3J0cy5TZWxlY3Rpb25SYW5nZVJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NDg5OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLlNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0ID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZXF1ZXN0ID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUgPSBleHBvcnRzLlRva2VuRm9ybWF0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODU5OSk7XG4vLy0tLS0tLS0gJ3RleHREb2N1bWVudC9zZW1hbnRpY1Rva2VucycgLS0tLS1cbnZhciBUb2tlbkZvcm1hdDtcbihmdW5jdGlvbiAoVG9rZW5Gb3JtYXQpIHtcbiAgICBUb2tlbkZvcm1hdC5SZWxhdGl2ZSA9ICdyZWxhdGl2ZSc7XG59KShUb2tlbkZvcm1hdCA9IGV4cG9ydHMuVG9rZW5Gb3JtYXQgfHwgKGV4cG9ydHMuVG9rZW5Gb3JtYXQgPSB7fSkpO1xudmFyIFNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZTtcbihmdW5jdGlvbiAoU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlKSB7XG4gICAgU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvc2VtYW50aWNUb2tlbnMnO1xuICAgIFNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZS50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUmVnaXN0cmF0aW9uVHlwZShTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUubWV0aG9kKTtcbn0pKFNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZSA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlIHx8IChleHBvcnRzLlNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZSA9IHt9KSk7XG4vKipcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFNlbWFudGljVG9rZW5zUmVxdWVzdDtcbihmdW5jdGlvbiAoU2VtYW50aWNUb2tlbnNSZXF1ZXN0KSB7XG4gICAgU2VtYW50aWNUb2tlbnNSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvc2VtYW50aWNUb2tlbnMvZnVsbCc7XG4gICAgU2VtYW50aWNUb2tlbnNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgU2VtYW50aWNUb2tlbnNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFNlbWFudGljVG9rZW5zUmVxdWVzdC5tZXRob2QpO1xuICAgIFNlbWFudGljVG9rZW5zUmVxdWVzdC5yZWdpc3RyYXRpb25NZXRob2QgPSBTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUubWV0aG9kO1xufSkoU2VtYW50aWNUb2tlbnNSZXF1ZXN0ID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlcXVlc3QgfHwgKGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3Q7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0KSB7XG4gICAgU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9zZW1hbnRpY1Rva2Vucy9mdWxsL2RlbHRhJztcbiAgICBTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0Lm1ldGhvZCk7XG4gICAgU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QucmVnaXN0cmF0aW9uTWV0aG9kID0gU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZDtcbn0pKFNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0ID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdCB8fCAoZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0O1xuKGZ1bmN0aW9uIChTZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdCkge1xuICAgIFNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvc2VtYW50aWNUb2tlbnMvcmFuZ2UnO1xuICAgIFNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QubWV0aG9kKTtcbiAgICBTZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdC5yZWdpc3RyYXRpb25NZXRob2QgPSBTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUubWV0aG9kO1xufSkoU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0IHx8IChleHBvcnRzLlNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdDtcbihmdW5jdGlvbiAoU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdCkge1xuICAgIFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QubWV0aG9kID0gYHdvcmtzcGFjZS9zZW1hbnRpY1Rva2Vucy9yZWZyZXNoYDtcbiAgICBTZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdC5tZXRob2QpO1xufSkoU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdCB8fCAoZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTU0MTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5TaG93RG9jdW1lbnRSZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODU5OSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBzaG93IGEgZG9jdW1lbnQuIFRoaXMgcmVxdWVzdCBtaWdodCBvcGVuIGFuXG4gKiBleHRlcm5hbCBwcm9ncmFtIGRlcGVuZGluZyBvbiB0aGUgdmFsdWUgb2YgdGhlIFVSSSB0byBvcGVuLlxuICogRm9yIGV4YW1wbGUgYSByZXF1ZXN0IHRvIG9wZW4gYGh0dHBzOi8vY29kZS52aXN1YWxzdHVkaW8uY29tL2BcbiAqIHdpbGwgdmVyeSBsaWtlbHkgb3BlbiB0aGUgVVJJIGluIGEgV0VCIGJyb3dzZXIuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuKi9cbnZhciBTaG93RG9jdW1lbnRSZXF1ZXN0O1xuKGZ1bmN0aW9uIChTaG93RG9jdW1lbnRSZXF1ZXN0KSB7XG4gICAgU2hvd0RvY3VtZW50UmVxdWVzdC5tZXRob2QgPSAnd2luZG93L3Nob3dEb2N1bWVudCc7XG4gICAgU2hvd0RvY3VtZW50UmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIFNob3dEb2N1bWVudFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoU2hvd0RvY3VtZW50UmVxdWVzdC5tZXRob2QpO1xufSkoU2hvd0RvY3VtZW50UmVxdWVzdCA9IGV4cG9ydHMuU2hvd0RvY3VtZW50UmVxdWVzdCB8fCAoZXhwb3J0cy5TaG93RG9jdW1lbnRSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODY0Mjpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5UeXBlRGVmaW5pdGlvblJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTk5KTtcbi8vIEB0cy1pZ25vcmU6IHRvIGF2b2lkIGlubGluaW5nIExvY2F0aW9MaW5rIGFzIGR5bmFtaWMgaW1wb3J0XG5sZXQgX19ub0R5bmFtaWNJbXBvcnQ7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSB0eXBlIGRlZmluaXRpb24gbG9jYXRpb25zIG9mIGEgc3ltYm9sIGF0IGEgZ2l2ZW4gdGV4dFxuICogZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUgW1RleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zXVxuICogKCNUZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtcykgdGhlIHJlc3BvbnNlIGlzIG9mIHR5cGUge0BsaW5rIERlZmluaXRpb259IG9yIGFcbiAqIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIFR5cGVEZWZpbml0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoVHlwZURlZmluaXRpb25SZXF1ZXN0KSB7XG4gICAgVHlwZURlZmluaXRpb25SZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvdHlwZURlZmluaXRpb24nO1xuICAgIFR5cGVEZWZpbml0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFR5cGVEZWZpbml0aW9uUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShUeXBlRGVmaW5pdGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKFR5cGVEZWZpbml0aW9uUmVxdWVzdCA9IGV4cG9ydHMuVHlwZURlZmluaXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLlR5cGVEZWZpbml0aW9uUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDUzMTg6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBUeXBlRm94LCBNaWNyb3NvZnQgYW5kIG90aGVycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5UeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0ID0gZXhwb3J0cy5UeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QgPSBleHBvcnRzLlR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1OTkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzdWx0IGEgYFR5cGVIaWVyYXJjaHlJdGVtYCBpbiBhIGRvY3VtZW50IGF0IGEgZ2l2ZW4gcG9zaXRpb24uXG4gKiBDYW4gYmUgdXNlZCBhcyBhbiBpbnB1dCB0byBhIHN1YnR5cGVzIG9yIHN1cGVydHlwZXMgdHlwZSBoaWVyYXJjaHkuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChUeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QpIHtcbiAgICBUeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9wcmVwYXJlVHlwZUhpZXJhcmNoeSc7XG4gICAgVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdC5tZXRob2QpO1xufSkoVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0ID0gZXhwb3J0cy5UeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QgfHwgKGV4cG9ydHMuVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgdGhlIHN1cGVydHlwZXMgZm9yIGEgZ2l2ZW4gYFR5cGVIaWVyYXJjaHlJdGVtYC5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBUeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKFR5cGVIaWVyYXJjaHlTdXBlcnR5cGVzUmVxdWVzdCkge1xuICAgIFR5cGVIaWVyYXJjaHlTdXBlcnR5cGVzUmVxdWVzdC5tZXRob2QgPSAndHlwZUhpZXJhcmNoeS9zdXBlcnR5cGVzJztcbiAgICBUeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBUeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0Lm1ldGhvZCk7XG59KShUeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QgPSBleHBvcnRzLlR5cGVIaWVyYXJjaHlTdXBlcnR5cGVzUmVxdWVzdCB8fCAoZXhwb3J0cy5UeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSB0aGUgc3VidHlwZXMgZm9yIGEgZ2l2ZW4gYFR5cGVIaWVyYXJjaHlJdGVtYC5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBUeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChUeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0KSB7XG4gICAgVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdC5tZXRob2QgPSAndHlwZUhpZXJhcmNoeS9zdWJ0eXBlcyc7XG4gICAgVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdC5tZXRob2QpO1xufSkoVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdCA9IGV4cG9ydHMuVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdCB8fCAoZXhwb3J0cy5UeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzQwMjpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5EaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Xb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1OTkpO1xuLyoqXG4gKiBUaGUgYHdvcmtzcGFjZS93b3Jrc3BhY2VGb2xkZXJzYCBpcyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIGZldGNoIHRoZSBvcGVuIHdvcmtzcGFjZSBmb2xkZXJzLlxuICovXG52YXIgV29ya3NwYWNlRm9sZGVyc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKFdvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0KSB7XG4gICAgV29ya3NwYWNlRm9sZGVyc1JlcXVlc3QubWV0aG9kID0gJ3dvcmtzcGFjZS93b3Jrc3BhY2VGb2xkZXJzJztcbiAgICBXb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIFdvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlMChXb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdC5tZXRob2QpO1xufSkoV29ya3NwYWNlRm9sZGVyc1JlcXVlc3QgPSBleHBvcnRzLldvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0IHx8IChleHBvcnRzLldvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIGB3b3Jrc3BhY2UvZGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc2Agbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgd2hlbiB0aGUgd29ya3NwYWNlXG4gKiBmb2xkZXIgY29uZmlndXJhdGlvbiBjaGFuZ2VzLlxuICovXG52YXIgRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvbikge1xuICAgIERpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24ubWV0aG9kID0gJ3dvcmtzcGFjZS9kaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzJztcbiAgICBEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvbiA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI1MjM6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMub2JqZWN0TGl0ZXJhbCA9IGV4cG9ydHMudHlwZWRBcnJheSA9IGV4cG9ydHMuc3RyaW5nQXJyYXkgPSBleHBvcnRzLmFycmF5ID0gZXhwb3J0cy5mdW5jID0gZXhwb3J0cy5lcnJvciA9IGV4cG9ydHMubnVtYmVyID0gZXhwb3J0cy5zdHJpbmcgPSBleHBvcnRzLmJvb2xlYW4gPSB2b2lkIDA7XG5mdW5jdGlvbiBib29sZWFuKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZTtcbn1cbmV4cG9ydHMuYm9vbGVhbiA9IGJvb2xlYW47XG5mdW5jdGlvbiBzdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZztcbn1cbmV4cG9ydHMuc3RyaW5nID0gc3RyaW5nO1xuZnVuY3Rpb24gbnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXI7XG59XG5leHBvcnRzLm51bWJlciA9IG51bWJlcjtcbmZ1bmN0aW9uIGVycm9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRXJyb3I7XG59XG5leHBvcnRzLmVycm9yID0gZXJyb3I7XG5mdW5jdGlvbiBmdW5jKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuZnVuYyA9IGZ1bmM7XG5mdW5jdGlvbiBhcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbmV4cG9ydHMuYXJyYXkgPSBhcnJheTtcbmZ1bmN0aW9uIHN0cmluZ0FycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIGFycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShlbGVtID0+IHN0cmluZyhlbGVtKSk7XG59XG5leHBvcnRzLnN0cmluZ0FycmF5ID0gc3RyaW5nQXJyYXk7XG5mdW5jdGlvbiB0eXBlZEFycmF5KHZhbHVlLCBjaGVjaykge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShjaGVjayk7XG59XG5leHBvcnRzLnR5cGVkQXJyYXkgPSB0eXBlZEFycmF5O1xuZnVuY3Rpb24gb2JqZWN0TGl0ZXJhbCh2YWx1ZSkge1xuICAgIC8vIFN0cmljdGx5IHNwZWFraW5nIGNsYXNzIGluc3RhbmNlcyBwYXNzIHRoaXMgY2hlY2sgYXMgd2VsbC4gU2luY2UgdGhlIExTUFxuICAgIC8vIGRvZXNuJ3QgdXNlIGNsYXNzZXMgd2UgaWdub3JlIHRoaXMgZm9yIG5vdy4gSWYgd2UgZG8gd2UgbmVlZCB0byBhZGQgc29tZXRoaW5nXG4gICAgLy8gbGlrZSB0aGlzOiBgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZih4KSkgPT09IG51bGxgXG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG59XG5leHBvcnRzLm9iamVjdExpdGVyYWwgPSBvYmplY3RMaXRlcmFsO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0ODgxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIG46ICgpID0+ICgvKiBiaW5kaW5nICovIFRleHREb2N1bWVudClcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG52YXIgX19zcHJlYWRBcnJheSA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xudmFyIEZ1bGxUZXh0RG9jdW1lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRnVsbFRleHREb2N1bWVudCh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5fdXJpID0gdXJpO1xuICAgICAgICB0aGlzLl9sYW5ndWFnZUlkID0gbGFuZ3VhZ2VJZDtcbiAgICAgICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLCBcInVyaVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VyaTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZSwgXCJsYW5ndWFnZUlkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGFuZ3VhZ2VJZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZSwgXCJ2ZXJzaW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLmdldFRleHQgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLmVuZCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7XG4gICAgfTtcbiAgICBGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoY2hhbmdlcywgdmVyc2lvbikge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGNoYW5nZXNfMSA9IGNoYW5nZXM7IF9pIDwgY2hhbmdlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNfMVtfaV07XG4gICAgICAgICAgICBpZiAoRnVsbFRleHREb2N1bWVudC5pc0luY3JlbWVudGFsKGNoYW5nZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlcyBzdXJlIHN0YXJ0IGlzIGJlZm9yZSBlbmRcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBnZXRXZWxsZm9ybWVkUmFuZ2UoY2hhbmdlLnJhbmdlKTtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgY29udGVudFxuICAgICAgICAgICAgICAgIHZhciBzdGFydE9mZnNldCA9IHRoaXMub2Zmc2V0QXQocmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgICAgIHZhciBlbmRPZmZzZXQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLmVuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGVudCA9IHRoaXMuX2NvbnRlbnQuc3Vic3RyaW5nKDAsIHN0YXJ0T2Zmc2V0KSArIGNoYW5nZS50ZXh0ICsgdGhpcy5fY29udGVudC5zdWJzdHJpbmcoZW5kT2Zmc2V0LCB0aGlzLl9jb250ZW50Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBvZmZzZXRzXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0TGluZSA9IE1hdGgubWF4KHJhbmdlLnN0YXJ0LmxpbmUsIDApO1xuICAgICAgICAgICAgICAgIHZhciBlbmRMaW5lID0gTWF0aC5tYXgocmFuZ2UuZW5kLmxpbmUsIDApO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lT2Zmc2V0cyA9IHRoaXMuX2xpbmVPZmZzZXRzO1xuICAgICAgICAgICAgICAgIHZhciBhZGRlZExpbmVPZmZzZXRzID0gY29tcHV0ZUxpbmVPZmZzZXRzKGNoYW5nZS50ZXh0LCBmYWxzZSwgc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChlbmRMaW5lIC0gc3RhcnRMaW5lID09PSBhZGRlZExpbmVPZmZzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYWRkZWRMaW5lT2Zmc2V0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZU9mZnNldHNbaSArIHN0YXJ0TGluZSArIDFdID0gYWRkZWRMaW5lT2Zmc2V0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZGVkTGluZU9mZnNldHMubGVuZ3RoIDwgMTAwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVPZmZzZXRzLnNwbGljZS5hcHBseShsaW5lT2Zmc2V0cywgX19zcHJlYWRBcnJheShbc3RhcnRMaW5lICsgMSwgZW5kTGluZSAtIHN0YXJ0TGluZV0sIGFkZGVkTGluZU9mZnNldHMsIGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7IC8vIGF2b2lkIHRvbyBtYW55IGFyZ3VtZW50cyBmb3Igc3BsaWNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IGxpbmVPZmZzZXRzID0gbGluZU9mZnNldHMuc2xpY2UoMCwgc3RhcnRMaW5lICsgMSkuY29uY2F0KGFkZGVkTGluZU9mZnNldHMsIGxpbmVPZmZzZXRzLnNsaWNlKGVuZExpbmUgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGRpZmYgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAoZW5kT2Zmc2V0IC0gc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChkaWZmICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydExpbmUgKyAxICsgYWRkZWRMaW5lT2Zmc2V0cy5sZW5ndGgsIGxlbiA9IGxpbmVPZmZzZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lT2Zmc2V0c1tpXSA9IGxpbmVPZmZzZXRzW2ldICsgZGlmZjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEZ1bGxUZXh0RG9jdW1lbnQuaXNGdWxsKGNoYW5nZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZW50ID0gY2hhbmdlLnRleHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY2hhbmdlIGV2ZW50IHJlY2VpdmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XG4gICAgfTtcbiAgICBGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZS5nZXRMaW5lT2Zmc2V0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xpbmVPZmZzZXRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gY29tcHV0ZUxpbmVPZmZzZXRzKHRoaXMuX2NvbnRlbnQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lT2Zmc2V0cztcbiAgICB9O1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLnBvc2l0aW9uQXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IE1hdGgubWF4KE1hdGgubWluKG9mZnNldCwgdGhpcy5fY29udGVudC5sZW5ndGgpLCAwKTtcbiAgICAgICAgdmFyIGxpbmVPZmZzZXRzID0gdGhpcy5nZXRMaW5lT2Zmc2V0cygpO1xuICAgICAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGxpbmVPZmZzZXRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGhpZ2ggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7IGxpbmU6IDAsIGNoYXJhY3Rlcjogb2Zmc2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKChsb3cgKyBoaWdoKSAvIDIpO1xuICAgICAgICAgICAgaWYgKGxpbmVPZmZzZXRzW21pZF0gPiBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBsb3cgaXMgdGhlIGxlYXN0IHggZm9yIHdoaWNoIHRoZSBsaW5lIG9mZnNldCBpcyBsYXJnZXIgdGhhbiB0aGUgY3VycmVudCBvZmZzZXRcbiAgICAgICAgLy8gb3IgYXJyYXkubGVuZ3RoIGlmIG5vIGxpbmUgb2Zmc2V0IGlzIGxhcmdlciB0aGFuIHRoZSBjdXJyZW50IG9mZnNldFxuICAgICAgICB2YXIgbGluZSA9IGxvdyAtIDE7XG4gICAgICAgIHJldHVybiB7IGxpbmU6IGxpbmUsIGNoYXJhY3Rlcjogb2Zmc2V0IC0gbGluZU9mZnNldHNbbGluZV0gfTtcbiAgICB9O1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLm9mZnNldEF0ID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBsaW5lT2Zmc2V0cyA9IHRoaXMuZ2V0TGluZU9mZnNldHMoKTtcbiAgICAgICAgaWYgKHBvc2l0aW9uLmxpbmUgPj0gbGluZU9mZnNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocG9zaXRpb24ubGluZSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaW5lT2Zmc2V0ID0gbGluZU9mZnNldHNbcG9zaXRpb24ubGluZV07XG4gICAgICAgIHZhciBuZXh0TGluZU9mZnNldCA9IChwb3NpdGlvbi5saW5lICsgMSA8IGxpbmVPZmZzZXRzLmxlbmd0aCkgPyBsaW5lT2Zmc2V0c1twb3NpdGlvbi5saW5lICsgMV0gOiB0aGlzLl9jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKGxpbmVPZmZzZXQgKyBwb3NpdGlvbi5jaGFyYWN0ZXIsIG5leHRMaW5lT2Zmc2V0KSwgbGluZU9mZnNldCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUsIFwibGluZUNvdW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMaW5lT2Zmc2V0cygpLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQuaXNJbmNyZW1lbnRhbCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gZXZlbnQ7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjYW5kaWRhdGUudGV4dCA9PT0gJ3N0cmluZycgJiYgY2FuZGlkYXRlLnJhbmdlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUucmFuZ2VMZW5ndGggPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgY2FuZGlkYXRlLnJhbmdlTGVuZ3RoID09PSAnbnVtYmVyJyk7XG4gICAgfTtcbiAgICBGdWxsVGV4dERvY3VtZW50LmlzRnVsbCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gZXZlbnQ7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjYW5kaWRhdGUudGV4dCA9PT0gJ3N0cmluZycgJiYgY2FuZGlkYXRlLnJhbmdlID09PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlLnJhbmdlTGVuZ3RoID09PSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICByZXR1cm4gRnVsbFRleHREb2N1bWVudDtcbn0oKSk7XG52YXIgVGV4dERvY3VtZW50O1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRleHQgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBkb2N1bWVudCdzIHVyaS5cbiAgICAgKiBAcGFyYW0gbGFuZ3VhZ2VJZCAgVGhlIGRvY3VtZW50J3MgbGFuZ3VhZ2UgSWQuXG4gICAgICogQHBhcmFtIHZlcnNpb24gVGhlIGRvY3VtZW50J3MgaW5pdGlhbCB2ZXJzaW9uIG51bWJlci5cbiAgICAgKiBAcGFyYW0gY29udGVudCBUaGUgZG9jdW1lbnQncyBjb250ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdWxsVGV4dERvY3VtZW50KHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhIFRleHREb2N1bWVudCBieSBtb2RpZnlpbmcgaXRzIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQgdGhlIGRvY3VtZW50IHRvIHVwZGF0ZS4gT25seSBkb2N1bWVudHMgY3JlYXRlZCBieSBUZXh0RG9jdW1lbnQuY3JlYXRlIGFyZSB2YWxpZCBpbnB1dHMuXG4gICAgICogQHBhcmFtIGNoYW5nZXMgdGhlIGNoYW5nZXMgdG8gYXBwbHkgdG8gdGhlIGRvY3VtZW50LlxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIHRoZSBjaGFuZ2VzIHZlcnNpb24gZm9yIHRoZSBkb2N1bWVudC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdXBkYXRlZCBUZXh0RG9jdW1lbnQuIE5vdGU6IFRoYXQncyB0aGUgc2FtZSBkb2N1bWVudCBpbnN0YW5jZSBwYXNzZWQgaW4gYXMgZmlyc3QgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlKGRvY3VtZW50LCBjaGFuZ2VzLCB2ZXJzaW9uKSB7XG4gICAgICAgIGlmIChkb2N1bWVudCBpbnN0YW5jZW9mIEZ1bGxUZXh0RG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnVwZGF0ZShjaGFuZ2VzLCB2ZXJzaW9uKTtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGV4dERvY3VtZW50LnVwZGF0ZTogZG9jdW1lbnQgbXVzdCBiZSBjcmVhdGVkIGJ5IFRleHREb2N1bWVudC5jcmVhdGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQudXBkYXRlID0gdXBkYXRlO1xuICAgIGZ1bmN0aW9uIGFwcGx5RWRpdHMoZG9jdW1lbnQsIGVkaXRzKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gZG9jdW1lbnQuZ2V0VGV4dCgpO1xuICAgICAgICB2YXIgc29ydGVkRWRpdHMgPSBtZXJnZVNvcnQoZWRpdHMubWFwKGdldFdlbGxmb3JtZWRFZGl0KSwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBkaWZmID0gYS5yYW5nZS5zdGFydC5saW5lIC0gYi5yYW5nZS5zdGFydC5saW5lO1xuICAgICAgICAgICAgaWYgKGRpZmYgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5yYW5nZS5zdGFydC5jaGFyYWN0ZXIgLSBiLnJhbmdlLnN0YXJ0LmNoYXJhY3RlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxhc3RNb2RpZmllZE9mZnNldCA9IDA7XG4gICAgICAgIHZhciBzcGFucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNvcnRlZEVkaXRzXzEgPSBzb3J0ZWRFZGl0czsgX2kgPCBzb3J0ZWRFZGl0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGUgPSBzb3J0ZWRFZGl0c18xW19pXTtcbiAgICAgICAgICAgIHZhciBzdGFydE9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KGUucmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0T2Zmc2V0IDwgbGFzdE1vZGlmaWVkT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPdmVybGFwcGluZyBlZGl0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdGFydE9mZnNldCA+IGxhc3RNb2RpZmllZE9mZnNldCkge1xuICAgICAgICAgICAgICAgIHNwYW5zLnB1c2godGV4dC5zdWJzdHJpbmcobGFzdE1vZGlmaWVkT2Zmc2V0LCBzdGFydE9mZnNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUubmV3VGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzcGFucy5wdXNoKGUubmV3VGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0TW9kaWZpZWRPZmZzZXQgPSBkb2N1bWVudC5vZmZzZXRBdChlLnJhbmdlLmVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3BhbnMucHVzaCh0ZXh0LnN1YnN0cihsYXN0TW9kaWZpZWRPZmZzZXQpKTtcbiAgICAgICAgcmV0dXJuIHNwYW5zLmpvaW4oJycpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQuYXBwbHlFZGl0cyA9IGFwcGx5RWRpdHM7XG59KShUZXh0RG9jdW1lbnQgfHwgKFRleHREb2N1bWVudCA9IHt9KSk7XG5mdW5jdGlvbiBtZXJnZVNvcnQoZGF0YSwgY29tcGFyZSkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIC8vIHNvcnRlZFxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgdmFyIHAgPSAoZGF0YS5sZW5ndGggLyAyKSB8IDA7XG4gICAgdmFyIGxlZnQgPSBkYXRhLnNsaWNlKDAsIHApO1xuICAgIHZhciByaWdodCA9IGRhdGEuc2xpY2UocCk7XG4gICAgbWVyZ2VTb3J0KGxlZnQsIGNvbXBhcmUpO1xuICAgIG1lcmdlU29ydChyaWdodCwgY29tcGFyZSk7XG4gICAgdmFyIGxlZnRJZHggPSAwO1xuICAgIHZhciByaWdodElkeCA9IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChsZWZ0SWR4IDwgbGVmdC5sZW5ndGggJiYgcmlnaHRJZHggPCByaWdodC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHJldCA9IGNvbXBhcmUobGVmdFtsZWZ0SWR4XSwgcmlnaHRbcmlnaHRJZHhdKTtcbiAgICAgICAgaWYgKHJldCA8PSAwKSB7XG4gICAgICAgICAgICAvLyBzbWFsbGVyX2VxdWFsIC0+IHRha2UgbGVmdCB0byBwcmVzZXJ2ZSBvcmRlclxuICAgICAgICAgICAgZGF0YVtpKytdID0gbGVmdFtsZWZ0SWR4KytdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZ3JlYXRlciAtPiB0YWtlIHJpZ2h0XG4gICAgICAgICAgICBkYXRhW2krK10gPSByaWdodFtyaWdodElkeCsrXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAobGVmdElkeCA8IGxlZnQubGVuZ3RoKSB7XG4gICAgICAgIGRhdGFbaSsrXSA9IGxlZnRbbGVmdElkeCsrXTtcbiAgICB9XG4gICAgd2hpbGUgKHJpZ2h0SWR4IDwgcmlnaHQubGVuZ3RoKSB7XG4gICAgICAgIGRhdGFbaSsrXSA9IHJpZ2h0W3JpZ2h0SWR4KytdO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVMaW5lT2Zmc2V0cyh0ZXh0LCBpc0F0TGluZVN0YXJ0LCB0ZXh0T2Zmc2V0KSB7XG4gICAgaWYgKHRleHRPZmZzZXQgPT09IHZvaWQgMCkgeyB0ZXh0T2Zmc2V0ID0gMDsgfVxuICAgIHZhciByZXN1bHQgPSBpc0F0TGluZVN0YXJ0ID8gW3RleHRPZmZzZXRdIDogW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaCA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNoID09PSAxMyAvKiBDaGFyQ29kZS5DYXJyaWFnZVJldHVybiAqLyB8fCBjaCA9PT0gMTAgLyogQ2hhckNvZGUuTGluZUZlZWQgKi8pIHtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gMTMgLyogQ2hhckNvZGUuQ2FycmlhZ2VSZXR1cm4gKi8gJiYgaSArIDEgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0LmNoYXJDb2RlQXQoaSArIDEpID09PSAxMCAvKiBDaGFyQ29kZS5MaW5lRmVlZCAqLykge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRleHRPZmZzZXQgKyBpICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldFdlbGxmb3JtZWRSYW5nZShyYW5nZSkge1xuICAgIHZhciBzdGFydCA9IHJhbmdlLnN0YXJ0O1xuICAgIHZhciBlbmQgPSByYW5nZS5lbmQ7XG4gICAgaWYgKHN0YXJ0LmxpbmUgPiBlbmQubGluZSB8fCAoc3RhcnQubGluZSA9PT0gZW5kLmxpbmUgJiYgc3RhcnQuY2hhcmFjdGVyID4gZW5kLmNoYXJhY3RlcikpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IGVuZCwgZW5kOiBzdGFydCB9O1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2U7XG59XG5mdW5jdGlvbiBnZXRXZWxsZm9ybWVkRWRpdCh0ZXh0RWRpdCkge1xuICAgIHZhciByYW5nZSA9IGdldFdlbGxmb3JtZWRSYW5nZSh0ZXh0RWRpdC5yYW5nZSk7XG4gICAgaWYgKHJhbmdlICE9PSB0ZXh0RWRpdC5yYW5nZSkge1xuICAgICAgICByZXR1cm4geyBuZXdUZXh0OiB0ZXh0RWRpdC5uZXdUZXh0LCByYW5nZTogcmFuZ2UgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHRFZGl0O1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NzY3OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEFubm90YXRlZFRleHRFZGl0OiAoKSA9PiAoLyogYmluZGluZyAqLyBBbm5vdGF0ZWRUZXh0RWRpdCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENoYW5nZUFubm90YXRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIENoYW5nZUFubm90YXRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb2RlQWN0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2RlQWN0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29kZUFjdGlvbkNvbnRleHQ6ICgpID0+ICgvKiBiaW5kaW5nICovIENvZGVBY3Rpb25Db250ZXh0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29kZUFjdGlvbktpbmQ6ICgpID0+ICgvKiBiaW5kaW5nICovIENvZGVBY3Rpb25LaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29kZUFjdGlvblRyaWdnZXJLaW5kOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2RlQWN0aW9uVHJpZ2dlcktpbmQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb2RlRGVzY3JpcHRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIENvZGVEZXNjcmlwdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvZGVMZW5zOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2RlTGVucyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvbG9yOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2xvciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvbG9ySW5mb3JtYXRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIENvbG9ySW5mb3JtYXRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb2xvclByZXNlbnRhdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29sb3JQcmVzZW50YXRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb21tYW5kOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb21tYW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tcGxldGlvbkl0ZW06ICgpID0+ICgvKiBiaW5kaW5nICovIENvbXBsZXRpb25JdGVtKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tcGxldGlvbkl0ZW1LaW5kOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb21wbGV0aW9uSXRlbUtpbmQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb21wbGV0aW9uSXRlbUxhYmVsRGV0YWlsczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHMpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb21wbGV0aW9uSXRlbVRhZzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29tcGxldGlvbkl0ZW1UYWcpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb21wbGV0aW9uTGlzdDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29tcGxldGlvbkxpc3QpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDcmVhdGVGaWxlOiAoKSA9PiAoLyogYmluZGluZyAqLyBDcmVhdGVGaWxlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRGVsZXRlRmlsZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRGVsZXRlRmlsZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERpYWdub3N0aWM6ICgpID0+ICgvKiBiaW5kaW5nICovIERpYWdub3N0aWMpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRGlhZ25vc3RpY1NldmVyaXR5OiAoKSA9PiAoLyogYmluZGluZyAqLyBEaWFnbm9zdGljU2V2ZXJpdHkpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBEaWFnbm9zdGljVGFnOiAoKSA9PiAoLyogYmluZGluZyAqLyBEaWFnbm9zdGljVGFnKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRG9jdW1lbnRIaWdobGlnaHQ6ICgpID0+ICgvKiBiaW5kaW5nICovIERvY3VtZW50SGlnaGxpZ2h0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRG9jdW1lbnRIaWdobGlnaHRLaW5kOiAoKSA9PiAoLyogYmluZGluZyAqLyBEb2N1bWVudEhpZ2hsaWdodEtpbmQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBEb2N1bWVudExpbms6ICgpID0+ICgvKiBiaW5kaW5nICovIERvY3VtZW50TGluayksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERvY3VtZW50U3ltYm9sOiAoKSA9PiAoLyogYmluZGluZyAqLyBEb2N1bWVudFN5bWJvbCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERvY3VtZW50VXJpOiAoKSA9PiAoLyogYmluZGluZyAqLyBEb2N1bWVudFVyaSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEVPTDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRU9MKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRm9sZGluZ1JhbmdlOiAoKSA9PiAoLyogYmluZGluZyAqLyBGb2xkaW5nUmFuZ2UpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBGb2xkaW5nUmFuZ2VLaW5kOiAoKSA9PiAoLyogYmluZGluZyAqLyBGb2xkaW5nUmFuZ2VLaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRm9ybWF0dGluZ09wdGlvbnM6ICgpID0+ICgvKiBiaW5kaW5nICovIEZvcm1hdHRpbmdPcHRpb25zKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSG92ZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIEhvdmVyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5sYXlIaW50OiAoKSA9PiAoLyogYmluZGluZyAqLyBJbmxheUhpbnQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBJbmxheUhpbnRLaW5kOiAoKSA9PiAoLyogYmluZGluZyAqLyBJbmxheUhpbnRLaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5sYXlIaW50TGFiZWxQYXJ0OiAoKSA9PiAoLyogYmluZGluZyAqLyBJbmxheUhpbnRMYWJlbFBhcnQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBJbmxpbmVWYWx1ZUNvbnRleHQ6ICgpID0+ICgvKiBiaW5kaW5nICovIElubGluZVZhbHVlQ29udGV4dCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIElubGluZVZhbHVlVGV4dDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5saW5lVmFsdWVUZXh0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEluc2VydFJlcGxhY2VFZGl0OiAoKSA9PiAoLyogYmluZGluZyAqLyBJbnNlcnRSZXBsYWNlRWRpdCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEluc2VydFRleHRGb3JtYXQ6ICgpID0+ICgvKiBiaW5kaW5nICovIEluc2VydFRleHRGb3JtYXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBJbnNlcnRUZXh0TW9kZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5zZXJ0VGV4dE1vZGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBMb2NhdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTG9jYXRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBMb2NhdGlvbkxpbms6ICgpID0+ICgvKiBiaW5kaW5nICovIExvY2F0aW9uTGluayksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIE1hcmtlZFN0cmluZzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTWFya2VkU3RyaW5nKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgTWFya3VwQ29udGVudDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTWFya3VwQ29udGVudCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIE1hcmt1cEtpbmQ6ICgpID0+ICgvKiBiaW5kaW5nICovIE1hcmt1cEtpbmQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFBhcmFtZXRlckluZm9ybWF0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBQYXJhbWV0ZXJJbmZvcm1hdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFBvc2l0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBQb3NpdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFJhbmdlOiAoKSA9PiAoLyogYmluZGluZyAqLyBSYW5nZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFJlbmFtZUZpbGU6ICgpID0+ICgvKiBiaW5kaW5nICovIFJlbmFtZUZpbGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBTZWxlY3Rpb25SYW5nZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU2VsZWN0aW9uUmFuZ2UpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzOiAoKSA9PiAoLyogYmluZGluZyAqLyBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2VtYW50aWNUb2tlblR5cGVzOiAoKSA9PiAoLyogYmluZGluZyAqLyBTZW1hbnRpY1Rva2VuVHlwZXMpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBTZW1hbnRpY1Rva2VuczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU2VtYW50aWNUb2tlbnMpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBTaWduYXR1cmVJbmZvcm1hdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU2lnbmF0dXJlSW5mb3JtYXRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBTeW1ib2xJbmZvcm1hdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU3ltYm9sSW5mb3JtYXRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBTeW1ib2xLaW5kOiAoKSA9PiAoLyogYmluZGluZyAqLyBTeW1ib2xLaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU3ltYm9sVGFnOiAoKSA9PiAoLyogYmluZGluZyAqLyBTeW1ib2xUYWcpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBUZXh0RG9jdW1lbnQ6ICgpID0+ICgvKiBiaW5kaW5nICovIFRleHREb2N1bWVudCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFRleHREb2N1bWVudEVkaXQ6ICgpID0+ICgvKiBiaW5kaW5nICovIFRleHREb2N1bWVudEVkaXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBUZXh0RG9jdW1lbnRJZGVudGlmaWVyOiAoKSA9PiAoLyogYmluZGluZyAqLyBUZXh0RG9jdW1lbnRJZGVudGlmaWVyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgVGV4dERvY3VtZW50SXRlbTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVGV4dERvY3VtZW50SXRlbSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFRleHRFZGl0OiAoKSA9PiAoLyogYmluZGluZyAqLyBUZXh0RWRpdCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFVSSTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVVJJKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFdvcmtzcGFjZUNoYW5nZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gV29ya3NwYWNlQ2hhbmdlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgV29ya3NwYWNlRWRpdDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gV29ya3NwYWNlRWRpdCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFdvcmtzcGFjZUZvbGRlcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gV29ya3NwYWNlRm9sZGVyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgV29ya3NwYWNlU3ltYm9sOiAoKSA9PiAoLyogYmluZGluZyAqLyBXb3Jrc3BhY2VTeW1ib2wpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBpbnRlZ2VyOiAoKSA9PiAoLyogYmluZGluZyAqLyBpbnRlZ2VyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgdWludGVnZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIHVpbnRlZ2VyKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbnZhciBEb2N1bWVudFVyaTtcbihmdW5jdGlvbiAoRG9jdW1lbnRVcmkpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbiAgICB9XG4gICAgRG9jdW1lbnRVcmkuaXMgPSBpcztcbn0pKERvY3VtZW50VXJpIHx8IChEb2N1bWVudFVyaSA9IHt9KSk7XG52YXIgVVJJO1xuKGZ1bmN0aW9uIChVUkkpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbiAgICB9XG4gICAgVVJJLmlzID0gaXM7XG59KShVUkkgfHwgKFVSSSA9IHt9KSk7XG52YXIgaW50ZWdlcjtcbihmdW5jdGlvbiAoaW50ZWdlcikge1xuICAgIGludGVnZXIuTUlOX1ZBTFVFID0gLTIxNDc0ODM2NDg7XG4gICAgaW50ZWdlci5NQVhfVkFMVUUgPSAyMTQ3NDgzNjQ3O1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGludGVnZXIuTUlOX1ZBTFVFIDw9IHZhbHVlICYmIHZhbHVlIDw9IGludGVnZXIuTUFYX1ZBTFVFO1xuICAgIH1cbiAgICBpbnRlZ2VyLmlzID0gaXM7XG59KShpbnRlZ2VyIHx8IChpbnRlZ2VyID0ge30pKTtcbnZhciB1aW50ZWdlcjtcbihmdW5jdGlvbiAodWludGVnZXIpIHtcbiAgICB1aW50ZWdlci5NSU5fVkFMVUUgPSAwO1xuICAgIHVpbnRlZ2VyLk1BWF9WQUxVRSA9IDIxNDc0ODM2NDc7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdWludGVnZXIuTUlOX1ZBTFVFIDw9IHZhbHVlICYmIHZhbHVlIDw9IHVpbnRlZ2VyLk1BWF9WQUxVRTtcbiAgICB9XG4gICAgdWludGVnZXIuaXMgPSBpcztcbn0pKHVpbnRlZ2VyIHx8ICh1aW50ZWdlciA9IHt9KSk7XG4vKipcbiAqIFRoZSBQb3NpdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBQb3NpdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBQb3NpdGlvbjtcbihmdW5jdGlvbiAoUG9zaXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFBvc2l0aW9uIGxpdGVyYWwgZnJvbSB0aGUgZ2l2ZW4gbGluZSBhbmQgY2hhcmFjdGVyLlxuICAgICAqIEBwYXJhbSBsaW5lIFRoZSBwb3NpdGlvbidzIGxpbmUuXG4gICAgICogQHBhcmFtIGNoYXJhY3RlciBUaGUgcG9zaXRpb24ncyBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxpbmUsIGNoYXJhY3Rlcikge1xuICAgICAgICBpZiAobGluZSA9PT0gTnVtYmVyLk1BWF9WQUxVRSkge1xuICAgICAgICAgICAgbGluZSA9IHVpbnRlZ2VyLk1BWF9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhcmFjdGVyID09PSBOdW1iZXIuTUFYX1ZBTFVFKSB7XG4gICAgICAgICAgICBjaGFyYWN0ZXIgPSB1aW50ZWdlci5NQVhfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbGluZTogbGluZSwgY2hhcmFjdGVyOiBjaGFyYWN0ZXIgfTtcbiAgICB9XG4gICAgUG9zaXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgUG9zaXRpb259IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMudWludGVnZXIoY2FuZGlkYXRlLmxpbmUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5jaGFyYWN0ZXIpO1xuICAgIH1cbiAgICBQb3NpdGlvbi5pcyA9IGlzO1xufSkoUG9zaXRpb24gfHwgKFBvc2l0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIFJhbmdlIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFJhbmdlfSBsaXRlcmFscy5cbiAqL1xudmFyIFJhbmdlO1xuKGZ1bmN0aW9uIChSYW5nZSkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShvbmUsIHR3bywgdGhyZWUsIGZvdXIpIHtcbiAgICAgICAgaWYgKElzLnVpbnRlZ2VyKG9uZSkgJiYgSXMudWludGVnZXIodHdvKSAmJiBJcy51aW50ZWdlcih0aHJlZSkgJiYgSXMudWludGVnZXIoZm91cikpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBQb3NpdGlvbi5jcmVhdGUob25lLCB0d28pLCBlbmQ6IFBvc2l0aW9uLmNyZWF0ZSh0aHJlZSwgZm91cikgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChQb3NpdGlvbi5pcyhvbmUpICYmIFBvc2l0aW9uLmlzKHR3bykpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBvbmUsIGVuZDogdHdvIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSYW5nZSNjcmVhdGUgY2FsbGVkIHdpdGggaW52YWxpZCBhcmd1bWVudHNbXCIuY29uY2F0KG9uZSwgXCIsIFwiKS5jb25jYXQodHdvLCBcIiwgXCIpLmNvbmNhdCh0aHJlZSwgXCIsIFwiKS5jb25jYXQoZm91ciwgXCJdXCIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBSYW5nZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBSYW5nZX0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBQb3NpdGlvbi5pcyhjYW5kaWRhdGUuc3RhcnQpICYmIFBvc2l0aW9uLmlzKGNhbmRpZGF0ZS5lbmQpO1xuICAgIH1cbiAgICBSYW5nZS5pcyA9IGlzO1xufSkoUmFuZ2UgfHwgKFJhbmdlID0ge30pKTtcbi8qKlxuICogVGhlIExvY2F0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIExvY2F0aW9ufSBsaXRlcmFscy5cbiAqL1xudmFyIExvY2F0aW9uO1xuKGZ1bmN0aW9uIChMb2NhdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBMb2NhdGlvbiBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGxvY2F0aW9uJ3MgdXJpLlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgbG9jYXRpb24ncyByYW5nZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCByYW5nZSkge1xuICAgICAgICByZXR1cm4geyB1cmk6IHVyaSwgcmFuZ2U6IHJhbmdlIH07XG4gICAgfVxuICAgIExvY2F0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIExvY2F0aW9ufSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSB8fCBJcy51bmRlZmluZWQoY2FuZGlkYXRlLnVyaSkpO1xuICAgIH1cbiAgICBMb2NhdGlvbi5pcyA9IGlzO1xufSkoTG9jYXRpb24gfHwgKExvY2F0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIExvY2F0aW9uTGluayBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBMb2NhdGlvbkxpbmt9IGxpdGVyYWxzLlxuICovXG52YXIgTG9jYXRpb25MaW5rO1xuKGZ1bmN0aW9uIChMb2NhdGlvbkxpbmspIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTG9jYXRpb25MaW5rIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHRhcmdldFVyaSBUaGUgZGVmaW5pdGlvbidzIHVyaS5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0UmFuZ2UgVGhlIGZ1bGwgcmFuZ2Ugb2YgdGhlIGRlZmluaXRpb24uXG4gICAgICogQHBhcmFtIHRhcmdldFNlbGVjdGlvblJhbmdlIFRoZSBzcGFuIG9mIHRoZSBzeW1ib2wgZGVmaW5pdGlvbiBhdCB0aGUgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSBvcmlnaW5TZWxlY3Rpb25SYW5nZSBUaGUgc3BhbiBvZiB0aGUgc3ltYm9sIGJlaW5nIGRlZmluZWQgaW4gdGhlIG9yaWdpbmF0aW5nIHNvdXJjZSBmaWxlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0YXJnZXRVcmksIHRhcmdldFJhbmdlLCB0YXJnZXRTZWxlY3Rpb25SYW5nZSwgb3JpZ2luU2VsZWN0aW9uUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHsgdGFyZ2V0VXJpOiB0YXJnZXRVcmksIHRhcmdldFJhbmdlOiB0YXJnZXRSYW5nZSwgdGFyZ2V0U2VsZWN0aW9uUmFuZ2U6IHRhcmdldFNlbGVjdGlvblJhbmdlLCBvcmlnaW5TZWxlY3Rpb25SYW5nZTogb3JpZ2luU2VsZWN0aW9uUmFuZ2UgfTtcbiAgICB9XG4gICAgTG9jYXRpb25MaW5rLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIExvY2F0aW9uTGlua30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUudGFyZ2V0UmFuZ2UpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGFyZ2V0VXJpKVxuICAgICAgICAgICAgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnRhcmdldFNlbGVjdGlvblJhbmdlKVxuICAgICAgICAgICAgJiYgKFJhbmdlLmlzKGNhbmRpZGF0ZS5vcmlnaW5TZWxlY3Rpb25SYW5nZSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5vcmlnaW5TZWxlY3Rpb25SYW5nZSkpO1xuICAgIH1cbiAgICBMb2NhdGlvbkxpbmsuaXMgPSBpcztcbn0pKExvY2F0aW9uTGluayB8fCAoTG9jYXRpb25MaW5rID0ge30pKTtcbi8qKlxuICogVGhlIENvbG9yIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIENvbG9yfSBsaXRlcmFscy5cbiAqL1xudmFyIENvbG9yO1xuKGZ1bmN0aW9uIChDb2xvcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29sb3IgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlZDogcmVkLFxuICAgICAgICAgICAgZ3JlZW46IGdyZWVuLFxuICAgICAgICAgICAgYmx1ZTogYmx1ZSxcbiAgICAgICAgICAgIGFscGhhOiBhbHBoYSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgQ29sb3IuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgQ29sb3J9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMubnVtYmVyUmFuZ2UoY2FuZGlkYXRlLnJlZCwgMCwgMSlcbiAgICAgICAgICAgICYmIElzLm51bWJlclJhbmdlKGNhbmRpZGF0ZS5ncmVlbiwgMCwgMSlcbiAgICAgICAgICAgICYmIElzLm51bWJlclJhbmdlKGNhbmRpZGF0ZS5ibHVlLCAwLCAxKVxuICAgICAgICAgICAgJiYgSXMubnVtYmVyUmFuZ2UoY2FuZGlkYXRlLmFscGhhLCAwLCAxKTtcbiAgICB9XG4gICAgQ29sb3IuaXMgPSBpcztcbn0pKENvbG9yIHx8IChDb2xvciA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb2xvckluZm9ybWF0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIENvbG9ySW5mb3JtYXRpb259IGxpdGVyYWxzLlxuICovXG52YXIgQ29sb3JJbmZvcm1hdGlvbjtcbihmdW5jdGlvbiAoQ29sb3JJbmZvcm1hdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29sb3JJbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgQ29sb3JJbmZvcm1hdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb2xvckluZm9ybWF0aW9ufSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgQ29sb3IuaXMoY2FuZGlkYXRlLmNvbG9yKTtcbiAgICB9XG4gICAgQ29sb3JJbmZvcm1hdGlvbi5pcyA9IGlzO1xufSkoQ29sb3JJbmZvcm1hdGlvbiB8fCAoQ29sb3JJbmZvcm1hdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb2xvciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb2xvclByZXNlbnRhdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBDb2xvclByZXNlbnRhdGlvbjtcbihmdW5jdGlvbiAoQ29sb3JQcmVzZW50YXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbG9ySW5mb3JtYXRpb24gbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUobGFiZWwsIHRleHRFZGl0LCBhZGRpdGlvbmFsVGV4dEVkaXRzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYWJlbDogbGFiZWwsXG4gICAgICAgICAgICB0ZXh0RWRpdDogdGV4dEVkaXQsXG4gICAgICAgICAgICBhZGRpdGlvbmFsVGV4dEVkaXRzOiBhZGRpdGlvbmFsVGV4dEVkaXRzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBDb2xvclByZXNlbnRhdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb2xvckluZm9ybWF0aW9ufSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUubGFiZWwpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS50ZXh0RWRpdCkgfHwgVGV4dEVkaXQuaXMoY2FuZGlkYXRlKSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmFkZGl0aW9uYWxUZXh0RWRpdHMpIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLmFkZGl0aW9uYWxUZXh0RWRpdHMsIFRleHRFZGl0LmlzKSk7XG4gICAgfVxuICAgIENvbG9yUHJlc2VudGF0aW9uLmlzID0gaXM7XG59KShDb2xvclByZXNlbnRhdGlvbiB8fCAoQ29sb3JQcmVzZW50YXRpb24gPSB7fSkpO1xuLyoqXG4gKiBBIHNldCBvZiBwcmVkZWZpbmVkIHJhbmdlIGtpbmRzLlxuICovXG52YXIgRm9sZGluZ1JhbmdlS2luZDtcbihmdW5jdGlvbiAoRm9sZGluZ1JhbmdlS2luZCkge1xuICAgIC8qKlxuICAgICAqIEZvbGRpbmcgcmFuZ2UgZm9yIGEgY29tbWVudFxuICAgICAqL1xuICAgIEZvbGRpbmdSYW5nZUtpbmQuQ29tbWVudCA9ICdjb21tZW50JztcbiAgICAvKipcbiAgICAgKiBGb2xkaW5nIHJhbmdlIGZvciBhbiBpbXBvcnQgb3IgaW5jbHVkZVxuICAgICAqL1xuICAgIEZvbGRpbmdSYW5nZUtpbmQuSW1wb3J0cyA9ICdpbXBvcnRzJztcbiAgICAvKipcbiAgICAgKiBGb2xkaW5nIHJhbmdlIGZvciBhIHJlZ2lvbiAoZS5nLiBgI3JlZ2lvbmApXG4gICAgICovXG4gICAgRm9sZGluZ1JhbmdlS2luZC5SZWdpb24gPSAncmVnaW9uJztcbn0pKEZvbGRpbmdSYW5nZUtpbmQgfHwgKEZvbGRpbmdSYW5nZUtpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZm9sZGluZyByYW5nZSBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBGb2xkaW5nUmFuZ2V9IGxpdGVyYWxzLlxuICovXG52YXIgRm9sZGluZ1JhbmdlO1xuKGZ1bmN0aW9uIChGb2xkaW5nUmFuZ2UpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEZvbGRpbmdSYW5nZSBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShzdGFydExpbmUsIGVuZExpbmUsIHN0YXJ0Q2hhcmFjdGVyLCBlbmRDaGFyYWN0ZXIsIGtpbmQsIGNvbGxhcHNlZFRleHQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHN0YXJ0TGluZTogc3RhcnRMaW5lLFxuICAgICAgICAgICAgZW5kTGluZTogZW5kTGluZVxuICAgICAgICB9O1xuICAgICAgICBpZiAoSXMuZGVmaW5lZChzdGFydENoYXJhY3RlcikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydENoYXJhY3RlciA9IHN0YXJ0Q2hhcmFjdGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGVuZENoYXJhY3RlcikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5lbmRDaGFyYWN0ZXIgPSBlbmRDaGFyYWN0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQoa2luZCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0ga2luZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChjb2xsYXBzZWRUZXh0KSkge1xuICAgICAgICAgICAgcmVzdWx0LmNvbGxhcHNlZFRleHQgPSBjb2xsYXBzZWRUZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIEZvbGRpbmdSYW5nZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBGb2xkaW5nUmFuZ2V9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMudWludGVnZXIoY2FuZGlkYXRlLnN0YXJ0TGluZSkgJiYgSXMudWludGVnZXIoY2FuZGlkYXRlLnN0YXJ0TGluZSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLnN0YXJ0Q2hhcmFjdGVyKSB8fCBJcy51aW50ZWdlcihjYW5kaWRhdGUuc3RhcnRDaGFyYWN0ZXIpKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuZW5kQ2hhcmFjdGVyKSB8fCBJcy51aW50ZWdlcihjYW5kaWRhdGUuZW5kQ2hhcmFjdGVyKSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmtpbmQpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUua2luZCkpO1xuICAgIH1cbiAgICBGb2xkaW5nUmFuZ2UuaXMgPSBpcztcbn0pKEZvbGRpbmdSYW5nZSB8fCAoRm9sZGluZ1JhbmdlID0ge30pKTtcbi8qKlxuICogVGhlIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uO1xuKGZ1bmN0aW9uIChEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxvY2F0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgICAgIH07XG4gICAgfVxuICAgIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBMb2NhdGlvbi5pcyhjYW5kaWRhdGUubG9jYXRpb24pICYmIElzLnN0cmluZyhjYW5kaWRhdGUubWVzc2FnZSk7XG4gICAgfVxuICAgIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24uaXMgPSBpcztcbn0pKERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24gfHwgKERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgZGlhZ25vc3RpYydzIHNldmVyaXR5LlxuICovXG52YXIgRGlhZ25vc3RpY1NldmVyaXR5O1xuKGZ1bmN0aW9uIChEaWFnbm9zdGljU2V2ZXJpdHkpIHtcbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIGFuIGVycm9yLlxuICAgICAqL1xuICAgIERpYWdub3N0aWNTZXZlcml0eS5FcnJvciA9IDE7XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyBhIHdhcm5pbmcuXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1NldmVyaXR5Lldhcm5pbmcgPSAyO1xuICAgIC8qKlxuICAgICAqIFJlcG9ydHMgYW4gaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1NldmVyaXR5LkluZm9ybWF0aW9uID0gMztcbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIGEgaGludC5cbiAgICAgKi9cbiAgICBEaWFnbm9zdGljU2V2ZXJpdHkuSGludCA9IDQ7XG59KShEaWFnbm9zdGljU2V2ZXJpdHkgfHwgKERpYWdub3N0aWNTZXZlcml0eSA9IHt9KSk7XG4vKipcbiAqIFRoZSBkaWFnbm9zdGljIHRhZ3MuXG4gKlxuICogQHNpbmNlIDMuMTUuMFxuICovXG52YXIgRGlhZ25vc3RpY1RhZztcbihmdW5jdGlvbiAoRGlhZ25vc3RpY1RhZykge1xuICAgIC8qKlxuICAgICAqIFVudXNlZCBvciB1bm5lY2Vzc2FyeSBjb2RlLlxuICAgICAqXG4gICAgICogQ2xpZW50cyBhcmUgYWxsb3dlZCB0byByZW5kZXIgZGlhZ25vc3RpY3Mgd2l0aCB0aGlzIHRhZyBmYWRlZCBvdXQgaW5zdGVhZCBvZiBoYXZpbmdcbiAgICAgKiBhbiBlcnJvciBzcXVpZ2dsZS5cbiAgICAgKi9cbiAgICBEaWFnbm9zdGljVGFnLlVubmVjZXNzYXJ5ID0gMTtcbiAgICAvKipcbiAgICAgKiBEZXByZWNhdGVkIG9yIG9ic29sZXRlIGNvZGUuXG4gICAgICpcbiAgICAgKiBDbGllbnRzIGFyZSBhbGxvd2VkIHRvIHJlbmRlcmVkIGRpYWdub3N0aWNzIHdpdGggdGhpcyB0YWcgc3RyaWtlIHRocm91Z2guXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1RhZy5EZXByZWNhdGVkID0gMjtcbn0pKERpYWdub3N0aWNUYWcgfHwgKERpYWdub3N0aWNUYWcgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29kZURlc2NyaXB0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoIGRlc2NyaXB0aW9ucyBmb3IgZGlhZ25vc3RpYyBjb2Rlcy5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBDb2RlRGVzY3JpcHRpb247XG4oZnVuY3Rpb24gKENvZGVEZXNjcmlwdGlvbikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmhyZWYpO1xuICAgIH1cbiAgICBDb2RlRGVzY3JpcHRpb24uaXMgPSBpcztcbn0pKENvZGVEZXNjcmlwdGlvbiB8fCAoQ29kZURlc2NyaXB0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIERpYWdub3N0aWMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgRGlhZ25vc3RpY30gbGl0ZXJhbHMuXG4gKi9cbnZhciBEaWFnbm9zdGljO1xuKGZ1bmN0aW9uIChEaWFnbm9zdGljKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBEaWFnbm9zdGljIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBtZXNzYWdlLCBzZXZlcml0eSwgY29kZSwgc291cmNlLCByZWxhdGVkSW5mb3JtYXRpb24pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgcmFuZ2U6IHJhbmdlLCBtZXNzYWdlOiBtZXNzYWdlIH07XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKHNldmVyaXR5KSkge1xuICAgICAgICAgICAgcmVzdWx0LnNldmVyaXR5ID0gc2V2ZXJpdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQoY29kZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jb2RlID0gY29kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChzb3VyY2UpKSB7XG4gICAgICAgICAgICByZXN1bHQuc291cmNlID0gc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKHJlbGF0ZWRJbmZvcm1hdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5yZWxhdGVkSW5mb3JtYXRpb24gPSByZWxhdGVkSW5mb3JtYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRGlhZ25vc3RpYy5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBEaWFnbm9zdGljfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSlcbiAgICAgICAgICAgICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSlcbiAgICAgICAgICAgICYmIElzLnN0cmluZyhjYW5kaWRhdGUubWVzc2FnZSlcbiAgICAgICAgICAgICYmIChJcy5udW1iZXIoY2FuZGlkYXRlLnNldmVyaXR5KSB8fCBJcy51bmRlZmluZWQoY2FuZGlkYXRlLnNldmVyaXR5KSlcbiAgICAgICAgICAgICYmIChJcy5pbnRlZ2VyKGNhbmRpZGF0ZS5jb2RlKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmNvZGUpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUuY29kZSkpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5jb2RlRGVzY3JpcHRpb24pIHx8IChJcy5zdHJpbmcoKF9hID0gY2FuZGlkYXRlLmNvZGVEZXNjcmlwdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhyZWYpKSlcbiAgICAgICAgICAgICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLnNvdXJjZSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5zb3VyY2UpKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUucmVsYXRlZEluZm9ybWF0aW9uKSB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5yZWxhdGVkSW5mb3JtYXRpb24sIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24uaXMpKTtcbiAgICB9XG4gICAgRGlhZ25vc3RpYy5pcyA9IGlzO1xufSkoRGlhZ25vc3RpYyB8fCAoRGlhZ25vc3RpYyA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb21tYW5kIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIENvbW1hbmR9IGxpdGVyYWxzLlxuICovXG52YXIgQ29tbWFuZDtcbihmdW5jdGlvbiAoQ29tbWFuZCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29tbWFuZCBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0aXRsZSwgY29tbWFuZCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0geyB0aXRsZTogdGl0bGUsIGNvbW1hbmQ6IGNvbW1hbmQgfTtcbiAgICAgICAgaWYgKElzLmRlZmluZWQoYXJncykgJiYgYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQuYXJndW1lbnRzID0gYXJncztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb21tYW5kLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIENvbW1hbmR9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS50aXRsZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5jb21tYW5kKTtcbiAgICB9XG4gICAgQ29tbWFuZC5pcyA9IGlzO1xufSkoQ29tbWFuZCB8fCAoQ29tbWFuZCA9IHt9KSk7XG4vKipcbiAqIFRoZSBUZXh0RWRpdCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSByZXBsYWNlLFxuICogaW5zZXJ0IGFuZCBkZWxldGUgZWRpdHMgbW9yZSBlYXNpbHkuXG4gKi9cbnZhciBUZXh0RWRpdDtcbihmdW5jdGlvbiAoVGV4dEVkaXQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcmVwbGFjZSB0ZXh0IGVkaXQuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0ZXh0IHRvIGJlIHJlcGxhY2VkLlxuICAgICAqIEBwYXJhbSBuZXdUZXh0IFRoZSBuZXcgdGV4dC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBsYWNlKHJhbmdlLCBuZXdUZXh0KSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiByYW5nZSwgbmV3VGV4dDogbmV3VGV4dCB9O1xuICAgIH1cbiAgICBUZXh0RWRpdC5yZXBsYWNlID0gcmVwbGFjZTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc2VydCB0ZXh0IGVkaXQuXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIFRoZSBwb3NpdGlvbiB0byBpbnNlcnQgdGhlIHRleHQgYXQuXG4gICAgICogQHBhcmFtIG5ld1RleHQgVGhlIHRleHQgdG8gYmUgaW5zZXJ0ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0KSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiB7IHN0YXJ0OiBwb3NpdGlvbiwgZW5kOiBwb3NpdGlvbiB9LCBuZXdUZXh0OiBuZXdUZXh0IH07XG4gICAgfVxuICAgIFRleHRFZGl0Lmluc2VydCA9IGluc2VydDtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGVsZXRlIHRleHQgZWRpdC5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIG9mIHRleHQgdG8gYmUgZGVsZXRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWwocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLCBuZXdUZXh0OiAnJyB9O1xuICAgIH1cbiAgICBUZXh0RWRpdC5kZWwgPSBkZWw7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm5ld1RleHQpXG4gICAgICAgICAgICAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpO1xuICAgIH1cbiAgICBUZXh0RWRpdC5pcyA9IGlzO1xufSkoVGV4dEVkaXQgfHwgKFRleHRFZGl0ID0ge30pKTtcbnZhciBDaGFuZ2VBbm5vdGF0aW9uO1xuKGZ1bmN0aW9uIChDaGFuZ2VBbm5vdGF0aW9uKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsLCBuZWVkc0NvbmZpcm1hdGlvbiwgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgbGFiZWw6IGxhYmVsIH07XG4gICAgICAgIGlmIChuZWVkc0NvbmZpcm1hdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQubmVlZHNDb25maXJtYXRpb24gPSBuZWVkc0NvbmZpcm1hdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgQ2hhbmdlQW5ub3RhdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUubGFiZWwpICYmXG4gICAgICAgICAgICAoSXMuYm9vbGVhbihjYW5kaWRhdGUubmVlZHNDb25maXJtYXRpb24pIHx8IGNhbmRpZGF0ZS5uZWVkc0NvbmZpcm1hdGlvbiA9PT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgKElzLnN0cmluZyhjYW5kaWRhdGUuZGVzY3JpcHRpb24pIHx8IGNhbmRpZGF0ZS5kZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgQ2hhbmdlQW5ub3RhdGlvbi5pcyA9IGlzO1xufSkoQ2hhbmdlQW5ub3RhdGlvbiB8fCAoQ2hhbmdlQW5ub3RhdGlvbiA9IHt9KSk7XG52YXIgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXI7XG4oZnVuY3Rpb24gKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuc3RyaW5nKGNhbmRpZGF0ZSk7XG4gICAgfVxuICAgIENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzID0gaXM7XG59KShDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllciB8fCAoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIgPSB7fSkpO1xudmFyIEFubm90YXRlZFRleHRFZGl0O1xuKGZ1bmN0aW9uIChBbm5vdGF0ZWRUZXh0RWRpdCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYW5ub3RhdGVkIHJlcGxhY2UgdGV4dCBlZGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0ZXh0IHRvIGJlIHJlcGxhY2VkLlxuICAgICAqIEBwYXJhbSBuZXdUZXh0IFRoZSBuZXcgdGV4dC5cbiAgICAgKiBAcGFyYW0gYW5ub3RhdGlvbiBUaGUgYW5ub3RhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBsYWNlKHJhbmdlLCBuZXdUZXh0LCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiByYW5nZSwgbmV3VGV4dDogbmV3VGV4dCwgYW5ub3RhdGlvbklkOiBhbm5vdGF0aW9uIH07XG4gICAgfVxuICAgIEFubm90YXRlZFRleHRFZGl0LnJlcGxhY2UgPSByZXBsYWNlO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYW5ub3RhdGVkIGluc2VydCB0ZXh0IGVkaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIHRvIGluc2VydCB0aGUgdGV4dCBhdC5cbiAgICAgKiBAcGFyYW0gbmV3VGV4dCBUaGUgdGV4dCB0byBiZSBpbnNlcnRlZC5cbiAgICAgKiBAcGFyYW0gYW5ub3RhdGlvbiBUaGUgYW5ub3RhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNlcnQocG9zaXRpb24sIG5ld1RleHQsIGFubm90YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHsgc3RhcnQ6IHBvc2l0aW9uLCBlbmQ6IHBvc2l0aW9uIH0sIG5ld1RleHQ6IG5ld1RleHQsIGFubm90YXRpb25JZDogYW5ub3RhdGlvbiB9O1xuICAgIH1cbiAgICBBbm5vdGF0ZWRUZXh0RWRpdC5pbnNlcnQgPSBpbnNlcnQ7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhbm5vdGF0ZWQgZGVsZXRlIHRleHQgZWRpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGV4dCB0byBiZSBkZWxldGVkLlxuICAgICAqIEBwYXJhbSBhbm5vdGF0aW9uIFRoZSBhbm5vdGF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlbChyYW5nZSwgYW5ub3RhdGlvbikge1xuICAgICAgICByZXR1cm4geyByYW5nZTogcmFuZ2UsIG5ld1RleHQ6ICcnLCBhbm5vdGF0aW9uSWQ6IGFubm90YXRpb24gfTtcbiAgICB9XG4gICAgQW5ub3RhdGVkVGV4dEVkaXQuZGVsID0gZGVsO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIFRleHRFZGl0LmlzKGNhbmRpZGF0ZSkgJiYgKENoYW5nZUFubm90YXRpb24uaXMoY2FuZGlkYXRlLmFubm90YXRpb25JZCkgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoY2FuZGlkYXRlLmFubm90YXRpb25JZCkpO1xuICAgIH1cbiAgICBBbm5vdGF0ZWRUZXh0RWRpdC5pcyA9IGlzO1xufSkoQW5ub3RhdGVkVGV4dEVkaXQgfHwgKEFubm90YXRlZFRleHRFZGl0ID0ge30pKTtcbi8qKlxuICogVGhlIFRleHREb2N1bWVudEVkaXQgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGVcbiAqIGFuIGVkaXQgdGhhdCBtYW5pcHVsYXRlcyBhIHRleHQgZG9jdW1lbnQuXG4gKi9cbnZhciBUZXh0RG9jdW1lbnRFZGl0O1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRFZGl0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgVGV4dERvY3VtZW50RWRpdGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodGV4dERvY3VtZW50LCBlZGl0cykge1xuICAgICAgICByZXR1cm4geyB0ZXh0RG9jdW1lbnQ6IHRleHREb2N1bWVudCwgZWRpdHM6IGVkaXRzIH07XG4gICAgfVxuICAgIFRleHREb2N1bWVudEVkaXQuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKVxuICAgICAgICAgICAgJiYgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmlzKGNhbmRpZGF0ZS50ZXh0RG9jdW1lbnQpXG4gICAgICAgICAgICAmJiBBcnJheS5pc0FycmF5KGNhbmRpZGF0ZS5lZGl0cyk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudEVkaXQuaXMgPSBpcztcbn0pKFRleHREb2N1bWVudEVkaXQgfHwgKFRleHREb2N1bWVudEVkaXQgPSB7fSkpO1xudmFyIENyZWF0ZUZpbGU7XG4oZnVuY3Rpb24gKENyZWF0ZUZpbGUpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCBvcHRpb25zLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBraW5kOiAnY3JlYXRlJyxcbiAgICAgICAgICAgIHVyaTogdXJpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgKG9wdGlvbnMub3ZlcndyaXRlICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5pZ25vcmVJZkV4aXN0cyAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgcmVzdWx0Lm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbm5vdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hbm5vdGF0aW9uSWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIENyZWF0ZUZpbGUuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBjYW5kaWRhdGUua2luZCA9PT0gJ2NyZWF0ZScgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIChjYW5kaWRhdGUub3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAoKGNhbmRpZGF0ZS5vcHRpb25zLm92ZXJ3cml0ZSA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMub3ZlcndyaXRlKSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmRXhpc3RzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZkV4aXN0cykpKSkgJiYgKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQgPT09IHVuZGVmaW5lZCB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSk7XG4gICAgfVxuICAgIENyZWF0ZUZpbGUuaXMgPSBpcztcbn0pKENyZWF0ZUZpbGUgfHwgKENyZWF0ZUZpbGUgPSB7fSkpO1xudmFyIFJlbmFtZUZpbGU7XG4oZnVuY3Rpb24gKFJlbmFtZUZpbGUpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUob2xkVXJpLCBuZXdVcmksIG9wdGlvbnMsIGFubm90YXRpb24pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGtpbmQ6ICdyZW5hbWUnLFxuICAgICAgICAgICAgb2xkVXJpOiBvbGRVcmksXG4gICAgICAgICAgICBuZXdVcmk6IG5ld1VyaVxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIChvcHRpb25zLm92ZXJ3cml0ZSAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuaWdub3JlSWZFeGlzdHMgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5ub3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQuYW5ub3RhdGlvbklkID0gYW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBSZW5hbWVGaWxlLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgY2FuZGlkYXRlLmtpbmQgPT09ICdyZW5hbWUnICYmIElzLnN0cmluZyhjYW5kaWRhdGUub2xkVXJpKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm5ld1VyaSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICgoY2FuZGlkYXRlLm9wdGlvbnMub3ZlcndyaXRlID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5vdmVyd3JpdGUpKSAmJiAoY2FuZGlkYXRlLm9wdGlvbnMuaWdub3JlSWZFeGlzdHMgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmRXhpc3RzKSkpKSAmJiAoY2FuZGlkYXRlLmFubm90YXRpb25JZCA9PT0gdW5kZWZpbmVkIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpKTtcbiAgICB9XG4gICAgUmVuYW1lRmlsZS5pcyA9IGlzO1xufSkoUmVuYW1lRmlsZSB8fCAoUmVuYW1lRmlsZSA9IHt9KSk7XG52YXIgRGVsZXRlRmlsZTtcbihmdW5jdGlvbiAoRGVsZXRlRmlsZSkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIG9wdGlvbnMsIGFubm90YXRpb24pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGtpbmQ6ICdkZWxldGUnLFxuICAgICAgICAgICAgdXJpOiB1cmlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiAob3B0aW9ucy5yZWN1cnNpdmUgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmlnbm9yZUlmTm90RXhpc3RzICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICByZXN1bHQub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFubm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmFubm90YXRpb25JZCA9IGFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRGVsZXRlRmlsZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGNhbmRpZGF0ZS5raW5kID09PSAnZGVsZXRlJyAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICgoY2FuZGlkYXRlLm9wdGlvbnMucmVjdXJzaXZlID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5yZWN1cnNpdmUpKSAmJiAoY2FuZGlkYXRlLm9wdGlvbnMuaWdub3JlSWZOb3RFeGlzdHMgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmTm90RXhpc3RzKSkpKSAmJiAoY2FuZGlkYXRlLmFubm90YXRpb25JZCA9PT0gdW5kZWZpbmVkIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpKTtcbiAgICB9XG4gICAgRGVsZXRlRmlsZS5pcyA9IGlzO1xufSkoRGVsZXRlRmlsZSB8fCAoRGVsZXRlRmlsZSA9IHt9KSk7XG52YXIgV29ya3NwYWNlRWRpdDtcbihmdW5jdGlvbiAoV29ya3NwYWNlRWRpdCkge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5jaGFuZ2VzICE9PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLmRvY3VtZW50Q2hhbmdlcyAhPT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCB8fCBjYW5kaWRhdGUuZG9jdW1lbnRDaGFuZ2VzLmV2ZXJ5KGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoSXMuc3RyaW5nKGNoYW5nZS5raW5kKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ3JlYXRlRmlsZS5pcyhjaGFuZ2UpIHx8IFJlbmFtZUZpbGUuaXMoY2hhbmdlKSB8fCBEZWxldGVGaWxlLmlzKGNoYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVGV4dERvY3VtZW50RWRpdC5pcyhjaGFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICB9XG4gICAgV29ya3NwYWNlRWRpdC5pcyA9IGlzO1xufSkoV29ya3NwYWNlRWRpdCB8fCAoV29ya3NwYWNlRWRpdCA9IHt9KSk7XG52YXIgVGV4dEVkaXRDaGFuZ2VJbXBsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRleHRFZGl0Q2hhbmdlSW1wbChlZGl0cywgY2hhbmdlQW5ub3RhdGlvbnMpIHtcbiAgICAgICAgdGhpcy5lZGl0cyA9IGVkaXRzO1xuICAgICAgICB0aGlzLmNoYW5nZUFubm90YXRpb25zID0gY2hhbmdlQW5ub3RhdGlvbnM7XG4gICAgfVxuICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBuZXdUZXh0LCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciBlZGl0O1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVkaXQgPSBUZXh0RWRpdC5pbnNlcnQocG9zaXRpb24sIG5ld1RleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pKSB7XG4gICAgICAgICAgICBpZCA9IGFubm90YXRpb247XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQuaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0LCBhbm5vdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0Q2hhbmdlQW5ub3RhdGlvbnModGhpcy5jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICBpZCA9IHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0Lmluc2VydChwb3NpdGlvbiwgbmV3VGV4dCwgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdHMucHVzaChlZGl0KTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGV4dEVkaXRDaGFuZ2VJbXBsLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKHJhbmdlLCBuZXdUZXh0LCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciBlZGl0O1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVkaXQgPSBUZXh0RWRpdC5yZXBsYWNlKHJhbmdlLCBuZXdUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhhbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgaWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0LnJlcGxhY2UocmFuZ2UsIG5ld1RleHQsIGFubm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRDaGFuZ2VBbm5vdGF0aW9ucyh0aGlzLmNoYW5nZUFubm90YXRpb25zKTtcbiAgICAgICAgICAgIGlkID0gdGhpcy5jaGFuZ2VBbm5vdGF0aW9ucy5tYW5hZ2UoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQucmVwbGFjZShyYW5nZSwgbmV3VGV4dCwgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdHMucHVzaChlZGl0KTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGV4dEVkaXRDaGFuZ2VJbXBsLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAocmFuZ2UsIGFubm90YXRpb24pIHtcbiAgICAgICAgdmFyIGVkaXQ7XG4gICAgICAgIHZhciBpZDtcbiAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZWRpdCA9IFRleHRFZGl0LmRlbChyYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoYW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGlkID0gYW5ub3RhdGlvbjtcbiAgICAgICAgICAgIGVkaXQgPSBBbm5vdGF0ZWRUZXh0RWRpdC5kZWwocmFuZ2UsIGFubm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRDaGFuZ2VBbm5vdGF0aW9ucyh0aGlzLmNoYW5nZUFubm90YXRpb25zKTtcbiAgICAgICAgICAgIGlkID0gdGhpcy5jaGFuZ2VBbm5vdGF0aW9ucy5tYW5hZ2UoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQuZGVsKHJhbmdlLCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0cy5wdXNoKGVkaXQpO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZXh0RWRpdENoYW5nZUltcGwucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChlZGl0KSB7XG4gICAgICAgIHRoaXMuZWRpdHMucHVzaChlZGl0KTtcbiAgICB9O1xuICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0cztcbiAgICB9O1xuICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZWRpdHMuc3BsaWNlKDAsIHRoaXMuZWRpdHMubGVuZ3RoKTtcbiAgICB9O1xuICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUuYXNzZXJ0Q2hhbmdlQW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRleHQgZWRpdCBjaGFuZ2UgaXMgbm90IGNvbmZpZ3VyZWQgdG8gbWFuYWdlIGNoYW5nZSBhbm5vdGF0aW9ucy5cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUZXh0RWRpdENoYW5nZUltcGw7XG59KCkpO1xuLyoqXG4gKiBBIGhlbHBlciBjbGFzc1xuICovXG52YXIgQ2hhbmdlQW5ub3RhdGlvbnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2hhbmdlQW5ub3RhdGlvbnMoYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucyA9PT0gdW5kZWZpbmVkID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IGFubm90YXRpb25zO1xuICAgICAgICB0aGlzLl9jb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgfVxuICAgIENoYW5nZUFubm90YXRpb25zLnByb3RvdHlwZS5hbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbm5vdGF0aW9ucztcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGFuZ2VBbm5vdGF0aW9ucy5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDaGFuZ2VBbm5vdGF0aW9ucy5wcm90b3R5cGUubWFuYWdlID0gZnVuY3Rpb24gKGlkT3JBbm5vdGF0aW9uLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciBpZDtcbiAgICAgICAgaWYgKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGlkT3JBbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgaWQgPSBpZE9yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlkID0gdGhpcy5uZXh0SWQoKTtcbiAgICAgICAgICAgIGFubm90YXRpb24gPSBpZE9yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYW5ub3RhdGlvbnNbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklkIFwiLmNvbmNhdChpZCwgXCIgaXMgYWxyZWFkeSBpbiB1c2UuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBhbm5vdGF0aW9uIHByb3ZpZGVkIGZvciBpZCBcIi5jb25jYXQoaWQpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hbm5vdGF0aW9uc1tpZF0gPSBhbm5vdGF0aW9uO1xuICAgICAgICB0aGlzLl9zaXplKys7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9O1xuICAgIENoYW5nZUFubm90YXRpb25zLnByb3RvdHlwZS5uZXh0SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NvdW50ZXIrKztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvdW50ZXIudG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIHJldHVybiBDaGFuZ2VBbm5vdGF0aW9ucztcbn0oKSk7XG4vKipcbiAqIEEgd29ya3NwYWNlIGNoYW5nZSBoZWxwcyBjb25zdHJ1Y3RpbmcgY2hhbmdlcyB0byBhIHdvcmtzcGFjZS5cbiAqL1xudmFyIFdvcmtzcGFjZUNoYW5nZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXb3Jrc3BhY2VDaGFuZ2Uod29ya3NwYWNlRWRpdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl90ZXh0RWRpdENoYW5nZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBpZiAod29ya3NwYWNlRWRpdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0ID0gd29ya3NwYWNlRWRpdDtcbiAgICAgICAgICAgIGlmICh3b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUFubm90YXRpb25zID0gbmV3IENoYW5nZUFubm90YXRpb25zKHdvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgICAgIHdvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMgPSB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5hbGwoKTtcbiAgICAgICAgICAgICAgICB3b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFRleHREb2N1bWVudEVkaXQuaXMoY2hhbmdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRFZGl0Q2hhbmdlID0gbmV3IFRleHRFZGl0Q2hhbmdlSW1wbChjaGFuZ2UuZWRpdHMsIF90aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW2NoYW5nZS50ZXh0RG9jdW1lbnQudXJpXSA9IHRleHRFZGl0Q2hhbmdlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh3b3Jrc3BhY2VFZGl0LmNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh3b3Jrc3BhY2VFZGl0LmNoYW5nZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dEVkaXRDaGFuZ2UgPSBuZXcgVGV4dEVkaXRDaGFuZ2VJbXBsKHdvcmtzcGFjZUVkaXQuY2hhbmdlc1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RleHRFZGl0Q2hhbmdlc1trZXldID0gdGV4dEVkaXRDaGFuZ2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0ID0ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdvcmtzcGFjZUNoYW5nZS5wcm90b3R5cGUsIFwiZWRpdFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIHtAbGluayBXb3Jrc3BhY2VFZGl0fSBsaXRlcmFsXG4gICAgICAgICAqIHVzZSB0byBiZSByZXR1cm5lZCBmcm9tIGEgd29ya3NwYWNlIGVkaXQgb3BlcmF0aW9uIGxpa2UgcmVuYW1lLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmluaXREb2N1bWVudENoYW5nZXMoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NoYW5nZUFubm90YXRpb25zLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VBbm5vdGF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMgPSB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5hbGwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd29ya3NwYWNlRWRpdDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFdvcmtzcGFjZUNoYW5nZS5wcm90b3R5cGUuZ2V0VGV4dEVkaXRDaGFuZ2UgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya3NwYWNlIGVkaXQgaXMgbm90IGNvbmZpZ3VyZWQgZm9yIGRvY3VtZW50IGNoYW5nZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGV4dERvY3VtZW50ID0geyB1cmk6IGtleS51cmksIHZlcnNpb246IGtleS52ZXJzaW9uIH07XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW3RleHREb2N1bWVudC51cmldO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWRpdHMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dERvY3VtZW50RWRpdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dERvY3VtZW50OiB0ZXh0RG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGVkaXRzOiBlZGl0c1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMucHVzaCh0ZXh0RG9jdW1lbnRFZGl0KTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVGV4dEVkaXRDaGFuZ2VJbXBsKGVkaXRzLCB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW3RleHREb2N1bWVudC51cmldID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdENoYW5nZXMoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya3NwYWNlIGVkaXQgaXMgbm90IGNvbmZpZ3VyZWQgZm9yIG5vcm1hbCB0ZXh0IGVkaXQgY2hhbmdlcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl90ZXh0RWRpdENoYW5nZXNba2V5XTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVkaXRzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzW2tleV0gPSBlZGl0cztcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVGV4dEVkaXRDaGFuZ2VJbXBsKGVkaXRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0RWRpdENoYW5nZXNba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdvcmtzcGFjZUNoYW5nZS5wcm90b3R5cGUuaW5pdERvY3VtZW50Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQgJiYgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZUFubm90YXRpb25zID0gbmV3IENoYW5nZUFubm90YXRpb25zKCk7XG4gICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VBbm5vdGF0aW9ucyA9IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLmFsbCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXb3Jrc3BhY2VDaGFuZ2UucHJvdG90eXBlLmluaXRDaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCAmJiB0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgV29ya3NwYWNlQ2hhbmdlLnByb3RvdHlwZS5jcmVhdGVGaWxlID0gZnVuY3Rpb24gKHVyaSwgb3B0aW9uc09yQW5ub3RhdGlvbiwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXREb2N1bWVudENoYW5nZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya3NwYWNlIGVkaXQgaXMgbm90IGNvbmZpZ3VyZWQgZm9yIGRvY3VtZW50IGNoYW5nZXMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFubm90YXRpb247XG4gICAgICAgIGlmIChDaGFuZ2VBbm5vdGF0aW9uLmlzKG9wdGlvbnNPckFubm90YXRpb24pIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKG9wdGlvbnNPckFubm90YXRpb24pKSB7XG4gICAgICAgICAgICBhbm5vdGF0aW9uID0gb3B0aW9uc09yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcGVyYXRpb247XG4gICAgICAgIHZhciBpZDtcbiAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3BlcmF0aW9uID0gQ3JlYXRlRmlsZS5jcmVhdGUodXJpLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlkID0gQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoYW5ub3RhdGlvbikgPyBhbm5vdGF0aW9uIDogdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgb3BlcmF0aW9uID0gQ3JlYXRlRmlsZS5jcmVhdGUodXJpLCBvcHRpb25zLCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMucHVzaChvcGVyYXRpb24pO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXb3Jrc3BhY2VDaGFuZ2UucHJvdG90eXBlLnJlbmFtZUZpbGUgPSBmdW5jdGlvbiAob2xkVXJpLCBuZXdVcmksIG9wdGlvbnNPckFubm90YXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBkb2N1bWVudCBjaGFuZ2VzLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbm5vdGF0aW9uO1xuICAgICAgICBpZiAoQ2hhbmdlQW5ub3RhdGlvbi5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgYW5ub3RhdGlvbiA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9uc09yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3BlcmF0aW9uO1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IFJlbmFtZUZpbGUuY3JlYXRlKG9sZFVyaSwgbmV3VXJpLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlkID0gQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoYW5ub3RhdGlvbikgPyBhbm5vdGF0aW9uIDogdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgb3BlcmF0aW9uID0gUmVuYW1lRmlsZS5jcmVhdGUob2xkVXJpLCBuZXdVcmksIG9wdGlvbnMsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcy5wdXNoKG9wZXJhdGlvbik7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdvcmtzcGFjZUNoYW5nZS5wcm90b3R5cGUuZGVsZXRlRmlsZSA9IGZ1bmN0aW9uICh1cmksIG9wdGlvbnNPckFubm90YXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBkb2N1bWVudCBjaGFuZ2VzLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbm5vdGF0aW9uO1xuICAgICAgICBpZiAoQ2hhbmdlQW5ub3RhdGlvbi5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgYW5ub3RhdGlvbiA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9uc09yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3BlcmF0aW9uO1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IERlbGV0ZUZpbGUuY3JlYXRlKHVyaSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZCA9IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pID8gYW5ub3RhdGlvbiA6IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IERlbGV0ZUZpbGUuY3JlYXRlKHVyaSwgb3B0aW9ucywgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzLnB1c2gob3BlcmF0aW9uKTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFdvcmtzcGFjZUNoYW5nZTtcbn0oKSk7XG5cbi8qKlxuICogVGhlIFRleHREb2N1bWVudElkZW50aWZpZXIgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgVGV4dERvY3VtZW50SWRlbnRpZmllcn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBUZXh0RG9jdW1lbnRJZGVudGlmaWVyO1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRJZGVudGlmaWVyKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBUZXh0RG9jdW1lbnRJZGVudGlmaWVyIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSkge1xuICAgICAgICByZXR1cm4geyB1cmk6IHVyaSB9O1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIFRleHREb2N1bWVudElkZW50aWZpZXJ9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmlzID0gaXM7XG59KShUZXh0RG9jdW1lbnRJZGVudGlmaWVyIHx8IChUZXh0RG9jdW1lbnRJZGVudGlmaWVyID0ge30pKTtcbi8qKlxuICogVGhlIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyO1xuKGZ1bmN0aW9uIChWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIHZlcnNpb24gVGhlIGRvY3VtZW50J3MgdmVyc2lvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCB2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB7IHVyaTogdXJpLCB2ZXJzaW9uOiB2ZXJzaW9uIH07XG4gICAgfVxuICAgIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgJiYgSXMuaW50ZWdlcihjYW5kaWRhdGUudmVyc2lvbik7XG4gICAgfVxuICAgIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMgPSBpcztcbn0pKFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgfHwgKFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXI7XG4oZnVuY3Rpb24gKE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIHZlcnNpb24gVGhlIGRvY3VtZW50J3MgdmVyc2lvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCB2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB7IHVyaTogdXJpLCB2ZXJzaW9uOiB2ZXJzaW9uIH07XG4gICAgfVxuICAgIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllci5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXJ9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIChjYW5kaWRhdGUudmVyc2lvbiA9PT0gbnVsbCB8fCBJcy5pbnRlZ2VyKGNhbmRpZGF0ZS52ZXJzaW9uKSk7XG4gICAgfVxuICAgIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllci5pcyA9IGlzO1xufSkoT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIHx8IChPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgVGV4dERvY3VtZW50SXRlbSBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBUZXh0RG9jdW1lbnRJdGVtfSBsaXRlcmFscy5cbiAqL1xudmFyIFRleHREb2N1bWVudEl0ZW07XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudEl0ZW0pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFRleHREb2N1bWVudEl0ZW0gbGl0ZXJhbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBkb2N1bWVudCdzIHVyaS5cbiAgICAgKiBAcGFyYW0gbGFuZ3VhZ2VJZCBUaGUgZG9jdW1lbnQncyBsYW5ndWFnZSBpZGVudGlmaWVyLlxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIFRoZSBkb2N1bWVudCdzIHZlcnNpb24gbnVtYmVyLlxuICAgICAqIEBwYXJhbSB0ZXh0IFRoZSBkb2N1bWVudCdzIHRleHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgdGV4dCkge1xuICAgICAgICByZXR1cm4geyB1cmk6IHVyaSwgbGFuZ3VhZ2VJZDogbGFuZ3VhZ2VJZCwgdmVyc2lvbjogdmVyc2lvbiwgdGV4dDogdGV4dCB9O1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRJdGVtLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIFRleHREb2N1bWVudEl0ZW19IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIElzLnN0cmluZyhjYW5kaWRhdGUubGFuZ3VhZ2VJZCkgJiYgSXMuaW50ZWdlcihjYW5kaWRhdGUudmVyc2lvbikgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS50ZXh0KTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50SXRlbS5pcyA9IGlzO1xufSkoVGV4dERvY3VtZW50SXRlbSB8fCAoVGV4dERvY3VtZW50SXRlbSA9IHt9KSk7XG4vKipcbiAqIERlc2NyaWJlcyB0aGUgY29udGVudCB0eXBlIHRoYXQgYSBjbGllbnQgc3VwcG9ydHMgaW4gdmFyaW91c1xuICogcmVzdWx0IGxpdGVyYWxzIGxpa2UgYEhvdmVyYCwgYFBhcmFtZXRlckluZm9gIG9yIGBDb21wbGV0aW9uSXRlbWAuXG4gKlxuICogUGxlYXNlIG5vdGUgdGhhdCBgTWFya3VwS2luZHNgIG11c3Qgbm90IHN0YXJ0IHdpdGggYSBgJGAuIFRoaXMga2luZHNcbiAqIGFyZSByZXNlcnZlZCBmb3IgaW50ZXJuYWwgdXNhZ2UuXG4gKi9cbnZhciBNYXJrdXBLaW5kO1xuKGZ1bmN0aW9uIChNYXJrdXBLaW5kKSB7XG4gICAgLyoqXG4gICAgICogUGxhaW4gdGV4dCBpcyBzdXBwb3J0ZWQgYXMgYSBjb250ZW50IGZvcm1hdFxuICAgICAqL1xuICAgIE1hcmt1cEtpbmQuUGxhaW5UZXh0ID0gJ3BsYWludGV4dCc7XG4gICAgLyoqXG4gICAgICogTWFya2Rvd24gaXMgc3VwcG9ydGVkIGFzIGEgY29udGVudCBmb3JtYXRcbiAgICAgKi9cbiAgICBNYXJrdXBLaW5kLk1hcmtkb3duID0gJ21hcmtkb3duJztcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWx1ZSBvZiB0aGUge0BsaW5rIE1hcmt1cEtpbmR9IHR5cGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlID09PSBNYXJrdXBLaW5kLlBsYWluVGV4dCB8fCBjYW5kaWRhdGUgPT09IE1hcmt1cEtpbmQuTWFya2Rvd247XG4gICAgfVxuICAgIE1hcmt1cEtpbmQuaXMgPSBpcztcbn0pKE1hcmt1cEtpbmQgfHwgKE1hcmt1cEtpbmQgPSB7fSkpO1xudmFyIE1hcmt1cENvbnRlbnQ7XG4oZnVuY3Rpb24gKE1hcmt1cENvbnRlbnQpIHtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgY29uZm9ybXMgdG8gdGhlIHtAbGluayBNYXJrdXBDb250ZW50fSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbCh2YWx1ZSkgJiYgTWFya3VwS2luZC5pcyhjYW5kaWRhdGUua2luZCkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS52YWx1ZSk7XG4gICAgfVxuICAgIE1hcmt1cENvbnRlbnQuaXMgPSBpcztcbn0pKE1hcmt1cENvbnRlbnQgfHwgKE1hcmt1cENvbnRlbnQgPSB7fSkpO1xuLyoqXG4gKiBUaGUga2luZCBvZiBhIGNvbXBsZXRpb24gZW50cnkuXG4gKi9cbnZhciBDb21wbGV0aW9uSXRlbUtpbmQ7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtS2luZCkge1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5UZXh0ID0gMTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuTWV0aG9kID0gMjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuRnVuY3Rpb24gPSAzO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Db25zdHJ1Y3RvciA9IDQ7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZpZWxkID0gNTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuVmFyaWFibGUgPSA2O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5DbGFzcyA9IDc7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkludGVyZmFjZSA9IDg7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLk1vZHVsZSA9IDk7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5ID0gMTA7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlVuaXQgPSAxMTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuVmFsdWUgPSAxMjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuRW51bSA9IDEzO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5LZXl3b3JkID0gMTQ7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlNuaXBwZXQgPSAxNTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ29sb3IgPSAxNjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuRmlsZSA9IDE3O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5SZWZlcmVuY2UgPSAxODtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuRm9sZGVyID0gMTk7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkVudW1NZW1iZXIgPSAyMDtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ29uc3RhbnQgPSAyMTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuU3RydWN0ID0gMjI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkV2ZW50ID0gMjM7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLk9wZXJhdG9yID0gMjQ7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlR5cGVQYXJhbWV0ZXIgPSAyNTtcbn0pKENvbXBsZXRpb25JdGVtS2luZCB8fCAoQ29tcGxldGlvbkl0ZW1LaW5kID0ge30pKTtcbi8qKlxuICogRGVmaW5lcyB3aGV0aGVyIHRoZSBpbnNlcnQgdGV4dCBpbiBhIGNvbXBsZXRpb24gaXRlbSBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXNcbiAqIHBsYWluIHRleHQgb3IgYSBzbmlwcGV0LlxuICovXG52YXIgSW5zZXJ0VGV4dEZvcm1hdDtcbihmdW5jdGlvbiAoSW5zZXJ0VGV4dEZvcm1hdCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBwcmltYXJ5IHRleHQgdG8gYmUgaW5zZXJ0ZWQgaXMgdHJlYXRlZCBhcyBhIHBsYWluIHN0cmluZy5cbiAgICAgKi9cbiAgICBJbnNlcnRUZXh0Rm9ybWF0LlBsYWluVGV4dCA9IDE7XG4gICAgLyoqXG4gICAgICogVGhlIHByaW1hcnkgdGV4dCB0byBiZSBpbnNlcnRlZCBpcyB0cmVhdGVkIGFzIGEgc25pcHBldC5cbiAgICAgKlxuICAgICAqIEEgc25pcHBldCBjYW4gZGVmaW5lIHRhYiBzdG9wcyBhbmQgcGxhY2Vob2xkZXJzIHdpdGggYCQxYCwgYCQyYFxuICAgICAqIGFuZCBgJHszOmZvb31gLiBgJDBgIGRlZmluZXMgdGhlIGZpbmFsIHRhYiBzdG9wLCBpdCBkZWZhdWx0cyB0b1xuICAgICAqIHRoZSBlbmQgb2YgdGhlIHNuaXBwZXQuIFBsYWNlaG9sZGVycyB3aXRoIGVxdWFsIGlkZW50aWZpZXJzIGFyZSBsaW5rZWQsXG4gICAgICogdGhhdCBpcyB0eXBpbmcgaW4gb25lIHdpbGwgdXBkYXRlIG90aGVycyB0b28uXG4gICAgICpcbiAgICAgKiBTZWUgYWxzbzogaHR0cHM6Ly9taWNyb3NvZnQuZ2l0aHViLmlvL2xhbmd1YWdlLXNlcnZlci1wcm90b2NvbC9zcGVjaWZpY2F0aW9ucy9zcGVjaWZpY2F0aW9uLWN1cnJlbnQvI3NuaXBwZXRfc3ludGF4XG4gICAgICovXG4gICAgSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0ID0gMjtcbn0pKEluc2VydFRleHRGb3JtYXQgfHwgKEluc2VydFRleHRGb3JtYXQgPSB7fSkpO1xuLyoqXG4gKiBDb21wbGV0aW9uIGl0ZW0gdGFncyBhcmUgZXh0cmEgYW5ub3RhdGlvbnMgdGhhdCB0d2VhayB0aGUgcmVuZGVyaW5nIG9mIGEgY29tcGxldGlvblxuICogaXRlbS5cbiAqXG4gKiBAc2luY2UgMy4xNS4wXG4gKi9cbnZhciBDb21wbGV0aW9uSXRlbVRhZztcbihmdW5jdGlvbiAoQ29tcGxldGlvbkl0ZW1UYWcpIHtcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYSBjb21wbGV0aW9uIGFzIG9ic29sZXRlLCB1c3VhbGx5IHVzaW5nIGEgc3RyaWtlLW91dC5cbiAgICAgKi9cbiAgICBDb21wbGV0aW9uSXRlbVRhZy5EZXByZWNhdGVkID0gMTtcbn0pKENvbXBsZXRpb25JdGVtVGFnIHx8IChDb21wbGV0aW9uSXRlbVRhZyA9IHt9KSk7XG4vKipcbiAqIFRoZSBJbnNlcnRSZXBsYWNlRWRpdCBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBpbnNlcnQgLyByZXBsYWNlIGVkaXRzLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIEluc2VydFJlcGxhY2VFZGl0O1xuKGZ1bmN0aW9uIChJbnNlcnRSZXBsYWNlRWRpdCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zZXJ0IC8gcmVwbGFjZSBlZGl0XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKG5ld1RleHQsIGluc2VydCwgcmVwbGFjZSkge1xuICAgICAgICByZXR1cm4geyBuZXdUZXh0OiBuZXdUZXh0LCBpbnNlcnQ6IGluc2VydCwgcmVwbGFjZTogcmVwbGFjZSB9O1xuICAgIH1cbiAgICBJbnNlcnRSZXBsYWNlRWRpdC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBJbnNlcnRSZXBsYWNlRWRpdH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm5ld1RleHQpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5pbnNlcnQpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yZXBsYWNlKTtcbiAgICB9XG4gICAgSW5zZXJ0UmVwbGFjZUVkaXQuaXMgPSBpcztcbn0pKEluc2VydFJlcGxhY2VFZGl0IHx8IChJbnNlcnRSZXBsYWNlRWRpdCA9IHt9KSk7XG4vKipcbiAqIEhvdyB3aGl0ZXNwYWNlIGFuZCBpbmRlbnRhdGlvbiBpcyBoYW5kbGVkIGR1cmluZyBjb21wbGV0aW9uXG4gKiBpdGVtIGluc2VydGlvbi5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBJbnNlcnRUZXh0TW9kZTtcbihmdW5jdGlvbiAoSW5zZXJ0VGV4dE1vZGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgaW5zZXJ0aW9uIG9yIHJlcGxhY2Ugc3RyaW5ncyBpcyB0YWtlbiBhcyBpdCBpcy4gSWYgdGhlXG4gICAgICogdmFsdWUgaXMgbXVsdGkgbGluZSB0aGUgbGluZXMgYmVsb3cgdGhlIGN1cnNvciB3aWxsIGJlXG4gICAgICogaW5zZXJ0ZWQgdXNpbmcgdGhlIGluZGVudGF0aW9uIGRlZmluZWQgaW4gdGhlIHN0cmluZyB2YWx1ZS5cbiAgICAgKiBUaGUgY2xpZW50IHdpbGwgbm90IGFwcGx5IGFueSBraW5kIG9mIGFkanVzdG1lbnRzIHRvIHRoZVxuICAgICAqIHN0cmluZy5cbiAgICAgKi9cbiAgICBJbnNlcnRUZXh0TW9kZS5hc0lzID0gMTtcbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGFkanVzdHMgbGVhZGluZyB3aGl0ZXNwYWNlIG9mIG5ldyBsaW5lcyBzbyB0aGF0XG4gICAgICogdGhleSBtYXRjaCB0aGUgaW5kZW50YXRpb24gdXAgdG8gdGhlIGN1cnNvciBvZiB0aGUgbGluZSBmb3JcbiAgICAgKiB3aGljaCB0aGUgaXRlbSBpcyBhY2NlcHRlZC5cbiAgICAgKlxuICAgICAqIENvbnNpZGVyIGEgbGluZSBsaWtlIHRoaXM6IDwydGFicz48Y3Vyc29yPjwzdGFicz5mb28uIEFjY2VwdGluZyBhXG4gICAgICogbXVsdGkgbGluZSBjb21wbGV0aW9uIGl0ZW0gaXMgaW5kZW50ZWQgdXNpbmcgMiB0YWJzIGFuZCBhbGxcbiAgICAgKiBmb2xsb3dpbmcgbGluZXMgaW5zZXJ0ZWQgd2lsbCBiZSBpbmRlbnRlZCB1c2luZyAyIHRhYnMgYXMgd2VsbC5cbiAgICAgKi9cbiAgICBJbnNlcnRUZXh0TW9kZS5hZGp1c3RJbmRlbnRhdGlvbiA9IDI7XG59KShJbnNlcnRUZXh0TW9kZSB8fCAoSW5zZXJ0VGV4dE1vZGUgPSB7fSkpO1xudmFyIENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzO1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbUxhYmVsRGV0YWlscykge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5kZXRhaWwpIHx8IGNhbmRpZGF0ZS5kZXRhaWwgPT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgIChJcy5zdHJpbmcoY2FuZGlkYXRlLmRlc2NyaXB0aW9uKSB8fCBjYW5kaWRhdGUuZGVzY3JpcHRpb24gPT09IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzLmlzID0gaXM7XG59KShDb21wbGV0aW9uSXRlbUxhYmVsRGV0YWlscyB8fCAoQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29tcGxldGlvbkl0ZW0gbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGhcbiAqIGNvbXBsZXRpb24gaXRlbXMuXG4gKi9cbnZhciBDb21wbGV0aW9uSXRlbTtcbihmdW5jdGlvbiAoQ29tcGxldGlvbkl0ZW0pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjb21wbGV0aW9uIGl0ZW0gYW5kIHNlZWQgaXQgd2l0aCBhIGxhYmVsLlxuICAgICAqIEBwYXJhbSBsYWJlbCBUaGUgY29tcGxldGlvbiBpdGVtJ3MgbGFiZWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIHsgbGFiZWw6IGxhYmVsIH07XG4gICAgfVxuICAgIENvbXBsZXRpb25JdGVtLmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKENvbXBsZXRpb25JdGVtIHx8IChDb21wbGV0aW9uSXRlbSA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb21wbGV0aW9uTGlzdCBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aFxuICogY29tcGxldGlvbiBsaXN0cy5cbiAqL1xudmFyIENvbXBsZXRpb25MaXN0O1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uTGlzdCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY29tcGxldGlvbiBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGl0ZW1zIFRoZSBjb21wbGV0aW9uIGl0ZW1zLlxuICAgICAqIEBwYXJhbSBpc0luY29tcGxldGUgVGhlIGxpc3QgaXMgbm90IGNvbXBsZXRlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShpdGVtcywgaXNJbmNvbXBsZXRlKSB7XG4gICAgICAgIHJldHVybiB7IGl0ZW1zOiBpdGVtcyA/IGl0ZW1zIDogW10sIGlzSW5jb21wbGV0ZTogISFpc0luY29tcGxldGUgfTtcbiAgICB9XG4gICAgQ29tcGxldGlvbkxpc3QuY3JlYXRlID0gY3JlYXRlO1xufSkoQ29tcGxldGlvbkxpc3QgfHwgKENvbXBsZXRpb25MaXN0ID0ge30pKTtcbnZhciBNYXJrZWRTdHJpbmc7XG4oZnVuY3Rpb24gKE1hcmtlZFN0cmluZykge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBtYXJrZWQgc3RyaW5nIGZyb20gcGxhaW4gdGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwbGFpblRleHQgVGhlIHBsYWluIHRleHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbVBsYWluVGV4dChwbGFpblRleHQpIHtcbiAgICAgICAgcmV0dXJuIHBsYWluVGV4dC5yZXBsYWNlKC9bXFxcXGAqX3t9W1xcXSgpIytcXC0uIV0vZywgJ1xcXFwkJicpOyAvLyBlc2NhcGUgbWFya2Rvd24gc3ludGF4IHRva2VuczogaHR0cDovL2RhcmluZ2ZpcmViYWxsLm5ldC9wcm9qZWN0cy9tYXJrZG93bi9zeW50YXgjYmFja3NsYXNoXG4gICAgfVxuICAgIE1hcmtlZFN0cmluZy5mcm9tUGxhaW5UZXh0ID0gZnJvbVBsYWluVGV4dDtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgY29uZm9ybXMgdG8gdGhlIHtAbGluayBNYXJrZWRTdHJpbmd9IHR5cGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuc3RyaW5nKGNhbmRpZGF0ZSkgfHwgKElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhbmd1YWdlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnZhbHVlKSk7XG4gICAgfVxuICAgIE1hcmtlZFN0cmluZy5pcyA9IGlzO1xufSkoTWFya2VkU3RyaW5nIHx8IChNYXJrZWRTdHJpbmcgPSB7fSkpO1xudmFyIEhvdmVyO1xuKGZ1bmN0aW9uIChIb3Zlcikge1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBjb25mb3JtcyB0byB0aGUge0BsaW5rIEhvdmVyfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gISFjYW5kaWRhdGUgJiYgSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIChNYXJrdXBDb250ZW50LmlzKGNhbmRpZGF0ZS5jb250ZW50cykgfHxcbiAgICAgICAgICAgIE1hcmtlZFN0cmluZy5pcyhjYW5kaWRhdGUuY29udGVudHMpIHx8XG4gICAgICAgICAgICBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5jb250ZW50cywgTWFya2VkU3RyaW5nLmlzKSkgJiYgKHZhbHVlLnJhbmdlID09PSB1bmRlZmluZWQgfHwgUmFuZ2UuaXModmFsdWUucmFuZ2UpKTtcbiAgICB9XG4gICAgSG92ZXIuaXMgPSBpcztcbn0pKEhvdmVyIHx8IChIb3ZlciA9IHt9KSk7XG4vKipcbiAqIFRoZSBQYXJhbWV0ZXJJbmZvcm1hdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBQYXJhbWV0ZXJJbmZvcm1hdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBQYXJhbWV0ZXJJbmZvcm1hdGlvbjtcbihmdW5jdGlvbiAoUGFyYW1ldGVySW5mb3JtYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHBhcmFtZXRlciBpbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxhYmVsIEEgbGFiZWwgc3RyaW5nLlxuICAgICAqIEBwYXJhbSBkb2N1bWVudGF0aW9uIEEgZG9jIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUobGFiZWwsIGRvY3VtZW50YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50YXRpb24gPyB7IGxhYmVsOiBsYWJlbCwgZG9jdW1lbnRhdGlvbjogZG9jdW1lbnRhdGlvbiB9IDogeyBsYWJlbDogbGFiZWwgfTtcbiAgICB9XG4gICAgUGFyYW1ldGVySW5mb3JtYXRpb24uY3JlYXRlID0gY3JlYXRlO1xufSkoUGFyYW1ldGVySW5mb3JtYXRpb24gfHwgKFBhcmFtZXRlckluZm9ybWF0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIFNpZ25hdHVyZUluZm9ybWF0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFNpZ25hdHVyZUluZm9ybWF0aW9ufSBsaXRlcmFscy5cbiAqL1xudmFyIFNpZ25hdHVyZUluZm9ybWF0aW9uO1xuKGZ1bmN0aW9uIChTaWduYXR1cmVJbmZvcm1hdGlvbikge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCwgZG9jdW1lbnRhdGlvbikge1xuICAgICAgICB2YXIgcGFyYW1ldGVycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgcGFyYW1ldGVyc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0geyBsYWJlbDogbGFiZWwgfTtcbiAgICAgICAgaWYgKElzLmRlZmluZWQoZG9jdW1lbnRhdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kb2N1bWVudGF0aW9uID0gZG9jdW1lbnRhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChwYXJhbWV0ZXJzKSkge1xuICAgICAgICAgICAgcmVzdWx0LnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBTaWduYXR1cmVJbmZvcm1hdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG59KShTaWduYXR1cmVJbmZvcm1hdGlvbiB8fCAoU2lnbmF0dXJlSW5mb3JtYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBBIGRvY3VtZW50IGhpZ2hsaWdodCBraW5kLlxuICovXG52YXIgRG9jdW1lbnRIaWdobGlnaHRLaW5kO1xuKGZ1bmN0aW9uIChEb2N1bWVudEhpZ2hsaWdodEtpbmQpIHtcbiAgICAvKipcbiAgICAgKiBBIHRleHR1YWwgb2NjdXJyZW5jZS5cbiAgICAgKi9cbiAgICBEb2N1bWVudEhpZ2hsaWdodEtpbmQuVGV4dCA9IDE7XG4gICAgLyoqXG4gICAgICogUmVhZC1hY2Nlc3Mgb2YgYSBzeW1ib2wsIGxpa2UgcmVhZGluZyBhIHZhcmlhYmxlLlxuICAgICAqL1xuICAgIERvY3VtZW50SGlnaGxpZ2h0S2luZC5SZWFkID0gMjtcbiAgICAvKipcbiAgICAgKiBXcml0ZS1hY2Nlc3Mgb2YgYSBzeW1ib2wsIGxpa2Ugd3JpdGluZyB0byBhIHZhcmlhYmxlLlxuICAgICAqL1xuICAgIERvY3VtZW50SGlnaGxpZ2h0S2luZC5Xcml0ZSA9IDM7XG59KShEb2N1bWVudEhpZ2hsaWdodEtpbmQgfHwgKERvY3VtZW50SGlnaGxpZ2h0S2luZCA9IHt9KSk7XG4vKipcbiAqIERvY3VtZW50SGlnaGxpZ2h0IG5hbWVzcGFjZSB0byBwcm92aWRlIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgRG9jdW1lbnRIaWdobGlnaHR9IGxpdGVyYWxzLlxuICovXG52YXIgRG9jdW1lbnRIaWdobGlnaHQ7XG4oZnVuY3Rpb24gKERvY3VtZW50SGlnaGxpZ2h0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgRG9jdW1lbnRIaWdobGlnaHQgb2JqZWN0LlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2UgdGhlIGhpZ2hsaWdodCBhcHBsaWVzIHRvLlxuICAgICAqIEBwYXJhbSBraW5kIFRoZSBoaWdobGlnaHQga2luZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwga2luZCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0geyByYW5nZTogcmFuZ2UgfTtcbiAgICAgICAgaWYgKElzLm51bWJlcihraW5kKSkge1xuICAgICAgICAgICAgcmVzdWx0LmtpbmQgPSBraW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIERvY3VtZW50SGlnaGxpZ2h0LmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKERvY3VtZW50SGlnaGxpZ2h0IHx8IChEb2N1bWVudEhpZ2hsaWdodCA9IHt9KSk7XG4vKipcbiAqIEEgc3ltYm9sIGtpbmQuXG4gKi9cbnZhciBTeW1ib2xLaW5kO1xuKGZ1bmN0aW9uIChTeW1ib2xLaW5kKSB7XG4gICAgU3ltYm9sS2luZC5GaWxlID0gMTtcbiAgICBTeW1ib2xLaW5kLk1vZHVsZSA9IDI7XG4gICAgU3ltYm9sS2luZC5OYW1lc3BhY2UgPSAzO1xuICAgIFN5bWJvbEtpbmQuUGFja2FnZSA9IDQ7XG4gICAgU3ltYm9sS2luZC5DbGFzcyA9IDU7XG4gICAgU3ltYm9sS2luZC5NZXRob2QgPSA2O1xuICAgIFN5bWJvbEtpbmQuUHJvcGVydHkgPSA3O1xuICAgIFN5bWJvbEtpbmQuRmllbGQgPSA4O1xuICAgIFN5bWJvbEtpbmQuQ29uc3RydWN0b3IgPSA5O1xuICAgIFN5bWJvbEtpbmQuRW51bSA9IDEwO1xuICAgIFN5bWJvbEtpbmQuSW50ZXJmYWNlID0gMTE7XG4gICAgU3ltYm9sS2luZC5GdW5jdGlvbiA9IDEyO1xuICAgIFN5bWJvbEtpbmQuVmFyaWFibGUgPSAxMztcbiAgICBTeW1ib2xLaW5kLkNvbnN0YW50ID0gMTQ7XG4gICAgU3ltYm9sS2luZC5TdHJpbmcgPSAxNTtcbiAgICBTeW1ib2xLaW5kLk51bWJlciA9IDE2O1xuICAgIFN5bWJvbEtpbmQuQm9vbGVhbiA9IDE3O1xuICAgIFN5bWJvbEtpbmQuQXJyYXkgPSAxODtcbiAgICBTeW1ib2xLaW5kLk9iamVjdCA9IDE5O1xuICAgIFN5bWJvbEtpbmQuS2V5ID0gMjA7XG4gICAgU3ltYm9sS2luZC5OdWxsID0gMjE7XG4gICAgU3ltYm9sS2luZC5FbnVtTWVtYmVyID0gMjI7XG4gICAgU3ltYm9sS2luZC5TdHJ1Y3QgPSAyMztcbiAgICBTeW1ib2xLaW5kLkV2ZW50ID0gMjQ7XG4gICAgU3ltYm9sS2luZC5PcGVyYXRvciA9IDI1O1xuICAgIFN5bWJvbEtpbmQuVHlwZVBhcmFtZXRlciA9IDI2O1xufSkoU3ltYm9sS2luZCB8fCAoU3ltYm9sS2luZCA9IHt9KSk7XG4vKipcbiAqIFN5bWJvbCB0YWdzIGFyZSBleHRyYSBhbm5vdGF0aW9ucyB0aGF0IHR3ZWFrIHRoZSByZW5kZXJpbmcgb2YgYSBzeW1ib2wuXG4gKlxuICogQHNpbmNlIDMuMTZcbiAqL1xudmFyIFN5bWJvbFRhZztcbihmdW5jdGlvbiAoU3ltYm9sVGFnKSB7XG4gICAgLyoqXG4gICAgICogUmVuZGVyIGEgc3ltYm9sIGFzIG9ic29sZXRlLCB1c3VhbGx5IHVzaW5nIGEgc3RyaWtlLW91dC5cbiAgICAgKi9cbiAgICBTeW1ib2xUYWcuRGVwcmVjYXRlZCA9IDE7XG59KShTeW1ib2xUYWcgfHwgKFN5bWJvbFRhZyA9IHt9KSk7XG52YXIgU3ltYm9sSW5mb3JtYXRpb247XG4oZnVuY3Rpb24gKFN5bWJvbEluZm9ybWF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBzeW1ib2wgaW5mb3JtYXRpb24gbGl0ZXJhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIGtpbmQgVGhlIGtpbmQgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIG9mIHRoZSBsb2NhdGlvbiBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIHJlc291cmNlIG9mIHRoZSBsb2NhdGlvbiBvZiBzeW1ib2wuXG4gICAgICogQHBhcmFtIGNvbnRhaW5lck5hbWUgVGhlIG5hbWUgb2YgdGhlIHN5bWJvbCBjb250YWluaW5nIHRoZSBzeW1ib2wuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKG5hbWUsIGtpbmQsIHJhbmdlLCB1cmksIGNvbnRhaW5lck5hbWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBraW5kOiBraW5kLFxuICAgICAgICAgICAgbG9jYXRpb246IHsgdXJpOiB1cmksIHJhbmdlOiByYW5nZSB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChjb250YWluZXJOYW1lKSB7XG4gICAgICAgICAgICByZXN1bHQuY29udGFpbmVyTmFtZSA9IGNvbnRhaW5lck5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgU3ltYm9sSW5mb3JtYXRpb24uY3JlYXRlID0gY3JlYXRlO1xufSkoU3ltYm9sSW5mb3JtYXRpb24gfHwgKFN5bWJvbEluZm9ybWF0aW9uID0ge30pKTtcbnZhciBXb3Jrc3BhY2VTeW1ib2w7XG4oZnVuY3Rpb24gKFdvcmtzcGFjZVN5bWJvbCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyB3b3Jrc3BhY2Ugc3ltYm9sLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0ga2luZCBUaGUga2luZCBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIHJlc291cmNlIG9mIHRoZSBsb2NhdGlvbiBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSByYW5nZSBBbiBvcHRpb25zIHJhbmdlIG9mIHRoZSBsb2NhdGlvbi5cbiAgICAgKiBAcmV0dXJucyBBIFdvcmtzcGFjZVN5bWJvbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUobmFtZSwga2luZCwgdXJpLCByYW5nZSkge1xuICAgICAgICByZXR1cm4gcmFuZ2UgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB7IG5hbWU6IG5hbWUsIGtpbmQ6IGtpbmQsIGxvY2F0aW9uOiB7IHVyaTogdXJpLCByYW5nZTogcmFuZ2UgfSB9XG4gICAgICAgICAgICA6IHsgbmFtZTogbmFtZSwga2luZDoga2luZCwgbG9jYXRpb246IHsgdXJpOiB1cmkgfSB9O1xuICAgIH1cbiAgICBXb3Jrc3BhY2VTeW1ib2wuY3JlYXRlID0gY3JlYXRlO1xufSkoV29ya3NwYWNlU3ltYm9sIHx8IChXb3Jrc3BhY2VTeW1ib2wgPSB7fSkpO1xudmFyIERvY3VtZW50U3ltYm9sO1xuKGZ1bmN0aW9uIChEb2N1bWVudFN5bWJvbCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgc3ltYm9sIGluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBkZXRhaWwgVGhlIGRldGFpbCBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBraW5kIFRoZSBraW5kIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBzZWxlY3Rpb25SYW5nZSBUaGUgc2VsZWN0aW9uUmFuZ2Ugb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gY2hpbGRyZW4gQ2hpbGRyZW4gb2YgdGhlIHN5bWJvbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUobmFtZSwgZGV0YWlsLCBraW5kLCByYW5nZSwgc2VsZWN0aW9uUmFuZ2UsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgZGV0YWlsOiBkZXRhaWwsXG4gICAgICAgICAgICBraW5kOiBraW5kLFxuICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICAgICAgc2VsZWN0aW9uUmFuZ2U6IHNlbGVjdGlvblJhbmdlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBEb2N1bWVudFN5bWJvbC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBEb2N1bWVudFN5bWJvbH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJlxuICAgICAgICAgICAgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uYW1lKSAmJiBJcy5udW1iZXIoY2FuZGlkYXRlLmtpbmQpICYmXG4gICAgICAgICAgICBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5zZWxlY3Rpb25SYW5nZSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZGV0YWlsID09PSB1bmRlZmluZWQgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5kZXRhaWwpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5kZXByZWNhdGVkID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUuZGVwcmVjYXRlZCkpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmNoaWxkcmVuID09PSB1bmRlZmluZWQgfHwgQXJyYXkuaXNBcnJheShjYW5kaWRhdGUuY2hpbGRyZW4pKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS50YWdzID09PSB1bmRlZmluZWQgfHwgQXJyYXkuaXNBcnJheShjYW5kaWRhdGUudGFncykpO1xuICAgIH1cbiAgICBEb2N1bWVudFN5bWJvbC5pcyA9IGlzO1xufSkoRG9jdW1lbnRTeW1ib2wgfHwgKERvY3VtZW50U3ltYm9sID0ge30pKTtcbi8qKlxuICogQSBzZXQgb2YgcHJlZGVmaW5lZCBjb2RlIGFjdGlvbiBraW5kc1xuICovXG52YXIgQ29kZUFjdGlvbktpbmQ7XG4oZnVuY3Rpb24gKENvZGVBY3Rpb25LaW5kKSB7XG4gICAgLyoqXG4gICAgICogRW1wdHkga2luZC5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5FbXB0eSA9ICcnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcXVpY2tmaXggYWN0aW9uczogJ3F1aWNrZml4J1xuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlF1aWNrRml4ID0gJ3F1aWNrZml4JztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIHJlZmFjdG9yaW5nIGFjdGlvbnM6ICdyZWZhY3RvcidcbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5SZWZhY3RvciA9ICdyZWZhY3Rvcic7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciByZWZhY3RvcmluZyBleHRyYWN0aW9uIGFjdGlvbnM6ICdyZWZhY3Rvci5leHRyYWN0J1xuICAgICAqXG4gICAgICogRXhhbXBsZSBleHRyYWN0IGFjdGlvbnM6XG4gICAgICpcbiAgICAgKiAtIEV4dHJhY3QgbWV0aG9kXG4gICAgICogLSBFeHRyYWN0IGZ1bmN0aW9uXG4gICAgICogLSBFeHRyYWN0IHZhcmlhYmxlXG4gICAgICogLSBFeHRyYWN0IGludGVyZmFjZSBmcm9tIGNsYXNzXG4gICAgICogLSAuLi5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5SZWZhY3RvckV4dHJhY3QgPSAncmVmYWN0b3IuZXh0cmFjdCc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciByZWZhY3RvcmluZyBpbmxpbmUgYWN0aW9uczogJ3JlZmFjdG9yLmlubGluZSdcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgaW5saW5lIGFjdGlvbnM6XG4gICAgICpcbiAgICAgKiAtIElubGluZSBmdW5jdGlvblxuICAgICAqIC0gSW5saW5lIHZhcmlhYmxlXG4gICAgICogLSBJbmxpbmUgY29uc3RhbnRcbiAgICAgKiAtIC4uLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlJlZmFjdG9ySW5saW5lID0gJ3JlZmFjdG9yLmlubGluZSc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciByZWZhY3RvcmluZyByZXdyaXRlIGFjdGlvbnM6ICdyZWZhY3Rvci5yZXdyaXRlJ1xuICAgICAqXG4gICAgICogRXhhbXBsZSByZXdyaXRlIGFjdGlvbnM6XG4gICAgICpcbiAgICAgKiAtIENvbnZlcnQgSmF2YVNjcmlwdCBmdW5jdGlvbiB0byBjbGFzc1xuICAgICAqIC0gQWRkIG9yIHJlbW92ZSBwYXJhbWV0ZXJcbiAgICAgKiAtIEVuY2Fwc3VsYXRlIGZpZWxkXG4gICAgICogLSBNYWtlIG1ldGhvZCBzdGF0aWNcbiAgICAgKiAtIE1vdmUgbWV0aG9kIHRvIGJhc2UgY2xhc3NcbiAgICAgKiAtIC4uLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlJlZmFjdG9yUmV3cml0ZSA9ICdyZWZhY3Rvci5yZXdyaXRlJztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIHNvdXJjZSBhY3Rpb25zOiBgc291cmNlYFxuICAgICAqXG4gICAgICogU291cmNlIGNvZGUgYWN0aW9ucyBhcHBseSB0byB0aGUgZW50aXJlIGZpbGUuXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuU291cmNlID0gJ3NvdXJjZSc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciBhbiBvcmdhbml6ZSBpbXBvcnRzIHNvdXJjZSBhY3Rpb246IGBzb3VyY2Uub3JnYW5pemVJbXBvcnRzYFxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlNvdXJjZU9yZ2FuaXplSW1wb3J0cyA9ICdzb3VyY2Uub3JnYW5pemVJbXBvcnRzJztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIGF1dG8tZml4IHNvdXJjZSBhY3Rpb25zOiBgc291cmNlLmZpeEFsbGAuXG4gICAgICpcbiAgICAgKiBGaXggYWxsIGFjdGlvbnMgYXV0b21hdGljYWxseSBmaXggZXJyb3JzIHRoYXQgaGF2ZSBhIGNsZWFyIGZpeCB0aGF0IGRvIG5vdCByZXF1aXJlIHVzZXIgaW5wdXQuXG4gICAgICogVGhleSBzaG91bGQgbm90IHN1cHByZXNzIGVycm9ycyBvciBwZXJmb3JtIHVuc2FmZSBmaXhlcyBzdWNoIGFzIGdlbmVyYXRpbmcgbmV3IHR5cGVzIG9yIGNsYXNzZXMuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMy4xNS4wXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuU291cmNlRml4QWxsID0gJ3NvdXJjZS5maXhBbGwnO1xufSkoQ29kZUFjdGlvbktpbmQgfHwgKENvZGVBY3Rpb25LaW5kID0ge30pKTtcbi8qKlxuICogVGhlIHJlYXNvbiB3aHkgY29kZSBhY3Rpb25zIHdlcmUgcmVxdWVzdGVkLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIENvZGVBY3Rpb25UcmlnZ2VyS2luZDtcbihmdW5jdGlvbiAoQ29kZUFjdGlvblRyaWdnZXJLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQ29kZSBhY3Rpb25zIHdlcmUgZXhwbGljaXRseSByZXF1ZXN0ZWQgYnkgdGhlIHVzZXIgb3IgYnkgYW4gZXh0ZW5zaW9uLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25UcmlnZ2VyS2luZC5JbnZva2VkID0gMTtcbiAgICAvKipcbiAgICAgKiBDb2RlIGFjdGlvbnMgd2VyZSByZXF1ZXN0ZWQgYXV0b21hdGljYWxseS5cbiAgICAgKlxuICAgICAqIFRoaXMgdHlwaWNhbGx5IGhhcHBlbnMgd2hlbiBjdXJyZW50IHNlbGVjdGlvbiBpbiBhIGZpbGUgY2hhbmdlcywgYnV0IGNhblxuICAgICAqIGFsc28gYmUgdHJpZ2dlcmVkIHdoZW4gZmlsZSBjb250ZW50IGNoYW5nZXMuXG4gICAgICovXG4gICAgQ29kZUFjdGlvblRyaWdnZXJLaW5kLkF1dG9tYXRpYyA9IDI7XG59KShDb2RlQWN0aW9uVHJpZ2dlcktpbmQgfHwgKENvZGVBY3Rpb25UcmlnZ2VyS2luZCA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb2RlQWN0aW9uQ29udGV4dCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb2RlQWN0aW9uQ29udGV4dH0gbGl0ZXJhbHMuXG4gKi9cbnZhciBDb2RlQWN0aW9uQ29udGV4dDtcbihmdW5jdGlvbiAoQ29kZUFjdGlvbkNvbnRleHQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvZGVBY3Rpb25Db250ZXh0IGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGRpYWdub3N0aWNzLCBvbmx5LCB0cmlnZ2VyS2luZCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0geyBkaWFnbm9zdGljczogZGlhZ25vc3RpY3MgfTtcbiAgICAgICAgaWYgKG9ubHkgIT09IHVuZGVmaW5lZCAmJiBvbmx5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQub25seSA9IG9ubHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyaWdnZXJLaW5kICE9PSB1bmRlZmluZWQgJiYgdHJpZ2dlcktpbmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC50cmlnZ2VyS2luZCA9IHRyaWdnZXJLaW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIENvZGVBY3Rpb25Db250ZXh0LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIENvZGVBY3Rpb25Db250ZXh0fSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLmRpYWdub3N0aWNzLCBEaWFnbm9zdGljLmlzKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5vbmx5ID09PSB1bmRlZmluZWQgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUub25seSwgSXMuc3RyaW5nKSlcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUudHJpZ2dlcktpbmQgPT09IHVuZGVmaW5lZCB8fCBjYW5kaWRhdGUudHJpZ2dlcktpbmQgPT09IENvZGVBY3Rpb25UcmlnZ2VyS2luZC5JbnZva2VkIHx8IGNhbmRpZGF0ZS50cmlnZ2VyS2luZCA9PT0gQ29kZUFjdGlvblRyaWdnZXJLaW5kLkF1dG9tYXRpYyk7XG4gICAgfVxuICAgIENvZGVBY3Rpb25Db250ZXh0LmlzID0gaXM7XG59KShDb2RlQWN0aW9uQ29udGV4dCB8fCAoQ29kZUFjdGlvbkNvbnRleHQgPSB7fSkpO1xudmFyIENvZGVBY3Rpb247XG4oZnVuY3Rpb24gKENvZGVBY3Rpb24pIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUodGl0bGUsIGtpbmRPckNvbW1hbmRPckVkaXQsIGtpbmQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgdGl0bGU6IHRpdGxlIH07XG4gICAgICAgIHZhciBjaGVja0tpbmQgPSB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIGtpbmRPckNvbW1hbmRPckVkaXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjaGVja0tpbmQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0ga2luZE9yQ29tbWFuZE9yRWRpdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChDb21tYW5kLmlzKGtpbmRPckNvbW1hbmRPckVkaXQpKSB7XG4gICAgICAgICAgICByZXN1bHQuY29tbWFuZCA9IGtpbmRPckNvbW1hbmRPckVkaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuZWRpdCA9IGtpbmRPckNvbW1hbmRPckVkaXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoZWNrS2luZCAmJiBraW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0ga2luZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb2RlQWN0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS50aXRsZSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZGlhZ25vc3RpY3MgPT09IHVuZGVmaW5lZCB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5kaWFnbm9zdGljcywgRGlhZ25vc3RpYy5pcykpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmtpbmQgPT09IHVuZGVmaW5lZCB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmtpbmQpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5lZGl0ICE9PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLmNvbW1hbmQgIT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuY29tbWFuZCA9PT0gdW5kZWZpbmVkIHx8IENvbW1hbmQuaXMoY2FuZGlkYXRlLmNvbW1hbmQpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5pc1ByZWZlcnJlZCA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLmlzUHJlZmVycmVkKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZWRpdCA9PT0gdW5kZWZpbmVkIHx8IFdvcmtzcGFjZUVkaXQuaXMoY2FuZGlkYXRlLmVkaXQpKTtcbiAgICB9XG4gICAgQ29kZUFjdGlvbi5pcyA9IGlzO1xufSkoQ29kZUFjdGlvbiB8fCAoQ29kZUFjdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb2RlTGVucyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb2RlTGVuc30gbGl0ZXJhbHMuXG4gKi9cbnZhciBDb2RlTGVucztcbihmdW5jdGlvbiAoQ29kZUxlbnMpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvZGVMZW5zIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBkYXRhKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7IHJhbmdlOiByYW5nZSB9O1xuICAgICAgICBpZiAoSXMuZGVmaW5lZChkYXRhKSkge1xuICAgICAgICAgICAgcmVzdWx0LmRhdGEgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIENvZGVMZW5zLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIENvZGVMZW5zfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuY29tbWFuZCkgfHwgQ29tbWFuZC5pcyhjYW5kaWRhdGUuY29tbWFuZCkpO1xuICAgIH1cbiAgICBDb2RlTGVucy5pcyA9IGlzO1xufSkoQ29kZUxlbnMgfHwgKENvZGVMZW5zID0ge30pKTtcbi8qKlxuICogVGhlIEZvcm1hdHRpbmdPcHRpb25zIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIEZvcm1hdHRpbmdPcHRpb25zfSBsaXRlcmFscy5cbiAqL1xudmFyIEZvcm1hdHRpbmdPcHRpb25zO1xuKGZ1bmN0aW9uIChGb3JtYXR0aW5nT3B0aW9ucykge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRm9ybWF0dGluZ09wdGlvbnMgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodGFiU2l6ZSwgaW5zZXJ0U3BhY2VzKSB7XG4gICAgICAgIHJldHVybiB7IHRhYlNpemU6IHRhYlNpemUsIGluc2VydFNwYWNlczogaW5zZXJ0U3BhY2VzIH07XG4gICAgfVxuICAgIEZvcm1hdHRpbmdPcHRpb25zLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIEZvcm1hdHRpbmdPcHRpb25zfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS50YWJTaXplKSAmJiBJcy5ib29sZWFuKGNhbmRpZGF0ZS5pbnNlcnRTcGFjZXMpO1xuICAgIH1cbiAgICBGb3JtYXR0aW5nT3B0aW9ucy5pcyA9IGlzO1xufSkoRm9ybWF0dGluZ09wdGlvbnMgfHwgKEZvcm1hdHRpbmdPcHRpb25zID0ge30pKTtcbi8qKlxuICogVGhlIERvY3VtZW50TGluayBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBEb2N1bWVudExpbmt9IGxpdGVyYWxzLlxuICovXG52YXIgRG9jdW1lbnRMaW5rO1xuKGZ1bmN0aW9uIChEb2N1bWVudExpbmspIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IERvY3VtZW50TGluayBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgdGFyZ2V0LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiByYW5nZSwgdGFyZ2V0OiB0YXJnZXQsIGRhdGE6IGRhdGEgfTtcbiAgICB9XG4gICAgRG9jdW1lbnRMaW5rLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIERvY3VtZW50TGlua30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLnRhcmdldCkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS50YXJnZXQpKTtcbiAgICB9XG4gICAgRG9jdW1lbnRMaW5rLmlzID0gaXM7XG59KShEb2N1bWVudExpbmsgfHwgKERvY3VtZW50TGluayA9IHt9KSk7XG4vKipcbiAqIFRoZSBTZWxlY3Rpb25SYW5nZSBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9uIHRvIHdvcmsgd2l0aFxuICogU2VsZWN0aW9uUmFuZ2UgbGl0ZXJhbHMuXG4gKi9cbnZhciBTZWxlY3Rpb25SYW5nZTtcbihmdW5jdGlvbiAoU2VsZWN0aW9uUmFuZ2UpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNlbGVjdGlvblJhbmdlXG4gICAgICogQHBhcmFtIHJhbmdlIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0gcGFyZW50IGFuIG9wdGlvbmFsIHBhcmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIHBhcmVudCkge1xuICAgICAgICByZXR1cm4geyByYW5nZTogcmFuZ2UsIHBhcmVudDogcGFyZW50IH07XG4gICAgfVxuICAgIFNlbGVjdGlvblJhbmdlLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiAoY2FuZGlkYXRlLnBhcmVudCA9PT0gdW5kZWZpbmVkIHx8IFNlbGVjdGlvblJhbmdlLmlzKGNhbmRpZGF0ZS5wYXJlbnQpKTtcbiAgICB9XG4gICAgU2VsZWN0aW9uUmFuZ2UuaXMgPSBpcztcbn0pKFNlbGVjdGlvblJhbmdlIHx8IChTZWxlY3Rpb25SYW5nZSA9IHt9KSk7XG4vKipcbiAqIEEgc2V0IG9mIHByZWRlZmluZWQgdG9rZW4gdHlwZXMuIFRoaXMgc2V0IGlzIG5vdCBmaXhlZFxuICogYW4gY2xpZW50cyBjYW4gc3BlY2lmeSBhZGRpdGlvbmFsIHRva2VuIHR5cGVzIHZpYSB0aGVcbiAqIGNvcnJlc3BvbmRpbmcgY2xpZW50IGNhcGFiaWxpdGllcy5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBTZW1hbnRpY1Rva2VuVHlwZXM7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5UeXBlcykge1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcIm5hbWVzcGFjZVwiXSA9IFwibmFtZXNwYWNlXCI7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIGdlbmVyaWMgdHlwZS4gQWN0cyBhcyBhIGZhbGxiYWNrIGZvciB0eXBlcyB3aGljaCBjYW4ndCBiZSBtYXBwZWQgdG9cbiAgICAgKiBhIHNwZWNpZmljIHR5cGUgbGlrZSBjbGFzcyBvciBlbnVtLlxuICAgICAqL1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInR5cGVcIl0gPSBcInR5cGVcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJjbGFzc1wiXSA9IFwiY2xhc3NcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJlbnVtXCJdID0gXCJlbnVtXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiaW50ZXJmYWNlXCJdID0gXCJpbnRlcmZhY2VcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJzdHJ1Y3RcIl0gPSBcInN0cnVjdFwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInR5cGVQYXJhbWV0ZXJcIl0gPSBcInR5cGVQYXJhbWV0ZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJwYXJhbWV0ZXJcIl0gPSBcInBhcmFtZXRlclwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInZhcmlhYmxlXCJdID0gXCJ2YXJpYWJsZVwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInByb3BlcnR5XCJdID0gXCJwcm9wZXJ0eVwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImVudW1NZW1iZXJcIl0gPSBcImVudW1NZW1iZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJldmVudFwiXSA9IFwiZXZlbnRcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJmdW5jdGlvblwiXSA9IFwiZnVuY3Rpb25cIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJtZXRob2RcIl0gPSBcIm1ldGhvZFwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcIm1hY3JvXCJdID0gXCJtYWNyb1wiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImtleXdvcmRcIl0gPSBcImtleXdvcmRcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJtb2RpZmllclwiXSA9IFwibW9kaWZpZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJjb21tZW50XCJdID0gXCJjb21tZW50XCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wic3RyaW5nXCJdID0gXCJzdHJpbmdcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJudW1iZXJcIl0gPSBcIm51bWJlclwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInJlZ2V4cFwiXSA9IFwicmVnZXhwXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wib3BlcmF0b3JcIl0gPSBcIm9wZXJhdG9yXCI7XG4gICAgLyoqXG4gICAgICogQHNpbmNlIDMuMTcuMFxuICAgICAqL1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImRlY29yYXRvclwiXSA9IFwiZGVjb3JhdG9yXCI7XG59KShTZW1hbnRpY1Rva2VuVHlwZXMgfHwgKFNlbWFudGljVG9rZW5UeXBlcyA9IHt9KSk7XG4vKipcbiAqIEEgc2V0IG9mIHByZWRlZmluZWQgdG9rZW4gbW9kaWZpZXJzLiBUaGlzIHNldCBpcyBub3QgZml4ZWRcbiAqIGFuIGNsaWVudHMgY2FuIHNwZWNpZnkgYWRkaXRpb25hbCB0b2tlbiB0eXBlcyB2aWEgdGhlXG4gKiBjb3JyZXNwb25kaW5nIGNsaWVudCBjYXBhYmlsaXRpZXMuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgU2VtYW50aWNUb2tlbk1vZGlmaWVycztcbihmdW5jdGlvbiAoU2VtYW50aWNUb2tlbk1vZGlmaWVycykge1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJkZWNsYXJhdGlvblwiXSA9IFwiZGVjbGFyYXRpb25cIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiZGVmaW5pdGlvblwiXSA9IFwiZGVmaW5pdGlvblwiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJyZWFkb25seVwiXSA9IFwicmVhZG9ubHlcIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wic3RhdGljXCJdID0gXCJzdGF0aWNcIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiZGVwcmVjYXRlZFwiXSA9IFwiZGVwcmVjYXRlZFwiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJhYnN0cmFjdFwiXSA9IFwiYWJzdHJhY3RcIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiYXN5bmNcIl0gPSBcImFzeW5jXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcIm1vZGlmaWNhdGlvblwiXSA9IFwibW9kaWZpY2F0aW9uXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImRvY3VtZW50YXRpb25cIl0gPSBcImRvY3VtZW50YXRpb25cIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiZGVmYXVsdExpYnJhcnlcIl0gPSBcImRlZmF1bHRMaWJyYXJ5XCI7XG59KShTZW1hbnRpY1Rva2VuTW9kaWZpZXJzIHx8IChTZW1hbnRpY1Rva2VuTW9kaWZpZXJzID0ge30pKTtcbi8qKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgU2VtYW50aWNUb2tlbnM7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5zKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIChjYW5kaWRhdGUucmVzdWx0SWQgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgY2FuZGlkYXRlLnJlc3VsdElkID09PSAnc3RyaW5nJykgJiZcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoY2FuZGlkYXRlLmRhdGEpICYmIChjYW5kaWRhdGUuZGF0YS5sZW5ndGggPT09IDAgfHwgdHlwZW9mIGNhbmRpZGF0ZS5kYXRhWzBdID09PSAnbnVtYmVyJyk7XG4gICAgfVxuICAgIFNlbWFudGljVG9rZW5zLmlzID0gaXM7XG59KShTZW1hbnRpY1Rva2VucyB8fCAoU2VtYW50aWNUb2tlbnMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgSW5saW5lVmFsdWVUZXh0IG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoIElubGluZVZhbHVlVGV4dHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5saW5lVmFsdWVUZXh0O1xuKGZ1bmN0aW9uIChJbmxpbmVWYWx1ZVRleHQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElubGluZVZhbHVlVGV4dCBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgdGV4dCkge1xuICAgICAgICByZXR1cm4geyByYW5nZTogcmFuZ2UsIHRleHQ6IHRleHQgfTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVUZXh0LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnRleHQpO1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZVRleHQuaXMgPSBpcztcbn0pKElubGluZVZhbHVlVGV4dCB8fCAoSW5saW5lVmFsdWVUZXh0ID0ge30pKTtcbi8qKlxuICogVGhlIElubGluZVZhbHVlVmFyaWFibGVMb29rdXAgbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGggSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cDtcbihmdW5jdGlvbiAoSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgSW5saW5lVmFsdWVUZXh0IGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCB2YXJpYWJsZU5hbWUsIGNhc2VTZW5zaXRpdmVMb29rdXApIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLCB2YXJpYWJsZU5hbWU6IHZhcmlhYmxlTmFtZSwgY2FzZVNlbnNpdGl2ZUxvb2t1cDogY2FzZVNlbnNpdGl2ZUxvb2t1cCB9O1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiBJcy5ib29sZWFuKGNhbmRpZGF0ZS5jYXNlU2Vuc2l0aXZlTG9va3VwKVxuICAgICAgICAgICAgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUudmFyaWFibGVOYW1lKSB8fCBjYW5kaWRhdGUudmFyaWFibGVOYW1lID09PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwLmlzID0gaXM7XG59KShJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwIHx8IChJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwID0ge30pKTtcbi8qKlxuICogVGhlIElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uIG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoIElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uO1xuKGZ1bmN0aW9uIChJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24gbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIGV4cHJlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLCBleHByZXNzaW9uOiBleHByZXNzaW9uIH07XG4gICAgfVxuICAgIElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKVxuICAgICAgICAgICAgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUuZXhwcmVzc2lvbikgfHwgY2FuZGlkYXRlLmV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uLmlzID0gaXM7XG59KShJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbiB8fCAoSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgSW5saW5lVmFsdWVDb250ZXh0IG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIElubGluZVZhbHVlQ29udGV4dH0gbGl0ZXJhbHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5saW5lVmFsdWVDb250ZXh0O1xuKGZ1bmN0aW9uIChJbmxpbmVWYWx1ZUNvbnRleHQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElubGluZVZhbHVlQ29udGV4dCBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShmcmFtZUlkLCBzdG9wcGVkTG9jYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgZnJhbWVJZDogZnJhbWVJZCwgc3RvcHBlZExvY2F0aW9uOiBzdG9wcGVkTG9jYXRpb24gfTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVDb250ZXh0LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIElubGluZVZhbHVlQ29udGV4dH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyh2YWx1ZS5zdG9wcGVkTG9jYXRpb24pO1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZUNvbnRleHQuaXMgPSBpcztcbn0pKElubGluZVZhbHVlQ29udGV4dCB8fCAoSW5saW5lVmFsdWVDb250ZXh0ID0ge30pKTtcbi8qKlxuICogSW5sYXkgaGludCBraW5kcy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBJbmxheUhpbnRLaW5kO1xuKGZ1bmN0aW9uIChJbmxheUhpbnRLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQW4gaW5sYXkgaGludCB0aGF0IGZvciBhIHR5cGUgYW5ub3RhdGlvbi5cbiAgICAgKi9cbiAgICBJbmxheUhpbnRLaW5kLlR5cGUgPSAxO1xuICAgIC8qKlxuICAgICAqIEFuIGlubGF5IGhpbnQgdGhhdCBpcyBmb3IgYSBwYXJhbWV0ZXIuXG4gICAgICovXG4gICAgSW5sYXlIaW50S2luZC5QYXJhbWV0ZXIgPSAyO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMSB8fCB2YWx1ZSA9PT0gMjtcbiAgICB9XG4gICAgSW5sYXlIaW50S2luZC5pcyA9IGlzO1xufSkoSW5sYXlIaW50S2luZCB8fCAoSW5sYXlIaW50S2luZCA9IHt9KSk7XG52YXIgSW5sYXlIaW50TGFiZWxQYXJ0O1xuKGZ1bmN0aW9uIChJbmxheUhpbnRMYWJlbFBhcnQpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlIH07XG4gICAgfVxuICAgIElubGF5SGludExhYmVsUGFydC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnRvb2x0aXAgPT09IHVuZGVmaW5lZCB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLnRvb2x0aXApIHx8IE1hcmt1cENvbnRlbnQuaXMoY2FuZGlkYXRlLnRvb2x0aXApKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5sb2NhdGlvbiA9PT0gdW5kZWZpbmVkIHx8IExvY2F0aW9uLmlzKGNhbmRpZGF0ZS5sb2NhdGlvbikpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLmNvbW1hbmQgPT09IHVuZGVmaW5lZCB8fCBDb21tYW5kLmlzKGNhbmRpZGF0ZS5jb21tYW5kKSk7XG4gICAgfVxuICAgIElubGF5SGludExhYmVsUGFydC5pcyA9IGlzO1xufSkoSW5sYXlIaW50TGFiZWxQYXJ0IHx8IChJbmxheUhpbnRMYWJlbFBhcnQgPSB7fSkpO1xudmFyIElubGF5SGludDtcbihmdW5jdGlvbiAoSW5sYXlIaW50KSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHBvc2l0aW9uLCBsYWJlbCwga2luZCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0geyBwb3NpdGlvbjogcG9zaXRpb24sIGxhYmVsOiBsYWJlbCB9O1xuICAgICAgICBpZiAoa2luZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGtpbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgSW5sYXlIaW50LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUG9zaXRpb24uaXMoY2FuZGlkYXRlLnBvc2l0aW9uKVxuICAgICAgICAgICAgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUubGFiZWwpIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLmxhYmVsLCBJbmxheUhpbnRMYWJlbFBhcnQuaXMpKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5raW5kID09PSB1bmRlZmluZWQgfHwgSW5sYXlIaW50S2luZC5pcyhjYW5kaWRhdGUua2luZCkpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnRleHRFZGl0cyA9PT0gdW5kZWZpbmVkKSB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS50ZXh0RWRpdHMsIFRleHRFZGl0LmlzKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS50b29sdGlwID09PSB1bmRlZmluZWQgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS50b29sdGlwKSB8fCBNYXJrdXBDb250ZW50LmlzKGNhbmRpZGF0ZS50b29sdGlwKSlcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUucGFkZGluZ0xlZnQgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5wYWRkaW5nTGVmdCkpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnBhZGRpbmdSaWdodCA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLnBhZGRpbmdSaWdodCkpO1xuICAgIH1cbiAgICBJbmxheUhpbnQuaXMgPSBpcztcbn0pKElubGF5SGludCB8fCAoSW5sYXlIaW50ID0ge30pKTtcbnZhciBXb3Jrc3BhY2VGb2xkZXI7XG4oZnVuY3Rpb24gKFdvcmtzcGFjZUZvbGRlcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBVUkkuaXMoY2FuZGlkYXRlLnVyaSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uYW1lKTtcbiAgICB9XG4gICAgV29ya3NwYWNlRm9sZGVyLmlzID0gaXM7XG59KShXb3Jrc3BhY2VGb2xkZXIgfHwgKFdvcmtzcGFjZUZvbGRlciA9IHt9KSk7XG52YXIgRU9MID0gWydcXG4nLCAnXFxyXFxuJywgJ1xcciddO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgdGhlIHRleHQgZG9jdW1lbnQgZnJvbSB0aGUgbmV3IHZzY29kZS1sYW5ndWFnZXNlcnZlci10ZXh0ZG9jdW1lbnQgcGFja2FnZS5cbiAqL1xudmFyIFRleHREb2N1bWVudDtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBJVGV4dERvY3VtZW50IGxpdGVyYWwgZnJvbSB0aGUgZ2l2ZW4gdXJpIGFuZCBjb250ZW50LlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqIEBwYXJhbSBsYW5ndWFnZUlkIFRoZSBkb2N1bWVudCdzIGxhbmd1YWdlIElkLlxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIFRoZSBkb2N1bWVudCdzIHZlcnNpb24uXG4gICAgICogQHBhcmFtIGNvbnRlbnQgVGhlIGRvY3VtZW50J3MgY29udGVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCBsYW5ndWFnZUlkLCB2ZXJzaW9uLCBjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVsbFRleHREb2N1bWVudCh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgSVRleHREb2N1bWVudH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUubGFuZ3VhZ2VJZCkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYW5ndWFnZUlkKSkgJiYgSXMudWludGVnZXIoY2FuZGlkYXRlLmxpbmVDb3VudClcbiAgICAgICAgICAgICYmIElzLmZ1bmMoY2FuZGlkYXRlLmdldFRleHQpICYmIElzLmZ1bmMoY2FuZGlkYXRlLnBvc2l0aW9uQXQpICYmIElzLmZ1bmMoY2FuZGlkYXRlLm9mZnNldEF0KSA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50LmlzID0gaXM7XG4gICAgZnVuY3Rpb24gYXBwbHlFZGl0cyhkb2N1bWVudCwgZWRpdHMpIHtcbiAgICAgICAgdmFyIHRleHQgPSBkb2N1bWVudC5nZXRUZXh0KCk7XG4gICAgICAgIHZhciBzb3J0ZWRFZGl0cyA9IG1lcmdlU29ydChlZGl0cywgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBkaWZmID0gYS5yYW5nZS5zdGFydC5saW5lIC0gYi5yYW5nZS5zdGFydC5saW5lO1xuICAgICAgICAgICAgaWYgKGRpZmYgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5yYW5nZS5zdGFydC5jaGFyYWN0ZXIgLSBiLnJhbmdlLnN0YXJ0LmNoYXJhY3RlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxhc3RNb2RpZmllZE9mZnNldCA9IHRleHQubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gc29ydGVkRWRpdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBlID0gc29ydGVkRWRpdHNbaV07XG4gICAgICAgICAgICB2YXIgc3RhcnRPZmZzZXQgPSBkb2N1bWVudC5vZmZzZXRBdChlLnJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgIHZhciBlbmRPZmZzZXQgPSBkb2N1bWVudC5vZmZzZXRBdChlLnJhbmdlLmVuZCk7XG4gICAgICAgICAgICBpZiAoZW5kT2Zmc2V0IDw9IGxhc3RNb2RpZmllZE9mZnNldCkge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydE9mZnNldCkgKyBlLm5ld1RleHQgKyB0ZXh0LnN1YnN0cmluZyhlbmRPZmZzZXQsIHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3ZlcmxhcHBpbmcgZWRpdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdE1vZGlmaWVkT2Zmc2V0ID0gc3RhcnRPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIFRleHREb2N1bWVudC5hcHBseUVkaXRzID0gYXBwbHlFZGl0cztcbiAgICBmdW5jdGlvbiBtZXJnZVNvcnQoZGF0YSwgY29tcGFyZSkge1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgLy8gc29ydGVkXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcCA9IChkYXRhLmxlbmd0aCAvIDIpIHwgMDtcbiAgICAgICAgdmFyIGxlZnQgPSBkYXRhLnNsaWNlKDAsIHApO1xuICAgICAgICB2YXIgcmlnaHQgPSBkYXRhLnNsaWNlKHApO1xuICAgICAgICBtZXJnZVNvcnQobGVmdCwgY29tcGFyZSk7XG4gICAgICAgIG1lcmdlU29ydChyaWdodCwgY29tcGFyZSk7XG4gICAgICAgIHZhciBsZWZ0SWR4ID0gMDtcbiAgICAgICAgdmFyIHJpZ2h0SWR4ID0gMDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAobGVmdElkeCA8IGxlZnQubGVuZ3RoICYmIHJpZ2h0SWR4IDwgcmlnaHQubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gY29tcGFyZShsZWZ0W2xlZnRJZHhdLCByaWdodFtyaWdodElkeF0pO1xuICAgICAgICAgICAgaWYgKHJldCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gc21hbGxlcl9lcXVhbCAtPiB0YWtlIGxlZnQgdG8gcHJlc2VydmUgb3JkZXJcbiAgICAgICAgICAgICAgICBkYXRhW2krK10gPSBsZWZ0W2xlZnRJZHgrK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBncmVhdGVyIC0+IHRha2UgcmlnaHRcbiAgICAgICAgICAgICAgICBkYXRhW2krK10gPSByaWdodFtyaWdodElkeCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobGVmdElkeCA8IGxlZnQubGVuZ3RoKSB7XG4gICAgICAgICAgICBkYXRhW2krK10gPSBsZWZ0W2xlZnRJZHgrK107XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHJpZ2h0SWR4IDwgcmlnaHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBkYXRhW2krK10gPSByaWdodFtyaWdodElkeCsrXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG59KShUZXh0RG9jdW1lbnQgfHwgKFRleHREb2N1bWVudCA9IHt9KSk7XG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSB0aGUgdGV4dCBkb2N1bWVudCBmcm9tIHRoZSBuZXcgdnNjb2RlLWxhbmd1YWdlc2VydmVyLXRleHRkb2N1bWVudCBwYWNrYWdlLlxuICovXG52YXIgRnVsbFRleHREb2N1bWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGdWxsVGV4dERvY3VtZW50KHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCkge1xuICAgICAgICB0aGlzLl91cmkgPSB1cmk7XG4gICAgICAgIHRoaXMuX2xhbmd1YWdlSWQgPSBsYW5ndWFnZUlkO1xuICAgICAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUsIFwidXJpXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXJpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLCBcImxhbmd1YWdlSWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYW5ndWFnZUlkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLCBcInZlcnNpb25cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92ZXJzaW9uO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMub2Zmc2V0QXQocmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IHRoaXMub2Zmc2V0QXQocmFuZ2UuZW5kKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50LnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudDtcbiAgICB9O1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChldmVudCwgdmVyc2lvbikge1xuICAgICAgICB0aGlzLl9jb250ZW50ID0gZXZlbnQudGV4dDtcbiAgICAgICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUuZ2V0TGluZU9mZnNldHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9saW5lT2Zmc2V0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgbGluZU9mZnNldHMgPSBbXTtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5fY29udGVudDtcbiAgICAgICAgICAgIHZhciBpc0xpbmVTdGFydCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNMaW5lU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZU9mZnNldHMucHVzaChpKTtcbiAgICAgICAgICAgICAgICAgICAgaXNMaW5lU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNoID0gdGV4dC5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgaXNMaW5lU3RhcnQgPSAoY2ggPT09ICdcXHInIHx8IGNoID09PSAnXFxuJyk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBpICsgMSA8IHRleHQubGVuZ3RoICYmIHRleHQuY2hhckF0KGkgKyAxKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0xpbmVTdGFydCAmJiB0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsaW5lT2Zmc2V0cy5wdXNoKHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gbGluZU9mZnNldHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVPZmZzZXRzO1xuICAgIH07XG4gICAgRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUucG9zaXRpb25BdCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgoTWF0aC5taW4ob2Zmc2V0LCB0aGlzLl9jb250ZW50Lmxlbmd0aCksIDApO1xuICAgICAgICB2YXIgbGluZU9mZnNldHMgPSB0aGlzLmdldExpbmVPZmZzZXRzKCk7XG4gICAgICAgIHZhciBsb3cgPSAwLCBoaWdoID0gbGluZU9mZnNldHMubGVuZ3RoO1xuICAgICAgICBpZiAoaGlnaCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFBvc2l0aW9uLmNyZWF0ZSgwLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgICB2YXIgbWlkID0gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgICAgICAgIGlmIChsaW5lT2Zmc2V0c1ttaWRdID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG93IGlzIHRoZSBsZWFzdCB4IGZvciB3aGljaCB0aGUgbGluZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gdGhlIGN1cnJlbnQgb2Zmc2V0XG4gICAgICAgIC8vIG9yIGFycmF5Lmxlbmd0aCBpZiBubyBsaW5lIG9mZnNldCBpcyBsYXJnZXIgdGhhbiB0aGUgY3VycmVudCBvZmZzZXRcbiAgICAgICAgdmFyIGxpbmUgPSBsb3cgLSAxO1xuICAgICAgICByZXR1cm4gUG9zaXRpb24uY3JlYXRlKGxpbmUsIG9mZnNldCAtIGxpbmVPZmZzZXRzW2xpbmVdKTtcbiAgICB9O1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLm9mZnNldEF0ID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBsaW5lT2Zmc2V0cyA9IHRoaXMuZ2V0TGluZU9mZnNldHMoKTtcbiAgICAgICAgaWYgKHBvc2l0aW9uLmxpbmUgPj0gbGluZU9mZnNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocG9zaXRpb24ubGluZSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaW5lT2Zmc2V0ID0gbGluZU9mZnNldHNbcG9zaXRpb24ubGluZV07XG4gICAgICAgIHZhciBuZXh0TGluZU9mZnNldCA9IChwb3NpdGlvbi5saW5lICsgMSA8IGxpbmVPZmZzZXRzLmxlbmd0aCkgPyBsaW5lT2Zmc2V0c1twb3NpdGlvbi5saW5lICsgMV0gOiB0aGlzLl9jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKGxpbmVPZmZzZXQgKyBwb3NpdGlvbi5jaGFyYWN0ZXIsIG5leHRMaW5lT2Zmc2V0KSwgbGluZU9mZnNldCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUsIFwibGluZUNvdW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMaW5lT2Zmc2V0cygpLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBGdWxsVGV4dERvY3VtZW50O1xufSgpKTtcbnZhciBJcztcbihmdW5jdGlvbiAoSXMpIHtcbiAgICB2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuICAgIGZ1bmN0aW9uIGRlZmluZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuICAgIElzLmRlZmluZWQgPSBkZWZpbmVkO1xuICAgIGZ1bmN0aW9uIHVuZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcbiAgICB9XG4gICAgSXMudW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIGZ1bmN0aW9uIGJvb2xlYW4odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZTtcbiAgICB9XG4gICAgSXMuYm9vbGVhbiA9IGJvb2xlYW47XG4gICAgZnVuY3Rpb24gc3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG4gICAgfVxuICAgIElzLnN0cmluZyA9IHN0cmluZztcbiAgICBmdW5jdGlvbiBudW1iZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJztcbiAgICB9XG4gICAgSXMubnVtYmVyID0gbnVtYmVyO1xuICAgIGZ1bmN0aW9uIG51bWJlclJhbmdlKHZhbHVlLCBtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmIG1pbiA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSBtYXg7XG4gICAgfVxuICAgIElzLm51bWJlclJhbmdlID0gbnVtYmVyUmFuZ2U7XG4gICAgZnVuY3Rpb24gaW50ZWdlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmIC0yMTQ3NDgzNjQ4IDw9IHZhbHVlICYmIHZhbHVlIDw9IDIxNDc0ODM2NDc7XG4gICAgfVxuICAgIElzLmludGVnZXIgPSBpbnRlZ2VyO1xuICAgIGZ1bmN0aW9uIHVpbnRlZ2VyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgTnVtYmVyXScgJiYgMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSAyMTQ3NDgzNjQ3O1xuICAgIH1cbiAgICBJcy51aW50ZWdlciA9IHVpbnRlZ2VyO1xuICAgIGZ1bmN0aW9uIGZ1bmModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICAgIH1cbiAgICBJcy5mdW5jID0gZnVuYztcbiAgICBmdW5jdGlvbiBvYmplY3RMaXRlcmFsKHZhbHVlKSB7XG4gICAgICAgIC8vIFN0cmljdGx5IHNwZWFraW5nIGNsYXNzIGluc3RhbmNlcyBwYXNzIHRoaXMgY2hlY2sgYXMgd2VsbC4gU2luY2UgdGhlIExTUFxuICAgICAgICAvLyBkb2Vzbid0IHVzZSBjbGFzc2VzIHdlIGlnbm9yZSB0aGlzIGZvciBub3cuIElmIHdlIGRvIHdlIG5lZWQgdG8gYWRkIHNvbWV0aGluZ1xuICAgICAgICAvLyBsaWtlIHRoaXM6IGBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqZWN0LmdldFByb3RvdHlwZU9mKHgpKSA9PT0gbnVsbGBcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG4gICAgfVxuICAgIElzLm9iamVjdExpdGVyYWwgPSBvYmplY3RMaXRlcmFsO1xuICAgIGZ1bmN0aW9uIHR5cGVkQXJyYXkodmFsdWUsIGNoZWNrKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShjaGVjayk7XG4gICAgfVxuICAgIElzLnR5cGVkQXJyYXkgPSB0eXBlZEFycmF5O1xufSkoSXMgfHwgKElzID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjA5NDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGZvckVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyNDMpO1xudmFyIGF2YWlsYWJsZVR5cGVkQXJyYXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTkxKTtcbnZhciBjYWxsQmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oOTQyOSk7XG52YXIgY2FsbEJvdW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjgwKTtcbnZhciBnT1BEID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMjYpO1xuXG52YXIgJHRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJyk7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyMjYpKCk7XG5cbnZhciBnID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX3JlcXVpcmVfXy5nIDogZ2xvYmFsVGhpcztcbnZhciB0eXBlZEFycmF5cyA9IGF2YWlsYWJsZVR5cGVkQXJyYXlzKCk7XG5cbnZhciAkc2xpY2UgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUuc2xpY2UnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjsgLy8gcmVxdWlyZSgnZ2V0cHJvdG90eXBlb2YnKTtcblxudmFyICRpbmRleE9mID0gY2FsbEJvdW5kKCdBcnJheS5wcm90b3R5cGUuaW5kZXhPZicsIHRydWUpIHx8IGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRpZiAoYXJyYXlbaV0gPT09IHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gaTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIC0xO1xufTtcbnZhciBjYWNoZSA9IHsgX19wcm90b19fOiBudWxsIH07XG5pZiAoaGFzVG9TdHJpbmdUYWcgJiYgZ09QRCAmJiBnZXRQcm90b3R5cGVPZikge1xuXHRmb3JFYWNoKHR5cGVkQXJyYXlzLCBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuXHRcdHZhciBhcnIgPSBuZXcgZ1t0eXBlZEFycmF5XSgpO1xuXHRcdGlmIChTeW1ib2wudG9TdHJpbmdUYWcgaW4gYXJyKSB7XG5cdFx0XHR2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihhcnIpO1xuXHRcdFx0dmFyIGRlc2NyaXB0b3IgPSBnT1BEKHByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0aWYgKCFkZXNjcmlwdG9yKSB7XG5cdFx0XHRcdHZhciBzdXBlclByb3RvID0gZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuXHRcdFx0XHRkZXNjcmlwdG9yID0gZ09QRChzdXBlclByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0fVxuXHRcdFx0Y2FjaGVbJyQnICsgdHlwZWRBcnJheV0gPSBjYWxsQmluZChkZXNjcmlwdG9yLmdldCk7XG5cdFx0fVxuXHR9KTtcbn0gZWxzZSB7XG5cdGZvckVhY2godHlwZWRBcnJheXMsIGZ1bmN0aW9uICh0eXBlZEFycmF5KSB7XG5cdFx0dmFyIGFyciA9IG5ldyBnW3R5cGVkQXJyYXldKCk7XG5cdFx0Y2FjaGVbJyQnICsgdHlwZWRBcnJheV0gPSBjYWxsQmluZChhcnIuc2xpY2UpO1xuXHR9KTtcbn1cblxudmFyIHRyeVR5cGVkQXJyYXlzID0gZnVuY3Rpb24gdHJ5QWxsVHlwZWRBcnJheXModmFsdWUpIHtcblx0dmFyIGZvdW5kID0gZmFsc2U7XG5cdGZvckVhY2goY2FjaGUsIGZ1bmN0aW9uIChnZXR0ZXIsIHR5cGVkQXJyYXkpIHtcblx0XHRpZiAoIWZvdW5kKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoJyQnICsgZ2V0dGVyKHZhbHVlKSA9PT0gdHlwZWRBcnJheSkge1xuXHRcdFx0XHRcdGZvdW5kID0gJHNsaWNlKHR5cGVkQXJyYXksIDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7IC8qKi8gfVxuXHRcdH1cblx0fSk7XG5cdHJldHVybiBmb3VuZDtcbn07XG5cbnZhciB0cnlTbGljZXMgPSBmdW5jdGlvbiB0cnlBbGxTbGljZXModmFsdWUpIHtcblx0dmFyIGZvdW5kID0gZmFsc2U7XG5cdGZvckVhY2goY2FjaGUsIGZ1bmN0aW9uIChnZXR0ZXIsIG5hbWUpIHtcblx0XHRpZiAoIWZvdW5kKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRnZXR0ZXIodmFsdWUpO1xuXHRcdFx0XHRmb3VuZCA9ICRzbGljZShuYW1lLCAxKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHsgLyoqLyB9XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGZvdW5kO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB3aGljaFR5cGVkQXJyYXkodmFsdWUpIHtcblx0aWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnKSB7XG5cdFx0dmFyIHRhZyA9ICRzbGljZSgkdG9TdHJpbmcodmFsdWUpLCA4LCAtMSk7XG5cdFx0aWYgKCRpbmRleE9mKHR5cGVkQXJyYXlzLCB0YWcpID4gLTEpIHtcblx0XHRcdHJldHVybiB0YWc7XG5cdFx0fVxuXHRcdGlmICh0YWcgIT09ICdPYmplY3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdC8vIG5vZGUgPCAwLjYgaGl0cyBoZXJlIG9uIHJlYWwgVHlwZWQgQXJyYXlzXG5cdFx0cmV0dXJuIHRyeVNsaWNlcyh2YWx1ZSk7XG5cdH1cblx0aWYgKCFnT1BEKSB7IHJldHVybiBudWxsOyB9IC8vIHVua25vd24gZW5naW5lXG5cdHJldHVybiB0cnlUeXBlZEFycmF5cyh2YWx1ZSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyMTkxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgcG9zc2libGVOYW1lcyA9IFtcblx0J0JpZ0ludDY0QXJyYXknLFxuXHQnQmlnVWludDY0QXJyYXknLFxuXHQnRmxvYXQzMkFycmF5Jyxcblx0J0Zsb2F0NjRBcnJheScsXG5cdCdJbnQxNkFycmF5Jyxcblx0J0ludDMyQXJyYXknLFxuXHQnSW50OEFycmF5Jyxcblx0J1VpbnQxNkFycmF5Jyxcblx0J1VpbnQzMkFycmF5Jyxcblx0J1VpbnQ4QXJyYXknLFxuXHQnVWludDhDbGFtcGVkQXJyYXknXG5dO1xuXG52YXIgZyA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19yZXF1aXJlX18uZyA6IGdsb2JhbFRoaXM7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXZhaWxhYmxlVHlwZWRBcnJheXMoKSB7XG5cdHZhciBvdXQgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwb3NzaWJsZU5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKHR5cGVvZiBnW3Bvc3NpYmxlTmFtZXNbaV1dID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRvdXRbb3V0Lmxlbmd0aF0gPSBwb3NzaWJsZU5hbWVzW2ldO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gb3V0O1xufTtcblxuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcbi8qKioqKiovIFx0XHRcdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcbi8qKioqKiovIFx0XHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG4vKioqKioqLyBcdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcbi8qKioqKiovIFx0XHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuLyoqKioqKi8gXHRcdFx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG4vKioqKioqLyBcdFx0XHR0cnkge1xuLyoqKioqKi8gXHRcdFx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbi8qKioqKiovIFx0XHRcdH0gY2F0Y2ggKGUpIHtcbi8qKioqKiovIFx0XHRcdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdH0pKCk7XG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKVxuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuLyoqKioqKi8gXHRcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IHt9O1xuLy8gVGhpcyBlbnRyeSBuZWVkIHRvIGJlIHdyYXBwZWQgaW4gYW4gSUlGRSBiZWNhdXNlIGl0IG5lZWQgdG8gYmUgaW4gc3RyaWN0IG1vZGUuXG4oKCkgPT4ge1xuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBFU00gQ09NUEFUIEZMQUdcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbiAgSnNvblNlcnZpY2U6ICgpID0+ICgvKiBiaW5kaW5nICovIEpzb25TZXJ2aWNlKVxufSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvc2VydmljZXMvYmFzZS1zZXJ2aWNlLnRzXG52YXIgYmFzZV9zZXJ2aWNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NDg3KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvanNvbmMtcGFyc2VyL2xpYi9lc20vaW1wbC9zY2FubmVyLmpzXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgSlNPTiBzY2FubmVyIG9uIHRoZSBnaXZlbiB0ZXh0LlxuICogSWYgaWdub3JlVHJpdmlhIGlzIHNldCwgd2hpdGVzcGFjZXMgb3IgY29tbWVudHMgYXJlIGlnbm9yZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNjYW5uZXIodGV4dCwgaWdub3JlVHJpdmlhID0gZmFsc2UpIHtcbiAgICBjb25zdCBsZW4gPSB0ZXh0Lmxlbmd0aDtcbiAgICBsZXQgcG9zID0gMCwgdmFsdWUgPSAnJywgdG9rZW5PZmZzZXQgPSAwLCB0b2tlbiA9IDE2IC8qIFN5bnRheEtpbmQuVW5rbm93biAqLywgbGluZU51bWJlciA9IDAsIGxpbmVTdGFydE9mZnNldCA9IDAsIHRva2VuTGluZVN0YXJ0T2Zmc2V0ID0gMCwgcHJldlRva2VuTGluZVN0YXJ0T2Zmc2V0ID0gMCwgc2NhbkVycm9yID0gMCAvKiBTY2FuRXJyb3IuTm9uZSAqLztcbiAgICBmdW5jdGlvbiBzY2FuSGV4RGlnaXRzKGNvdW50LCBleGFjdCkge1xuICAgICAgICBsZXQgZGlnaXRzID0gMDtcbiAgICAgICAgbGV0IHZhbHVlID0gMDtcbiAgICAgICAgd2hpbGUgKGRpZ2l0cyA8IGNvdW50IHx8ICFleGFjdCkge1xuICAgICAgICAgICAgbGV0IGNoID0gdGV4dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAoY2ggPj0gNDggLyogQ2hhcmFjdGVyQ29kZXMuXzAgKi8gJiYgY2ggPD0gNTcgLyogQ2hhcmFjdGVyQ29kZXMuXzkgKi8pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICogMTYgKyBjaCAtIDQ4IC8qIENoYXJhY3RlckNvZGVzLl8wICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPj0gNjUgLyogQ2hhcmFjdGVyQ29kZXMuQSAqLyAmJiBjaCA8PSA3MCAvKiBDaGFyYWN0ZXJDb2Rlcy5GICovKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAqIDE2ICsgY2ggLSA2NSAvKiBDaGFyYWN0ZXJDb2Rlcy5BICovICsgMTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaCA+PSA5NyAvKiBDaGFyYWN0ZXJDb2Rlcy5hICovICYmIGNoIDw9IDEwMiAvKiBDaGFyYWN0ZXJDb2Rlcy5mICovKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAqIDE2ICsgY2ggLSA5NyAvKiBDaGFyYWN0ZXJDb2Rlcy5hICovICsgMTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgZGlnaXRzKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpZ2l0cyA8IGNvdW50KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0UG9zaXRpb24obmV3UG9zaXRpb24pIHtcbiAgICAgICAgcG9zID0gbmV3UG9zaXRpb247XG4gICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgIHRva2VuT2Zmc2V0ID0gMDtcbiAgICAgICAgdG9rZW4gPSAxNiAvKiBTeW50YXhLaW5kLlVua25vd24gKi87XG4gICAgICAgIHNjYW5FcnJvciA9IDAgLyogU2NhbkVycm9yLk5vbmUgKi87XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYW5OdW1iZXIoKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHBvcztcbiAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChwb3MpID09PSA0OCAvKiBDaGFyYWN0ZXJDb2Rlcy5fMCAqLykge1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPCB0ZXh0Lmxlbmd0aCAmJiBpc0RpZ2l0KHRleHQuY2hhckNvZGVBdChwb3MpKSkge1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0LmNoYXJDb2RlQXQocG9zKSA9PT0gNDYgLyogQ2hhcmFjdGVyQ29kZXMuZG90ICovKSB7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIGlmIChwb3MgPCB0ZXh0Lmxlbmd0aCAmJiBpc0RpZ2l0KHRleHQuY2hhckNvZGVBdChwb3MpKSkge1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIHdoaWxlIChwb3MgPCB0ZXh0Lmxlbmd0aCAmJiBpc0RpZ2l0KHRleHQuY2hhckNvZGVBdChwb3MpKSkge1xuICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY2FuRXJyb3IgPSAzIC8qIFNjYW5FcnJvci5VbmV4cGVjdGVkRW5kT2ZOdW1iZXIgKi87XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBlbmQgPSBwb3M7XG4gICAgICAgIGlmIChwb3MgPCB0ZXh0Lmxlbmd0aCAmJiAodGV4dC5jaGFyQ29kZUF0KHBvcykgPT09IDY5IC8qIENoYXJhY3RlckNvZGVzLkUgKi8gfHwgdGV4dC5jaGFyQ29kZUF0KHBvcykgPT09IDEwMSAvKiBDaGFyYWN0ZXJDb2Rlcy5lICovKSkge1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICBpZiAocG9zIDwgdGV4dC5sZW5ndGggJiYgdGV4dC5jaGFyQ29kZUF0KHBvcykgPT09IDQzIC8qIENoYXJhY3RlckNvZGVzLnBsdXMgKi8gfHwgdGV4dC5jaGFyQ29kZUF0KHBvcykgPT09IDQ1IC8qIENoYXJhY3RlckNvZGVzLm1pbnVzICovKSB7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zIDwgdGV4dC5sZW5ndGggJiYgaXNEaWdpdCh0ZXh0LmNoYXJDb2RlQXQocG9zKSkpIHtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB3aGlsZSAocG9zIDwgdGV4dC5sZW5ndGggJiYgaXNEaWdpdCh0ZXh0LmNoYXJDb2RlQXQocG9zKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVuZCA9IHBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjYW5FcnJvciA9IDMgLyogU2NhbkVycm9yLlVuZXhwZWN0ZWRFbmRPZk51bWJlciAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYW5TdHJpbmcoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSAnJywgc3RhcnQgPSBwb3M7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAocG9zID49IGxlbikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0ZXh0LnN1YnN0cmluZyhzdGFydCwgcG9zKTtcbiAgICAgICAgICAgICAgICBzY2FuRXJyb3IgPSAyIC8qIFNjYW5FcnJvci5VbmV4cGVjdGVkRW5kT2ZTdHJpbmcgKi87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjaCA9IHRleHQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKGNoID09PSAzNCAvKiBDaGFyYWN0ZXJDb2Rlcy5kb3VibGVRdW90ZSAqLykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0ZXh0LnN1YnN0cmluZyhzdGFydCwgcG9zKTtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaCA9PT0gOTIgLyogQ2hhcmFjdGVyQ29kZXMuYmFja3NsYXNoICovKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBwb3MpO1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjYW5FcnJvciA9IDIgLyogU2NhbkVycm9yLlVuZXhwZWN0ZWRFbmRPZlN0cmluZyAqLztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNoMiA9IHRleHQuY2hhckNvZGVBdChwb3MrKyk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjaDIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzNCAvKiBDaGFyYWN0ZXJDb2Rlcy5kb3VibGVRdW90ZSAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxcIic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5MiAvKiBDaGFyYWN0ZXJDb2Rlcy5iYWNrc2xhc2ggKi86XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcXFwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDcgLyogQ2hhcmFjdGVyQ29kZXMuc2xhc2ggKi86XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJy8nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTggLyogQ2hhcmFjdGVyQ29kZXMuYiAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxiJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEwMiAvKiBDaGFyYWN0ZXJDb2Rlcy5mICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXGYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTEwIC8qIENoYXJhY3RlckNvZGVzLm4gKi86XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTQgLyogQ2hhcmFjdGVyQ29kZXMuciAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxyJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExNiAvKiBDaGFyYWN0ZXJDb2Rlcy50ICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTE3IC8qIENoYXJhY3RlckNvZGVzLnUgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaDMgPSBzY2FuSGV4RGlnaXRzKDQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoMyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYW5FcnJvciA9IDQgLyogU2NhbkVycm9yLkludmFsaWRVbmljb2RlICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FuRXJyb3IgPSA1IC8qIFNjYW5FcnJvci5JbnZhbGlkRXNjYXBlQ2hhcmFjdGVyICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFydCA9IHBvcztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaCA+PSAwICYmIGNoIDw9IDB4MWYpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNMaW5lQnJlYWsoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0ZXh0LnN1YnN0cmluZyhzdGFydCwgcG9zKTtcbiAgICAgICAgICAgICAgICAgICAgc2NhbkVycm9yID0gMiAvKiBTY2FuRXJyb3IuVW5leHBlY3RlZEVuZE9mU3RyaW5nICovO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNjYW5FcnJvciA9IDYgLyogU2NhbkVycm9yLkludmFsaWRDaGFyYWN0ZXIgKi87XG4gICAgICAgICAgICAgICAgICAgIC8vIG1hcmsgYXMgZXJyb3IgYnV0IGNvbnRpbnVlIHdpdGggc3RyaW5nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2Nhbk5leHQoKSB7XG4gICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgIHNjYW5FcnJvciA9IDAgLyogU2NhbkVycm9yLk5vbmUgKi87XG4gICAgICAgIHRva2VuT2Zmc2V0ID0gcG9zO1xuICAgICAgICBsaW5lU3RhcnRPZmZzZXQgPSBsaW5lTnVtYmVyO1xuICAgICAgICBwcmV2VG9rZW5MaW5lU3RhcnRPZmZzZXQgPSB0b2tlbkxpbmVTdGFydE9mZnNldDtcbiAgICAgICAgaWYgKHBvcyA+PSBsZW4pIHtcbiAgICAgICAgICAgIC8vIGF0IHRoZSBlbmRcbiAgICAgICAgICAgIHRva2VuT2Zmc2V0ID0gbGVuO1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gMTcgLyogU3ludGF4S2luZC5FT0YgKi87XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgLy8gdHJpdmlhOiB3aGl0ZXNwYWNlXG4gICAgICAgIGlmIChpc1doaXRlU3BhY2UoY29kZSkpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgICAgIGNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGlzV2hpdGVTcGFjZShjb2RlKSk7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW4gPSAxNSAvKiBTeW50YXhLaW5kLlRyaXZpYSAqLztcbiAgICAgICAgfVxuICAgICAgICAvLyB0cml2aWE6IG5ld2xpbmVzXG4gICAgICAgIGlmIChpc0xpbmVCcmVhayhjb2RlKSkge1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB2YWx1ZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgaWYgKGNvZGUgPT09IDEzIC8qIENoYXJhY3RlckNvZGVzLmNhcnJpYWdlUmV0dXJuICovICYmIHRleHQuY2hhckNvZGVBdChwb3MpID09PSAxMCAvKiBDaGFyYWN0ZXJDb2Rlcy5saW5lRmVlZCAqLykge1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIHZhbHVlICs9ICdcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGluZU51bWJlcisrO1xuICAgICAgICAgICAgdG9rZW5MaW5lU3RhcnRPZmZzZXQgPSBwb3M7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW4gPSAxNCAvKiBTeW50YXhLaW5kLkxpbmVCcmVha1RyaXZpYSAqLztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgIC8vIHRva2VuczogW117fTosXG4gICAgICAgICAgICBjYXNlIDEyMyAvKiBDaGFyYWN0ZXJDb2Rlcy5vcGVuQnJhY2UgKi86XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gMSAvKiBTeW50YXhLaW5kLk9wZW5CcmFjZVRva2VuICovO1xuICAgICAgICAgICAgY2FzZSAxMjUgLyogQ2hhcmFjdGVyQ29kZXMuY2xvc2VCcmFjZSAqLzpcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSAyIC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICovO1xuICAgICAgICAgICAgY2FzZSA5MSAvKiBDaGFyYWN0ZXJDb2Rlcy5vcGVuQnJhY2tldCAqLzpcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSAzIC8qIFN5bnRheEtpbmQuT3BlbkJyYWNrZXRUb2tlbiAqLztcbiAgICAgICAgICAgIGNhc2UgOTMgLyogQ2hhcmFjdGVyQ29kZXMuY2xvc2VCcmFja2V0ICovOlxuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbiA9IDQgLyogU3ludGF4S2luZC5DbG9zZUJyYWNrZXRUb2tlbiAqLztcbiAgICAgICAgICAgIGNhc2UgNTggLyogQ2hhcmFjdGVyQ29kZXMuY29sb24gKi86XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gNiAvKiBTeW50YXhLaW5kLkNvbG9uVG9rZW4gKi87XG4gICAgICAgICAgICBjYXNlIDQ0IC8qIENoYXJhY3RlckNvZGVzLmNvbW1hICovOlxuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbiA9IDUgLyogU3ludGF4S2luZC5Db21tYVRva2VuICovO1xuICAgICAgICAgICAgLy8gc3RyaW5nc1xuICAgICAgICAgICAgY2FzZSAzNCAvKiBDaGFyYWN0ZXJDb2Rlcy5kb3VibGVRdW90ZSAqLzpcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHNjYW5TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSAxMCAvKiBTeW50YXhLaW5kLlN0cmluZ0xpdGVyYWwgKi87XG4gICAgICAgICAgICAvLyBjb21tZW50c1xuICAgICAgICAgICAgY2FzZSA0NyAvKiBDaGFyYWN0ZXJDb2Rlcy5zbGFzaCAqLzpcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IHBvcyAtIDE7XG4gICAgICAgICAgICAgICAgLy8gU2luZ2xlLWxpbmUgY29tbWVudFxuICAgICAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQocG9zICsgMSkgPT09IDQ3IC8qIENoYXJhY3RlckNvZGVzLnNsYXNoICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocG9zIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNMaW5lQnJlYWsodGV4dC5jaGFyQ29kZUF0KHBvcykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBwb3MpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSAxMiAvKiBTeW50YXhLaW5kLkxpbmVDb21tZW50VHJpdmlhICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBNdWx0aS1saW5lIGNvbW1lbnRcbiAgICAgICAgICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KHBvcyArIDEpID09PSA0MiAvKiBDaGFyYWN0ZXJDb2Rlcy5hc3RlcmlzayAqLykge1xuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2FmZUxlbmd0aCA9IGxlbiAtIDE7IC8vIEZvciBsb29rYWhlYWQuXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb21tZW50Q2xvc2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwb3MgPCBzYWZlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaCA9IHRleHQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSA0MiAvKiBDaGFyYWN0ZXJDb2Rlcy5hc3RlcmlzayAqLyAmJiB0ZXh0LmNoYXJDb2RlQXQocG9zICsgMSkgPT09IDQ3IC8qIENoYXJhY3RlckNvZGVzLnNsYXNoICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudENsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0xpbmVCcmVhayhjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDEzIC8qIENoYXJhY3RlckNvZGVzLmNhcnJpYWdlUmV0dXJuICovICYmIHRleHQuY2hhckNvZGVBdChwb3MpID09PSAxMCAvKiBDaGFyYWN0ZXJDb2Rlcy5saW5lRmVlZCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuTGluZVN0YXJ0T2Zmc2V0ID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tbWVudENsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FuRXJyb3IgPSAxIC8qIFNjYW5FcnJvci5VbmV4cGVjdGVkRW5kT2ZDb21tZW50ICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGV4dC5zdWJzdHJpbmcoc3RhcnQsIHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbiA9IDEzIC8qIFN5bnRheEtpbmQuQmxvY2tDb21tZW50VHJpdmlhICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBqdXN0IGEgc2luZ2xlIHNsYXNoXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSAxNiAvKiBTeW50YXhLaW5kLlVua25vd24gKi87XG4gICAgICAgICAgICAvLyBudW1iZXJzXG4gICAgICAgICAgICBjYXNlIDQ1IC8qIENoYXJhY3RlckNvZGVzLm1pbnVzICovOlxuICAgICAgICAgICAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA9PT0gbGVuIHx8ICFpc0RpZ2l0KHRleHQuY2hhckNvZGVBdChwb3MpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSAxNiAvKiBTeW50YXhLaW5kLlVua25vd24gKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZm91bmQgYSBtaW51cywgZm9sbG93ZWQgYnkgYSBudW1iZXIgc29cbiAgICAgICAgICAgIC8vIHdlIGZhbGwgdGhyb3VnaCB0byBwcm9jZWVkIHdpdGggc2Nhbm5pbmdcbiAgICAgICAgICAgIC8vIG51bWJlcnNcbiAgICAgICAgICAgIGNhc2UgNDggLyogQ2hhcmFjdGVyQ29kZXMuXzAgKi86XG4gICAgICAgICAgICBjYXNlIDQ5IC8qIENoYXJhY3RlckNvZGVzLl8xICovOlxuICAgICAgICAgICAgY2FzZSA1MCAvKiBDaGFyYWN0ZXJDb2Rlcy5fMiAqLzpcbiAgICAgICAgICAgIGNhc2UgNTEgLyogQ2hhcmFjdGVyQ29kZXMuXzMgKi86XG4gICAgICAgICAgICBjYXNlIDUyIC8qIENoYXJhY3RlckNvZGVzLl80ICovOlxuICAgICAgICAgICAgY2FzZSA1MyAvKiBDaGFyYWN0ZXJDb2Rlcy5fNSAqLzpcbiAgICAgICAgICAgIGNhc2UgNTQgLyogQ2hhcmFjdGVyQ29kZXMuXzYgKi86XG4gICAgICAgICAgICBjYXNlIDU1IC8qIENoYXJhY3RlckNvZGVzLl83ICovOlxuICAgICAgICAgICAgY2FzZSA1NiAvKiBDaGFyYWN0ZXJDb2Rlcy5fOCAqLzpcbiAgICAgICAgICAgIGNhc2UgNTcgLyogQ2hhcmFjdGVyQ29kZXMuXzkgKi86XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gc2Nhbk51bWJlcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbiA9IDExIC8qIFN5bnRheEtpbmQuTnVtZXJpY0xpdGVyYWwgKi87XG4gICAgICAgICAgICAvLyBsaXRlcmFscyBhbmQgdW5rbm93biBzeW1ib2xzXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIGlzIGEgbGl0ZXJhbD8gUmVhZCB0aGUgZnVsbCB3b3JkLlxuICAgICAgICAgICAgICAgIHdoaWxlIChwb3MgPCBsZW4gJiYgaXNVbmtub3duQ29udGVudENoYXJhY3Rlcihjb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9IHRleHQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG9rZW5PZmZzZXQgIT09IHBvcykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRleHQuc3Vic3RyaW5nKHRva2VuT2Zmc2V0LCBwb3MpO1xuICAgICAgICAgICAgICAgICAgICAvLyBrZXl3b3JkczogdHJ1ZSwgZmFsc2UsIG51bGxcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndHJ1ZSc6IHJldHVybiB0b2tlbiA9IDggLyogU3ludGF4S2luZC5UcnVlS2V5d29yZCAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZhbHNlJzogcmV0dXJuIHRva2VuID0gOSAvKiBTeW50YXhLaW5kLkZhbHNlS2V5d29yZCAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ251bGwnOiByZXR1cm4gdG9rZW4gPSA3IC8qIFN5bnRheEtpbmQuTnVsbEtleXdvcmQgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gMTYgLyogU3ludGF4S2luZC5Vbmtub3duICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSAxNiAvKiBTeW50YXhLaW5kLlVua25vd24gKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaXNVbmtub3duQ29udGVudENoYXJhY3Rlcihjb2RlKSB7XG4gICAgICAgIGlmIChpc1doaXRlU3BhY2UoY29kZSkgfHwgaXNMaW5lQnJlYWsoY29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgMTI1IC8qIENoYXJhY3RlckNvZGVzLmNsb3NlQnJhY2UgKi86XG4gICAgICAgICAgICBjYXNlIDkzIC8qIENoYXJhY3RlckNvZGVzLmNsb3NlQnJhY2tldCAqLzpcbiAgICAgICAgICAgIGNhc2UgMTIzIC8qIENoYXJhY3RlckNvZGVzLm9wZW5CcmFjZSAqLzpcbiAgICAgICAgICAgIGNhc2UgOTEgLyogQ2hhcmFjdGVyQ29kZXMub3BlbkJyYWNrZXQgKi86XG4gICAgICAgICAgICBjYXNlIDM0IC8qIENoYXJhY3RlckNvZGVzLmRvdWJsZVF1b3RlICovOlxuICAgICAgICAgICAgY2FzZSA1OCAvKiBDaGFyYWN0ZXJDb2Rlcy5jb2xvbiAqLzpcbiAgICAgICAgICAgIGNhc2UgNDQgLyogQ2hhcmFjdGVyQ29kZXMuY29tbWEgKi86XG4gICAgICAgICAgICBjYXNlIDQ3IC8qIENoYXJhY3RlckNvZGVzLnNsYXNoICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2Nhbk5leHROb25Ucml2aWEoKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHNjYW5OZXh0KCk7XG4gICAgICAgIH0gd2hpbGUgKHJlc3VsdCA+PSAxMiAvKiBTeW50YXhLaW5kLkxpbmVDb21tZW50VHJpdmlhICovICYmIHJlc3VsdCA8PSAxNSAvKiBTeW50YXhLaW5kLlRyaXZpYSAqLyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNldFBvc2l0aW9uOiBzZXRQb3NpdGlvbixcbiAgICAgICAgZ2V0UG9zaXRpb246ICgpID0+IHBvcyxcbiAgICAgICAgc2NhbjogaWdub3JlVHJpdmlhID8gc2Nhbk5leHROb25Ucml2aWEgOiBzY2FuTmV4dCxcbiAgICAgICAgZ2V0VG9rZW46ICgpID0+IHRva2VuLFxuICAgICAgICBnZXRUb2tlblZhbHVlOiAoKSA9PiB2YWx1ZSxcbiAgICAgICAgZ2V0VG9rZW5PZmZzZXQ6ICgpID0+IHRva2VuT2Zmc2V0LFxuICAgICAgICBnZXRUb2tlbkxlbmd0aDogKCkgPT4gcG9zIC0gdG9rZW5PZmZzZXQsXG4gICAgICAgIGdldFRva2VuU3RhcnRMaW5lOiAoKSA9PiBsaW5lU3RhcnRPZmZzZXQsXG4gICAgICAgIGdldFRva2VuU3RhcnRDaGFyYWN0ZXI6ICgpID0+IHRva2VuT2Zmc2V0IC0gcHJldlRva2VuTGluZVN0YXJ0T2Zmc2V0LFxuICAgICAgICBnZXRUb2tlbkVycm9yOiAoKSA9PiBzY2FuRXJyb3IsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjaCkge1xuICAgIHJldHVybiBjaCA9PT0gMzIgLyogQ2hhcmFjdGVyQ29kZXMuc3BhY2UgKi8gfHwgY2ggPT09IDkgLyogQ2hhcmFjdGVyQ29kZXMudGFiICovO1xufVxuZnVuY3Rpb24gaXNMaW5lQnJlYWsoY2gpIHtcbiAgICByZXR1cm4gY2ggPT09IDEwIC8qIENoYXJhY3RlckNvZGVzLmxpbmVGZWVkICovIHx8IGNoID09PSAxMyAvKiBDaGFyYWN0ZXJDb2Rlcy5jYXJyaWFnZVJldHVybiAqLztcbn1cbmZ1bmN0aW9uIGlzRGlnaXQoY2gpIHtcbiAgICByZXR1cm4gY2ggPj0gNDggLyogQ2hhcmFjdGVyQ29kZXMuXzAgKi8gJiYgY2ggPD0gNTcgLyogQ2hhcmFjdGVyQ29kZXMuXzkgKi87XG59XG52YXIgQ2hhcmFjdGVyQ29kZXM7XG4oZnVuY3Rpb24gKENoYXJhY3RlckNvZGVzKSB7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJsaW5lRmVlZFwiXSA9IDEwXSA9IFwibGluZUZlZWRcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcImNhcnJpYWdlUmV0dXJuXCJdID0gMTNdID0gXCJjYXJyaWFnZVJldHVyblwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wic3BhY2VcIl0gPSAzMl0gPSBcInNwYWNlXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJfMFwiXSA9IDQ4XSA9IFwiXzBcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIl8xXCJdID0gNDldID0gXCJfMVwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiXzJcIl0gPSA1MF0gPSBcIl8yXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJfM1wiXSA9IDUxXSA9IFwiXzNcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIl80XCJdID0gNTJdID0gXCJfNFwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiXzVcIl0gPSA1M10gPSBcIl81XCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJfNlwiXSA9IDU0XSA9IFwiXzZcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIl83XCJdID0gNTVdID0gXCJfN1wiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiXzhcIl0gPSA1Nl0gPSBcIl84XCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJfOVwiXSA9IDU3XSA9IFwiXzlcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcImFcIl0gPSA5N10gPSBcImFcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcImJcIl0gPSA5OF0gPSBcImJcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcImNcIl0gPSA5OV0gPSBcImNcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcImRcIl0gPSAxMDBdID0gXCJkXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJlXCJdID0gMTAxXSA9IFwiZVwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiZlwiXSA9IDEwMl0gPSBcImZcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcImdcIl0gPSAxMDNdID0gXCJnXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJoXCJdID0gMTA0XSA9IFwiaFwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiaVwiXSA9IDEwNV0gPSBcImlcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcImpcIl0gPSAxMDZdID0gXCJqXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJrXCJdID0gMTA3XSA9IFwia1wiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wibFwiXSA9IDEwOF0gPSBcImxcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIm1cIl0gPSAxMDldID0gXCJtXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJuXCJdID0gMTEwXSA9IFwiblwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wib1wiXSA9IDExMV0gPSBcIm9cIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcInBcIl0gPSAxMTJdID0gXCJwXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJxXCJdID0gMTEzXSA9IFwicVwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiclwiXSA9IDExNF0gPSBcInJcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcInNcIl0gPSAxMTVdID0gXCJzXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJ0XCJdID0gMTE2XSA9IFwidFwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1widVwiXSA9IDExN10gPSBcInVcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcInZcIl0gPSAxMThdID0gXCJ2XCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJ3XCJdID0gMTE5XSA9IFwid1wiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wieFwiXSA9IDEyMF0gPSBcInhcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcInlcIl0gPSAxMjFdID0gXCJ5XCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJ6XCJdID0gMTIyXSA9IFwielwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiQVwiXSA9IDY1XSA9IFwiQVwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiQlwiXSA9IDY2XSA9IFwiQlwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiQ1wiXSA9IDY3XSA9IFwiQ1wiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiRFwiXSA9IDY4XSA9IFwiRFwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiRVwiXSA9IDY5XSA9IFwiRVwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiRlwiXSA9IDcwXSA9IFwiRlwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiR1wiXSA9IDcxXSA9IFwiR1wiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiSFwiXSA9IDcyXSA9IFwiSFwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiSVwiXSA9IDczXSA9IFwiSVwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiSlwiXSA9IDc0XSA9IFwiSlwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiS1wiXSA9IDc1XSA9IFwiS1wiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiTFwiXSA9IDc2XSA9IFwiTFwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiTVwiXSA9IDc3XSA9IFwiTVwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiTlwiXSA9IDc4XSA9IFwiTlwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiT1wiXSA9IDc5XSA9IFwiT1wiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiUFwiXSA9IDgwXSA9IFwiUFwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiUVwiXSA9IDgxXSA9IFwiUVwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiUlwiXSA9IDgyXSA9IFwiUlwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiU1wiXSA9IDgzXSA9IFwiU1wiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiVFwiXSA9IDg0XSA9IFwiVFwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiVVwiXSA9IDg1XSA9IFwiVVwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiVlwiXSA9IDg2XSA9IFwiVlwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiV1wiXSA9IDg3XSA9IFwiV1wiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiWFwiXSA9IDg4XSA9IFwiWFwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiWVwiXSA9IDg5XSA9IFwiWVwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiWlwiXSA9IDkwXSA9IFwiWlwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiYXN0ZXJpc2tcIl0gPSA0Ml0gPSBcImFzdGVyaXNrXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJiYWNrc2xhc2hcIl0gPSA5Ml0gPSBcImJhY2tzbGFzaFwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiY2xvc2VCcmFjZVwiXSA9IDEyNV0gPSBcImNsb3NlQnJhY2VcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcImNsb3NlQnJhY2tldFwiXSA9IDkzXSA9IFwiY2xvc2VCcmFja2V0XCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJjb2xvblwiXSA9IDU4XSA9IFwiY29sb25cIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcImNvbW1hXCJdID0gNDRdID0gXCJjb21tYVwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiZG90XCJdID0gNDZdID0gXCJkb3RcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcImRvdWJsZVF1b3RlXCJdID0gMzRdID0gXCJkb3VibGVRdW90ZVwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wibWludXNcIl0gPSA0NV0gPSBcIm1pbnVzXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJvcGVuQnJhY2VcIl0gPSAxMjNdID0gXCJvcGVuQnJhY2VcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIm9wZW5CcmFja2V0XCJdID0gOTFdID0gXCJvcGVuQnJhY2tldFwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wicGx1c1wiXSA9IDQzXSA9IFwicGx1c1wiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wic2xhc2hcIl0gPSA0N10gPSBcInNsYXNoXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJmb3JtRmVlZFwiXSA9IDEyXSA9IFwiZm9ybUZlZWRcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcInRhYlwiXSA9IDldID0gXCJ0YWJcIjtcbn0pKENoYXJhY3RlckNvZGVzIHx8IChDaGFyYWN0ZXJDb2RlcyA9IHt9KSk7XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvanNvbmMtcGFyc2VyL2xpYi9lc20vaW1wbC9mb3JtYXQuanNcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cbmZ1bmN0aW9uIGZvcm1hdF9mb3JtYXQoZG9jdW1lbnRUZXh0LCByYW5nZSwgb3B0aW9ucykge1xuICAgIGxldCBpbml0aWFsSW5kZW50TGV2ZWw7XG4gICAgbGV0IGZvcm1hdFRleHQ7XG4gICAgbGV0IGZvcm1hdFRleHRTdGFydDtcbiAgICBsZXQgcmFuZ2VTdGFydDtcbiAgICBsZXQgcmFuZ2VFbmQ7XG4gICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIHJhbmdlU3RhcnQgPSByYW5nZS5vZmZzZXQ7XG4gICAgICAgIHJhbmdlRW5kID0gcmFuZ2VTdGFydCArIHJhbmdlLmxlbmd0aDtcbiAgICAgICAgZm9ybWF0VGV4dFN0YXJ0ID0gcmFuZ2VTdGFydDtcbiAgICAgICAgd2hpbGUgKGZvcm1hdFRleHRTdGFydCA+IDAgJiYgIWZvcm1hdF9pc0VPTChkb2N1bWVudFRleHQsIGZvcm1hdFRleHRTdGFydCAtIDEpKSB7XG4gICAgICAgICAgICBmb3JtYXRUZXh0U3RhcnQtLTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZW5kT2Zmc2V0ID0gcmFuZ2VFbmQ7XG4gICAgICAgIHdoaWxlIChlbmRPZmZzZXQgPCBkb2N1bWVudFRleHQubGVuZ3RoICYmICFmb3JtYXRfaXNFT0woZG9jdW1lbnRUZXh0LCBlbmRPZmZzZXQpKSB7XG4gICAgICAgICAgICBlbmRPZmZzZXQrKztcbiAgICAgICAgfVxuICAgICAgICBmb3JtYXRUZXh0ID0gZG9jdW1lbnRUZXh0LnN1YnN0cmluZyhmb3JtYXRUZXh0U3RhcnQsIGVuZE9mZnNldCk7XG4gICAgICAgIGluaXRpYWxJbmRlbnRMZXZlbCA9IGNvbXB1dGVJbmRlbnRMZXZlbChmb3JtYXRUZXh0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvcm1hdFRleHQgPSBkb2N1bWVudFRleHQ7XG4gICAgICAgIGluaXRpYWxJbmRlbnRMZXZlbCA9IDA7XG4gICAgICAgIGZvcm1hdFRleHRTdGFydCA9IDA7XG4gICAgICAgIHJhbmdlU3RhcnQgPSAwO1xuICAgICAgICByYW5nZUVuZCA9IGRvY3VtZW50VGV4dC5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IGVvbCA9IGdldEVPTChvcHRpb25zLCBkb2N1bWVudFRleHQpO1xuICAgIGxldCBudW1iZXJMaW5lQnJlYWtzID0gMDtcbiAgICBsZXQgaW5kZW50TGV2ZWwgPSAwO1xuICAgIGxldCBpbmRlbnRWYWx1ZTtcbiAgICBpZiAob3B0aW9ucy5pbnNlcnRTcGFjZXMpIHtcbiAgICAgICAgaW5kZW50VmFsdWUgPSByZXBlYXQoJyAnLCBvcHRpb25zLnRhYlNpemUgfHwgNCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpbmRlbnRWYWx1ZSA9ICdcXHQnO1xuICAgIH1cbiAgICBsZXQgc2Nhbm5lciA9IGNyZWF0ZVNjYW5uZXIoZm9ybWF0VGV4dCwgZmFsc2UpO1xuICAgIGxldCBoYXNFcnJvciA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIG5ld0xpbmVzQW5kSW5kZW50KCkge1xuICAgICAgICBpZiAobnVtYmVyTGluZUJyZWFrcyA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiByZXBlYXQoZW9sLCBudW1iZXJMaW5lQnJlYWtzKSArIHJlcGVhdChpbmRlbnRWYWx1ZSwgaW5pdGlhbEluZGVudExldmVsICsgaW5kZW50TGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVvbCArIHJlcGVhdChpbmRlbnRWYWx1ZSwgaW5pdGlhbEluZGVudExldmVsICsgaW5kZW50TGV2ZWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYW5OZXh0KCkge1xuICAgICAgICBsZXQgdG9rZW4gPSBzY2FubmVyLnNjYW4oKTtcbiAgICAgICAgbnVtYmVyTGluZUJyZWFrcyA9IDA7XG4gICAgICAgIHdoaWxlICh0b2tlbiA9PT0gMTUgLyogU3ludGF4S2luZC5Ucml2aWEgKi8gfHwgdG9rZW4gPT09IDE0IC8qIFN5bnRheEtpbmQuTGluZUJyZWFrVHJpdmlhICovKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IDE0IC8qIFN5bnRheEtpbmQuTGluZUJyZWFrVHJpdmlhICovICYmIG9wdGlvbnMua2VlcExpbmVzKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyTGluZUJyZWFrcyArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09IDE0IC8qIFN5bnRheEtpbmQuTGluZUJyZWFrVHJpdmlhICovKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyTGluZUJyZWFrcyA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlbiA9IHNjYW5uZXIuc2NhbigpO1xuICAgICAgICB9XG4gICAgICAgIGhhc0Vycm9yID0gdG9rZW4gPT09IDE2IC8qIFN5bnRheEtpbmQuVW5rbm93biAqLyB8fCBzY2FubmVyLmdldFRva2VuRXJyb3IoKSAhPT0gMCAvKiBTY2FuRXJyb3IuTm9uZSAqLztcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cbiAgICBjb25zdCBlZGl0T3BlcmF0aW9ucyA9IFtdO1xuICAgIGZ1bmN0aW9uIGFkZEVkaXQodGV4dCwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkge1xuICAgICAgICBpZiAoIWhhc0Vycm9yICYmICghcmFuZ2UgfHwgKHN0YXJ0T2Zmc2V0IDwgcmFuZ2VFbmQgJiYgZW5kT2Zmc2V0ID4gcmFuZ2VTdGFydCkpICYmIGRvY3VtZW50VGV4dC5zdWJzdHJpbmcoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkgIT09IHRleHQpIHtcbiAgICAgICAgICAgIGVkaXRPcGVyYXRpb25zLnB1c2goeyBvZmZzZXQ6IHN0YXJ0T2Zmc2V0LCBsZW5ndGg6IGVuZE9mZnNldCAtIHN0YXJ0T2Zmc2V0LCBjb250ZW50OiB0ZXh0IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBmaXJzdFRva2VuID0gc2Nhbk5leHQoKTtcbiAgICBpZiAob3B0aW9ucy5rZWVwTGluZXMgJiYgbnVtYmVyTGluZUJyZWFrcyA+IDApIHtcbiAgICAgICAgYWRkRWRpdChyZXBlYXQoZW9sLCBudW1iZXJMaW5lQnJlYWtzKSwgMCwgMCk7XG4gICAgfVxuICAgIGlmIChmaXJzdFRva2VuICE9PSAxNyAvKiBTeW50YXhLaW5kLkVPRiAqLykge1xuICAgICAgICBsZXQgZmlyc3RUb2tlblN0YXJ0ID0gc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpICsgZm9ybWF0VGV4dFN0YXJ0O1xuICAgICAgICBsZXQgaW5pdGlhbEluZGVudCA9IHJlcGVhdChpbmRlbnRWYWx1ZSwgaW5pdGlhbEluZGVudExldmVsKTtcbiAgICAgICAgYWRkRWRpdChpbml0aWFsSW5kZW50LCBmb3JtYXRUZXh0U3RhcnQsIGZpcnN0VG9rZW5TdGFydCk7XG4gICAgfVxuICAgIHdoaWxlIChmaXJzdFRva2VuICE9PSAxNyAvKiBTeW50YXhLaW5kLkVPRiAqLykge1xuICAgICAgICBsZXQgZmlyc3RUb2tlbkVuZCA9IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSArIHNjYW5uZXIuZ2V0VG9rZW5MZW5ndGgoKSArIGZvcm1hdFRleHRTdGFydDtcbiAgICAgICAgbGV0IHNlY29uZFRva2VuID0gc2Nhbk5leHQoKTtcbiAgICAgICAgbGV0IHJlcGxhY2VDb250ZW50ID0gJyc7XG4gICAgICAgIGxldCBuZWVkc0xpbmVCcmVhayA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAobnVtYmVyTGluZUJyZWFrcyA9PT0gMCAmJiAoc2Vjb25kVG9rZW4gPT09IDEyIC8qIFN5bnRheEtpbmQuTGluZUNvbW1lbnRUcml2aWEgKi8gfHwgc2Vjb25kVG9rZW4gPT09IDEzIC8qIFN5bnRheEtpbmQuQmxvY2tDb21tZW50VHJpdmlhICovKSkge1xuICAgICAgICAgICAgbGV0IGNvbW1lbnRUb2tlblN0YXJ0ID0gc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpICsgZm9ybWF0VGV4dFN0YXJ0O1xuICAgICAgICAgICAgYWRkRWRpdCgnICcsIGZpcnN0VG9rZW5FbmQsIGNvbW1lbnRUb2tlblN0YXJ0KTtcbiAgICAgICAgICAgIGZpcnN0VG9rZW5FbmQgPSBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkgKyBzY2FubmVyLmdldFRva2VuTGVuZ3RoKCkgKyBmb3JtYXRUZXh0U3RhcnQ7XG4gICAgICAgICAgICBuZWVkc0xpbmVCcmVhayA9IHNlY29uZFRva2VuID09PSAxMiAvKiBTeW50YXhLaW5kLkxpbmVDb21tZW50VHJpdmlhICovO1xuICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSBuZWVkc0xpbmVCcmVhayA/IG5ld0xpbmVzQW5kSW5kZW50KCkgOiAnJztcbiAgICAgICAgICAgIHNlY29uZFRva2VuID0gc2Nhbk5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Vjb25kVG9rZW4gPT09IDIgLyogU3ludGF4S2luZC5DbG9zZUJyYWNlVG9rZW4gKi8pIHtcbiAgICAgICAgICAgIGlmIChmaXJzdFRva2VuICE9PSAxIC8qIFN5bnRheEtpbmQuT3BlbkJyYWNlVG9rZW4gKi8pIHtcbiAgICAgICAgICAgICAgICBpbmRlbnRMZXZlbC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMua2VlcExpbmVzICYmIG51bWJlckxpbmVCcmVha3MgPiAwIHx8ICFvcHRpb25zLmtlZXBMaW5lcyAmJiBmaXJzdFRva2VuICE9PSAxIC8qIFN5bnRheEtpbmQuT3BlbkJyYWNlVG9rZW4gKi8pIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlQ29udGVudCA9IG5ld0xpbmVzQW5kSW5kZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmtlZXBMaW5lcykge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNlY29uZFRva2VuID09PSA0IC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFja2V0VG9rZW4gKi8pIHtcbiAgICAgICAgICAgIGlmIChmaXJzdFRva2VuICE9PSAzIC8qIFN5bnRheEtpbmQuT3BlbkJyYWNrZXRUb2tlbiAqLykge1xuICAgICAgICAgICAgICAgIGluZGVudExldmVsLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5rZWVwTGluZXMgJiYgbnVtYmVyTGluZUJyZWFrcyA+IDAgfHwgIW9wdGlvbnMua2VlcExpbmVzICYmIGZpcnN0VG9rZW4gIT09IDMgLyogU3ludGF4S2luZC5PcGVuQnJhY2tldFRva2VuICovKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSBuZXdMaW5lc0FuZEluZGVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5rZWVwTGluZXMpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlQ29udGVudCA9ICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZmlyc3RUb2tlbikge1xuICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBTeW50YXhLaW5kLk9wZW5CcmFja2V0VG9rZW4gKi86XG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIFN5bnRheEtpbmQuT3BlbkJyYWNlVG9rZW4gKi86XG4gICAgICAgICAgICAgICAgICAgIGluZGVudExldmVsKys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmtlZXBMaW5lcyAmJiBudW1iZXJMaW5lQnJlYWtzID4gMCB8fCAhb3B0aW9ucy5rZWVwTGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gbmV3TGluZXNBbmRJbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNSAvKiBTeW50YXhLaW5kLkNvbW1hVG9rZW4gKi86XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmtlZXBMaW5lcyAmJiBudW1iZXJMaW5lQnJlYWtzID4gMCB8fCAhb3B0aW9ucy5rZWVwTGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gbmV3TGluZXNBbmRJbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTIgLyogU3ludGF4S2luZC5MaW5lQ29tbWVudFRyaXZpYSAqLzpcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSBuZXdMaW5lc0FuZEluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEzIC8qIFN5bnRheEtpbmQuQmxvY2tDb21tZW50VHJpdmlhICovOlxuICAgICAgICAgICAgICAgICAgICBpZiAobnVtYmVyTGluZUJyZWFrcyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gbmV3TGluZXNBbmRJbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghbmVlZHNMaW5lQnJlYWspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNiAvKiBTeW50YXhLaW5kLkNvbG9uVG9rZW4gKi86XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmtlZXBMaW5lcyAmJiBudW1iZXJMaW5lQnJlYWtzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSBuZXdMaW5lc0FuZEluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFuZWVkc0xpbmVCcmVhaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSAnICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMCAvKiBTeW50YXhLaW5kLlN0cmluZ0xpdGVyYWwgKi86XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmtlZXBMaW5lcyAmJiBudW1iZXJMaW5lQnJlYWtzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSBuZXdMaW5lc0FuZEluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlY29uZFRva2VuID09PSA2IC8qIFN5bnRheEtpbmQuQ29sb25Ub2tlbiAqLyAmJiAhbmVlZHNMaW5lQnJlYWspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3IC8qIFN5bnRheEtpbmQuTnVsbEtleXdvcmQgKi86XG4gICAgICAgICAgICAgICAgY2FzZSA4IC8qIFN5bnRheEtpbmQuVHJ1ZUtleXdvcmQgKi86XG4gICAgICAgICAgICAgICAgY2FzZSA5IC8qIFN5bnRheEtpbmQuRmFsc2VLZXl3b3JkICovOlxuICAgICAgICAgICAgICAgIGNhc2UgMTEgLyogU3ludGF4S2luZC5OdW1lcmljTGl0ZXJhbCAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogU3ludGF4S2luZC5DbG9zZUJyYWNlVG9rZW4gKi86XG4gICAgICAgICAgICAgICAgY2FzZSA0IC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFja2V0VG9rZW4gKi86XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmtlZXBMaW5lcyAmJiBudW1iZXJMaW5lQnJlYWtzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSBuZXdMaW5lc0FuZEluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChzZWNvbmRUb2tlbiA9PT0gMTIgLyogU3ludGF4S2luZC5MaW5lQ29tbWVudFRyaXZpYSAqLyB8fCBzZWNvbmRUb2tlbiA9PT0gMTMgLyogU3ludGF4S2luZC5CbG9ja0NvbW1lbnRUcml2aWEgKi8pICYmICFuZWVkc0xpbmVCcmVhaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2Vjb25kVG9rZW4gIT09IDUgLyogU3ludGF4S2luZC5Db21tYVRva2VuICovICYmIHNlY29uZFRva2VuICE9PSAxNyAvKiBTeW50YXhLaW5kLkVPRiAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE2IC8qIFN5bnRheEtpbmQuVW5rbm93biAqLzpcbiAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChudW1iZXJMaW5lQnJlYWtzID4gMCAmJiAoc2Vjb25kVG9rZW4gPT09IDEyIC8qIFN5bnRheEtpbmQuTGluZUNvbW1lbnRUcml2aWEgKi8gfHwgc2Vjb25kVG9rZW4gPT09IDEzIC8qIFN5bnRheEtpbmQuQmxvY2tDb21tZW50VHJpdmlhICovKSkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gbmV3TGluZXNBbmRJbmRlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Vjb25kVG9rZW4gPT09IDE3IC8qIFN5bnRheEtpbmQuRU9GICovKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5rZWVwTGluZXMgJiYgbnVtYmVyTGluZUJyZWFrcyA+IDApIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlQ29udGVudCA9IG5ld0xpbmVzQW5kSW5kZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlQ29udGVudCA9IG9wdGlvbnMuaW5zZXJ0RmluYWxOZXdsaW5lID8gZW9sIDogJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2Vjb25kVG9rZW5TdGFydCA9IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSArIGZvcm1hdFRleHRTdGFydDtcbiAgICAgICAgYWRkRWRpdChyZXBsYWNlQ29udGVudCwgZmlyc3RUb2tlbkVuZCwgc2Vjb25kVG9rZW5TdGFydCk7XG4gICAgICAgIGZpcnN0VG9rZW4gPSBzZWNvbmRUb2tlbjtcbiAgICB9XG4gICAgcmV0dXJuIGVkaXRPcGVyYXRpb25zO1xufVxuZnVuY3Rpb24gcmVwZWF0KHMsIGNvdW50KSB7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gcztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVJbmRlbnRMZXZlbChjb250ZW50LCBvcHRpb25zKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBuQ2hhcnMgPSAwO1xuICAgIGNvbnN0IHRhYlNpemUgPSBvcHRpb25zLnRhYlNpemUgfHwgNDtcbiAgICB3aGlsZSAoaSA8IGNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgIGxldCBjaCA9IGNvbnRlbnQuY2hhckF0KGkpO1xuICAgICAgICBpZiAoY2ggPT09ICcgJykge1xuICAgICAgICAgICAgbkNoYXJzKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09ICdcXHQnKSB7XG4gICAgICAgICAgICBuQ2hhcnMgKz0gdGFiU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobkNoYXJzIC8gdGFiU2l6ZSk7XG59XG5mdW5jdGlvbiBnZXRFT0wob3B0aW9ucywgdGV4dCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaCA9IHRleHQuY2hhckF0KGkpO1xuICAgICAgICBpZiAoY2ggPT09ICdcXHInKSB7XG4gICAgICAgICAgICBpZiAoaSArIDEgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0LmNoYXJBdChpICsgMSkgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXHJcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdcXHInO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAnXFxuJykge1xuICAgICAgICAgICAgcmV0dXJuICdcXG4nO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAob3B0aW9ucyAmJiBvcHRpb25zLmVvbCkgfHwgJ1xcbic7XG59XG5mdW5jdGlvbiBmb3JtYXRfaXNFT0wodGV4dCwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuICdcXHJcXG4nLmluZGV4T2YodGV4dC5jaGFyQXQob2Zmc2V0KSkgIT09IC0xO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL2pzb25jLXBhcnNlci9saWIvZXNtL2ltcGwvcGFyc2VyLmpzXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG52YXIgUGFyc2VPcHRpb25zO1xuKGZ1bmN0aW9uIChQYXJzZU9wdGlvbnMpIHtcbiAgICBQYXJzZU9wdGlvbnMuREVGQVVMVCA9IHtcbiAgICAgICAgYWxsb3dUcmFpbGluZ0NvbW1hOiBmYWxzZVxuICAgIH07XG59KShQYXJzZU9wdGlvbnMgfHwgKFBhcnNlT3B0aW9ucyA9IHt9KSk7XG4vKipcbiAqIEZvciBhIGdpdmVuIG9mZnNldCwgZXZhbHVhdGUgdGhlIGxvY2F0aW9uIGluIHRoZSBKU09OIGRvY3VtZW50LiBFYWNoIHNlZ21lbnQgaW4gdGhlIGxvY2F0aW9uIHBhdGggaXMgZWl0aGVyIGEgcHJvcGVydHkgbmFtZSBvciBhbiBhcnJheSBpbmRleC5cbiAqL1xuZnVuY3Rpb24gZ2V0TG9jYXRpb24odGV4dCwgcG9zaXRpb24pIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IFtdOyAvLyBzdHJpbmdzIG9yIG51bWJlcnNcbiAgICBjb25zdCBlYXJseVJldHVybkV4Y2VwdGlvbiA9IG5ldyBPYmplY3QoKTtcbiAgICBsZXQgcHJldmlvdXNOb2RlID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHByZXZpb3VzTm9kZUluc3QgPSB7XG4gICAgICAgIHZhbHVlOiB7fSxcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICBsZW5ndGg6IDAsXG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBwYXJlbnQ6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgbGV0IGlzQXRQcm9wZXJ0eUtleSA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIHNldFByZXZpb3VzTm9kZSh2YWx1ZSwgb2Zmc2V0LCBsZW5ndGgsIHR5cGUpIHtcbiAgICAgICAgcHJldmlvdXNOb2RlSW5zdC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBwcmV2aW91c05vZGVJbnN0Lm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgcHJldmlvdXNOb2RlSW5zdC5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHByZXZpb3VzTm9kZUluc3QudHlwZSA9IHR5cGU7XG4gICAgICAgIHByZXZpb3VzTm9kZUluc3QuY29sb25PZmZzZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHByZXZpb3VzTm9kZSA9IHByZXZpb3VzTm9kZUluc3Q7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHZpc2l0KHRleHQsIHtcbiAgICAgICAgICAgIG9uT2JqZWN0QmVnaW46IChvZmZzZXQsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZWFybHlSZXR1cm5FeGNlcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZpb3VzTm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpc0F0UHJvcGVydHlLZXkgPSBwb3NpdGlvbiA+IG9mZnNldDtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKCcnKTsgLy8gcHVzaCBhIHBsYWNlaG9sZGVyICh3aWxsIGJlIHJlcGxhY2VkKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uT2JqZWN0UHJvcGVydHk6IChuYW1lLCBvZmZzZXQsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlYXJseVJldHVybkV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0UHJldmlvdXNOb2RlKG5hbWUsIG9mZnNldCwgbGVuZ3RoLCAncHJvcGVydHknKTtcbiAgICAgICAgICAgICAgICBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDw9IG9mZnNldCArIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlYXJseVJldHVybkV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25PYmplY3RFbmQ6IChvZmZzZXQsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZWFybHlSZXR1cm5FeGNlcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZpb3VzTm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wb3AoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkFycmF5QmVnaW46IChvZmZzZXQsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZWFybHlSZXR1cm5FeGNlcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZpb3VzTm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKDApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQXJyYXlFbmQ6IChvZmZzZXQsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZWFybHlSZXR1cm5FeGNlcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZpb3VzTm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wb3AoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkxpdGVyYWxWYWx1ZTogKHZhbHVlLCBvZmZzZXQsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlYXJseVJldHVybkV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0UHJldmlvdXNOb2RlKHZhbHVlLCBvZmZzZXQsIGxlbmd0aCwgZ2V0Tm9kZVR5cGUodmFsdWUpKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPD0gb2Zmc2V0ICsgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVhcmx5UmV0dXJuRXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblNlcGFyYXRvcjogKHNlcCwgb2Zmc2V0LCBsZW5ndGgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVhcmx5UmV0dXJuRXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VwID09PSAnOicgJiYgcHJldmlvdXNOb2RlICYmIHByZXZpb3VzTm9kZS50eXBlID09PSAncHJvcGVydHknKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzTm9kZS5jb2xvbk9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgaXNBdFByb3BlcnR5S2V5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzTm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VwID09PSAnLCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxhc3QgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXSA9IGxhc3QgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNBdFByb3BlcnR5S2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNOb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlICE9PSBlYXJseVJldHVybkV4Y2VwdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiBzZWdtZW50cyxcbiAgICAgICAgcHJldmlvdXNOb2RlLFxuICAgICAgICBpc0F0UHJvcGVydHlLZXksXG4gICAgICAgIG1hdGNoZXM6IChwYXR0ZXJuKSA9PiB7XG4gICAgICAgICAgICBsZXQgayA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgayA8IHBhdHRlcm4ubGVuZ3RoICYmIGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuW2tdID09PSBzZWdtZW50c1tpXSB8fCBwYXR0ZXJuW2tdID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXR0ZXJuW2tdICE9PSAnKionKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gayA9PT0gcGF0dGVybi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIHRleHQgYW5kIHJldHVybnMgdGhlIG9iamVjdCB0aGUgSlNPTiBjb250ZW50IHJlcHJlc2VudHMuIE9uIGludmFsaWQgaW5wdXQsIHRoZSBwYXJzZXIgdHJpZXMgdG8gYmUgYXMgZmF1bHQgdG9sZXJhbnQgYXMgcG9zc2libGUsIGJ1dCBzdGlsbCByZXR1cm4gYSByZXN1bHQuXG4gKiBUaGVyZWZvcmUgYWx3YXlzIGNoZWNrIHRoZSBlcnJvcnMgbGlzdCB0byBmaW5kIG91dCBpZiB0aGUgaW5wdXQgd2FzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBwYXJzZSh0ZXh0LCBlcnJvcnMgPSBbXSwgb3B0aW9ucyA9IFBhcnNlT3B0aW9ucy5ERUZBVUxUKSB7XG4gICAgbGV0IGN1cnJlbnRQcm9wZXJ0eSA9IG51bGw7XG4gICAgbGV0IGN1cnJlbnRQYXJlbnQgPSBbXTtcbiAgICBjb25zdCBwcmV2aW91c1BhcmVudHMgPSBbXTtcbiAgICBmdW5jdGlvbiBvblZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRQYXJlbnQpKSB7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRQcm9wZXJ0eSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY3VycmVudFBhcmVudFtjdXJyZW50UHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdmlzaXRvciA9IHtcbiAgICAgICAgb25PYmplY3RCZWdpbjogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBvblZhbHVlKG9iamVjdCk7XG4gICAgICAgICAgICBwcmV2aW91c1BhcmVudHMucHVzaChjdXJyZW50UGFyZW50KTtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBvYmplY3Q7XG4gICAgICAgICAgICBjdXJyZW50UHJvcGVydHkgPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBvbk9iamVjdFByb3BlcnR5OiAobmFtZSkgPT4ge1xuICAgICAgICAgICAgY3VycmVudFByb3BlcnR5ID0gbmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25PYmplY3RFbmQ6ICgpID0+IHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwcmV2aW91c1BhcmVudHMucG9wKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQXJyYXlCZWdpbjogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICAgICAgICAgIG9uVmFsdWUoYXJyYXkpO1xuICAgICAgICAgICAgcHJldmlvdXNQYXJlbnRzLnB1c2goY3VycmVudFBhcmVudCk7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gYXJyYXk7XG4gICAgICAgICAgICBjdXJyZW50UHJvcGVydHkgPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBvbkFycmF5RW5kOiAoKSA9PiB7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gcHJldmlvdXNQYXJlbnRzLnBvcCgpO1xuICAgICAgICB9LFxuICAgICAgICBvbkxpdGVyYWxWYWx1ZTogb25WYWx1ZSxcbiAgICAgICAgb25FcnJvcjogKGVycm9yLCBvZmZzZXQsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goeyBlcnJvciwgb2Zmc2V0LCBsZW5ndGggfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZpc2l0KHRleHQsIHZpc2l0b3IsIG9wdGlvbnMpO1xuICAgIHJldHVybiBjdXJyZW50UGFyZW50WzBdO1xufVxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIHRleHQgYW5kIHJldHVybnMgYSB0cmVlIHJlcHJlc2VudGF0aW9uIHRoZSBKU09OIGNvbnRlbnQuIE9uIGludmFsaWQgaW5wdXQsIHRoZSBwYXJzZXIgdHJpZXMgdG8gYmUgYXMgZmF1bHQgdG9sZXJhbnQgYXMgcG9zc2libGUsIGJ1dCBzdGlsbCByZXR1cm4gYSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlcl9wYXJzZVRyZWUodGV4dCwgZXJyb3JzID0gW10sIG9wdGlvbnMgPSBQYXJzZU9wdGlvbnMuREVGQVVMVCkge1xuICAgIGxldCBjdXJyZW50UGFyZW50ID0geyB0eXBlOiAnYXJyYXknLCBvZmZzZXQ6IC0xLCBsZW5ndGg6IC0xLCBjaGlsZHJlbjogW10sIHBhcmVudDogdW5kZWZpbmVkIH07IC8vIGFydGlmaWNpYWwgcm9vdFxuICAgIGZ1bmN0aW9uIGVuc3VyZVByb3BlcnR5Q29tcGxldGUoZW5kT2Zmc2V0KSB7XG4gICAgICAgIGlmIChjdXJyZW50UGFyZW50LnR5cGUgPT09ICdwcm9wZXJ0eScpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQubGVuZ3RoID0gZW5kT2Zmc2V0IC0gY3VycmVudFBhcmVudC5vZmZzZXQ7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gY3VycmVudFBhcmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25WYWx1ZSh2YWx1ZU5vZGUpIHtcbiAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKHZhbHVlTm9kZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZU5vZGU7XG4gICAgfVxuICAgIGNvbnN0IHZpc2l0b3IgPSB7XG4gICAgICAgIG9uT2JqZWN0QmVnaW46IChvZmZzZXQpID0+IHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBvblZhbHVlKHsgdHlwZTogJ29iamVjdCcsIG9mZnNldCwgbGVuZ3RoOiAtMSwgcGFyZW50OiBjdXJyZW50UGFyZW50LCBjaGlsZHJlbjogW10gfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uT2JqZWN0UHJvcGVydHk6IChuYW1lLCBvZmZzZXQsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IG9uVmFsdWUoeyB0eXBlOiAncHJvcGVydHknLCBvZmZzZXQsIGxlbmd0aDogLTEsIHBhcmVudDogY3VycmVudFBhcmVudCwgY2hpbGRyZW46IFtdIH0pO1xuICAgICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKHsgdHlwZTogJ3N0cmluZycsIHZhbHVlOiBuYW1lLCBvZmZzZXQsIGxlbmd0aCwgcGFyZW50OiBjdXJyZW50UGFyZW50IH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbk9iamVjdEVuZDogKG9mZnNldCwgbGVuZ3RoKSA9PiB7XG4gICAgICAgICAgICBlbnN1cmVQcm9wZXJ0eUNvbXBsZXRlKG9mZnNldCArIGxlbmd0aCk7IC8vIGluIGNhc2Ugb2YgYSBtaXNzaW5nIHZhbHVlIGZvciBhIHByb3BlcnR5OiBtYWtlIHN1cmUgcHJvcGVydHkgaXMgY29tcGxldGVcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQubGVuZ3RoID0gb2Zmc2V0ICsgbGVuZ3RoIC0gY3VycmVudFBhcmVudC5vZmZzZXQ7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gY3VycmVudFBhcmVudC5wYXJlbnQ7XG4gICAgICAgICAgICBlbnN1cmVQcm9wZXJ0eUNvbXBsZXRlKG9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQXJyYXlCZWdpbjogKG9mZnNldCwgbGVuZ3RoKSA9PiB7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gb25WYWx1ZSh7IHR5cGU6ICdhcnJheScsIG9mZnNldCwgbGVuZ3RoOiAtMSwgcGFyZW50OiBjdXJyZW50UGFyZW50LCBjaGlsZHJlbjogW10gfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQXJyYXlFbmQ6IChvZmZzZXQsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgY3VycmVudFBhcmVudC5sZW5ndGggPSBvZmZzZXQgKyBsZW5ndGggLSBjdXJyZW50UGFyZW50Lm9mZnNldDtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBjdXJyZW50UGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgIGVuc3VyZVByb3BlcnR5Q29tcGxldGUob2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25MaXRlcmFsVmFsdWU6ICh2YWx1ZSwgb2Zmc2V0LCBsZW5ndGgpID0+IHtcbiAgICAgICAgICAgIG9uVmFsdWUoeyB0eXBlOiBnZXROb2RlVHlwZSh2YWx1ZSksIG9mZnNldCwgbGVuZ3RoLCBwYXJlbnQ6IGN1cnJlbnRQYXJlbnQsIHZhbHVlIH0pO1xuICAgICAgICAgICAgZW5zdXJlUHJvcGVydHlDb21wbGV0ZShvZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgICB9LFxuICAgICAgICBvblNlcGFyYXRvcjogKHNlcCwgb2Zmc2V0LCBsZW5ndGgpID0+IHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UGFyZW50LnR5cGUgPT09ICdwcm9wZXJ0eScpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VwID09PSAnOicpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcmVudC5jb2xvbk9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VwID09PSAnLCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5zdXJlUHJvcGVydHlDb21wbGV0ZShvZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogKGVycm9yLCBvZmZzZXQsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goeyBlcnJvciwgb2Zmc2V0LCBsZW5ndGggfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZpc2l0KHRleHQsIHZpc2l0b3IsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW5bMF07XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBkZWxldGUgcmVzdWx0LnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogRmluZHMgdGhlIG5vZGUgYXQgdGhlIGdpdmVuIHBhdGggaW4gYSBKU09OIERPTS5cbiAqL1xuZnVuY3Rpb24gcGFyc2VyX2ZpbmROb2RlQXRMb2NhdGlvbihyb290LCBwYXRoKSB7XG4gICAgaWYgKCFyb290KSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGxldCBub2RlID0gcm9vdDtcbiAgICBmb3IgKGxldCBzZWdtZW50IG9mIHBhdGgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWdtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSAhPT0gJ29iamVjdCcgfHwgIUFycmF5LmlzQXJyYXkobm9kZS5jaGlsZHJlbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5Tm9kZSBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcGVydHlOb2RlLmNoaWxkcmVuKSAmJiBwcm9wZXJ0eU5vZGUuY2hpbGRyZW5bMF0udmFsdWUgPT09IHNlZ21lbnQgJiYgcHJvcGVydHlOb2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gcHJvcGVydHlOb2RlLmNoaWxkcmVuWzFdO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBzZWdtZW50O1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSAhPT0gJ2FycmF5JyB8fCBpbmRleCA8IDAgfHwgIUFycmF5LmlzQXJyYXkobm9kZS5jaGlsZHJlbikgfHwgaW5kZXggPj0gbm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuLyoqXG4gKiBHZXRzIHRoZSBKU09OIHBhdGggb2YgdGhlIGdpdmVuIEpTT04gRE9NIG5vZGVcbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZVBhdGgobm9kZSkge1xuICAgIGlmICghbm9kZS5wYXJlbnQgfHwgIW5vZGUucGFyZW50LmNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgcGF0aCA9IGdldE5vZGVQYXRoKG5vZGUucGFyZW50KTtcbiAgICBpZiAobm9kZS5wYXJlbnQudHlwZSA9PT0gJ3Byb3BlcnR5Jykge1xuICAgICAgICBjb25zdCBrZXkgPSBub2RlLnBhcmVudC5jaGlsZHJlblswXS52YWx1ZTtcbiAgICAgICAgcGF0aC5wdXNoKGtleSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUucGFyZW50LnR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBub2RlLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKG5vZGUpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2goaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufVxuLyoqXG4gKiBFdmFsdWF0ZXMgdGhlIEphdmFTY3JpcHQgb2JqZWN0IG9mIHRoZSBnaXZlbiBKU09OIERPTSBub2RlXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVWYWx1ZShub2RlKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4ubWFwKGdldE5vZGVWYWx1ZSk7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVOb2RlID0gcHJvcC5jaGlsZHJlblsxXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtwcm9wLmNoaWxkcmVuWzBdLnZhbHVlXSA9IGdldE5vZGVWYWx1ZSh2YWx1ZU5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5mdW5jdGlvbiBjb250YWlucyhub2RlLCBvZmZzZXQsIGluY2x1ZGVSaWdodEJvdW5kID0gZmFsc2UpIHtcbiAgICByZXR1cm4gKG9mZnNldCA+PSBub2RlLm9mZnNldCAmJiBvZmZzZXQgPCAobm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aCkpIHx8IGluY2x1ZGVSaWdodEJvdW5kICYmIChvZmZzZXQgPT09IChub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoKSk7XG59XG4vKipcbiAqIEZpbmRzIHRoZSBtb3N0IGlubmVyIG5vZGUgYXQgdGhlIGdpdmVuIG9mZnNldC4gSWYgaW5jbHVkZVJpZ2h0Qm91bmQgaXMgc2V0LCBhbHNvIGZpbmRzIG5vZGVzIHRoYXQgZW5kIGF0IHRoZSBnaXZlbiBvZmZzZXQuXG4gKi9cbmZ1bmN0aW9uIGZpbmROb2RlQXRPZmZzZXQobm9kZSwgb2Zmc2V0LCBpbmNsdWRlUmlnaHRCb3VuZCA9IGZhbHNlKSB7XG4gICAgaWYgKGNvbnRhaW5zKG5vZGUsIG9mZnNldCwgaW5jbHVkZVJpZ2h0Qm91bmQpKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aCAmJiBjaGlsZHJlbltpXS5vZmZzZXQgPD0gb2Zmc2V0OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gZmluZE5vZGVBdE9mZnNldChjaGlsZHJlbltpXSwgb2Zmc2V0LCBpbmNsdWRlUmlnaHRCb3VuZCk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIHRleHQgYW5kIGludm9rZXMgdGhlIHZpc2l0b3IgZnVuY3Rpb25zIGZvciBlYWNoIG9iamVjdCwgYXJyYXkgYW5kIGxpdGVyYWwgcmVhY2hlZC5cbiAqL1xuZnVuY3Rpb24gdmlzaXQodGV4dCwgdmlzaXRvciwgb3B0aW9ucyA9IFBhcnNlT3B0aW9ucy5ERUZBVUxUKSB7XG4gICAgY29uc3QgX3NjYW5uZXIgPSBjcmVhdGVTY2FubmVyKHRleHQsIGZhbHNlKTtcbiAgICAvLyBJbXBvcnRhbnQ6IE9ubHkgcGFzcyBjb3BpZXMgb2YgdGhpcyB0byB2aXNpdG9yIGZ1bmN0aW9ucyB0byBwcmV2ZW50IGFjY2lkZW50YWwgbW9kaWZpY2F0aW9uLCBhbmRcbiAgICAvLyB0byBub3QgYWZmZWN0IHZpc2l0b3IgZnVuY3Rpb25zIHdoaWNoIHN0b3JlZCBhIHJlZmVyZW5jZSB0byBhIHByZXZpb3VzIEpTT05QYXRoXG4gICAgY29uc3QgX2pzb25QYXRoID0gW107XG4gICAgZnVuY3Rpb24gdG9Ob0FyZ1Zpc2l0KHZpc2l0RnVuY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0RnVuY3Rpb24gPyAoKSA9PiB2aXNpdEZ1bmN0aW9uKF9zY2FubmVyLmdldFRva2VuT2Zmc2V0KCksIF9zY2FubmVyLmdldFRva2VuTGVuZ3RoKCksIF9zY2FubmVyLmdldFRva2VuU3RhcnRMaW5lKCksIF9zY2FubmVyLmdldFRva2VuU3RhcnRDaGFyYWN0ZXIoKSkgOiAoKSA9PiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b05vQXJnVmlzaXRXaXRoUGF0aCh2aXNpdEZ1bmN0aW9uKSB7XG4gICAgICAgIHJldHVybiB2aXNpdEZ1bmN0aW9uID8gKCkgPT4gdmlzaXRGdW5jdGlvbihfc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpLCBfc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpLCBfc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpLCBfc2Nhbm5lci5nZXRUb2tlblN0YXJ0Q2hhcmFjdGVyKCksICgpID0+IF9qc29uUGF0aC5zbGljZSgpKSA6ICgpID0+IHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvT25lQXJnVmlzaXQodmlzaXRGdW5jdGlvbikge1xuICAgICAgICByZXR1cm4gdmlzaXRGdW5jdGlvbiA/IChhcmcpID0+IHZpc2l0RnVuY3Rpb24oYXJnLCBfc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpLCBfc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpLCBfc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpLCBfc2Nhbm5lci5nZXRUb2tlblN0YXJ0Q2hhcmFjdGVyKCkpIDogKCkgPT4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9PbmVBcmdWaXNpdFdpdGhQYXRoKHZpc2l0RnVuY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0RnVuY3Rpb24gPyAoYXJnKSA9PiB2aXNpdEZ1bmN0aW9uKGFyZywgX3NjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSwgX3NjYW5uZXIuZ2V0VG9rZW5MZW5ndGgoKSwgX3NjYW5uZXIuZ2V0VG9rZW5TdGFydExpbmUoKSwgX3NjYW5uZXIuZ2V0VG9rZW5TdGFydENoYXJhY3RlcigpLCAoKSA9PiBfanNvblBhdGguc2xpY2UoKSkgOiAoKSA9PiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBvbk9iamVjdEJlZ2luID0gdG9Ob0FyZ1Zpc2l0V2l0aFBhdGgodmlzaXRvci5vbk9iamVjdEJlZ2luKSwgb25PYmplY3RQcm9wZXJ0eSA9IHRvT25lQXJnVmlzaXRXaXRoUGF0aCh2aXNpdG9yLm9uT2JqZWN0UHJvcGVydHkpLCBvbk9iamVjdEVuZCA9IHRvTm9BcmdWaXNpdCh2aXNpdG9yLm9uT2JqZWN0RW5kKSwgb25BcnJheUJlZ2luID0gdG9Ob0FyZ1Zpc2l0V2l0aFBhdGgodmlzaXRvci5vbkFycmF5QmVnaW4pLCBvbkFycmF5RW5kID0gdG9Ob0FyZ1Zpc2l0KHZpc2l0b3Iub25BcnJheUVuZCksIG9uTGl0ZXJhbFZhbHVlID0gdG9PbmVBcmdWaXNpdFdpdGhQYXRoKHZpc2l0b3Iub25MaXRlcmFsVmFsdWUpLCBvblNlcGFyYXRvciA9IHRvT25lQXJnVmlzaXQodmlzaXRvci5vblNlcGFyYXRvciksIG9uQ29tbWVudCA9IHRvTm9BcmdWaXNpdCh2aXNpdG9yLm9uQ29tbWVudCksIG9uRXJyb3IgPSB0b09uZUFyZ1Zpc2l0KHZpc2l0b3Iub25FcnJvcik7XG4gICAgY29uc3QgZGlzYWxsb3dDb21tZW50cyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kaXNhbGxvd0NvbW1lbnRzO1xuICAgIGNvbnN0IGFsbG93VHJhaWxpbmdDb21tYSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd1RyYWlsaW5nQ29tbWE7XG4gICAgZnVuY3Rpb24gc2Nhbk5leHQoKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IF9zY2FubmVyLnNjYW4oKTtcbiAgICAgICAgICAgIHN3aXRjaCAoX3NjYW5uZXIuZ2V0VG9rZW5FcnJvcigpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSA0IC8qIFNjYW5FcnJvci5JbnZhbGlkVW5pY29kZSAqLzpcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoMTQgLyogUGFyc2VFcnJvckNvZGUuSW52YWxpZFVuaWNvZGUgKi8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDUgLyogU2NhbkVycm9yLkludmFsaWRFc2NhcGVDaGFyYWN0ZXIgKi86XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKDE1IC8qIFBhcnNlRXJyb3JDb2RlLkludmFsaWRFc2NhcGVDaGFyYWN0ZXIgKi8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDMgLyogU2NhbkVycm9yLlVuZXhwZWN0ZWRFbmRPZk51bWJlciAqLzpcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoMTMgLyogUGFyc2VFcnJvckNvZGUuVW5leHBlY3RlZEVuZE9mTnVtYmVyICovKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIFNjYW5FcnJvci5VbmV4cGVjdGVkRW5kT2ZDb21tZW50ICovOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRpc2FsbG93Q29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKDExIC8qIFBhcnNlRXJyb3JDb2RlLlVuZXhwZWN0ZWRFbmRPZkNvbW1lbnQgKi8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMiAvKiBTY2FuRXJyb3IuVW5leHBlY3RlZEVuZE9mU3RyaW5nICovOlxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcigxMiAvKiBQYXJzZUVycm9yQ29kZS5VbmV4cGVjdGVkRW5kT2ZTdHJpbmcgKi8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDYgLyogU2NhbkVycm9yLkludmFsaWRDaGFyYWN0ZXIgKi86XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKDE2IC8qIFBhcnNlRXJyb3JDb2RlLkludmFsaWRDaGFyYWN0ZXIgKi8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDEyIC8qIFN5bnRheEtpbmQuTGluZUNvbW1lbnRUcml2aWEgKi86XG4gICAgICAgICAgICAgICAgY2FzZSAxMyAvKiBTeW50YXhLaW5kLkJsb2NrQ29tbWVudFRyaXZpYSAqLzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc2FsbG93Q29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKDEwIC8qIFBhcnNlRXJyb3JDb2RlLkludmFsaWRDb21tZW50VG9rZW4gKi8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Db21tZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxNiAvKiBTeW50YXhLaW5kLlVua25vd24gKi86XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKDEgLyogUGFyc2VFcnJvckNvZGUuSW52YWxpZFN5bWJvbCAqLyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTUgLyogU3ludGF4S2luZC5Ucml2aWEgKi86XG4gICAgICAgICAgICAgICAgY2FzZSAxNCAvKiBTeW50YXhLaW5kLkxpbmVCcmVha1RyaXZpYSAqLzpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycm9yLCBza2lwVW50aWxBZnRlciA9IFtdLCBza2lwVW50aWwgPSBbXSkge1xuICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgaWYgKHNraXBVbnRpbEFmdGVyLmxlbmd0aCArIHNraXBVbnRpbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgdG9rZW4gPSBfc2Nhbm5lci5nZXRUb2tlbigpO1xuICAgICAgICAgICAgd2hpbGUgKHRva2VuICE9PSAxNyAvKiBTeW50YXhLaW5kLkVPRiAqLykge1xuICAgICAgICAgICAgICAgIGlmIChza2lwVW50aWxBZnRlci5pbmRleE9mKHRva2VuKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nhbk5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNraXBVbnRpbC5pbmRleE9mKHRva2VuKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRva2VuID0gc2Nhbk5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVN0cmluZyhpc1ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gX3NjYW5uZXIuZ2V0VG9rZW5WYWx1ZSgpO1xuICAgICAgICBpZiAoaXNWYWx1ZSkge1xuICAgICAgICAgICAgb25MaXRlcmFsVmFsdWUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb25PYmplY3RQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICAgICAgICAvLyBhZGQgcHJvcGVydHkgbmFtZSBhZnRlcndhcmRzXG4gICAgICAgICAgICBfanNvblBhdGgucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgc2Nhbk5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlTGl0ZXJhbCgpIHtcbiAgICAgICAgc3dpdGNoIChfc2Nhbm5lci5nZXRUb2tlbigpKSB7XG4gICAgICAgICAgICBjYXNlIDExIC8qIFN5bnRheEtpbmQuTnVtZXJpY0xpdGVyYWwgKi86XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5WYWx1ZSA9IF9zY2FubmVyLmdldFRva2VuVmFsdWUoKTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBOdW1iZXIodG9rZW5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcigyIC8qIFBhcnNlRXJyb3JDb2RlLkludmFsaWROdW1iZXJGb3JtYXQgKi8pO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9uTGl0ZXJhbFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNyAvKiBTeW50YXhLaW5kLk51bGxLZXl3b3JkICovOlxuICAgICAgICAgICAgICAgIG9uTGl0ZXJhbFZhbHVlKG51bGwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4IC8qIFN5bnRheEtpbmQuVHJ1ZUtleXdvcmQgKi86XG4gICAgICAgICAgICAgICAgb25MaXRlcmFsVmFsdWUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDkgLyogU3ludGF4S2luZC5GYWxzZUtleXdvcmQgKi86XG4gICAgICAgICAgICAgICAgb25MaXRlcmFsVmFsdWUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc2Nhbk5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlUHJvcGVydHkoKSB7XG4gICAgICAgIGlmIChfc2Nhbm5lci5nZXRUb2tlbigpICE9PSAxMCAvKiBTeW50YXhLaW5kLlN0cmluZ0xpdGVyYWwgKi8pIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKDMgLyogUGFyc2VFcnJvckNvZGUuUHJvcGVydHlOYW1lRXhwZWN0ZWQgKi8sIFtdLCBbMiAvKiBTeW50YXhLaW5kLkNsb3NlQnJhY2VUb2tlbiAqLywgNSAvKiBTeW50YXhLaW5kLkNvbW1hVG9rZW4gKi9dKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZVN0cmluZyhmYWxzZSk7XG4gICAgICAgIGlmIChfc2Nhbm5lci5nZXRUb2tlbigpID09PSA2IC8qIFN5bnRheEtpbmQuQ29sb25Ub2tlbiAqLykge1xuICAgICAgICAgICAgb25TZXBhcmF0b3IoJzonKTtcbiAgICAgICAgICAgIHNjYW5OZXh0KCk7IC8vIGNvbnN1bWUgY29sb25cbiAgICAgICAgICAgIGlmICghcGFyc2VWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoNCAvKiBQYXJzZUVycm9yQ29kZS5WYWx1ZUV4cGVjdGVkICovLCBbXSwgWzIgLyogU3ludGF4S2luZC5DbG9zZUJyYWNlVG9rZW4gKi8sIDUgLyogU3ludGF4S2luZC5Db21tYVRva2VuICovXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVFcnJvcig1IC8qIFBhcnNlRXJyb3JDb2RlLkNvbG9uRXhwZWN0ZWQgKi8sIFtdLCBbMiAvKiBTeW50YXhLaW5kLkNsb3NlQnJhY2VUb2tlbiAqLywgNSAvKiBTeW50YXhLaW5kLkNvbW1hVG9rZW4gKi9dKTtcbiAgICAgICAgfVxuICAgICAgICBfanNvblBhdGgucG9wKCk7IC8vIHJlbW92ZSBwcm9jZXNzZWQgcHJvcGVydHkgbmFtZVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VPYmplY3QoKSB7XG4gICAgICAgIG9uT2JqZWN0QmVnaW4oKTtcbiAgICAgICAgc2Nhbk5leHQoKTsgLy8gY29uc3VtZSBvcGVuIGJyYWNlXG4gICAgICAgIGxldCBuZWVkc0NvbW1hID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChfc2Nhbm5lci5nZXRUb2tlbigpICE9PSAyIC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICovICYmIF9zY2FubmVyLmdldFRva2VuKCkgIT09IDE3IC8qIFN5bnRheEtpbmQuRU9GICovKSB7XG4gICAgICAgICAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gNSAvKiBTeW50YXhLaW5kLkNvbW1hVG9rZW4gKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5lZWRzQ29tbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoNCAvKiBQYXJzZUVycm9yQ29kZS5WYWx1ZUV4cGVjdGVkICovLCBbXSwgW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvblNlcGFyYXRvcignLCcpO1xuICAgICAgICAgICAgICAgIHNjYW5OZXh0KCk7IC8vIGNvbnN1bWUgY29tbWFcbiAgICAgICAgICAgICAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gMiAvKiBTeW50YXhLaW5kLkNsb3NlQnJhY2VUb2tlbiAqLyAmJiBhbGxvd1RyYWlsaW5nQ29tbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmVlZHNDb21tYSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKDYgLyogUGFyc2VFcnJvckNvZGUuQ29tbWFFeHBlY3RlZCAqLywgW10sIFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcGFyc2VQcm9wZXJ0eSgpKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoNCAvKiBQYXJzZUVycm9yQ29kZS5WYWx1ZUV4cGVjdGVkICovLCBbXSwgWzIgLyogU3ludGF4S2luZC5DbG9zZUJyYWNlVG9rZW4gKi8sIDUgLyogU3ludGF4S2luZC5Db21tYVRva2VuICovXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZWVkc0NvbW1hID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBvbk9iamVjdEVuZCgpO1xuICAgICAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMiAvKiBTeW50YXhLaW5kLkNsb3NlQnJhY2VUb2tlbiAqLykge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoNyAvKiBQYXJzZUVycm9yQ29kZS5DbG9zZUJyYWNlRXhwZWN0ZWQgKi8sIFsyIC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICovXSwgW10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2Nhbk5leHQoKTsgLy8gY29uc3VtZSBjbG9zZSBicmFjZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUFycmF5KCkge1xuICAgICAgICBvbkFycmF5QmVnaW4oKTtcbiAgICAgICAgc2Nhbk5leHQoKTsgLy8gY29uc3VtZSBvcGVuIGJyYWNrZXRcbiAgICAgICAgbGV0IGlzRmlyc3RFbGVtZW50ID0gdHJ1ZTtcbiAgICAgICAgbGV0IG5lZWRzQ29tbWEgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKF9zY2FubmVyLmdldFRva2VuKCkgIT09IDQgLyogU3ludGF4S2luZC5DbG9zZUJyYWNrZXRUb2tlbiAqLyAmJiBfc2Nhbm5lci5nZXRUb2tlbigpICE9PSAxNyAvKiBTeW50YXhLaW5kLkVPRiAqLykge1xuICAgICAgICAgICAgaWYgKF9zY2FubmVyLmdldFRva2VuKCkgPT09IDUgLyogU3ludGF4S2luZC5Db21tYVRva2VuICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFuZWVkc0NvbW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKDQgLyogUGFyc2VFcnJvckNvZGUuVmFsdWVFeHBlY3RlZCAqLywgW10sIFtdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb25TZXBhcmF0b3IoJywnKTtcbiAgICAgICAgICAgICAgICBzY2FuTmV4dCgpOyAvLyBjb25zdW1lIGNvbW1hXG4gICAgICAgICAgICAgICAgaWYgKF9zY2FubmVyLmdldFRva2VuKCkgPT09IDQgLyogU3ludGF4S2luZC5DbG9zZUJyYWNrZXRUb2tlbiAqLyAmJiBhbGxvd1RyYWlsaW5nQ29tbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmVlZHNDb21tYSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKDYgLyogUGFyc2VFcnJvckNvZGUuQ29tbWFFeHBlY3RlZCAqLywgW10sIFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0ZpcnN0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIF9qc29uUGF0aC5wdXNoKDApO1xuICAgICAgICAgICAgICAgIGlzRmlyc3RFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfanNvblBhdGhbX2pzb25QYXRoLmxlbmd0aCAtIDFdKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXBhcnNlVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKDQgLyogUGFyc2VFcnJvckNvZGUuVmFsdWVFeHBlY3RlZCAqLywgW10sIFs0IC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFja2V0VG9rZW4gKi8sIDUgLyogU3ludGF4S2luZC5Db21tYVRva2VuICovXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZWVkc0NvbW1hID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBvbkFycmF5RW5kKCk7XG4gICAgICAgIGlmICghaXNGaXJzdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIF9qc29uUGF0aC5wb3AoKTsgLy8gcmVtb3ZlIGFycmF5IGluZGV4XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9zY2FubmVyLmdldFRva2VuKCkgIT09IDQgLyogU3ludGF4S2luZC5DbG9zZUJyYWNrZXRUb2tlbiAqLykge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoOCAvKiBQYXJzZUVycm9yQ29kZS5DbG9zZUJyYWNrZXRFeHBlY3RlZCAqLywgWzQgLyogU3ludGF4S2luZC5DbG9zZUJyYWNrZXRUb2tlbiAqL10sIFtdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjYW5OZXh0KCk7IC8vIGNvbnN1bWUgY2xvc2UgYnJhY2tldFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVZhbHVlKCkge1xuICAgICAgICBzd2l0Y2ggKF9zY2FubmVyLmdldFRva2VuKCkpIHtcbiAgICAgICAgICAgIGNhc2UgMyAvKiBTeW50YXhLaW5kLk9wZW5CcmFja2V0VG9rZW4gKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQXJyYXkoKTtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBTeW50YXhLaW5kLk9wZW5CcmFjZVRva2VuICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZU9iamVjdCgpO1xuICAgICAgICAgICAgY2FzZSAxMCAvKiBTeW50YXhLaW5kLlN0cmluZ0xpdGVyYWwgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlU3RyaW5nKHRydWUpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VMaXRlcmFsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2Nhbk5leHQoKTtcbiAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gMTcgLyogU3ludGF4S2luZC5FT0YgKi8pIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dFbXB0eUNvbnRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZUVycm9yKDQgLyogUGFyc2VFcnJvckNvZGUuVmFsdWVFeHBlY3RlZCAqLywgW10sIFtdKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXBhcnNlVmFsdWUoKSkge1xuICAgICAgICBoYW5kbGVFcnJvcig0IC8qIFBhcnNlRXJyb3JDb2RlLlZhbHVlRXhwZWN0ZWQgKi8sIFtdLCBbXSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKF9zY2FubmVyLmdldFRva2VuKCkgIT09IDE3IC8qIFN5bnRheEtpbmQuRU9GICovKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKDkgLyogUGFyc2VFcnJvckNvZGUuRW5kT2ZGaWxlRXhwZWN0ZWQgKi8sIFtdLCBbXSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBUYWtlcyBKU09OIHdpdGggSmF2YVNjcmlwdC1zdHlsZSBjb21tZW50cyBhbmQgcmVtb3ZlXG4gKiB0aGVtLiBPcHRpb25hbGx5IHJlcGxhY2VzIGV2ZXJ5IG5vbmUtbmV3bGluZSBjaGFyYWN0ZXJcbiAqIG9mIGNvbW1lbnRzIHdpdGggYSByZXBsYWNlQ2hhcmFjdGVyXG4gKi9cbmZ1bmN0aW9uIHN0cmlwQ29tbWVudHModGV4dCwgcmVwbGFjZUNoKSB7XG4gICAgbGV0IF9zY2FubmVyID0gY3JlYXRlU2Nhbm5lcih0ZXh0KSwgcGFydHMgPSBbXSwga2luZCwgb2Zmc2V0ID0gMCwgcG9zO1xuICAgIGRvIHtcbiAgICAgICAgcG9zID0gX3NjYW5uZXIuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAga2luZCA9IF9zY2FubmVyLnNjYW4oKTtcbiAgICAgICAgc3dpdGNoIChraW5kKSB7XG4gICAgICAgICAgICBjYXNlIDEyIC8qIFN5bnRheEtpbmQuTGluZUNvbW1lbnRUcml2aWEgKi86XG4gICAgICAgICAgICBjYXNlIDEzIC8qIFN5bnRheEtpbmQuQmxvY2tDb21tZW50VHJpdmlhICovOlxuICAgICAgICAgICAgY2FzZSAxNyAvKiBTeW50YXhLaW5kLkVPRiAqLzpcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ICE9PSBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydHMucHVzaCh0ZXh0LnN1YnN0cmluZyhvZmZzZXQsIHBvcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVwbGFjZUNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydHMucHVzaChfc2Nhbm5lci5nZXRUb2tlblZhbHVlKCkucmVwbGFjZSgvW15cXHJcXG5dL2csIHJlcGxhY2VDaCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBfc2Nhbm5lci5nZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSB3aGlsZSAoa2luZCAhPT0gMTcgLyogU3ludGF4S2luZC5FT0YgKi8pO1xuICAgIHJldHVybiBwYXJ0cy5qb2luKCcnKTtcbn1cbmZ1bmN0aW9uIGdldE5vZGVUeXBlKHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6IHJldHVybiAnYm9vbGVhbic7XG4gICAgICAgIGNhc2UgJ251bWJlcic6IHJldHVybiAnbnVtYmVyJztcbiAgICAgICAgY2FzZSAnc3RyaW5nJzogcmV0dXJuICdzdHJpbmcnO1xuICAgICAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDogcmV0dXJuICdudWxsJztcbiAgICB9XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvanNvbmMtcGFyc2VyL2xpYi9lc20vaW1wbC9lZGl0LmpzXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cbmZ1bmN0aW9uIHJlbW92ZVByb3BlcnR5KHRleHQsIHBhdGgsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gc2V0UHJvcGVydHkodGV4dCwgcGF0aCwgdm9pZCAwLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHNldFByb3BlcnR5KHRleHQsIG9yaWdpbmFsUGF0aCwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBwYXRoID0gb3JpZ2luYWxQYXRoLnNsaWNlKCk7XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgY29uc3Qgcm9vdCA9IHBhcnNlVHJlZSh0ZXh0LCBlcnJvcnMpO1xuICAgIGxldCBwYXJlbnQgPSB2b2lkIDA7XG4gICAgbGV0IGxhc3RTZWdtZW50ID0gdm9pZCAwO1xuICAgIHdoaWxlIChwYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGFzdFNlZ21lbnQgPSBwYXRoLnBvcCgpO1xuICAgICAgICBwYXJlbnQgPSBmaW5kTm9kZUF0TG9jYXRpb24ocm9vdCwgcGF0aCk7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IHZvaWQgMCAmJiB2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxhc3RTZWdtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0geyBbbGFzdFNlZ21lbnRdOiB2YWx1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgLy8gZW1wdHkgZG9jdW1lbnRcbiAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgLy8gZGVsZXRlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgZGVsZXRlIGluIGVtcHR5IGRvY3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdpdGhGb3JtYXR0aW5nKHRleHQsIHsgb2Zmc2V0OiByb290ID8gcm9vdC5vZmZzZXQgOiAwLCBsZW5ndGg6IHJvb3QgPyByb290Lmxlbmd0aCA6IDAsIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHZhbHVlKSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFyZW50LnR5cGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBsYXN0U2VnbWVudCA9PT0gJ3N0cmluZycgJiYgQXJyYXkuaXNBcnJheShwYXJlbnQuY2hpbGRyZW4pKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gZmluZE5vZGVBdExvY2F0aW9uKHBhcmVudCwgW2xhc3RTZWdtZW50XSk7XG4gICAgICAgIGlmIChleGlzdGluZyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyAvLyBkZWxldGVcbiAgICAgICAgICAgICAgICBpZiAoIWV4aXN0aW5nLnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBBU1QnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHlJbmRleCA9IHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKGV4aXN0aW5nLnBhcmVudCk7XG4gICAgICAgICAgICAgICAgbGV0IHJlbW92ZUJlZ2luO1xuICAgICAgICAgICAgICAgIGxldCByZW1vdmVFbmQgPSBleGlzdGluZy5wYXJlbnQub2Zmc2V0ICsgZXhpc3RpbmcucGFyZW50Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBjb21tYSBvZiB0aGUgcHJldmlvdXMgbm9kZVxuICAgICAgICAgICAgICAgICAgICBsZXQgcHJldmlvdXMgPSBwYXJlbnQuY2hpbGRyZW5bcHJvcGVydHlJbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVCZWdpbiA9IHByZXZpb3VzLm9mZnNldCArIHByZXZpb3VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUJlZ2luID0gcGFyZW50Lm9mZnNldCArIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBjb21tYSBvZiB0aGUgbmV4dCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHBhcmVudC5jaGlsZHJlblsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUVuZCA9IG5leHQub2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB3aXRoRm9ybWF0dGluZyh0ZXh0LCB7IG9mZnNldDogcmVtb3ZlQmVnaW4sIGxlbmd0aDogcmVtb3ZlRW5kIC0gcmVtb3ZlQmVnaW4sIGNvbnRlbnQ6ICcnIH0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc2V0IHZhbHVlIG9mIGV4aXN0aW5nIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpdGhGb3JtYXR0aW5nKHRleHQsIHsgb2Zmc2V0OiBleGlzdGluZy5vZmZzZXQsIGxlbmd0aDogZXhpc3RpbmcubGVuZ3RoLCBjb250ZW50OiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyAvLyBkZWxldGVcbiAgICAgICAgICAgICAgICByZXR1cm4gW107IC8vIHByb3BlcnR5IGRvZXMgbm90IGV4aXN0LCBub3RoaW5nIHRvIGRvXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXdQcm9wZXJ0eSA9IGAke0pTT04uc3RyaW5naWZ5KGxhc3RTZWdtZW50KX06ICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWA7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IG9wdGlvbnMuZ2V0SW5zZXJ0aW9uSW5kZXggPyBvcHRpb25zLmdldEluc2VydGlvbkluZGV4KHBhcmVudC5jaGlsZHJlbi5tYXAocCA9PiBwLmNoaWxkcmVuWzBdLnZhbHVlKSkgOiBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGVkaXQ7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZXZpb3VzID0gcGFyZW50LmNoaWxkcmVuW2luZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgZWRpdCA9IHsgb2Zmc2V0OiBwcmV2aW91cy5vZmZzZXQgKyBwcmV2aW91cy5sZW5ndGgsIGxlbmd0aDogMCwgY29udGVudDogJywnICsgbmV3UHJvcGVydHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudC5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBlZGl0ID0geyBvZmZzZXQ6IHBhcmVudC5vZmZzZXQgKyAxLCBsZW5ndGg6IDAsIGNvbnRlbnQ6IG5ld1Byb3BlcnR5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlZGl0ID0geyBvZmZzZXQ6IHBhcmVudC5vZmZzZXQgKyAxLCBsZW5ndGg6IDAsIGNvbnRlbnQ6IG5ld1Byb3BlcnR5ICsgJywnIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2l0aEZvcm1hdHRpbmcodGV4dCwgZWRpdCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocGFyZW50LnR5cGUgPT09ICdhcnJheScgJiYgdHlwZW9mIGxhc3RTZWdtZW50ID09PSAnbnVtYmVyJyAmJiBBcnJheS5pc0FycmF5KHBhcmVudC5jaGlsZHJlbikpIHtcbiAgICAgICAgY29uc3QgaW5zZXJ0SW5kZXggPSBsYXN0U2VnbWVudDtcbiAgICAgICAgaWYgKGluc2VydEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgLy8gSW5zZXJ0XG4gICAgICAgICAgICBjb25zdCBuZXdQcm9wZXJ0eSA9IGAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gO1xuICAgICAgICAgICAgbGV0IGVkaXQ7XG4gICAgICAgICAgICBpZiAocGFyZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGVkaXQgPSB7IG9mZnNldDogcGFyZW50Lm9mZnNldCArIDEsIGxlbmd0aDogMCwgY29udGVudDogbmV3UHJvcGVydHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gcGFyZW50LmNoaWxkcmVuW3BhcmVudC5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBlZGl0ID0geyBvZmZzZXQ6IHByZXZpb3VzLm9mZnNldCArIHByZXZpb3VzLmxlbmd0aCwgbGVuZ3RoOiAwLCBjb250ZW50OiAnLCcgKyBuZXdQcm9wZXJ0eSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdpdGhGb3JtYXR0aW5nKHRleHQsIGVkaXQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSB2b2lkIDAgJiYgcGFyZW50LmNoaWxkcmVuLmxlbmd0aCA+PSAwKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmFsXG4gICAgICAgICAgICBjb25zdCByZW1vdmFsSW5kZXggPSBsYXN0U2VnbWVudDtcbiAgICAgICAgICAgIGNvbnN0IHRvUmVtb3ZlID0gcGFyZW50LmNoaWxkcmVuW3JlbW92YWxJbmRleF07XG4gICAgICAgICAgICBsZXQgZWRpdDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBpdGVtXG4gICAgICAgICAgICAgICAgZWRpdCA9IHsgb2Zmc2V0OiBwYXJlbnQub2Zmc2V0ICsgMSwgbGVuZ3RoOiBwYXJlbnQubGVuZ3RoIC0gMiwgY29udGVudDogJycgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudC5jaGlsZHJlbi5sZW5ndGggLSAxID09PSByZW1vdmFsSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBsYXN0IGl0ZW1cbiAgICAgICAgICAgICAgICBsZXQgcHJldmlvdXMgPSBwYXJlbnQuY2hpbGRyZW5bcmVtb3ZhbEluZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IHByZXZpb3VzLm9mZnNldCArIHByZXZpb3VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50RW5kT2Zmc2V0ID0gcGFyZW50Lm9mZnNldCArIHBhcmVudC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZWRpdCA9IHsgb2Zmc2V0LCBsZW5ndGg6IHBhcmVudEVuZE9mZnNldCAtIDIgLSBvZmZzZXQsIGNvbnRlbnQ6ICcnIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlZGl0ID0geyBvZmZzZXQ6IHRvUmVtb3ZlLm9mZnNldCwgbGVuZ3RoOiBwYXJlbnQuY2hpbGRyZW5bcmVtb3ZhbEluZGV4ICsgMV0ub2Zmc2V0IC0gdG9SZW1vdmUub2Zmc2V0LCBjb250ZW50OiAnJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdpdGhGb3JtYXR0aW5nKHRleHQsIGVkaXQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGxldCBlZGl0O1xuICAgICAgICAgICAgY29uc3QgbmV3UHJvcGVydHkgPSBgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YDtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5pc0FycmF5SW5zZXJ0aW9uICYmIHBhcmVudC5jaGlsZHJlbi5sZW5ndGggPiBsYXN0U2VnbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvTW9kaWZ5ID0gcGFyZW50LmNoaWxkcmVuW2xhc3RTZWdtZW50XTtcbiAgICAgICAgICAgICAgICBlZGl0ID0geyBvZmZzZXQ6IHRvTW9kaWZ5Lm9mZnNldCwgbGVuZ3RoOiB0b01vZGlmeS5sZW5ndGgsIGNvbnRlbnQ6IG5ld1Byb3BlcnR5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IGxhc3RTZWdtZW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZWRpdCA9IHsgb2Zmc2V0OiBwYXJlbnQub2Zmc2V0ICsgMSwgbGVuZ3RoOiAwLCBjb250ZW50OiBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAwID8gbmV3UHJvcGVydHkgOiBuZXdQcm9wZXJ0eSArICcsJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBsYXN0U2VnbWVudCA+IHBhcmVudC5jaGlsZHJlbi5sZW5ndGggPyBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoIDogbGFzdFNlZ21lbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXMgPSBwYXJlbnQuY2hpbGRyZW5baW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICBlZGl0ID0geyBvZmZzZXQ6IHByZXZpb3VzLm9mZnNldCArIHByZXZpb3VzLmxlbmd0aCwgbGVuZ3RoOiAwLCBjb250ZW50OiAnLCcgKyBuZXdQcm9wZXJ0eSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdpdGhGb3JtYXR0aW5nKHRleHQsIGVkaXQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4gbm90ICR7dmFsdWUgPT09IHZvaWQgMCA/ICdyZW1vdmUnIDogKG9wdGlvbnMuaXNBcnJheUluc2VydGlvbiA/ICdpbnNlcnQnIDogJ21vZGlmeScpfSBBcnJheSBpbmRleCAke2luc2VydEluZGV4fSBhcyBsZW5ndGggaXMgbm90IHN1ZmZpY2llbnRgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4gbm90IGFkZCAke3R5cGVvZiBsYXN0U2VnbWVudCAhPT0gJ251bWJlcicgPyAnaW5kZXgnIDogJ3Byb3BlcnR5J30gdG8gcGFyZW50IG9mIHR5cGUgJHtwYXJlbnQudHlwZX1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiB3aXRoRm9ybWF0dGluZyh0ZXh0LCBlZGl0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLmZvcm1hdHRpbmdPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBbZWRpdF07XG4gICAgfVxuICAgIC8vIGFwcGx5IHRoZSBlZGl0XG4gICAgbGV0IG5ld1RleHQgPSBhcHBseUVkaXQodGV4dCwgZWRpdCk7XG4gICAgLy8gZm9ybWF0IHRoZSBuZXcgdGV4dFxuICAgIGxldCBiZWdpbiA9IGVkaXQub2Zmc2V0O1xuICAgIGxldCBlbmQgPSBlZGl0Lm9mZnNldCArIGVkaXQuY29udGVudC5sZW5ndGg7XG4gICAgaWYgKGVkaXQubGVuZ3RoID09PSAwIHx8IGVkaXQuY29udGVudC5sZW5ndGggPT09IDApIHsgLy8gaW5zZXJ0IG9yIHJlbW92ZVxuICAgICAgICB3aGlsZSAoYmVnaW4gPiAwICYmICFpc0VPTChuZXdUZXh0LCBiZWdpbiAtIDEpKSB7XG4gICAgICAgICAgICBiZWdpbi0tO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChlbmQgPCBuZXdUZXh0Lmxlbmd0aCAmJiAhaXNFT0wobmV3VGV4dCwgZW5kKSkge1xuICAgICAgICAgICAgZW5kKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZWRpdHMgPSBmb3JtYXQobmV3VGV4dCwgeyBvZmZzZXQ6IGJlZ2luLCBsZW5ndGg6IGVuZCAtIGJlZ2luIH0sIHsgLi4ub3B0aW9ucy5mb3JtYXR0aW5nT3B0aW9ucywga2VlcExpbmVzOiBmYWxzZSB9KTtcbiAgICAvLyBhcHBseSB0aGUgZm9ybWF0dGluZyBlZGl0cyBhbmQgdHJhY2sgdGhlIGJlZ2luIGFuZCBlbmQgb2Zmc2V0cyBvZiB0aGUgY2hhbmdlc1xuICAgIGZvciAobGV0IGkgPSBlZGl0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBlZGl0ID0gZWRpdHNbaV07XG4gICAgICAgIG5ld1RleHQgPSBhcHBseUVkaXQobmV3VGV4dCwgZWRpdCk7XG4gICAgICAgIGJlZ2luID0gTWF0aC5taW4oYmVnaW4sIGVkaXQub2Zmc2V0KTtcbiAgICAgICAgZW5kID0gTWF0aC5tYXgoZW5kLCBlZGl0Lm9mZnNldCArIGVkaXQubGVuZ3RoKTtcbiAgICAgICAgZW5kICs9IGVkaXQuY29udGVudC5sZW5ndGggLSBlZGl0Lmxlbmd0aDtcbiAgICB9XG4gICAgLy8gY3JlYXRlIGEgc2luZ2xlIGVkaXQgd2l0aCBhbGwgY2hhbmdlc1xuICAgIGNvbnN0IGVkaXRMZW5ndGggPSB0ZXh0Lmxlbmd0aCAtIChuZXdUZXh0Lmxlbmd0aCAtIGVuZCkgLSBiZWdpbjtcbiAgICByZXR1cm4gW3sgb2Zmc2V0OiBiZWdpbiwgbGVuZ3RoOiBlZGl0TGVuZ3RoLCBjb250ZW50OiBuZXdUZXh0LnN1YnN0cmluZyhiZWdpbiwgZW5kKSB9XTtcbn1cbmZ1bmN0aW9uIGFwcGx5RWRpdCh0ZXh0LCBlZGl0KSB7XG4gICAgcmV0dXJuIHRleHQuc3Vic3RyaW5nKDAsIGVkaXQub2Zmc2V0KSArIGVkaXQuY29udGVudCArIHRleHQuc3Vic3RyaW5nKGVkaXQub2Zmc2V0ICsgZWRpdC5sZW5ndGgpO1xufVxuZnVuY3Rpb24gaXNXUyh0ZXh0LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gJ1xcclxcbiBcXHQnLmluZGV4T2YodGV4dC5jaGFyQXQob2Zmc2V0KSkgIT09IC0xO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL2pzb25jLXBhcnNlci9saWIvZXNtL21haW4uanNcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblxuXG5cbi8qKlxuICogQ3JlYXRlcyBhIEpTT04gc2Nhbm5lciBvbiB0aGUgZ2l2ZW4gdGV4dC5cbiAqIElmIGlnbm9yZVRyaXZpYSBpcyBzZXQsIHdoaXRlc3BhY2VzIG9yIGNvbW1lbnRzIGFyZSBpZ25vcmVkLlxuICovXG5jb25zdCBtYWluX2NyZWF0ZVNjYW5uZXIgPSBjcmVhdGVTY2FubmVyO1xudmFyIFNjYW5FcnJvcjtcbihmdW5jdGlvbiAoU2NhbkVycm9yKSB7XG4gICAgU2NhbkVycm9yW1NjYW5FcnJvcltcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xuICAgIFNjYW5FcnJvcltTY2FuRXJyb3JbXCJVbmV4cGVjdGVkRW5kT2ZDb21tZW50XCJdID0gMV0gPSBcIlVuZXhwZWN0ZWRFbmRPZkNvbW1lbnRcIjtcbiAgICBTY2FuRXJyb3JbU2NhbkVycm9yW1wiVW5leHBlY3RlZEVuZE9mU3RyaW5nXCJdID0gMl0gPSBcIlVuZXhwZWN0ZWRFbmRPZlN0cmluZ1wiO1xuICAgIFNjYW5FcnJvcltTY2FuRXJyb3JbXCJVbmV4cGVjdGVkRW5kT2ZOdW1iZXJcIl0gPSAzXSA9IFwiVW5leHBlY3RlZEVuZE9mTnVtYmVyXCI7XG4gICAgU2NhbkVycm9yW1NjYW5FcnJvcltcIkludmFsaWRVbmljb2RlXCJdID0gNF0gPSBcIkludmFsaWRVbmljb2RlXCI7XG4gICAgU2NhbkVycm9yW1NjYW5FcnJvcltcIkludmFsaWRFc2NhcGVDaGFyYWN0ZXJcIl0gPSA1XSA9IFwiSW52YWxpZEVzY2FwZUNoYXJhY3RlclwiO1xuICAgIFNjYW5FcnJvcltTY2FuRXJyb3JbXCJJbnZhbGlkQ2hhcmFjdGVyXCJdID0gNl0gPSBcIkludmFsaWRDaGFyYWN0ZXJcIjtcbn0pKFNjYW5FcnJvciB8fCAoU2NhbkVycm9yID0ge30pKTtcbnZhciBTeW50YXhLaW5kO1xuKGZ1bmN0aW9uIChTeW50YXhLaW5kKSB7XG4gICAgU3ludGF4S2luZFtTeW50YXhLaW5kW1wiT3BlbkJyYWNlVG9rZW5cIl0gPSAxXSA9IFwiT3BlbkJyYWNlVG9rZW5cIjtcbiAgICBTeW50YXhLaW5kW1N5bnRheEtpbmRbXCJDbG9zZUJyYWNlVG9rZW5cIl0gPSAyXSA9IFwiQ2xvc2VCcmFjZVRva2VuXCI7XG4gICAgU3ludGF4S2luZFtTeW50YXhLaW5kW1wiT3BlbkJyYWNrZXRUb2tlblwiXSA9IDNdID0gXCJPcGVuQnJhY2tldFRva2VuXCI7XG4gICAgU3ludGF4S2luZFtTeW50YXhLaW5kW1wiQ2xvc2VCcmFja2V0VG9rZW5cIl0gPSA0XSA9IFwiQ2xvc2VCcmFja2V0VG9rZW5cIjtcbiAgICBTeW50YXhLaW5kW1N5bnRheEtpbmRbXCJDb21tYVRva2VuXCJdID0gNV0gPSBcIkNvbW1hVG9rZW5cIjtcbiAgICBTeW50YXhLaW5kW1N5bnRheEtpbmRbXCJDb2xvblRva2VuXCJdID0gNl0gPSBcIkNvbG9uVG9rZW5cIjtcbiAgICBTeW50YXhLaW5kW1N5bnRheEtpbmRbXCJOdWxsS2V5d29yZFwiXSA9IDddID0gXCJOdWxsS2V5d29yZFwiO1xuICAgIFN5bnRheEtpbmRbU3ludGF4S2luZFtcIlRydWVLZXl3b3JkXCJdID0gOF0gPSBcIlRydWVLZXl3b3JkXCI7XG4gICAgU3ludGF4S2luZFtTeW50YXhLaW5kW1wiRmFsc2VLZXl3b3JkXCJdID0gOV0gPSBcIkZhbHNlS2V5d29yZFwiO1xuICAgIFN5bnRheEtpbmRbU3ludGF4S2luZFtcIlN0cmluZ0xpdGVyYWxcIl0gPSAxMF0gPSBcIlN0cmluZ0xpdGVyYWxcIjtcbiAgICBTeW50YXhLaW5kW1N5bnRheEtpbmRbXCJOdW1lcmljTGl0ZXJhbFwiXSA9IDExXSA9IFwiTnVtZXJpY0xpdGVyYWxcIjtcbiAgICBTeW50YXhLaW5kW1N5bnRheEtpbmRbXCJMaW5lQ29tbWVudFRyaXZpYVwiXSA9IDEyXSA9IFwiTGluZUNvbW1lbnRUcml2aWFcIjtcbiAgICBTeW50YXhLaW5kW1N5bnRheEtpbmRbXCJCbG9ja0NvbW1lbnRUcml2aWFcIl0gPSAxM10gPSBcIkJsb2NrQ29tbWVudFRyaXZpYVwiO1xuICAgIFN5bnRheEtpbmRbU3ludGF4S2luZFtcIkxpbmVCcmVha1RyaXZpYVwiXSA9IDE0XSA9IFwiTGluZUJyZWFrVHJpdmlhXCI7XG4gICAgU3ludGF4S2luZFtTeW50YXhLaW5kW1wiVHJpdmlhXCJdID0gMTVdID0gXCJUcml2aWFcIjtcbiAgICBTeW50YXhLaW5kW1N5bnRheEtpbmRbXCJVbmtub3duXCJdID0gMTZdID0gXCJVbmtub3duXCI7XG4gICAgU3ludGF4S2luZFtTeW50YXhLaW5kW1wiRU9GXCJdID0gMTddID0gXCJFT0ZcIjtcbn0pKFN5bnRheEtpbmQgfHwgKFN5bnRheEtpbmQgPSB7fSkpO1xuLyoqXG4gKiBGb3IgYSBnaXZlbiBvZmZzZXQsIGV2YWx1YXRlIHRoZSBsb2NhdGlvbiBpbiB0aGUgSlNPTiBkb2N1bWVudC4gRWFjaCBzZWdtZW50IGluIHRoZSBsb2NhdGlvbiBwYXRoIGlzIGVpdGhlciBhIHByb3BlcnR5IG5hbWUgb3IgYW4gYXJyYXkgaW5kZXguXG4gKi9cbmNvbnN0IG1haW5fZ2V0TG9jYXRpb24gPSBnZXRMb2NhdGlvbjtcbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiB0ZXh0IGFuZCByZXR1cm5zIHRoZSBvYmplY3QgdGhlIEpTT04gY29udGVudCByZXByZXNlbnRzLiBPbiBpbnZhbGlkIGlucHV0LCB0aGUgcGFyc2VyIHRyaWVzIHRvIGJlIGFzIGZhdWx0IHRvbGVyYW50IGFzIHBvc3NpYmxlLCBidXQgc3RpbGwgcmV0dXJuIGEgcmVzdWx0LlxuICogVGhlcmVmb3JlLCBhbHdheXMgY2hlY2sgdGhlIGVycm9ycyBsaXN0IHRvIGZpbmQgb3V0IGlmIHRoZSBpbnB1dCB3YXMgdmFsaWQuXG4gKi9cbmNvbnN0IG1haW5fcGFyc2UgPSBwYXJzZTtcbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiB0ZXh0IGFuZCByZXR1cm5zIGEgdHJlZSByZXByZXNlbnRhdGlvbiB0aGUgSlNPTiBjb250ZW50LiBPbiBpbnZhbGlkIGlucHV0LCB0aGUgcGFyc2VyIHRyaWVzIHRvIGJlIGFzIGZhdWx0IHRvbGVyYW50IGFzIHBvc3NpYmxlLCBidXQgc3RpbGwgcmV0dXJuIGEgcmVzdWx0LlxuICovXG5jb25zdCBtYWluX3BhcnNlVHJlZSA9IHBhcnNlcl9wYXJzZVRyZWU7XG4vKipcbiAqIEZpbmRzIHRoZSBub2RlIGF0IHRoZSBnaXZlbiBwYXRoIGluIGEgSlNPTiBET00uXG4gKi9cbmNvbnN0IG1haW5fZmluZE5vZGVBdExvY2F0aW9uID0gcGFyc2VyX2ZpbmROb2RlQXRMb2NhdGlvbjtcbi8qKlxuICogRmluZHMgdGhlIGlubmVybW9zdCBub2RlIGF0IHRoZSBnaXZlbiBvZmZzZXQuIElmIGluY2x1ZGVSaWdodEJvdW5kIGlzIHNldCwgYWxzbyBmaW5kcyBub2RlcyB0aGF0IGVuZCBhdCB0aGUgZ2l2ZW4gb2Zmc2V0LlxuICovXG5jb25zdCBtYWluX2ZpbmROb2RlQXRPZmZzZXQgPSBmaW5kTm9kZUF0T2Zmc2V0O1xuLyoqXG4gKiBHZXRzIHRoZSBKU09OIHBhdGggb2YgdGhlIGdpdmVuIEpTT04gRE9NIG5vZGVcbiAqL1xuY29uc3QgbWFpbl9nZXROb2RlUGF0aCA9IGdldE5vZGVQYXRoO1xuLyoqXG4gKiBFdmFsdWF0ZXMgdGhlIEphdmFTY3JpcHQgb2JqZWN0IG9mIHRoZSBnaXZlbiBKU09OIERPTSBub2RlXG4gKi9cbmNvbnN0IG1haW5fZ2V0Tm9kZVZhbHVlID0gZ2V0Tm9kZVZhbHVlO1xuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIHRleHQgYW5kIGludm9rZXMgdGhlIHZpc2l0b3IgZnVuY3Rpb25zIGZvciBlYWNoIG9iamVjdCwgYXJyYXkgYW5kIGxpdGVyYWwgcmVhY2hlZC5cbiAqL1xuY29uc3QgbWFpbl92aXNpdCA9IHZpc2l0O1xuLyoqXG4gKiBUYWtlcyBKU09OIHdpdGggSmF2YVNjcmlwdC1zdHlsZSBjb21tZW50cyBhbmQgcmVtb3ZlXG4gKiB0aGVtLiBPcHRpb25hbGx5IHJlcGxhY2VzIGV2ZXJ5IG5vbmUtbmV3bGluZSBjaGFyYWN0ZXJcbiAqIG9mIGNvbW1lbnRzIHdpdGggYSByZXBsYWNlQ2hhcmFjdGVyXG4gKi9cbmNvbnN0IG1haW5fc3RyaXBDb21tZW50cyA9IHN0cmlwQ29tbWVudHM7XG52YXIgUGFyc2VFcnJvckNvZGU7XG4oZnVuY3Rpb24gKFBhcnNlRXJyb3JDb2RlKSB7XG4gICAgUGFyc2VFcnJvckNvZGVbUGFyc2VFcnJvckNvZGVbXCJJbnZhbGlkU3ltYm9sXCJdID0gMV0gPSBcIkludmFsaWRTeW1ib2xcIjtcbiAgICBQYXJzZUVycm9yQ29kZVtQYXJzZUVycm9yQ29kZVtcIkludmFsaWROdW1iZXJGb3JtYXRcIl0gPSAyXSA9IFwiSW52YWxpZE51bWJlckZvcm1hdFwiO1xuICAgIFBhcnNlRXJyb3JDb2RlW1BhcnNlRXJyb3JDb2RlW1wiUHJvcGVydHlOYW1lRXhwZWN0ZWRcIl0gPSAzXSA9IFwiUHJvcGVydHlOYW1lRXhwZWN0ZWRcIjtcbiAgICBQYXJzZUVycm9yQ29kZVtQYXJzZUVycm9yQ29kZVtcIlZhbHVlRXhwZWN0ZWRcIl0gPSA0XSA9IFwiVmFsdWVFeHBlY3RlZFwiO1xuICAgIFBhcnNlRXJyb3JDb2RlW1BhcnNlRXJyb3JDb2RlW1wiQ29sb25FeHBlY3RlZFwiXSA9IDVdID0gXCJDb2xvbkV4cGVjdGVkXCI7XG4gICAgUGFyc2VFcnJvckNvZGVbUGFyc2VFcnJvckNvZGVbXCJDb21tYUV4cGVjdGVkXCJdID0gNl0gPSBcIkNvbW1hRXhwZWN0ZWRcIjtcbiAgICBQYXJzZUVycm9yQ29kZVtQYXJzZUVycm9yQ29kZVtcIkNsb3NlQnJhY2VFeHBlY3RlZFwiXSA9IDddID0gXCJDbG9zZUJyYWNlRXhwZWN0ZWRcIjtcbiAgICBQYXJzZUVycm9yQ29kZVtQYXJzZUVycm9yQ29kZVtcIkNsb3NlQnJhY2tldEV4cGVjdGVkXCJdID0gOF0gPSBcIkNsb3NlQnJhY2tldEV4cGVjdGVkXCI7XG4gICAgUGFyc2VFcnJvckNvZGVbUGFyc2VFcnJvckNvZGVbXCJFbmRPZkZpbGVFeHBlY3RlZFwiXSA9IDldID0gXCJFbmRPZkZpbGVFeHBlY3RlZFwiO1xuICAgIFBhcnNlRXJyb3JDb2RlW1BhcnNlRXJyb3JDb2RlW1wiSW52YWxpZENvbW1lbnRUb2tlblwiXSA9IDEwXSA9IFwiSW52YWxpZENvbW1lbnRUb2tlblwiO1xuICAgIFBhcnNlRXJyb3JDb2RlW1BhcnNlRXJyb3JDb2RlW1wiVW5leHBlY3RlZEVuZE9mQ29tbWVudFwiXSA9IDExXSA9IFwiVW5leHBlY3RlZEVuZE9mQ29tbWVudFwiO1xuICAgIFBhcnNlRXJyb3JDb2RlW1BhcnNlRXJyb3JDb2RlW1wiVW5leHBlY3RlZEVuZE9mU3RyaW5nXCJdID0gMTJdID0gXCJVbmV4cGVjdGVkRW5kT2ZTdHJpbmdcIjtcbiAgICBQYXJzZUVycm9yQ29kZVtQYXJzZUVycm9yQ29kZVtcIlVuZXhwZWN0ZWRFbmRPZk51bWJlclwiXSA9IDEzXSA9IFwiVW5leHBlY3RlZEVuZE9mTnVtYmVyXCI7XG4gICAgUGFyc2VFcnJvckNvZGVbUGFyc2VFcnJvckNvZGVbXCJJbnZhbGlkVW5pY29kZVwiXSA9IDE0XSA9IFwiSW52YWxpZFVuaWNvZGVcIjtcbiAgICBQYXJzZUVycm9yQ29kZVtQYXJzZUVycm9yQ29kZVtcIkludmFsaWRFc2NhcGVDaGFyYWN0ZXJcIl0gPSAxNV0gPSBcIkludmFsaWRFc2NhcGVDaGFyYWN0ZXJcIjtcbiAgICBQYXJzZUVycm9yQ29kZVtQYXJzZUVycm9yQ29kZVtcIkludmFsaWRDaGFyYWN0ZXJcIl0gPSAxNl0gPSBcIkludmFsaWRDaGFyYWN0ZXJcIjtcbn0pKFBhcnNlRXJyb3JDb2RlIHx8IChQYXJzZUVycm9yQ29kZSA9IHt9KSk7XG5mdW5jdGlvbiBwcmludFBhcnNlRXJyb3JDb2RlKGNvZGUpIHtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgY2FzZSAxIC8qIFBhcnNlRXJyb3JDb2RlLkludmFsaWRTeW1ib2wgKi86IHJldHVybiAnSW52YWxpZFN5bWJvbCc7XG4gICAgICAgIGNhc2UgMiAvKiBQYXJzZUVycm9yQ29kZS5JbnZhbGlkTnVtYmVyRm9ybWF0ICovOiByZXR1cm4gJ0ludmFsaWROdW1iZXJGb3JtYXQnO1xuICAgICAgICBjYXNlIDMgLyogUGFyc2VFcnJvckNvZGUuUHJvcGVydHlOYW1lRXhwZWN0ZWQgKi86IHJldHVybiAnUHJvcGVydHlOYW1lRXhwZWN0ZWQnO1xuICAgICAgICBjYXNlIDQgLyogUGFyc2VFcnJvckNvZGUuVmFsdWVFeHBlY3RlZCAqLzogcmV0dXJuICdWYWx1ZUV4cGVjdGVkJztcbiAgICAgICAgY2FzZSA1IC8qIFBhcnNlRXJyb3JDb2RlLkNvbG9uRXhwZWN0ZWQgKi86IHJldHVybiAnQ29sb25FeHBlY3RlZCc7XG4gICAgICAgIGNhc2UgNiAvKiBQYXJzZUVycm9yQ29kZS5Db21tYUV4cGVjdGVkICovOiByZXR1cm4gJ0NvbW1hRXhwZWN0ZWQnO1xuICAgICAgICBjYXNlIDcgLyogUGFyc2VFcnJvckNvZGUuQ2xvc2VCcmFjZUV4cGVjdGVkICovOiByZXR1cm4gJ0Nsb3NlQnJhY2VFeHBlY3RlZCc7XG4gICAgICAgIGNhc2UgOCAvKiBQYXJzZUVycm9yQ29kZS5DbG9zZUJyYWNrZXRFeHBlY3RlZCAqLzogcmV0dXJuICdDbG9zZUJyYWNrZXRFeHBlY3RlZCc7XG4gICAgICAgIGNhc2UgOSAvKiBQYXJzZUVycm9yQ29kZS5FbmRPZkZpbGVFeHBlY3RlZCAqLzogcmV0dXJuICdFbmRPZkZpbGVFeHBlY3RlZCc7XG4gICAgICAgIGNhc2UgMTAgLyogUGFyc2VFcnJvckNvZGUuSW52YWxpZENvbW1lbnRUb2tlbiAqLzogcmV0dXJuICdJbnZhbGlkQ29tbWVudFRva2VuJztcbiAgICAgICAgY2FzZSAxMSAvKiBQYXJzZUVycm9yQ29kZS5VbmV4cGVjdGVkRW5kT2ZDb21tZW50ICovOiByZXR1cm4gJ1VuZXhwZWN0ZWRFbmRPZkNvbW1lbnQnO1xuICAgICAgICBjYXNlIDEyIC8qIFBhcnNlRXJyb3JDb2RlLlVuZXhwZWN0ZWRFbmRPZlN0cmluZyAqLzogcmV0dXJuICdVbmV4cGVjdGVkRW5kT2ZTdHJpbmcnO1xuICAgICAgICBjYXNlIDEzIC8qIFBhcnNlRXJyb3JDb2RlLlVuZXhwZWN0ZWRFbmRPZk51bWJlciAqLzogcmV0dXJuICdVbmV4cGVjdGVkRW5kT2ZOdW1iZXInO1xuICAgICAgICBjYXNlIDE0IC8qIFBhcnNlRXJyb3JDb2RlLkludmFsaWRVbmljb2RlICovOiByZXR1cm4gJ0ludmFsaWRVbmljb2RlJztcbiAgICAgICAgY2FzZSAxNSAvKiBQYXJzZUVycm9yQ29kZS5JbnZhbGlkRXNjYXBlQ2hhcmFjdGVyICovOiByZXR1cm4gJ0ludmFsaWRFc2NhcGVDaGFyYWN0ZXInO1xuICAgICAgICBjYXNlIDE2IC8qIFBhcnNlRXJyb3JDb2RlLkludmFsaWRDaGFyYWN0ZXIgKi86IHJldHVybiAnSW52YWxpZENoYXJhY3Rlcic7XG4gICAgfVxuICAgIHJldHVybiAnPHVua25vd24gUGFyc2VFcnJvckNvZGU+Jztcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGVkaXQgb3BlcmF0aW9ucyBuZWVkZWQgdG8gZm9ybWF0IGEgSlNPTiBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0gZG9jdW1lbnRUZXh0IFRoZSBpbnB1dCB0ZXh0XG4gKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIHRvIGZvcm1hdCBvciBgdW5kZWZpbmVkYCB0byBmb3JtYXQgdGhlIGZ1bGwgY29udGVudFxuICogQHBhcmFtIG9wdGlvbnMgVGhlIGZvcm1hdHRpbmcgb3B0aW9uc1xuICogQHJldHVybnMgVGhlIGVkaXQgb3BlcmF0aW9ucyBkZXNjcmliaW5nIHRoZSBmb3JtYXR0aW5nIGNoYW5nZXMgdG8gdGhlIG9yaWdpbmFsIGRvY3VtZW50IGZvbGxvd2luZyB0aGUgZm9ybWF0IGRlc2NyaWJlZCBpbiB7QGxpbmtjb2RlIEVkaXRSZXN1bHR9LlxuICogVG8gYXBwbHkgdGhlIGVkaXQgb3BlcmF0aW9ucyB0byB0aGUgaW5wdXQsIHVzZSB7QGxpbmtjb2RlIGFwcGx5RWRpdHN9LlxuICovXG5mdW5jdGlvbiBtYWluX2Zvcm1hdChkb2N1bWVudFRleHQsIHJhbmdlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZvcm1hdF9mb3JtYXQoZG9jdW1lbnRUZXh0LCByYW5nZSwgb3B0aW9ucyk7XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBlZGl0IG9wZXJhdGlvbnMgbmVlZGVkIHRvIG1vZGlmeSBhIHZhbHVlIGluIHRoZSBKU09OIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudFRleHQgVGhlIGlucHV0IHRleHRcbiAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIG9mIHRoZSB2YWx1ZSB0byBjaGFuZ2UuIFRoZSBwYXRoIHJlcHJlc2VudHMgZWl0aGVyIHRvIHRoZSBkb2N1bWVudCByb290LCBhIHByb3BlcnR5IG9yIGFuIGFycmF5IGl0ZW0uXG4gKiBJZiB0aGUgcGF0aCBwb2ludHMgdG8gYW4gbm9uLWV4aXN0aW5nIHByb3BlcnR5IG9yIGl0ZW0sIGl0IHdpbGwgYmUgY3JlYXRlZC5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgbmV3IHZhbHVlIGZvciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IG9yIGl0ZW0uIElmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsXG4gKiB0aGUgcHJvcGVydHkgb3IgaXRlbSB3aWxsIGJlIHJlbW92ZWQuXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zXG4gKiBAcmV0dXJucyBUaGUgZWRpdCBvcGVyYXRpb25zIGRlc2NyaWJpbmcgdGhlIGNoYW5nZXMgdG8gdGhlIG9yaWdpbmFsIGRvY3VtZW50LCBmb2xsb3dpbmcgdGhlIGZvcm1hdCBkZXNjcmliZWQgaW4ge0BsaW5rY29kZSBFZGl0UmVzdWx0fS5cbiAqIFRvIGFwcGx5IHRoZSBlZGl0IG9wZXJhdGlvbnMgdG8gdGhlIGlucHV0LCB1c2Uge0BsaW5rY29kZSBhcHBseUVkaXRzfS5cbiAqL1xuZnVuY3Rpb24gbW9kaWZ5KHRleHQsIHBhdGgsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXQuc2V0UHJvcGVydHkodGV4dCwgcGF0aCwgdmFsdWUsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBBcHBsaWVzIGVkaXRzIHRvIGFuIGlucHV0IHN0cmluZy5cbiAqIEBwYXJhbSB0ZXh0IFRoZSBpbnB1dCB0ZXh0XG4gKiBAcGFyYW0gZWRpdHMgRWRpdCBvcGVyYXRpb25zIGZvbGxvd2luZyB0aGUgZm9ybWF0IGRlc2NyaWJlZCBpbiB7QGxpbmtjb2RlIEVkaXRSZXN1bHR9LlxuICogQHJldHVybnMgVGhlIHRleHQgd2l0aCB0aGUgYXBwbGllZCBlZGl0cy5cbiAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIGVkaXQgb3BlcmF0aW9ucyBhcmUgbm90IHdlbGwtZm9ybWVkIGFzIGRlc2NyaWJlZCBpbiB7QGxpbmtjb2RlIEVkaXRSZXN1bHR9LlxuICovXG5mdW5jdGlvbiBhcHBseUVkaXRzKHRleHQsIGVkaXRzKSB7XG4gICAgbGV0IHNvcnRlZEVkaXRzID0gZWRpdHMuc2xpY2UoMCkuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICBjb25zdCBkaWZmID0gYS5vZmZzZXQgLSBiLm9mZnNldDtcbiAgICAgICAgaWYgKGRpZmYgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBhLmxlbmd0aCAtIGIubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmO1xuICAgIH0pO1xuICAgIGxldCBsYXN0TW9kaWZpZWRPZmZzZXQgPSB0ZXh0Lmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gc29ydGVkRWRpdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IGUgPSBzb3J0ZWRFZGl0c1tpXTtcbiAgICAgICAgaWYgKGUub2Zmc2V0ICsgZS5sZW5ndGggPD0gbGFzdE1vZGlmaWVkT2Zmc2V0KSB7XG4gICAgICAgICAgICB0ZXh0ID0gZWRpdC5hcHBseUVkaXQodGV4dCwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ092ZXJsYXBwaW5nIGVkaXQnKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0TW9kaWZpZWRPZmZzZXQgPSBlLm9mZnNldDtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL2xpYi9lc20vdXRpbHMvb2JqZWN0cy5qc1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBlcXVhbHMob25lLCBvdGhlcikge1xuICAgIGlmIChvbmUgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAob25lID09PSBudWxsIHx8IG9uZSA9PT0gdW5kZWZpbmVkIHx8IG90aGVyID09PSBudWxsIHx8IG90aGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9uZSAhPT0gdHlwZW9mIG90aGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvbmUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKChBcnJheS5pc0FycmF5KG9uZSkpICE9PSAoQXJyYXkuaXNBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGksIGtleTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvbmUpKSB7XG4gICAgICAgIGlmIChvbmUubGVuZ3RoICE9PSBvdGhlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb25lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWVxdWFscyhvbmVbaV0sIG90aGVyW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgb25lS2V5cyA9IFtdO1xuICAgICAgICBmb3IgKGtleSBpbiBvbmUpIHtcbiAgICAgICAgICAgIG9uZUtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIG9uZUtleXMuc29ydCgpO1xuICAgICAgICBjb25zdCBvdGhlcktleXMgPSBbXTtcbiAgICAgICAgZm9yIChrZXkgaW4gb3RoZXIpIHtcbiAgICAgICAgICAgIG90aGVyS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXJLZXlzLnNvcnQoKTtcbiAgICAgICAgaWYgKCFlcXVhbHMob25lS2V5cywgb3RoZXJLZXlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvbmVLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWVxdWFscyhvbmVbb25lS2V5c1tpXV0sIG90aGVyW29uZUtleXNbaV1dKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cbmZ1bmN0aW9uIGlzRGVmaW5lZCh2YWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCAhPT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBpc0Jvb2xlYW4odmFsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdib29sZWFuJztcbn1cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkodmFsKTtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2UvbGliL2VzbS91dGlscy9zdHJpbmdzLmpzXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoaGF5c3RhY2ssIG5lZWRsZSkge1xuICAgIGlmIChoYXlzdGFjay5sZW5ndGggPCBuZWVkbGUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZWVkbGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGhheXN0YWNrW2ldICE9PSBuZWVkbGVbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBoYXlzdGFjayBlbmRzIHdpdGggbmVlZGxlLlxuICovXG5mdW5jdGlvbiBlbmRzV2l0aChoYXlzdGFjaywgbmVlZGxlKSB7XG4gICAgY29uc3QgZGlmZiA9IGhheXN0YWNrLmxlbmd0aCAtIG5lZWRsZS5sZW5ndGg7XG4gICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgIHJldHVybiBoYXlzdGFjay5sYXN0SW5kZXhPZihuZWVkbGUpID09PSBkaWZmO1xuICAgIH1cbiAgICBlbHNlIGlmIChkaWZmID09PSAwKSB7XG4gICAgICAgIHJldHVybiBoYXlzdGFjayA9PT0gbmVlZGxlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnRTaW1wbGUyUmVnRXhwUGF0dGVybihwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4ucmVwbGFjZSgvW1xcLVxcXFxcXHtcXH1cXCtcXD9cXHxcXF5cXCRcXC5cXCxcXFtcXF1cXChcXClcXCNcXHNdL2csICdcXFxcJCYnKS5yZXBsYWNlKC9bXFwqXS9nLCAnLionKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ3NfcmVwZWF0KHZhbHVlLCBjb3VudCkge1xuICAgIGxldCBzID0gJyc7XG4gICAgd2hpbGUgKGNvdW50ID4gMCkge1xuICAgICAgICBpZiAoKGNvdW50ICYgMSkgPT09IDEpIHtcbiAgICAgICAgICAgIHMgKz0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgKz0gdmFsdWU7XG4gICAgICAgIGNvdW50ID0gY291bnQgPj4+IDE7XG4gICAgfVxuICAgIHJldHVybiBzO1xufVxuZnVuY3Rpb24gZXh0ZW5kZWRSZWdFeHAocGF0dGVybikge1xuICAgIGxldCBmbGFncyA9ICcnO1xuICAgIGlmIChzdGFydHNXaXRoKHBhdHRlcm4sICcoP2kpJykpIHtcbiAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4uc3Vic3RyaW5nKDQpO1xuICAgICAgICBmbGFncyA9ICdpJztcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MgKyAndScpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBjb3VsZCBiZSBhbiBleGNlcHRpb24gZHVlIHRvIHRoZSAndSAnIGZsYWdcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gaW52YWxpZCBwYXR0ZXJuXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gZnJvbSBodHRwczovL3RhbmlzaGlraW5nLmdpdGh1Yi5pby9wb3N0cy9jb3VudC11bmljb2RlLWNvZGVwb2ludC8jd29yay1oYXJkLXdpdGgtZm9yLXN0YXRlbWVudHNcbmZ1bmN0aW9uIHN0cmluZ0xlbmd0aChzdHIpIHtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICAgIC8vIG9idGFpbiB0aGUgaS10aCAxNi1iaXRcbiAgICAgICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoMHhEODAwIDw9IGNvZGUgJiYgY29kZSA8PSAweERCRkYpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBpLXRoIDE2Yml0IGlzIGFuIHVwcGVyIHN1cnJvZ2F0ZVxuICAgICAgICAgICAgLy8gc2tpcCB0aGUgbmV4dCAxNiBiaXRzIChsb3dlciBzdXJyb2dhdGUpXG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xufVxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItdHlwZXMvbGliL2VzbS9tYWluLmpzXG52YXIgbWFpbiA9IF9fd2VicGFja19yZXF1aXJlX18oNDc2Nyk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItdGV4dGRvY3VtZW50L2xpYi9lc20vbWFpbi5qc1xudmFyIGVzbV9tYWluID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0ODgxKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL2xpYi9lc20vanNvbkxhbmd1YWdlVHlwZXMuanNcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblxuLyoqXG4gKiBFcnJvciBjb2RlcyB1c2VkIGJ5IGRpYWdub3N0aWNzXG4gKi9cbnZhciBFcnJvckNvZGU7XG4oZnVuY3Rpb24gKEVycm9yQ29kZSkge1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJVbmRlZmluZWRcIl0gPSAwXSA9IFwiVW5kZWZpbmVkXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVudW1WYWx1ZU1pc21hdGNoXCJdID0gMV0gPSBcIkVudW1WYWx1ZU1pc21hdGNoXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkRlcHJlY2F0ZWRcIl0gPSAyXSA9IFwiRGVwcmVjYXRlZFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJVbmV4cGVjdGVkRW5kT2ZDb21tZW50XCJdID0gMjU3XSA9IFwiVW5leHBlY3RlZEVuZE9mQ29tbWVudFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJVbmV4cGVjdGVkRW5kT2ZTdHJpbmdcIl0gPSAyNThdID0gXCJVbmV4cGVjdGVkRW5kT2ZTdHJpbmdcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiVW5leHBlY3RlZEVuZE9mTnVtYmVyXCJdID0gMjU5XSA9IFwiVW5leHBlY3RlZEVuZE9mTnVtYmVyXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkludmFsaWRVbmljb2RlXCJdID0gMjYwXSA9IFwiSW52YWxpZFVuaWNvZGVcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiSW52YWxpZEVzY2FwZUNoYXJhY3RlclwiXSA9IDI2MV0gPSBcIkludmFsaWRFc2NhcGVDaGFyYWN0ZXJcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiSW52YWxpZENoYXJhY3RlclwiXSA9IDI2Ml0gPSBcIkludmFsaWRDaGFyYWN0ZXJcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiUHJvcGVydHlFeHBlY3RlZFwiXSA9IDUxM10gPSBcIlByb3BlcnR5RXhwZWN0ZWRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiQ29tbWFFeHBlY3RlZFwiXSA9IDUxNF0gPSBcIkNvbW1hRXhwZWN0ZWRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiQ29sb25FeHBlY3RlZFwiXSA9IDUxNV0gPSBcIkNvbG9uRXhwZWN0ZWRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiVmFsdWVFeHBlY3RlZFwiXSA9IDUxNl0gPSBcIlZhbHVlRXhwZWN0ZWRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiQ29tbWFPckNsb3NlQmFja2V0RXhwZWN0ZWRcIl0gPSA1MTddID0gXCJDb21tYU9yQ2xvc2VCYWNrZXRFeHBlY3RlZFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJDb21tYU9yQ2xvc2VCcmFjZUV4cGVjdGVkXCJdID0gNTE4XSA9IFwiQ29tbWFPckNsb3NlQnJhY2VFeHBlY3RlZFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJUcmFpbGluZ0NvbW1hXCJdID0gNTE5XSA9IFwiVHJhaWxpbmdDb21tYVwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJEdXBsaWNhdGVLZXlcIl0gPSA1MjBdID0gXCJEdXBsaWNhdGVLZXlcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiQ29tbWVudE5vdFBlcm1pdHRlZFwiXSA9IDUyMV0gPSBcIkNvbW1lbnROb3RQZXJtaXR0ZWRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiU2NoZW1hUmVzb2x2ZUVycm9yXCJdID0gNzY4XSA9IFwiU2NoZW1hUmVzb2x2ZUVycm9yXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIlNjaGVtYVVuc3VwcG9ydGVkRmVhdHVyZVwiXSA9IDc2OV0gPSBcIlNjaGVtYVVuc3VwcG9ydGVkRmVhdHVyZVwiO1xufSkoRXJyb3JDb2RlIHx8IChFcnJvckNvZGUgPSB7fSkpO1xudmFyIFNjaGVtYURyYWZ0O1xuKGZ1bmN0aW9uIChTY2hlbWFEcmFmdCkge1xuICAgIFNjaGVtYURyYWZ0W1NjaGVtYURyYWZ0W1widjNcIl0gPSAzXSA9IFwidjNcIjtcbiAgICBTY2hlbWFEcmFmdFtTY2hlbWFEcmFmdFtcInY0XCJdID0gNF0gPSBcInY0XCI7XG4gICAgU2NoZW1hRHJhZnRbU2NoZW1hRHJhZnRbXCJ2NlwiXSA9IDZdID0gXCJ2NlwiO1xuICAgIFNjaGVtYURyYWZ0W1NjaGVtYURyYWZ0W1widjdcIl0gPSA3XSA9IFwidjdcIjtcbiAgICBTY2hlbWFEcmFmdFtTY2hlbWFEcmFmdFtcInYyMDE5XzA5XCJdID0gMTldID0gXCJ2MjAxOV8wOVwiO1xuICAgIFNjaGVtYURyYWZ0W1NjaGVtYURyYWZ0W1widjIwMjBfMTJcIl0gPSAyMF0gPSBcInYyMDIwXzEyXCI7XG59KShTY2hlbWFEcmFmdCB8fCAoU2NoZW1hRHJhZnQgPSB7fSkpO1xudmFyIENsaWVudENhcGFiaWxpdGllcztcbihmdW5jdGlvbiAoQ2xpZW50Q2FwYWJpbGl0aWVzKSB7XG4gICAgQ2xpZW50Q2FwYWJpbGl0aWVzLkxBVEVTVCA9IHtcbiAgICAgICAgdGV4dERvY3VtZW50OiB7XG4gICAgICAgICAgICBjb21wbGV0aW9uOiB7XG4gICAgICAgICAgICAgICAgY29tcGxldGlvbkl0ZW06IHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRhdGlvbkZvcm1hdDogW21haW4uTWFya3VwS2luZC5NYXJrZG93biwgbWFpbi5NYXJrdXBLaW5kLlBsYWluVGV4dF0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1pdENoYXJhY3RlcnNTdXBwb3J0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbERldGFpbHNTdXBwb3J0OiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn0pKENsaWVudENhcGFiaWxpdGllcyB8fCAoQ2xpZW50Q2FwYWJpbGl0aWVzID0ge30pKTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2Uvbm9kZV9tb2R1bGVzL0B2c2NvZGUvbDEwbi9kaXN0L2Jyb3dzZXIuanNcbi8vIHNyYy9icm93c2VyL3JlYWRlci50c1xuYXN5bmMgZnVuY3Rpb24gcmVhZEZpbGVGcm9tVXJpKHVyaSkge1xuICBpZiAodXJpLnByb3RvY29sID09PSBcImh0dHA6XCIgfHwgdXJpLnByb3RvY29sID09PSBcImh0dHBzOlwiKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godXJpKTtcbiAgICByZXR1cm4gYXdhaXQgcmVzLnRleHQoKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBwcm90b2NvbFwiKTtcbn1cbmZ1bmN0aW9uIHJlYWRGaWxlRnJvbUZzUGF0aChfKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGluIGJyb3dzZXJcIik7XG59XG5cbi8vIHNyYy9tYWluLnRzXG52YXIgYnVuZGxlO1xuZnVuY3Rpb24gY29uZmlnKGNvbmZpZzIpIHtcbiAgaWYgKFwiY29udGVudHNcIiBpbiBjb25maWcyKSB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcyLmNvbnRlbnRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBidW5kbGUgPSBKU09OLnBhcnNlKGNvbmZpZzIuY29udGVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBidW5kbGUgPSBjb25maWcyLmNvbnRlbnRzO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKFwiZnNQYXRoXCIgaW4gY29uZmlnMikge1xuICAgIGNvbnN0IGZpbGVDb250ZW50ID0gcmVhZEZpbGVGcm9tRnNQYXRoKGNvbmZpZzIuZnNQYXRoKTtcbiAgICBjb25zdCBjb250ZW50ID0gSlNPTi5wYXJzZShmaWxlQ29udGVudCk7XG4gICAgYnVuZGxlID0gaXNCdWlsdGluRXh0ZW5zaW9uKGNvbnRlbnQpID8gY29udGVudC5jb250ZW50cy5idW5kbGUgOiBjb250ZW50O1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoY29uZmlnMi51cmkpIHtcbiAgICBsZXQgdXJpID0gY29uZmlnMi51cmk7XG4gICAgaWYgKHR5cGVvZiBjb25maWcyLnVyaSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdXJpID0gbmV3IFVSTChjb25maWcyLnVyaSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBwID0gcmVhZEZpbGVGcm9tVXJpKHVyaSkudGhlbigodXJpQ29udGVudCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBKU09OLnBhcnNlKHVyaUNvbnRlbnQpO1xuICAgICAgICAgIGJ1bmRsZSA9IGlzQnVpbHRpbkV4dGVuc2lvbihjb250ZW50KSA/IGNvbnRlbnQuY29udGVudHMuYnVuZGxlIDogY29udGVudDtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9KTtcbiAgICAgIHJlc29sdmUocCk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHQoLi4uYXJncykge1xuICBjb25zdCBmaXJzdEFyZyA9IGFyZ3NbMF07XG4gIGxldCBrZXk7XG4gIGxldCBtZXNzYWdlO1xuICBsZXQgZm9ybWF0QXJncztcbiAgaWYgKHR5cGVvZiBmaXJzdEFyZyA9PT0gXCJzdHJpbmdcIikge1xuICAgIGtleSA9IGZpcnN0QXJnO1xuICAgIG1lc3NhZ2UgPSBmaXJzdEFyZztcbiAgICBhcmdzLnNwbGljZSgwLCAxKTtcbiAgICBmb3JtYXRBcmdzID0gIWFyZ3MgfHwgdHlwZW9mIGFyZ3NbMF0gIT09IFwib2JqZWN0XCIgPyBhcmdzIDogYXJnc1swXTtcbiAgfSBlbHNlIHtcbiAgICBtZXNzYWdlID0gZmlyc3RBcmcubWVzc2FnZTtcbiAgICBrZXkgPSBtZXNzYWdlO1xuICAgIGlmIChmaXJzdEFyZy5jb21tZW50ICYmIGZpcnN0QXJnLmNvbW1lbnQubGVuZ3RoID4gMCkge1xuICAgICAga2V5ICs9IGAvJHtBcnJheS5pc0FycmF5KGZpcnN0QXJnLmNvbW1lbnQpID8gZmlyc3RBcmcuY29tbWVudC5qb2luKFwiXCIpIDogZmlyc3RBcmcuY29tbWVudH1gO1xuICAgIH1cbiAgICBmb3JtYXRBcmdzID0gZmlyc3RBcmcuYXJncyA/PyB7fTtcbiAgfVxuICBpZiAoIWJ1bmRsZSkge1xuICAgIHJldHVybiBicm93c2VyX2Zvcm1hdChtZXNzYWdlLCBmb3JtYXRBcmdzKTtcbiAgfVxuICBjb25zdCBtZXNzYWdlRnJvbUJ1bmRsZSA9IGJ1bmRsZVtrZXldO1xuICBpZiAoIW1lc3NhZ2VGcm9tQnVuZGxlKSB7XG4gICAgcmV0dXJuIGJyb3dzZXJfZm9ybWF0KG1lc3NhZ2UsIGZvcm1hdEFyZ3MpO1xuICB9XG4gIGlmICh0eXBlb2YgbWVzc2FnZUZyb21CdW5kbGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gYnJvd3Nlcl9mb3JtYXQobWVzc2FnZUZyb21CdW5kbGUsIGZvcm1hdEFyZ3MpO1xuICB9XG4gIGlmIChtZXNzYWdlRnJvbUJ1bmRsZS5jb21tZW50KSB7XG4gICAgcmV0dXJuIGJyb3dzZXJfZm9ybWF0KG1lc3NhZ2VGcm9tQnVuZGxlLm1lc3NhZ2UsIGZvcm1hdEFyZ3MpO1xuICB9XG4gIHJldHVybiBicm93c2VyX2Zvcm1hdChtZXNzYWdlLCBmb3JtYXRBcmdzKTtcbn1cbnZhciBfZm9ybWF0MlJlZ2V4cCA9IC97KFtefV0rKX0vZztcbmZ1bmN0aW9uIGJyb3dzZXJfZm9ybWF0KHRlbXBsYXRlLCB2YWx1ZXMpIHtcbiAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoX2Zvcm1hdDJSZWdleHAsIChtYXRjaCwgZ3JvdXApID0+IHZhbHVlc1tncm91cF0gPz8gbWF0Y2gpO1xufVxuZnVuY3Rpb24gaXNCdWlsdGluRXh0ZW5zaW9uKGpzb24pIHtcbiAgcmV0dXJuICEhKHR5cGVvZiBqc29uPy5jb250ZW50cz8uYnVuZGxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBqc29uPy52ZXJzaW9uID09PSBcInN0cmluZ1wiKTtcbn1cblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL3BhcnNlci9qc29uUGFyc2VyLmpzXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cblxuXG5jb25zdCBmb3JtYXRzID0ge1xuICAgICdjb2xvci1oZXgnOiB7IGVycm9yTWVzc2FnZTogdCgnSW52YWxpZCBjb2xvciBmb3JtYXQuIFVzZSAjUkdCLCAjUkdCQSwgI1JSR0dCQiBvciAjUlJHR0JCQUEuJyksIHBhdHRlcm46IC9eIyhbMC05QS1GYS1mXXszLDR9fChbMC05QS1GYS1mXXsyfSl7Myw0fSkkLyB9LFxuICAgICdkYXRlLXRpbWUnOiB7IGVycm9yTWVzc2FnZTogdCgnU3RyaW5nIGlzIG5vdCBhIFJGQzMzMzkgZGF0ZS10aW1lLicpLCBwYXR0ZXJuOiAvXihcXGR7NH0pLSgwWzEtOV18MVswLTJdKS0oMFsxLTldfFsxMl1bMC05XXwzWzAxXSlUKFswMV1bMC05XXwyWzAtM10pOihbMC01XVswLTldKTooWzAtNV1bMC05XXw2MCkoXFwuWzAtOV0rKT8oWnwoXFwrfC0pKFswMV1bMC05XXwyWzAtM10pOihbMC01XVswLTldKSkkL2kgfSxcbiAgICAnZGF0ZSc6IHsgZXJyb3JNZXNzYWdlOiB0KCdTdHJpbmcgaXMgbm90IGEgUkZDMzMzOSBkYXRlLicpLCBwYXR0ZXJuOiAvXihcXGR7NH0pLSgwWzEtOV18MVswLTJdKS0oMFsxLTldfFsxMl1bMC05XXwzWzAxXSkkL2kgfSxcbiAgICAndGltZSc6IHsgZXJyb3JNZXNzYWdlOiB0KCdTdHJpbmcgaXMgbm90IGEgUkZDMzMzOSB0aW1lLicpLCBwYXR0ZXJuOiAvXihbMDFdWzAtOV18MlswLTNdKTooWzAtNV1bMC05XSk6KFswLTVdWzAtOV18NjApKFxcLlswLTldKyk/KFp8KFxcK3wtKShbMDFdWzAtOV18MlswLTNdKTooWzAtNV1bMC05XSkpJC9pIH0sXG4gICAgJ2VtYWlsJzogeyBlcnJvck1lc3NhZ2U6IHQoJ1N0cmluZyBpcyBub3QgYW4gZS1tYWlsIGFkZHJlc3MuJyksIHBhdHRlcm46IC9eKChbXjw+KClcXFtcXF1cXFxcLiw7Olxcc0BcIl0rKFxcLltePD4oKVxcW1xcXVxcXFwuLDs6XFxzQFwiXSspKil8KFwiLitcIikpQCgoXFxbWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XFwuWzAtOV17MSwzfV0pfCgoW2EtekEtWjAtOS1dK1xcLikrW2EtekEtWl17Mix9KSkkLyB9LFxuICAgICdob3N0bmFtZSc6IHsgZXJyb3JNZXNzYWdlOiB0KCdTdHJpbmcgaXMgbm90IGEgaG9zdG5hbWUuJyksIHBhdHRlcm46IC9eKD89LnsxLDI1M31cXC4/JClbYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8oPzpcXC5bYS16MC05XSg/OlstMC05YS16XXswLDYxfVswLTlhLXpdKT8pKlxcLj8kL2kgfSxcbiAgICAnaXB2NCc6IHsgZXJyb3JNZXNzYWdlOiB0KCdTdHJpbmcgaXMgbm90IGFuIElQdjQgYWRkcmVzcy4nKSwgcGF0dGVybjogL14oPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZClcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpJC8gfSxcbiAgICAnaXB2Nic6IHsgZXJyb3JNZXNzYWdlOiB0KCdTdHJpbmcgaXMgbm90IGFuIElQdjYgYWRkcmVzcy4nKSwgcGF0dGVybjogL14oKChbMC05YS1mXXsxLDR9Oil7N30oWzAtOWEtZl17MSw0fXw6KSl8KChbMC05YS1mXXsxLDR9Oil7Nn0oOlswLTlhLWZdezEsNH18KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlhLWZdezEsNH06KXs1fSgoKDpbMC05YS1mXXsxLDR9KXsxLDJ9KXw6KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlhLWZdezEsNH06KXs0fSgoKDpbMC05YS1mXXsxLDR9KXsxLDN9KXwoKDpbMC05YS1mXXsxLDR9KT86KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05YS1mXXsxLDR9Oil7M30oKCg6WzAtOWEtZl17MSw0fSl7MSw0fSl8KCg6WzAtOWEtZl17MSw0fSl7MCwyfTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlhLWZdezEsNH06KXsyfSgoKDpbMC05YS1mXXsxLDR9KXsxLDV9KXwoKDpbMC05YS1mXXsxLDR9KXswLDN9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOWEtZl17MSw0fTopezF9KCgoOlswLTlhLWZdezEsNH0pezEsNn0pfCgoOlswLTlhLWZdezEsNH0pezAsNH06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KDooKCg6WzAtOWEtZl17MSw0fSl7MSw3fSl8KCg6WzAtOWEtZl17MSw0fSl7MCw1fTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKSkkL2kgfSxcbn07XG5jbGFzcyBBU1ROb2RlSW1wbCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBvZmZzZXQsIGxlbmd0aCA9IDApIHtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gJ3R5cGU6ICcgKyB0aGlzLnR5cGUgKyAnICgnICsgdGhpcy5vZmZzZXQgKyAnLycgKyB0aGlzLmxlbmd0aCArICcpJyArICh0aGlzLnBhcmVudCA/ICcgcGFyZW50OiB7JyArIHRoaXMucGFyZW50LnRvU3RyaW5nKCkgKyAnfScgOiAnJyk7XG4gICAgfVxufVxuY2xhc3MgTnVsbEFTVE5vZGVJbXBsIGV4dGVuZHMgQVNUTm9kZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgb2Zmc2V0KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy50eXBlID0gJ251bGwnO1xuICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICB9XG59XG5jbGFzcyBCb29sZWFuQVNUTm9kZUltcGwgZXh0ZW5kcyBBU1ROb2RlSW1wbCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBib29sVmFsdWUsIG9mZnNldCkge1xuICAgICAgICBzdXBlcihwYXJlbnQsIG9mZnNldCk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdib29sZWFuJztcbiAgICAgICAgdGhpcy52YWx1ZSA9IGJvb2xWYWx1ZTtcbiAgICB9XG59XG5jbGFzcyBBcnJheUFTVE5vZGVJbXBsIGV4dGVuZHMgQVNUTm9kZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgb2Zmc2V0KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2FycmF5JztcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgIH1cbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zO1xuICAgIH1cbn1cbmNsYXNzIE51bWJlckFTVE5vZGVJbXBsIGV4dGVuZHMgQVNUTm9kZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgb2Zmc2V0KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy50eXBlID0gJ251bWJlcic7XG4gICAgICAgIHRoaXMuaXNJbnRlZ2VyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IE51bWJlci5OYU47XG4gICAgfVxufVxuY2xhc3MgU3RyaW5nQVNUTm9kZUltcGwgZXh0ZW5kcyBBU1ROb2RlSW1wbCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICBzdXBlcihwYXJlbnQsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3N0cmluZyc7XG4gICAgICAgIHRoaXMudmFsdWUgPSAnJztcbiAgICB9XG59XG5jbGFzcyBQcm9wZXJ0eUFTVE5vZGVJbXBsIGV4dGVuZHMgQVNUTm9kZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgb2Zmc2V0LCBrZXlOb2RlKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3Byb3BlcnR5JztcbiAgICAgICAgdGhpcy5jb2xvbk9mZnNldCA9IC0xO1xuICAgICAgICB0aGlzLmtleU5vZGUgPSBrZXlOb2RlO1xuICAgIH1cbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlTm9kZSA/IFt0aGlzLmtleU5vZGUsIHRoaXMudmFsdWVOb2RlXSA6IFt0aGlzLmtleU5vZGVdO1xuICAgIH1cbn1cbmNsYXNzIE9iamVjdEFTVE5vZGVJbXBsIGV4dGVuZHMgQVNUTm9kZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgb2Zmc2V0KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy50eXBlID0gJ29iamVjdCc7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IFtdO1xuICAgIH1cbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXM7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNTY2hlbWEoc2NoZW1hKSB7XG4gICAgaWYgKGlzQm9vbGVhbihzY2hlbWEpKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEgPyB7fSA6IHsgXCJub3RcIjoge30gfTtcbiAgICB9XG4gICAgcmV0dXJuIHNjaGVtYTtcbn1cbnZhciBFbnVtTWF0Y2g7XG4oZnVuY3Rpb24gKEVudW1NYXRjaCkge1xuICAgIEVudW1NYXRjaFtFbnVtTWF0Y2hbXCJLZXlcIl0gPSAwXSA9IFwiS2V5XCI7XG4gICAgRW51bU1hdGNoW0VudW1NYXRjaFtcIkVudW1cIl0gPSAxXSA9IFwiRW51bVwiO1xufSkoRW51bU1hdGNoIHx8IChFbnVtTWF0Y2ggPSB7fSkpO1xuY29uc3Qgc2NoZW1hRHJhZnRGcm9tSWQgPSB7XG4gICAgJ2h0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDMvc2NoZW1hIyc6IFNjaGVtYURyYWZ0LnYzLFxuICAgICdodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSMnOiBTY2hlbWFEcmFmdC52NCxcbiAgICAnaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNi9zY2hlbWEjJzogU2NoZW1hRHJhZnQudjYsXG4gICAgJ2h0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hIyc6IFNjaGVtYURyYWZ0LnY3LFxuICAgICdodHRwczovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC8yMDE5LTA5L3NjaGVtYSc6IFNjaGVtYURyYWZ0LnYyMDE5XzA5LFxuICAgICdodHRwczovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC8yMDIwLTEyL3NjaGVtYSc6IFNjaGVtYURyYWZ0LnYyMDIwXzEyXG59O1xuY2xhc3MgRXZhbHVhdGlvbkNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHNjaGVtYURyYWZ0KSB7XG4gICAgICAgIHRoaXMuc2NoZW1hRHJhZnQgPSBzY2hlbWFEcmFmdDtcbiAgICB9XG59XG5jbGFzcyBTY2hlbWFDb2xsZWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGZvY3VzT2Zmc2V0ID0gLTEsIGV4Y2x1ZGUpIHtcbiAgICAgICAgdGhpcy5mb2N1c09mZnNldCA9IGZvY3VzT2Zmc2V0O1xuICAgICAgICB0aGlzLmV4Y2x1ZGUgPSBleGNsdWRlO1xuICAgICAgICB0aGlzLnNjaGVtYXMgPSBbXTtcbiAgICB9XG4gICAgYWRkKHNjaGVtYSkge1xuICAgICAgICB0aGlzLnNjaGVtYXMucHVzaChzY2hlbWEpO1xuICAgIH1cbiAgICBtZXJnZShvdGhlcikge1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLnNjaGVtYXMsIG90aGVyLnNjaGVtYXMpO1xuICAgIH1cbiAgICBpbmNsdWRlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZvY3VzT2Zmc2V0ID09PSAtMSB8fCBqc29uUGFyc2VyX2NvbnRhaW5zKG5vZGUsIHRoaXMuZm9jdXNPZmZzZXQpKSAmJiAobm9kZSAhPT0gdGhpcy5leGNsdWRlKTtcbiAgICB9XG4gICAgbmV3U3ViKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNjaGVtYUNvbGxlY3RvcigtMSwgdGhpcy5leGNsdWRlKTtcbiAgICB9XG59XG5jbGFzcyBOb09wU2NoZW1hQ29sbGVjdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHsgfVxuICAgIGdldCBzY2hlbWFzKCkgeyByZXR1cm4gW107IH1cbiAgICBhZGQoX3NjaGVtYSkgeyB9XG4gICAgbWVyZ2UoX290aGVyKSB7IH1cbiAgICBpbmNsdWRlKF9ub2RlKSB7IHJldHVybiB0cnVlOyB9XG4gICAgbmV3U3ViKCkgeyByZXR1cm4gdGhpczsgfVxufVxuTm9PcFNjaGVtYUNvbGxlY3Rvci5pbnN0YW5jZSA9IG5ldyBOb09wU2NoZW1hQ29sbGVjdG9yKCk7XG5jbGFzcyBWYWxpZGF0aW9uUmVzdWx0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcm9ibGVtcyA9IFtdO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXNNYXRjaGVzID0gMDtcbiAgICAgICAgdGhpcy5wcm9jZXNzZWRQcm9wZXJ0aWVzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXNWYWx1ZU1hdGNoZXMgPSAwO1xuICAgICAgICB0aGlzLnByaW1hcnlWYWx1ZU1hdGNoZXMgPSAwO1xuICAgICAgICB0aGlzLmVudW1WYWx1ZU1hdGNoID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW51bVZhbHVlcyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaGFzUHJvYmxlbXMoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMucHJvYmxlbXMubGVuZ3RoO1xuICAgIH1cbiAgICBtZXJnZSh2YWxpZGF0aW9uUmVzdWx0KSB7XG4gICAgICAgIHRoaXMucHJvYmxlbXMgPSB0aGlzLnByb2JsZW1zLmNvbmNhdCh2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zKTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzTWF0Y2hlcyArPSB2YWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNNYXRjaGVzO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXNWYWx1ZU1hdGNoZXMgKz0gdmFsaWRhdGlvblJlc3VsdC5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzO1xuICAgICAgICB0aGlzLm1lcmdlUHJvY2Vzc2VkUHJvcGVydGllcyh2YWxpZGF0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgbWVyZ2VFbnVtVmFsdWVzKHZhbGlkYXRpb25SZXN1bHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVudW1WYWx1ZU1hdGNoICYmICF2YWxpZGF0aW9uUmVzdWx0LmVudW1WYWx1ZU1hdGNoICYmIHRoaXMuZW51bVZhbHVlcyAmJiB2YWxpZGF0aW9uUmVzdWx0LmVudW1WYWx1ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZW51bVZhbHVlcyA9IHRoaXMuZW51bVZhbHVlcy5jb25jYXQodmFsaWRhdGlvblJlc3VsdC5lbnVtVmFsdWVzKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZXJyb3Igb2YgdGhpcy5wcm9ibGVtcykge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBFcnJvckNvZGUuRW51bVZhbHVlTWlzbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IHQoJ1ZhbHVlIGlzIG5vdCBhY2NlcHRlZC4gVmFsaWQgdmFsdWVzOiB7MH0uJywgdGhpcy5lbnVtVmFsdWVzLm1hcCh2ID0+IEpTT04uc3RyaW5naWZ5KHYpKS5qb2luKCcsICcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWVyZ2VQcm9wZXJ0eU1hdGNoKHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCkge1xuICAgICAgICB0aGlzLnByb2JsZW1zID0gdGhpcy5wcm9ibGVtcy5jb25jYXQocHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zKTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzTWF0Y2hlcysrO1xuICAgICAgICBpZiAocHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0LmVudW1WYWx1ZU1hdGNoIHx8ICFwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQuaGFzUHJvYmxlbXMoKSAmJiBwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc01hdGNoZXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1ZhbHVlTWF0Y2hlcysrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQuZW51bVZhbHVlTWF0Y2ggJiYgcHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0LmVudW1WYWx1ZXMgJiYgcHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0LmVudW1WYWx1ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnByaW1hcnlWYWx1ZU1hdGNoZXMrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBtZXJnZVByb2Nlc3NlZFByb3BlcnRpZXModmFsaWRhdGlvblJlc3VsdCkge1xuICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2Nlc3NlZFByb3BlcnRpZXMuZm9yRWFjaChwID0+IHRoaXMucHJvY2Vzc2VkUHJvcGVydGllcy5hZGQocCkpO1xuICAgIH1cbiAgICBjb21wYXJlKG90aGVyKSB7XG4gICAgICAgIGNvbnN0IGhhc1Byb2JsZW1zID0gdGhpcy5oYXNQcm9ibGVtcygpO1xuICAgICAgICBpZiAoaGFzUHJvYmxlbXMgIT09IG90aGVyLmhhc1Byb2JsZW1zKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNQcm9ibGVtcyA/IC0xIDogMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lbnVtVmFsdWVNYXRjaCAhPT0gb3RoZXIuZW51bVZhbHVlTWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBvdGhlci5lbnVtVmFsdWVNYXRjaCA/IC0xIDogMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcmltYXJ5VmFsdWVNYXRjaGVzICE9PSBvdGhlci5wcmltYXJ5VmFsdWVNYXRjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmltYXJ5VmFsdWVNYXRjaGVzIC0gb3RoZXIucHJpbWFyeVZhbHVlTWF0Y2hlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzICE9PSBvdGhlci5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzIC0gb3RoZXIucHJvcGVydGllc1ZhbHVlTWF0Y2hlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzTWF0Y2hlcyAtIG90aGVyLnByb3BlcnRpZXNNYXRjaGVzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5ld0pTT05Eb2N1bWVudChyb290LCBkaWFnbm9zdGljcyA9IFtdKSB7XG4gICAgcmV0dXJuIG5ldyBKU09ORG9jdW1lbnQocm9vdCwgZGlhZ25vc3RpY3MsIFtdKTtcbn1cbmZ1bmN0aW9uIGpzb25QYXJzZXJfZ2V0Tm9kZVZhbHVlKG5vZGUpIHtcbiAgICByZXR1cm4gbWFpbl9nZXROb2RlVmFsdWUobm9kZSk7XG59XG5mdW5jdGlvbiBqc29uUGFyc2VyX2dldE5vZGVQYXRoKG5vZGUpIHtcbiAgICByZXR1cm4gbWFpbl9nZXROb2RlUGF0aChub2RlKTtcbn1cbmZ1bmN0aW9uIGpzb25QYXJzZXJfY29udGFpbnMobm9kZSwgb2Zmc2V0LCBpbmNsdWRlUmlnaHRCb3VuZCA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9mZnNldCA+PSBub2RlLm9mZnNldCAmJiBvZmZzZXQgPCAobm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aCkgfHwgaW5jbHVkZVJpZ2h0Qm91bmQgJiYgb2Zmc2V0ID09PSAobm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aCk7XG59XG5jbGFzcyBKU09ORG9jdW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHJvb3QsIHN5bnRheEVycm9ycyA9IFtdLCBjb21tZW50cyA9IFtdKSB7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMuc3ludGF4RXJyb3JzID0gc3ludGF4RXJyb3JzO1xuICAgICAgICB0aGlzLmNvbW1lbnRzID0gY29tbWVudHM7XG4gICAgfVxuICAgIGdldE5vZGVGcm9tT2Zmc2V0KG9mZnNldCwgaW5jbHVkZVJpZ2h0Qm91bmQgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICAgICAgICByZXR1cm4gbWFpbl9maW5kTm9kZUF0T2Zmc2V0KHRoaXMucm9vdCwgb2Zmc2V0LCBpbmNsdWRlUmlnaHRCb3VuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvcikge1xuICAgICAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICAgICAgICBjb25zdCBkb1Zpc2l0ID0gKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgY3RuID0gdmlzaXRvcihub2RlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoICYmIGN0bjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdG4gPSBkb1Zpc2l0KGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY3RuO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRvVmlzaXQodGhpcy5yb290KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YWxpZGF0ZSh0ZXh0RG9jdW1lbnQsIHNjaGVtYSwgc2V2ZXJpdHkgPSBtYWluLkRpYWdub3N0aWNTZXZlcml0eS5XYXJuaW5nLCBzY2hlbWFEcmFmdCkge1xuICAgICAgICBpZiAodGhpcy5yb290ICYmIHNjaGVtYSkge1xuICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICB2YWxpZGF0ZSh0aGlzLnJvb3QsIHNjaGVtYSwgdmFsaWRhdGlvblJlc3VsdCwgTm9PcFNjaGVtYUNvbGxlY3Rvci5pbnN0YW5jZSwgbmV3IEV2YWx1YXRpb25Db250ZXh0KHNjaGVtYURyYWZ0ID8/IGdldFNjaGVtYURyYWZ0KHNjaGVtYSkpKTtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLm1hcChwID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IG1haW4uUmFuZ2UuY3JlYXRlKHRleHREb2N1bWVudC5wb3NpdGlvbkF0KHAubG9jYXRpb24ub2Zmc2V0KSwgdGV4dERvY3VtZW50LnBvc2l0aW9uQXQocC5sb2NhdGlvbi5vZmZzZXQgKyBwLmxvY2F0aW9uLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWluLkRpYWdub3N0aWMuY3JlYXRlKHJhbmdlLCBwLm1lc3NhZ2UsIHAuc2V2ZXJpdHkgPz8gc2V2ZXJpdHksIHAuY29kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXRNYXRjaGluZ1NjaGVtYXMoc2NoZW1hLCBmb2N1c09mZnNldCA9IC0xLCBleGNsdWRlKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb3QgJiYgc2NoZW1hKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZ1NjaGVtYXMgPSBuZXcgU2NoZW1hQ29sbGVjdG9yKGZvY3VzT2Zmc2V0LCBleGNsdWRlKTtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYURyYWZ0ID0gZ2V0U2NoZW1hRHJhZnQoc2NoZW1hKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBuZXcgRXZhbHVhdGlvbkNvbnRleHQoc2NoZW1hRHJhZnQpO1xuICAgICAgICAgICAgdmFsaWRhdGUodGhpcy5yb290LCBzY2hlbWEsIG5ldyBWYWxpZGF0aW9uUmVzdWx0KCksIG1hdGNoaW5nU2NoZW1hcywgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hpbmdTY2hlbWFzLnNjaGVtYXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFNjaGVtYURyYWZ0KHNjaGVtYSwgZmFsbEJhY2sgPSBTY2hlbWFEcmFmdC52MjAyMF8xMikge1xuICAgIGxldCBzY2hlbWFJZCA9IHNjaGVtYS4kc2NoZW1hO1xuICAgIGlmIChzY2hlbWFJZCkge1xuICAgICAgICByZXR1cm4gc2NoZW1hRHJhZnRGcm9tSWRbc2NoZW1hSWRdID8/IGZhbGxCYWNrO1xuICAgIH1cbiAgICByZXR1cm4gZmFsbEJhY2s7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZShuLCBzY2hlbWEsIHZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hcywgY29udGV4dCkge1xuICAgIGlmICghbiB8fCAhbWF0Y2hpbmdTY2hlbWFzLmluY2x1ZGUobikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobi50eXBlID09PSAncHJvcGVydHknKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShuLnZhbHVlTm9kZSwgc2NoZW1hLCB2YWxpZGF0aW9uUmVzdWx0LCBtYXRjaGluZ1NjaGVtYXMsIGNvbnRleHQpO1xuICAgIH1cbiAgICBjb25zdCBub2RlID0gbjtcbiAgICBfdmFsaWRhdGVOb2RlKCk7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIF92YWxpZGF0ZU9iamVjdE5vZGUobm9kZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgICAgX3ZhbGlkYXRlQXJyYXlOb2RlKG5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICBfdmFsaWRhdGVTdHJpbmdOb2RlKG5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICBfdmFsaWRhdGVOdW1iZXJOb2RlKG5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG1hdGNoaW5nU2NoZW1hcy5hZGQoeyBub2RlOiBub2RlLCBzY2hlbWE6IHNjaGVtYSB9KTtcbiAgICBmdW5jdGlvbiBfdmFsaWRhdGVOb2RlKCkge1xuICAgICAgICBmdW5jdGlvbiBtYXRjaGVzVHlwZSh0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS50eXBlID09PSB0eXBlIHx8ICh0eXBlID09PSAnaW50ZWdlcicgJiYgbm9kZS50eXBlID09PSAnbnVtYmVyJyAmJiBub2RlLmlzSW50ZWdlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLnR5cGUpKSB7XG4gICAgICAgICAgICBpZiAoIXNjaGVtYS50eXBlLnNvbWUobWF0Y2hlc1R5cGUpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IHQoJ0luY29ycmVjdCB0eXBlLiBFeHBlY3RlZCBvbmUgb2YgezB9LicsIHNjaGVtYS50eXBlLmpvaW4oJywgJykpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2NoZW1hLnR5cGUpIHtcbiAgICAgICAgICAgIGlmICghbWF0Y2hlc1R5cGUoc2NoZW1hLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IHQoJ0luY29ycmVjdCB0eXBlLiBFeHBlY3RlZCBcInswfVwiLicsIHNjaGVtYS50eXBlKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5hbGxPZikpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3ViU2NoZW1hUmVmIG9mIHNjaGVtYS5hbGxPZikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YlZhbGlkYXRpb25SZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1Yk1hdGNoaW5nU2NoZW1hcyA9IG1hdGNoaW5nU2NoZW1hcy5uZXdTdWIoKTtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZShub2RlLCBhc1NjaGVtYShzdWJTY2hlbWFSZWYpLCBzdWJWYWxpZGF0aW9uUmVzdWx0LCBzdWJNYXRjaGluZ1NjaGVtYXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQubWVyZ2Uoc3ViVmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgbWF0Y2hpbmdTY2hlbWFzLm1lcmdlKHN1Yk1hdGNoaW5nU2NoZW1hcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm90U2NoZW1hID0gYXNTY2hlbWEoc2NoZW1hLm5vdCk7XG4gICAgICAgIGlmIChub3RTY2hlbWEpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YlZhbGlkYXRpb25SZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdCgpO1xuICAgICAgICAgICAgY29uc3Qgc3ViTWF0Y2hpbmdTY2hlbWFzID0gbWF0Y2hpbmdTY2hlbWFzLm5ld1N1YigpO1xuICAgICAgICAgICAgdmFsaWRhdGUobm9kZSwgbm90U2NoZW1hLCBzdWJWYWxpZGF0aW9uUmVzdWx0LCBzdWJNYXRjaGluZ1NjaGVtYXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKCFzdWJWYWxpZGF0aW9uUmVzdWx0Lmhhc1Byb2JsZW1zKCkpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IG5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNjaGVtYS5lcnJvck1lc3NhZ2UgfHwgdChcIk1hdGNoZXMgYSBzY2hlbWEgdGhhdCBpcyBub3QgYWxsb3dlZC5cIilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgbXMgb2Ygc3ViTWF0Y2hpbmdTY2hlbWFzLnNjaGVtYXMpIHtcbiAgICAgICAgICAgICAgICBtcy5pbnZlcnRlZCA9ICFtcy5pbnZlcnRlZDtcbiAgICAgICAgICAgICAgICBtYXRjaGluZ1NjaGVtYXMuYWRkKG1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXN0QWx0ZXJuYXRpdmVzID0gKGFsdGVybmF0aXZlcywgbWF4T25lTWF0Y2gpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBbXTtcbiAgICAgICAgICAgIC8vIHJlbWVtYmVyIHRoZSBiZXN0IG1hdGNoIHRoYXQgaXMgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXNcbiAgICAgICAgICAgIGxldCBiZXN0TWF0Y2ggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN1YlNjaGVtYVJlZiBvZiBhbHRlcm5hdGl2ZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJTY2hlbWEgPSBhc1NjaGVtYShzdWJTY2hlbWFSZWYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YlZhbGlkYXRpb25SZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1Yk1hdGNoaW5nU2NoZW1hcyA9IG1hdGNoaW5nU2NoZW1hcy5uZXdTdWIoKTtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZShub2RlLCBzdWJTY2hlbWEsIHN1YlZhbGlkYXRpb25SZXN1bHQsIHN1Yk1hdGNoaW5nU2NoZW1hcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKCFzdWJWYWxpZGF0aW9uUmVzdWx0Lmhhc1Byb2JsZW1zKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKHN1YlNjaGVtYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghYmVzdE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaCA9IHsgc2NoZW1hOiBzdWJTY2hlbWEsIHZhbGlkYXRpb25SZXN1bHQ6IHN1YlZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hczogc3ViTWF0Y2hpbmdTY2hlbWFzIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1heE9uZU1hdGNoICYmICFzdWJWYWxpZGF0aW9uUmVzdWx0Lmhhc1Byb2JsZW1zKCkgJiYgIWJlc3RNYXRjaC52YWxpZGF0aW9uUmVzdWx0Lmhhc1Byb2JsZW1zKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIGVycm9ycywgYm90aCBhcmUgZXF1YWxseSBnb29kIG1hdGNoZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5tYXRjaGluZ1NjaGVtYXMubWVyZ2Uoc3ViTWF0Y2hpbmdTY2hlbWFzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC52YWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNNYXRjaGVzICs9IHN1YlZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc01hdGNoZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2gudmFsaWRhdGlvblJlc3VsdC5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzICs9IHN1YlZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc1ZhbHVlTWF0Y2hlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC52YWxpZGF0aW9uUmVzdWx0Lm1lcmdlUHJvY2Vzc2VkUHJvcGVydGllcyhzdWJWYWxpZGF0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBhcmVSZXN1bHQgPSBzdWJWYWxpZGF0aW9uUmVzdWx0LmNvbXBhcmUoYmVzdE1hdGNoLnZhbGlkYXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmVSZXN1bHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3VyIG5vZGUgaXMgdGhlIGJlc3QgbWF0Y2hpbmcgc28gZmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoID0geyBzY2hlbWE6IHN1YlNjaGVtYSwgdmFsaWRhdGlvblJlc3VsdDogc3ViVmFsaWRhdGlvblJlc3VsdCwgbWF0Y2hpbmdTY2hlbWFzOiBzdWJNYXRjaGluZ1NjaGVtYXMgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbXBhcmVSZXN1bHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVyZSdzIGFscmVhZHkgYSBiZXN0IG1hdGNoaW5nIGJ1dCB3ZSBhcmUgYXMgZ29vZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5tYXRjaGluZ1NjaGVtYXMubWVyZ2Uoc3ViTWF0Y2hpbmdTY2hlbWFzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2gudmFsaWRhdGlvblJlc3VsdC5tZXJnZUVudW1WYWx1ZXMoc3ViVmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPiAxICYmIG1heE9uZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiAxIH0sXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHQoXCJNYXRjaGVzIG11bHRpcGxlIHNjaGVtYXMgd2hlbiBvbmx5IG9uZSBtdXN0IHZhbGlkYXRlLlwiKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJlc3RNYXRjaCkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQubWVyZ2UoYmVzdE1hdGNoLnZhbGlkYXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgIG1hdGNoaW5nU2NoZW1hcy5tZXJnZShiZXN0TWF0Y2gubWF0Y2hpbmdTY2hlbWFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzLmxlbmd0aDtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLmFueU9mKSkge1xuICAgICAgICAgICAgdGVzdEFsdGVybmF0aXZlcyhzY2hlbWEuYW55T2YsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEub25lT2YpKSB7XG4gICAgICAgICAgICB0ZXN0QWx0ZXJuYXRpdmVzKHNjaGVtYS5vbmVPZiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGVzdEJyYW5jaCA9IChzY2hlbWEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN1YlZhbGlkYXRpb25SZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdCgpO1xuICAgICAgICAgICAgY29uc3Qgc3ViTWF0Y2hpbmdTY2hlbWFzID0gbWF0Y2hpbmdTY2hlbWFzLm5ld1N1YigpO1xuICAgICAgICAgICAgdmFsaWRhdGUobm9kZSwgYXNTY2hlbWEoc2NoZW1hKSwgc3ViVmFsaWRhdGlvblJlc3VsdCwgc3ViTWF0Y2hpbmdTY2hlbWFzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQubWVyZ2Uoc3ViVmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICBtYXRjaGluZ1NjaGVtYXMubWVyZ2Uoc3ViTWF0Y2hpbmdTY2hlbWFzKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdGVzdENvbmRpdGlvbiA9IChpZlNjaGVtYSwgdGhlblNjaGVtYSwgZWxzZVNjaGVtYSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3ViU2NoZW1hID0gYXNTY2hlbWEoaWZTY2hlbWEpO1xuICAgICAgICAgICAgY29uc3Qgc3ViVmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICBjb25zdCBzdWJNYXRjaGluZ1NjaGVtYXMgPSBtYXRjaGluZ1NjaGVtYXMubmV3U3ViKCk7XG4gICAgICAgICAgICB2YWxpZGF0ZShub2RlLCBzdWJTY2hlbWEsIHN1YlZhbGlkYXRpb25SZXN1bHQsIHN1Yk1hdGNoaW5nU2NoZW1hcywgY29udGV4dCk7XG4gICAgICAgICAgICBtYXRjaGluZ1NjaGVtYXMubWVyZ2Uoc3ViTWF0Y2hpbmdTY2hlbWFzKTtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQubWVyZ2VQcm9jZXNzZWRQcm9wZXJ0aWVzKHN1YlZhbGlkYXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgaWYgKCFzdWJWYWxpZGF0aW9uUmVzdWx0Lmhhc1Byb2JsZW1zKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhlblNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICB0ZXN0QnJhbmNoKHRoZW5TY2hlbWEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVsc2VTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICB0ZXN0QnJhbmNoKGVsc2VTY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBpZlNjaGVtYSA9IGFzU2NoZW1hKHNjaGVtYS5pZik7XG4gICAgICAgIGlmIChpZlNjaGVtYSkge1xuICAgICAgICAgICAgdGVzdENvbmRpdGlvbihpZlNjaGVtYSwgYXNTY2hlbWEoc2NoZW1hLnRoZW4pLCBhc1NjaGVtYShzY2hlbWEuZWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5lbnVtKSkge1xuICAgICAgICAgICAgY29uc3QgdmFsID0ganNvblBhcnNlcl9nZXROb2RlVmFsdWUobm9kZSk7XG4gICAgICAgICAgICBsZXQgZW51bVZhbHVlTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBzY2hlbWEuZW51bSkge1xuICAgICAgICAgICAgICAgIGlmIChlcXVhbHModmFsLCBlKSkge1xuICAgICAgICAgICAgICAgICAgICBlbnVtVmFsdWVNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQuZW51bVZhbHVlcyA9IHNjaGVtYS5lbnVtO1xuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5lbnVtVmFsdWVNYXRjaCA9IGVudW1WYWx1ZU1hdGNoO1xuICAgICAgICAgICAgaWYgKCFlbnVtVmFsdWVNYXRjaCkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogRXJyb3JDb2RlLkVudW1WYWx1ZU1pc21hdGNoLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IHQoJ1ZhbHVlIGlzIG5vdCBhY2NlcHRlZC4gVmFsaWQgdmFsdWVzOiB7MH0uJywgc2NoZW1hLmVudW0ubWFwKHYgPT4gSlNPTi5zdHJpbmdpZnkodikpLmpvaW4oJywgJykpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmaW5lZChzY2hlbWEuY29uc3QpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSBqc29uUGFyc2VyX2dldE5vZGVWYWx1ZShub2RlKTtcbiAgICAgICAgICAgIGlmICghZXF1YWxzKHZhbCwgc2NoZW1hLmNvbnN0KSkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogRXJyb3JDb2RlLkVudW1WYWx1ZU1pc21hdGNoLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IHQoJ1ZhbHVlIG11c3QgYmUgezB9LicsIEpTT04uc3RyaW5naWZ5KHNjaGVtYS5jb25zdCkpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5lbnVtVmFsdWVNYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5lbnVtVmFsdWVNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LmVudW1WYWx1ZXMgPSBbc2NoZW1hLmNvbnN0XTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVwcmVjYXRpb25NZXNzYWdlID0gc2NoZW1hLmRlcHJlY2F0aW9uTWVzc2FnZTtcbiAgICAgICAgaWYgKChkZXByZWNhdGlvbk1lc3NhZ2UgfHwgc2NoZW1hLmRlcHJlY2F0ZWQpICYmIG5vZGUucGFyZW50KSB7XG4gICAgICAgICAgICBkZXByZWNhdGlvbk1lc3NhZ2UgPSBkZXByZWNhdGlvbk1lc3NhZ2UgfHwgdCgnVmFsdWUgaXMgZGVwcmVjYXRlZCcpO1xuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUucGFyZW50Lm9mZnNldCwgbGVuZ3RoOiBub2RlLnBhcmVudC5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICBzZXZlcml0eTogbWFpbi5EaWFnbm9zdGljU2V2ZXJpdHkuV2FybmluZyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZXByZWNhdGlvbk1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgY29kZTogRXJyb3JDb2RlLkRlcHJlY2F0ZWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIF92YWxpZGF0ZU51bWJlck5vZGUobm9kZSkge1xuICAgICAgICBjb25zdCB2YWwgPSBub2RlLnZhbHVlO1xuICAgICAgICBmdW5jdGlvbiBub3JtYWxpemVGbG9hdHMoZmxvYXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gL14oLT9cXGQrKSg/OlxcLihcXGQrKSk/KD86ZShbLStdXFxkKykpPyQvLmV4ZWMoZmxvYXQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICByZXR1cm4gcGFydHMgJiYge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIocGFydHNbMV0gKyAocGFydHNbMl0gfHwgJycpKSxcbiAgICAgICAgICAgICAgICBtdWx0aXBsaWVyOiAocGFydHNbMl0/Lmxlbmd0aCB8fCAwKSAtIChwYXJzZUludChwYXJ0c1szXSkgfHwgMClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBpZiAoaXNOdW1iZXIoc2NoZW1hLm11bHRpcGxlT2YpKSB7XG4gICAgICAgICAgICBsZXQgcmVtYWluZGVyID0gLTE7XG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihzY2hlbWEubXVsdGlwbGVPZikpIHtcbiAgICAgICAgICAgICAgICByZW1haW5kZXIgPSB2YWwgJSBzY2hlbWEubXVsdGlwbGVPZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBub3JtTXVsdGlwbGVPZiA9IG5vcm1hbGl6ZUZsb2F0cyhzY2hlbWEubXVsdGlwbGVPZik7XG4gICAgICAgICAgICAgICAgbGV0IG5vcm1WYWx1ZSA9IG5vcm1hbGl6ZUZsb2F0cyh2YWwpO1xuICAgICAgICAgICAgICAgIGlmIChub3JtTXVsdGlwbGVPZiAmJiBub3JtVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbXVsdGlwbGllciA9IDEwICoqIE1hdGguYWJzKG5vcm1WYWx1ZS5tdWx0aXBsaWVyIC0gbm9ybU11bHRpcGxlT2YubXVsdGlwbGllcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub3JtVmFsdWUubXVsdGlwbGllciA8IG5vcm1NdWx0aXBsZU9mLm11bHRpcGxpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1WYWx1ZS52YWx1ZSAqPSBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybU11bHRpcGxlT2YudmFsdWUgKj0gbXVsdGlwbGllcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZW1haW5kZXIgPSBub3JtVmFsdWUudmFsdWUgJSBub3JtTXVsdGlwbGVPZi52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVtYWluZGVyICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB0KCdWYWx1ZSBpcyBub3QgZGl2aXNpYmxlIGJ5IHswfS4nLCBzY2hlbWEubXVsdGlwbGVPZilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRFeGNsdXNpdmVMaW1pdChsaW1pdCwgZXhjbHVzaXZlKSB7XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoZXhjbHVzaXZlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBleGNsdXNpdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNCb29sZWFuKGV4Y2x1c2l2ZSkgJiYgZXhjbHVzaXZlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRMaW1pdChsaW1pdCwgZXhjbHVzaXZlKSB7XG4gICAgICAgICAgICBpZiAoIWlzQm9vbGVhbihleGNsdXNpdmUpIHx8ICFleGNsdXNpdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4Y2x1c2l2ZU1pbmltdW0gPSBnZXRFeGNsdXNpdmVMaW1pdChzY2hlbWEubWluaW11bSwgc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0pO1xuICAgICAgICBpZiAoaXNOdW1iZXIoZXhjbHVzaXZlTWluaW11bSkgJiYgdmFsIDw9IGV4Y2x1c2l2ZU1pbmltdW0pIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHQoJ1ZhbHVlIGlzIGJlbG93IHRoZSBleGNsdXNpdmUgbWluaW11bSBvZiB7MH0uJywgZXhjbHVzaXZlTWluaW11bSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4Y2x1c2l2ZU1heGltdW0gPSBnZXRFeGNsdXNpdmVMaW1pdChzY2hlbWEubWF4aW11bSwgc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0pO1xuICAgICAgICBpZiAoaXNOdW1iZXIoZXhjbHVzaXZlTWF4aW11bSkgJiYgdmFsID49IGV4Y2x1c2l2ZU1heGltdW0pIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHQoJ1ZhbHVlIGlzIGFib3ZlIHRoZSBleGNsdXNpdmUgbWF4aW11bSBvZiB7MH0uJywgZXhjbHVzaXZlTWF4aW11bSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1pbmltdW0gPSBnZXRMaW1pdChzY2hlbWEubWluaW11bSwgc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0pO1xuICAgICAgICBpZiAoaXNOdW1iZXIobWluaW11bSkgJiYgdmFsIDwgbWluaW11bSkge1xuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IG5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogdCgnVmFsdWUgaXMgYmVsb3cgdGhlIG1pbmltdW0gb2YgezB9LicsIG1pbmltdW0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXhpbXVtID0gZ2V0TGltaXQoc2NoZW1hLm1heGltdW0sIHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtKTtcbiAgICAgICAgaWYgKGlzTnVtYmVyKG1heGltdW0pICYmIHZhbCA+IG1heGltdW0pIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHQoJ1ZhbHVlIGlzIGFib3ZlIHRoZSBtYXhpbXVtIG9mIHswfS4nLCBtYXhpbXVtKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gX3ZhbGlkYXRlU3RyaW5nTm9kZShub2RlKSB7XG4gICAgICAgIGlmIChpc051bWJlcihzY2hlbWEubWluTGVuZ3RoKSAmJiBzdHJpbmdMZW5ndGgobm9kZS52YWx1ZSkgPCBzY2hlbWEubWluTGVuZ3RoKSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB0KCdTdHJpbmcgaXMgc2hvcnRlciB0aGFuIHRoZSBtaW5pbXVtIGxlbmd0aCBvZiB7MH0uJywgc2NoZW1hLm1pbkxlbmd0aClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bWJlcihzY2hlbWEubWF4TGVuZ3RoKSAmJiBzdHJpbmdMZW5ndGgobm9kZS52YWx1ZSkgPiBzY2hlbWEubWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB0KCdTdHJpbmcgaXMgbG9uZ2VyIHRoYW4gdGhlIG1heGltdW0gbGVuZ3RoIG9mIHswfS4nLCBzY2hlbWEubWF4TGVuZ3RoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaW5nKHNjaGVtYS5wYXR0ZXJuKSkge1xuICAgICAgICAgICAgY29uc3QgcmVnZXggPSBleHRlbmRlZFJlZ0V4cChzY2hlbWEucGF0dGVybik7XG4gICAgICAgICAgICBpZiAoIShyZWdleD8udGVzdChub2RlLnZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IG5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNjaGVtYS5wYXR0ZXJuRXJyb3JNZXNzYWdlIHx8IHNjaGVtYS5lcnJvck1lc3NhZ2UgfHwgdCgnU3RyaW5nIGRvZXMgbm90IG1hdGNoIHRoZSBwYXR0ZXJuIG9mIFwiezB9XCIuJywgc2NoZW1hLnBhdHRlcm4pXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5mb3JtYXQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoc2NoZW1hLmZvcm1hdCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3VyaSc6XG4gICAgICAgICAgICAgICAgY2FzZSAndXJpLXJlZmVyZW5jZSc6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlcnJvck1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSB0KCdVUkkgZXhwZWN0ZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IC9eKChbXjovPyNdKz8pOik/KFxcL1xcLyhbXi8/I10qKSk/KFtePyNdKikoXFw/KFteI10qKSk/KCMoLiopKT8vLmV4ZWMobm9kZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSB0KCdVUkkgaXMgZXhwZWN0ZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFtYXRjaFsyXSAmJiBzY2hlbWEuZm9ybWF0ID09PSAndXJpJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSB0KCdVUkkgd2l0aCBhIHNjaGVtZSBpcyBleHBlY3RlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEucGF0dGVybkVycm9yTWVzc2FnZSB8fCBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IHQoJ1N0cmluZyBpcyBub3QgYSBVUkk6IHswfScsIGVycm9yTWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjb2xvci1oZXgnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2RhdGUtdGltZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAndGltZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZW1haWwnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2hvc3RuYW1lJzpcbiAgICAgICAgICAgICAgICBjYXNlICdpcHY0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdpcHY2JzpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0ID0gZm9ybWF0c1tzY2hlbWEuZm9ybWF0XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLnZhbHVlIHx8ICFmb3JtYXQucGF0dGVybi5leGVjKG5vZGUudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEucGF0dGVybkVycm9yTWVzc2FnZSB8fCBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IGZvcm1hdC5lcnJvck1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBfdmFsaWRhdGVBcnJheU5vZGUobm9kZSkge1xuICAgICAgICBsZXQgcHJlZml4SXRlbXNTY2hlbWFzO1xuICAgICAgICBsZXQgYWRkaXRpb25hbEl0ZW1TY2hlbWE7XG4gICAgICAgIGlmIChjb250ZXh0LnNjaGVtYURyYWZ0ID49IFNjaGVtYURyYWZ0LnYyMDIwXzEyKSB7XG4gICAgICAgICAgICBwcmVmaXhJdGVtc1NjaGVtYXMgPSBzY2hlbWEucHJlZml4SXRlbXM7XG4gICAgICAgICAgICBhZGRpdGlvbmFsSXRlbVNjaGVtYSA9ICFBcnJheS5pc0FycmF5KHNjaGVtYS5pdGVtcykgPyBzY2hlbWEuaXRlbXMgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcmVmaXhJdGVtc1NjaGVtYXMgPSBBcnJheS5pc0FycmF5KHNjaGVtYS5pdGVtcykgPyBzY2hlbWEuaXRlbXMgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBhZGRpdGlvbmFsSXRlbVNjaGVtYSA9ICFBcnJheS5pc0FycmF5KHNjaGVtYS5pdGVtcykgPyBzY2hlbWEuaXRlbXMgOiBzY2hlbWEuYWRkaXRpb25hbEl0ZW1zO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGlmIChwcmVmaXhJdGVtc1NjaGVtYXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgbWF4ID0gTWF0aC5taW4ocHJlZml4SXRlbXNTY2hlbWFzLmxlbmd0aCwgbm9kZS5pdGVtcy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViU2NoZW1hUmVmID0gcHJlZml4SXRlbXNTY2hlbWFzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJTY2hlbWEgPSBhc1NjaGVtYShzdWJTY2hlbWFSZWYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1WYWxpZGF0aW9uUmVzdWx0ID0gbmV3IFZhbGlkYXRpb25SZXN1bHQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gbm9kZS5pdGVtc1tpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGUoaXRlbSwgc3ViU2NoZW1hLCBpdGVtVmFsaWRhdGlvblJlc3VsdCwgbWF0Y2hpbmdTY2hlbWFzLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5tZXJnZVByb3BlcnR5TWF0Y2goaXRlbVZhbGlkYXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2Nlc3NlZFByb3BlcnRpZXMuYWRkKFN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRpdGlvbmFsSXRlbVNjaGVtYSAhPT0gdW5kZWZpbmVkICYmIGluZGV4IDwgbm9kZS5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYWRkaXRpb25hbEl0ZW1TY2hlbWEgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGlmIChhZGRpdGlvbmFsSXRlbVNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHQoJ0FycmF5IGhhcyB0b28gbWFueSBpdGVtcyBhY2NvcmRpbmcgdG8gc2NoZW1hLiBFeHBlY3RlZCB7MH0gb3IgZmV3ZXIuJywgaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKDsgaW5kZXggPCBub2RlLml0ZW1zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2Nlc3NlZFByb3BlcnRpZXMuYWRkKFN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNWYWx1ZU1hdGNoZXMrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKDsgaW5kZXggPCBub2RlLml0ZW1zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtVmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlKG5vZGUuaXRlbXNbaW5kZXhdLCBhZGRpdGlvbmFsSXRlbVNjaGVtYSwgaXRlbVZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQubWVyZ2VQcm9wZXJ0eU1hdGNoKGl0ZW1WYWxpZGF0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9jZXNzZWRQcm9wZXJ0aWVzLmFkZChTdHJpbmcoaW5kZXgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGFpbnNTY2hlbWEgPSBhc1NjaGVtYShzY2hlbWEuY29udGFpbnMpO1xuICAgICAgICBpZiAoY29udGFpbnNTY2hlbWEpIHtcbiAgICAgICAgICAgIGxldCBjb250YWluc0NvdW50ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBub2RlLml0ZW1zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBub2RlLml0ZW1zW2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtVmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGUoaXRlbSwgY29udGFpbnNTY2hlbWEsIGl0ZW1WYWxpZGF0aW9uUmVzdWx0LCBOb09wU2NoZW1hQ29sbGVjdG9yLmluc3RhbmNlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW1WYWxpZGF0aW9uUmVzdWx0Lmhhc1Byb2JsZW1zKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbnNDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5zY2hlbWFEcmFmdCA+PSBTY2hlbWFEcmFmdC52MjAyMF8xMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9jZXNzZWRQcm9wZXJ0aWVzLmFkZChTdHJpbmcoaW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250YWluc0NvdW50ID09PSAwICYmICFpc051bWJlcihzY2hlbWEubWluQ29udGFpbnMpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IHQoJ0FycmF5IGRvZXMgbm90IGNvbnRhaW4gcmVxdWlyZWQgaXRlbS4nKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKHNjaGVtYS5taW5Db250YWlucykgJiYgY29udGFpbnNDb3VudCA8IHNjaGVtYS5taW5Db250YWlucykge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdCgnQXJyYXkgaGFzIHRvbyBmZXcgaXRlbXMgdGhhdCBtYXRjaCB0aGUgY29udGFpbnMgY29udHJhaW50LiBFeHBlY3RlZCB7MH0gb3IgbW9yZS4nLCBzY2hlbWEubWluQ29udGFpbnMpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoc2NoZW1hLm1heENvbnRhaW5zKSAmJiBjb250YWluc0NvdW50ID4gc2NoZW1hLm1heENvbnRhaW5zKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB0KCdBcnJheSBoYXMgdG9vIG1hbnkgaXRlbXMgdGhhdCBtYXRjaCB0aGUgY29udGFpbnMgY29udHJhaW50LiBFeHBlY3RlZCB7MH0gb3IgbGVzcy4nLCBzY2hlbWEubWF4Q29udGFpbnMpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdW5ldmFsdWF0ZWRJdGVtcyA9IHNjaGVtYS51bmV2YWx1YXRlZEl0ZW1zO1xuICAgICAgICBpZiAodW5ldmFsdWF0ZWRJdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRpb25SZXN1bHQucHJvY2Vzc2VkUHJvcGVydGllcy5oYXMoU3RyaW5nKGkpKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodW5ldmFsdWF0ZWRJdGVtcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHQoJ0l0ZW0gZG9lcyBub3QgbWF0Y2ggYW55IHZhbGlkYXRpb24gcnVsZSBmcm9tIHRoZSBhcnJheS4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtVmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZShub2RlLml0ZW1zW2ldLCBzY2hlbWEudW5ldmFsdWF0ZWRJdGVtcywgaXRlbVZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0Lm1lcmdlUHJvcGVydHlNYXRjaChpdGVtVmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9jZXNzZWRQcm9wZXJ0aWVzLmFkZChTdHJpbmcoaSkpO1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc1ZhbHVlTWF0Y2hlcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bWJlcihzY2hlbWEubWluSXRlbXMpICYmIG5vZGUuaXRlbXMubGVuZ3RoIDwgc2NoZW1hLm1pbkl0ZW1zKSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB0KCdBcnJheSBoYXMgdG9vIGZldyBpdGVtcy4gRXhwZWN0ZWQgezB9IG9yIG1vcmUuJywgc2NoZW1hLm1pbkl0ZW1zKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKHNjaGVtYS5tYXhJdGVtcykgJiYgbm9kZS5pdGVtcy5sZW5ndGggPiBzY2hlbWEubWF4SXRlbXMpIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHQoJ0FycmF5IGhhcyB0b28gbWFueSBpdGVtcy4gRXhwZWN0ZWQgezB9IG9yIGZld2VyLicsIHNjaGVtYS5tYXhJdGVtcylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEudW5pcXVlSXRlbXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGpzb25QYXJzZXJfZ2V0Tm9kZVZhbHVlKG5vZGUpO1xuICAgICAgICAgICAgY29uc3QgZHVwbGljYXRlcyA9IHZhbHVlcy5zb21lKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggIT09IHZhbHVlcy5sYXN0SW5kZXhPZih2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChkdXBsaWNhdGVzKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB0KCdBcnJheSBoYXMgZHVwbGljYXRlIGl0ZW1zLicpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gX3ZhbGlkYXRlT2JqZWN0Tm9kZShub2RlKSB7XG4gICAgICAgIGNvbnN0IHNlZW5LZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgY29uc3QgdW5wcm9jZXNzZWRQcm9wZXJ0aWVzID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5Tm9kZSBvZiBub2RlLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHByb3BlcnR5Tm9kZS5rZXlOb2RlLnZhbHVlO1xuICAgICAgICAgICAgc2VlbktleXNba2V5XSA9IHByb3BlcnR5Tm9kZS52YWx1ZU5vZGU7XG4gICAgICAgICAgICB1bnByb2Nlc3NlZFByb3BlcnRpZXMuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLnJlcXVpcmVkKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eU5hbWUgb2Ygc2NoZW1hLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWVuS2V5c1twcm9wZXJ0eU5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleU5vZGUgPSBub2RlLnBhcmVudCAmJiBub2RlLnBhcmVudC50eXBlID09PSAncHJvcGVydHknICYmIG5vZGUucGFyZW50LmtleU5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0ga2V5Tm9kZSA/IHsgb2Zmc2V0OiBrZXlOb2RlLm9mZnNldCwgbGVuZ3RoOiBrZXlOb2RlLmxlbmd0aCB9IDogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IDEgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHQoJ01pc3NpbmcgcHJvcGVydHkgXCJ7MH1cIi4nLCBwcm9wZXJ0eU5hbWUpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9wZXJ0eVByb2Nlc3NlZCA9IChwcm9wKSA9PiB7XG4gICAgICAgICAgICB1bnByb2Nlc3NlZFByb3BlcnRpZXMuZGVsZXRlKHByb3ApO1xuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9jZXNzZWRQcm9wZXJ0aWVzLmFkZChwcm9wKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNjaGVtYS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5TmFtZSBvZiBPYmplY3Qua2V5cyhzY2hlbWEucHJvcGVydGllcykpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eVByb2Nlc3NlZChwcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5U2NoZW1hID0gc2NoZW1hLnByb3BlcnRpZXNbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IHNlZW5LZXlzW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Jvb2xlYW4ocHJvcGVydHlTY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3BlcnR5U2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHlOb2RlID0gY2hpbGQucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogcHJvcGVydHlOb2RlLmtleU5vZGUub2Zmc2V0LCBsZW5ndGg6IHByb3BlcnR5Tm9kZS5rZXlOb2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IHQoJ1Byb3BlcnR5IHswfSBpcyBub3QgYWxsb3dlZC4nLCBwcm9wZXJ0eU5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNNYXRjaGVzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGUoY2hpbGQsIHByb3BlcnR5U2NoZW1hLCBwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0Lm1lcmdlUHJvcGVydHlNYXRjaChwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcGVydHlQYXR0ZXJuIG9mIE9iamVjdC5rZXlzKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IGV4dGVuZGVkUmVnRXhwKHByb3BlcnR5UGF0dGVybik7XG4gICAgICAgICAgICAgICAgaWYgKHJlZ2V4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5TmFtZSBvZiB1bnByb2Nlc3NlZFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KHByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWQucHVzaChwcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gc2VlbktleXNbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHlTY2hlbWEgPSBzY2hlbWEucGF0dGVyblByb3BlcnRpZXNbcHJvcGVydHlQYXR0ZXJuXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQm9vbGVhbihwcm9wZXJ0eVNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJvcGVydHlTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eU5vZGUgPSBjaGlsZC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBwcm9wZXJ0eU5vZGUua2V5Tm9kZS5vZmZzZXQsIGxlbmd0aDogcHJvcGVydHlOb2RlLmtleU5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNjaGVtYS5lcnJvck1lc3NhZ2UgfHwgdCgnUHJvcGVydHkgezB9IGlzIG5vdCBhbGxvd2VkLicsIHByb3BlcnR5TmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc01hdGNoZXMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNWYWx1ZU1hdGNoZXMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZShjaGlsZCwgcHJvcGVydHlTY2hlbWEsIHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCwgbWF0Y2hpbmdTY2hlbWFzLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQubWVyZ2VQcm9wZXJ0eU1hdGNoKHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkLmZvckVhY2gocHJvcGVydHlQcm9jZXNzZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRpdGlvbmFsUHJvcGVydGllcyA9IHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcztcbiAgICAgICAgaWYgKGFkZGl0aW9uYWxQcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcGVydHlOYW1lIG9mIHVucHJvY2Vzc2VkUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5UHJvY2Vzc2VkKHByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBzZWVuS2V5c1twcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eU5vZGUgPSBjaGlsZC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogcHJvcGVydHlOb2RlLmtleU5vZGUub2Zmc2V0LCBsZW5ndGg6IHByb3BlcnR5Tm9kZS5rZXlOb2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNjaGVtYS5lcnJvck1lc3NhZ2UgfHwgdCgnUHJvcGVydHkgezB9IGlzIG5vdCBhbGxvd2VkLicsIHByb3BlcnR5TmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFkZGl0aW9uYWxQcm9wZXJ0aWVzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGUoY2hpbGQsIGFkZGl0aW9uYWxQcm9wZXJ0aWVzLCBwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0Lm1lcmdlUHJvcGVydHlNYXRjaChwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVuZXZhbHVhdGVkUHJvcGVydGllcyA9IHNjaGVtYS51bmV2YWx1YXRlZFByb3BlcnRpZXM7XG4gICAgICAgIGlmICh1bmV2YWx1YXRlZFByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5TmFtZSBvZiB1bnByb2Nlc3NlZFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRpb25SZXN1bHQucHJvY2Vzc2VkUHJvcGVydGllcy5oYXMocHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWQucHVzaChwcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IHNlZW5LZXlzW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuZXZhbHVhdGVkUHJvcGVydGllcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eU5vZGUgPSBjaGlsZC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBwcm9wZXJ0eU5vZGUua2V5Tm9kZS5vZmZzZXQsIGxlbmd0aDogcHJvcGVydHlOb2RlLmtleU5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNjaGVtYS5lcnJvck1lc3NhZ2UgfHwgdCgnUHJvcGVydHkgezB9IGlzIG5vdCBhbGxvd2VkLicsIHByb3BlcnR5TmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHVuZXZhbHVhdGVkUHJvcGVydGllcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGUoY2hpbGQsIHVuZXZhbHVhdGVkUHJvcGVydGllcywgcHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0LCBtYXRjaGluZ1NjaGVtYXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQubWVyZ2VQcm9wZXJ0eU1hdGNoKHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9jZXNzZWQuZm9yRWFjaChwcm9wZXJ0eVByb2Nlc3NlZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKHNjaGVtYS5tYXhQcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUucHJvcGVydGllcy5sZW5ndGggPiBzY2hlbWEubWF4UHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdCgnT2JqZWN0IGhhcyBtb3JlIHByb3BlcnRpZXMgdGhhbiBsaW1pdCBvZiB7MH0uJywgc2NoZW1hLm1heFByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKHNjaGVtYS5taW5Qcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUucHJvcGVydGllcy5sZW5ndGggPCBzY2hlbWEubWluUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdCgnT2JqZWN0IGhhcyBmZXdlciBwcm9wZXJ0aWVzIHRoYW4gdGhlIHJlcXVpcmVkIG51bWJlciBvZiB7MH0nLCBzY2hlbWEubWluUHJvcGVydGllcylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLmRlcGVuZGVudFJlcXVpcmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuZGVwZW5kZW50UmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wID0gc2VlbktleXNba2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eURlcHMgPSBzY2hlbWEuZGVwZW5kZW50UmVxdWlyZWRba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCAmJiBBcnJheS5pc0FycmF5KHByb3BlcnR5RGVwcykpIHtcbiAgICAgICAgICAgICAgICAgICAgX3ZhbGlkYXRlUHJvcGVydHlEZXBlbmRlbmNpZXMoa2V5LCBwcm9wZXJ0eURlcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLmRlcGVuZGVudFNjaGVtYXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5kZXBlbmRlbnRTY2hlbWFzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcCA9IHNlZW5LZXlzW2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHlEZXBzID0gc2NoZW1hLmRlcGVuZGVudFNjaGVtYXNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCAmJiBpc09iamVjdChwcm9wZXJ0eURlcHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIF92YWxpZGF0ZVByb3BlcnR5RGVwZW5kZW5jaWVzKGtleSwgcHJvcGVydHlEZXBzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wID0gc2VlbktleXNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBfdmFsaWRhdGVQcm9wZXJ0eURlcGVuZGVuY2llcyhrZXksIHNjaGVtYS5kZXBlbmRlbmNpZXNba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3BlcnR5TmFtZXMgPSBhc1NjaGVtYShzY2hlbWEucHJvcGVydHlOYW1lcyk7XG4gICAgICAgIGlmIChwcm9wZXJ0eU5hbWVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGYgb2Ygbm9kZS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gZi5rZXlOb2RlO1xuICAgICAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGUoa2V5LCBwcm9wZXJ0eU5hbWVzLCB2YWxpZGF0aW9uUmVzdWx0LCBOb09wU2NoZW1hQ29sbGVjdG9yLmluc3RhbmNlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gX3ZhbGlkYXRlUHJvcGVydHlEZXBlbmRlbmNpZXMoa2V5LCBwcm9wZXJ0eURlcCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcGVydHlEZXApKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByZXF1aXJlZFByb3Agb2YgcHJvcGVydHlEZXApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWVuS2V5c1tyZXF1aXJlZFByb3BdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB0KCdPYmplY3QgaXMgbWlzc2luZyBwcm9wZXJ0eSB7MH0gcmVxdWlyZWQgYnkgcHJvcGVydHkgezF9LicsIHJlcXVpcmVkUHJvcCwga2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNWYWx1ZU1hdGNoZXMrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5U2NoZW1hID0gYXNTY2hlbWEocHJvcGVydHlEZXApO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eVNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZShub2RlLCBwcm9wZXJ0eVNjaGVtYSwgcHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0LCBtYXRjaGluZ1NjaGVtYXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0Lm1lcmdlUHJvcGVydHlNYXRjaChwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGpzb25QYXJzZXJfcGFyc2UodGV4dERvY3VtZW50LCBjb25maWcpIHtcbiAgICBjb25zdCBwcm9ibGVtcyA9IFtdO1xuICAgIGxldCBsYXN0UHJvYmxlbU9mZnNldCA9IC0xO1xuICAgIGNvbnN0IHRleHQgPSB0ZXh0RG9jdW1lbnQuZ2V0VGV4dCgpO1xuICAgIGNvbnN0IHNjYW5uZXIgPSBtYWluX2NyZWF0ZVNjYW5uZXIodGV4dCwgZmFsc2UpO1xuICAgIGNvbnN0IGNvbW1lbnRSYW5nZXMgPSBjb25maWcgJiYgY29uZmlnLmNvbGxlY3RDb21tZW50cyA/IFtdIDogdW5kZWZpbmVkO1xuICAgIGZ1bmN0aW9uIF9zY2FuTmV4dCgpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gc2Nhbm5lci5zY2FuKCk7XG4gICAgICAgICAgICBfY2hlY2tTY2FuRXJyb3IoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDEyIC8qIEpzb24uU3ludGF4S2luZC5MaW5lQ29tbWVudFRyaXZpYSAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIDEzIC8qIEpzb24uU3ludGF4S2luZC5CbG9ja0NvbW1lbnRUcml2aWEgKi86XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbW1lbnRSYW5nZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50UmFuZ2VzLnB1c2gobWFpbi5SYW5nZS5jcmVhdGUodGV4dERvY3VtZW50LnBvc2l0aW9uQXQoc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpKSwgdGV4dERvY3VtZW50LnBvc2l0aW9uQXQoc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpICsgc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTUgLyogSnNvbi5TeW50YXhLaW5kLlRyaXZpYSAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIDE0IC8qIEpzb24uU3ludGF4S2luZC5MaW5lQnJlYWtUcml2aWEgKi86XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBfYWNjZXB0KHRva2VuKSB7XG4gICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgPT09IHRva2VuKSB7XG4gICAgICAgICAgICBfc2Nhbk5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2Vycm9yQXRSYW5nZShtZXNzYWdlLCBjb2RlLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCBzZXZlcml0eSA9IG1haW4uRGlhZ25vc3RpY1NldmVyaXR5LkVycm9yKSB7XG4gICAgICAgIGlmIChwcm9ibGVtcy5sZW5ndGggPT09IDAgfHwgc3RhcnRPZmZzZXQgIT09IGxhc3RQcm9ibGVtT2Zmc2V0KSB7XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IG1haW4uUmFuZ2UuY3JlYXRlKHRleHREb2N1bWVudC5wb3NpdGlvbkF0KHN0YXJ0T2Zmc2V0KSwgdGV4dERvY3VtZW50LnBvc2l0aW9uQXQoZW5kT2Zmc2V0KSk7XG4gICAgICAgICAgICBwcm9ibGVtcy5wdXNoKG1haW4uRGlhZ25vc3RpYy5jcmVhdGUocmFuZ2UsIG1lc3NhZ2UsIHNldmVyaXR5LCBjb2RlLCB0ZXh0RG9jdW1lbnQubGFuZ3VhZ2VJZCkpO1xuICAgICAgICAgICAgbGFzdFByb2JsZW1PZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBfZXJyb3IobWVzc2FnZSwgY29kZSwgbm9kZSA9IHVuZGVmaW5lZCwgc2tpcFVudGlsQWZ0ZXIgPSBbXSwgc2tpcFVudGlsID0gW10pIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpO1xuICAgICAgICBsZXQgZW5kID0gc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpICsgc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpO1xuICAgICAgICBpZiAoc3RhcnQgPT09IGVuZCAmJiBzdGFydCA+IDApIHtcbiAgICAgICAgICAgIHN0YXJ0LS07XG4gICAgICAgICAgICB3aGlsZSAoc3RhcnQgPiAwICYmIC9cXHMvLnRlc3QodGV4dC5jaGFyQXQoc3RhcnQpKSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmQgPSBzdGFydCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgX2Vycm9yQXRSYW5nZShtZXNzYWdlLCBjb2RlLCBzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIF9maW5hbGl6ZShub2RlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNraXBVbnRpbEFmdGVyLmxlbmd0aCArIHNraXBVbnRpbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgdG9rZW4gPSBzY2FubmVyLmdldFRva2VuKCk7XG4gICAgICAgICAgICB3aGlsZSAodG9rZW4gIT09IDE3IC8qIEpzb24uU3ludGF4S2luZC5FT0YgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcFVudGlsQWZ0ZXIuaW5kZXhPZih0b2tlbikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIF9zY2FuTmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2tpcFVudGlsLmluZGV4T2YodG9rZW4pICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBfc2Nhbk5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2NoZWNrU2NhbkVycm9yKCkge1xuICAgICAgICBzd2l0Y2ggKHNjYW5uZXIuZ2V0VG9rZW5FcnJvcigpKSB7XG4gICAgICAgICAgICBjYXNlIDQgLyogSnNvbi5TY2FuRXJyb3IuSW52YWxpZFVuaWNvZGUgKi86XG4gICAgICAgICAgICAgICAgX2Vycm9yKHQoJ0ludmFsaWQgdW5pY29kZSBzZXF1ZW5jZSBpbiBzdHJpbmcuJyksIEVycm9yQ29kZS5JbnZhbGlkVW5pY29kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjYXNlIDUgLyogSnNvbi5TY2FuRXJyb3IuSW52YWxpZEVzY2FwZUNoYXJhY3RlciAqLzpcbiAgICAgICAgICAgICAgICBfZXJyb3IodCgnSW52YWxpZCBlc2NhcGUgY2hhcmFjdGVyIGluIHN0cmluZy4nKSwgRXJyb3JDb2RlLkludmFsaWRFc2NhcGVDaGFyYWN0ZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY2FzZSAzIC8qIEpzb24uU2NhbkVycm9yLlVuZXhwZWN0ZWRFbmRPZk51bWJlciAqLzpcbiAgICAgICAgICAgICAgICBfZXJyb3IodCgnVW5leHBlY3RlZCBlbmQgb2YgbnVtYmVyLicpLCBFcnJvckNvZGUuVW5leHBlY3RlZEVuZE9mTnVtYmVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBKc29uLlNjYW5FcnJvci5VbmV4cGVjdGVkRW5kT2ZDb21tZW50ICovOlxuICAgICAgICAgICAgICAgIF9lcnJvcih0KCdVbmV4cGVjdGVkIGVuZCBvZiBjb21tZW50LicpLCBFcnJvckNvZGUuVW5leHBlY3RlZEVuZE9mQ29tbWVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjYXNlIDIgLyogSnNvbi5TY2FuRXJyb3IuVW5leHBlY3RlZEVuZE9mU3RyaW5nICovOlxuICAgICAgICAgICAgICAgIF9lcnJvcih0KCdVbmV4cGVjdGVkIGVuZCBvZiBzdHJpbmcuJyksIEVycm9yQ29kZS5VbmV4cGVjdGVkRW5kT2ZTdHJpbmcpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY2FzZSA2IC8qIEpzb24uU2NhbkVycm9yLkludmFsaWRDaGFyYWN0ZXIgKi86XG4gICAgICAgICAgICAgICAgX2Vycm9yKHQoJ0ludmFsaWQgY2hhcmFjdGVycyBpbiBzdHJpbmcuIENvbnRyb2wgY2hhcmFjdGVycyBtdXN0IGJlIGVzY2FwZWQuJyksIEVycm9yQ29kZS5JbnZhbGlkQ2hhcmFjdGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9maW5hbGl6ZShub2RlLCBzY2FuTmV4dCkge1xuICAgICAgICBub2RlLmxlbmd0aCA9IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSArIHNjYW5uZXIuZ2V0VG9rZW5MZW5ndGgoKSAtIG5vZGUub2Zmc2V0O1xuICAgICAgICBpZiAoc2Nhbk5leHQpIHtcbiAgICAgICAgICAgIF9zY2FuTmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfcGFyc2VBcnJheShwYXJlbnQpIHtcbiAgICAgICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMyAvKiBKc29uLlN5bnRheEtpbmQuT3BlbkJyYWNrZXRUb2tlbiAqLykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2RlID0gbmV3IEFycmF5QVNUTm9kZUltcGwocGFyZW50LCBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkpO1xuICAgICAgICBfc2Nhbk5leHQoKTsgLy8gY29uc3VtZSBPcGVuQnJhY2tldFRva2VuXG4gICAgICAgIGNvbnN0IGNvdW50ID0gMDtcbiAgICAgICAgbGV0IG5lZWRzQ29tbWEgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKHNjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gNCAvKiBKc29uLlN5bnRheEtpbmQuQ2xvc2VCcmFja2V0VG9rZW4gKi8gJiYgc2Nhbm5lci5nZXRUb2tlbigpICE9PSAxNyAvKiBKc29uLlN5bnRheEtpbmQuRU9GICovKSB7XG4gICAgICAgICAgICBpZiAoc2Nhbm5lci5nZXRUb2tlbigpID09PSA1IC8qIEpzb24uU3ludGF4S2luZC5Db21tYVRva2VuICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFuZWVkc0NvbW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIF9lcnJvcih0KCdWYWx1ZSBleHBlY3RlZCcpLCBFcnJvckNvZGUuVmFsdWVFeHBlY3RlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1hT2Zmc2V0ID0gc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpO1xuICAgICAgICAgICAgICAgIF9zY2FuTmV4dCgpOyAvLyBjb25zdW1lIGNvbW1hXG4gICAgICAgICAgICAgICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gNCAvKiBKc29uLlN5bnRheEtpbmQuQ2xvc2VCcmFja2V0VG9rZW4gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5lZWRzQ29tbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lcnJvckF0UmFuZ2UodCgnVHJhaWxpbmcgY29tbWEnKSwgRXJyb3JDb2RlLlRyYWlsaW5nQ29tbWEsIGNvbW1hT2Zmc2V0LCBjb21tYU9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5lZWRzQ29tbWEpIHtcbiAgICAgICAgICAgICAgICBfZXJyb3IodCgnRXhwZWN0ZWQgY29tbWEnKSwgRXJyb3JDb2RlLkNvbW1hRXhwZWN0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXRlbSA9IF9wYXJzZVZhbHVlKG5vZGUpO1xuICAgICAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICAgICAgX2Vycm9yKHQoJ1ZhbHVlIGV4cGVjdGVkJyksIEVycm9yQ29kZS5WYWx1ZUV4cGVjdGVkLCB1bmRlZmluZWQsIFtdLCBbNCAvKiBKc29uLlN5bnRheEtpbmQuQ2xvc2VCcmFja2V0VG9rZW4gKi8sIDUgLyogSnNvbi5TeW50YXhLaW5kLkNvbW1hVG9rZW4gKi9dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUuaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5lZWRzQ29tbWEgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgIT09IDQgLyogSnNvbi5TeW50YXhLaW5kLkNsb3NlQnJhY2tldFRva2VuICovKSB7XG4gICAgICAgICAgICByZXR1cm4gX2Vycm9yKHQoJ0V4cGVjdGVkIGNvbW1hIG9yIGNsb3NpbmcgYnJhY2tldCcpLCBFcnJvckNvZGUuQ29tbWFPckNsb3NlQmFja2V0RXhwZWN0ZWQsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfZmluYWxpemUobm9kZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGNvbnN0IGtleVBsYWNlaG9sZGVyID0gbmV3IFN0cmluZ0FTVE5vZGVJbXBsKHVuZGVmaW5lZCwgMCwgMCk7XG4gICAgZnVuY3Rpb24gX3BhcnNlUHJvcGVydHkocGFyZW50LCBrZXlzU2Vlbikge1xuICAgICAgICBjb25zdCBub2RlID0gbmV3IFByb3BlcnR5QVNUTm9kZUltcGwocGFyZW50LCBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCksIGtleVBsYWNlaG9sZGVyKTtcbiAgICAgICAgbGV0IGtleSA9IF9wYXJzZVN0cmluZyhub2RlKTtcbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgPT09IDE2IC8qIEpzb24uU3ludGF4S2luZC5Vbmtub3duICovKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2l2ZSBhIG1vcmUgaGVscGZ1bCBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICAgICAgX2Vycm9yKHQoJ1Byb3BlcnR5IGtleXMgbXVzdCBiZSBkb3VibGVxdW90ZWQnKSwgRXJyb3JDb2RlLlVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5Tm9kZSA9IG5ldyBTdHJpbmdBU1ROb2RlSW1wbChub2RlLCBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCksIHNjYW5uZXIuZ2V0VG9rZW5MZW5ndGgoKSk7XG4gICAgICAgICAgICAgICAga2V5Tm9kZS52YWx1ZSA9IHNjYW5uZXIuZ2V0VG9rZW5WYWx1ZSgpO1xuICAgICAgICAgICAgICAgIGtleSA9IGtleU5vZGU7XG4gICAgICAgICAgICAgICAgX3NjYW5OZXh0KCk7IC8vIGNvbnN1bWUgVW5rbm93blxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBub2RlLmtleU5vZGUgPSBrZXk7XG4gICAgICAgIC8vIEZvciBKU09OIGZpbGVzIHRoYXQgZm9yYmlkIGNvZGUgY29tbWVudHMsIHRoZXJlIGlzIGEgY29udmVudGlvbiB0byB1c2UgdGhlIGtleSBuYW1lIFwiLy9cIiB0byBhZGQgY29tbWVudHMuXG4gICAgICAgIC8vIE11bHRpcGxlIGluc3RhbmNlcyBvZiBcIi8vXCIgYXJlIG9rYXkuXG4gICAgICAgIGlmIChrZXkudmFsdWUgIT09IFwiLy9cIikge1xuICAgICAgICAgICAgY29uc3Qgc2VlbiA9IGtleXNTZWVuW2tleS52YWx1ZV07XG4gICAgICAgICAgICBpZiAoc2Vlbikge1xuICAgICAgICAgICAgICAgIF9lcnJvckF0UmFuZ2UodChcIkR1cGxpY2F0ZSBvYmplY3Qga2V5XCIpLCBFcnJvckNvZGUuRHVwbGljYXRlS2V5LCBub2RlLmtleU5vZGUub2Zmc2V0LCBub2RlLmtleU5vZGUub2Zmc2V0ICsgbm9kZS5rZXlOb2RlLmxlbmd0aCwgbWFpbi5EaWFnbm9zdGljU2V2ZXJpdHkuV2FybmluZyk7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHNlZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIF9lcnJvckF0UmFuZ2UodChcIkR1cGxpY2F0ZSBvYmplY3Qga2V5XCIpLCBFcnJvckNvZGUuRHVwbGljYXRlS2V5LCBzZWVuLmtleU5vZGUub2Zmc2V0LCBzZWVuLmtleU5vZGUub2Zmc2V0ICsgc2Vlbi5rZXlOb2RlLmxlbmd0aCwgbWFpbi5EaWFnbm9zdGljU2V2ZXJpdHkuV2FybmluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGtleXNTZWVuW2tleS52YWx1ZV0gPSB0cnVlOyAvLyBpZiB0aGUgc2FtZSBrZXkgaXMgZHVwbGljYXRlIGFnYWluLCBhdm9pZCBkdXBsaWNhdGUgZXJyb3IgcmVwb3J0aW5nXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXlzU2VlbltrZXkudmFsdWVdID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Nhbm5lci5nZXRUb2tlbigpID09PSA2IC8qIEpzb24uU3ludGF4S2luZC5Db2xvblRva2VuICovKSB7XG4gICAgICAgICAgICBub2RlLmNvbG9uT2Zmc2V0ID0gc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpO1xuICAgICAgICAgICAgX3NjYW5OZXh0KCk7IC8vIGNvbnN1bWUgQ29sb25Ub2tlblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX2Vycm9yKHQoJ0NvbG9uIGV4cGVjdGVkJyksIEVycm9yQ29kZS5Db2xvbkV4cGVjdGVkKTtcbiAgICAgICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgPT09IDEwIC8qIEpzb24uU3ludGF4S2luZC5TdHJpbmdMaXRlcmFsICovICYmIHRleHREb2N1bWVudC5wb3NpdGlvbkF0KGtleS5vZmZzZXQgKyBrZXkubGVuZ3RoKS5saW5lIDwgdGV4dERvY3VtZW50LnBvc2l0aW9uQXQoc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpKS5saW5lKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5sZW5ndGggPSBrZXkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gX3BhcnNlVmFsdWUobm9kZSk7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfZXJyb3IodCgnVmFsdWUgZXhwZWN0ZWQnKSwgRXJyb3JDb2RlLlZhbHVlRXhwZWN0ZWQsIG5vZGUsIFtdLCBbMiAvKiBKc29uLlN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICovLCA1IC8qIEpzb24uU3ludGF4S2luZC5Db21tYVRva2VuICovXSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS52YWx1ZU5vZGUgPSB2YWx1ZTtcbiAgICAgICAgbm9kZS5sZW5ndGggPSB2YWx1ZS5vZmZzZXQgKyB2YWx1ZS5sZW5ndGggLSBub2RlLm9mZnNldDtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9wYXJzZU9iamVjdChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMSAvKiBKc29uLlN5bnRheEtpbmQuT3BlbkJyYWNlVG9rZW4gKi8pIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBPYmplY3RBU1ROb2RlSW1wbChwYXJlbnQsIHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSk7XG4gICAgICAgIGNvbnN0IGtleXNTZWVuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgX3NjYW5OZXh0KCk7IC8vIGNvbnN1bWUgT3BlbkJyYWNlVG9rZW5cbiAgICAgICAgbGV0IG5lZWRzQ29tbWEgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKHNjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMiAvKiBKc29uLlN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICovICYmIHNjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMTcgLyogSnNvbi5TeW50YXhLaW5kLkVPRiAqLykge1xuICAgICAgICAgICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gNSAvKiBKc29uLlN5bnRheEtpbmQuQ29tbWFUb2tlbiAqLykge1xuICAgICAgICAgICAgICAgIGlmICghbmVlZHNDb21tYSkge1xuICAgICAgICAgICAgICAgICAgICBfZXJyb3IodCgnUHJvcGVydHkgZXhwZWN0ZWQnKSwgRXJyb3JDb2RlLlByb3BlcnR5RXhwZWN0ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb21tYU9mZnNldCA9IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKTtcbiAgICAgICAgICAgICAgICBfc2Nhbk5leHQoKTsgLy8gY29uc3VtZSBjb21tYVxuICAgICAgICAgICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgPT09IDIgLyogSnNvbi5TeW50YXhLaW5kLkNsb3NlQnJhY2VUb2tlbiAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmVlZHNDb21tYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2Vycm9yQXRSYW5nZSh0KCdUcmFpbGluZyBjb21tYScpLCBFcnJvckNvZGUuVHJhaWxpbmdDb21tYSwgY29tbWFPZmZzZXQsIGNvbW1hT2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmVlZHNDb21tYSkge1xuICAgICAgICAgICAgICAgIF9lcnJvcih0KCdFeHBlY3RlZCBjb21tYScpLCBFcnJvckNvZGUuQ29tbWFFeHBlY3RlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IF9wYXJzZVByb3BlcnR5KG5vZGUsIGtleXNTZWVuKTtcbiAgICAgICAgICAgIGlmICghcHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBfZXJyb3IodCgnUHJvcGVydHkgZXhwZWN0ZWQnKSwgRXJyb3JDb2RlLlByb3BlcnR5RXhwZWN0ZWQsIHVuZGVmaW5lZCwgW10sIFsyIC8qIEpzb24uU3ludGF4S2luZC5DbG9zZUJyYWNlVG9rZW4gKi8sIDUgLyogSnNvbi5TeW50YXhLaW5kLkNvbW1hVG9rZW4gKi9dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUucHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5lZWRzQ29tbWEgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgIT09IDIgLyogSnNvbi5TeW50YXhLaW5kLkNsb3NlQnJhY2VUb2tlbiAqLykge1xuICAgICAgICAgICAgcmV0dXJuIF9lcnJvcih0KCdFeHBlY3RlZCBjb21tYSBvciBjbG9zaW5nIGJyYWNlJyksIEVycm9yQ29kZS5Db21tYU9yQ2xvc2VCcmFjZUV4cGVjdGVkLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2ZpbmFsaXplKG5vZGUsIHRydWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfcGFyc2VTdHJpbmcocGFyZW50KSB7XG4gICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgIT09IDEwIC8qIEpzb24uU3ludGF4S2luZC5TdHJpbmdMaXRlcmFsICovKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgU3RyaW5nQVNUTm9kZUltcGwocGFyZW50LCBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkpO1xuICAgICAgICBub2RlLnZhbHVlID0gc2Nhbm5lci5nZXRUb2tlblZhbHVlKCk7XG4gICAgICAgIHJldHVybiBfZmluYWxpemUobm9kZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9wYXJzZU51bWJlcihwYXJlbnQpIHtcbiAgICAgICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMTEgLyogSnNvbi5TeW50YXhLaW5kLk51bWVyaWNMaXRlcmFsICovKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgTnVtYmVyQVNUTm9kZUltcGwocGFyZW50LCBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkpO1xuICAgICAgICBpZiAoc2Nhbm5lci5nZXRUb2tlbkVycm9yKCkgPT09IDAgLyogSnNvbi5TY2FuRXJyb3IuTm9uZSAqLykge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5WYWx1ZSA9IHNjYW5uZXIuZ2V0VG9rZW5WYWx1ZSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBudW1iZXJWYWx1ZSA9IEpTT04ucGFyc2UodG9rZW5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc051bWJlcihudW1iZXJWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9lcnJvcih0KCdJbnZhbGlkIG51bWJlciBmb3JtYXQuJyksIEVycm9yQ29kZS5VbmRlZmluZWQsIG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLnZhbHVlID0gbnVtYmVyVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZXJyb3IodCgnSW52YWxpZCBudW1iZXIgZm9ybWF0LicpLCBFcnJvckNvZGUuVW5kZWZpbmVkLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuaXNJbnRlZ2VyID0gdG9rZW5WYWx1ZS5pbmRleE9mKCcuJykgPT09IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfZmluYWxpemUobm9kZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9wYXJzZUxpdGVyYWwocGFyZW50KSB7XG4gICAgICAgIGxldCBub2RlO1xuICAgICAgICBzd2l0Y2ggKHNjYW5uZXIuZ2V0VG9rZW4oKSkge1xuICAgICAgICAgICAgY2FzZSA3IC8qIEpzb24uU3ludGF4S2luZC5OdWxsS2V5d29yZCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZpbmFsaXplKG5ldyBOdWxsQVNUTm9kZUltcGwocGFyZW50LCBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkpLCB0cnVlKTtcbiAgICAgICAgICAgIGNhc2UgOCAvKiBKc29uLlN5bnRheEtpbmQuVHJ1ZUtleXdvcmQgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9maW5hbGl6ZShuZXcgQm9vbGVhbkFTVE5vZGVJbXBsKHBhcmVudCwgdHJ1ZSwgc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpKSwgdHJ1ZSk7XG4gICAgICAgICAgICBjYXNlIDkgLyogSnNvbi5TeW50YXhLaW5kLkZhbHNlS2V5d29yZCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZpbmFsaXplKG5ldyBCb29sZWFuQVNUTm9kZUltcGwocGFyZW50LCBmYWxzZSwgc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpKSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gX3BhcnNlVmFsdWUocGFyZW50KSB7XG4gICAgICAgIHJldHVybiBfcGFyc2VBcnJheShwYXJlbnQpIHx8IF9wYXJzZU9iamVjdChwYXJlbnQpIHx8IF9wYXJzZVN0cmluZyhwYXJlbnQpIHx8IF9wYXJzZU51bWJlcihwYXJlbnQpIHx8IF9wYXJzZUxpdGVyYWwocGFyZW50KTtcbiAgICB9XG4gICAgbGV0IF9yb290ID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHRva2VuID0gX3NjYW5OZXh0KCk7XG4gICAgaWYgKHRva2VuICE9PSAxNyAvKiBKc29uLlN5bnRheEtpbmQuRU9GICovKSB7XG4gICAgICAgIF9yb290ID0gX3BhcnNlVmFsdWUoX3Jvb3QpO1xuICAgICAgICBpZiAoIV9yb290KSB7XG4gICAgICAgICAgICBfZXJyb3IodCgnRXhwZWN0ZWQgYSBKU09OIG9iamVjdCwgYXJyYXkgb3IgbGl0ZXJhbC4nKSwgRXJyb3JDb2RlLlVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2Nhbm5lci5nZXRUb2tlbigpICE9PSAxNyAvKiBKc29uLlN5bnRheEtpbmQuRU9GICovKSB7XG4gICAgICAgICAgICBfZXJyb3IodCgnRW5kIG9mIGZpbGUgZXhwZWN0ZWQuJyksIEVycm9yQ29kZS5VbmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgSlNPTkRvY3VtZW50KF9yb290LCBwcm9ibGVtcywgY29tbWVudFJhbmdlcyk7XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL2xpYi9lc20vdXRpbHMvanNvbi5qc1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBzdHJpbmdpZnlPYmplY3Qob2JqLCBpbmRlbnQsIHN0cmluZ2lmeUxpdGVyYWwpIHtcbiAgICBpZiAob2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IG5ld0luZGVudCA9IGluZGVudCArICdcXHQnO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICBpZiAob2JqLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnW10nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9ICdbXFxuJztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IG5ld0luZGVudCArIHN0cmluZ2lmeU9iamVjdChvYmpbaV0sIG5ld0luZGVudCwgc3RyaW5naWZ5TGl0ZXJhbCk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCBvYmoubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJywnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gaW5kZW50ICsgJ10nO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICd7fSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gJ3tcXG4nO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gbmV3SW5kZW50ICsgSlNPTi5zdHJpbmdpZnkoa2V5KSArICc6ICcgKyBzdHJpbmdpZnlPYmplY3Qob2JqW2tleV0sIG5ld0luZGVudCwgc3RyaW5naWZ5TGl0ZXJhbCk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCBrZXlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcsJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9IGluZGVudCArICd9JztcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ2lmeUxpdGVyYWwob2JqKTtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2UvbGliL2VzbS9zZXJ2aWNlcy9qc29uQ29tcGxldGlvbi5qc1xuLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgY29uc29sZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzcxNik7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cblxuXG5cblxuY29uc3QgdmFsdWVDb21taXRDaGFyYWN0ZXJzID0gWycsJywgJ30nLCAnXSddO1xuY29uc3QgcHJvcGVydHlDb21taXRDaGFyYWN0ZXJzID0gWyc6J107XG5jbGFzcyBKU09OQ29tcGxldGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc2NoZW1hU2VydmljZSwgY29udHJpYnV0aW9ucyA9IFtdLCBwcm9taXNlQ29uc3RydWN0b3IgPSBQcm9taXNlLCBjbGllbnRDYXBhYmlsaXRpZXMgPSB7fSkge1xuICAgICAgICB0aGlzLnNjaGVtYVNlcnZpY2UgPSBzY2hlbWFTZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbnRyaWJ1dGlvbnMgPSBjb250cmlidXRpb25zO1xuICAgICAgICB0aGlzLnByb21pc2VDb25zdHJ1Y3RvciA9IHByb21pc2VDb25zdHJ1Y3RvcjtcbiAgICAgICAgdGhpcy5jbGllbnRDYXBhYmlsaXRpZXMgPSBjbGllbnRDYXBhYmlsaXRpZXM7XG4gICAgfVxuICAgIGRvUmVzb2x2ZShpdGVtKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmNvbnRyaWJ1dGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVDb21wbGV0aW9uID0gdGhpcy5jb250cmlidXRpb25zW2ldLnJlc29sdmVDb21wbGV0aW9uO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVDb21wbGV0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSByZXNvbHZlQ29tcGxldGlvbihpdGVtKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlQ29uc3RydWN0b3IucmVzb2x2ZShpdGVtKTtcbiAgICB9XG4gICAgZG9Db21wbGV0ZShkb2N1bWVudCwgcG9zaXRpb24sIGRvYykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBpdGVtczogW10sXG4gICAgICAgICAgICBpc0luY29tcGxldGU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRleHQgPSBkb2N1bWVudC5nZXRUZXh0KCk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KHBvc2l0aW9uKTtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2MuZ2V0Tm9kZUZyb21PZmZzZXQob2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMuaXNJbkNvbW1lbnQoZG9jdW1lbnQsIG5vZGUgPyBub2RlLm9mZnNldCA6IDAsIG9mZnNldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSAmJiAob2Zmc2V0ID09PSBub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoKSAmJiBvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjaCA9IHRleHRbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnb2JqZWN0JyAmJiBjaCA9PT0gJ30nIHx8IG5vZGUudHlwZSA9PT0gJ2FycmF5JyAmJiBjaCA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgLy8gYWZ0ZXIgXSBvciB9XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRXb3JkID0gdGhpcy5nZXRDdXJyZW50V29yZChkb2N1bWVudCwgb2Zmc2V0KTtcbiAgICAgICAgbGV0IG92ZXJ3cml0ZVJhbmdlO1xuICAgICAgICBpZiAobm9kZSAmJiAobm9kZS50eXBlID09PSAnc3RyaW5nJyB8fCBub2RlLnR5cGUgPT09ICdudW1iZXInIHx8IG5vZGUudHlwZSA9PT0gJ2Jvb2xlYW4nIHx8IG5vZGUudHlwZSA9PT0gJ251bGwnKSkge1xuICAgICAgICAgICAgb3ZlcndyaXRlUmFuZ2UgPSBtYWluLlJhbmdlLmNyZWF0ZShkb2N1bWVudC5wb3NpdGlvbkF0KG5vZGUub2Zmc2V0KSwgZG9jdW1lbnQucG9zaXRpb25BdChub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgb3ZlcndyaXRlU3RhcnQgPSBvZmZzZXQgLSBjdXJyZW50V29yZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAob3ZlcndyaXRlU3RhcnQgPiAwICYmIHRleHRbb3ZlcndyaXRlU3RhcnQgLSAxXSA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgIG92ZXJ3cml0ZVN0YXJ0LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdmVyd3JpdGVSYW5nZSA9IG1haW4uUmFuZ2UuY3JlYXRlKGRvY3VtZW50LnBvc2l0aW9uQXQob3ZlcndyaXRlU3RhcnQpLCBwb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VwcG9ydHNDb21taXRDaGFyYWN0ZXJzID0gZmFsc2U7IC8vdGhpcy5kb2VzU3VwcG9ydHNDb21taXRDaGFyYWN0ZXJzKCk7IGRpc2FibGVkIGZvciBub3csIHdhaXRpbmcgZm9yIG5ldyBBUEk6IGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvdnNjb2RlL2lzc3Vlcy80MjU0NFxuICAgICAgICBjb25zdCBwcm9wb3NlZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgY29sbGVjdG9yID0ge1xuICAgICAgICAgICAgYWRkOiAoc3VnZ2VzdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBsYWJlbCA9IHN1Z2dlc3Rpb24ubGFiZWw7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBwcm9wb3NlZC5nZXQobGFiZWwpO1xuICAgICAgICAgICAgICAgIGlmICghZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSBsYWJlbC5yZXBsYWNlKC9bXFxuXS9nLCAn4oa1Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbC5sZW5ndGggPiA2MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hvcnRlbmRlZExhYmVsID0gbGFiZWwuc3Vic3RyKDAsIDU3KS50cmltKCkgKyAnLi4uJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJvcG9zZWQuaGFzKHNob3J0ZW5kZWRMYWJlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IHNob3J0ZW5kZWRMYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uLnRleHRFZGl0ID0gbWFpbi5UZXh0RWRpdC5yZXBsYWNlKG92ZXJ3cml0ZVJhbmdlLCBzdWdnZXN0aW9uLmluc2VydFRleHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydHNDb21taXRDaGFyYWN0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uLmNvbW1pdENoYXJhY3RlcnMgPSBzdWdnZXN0aW9uLmtpbmQgPT09IG1haW4uQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5ID8gcHJvcGVydHlDb21taXRDaGFyYWN0ZXJzIDogdmFsdWVDb21taXRDaGFyYWN0ZXJzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN1Z2dlc3Rpb24ubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgcHJvcG9zZWQuc2V0KGxhYmVsLCBzdWdnZXN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lml0ZW1zLnB1c2goc3VnZ2VzdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV4aXN0aW5nLmRvY3VtZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmRvY3VtZW50YXRpb24gPSBzdWdnZXN0aW9uLmRvY3VtZW50YXRpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFleGlzdGluZy5kZXRhaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmRldGFpbCA9IHN1Z2dlc3Rpb24uZGV0YWlsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXhpc3RpbmcubGFiZWxEZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sYWJlbERldGFpbHMgPSBzdWdnZXN0aW9uLmxhYmVsRGV0YWlscztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRBc0luY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXN1bHQuaXNJbmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldE51bWJlck9mUHJvcG9zYWxzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5pdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVtYVNlcnZpY2UuZ2V0U2NoZW1hRm9yUmVzb3VyY2UoZG9jdW1lbnQudXJpLCBkb2MpLnRoZW4oKHNjaGVtYSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvblByb21pc2VzID0gW107XG4gICAgICAgICAgICBsZXQgYWRkVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRLZXkgPSAnJztcbiAgICAgICAgICAgIGxldCBjdXJyZW50UHJvcGVydHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC50eXBlID09PSAncHJvcGVydHknICYmIHBhcmVudC5rZXlOb2RlID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRWYWx1ZSA9ICFwYXJlbnQudmFsdWVOb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb3BlcnR5ID0gcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEtleSA9IHRleHQuc3Vic3RyKG5vZGUub2Zmc2V0ICsgMSwgbm9kZS5sZW5ndGggLSAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHByb3Bvc2FscyBmb3IgcHJvcGVydGllc1xuICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IHN1Z2dlc3Qga2V5cyB3aGVuIHRoZSBjdXJzb3IgaXMganVzdCBiZWZvcmUgdGhlIG9wZW5pbmcgY3VybHkgYnJhY2VcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5vZmZzZXQgPT09IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkb24ndCBzdWdnZXN0IHByb3BlcnRpZXMgdGhhdCBhcmUgYWxyZWFkeSBwcmVzZW50XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IG5vZGUucHJvcGVydGllcztcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2gocCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudFByb3BlcnR5IHx8IGN1cnJlbnRQcm9wZXJ0eSAhPT0gcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcG9zZWQuc2V0KHAua2V5Tm9kZS52YWx1ZSwgbWFpbi5Db21wbGV0aW9uSXRlbS5jcmVhdGUoJ19fJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGV0IHNlcGFyYXRvckFmdGVyID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKGFkZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvckFmdGVyID0gdGhpcy5ldmFsdWF0ZVNlcGFyYXRvckFmdGVyKGRvY3VtZW50LCBkb2N1bWVudC5vZmZzZXRBdChvdmVyd3JpdGVSYW5nZS5lbmQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0eSBwcm9wb3NhbHMgd2l0aCBzY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRQcm9wZXJ0eUNvbXBsZXRpb25zKHNjaGVtYSwgZG9jLCBub2RlLCBhZGRWYWx1ZSwgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0eSBwcm9wb3NhbHMgd2l0aG91dCBzY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRTY2hlbWFMZXNzUHJvcGVydHlDb21wbGV0aW9ucyhkb2MsIG5vZGUsIGN1cnJlbnRLZXksIGNvbGxlY3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0ganNvblBhcnNlcl9nZXROb2RlUGF0aChub2RlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyaWJ1dGlvbnMuZm9yRWFjaCgoY29udHJpYnV0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbGxlY3RQcm9taXNlID0gY29udHJpYnV0aW9uLmNvbGxlY3RQcm9wZXJ0eUNvbXBsZXRpb25zKGRvY3VtZW50LnVyaSwgbG9jYXRpb24sIGN1cnJlbnRXb3JkLCBhZGRWYWx1ZSwgc2VwYXJhdG9yQWZ0ZXIgPT09ICcnLCBjb2xsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sbGVjdFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25Qcm9taXNlcy5wdXNoKGNvbGxlY3RQcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICgoIXNjaGVtYSAmJiBjdXJyZW50V29yZC5sZW5ndGggPiAwICYmIHRleHQuY2hhckF0KG9mZnNldCAtIGN1cnJlbnRXb3JkLmxlbmd0aCAtIDEpICE9PSAnXCInKSkge1xuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0b3IuYWRkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IG1haW4uQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMuZ2V0TGFiZWxGb3JWYWx1ZShjdXJyZW50V29yZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0OiB0aGlzLmdldEluc2VydFRleHRGb3JQcm9wZXJ0eShjdXJyZW50V29yZCwgdW5kZWZpbmVkLCBmYWxzZSwgc2VwYXJhdG9yQWZ0ZXIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogbWFpbi5JbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsIGRvY3VtZW50YXRpb246ICcnLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdG9yLnNldEFzSW5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHByb3Bvc2FscyBmb3IgdmFsdWVzXG4gICAgICAgICAgICBjb25zdCB0eXBlcyA9IHt9O1xuICAgICAgICAgICAgaWYgKHNjaGVtYSkge1xuICAgICAgICAgICAgICAgIC8vIHZhbHVlIHByb3Bvc2FscyB3aXRoIHNjaGVtYVxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0VmFsdWVDb21wbGV0aW9ucyhzY2hlbWEsIGRvYywgbm9kZSwgb2Zmc2V0LCBkb2N1bWVudCwgY29sbGVjdG9yLCB0eXBlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZSBwcm9wb3NhbHMgd2l0aG91dCBzY2hlbWFcbiAgICAgICAgICAgICAgICB0aGlzLmdldFNjaGVtYUxlc3NWYWx1ZUNvbXBsZXRpb25zKGRvYywgbm9kZSwgb2Zmc2V0LCBkb2N1bWVudCwgY29sbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyaWJ1dGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q29udHJpYnV0ZWRWYWx1ZUNvbXBsZXRpb25zKGRvYywgbm9kZSwgb2Zmc2V0LCBkb2N1bWVudCwgY29sbGVjdG9yLCBjb2xsZWN0aW9uUHJvbWlzZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZUNvbnN0cnVjdG9yLmFsbChjb2xsZWN0aW9uUHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0b3IuZ2V0TnVtYmVyT2ZQcm9wb3NhbHMoKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0Rm9yU2VwYXJhdG9yID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSAmJiAobm9kZS50eXBlID09PSAnc3RyaW5nJyB8fCBub2RlLnR5cGUgPT09ICdudW1iZXInIHx8IG5vZGUudHlwZSA9PT0gJ2Jvb2xlYW4nIHx8IG5vZGUudHlwZSA9PT0gJ251bGwnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Rm9yU2VwYXJhdG9yID0gbm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXBhcmF0b3JBZnRlciA9IHRoaXMuZXZhbHVhdGVTZXBhcmF0b3JBZnRlcihkb2N1bWVudCwgb2Zmc2V0Rm9yU2VwYXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRGaWxsZXJWYWx1ZUNvbXBsZXRpb25zKHR5cGVzLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UHJvcGVydHlDb21wbGV0aW9ucyhzY2hlbWEsIGRvYywgbm9kZSwgYWRkVmFsdWUsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdTY2hlbWFzID0gZG9jLmdldE1hdGNoaW5nU2NoZW1hcyhzY2hlbWEuc2NoZW1hLCBub2RlLm9mZnNldCk7XG4gICAgICAgIG1hdGNoaW5nU2NoZW1hcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICBpZiAocy5ub2RlID09PSBub2RlICYmICFzLmludmVydGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hUHJvcGVydGllcyA9IHMuc2NoZW1hLnByb3BlcnRpZXM7XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYVByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc2NoZW1hUHJvcGVydGllcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eVNjaGVtYSA9IHNjaGVtYVByb3BlcnRpZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHlTY2hlbWEgPT09ICdvYmplY3QnICYmICFwcm9wZXJ0eVNjaGVtYS5kZXByZWNhdGlvbk1lc3NhZ2UgJiYgIXByb3BlcnR5U2NoZW1hLmRvTm90U3VnZ2VzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3Bvc2FsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBtYWluLkNvbXBsZXRpb25JdGVtS2luZC5Qcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogdGhpcy5nZXRJbnNlcnRUZXh0Rm9yUHJvcGVydHkoa2V5LCBwcm9wZXJ0eVNjaGVtYSwgYWRkVmFsdWUsIHNlcGFyYXRvckFmdGVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogbWFpbi5JbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlclRleHQ6IHRoaXMuZ2V0RmlsdGVyVGV4dEZvclZhbHVlKGtleSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb246IHRoaXMuZnJvbU1hcmt1cChwcm9wZXJ0eVNjaGVtYS5tYXJrZG93bkRlc2NyaXB0aW9uKSB8fCBwcm9wZXJ0eVNjaGVtYS5kZXNjcmlwdGlvbiB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eVNjaGVtYS5zdWdnZXN0U29ydFRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wb3NhbC5zb3J0VGV4dCA9IHByb3BlcnR5U2NoZW1hLnN1Z2dlc3RTb3J0VGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3Bvc2FsLmluc2VydFRleHQgJiYgZW5kc1dpdGgocHJvcG9zYWwuaW5zZXJ0VGV4dCwgYCQxJHtzZXBhcmF0b3JBZnRlcn1gKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wb3NhbC5jb21tYW5kID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdTdWdnZXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdlZGl0b3IuYWN0aW9uLnRyaWdnZXJTdWdnZXN0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0b3IuYWRkKHByb3Bvc2FsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYVByb3BlcnR5TmFtZXMgPSBzLnNjaGVtYS5wcm9wZXJ0eU5hbWVzO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hUHJvcGVydHlOYW1lcyA9PT0gJ29iamVjdCcgJiYgIXNjaGVtYVByb3BlcnR5TmFtZXMuZGVwcmVjYXRpb25NZXNzYWdlICYmICFzY2hlbWFQcm9wZXJ0eU5hbWVzLmRvTm90U3VnZ2VzdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eU5hbWVDb21wbGV0aW9uSXRlbSA9IChuYW1lLCBlbnVtRGVzY3JpcHRpb24gPSB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3Bvc2FsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IG1haW4uQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydFRleHQ6IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclByb3BlcnR5KG5hbWUsIHVuZGVmaW5lZCwgYWRkVmFsdWUsIHNlcGFyYXRvckFmdGVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBtYWluLkluc2VydFRleHRGb3JtYXQuU25pcHBldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJUZXh0OiB0aGlzLmdldEZpbHRlclRleHRGb3JWYWx1ZShuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uOiBlbnVtRGVzY3JpcHRpb24gfHwgdGhpcy5mcm9tTWFya3VwKHNjaGVtYVByb3BlcnR5TmFtZXMubWFya2Rvd25EZXNjcmlwdGlvbikgfHwgc2NoZW1hUHJvcGVydHlOYW1lcy5kZXNjcmlwdGlvbiB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hUHJvcGVydHlOYW1lcy5zdWdnZXN0U29ydFRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3Bvc2FsLnNvcnRUZXh0ID0gc2NoZW1hUHJvcGVydHlOYW1lcy5zdWdnZXN0U29ydFRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcG9zYWwuaW5zZXJ0VGV4dCAmJiBlbmRzV2l0aChwcm9wb3NhbC5pbnNlcnRUZXh0LCBgJDEke3NlcGFyYXRvckFmdGVyfWApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcG9zYWwuY29tbWFuZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdTdWdnZXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogJ2VkaXRvci5hY3Rpb24udHJpZ2dlclN1Z2dlc3QnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rvci5hZGQocHJvcG9zYWwpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hUHJvcGVydHlOYW1lcy5lbnVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYVByb3BlcnR5TmFtZXMuZW51bS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbnVtRGVzY3JpcHRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtYVByb3BlcnR5TmFtZXMubWFya2Rvd25FbnVtRGVzY3JpcHRpb25zICYmIGkgPCBzY2hlbWFQcm9wZXJ0eU5hbWVzLm1hcmtkb3duRW51bURlc2NyaXB0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bURlc2NyaXB0aW9uID0gdGhpcy5mcm9tTWFya3VwKHNjaGVtYVByb3BlcnR5TmFtZXMubWFya2Rvd25FbnVtRGVzY3JpcHRpb25zW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2NoZW1hUHJvcGVydHlOYW1lcy5lbnVtRGVzY3JpcHRpb25zICYmIGkgPCBzY2hlbWFQcm9wZXJ0eU5hbWVzLmVudW1EZXNjcmlwdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1EZXNjcmlwdGlvbiA9IHNjaGVtYVByb3BlcnR5TmFtZXMuZW51bURlc2NyaXB0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lQ29tcGxldGlvbkl0ZW0oc2NoZW1hUHJvcGVydHlOYW1lcy5lbnVtW2ldLCBlbnVtRGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWFQcm9wZXJ0eU5hbWVzLmNvbnN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWVDb21wbGV0aW9uSXRlbShzY2hlbWFQcm9wZXJ0eU5hbWVzLmNvbnN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFNjaGVtYUxlc3NQcm9wZXJ0eUNvbXBsZXRpb25zKGRvYywgbm9kZSwgY3VycmVudEtleSwgY29sbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IGNvbGxlY3RDb21wbGV0aW9uc0ZvclNpbWlsYXJPYmplY3QgPSAob2JqKSA9PiB7XG4gICAgICAgICAgICBvYmoucHJvcGVydGllcy5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcC5rZXlOb2RlLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbGxlY3Rvci5hZGQoe1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBtYWluLkNvbXBsZXRpb25JdGVtS2luZC5Qcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogdGhpcy5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUoa2V5LCAnJyksXG4gICAgICAgICAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IG1haW4uSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJUZXh0OiB0aGlzLmdldEZpbHRlclRleHRGb3JWYWx1ZShrZXkpLFxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uOiAnJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChub2RlLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50LnR5cGUgPT09ICdwcm9wZXJ0eScpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgb2JqZWN0IGlzIGEgcHJvcGVydHkgdmFsdWUsIGNoZWNrIHRoZSB0cmVlIGZvciBvdGhlciBvYmplY3RzIHRoYXQgaGFuZyB1bmRlciBhIHByb3BlcnR5IG9mIHRoZSBzYW1lIG5hbWVcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRLZXkgPSBub2RlLnBhcmVudC5rZXlOb2RlLnZhbHVlO1xuICAgICAgICAgICAgICAgIGRvYy52aXNpdChuID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4udHlwZSA9PT0gJ3Byb3BlcnR5JyAmJiBuICE9PSBub2RlLnBhcmVudCAmJiBuLmtleU5vZGUudmFsdWUgPT09IHBhcmVudEtleSAmJiBuLnZhbHVlTm9kZSAmJiBuLnZhbHVlTm9kZS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdENvbXBsZXRpb25zRm9yU2ltaWxhck9iamVjdChuLnZhbHVlTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLnBhcmVudC50eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIG9iamVjdCBpcyBpbiBhbiBhcnJheSwgdXNlIGFsbCBvdGhlciBhcnJheSBlbGVtZW50cyBhcyBzaW1pbGFyIG9iamVjdHNcbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudC5pdGVtcy5mb3JFYWNoKG4gPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobi50eXBlID09PSAnb2JqZWN0JyAmJiBuICE9PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0Q29tcGxldGlvbnNGb3JTaW1pbGFyT2JqZWN0KG4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29sbGVjdG9yLmFkZCh7XG4gICAgICAgICAgICAgICAga2luZDogbWFpbi5Db21wbGV0aW9uSXRlbUtpbmQuUHJvcGVydHksXG4gICAgICAgICAgICAgICAgbGFiZWw6ICckc2NoZW1hJyxcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0OiB0aGlzLmdldEluc2VydFRleHRGb3JQcm9wZXJ0eSgnJHNjaGVtYScsIHVuZGVmaW5lZCwgdHJ1ZSwgJycpLFxuICAgICAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IG1haW4uSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LCBkb2N1bWVudGF0aW9uOiAnJyxcbiAgICAgICAgICAgICAgICBmaWx0ZXJUZXh0OiB0aGlzLmdldEZpbHRlclRleHRGb3JWYWx1ZShcIiRzY2hlbWFcIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFNjaGVtYUxlc3NWYWx1ZUNvbXBsZXRpb25zKGRvYywgbm9kZSwgb2Zmc2V0LCBkb2N1bWVudCwgY29sbGVjdG9yKSB7XG4gICAgICAgIGxldCBvZmZzZXRGb3JTZXBhcmF0b3IgPSBvZmZzZXQ7XG4gICAgICAgIGlmIChub2RlICYmIChub2RlLnR5cGUgPT09ICdzdHJpbmcnIHx8IG5vZGUudHlwZSA9PT0gJ251bWJlcicgfHwgbm9kZS50eXBlID09PSAnYm9vbGVhbicgfHwgbm9kZS50eXBlID09PSAnbnVsbCcpKSB7XG4gICAgICAgICAgICBvZmZzZXRGb3JTZXBhcmF0b3IgPSBub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgY29sbGVjdG9yLmFkZCh7XG4gICAgICAgICAgICAgICAga2luZDogdGhpcy5nZXRTdWdnZXN0aW9uS2luZCgnb2JqZWN0JyksXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdFbXB0eSBvYmplY3QnLFxuICAgICAgICAgICAgICAgIGluc2VydFRleHQ6IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKHt9LCAnJyksXG4gICAgICAgICAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogbWFpbi5JbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRhdGlvbjogJydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29sbGVjdG9yLmFkZCh7XG4gICAgICAgICAgICAgICAga2luZDogdGhpcy5nZXRTdWdnZXN0aW9uS2luZCgnYXJyYXknKSxcbiAgICAgICAgICAgICAgICBsYWJlbDogJ0VtcHR5IGFycmF5JyxcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0OiB0aGlzLmdldEluc2VydFRleHRGb3JWYWx1ZShbXSwgJycpLFxuICAgICAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IG1haW4uSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LFxuICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb246ICcnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXBhcmF0b3JBZnRlciA9IHRoaXMuZXZhbHVhdGVTZXBhcmF0b3JBZnRlcihkb2N1bWVudCwgb2Zmc2V0Rm9yU2VwYXJhdG9yKTtcbiAgICAgICAgY29uc3QgY29sbGVjdFN1Z2dlc3Rpb25zRm9yVmFsdWVzID0gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUucGFyZW50ICYmICFqc29uUGFyc2VyX2NvbnRhaW5zKHZhbHVlLnBhcmVudCwgb2Zmc2V0LCB0cnVlKSkge1xuICAgICAgICAgICAgICAgIGNvbGxlY3Rvci5hZGQoe1xuICAgICAgICAgICAgICAgICAgICBraW5kOiB0aGlzLmdldFN1Z2dlc3Rpb25LaW5kKHZhbHVlLnR5cGUpLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogdGhpcy5nZXRMYWJlbFRleHRGb3JNYXRjaGluZ05vZGUodmFsdWUsIGRvY3VtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogdGhpcy5nZXRJbnNlcnRUZXh0Rm9yTWF0Y2hpbmdOb2RlKHZhbHVlLCBkb2N1bWVudCwgc2VwYXJhdG9yQWZ0ZXIpLFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBtYWluLkluc2VydFRleHRGb3JtYXQuU25pcHBldCwgZG9jdW1lbnRhdGlvbjogJydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEJvb2xlYW5WYWx1ZUNvbXBsZXRpb24oIXZhbHVlLnZhbHVlLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ3Byb3BlcnR5Jykge1xuICAgICAgICAgICAgaWYgKG9mZnNldCA+IChub2RlLmNvbG9uT2Zmc2V0IHx8IDApKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVOb2RlID0gbm9kZS52YWx1ZU5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlTm9kZSAmJiAob2Zmc2V0ID4gKHZhbHVlTm9kZS5vZmZzZXQgKyB2YWx1ZU5vZGUubGVuZ3RoKSB8fCB2YWx1ZU5vZGUudHlwZSA9PT0gJ29iamVjdCcgfHwgdmFsdWVOb2RlLnR5cGUgPT09ICdhcnJheScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gc3VnZ2VzdCB2YWx1ZXMgYXQgdGhlIHNhbWUga2V5XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50S2V5ID0gbm9kZS5rZXlOb2RlLnZhbHVlO1xuICAgICAgICAgICAgICAgIGRvYy52aXNpdChuID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4udHlwZSA9PT0gJ3Byb3BlcnR5JyAmJiBuLmtleU5vZGUudmFsdWUgPT09IHBhcmVudEtleSAmJiBuLnZhbHVlTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdFN1Z2dlc3Rpb25zRm9yVmFsdWVzKG4udmFsdWVOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50S2V5ID09PSAnJHNjaGVtYScgJiYgbm9kZS5wYXJlbnQgJiYgIW5vZGUucGFyZW50LnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZERvbGxhclNjaGVtYUNvbXBsZXRpb25zKHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS50eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnQudHlwZSA9PT0gJ3Byb3BlcnR5Jykge1xuICAgICAgICAgICAgICAgIC8vIHN1Z2dlc3QgaXRlbXMgb2YgYW4gYXJyYXkgYXQgdGhlIHNhbWUga2V5XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50S2V5ID0gbm9kZS5wYXJlbnQua2V5Tm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICBkb2MudmlzaXQoKG4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4udHlwZSA9PT0gJ3Byb3BlcnR5JyAmJiBuLmtleU5vZGUudmFsdWUgPT09IHBhcmVudEtleSAmJiBuLnZhbHVlTm9kZSAmJiBuLnZhbHVlTm9kZS50eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuLnZhbHVlTm9kZS5pdGVtcy5mb3JFYWNoKGNvbGxlY3RTdWdnZXN0aW9uc0ZvclZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzdWdnZXN0IGl0ZW1zIGluIHRoZSBzYW1lIGFycmF5XG4gICAgICAgICAgICAgICAgbm9kZS5pdGVtcy5mb3JFYWNoKGNvbGxlY3RTdWdnZXN0aW9uc0ZvclZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VmFsdWVDb21wbGV0aW9ucyhzY2hlbWEsIGRvYywgbm9kZSwgb2Zmc2V0LCBkb2N1bWVudCwgY29sbGVjdG9yLCB0eXBlcykge1xuICAgICAgICBsZXQgb2Zmc2V0Rm9yU2VwYXJhdG9yID0gb2Zmc2V0O1xuICAgICAgICBsZXQgcGFyZW50S2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgdmFsdWVOb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobm9kZSAmJiAobm9kZS50eXBlID09PSAnc3RyaW5nJyB8fCBub2RlLnR5cGUgPT09ICdudW1iZXInIHx8IG5vZGUudHlwZSA9PT0gJ2Jvb2xlYW4nIHx8IG5vZGUudHlwZSA9PT0gJ251bGwnKSkge1xuICAgICAgICAgICAgb2Zmc2V0Rm9yU2VwYXJhdG9yID0gbm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aDtcbiAgICAgICAgICAgIHZhbHVlTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFNjaGVtYVZhbHVlQ29tcGxldGlvbnMoc2NoZW1hLnNjaGVtYSwgJycsIGNvbGxlY3RvciwgdHlwZXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgobm9kZS50eXBlID09PSAncHJvcGVydHknKSAmJiBvZmZzZXQgPiAobm9kZS5jb2xvbk9mZnNldCB8fCAwKSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVOb2RlID0gbm9kZS52YWx1ZU5vZGU7XG4gICAgICAgICAgICBpZiAodmFsdWVOb2RlICYmIG9mZnNldCA+ICh2YWx1ZU5vZGUub2Zmc2V0ICsgdmFsdWVOb2RlLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIHdlIGFyZSBwYXN0IHRoZSB2YWx1ZSBub2RlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnRLZXkgPSBub2RlLmtleU5vZGUudmFsdWU7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgJiYgKHBhcmVudEtleSAhPT0gdW5kZWZpbmVkIHx8IG5vZGUudHlwZSA9PT0gJ2FycmF5JykpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlcGFyYXRvckFmdGVyID0gdGhpcy5ldmFsdWF0ZVNlcGFyYXRvckFmdGVyKGRvY3VtZW50LCBvZmZzZXRGb3JTZXBhcmF0b3IpO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmdTY2hlbWFzID0gZG9jLmdldE1hdGNoaW5nU2NoZW1hcyhzY2hlbWEuc2NoZW1hLCBub2RlLm9mZnNldCwgdmFsdWVOb2RlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcyBvZiBtYXRjaGluZ1NjaGVtYXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocy5ub2RlID09PSBub2RlICYmICFzLmludmVydGVkICYmIHMuc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdhcnJheScgJiYgcy5zY2hlbWEuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjID0gY29sbGVjdG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMuc2NoZW1hLnVuaXF1ZUl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdWYWx1ZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKG4gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobi50eXBlICE9PSAnYXJyYXknICYmIG4udHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nVmFsdWVzLmFkZCh0aGlzLmdldExhYmVsRm9yVmFsdWUoanNvblBhcnNlcl9nZXROb2RlVmFsdWUobikpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNvbGxlY3RvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkKHN1Z2dlc3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXhpc3RpbmdWYWx1ZXMuaGFzKHN1Z2dlc3Rpb24ubGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdG9yLmFkZChzdWdnZXN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzLnNjaGVtYS5pdGVtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZmluZEl0ZW1BdE9mZnNldChub2RlLCBkb2N1bWVudCwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBzLnNjaGVtYS5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWFWYWx1ZUNvbXBsZXRpb25zKHMuc2NoZW1hLml0ZW1zW2luZGV4XSwgc2VwYXJhdG9yQWZ0ZXIsIGMsIHR5cGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFNjaGVtYVZhbHVlQ29tcGxldGlvbnMocy5zY2hlbWEuaXRlbXMsIHNlcGFyYXRvckFmdGVyLCBjLCB0eXBlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudEtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcHJvcGVydHlNYXRjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocy5zY2hlbWEucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5U2NoZW1hID0gcy5zY2hlbWEucHJvcGVydGllc1twYXJlbnRLZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eVNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eU1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFNjaGVtYVZhbHVlQ29tcGxldGlvbnMocHJvcGVydHlTY2hlbWEsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IsIHR5cGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocy5zY2hlbWEucGF0dGVyblByb3BlcnRpZXMgJiYgIXByb3BlcnR5TWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBPYmplY3Qua2V5cyhzLnNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBleHRlbmRlZFJlZ0V4cChwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZ2V4Py50ZXN0KHBhcmVudEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5TWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eVNjaGVtYSA9IHMuc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzW3BhdHRlcm5dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWFWYWx1ZUNvbXBsZXRpb25zKHByb3BlcnR5U2NoZW1hLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yLCB0eXBlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocy5zY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgJiYgIXByb3BlcnR5TWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5U2NoZW1hID0gcy5zY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWFWYWx1ZUNvbXBsZXRpb25zKHByb3BlcnR5U2NoZW1hLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yLCB0eXBlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50S2V5ID09PSAnJHNjaGVtYScgJiYgIW5vZGUucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGREb2xsYXJTY2hlbWFDb21wbGV0aW9ucyhzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlc1snYm9vbGVhbiddKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRCb29sZWFuVmFsdWVDb21wbGV0aW9uKHRydWUsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQm9vbGVhblZhbHVlQ29tcGxldGlvbihmYWxzZSwgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZXNbJ251bGwnXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTnVsbFZhbHVlQ29tcGxldGlvbihzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDb250cmlidXRlZFZhbHVlQ29tcGxldGlvbnMoZG9jLCBub2RlLCBvZmZzZXQsIGRvY3VtZW50LCBjb2xsZWN0b3IsIGNvbGxlY3Rpb25Qcm9taXNlcykge1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29udHJpYnV0aW9ucy5mb3JFYWNoKChjb250cmlidXRpb24pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xsZWN0UHJvbWlzZSA9IGNvbnRyaWJ1dGlvbi5jb2xsZWN0RGVmYXVsdENvbXBsZXRpb25zKGRvY3VtZW50LnVyaSwgY29sbGVjdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sbGVjdFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvblByb21pc2VzLnB1c2goY29sbGVjdFByb21pc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ3N0cmluZycgfHwgbm9kZS50eXBlID09PSAnbnVtYmVyJyB8fCBub2RlLnR5cGUgPT09ICdib29sZWFuJyB8fCBub2RlLnR5cGUgPT09ICdudWxsJykge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlICYmIChub2RlLnR5cGUgPT09ICdwcm9wZXJ0eScpICYmIG9mZnNldCA+IChub2RlLmNvbG9uT2Zmc2V0IHx8IDApKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50S2V5ID0gbm9kZS5rZXlOb2RlLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlTm9kZSA9IG5vZGUudmFsdWVOb2RlO1xuICAgICAgICAgICAgICAgIGlmICgoIXZhbHVlTm9kZSB8fCBvZmZzZXQgPD0gKHZhbHVlTm9kZS5vZmZzZXQgKyB2YWx1ZU5vZGUubGVuZ3RoKSkgJiYgbm9kZS5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSBqc29uUGFyc2VyX2dldE5vZGVQYXRoKG5vZGUucGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250cmlidXRpb25zLmZvckVhY2goKGNvbnRyaWJ1dGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdFByb21pc2UgPSBjb250cmlidXRpb24uY29sbGVjdFZhbHVlQ29tcGxldGlvbnMoZG9jdW1lbnQudXJpLCBsb2NhdGlvbiwgcGFyZW50S2V5LCBjb2xsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbGxlY3RQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvblByb21pc2VzLnB1c2goY29sbGVjdFByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkU2NoZW1hVmFsdWVDb21wbGV0aW9ucyhzY2hlbWEsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IsIHR5cGVzKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5hZGRFbnVtVmFsdWVDb21wbGV0aW9ucyhzY2hlbWEsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpO1xuICAgICAgICAgICAgdGhpcy5hZGREZWZhdWx0VmFsdWVDb21wbGV0aW9ucyhzY2hlbWEsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpO1xuICAgICAgICAgICAgdGhpcy5jb2xsZWN0VHlwZXMoc2NoZW1hLCB0eXBlcyk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuYWxsT2YpKSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hLmFsbE9mLmZvckVhY2gocyA9PiB0aGlzLmFkZFNjaGVtYVZhbHVlQ29tcGxldGlvbnMocywgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3RvciwgdHlwZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5hbnlPZikpIHtcbiAgICAgICAgICAgICAgICBzY2hlbWEuYW55T2YuZm9yRWFjaChzID0+IHRoaXMuYWRkU2NoZW1hVmFsdWVDb21wbGV0aW9ucyhzLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yLCB0eXBlcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLm9uZU9mKSkge1xuICAgICAgICAgICAgICAgIHNjaGVtYS5vbmVPZi5mb3JFYWNoKHMgPT4gdGhpcy5hZGRTY2hlbWFWYWx1ZUNvbXBsZXRpb25zKHMsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IsIHR5cGVzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkRGVmYXVsdFZhbHVlQ29tcGxldGlvbnMoc2NoZW1hLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yLCBhcnJheURlcHRoID0gMCkge1xuICAgICAgICBsZXQgaGFzUHJvcG9zYWxzID0gZmFsc2U7XG4gICAgICAgIGlmIChpc0RlZmluZWQoc2NoZW1hLmRlZmF1bHQpKSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHNjaGVtYS50eXBlO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gc2NoZW1hLmRlZmF1bHQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gYXJyYXlEZXB0aDsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ2FycmF5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRpb25JdGVtID0ge1xuICAgICAgICAgICAgICAgIGtpbmQ6IHRoaXMuZ2V0U3VnZ2VzdGlvbktpbmQodHlwZSksXG4gICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMuZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSksXG4gICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogdGhpcy5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUodmFsdWUsIHNlcGFyYXRvckFmdGVyKSxcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBtYWluLkluc2VydFRleHRGb3JtYXQuU25pcHBldFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvZXNTdXBwb3J0c0xhYmVsRGV0YWlscygpKSB7XG4gICAgICAgICAgICAgICAgY29tcGxldGlvbkl0ZW0ubGFiZWxEZXRhaWxzID0geyBkZXNjcmlwdGlvbjogdCgnRGVmYXVsdCB2YWx1ZScpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0aW9uSXRlbS5kZXRhaWwgPSB0KCdEZWZhdWx0IHZhbHVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2xsZWN0b3IuYWRkKGNvbXBsZXRpb25JdGVtKTtcbiAgICAgICAgICAgIGhhc1Byb3Bvc2FscyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLmV4YW1wbGVzKSkge1xuICAgICAgICAgICAgc2NoZW1hLmV4YW1wbGVzLmZvckVhY2goZXhhbXBsZSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHR5cGUgPSBzY2hlbWEudHlwZTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBleGFtcGxlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBhcnJheURlcHRoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICdhcnJheSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbGxlY3Rvci5hZGQoe1xuICAgICAgICAgICAgICAgICAgICBraW5kOiB0aGlzLmdldFN1Z2dlc3Rpb25LaW5kKHR5cGUpLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogdGhpcy5nZXRMYWJlbEZvclZhbHVlKHZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogdGhpcy5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUodmFsdWUsIHNlcGFyYXRvckFmdGVyKSxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogbWFpbi5JbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBoYXNQcm9wb3NhbHMgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLmRlZmF1bHRTbmlwcGV0cykpIHtcbiAgICAgICAgICAgIHNjaGVtYS5kZWZhdWx0U25pcHBldHMuZm9yRWFjaChzID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdHlwZSA9IHNjaGVtYS50eXBlO1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHMuYm9keTtcbiAgICAgICAgICAgICAgICBsZXQgbGFiZWwgPSBzLmxhYmVsO1xuICAgICAgICAgICAgICAgIGxldCBpbnNlcnRUZXh0O1xuICAgICAgICAgICAgICAgIGxldCBmaWx0ZXJUZXh0O1xuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0eXBlID0gc2NoZW1hLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBhcnJheURlcHRoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ2FycmF5JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0ID0gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yU25pcHBldFZhbHVlKHZhbHVlLCBzZXBhcmF0b3JBZnRlcik7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclRleHQgPSB0aGlzLmdldEZpbHRlclRleHRGb3JTbmlwcGV0VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IGxhYmVsIHx8IHRoaXMuZ2V0TGFiZWxGb3JTbmlwcGV0VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygcy5ib2R5VGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZWZpeCA9ICcnLCBzdWZmaXggPSAnJywgaW5kZW50ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBhcnJheURlcHRoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmaXggPSBwcmVmaXggKyBpbmRlbnQgKyAnW1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWZmaXggPSBzdWZmaXggKyAnXFxuJyArIGluZGVudCArICddJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudCArPSAnXFx0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnYXJyYXknO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluc2VydFRleHQgPSBwcmVmaXggKyBpbmRlbnQgKyBzLmJvZHlUZXh0LnNwbGl0KCdcXG4nKS5qb2luKCdcXG4nICsgaW5kZW50KSArIHN1ZmZpeCArIHNlcGFyYXRvckFmdGVyO1xuICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IGxhYmVsIHx8IGluc2VydFRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJUZXh0ID0gaW5zZXJ0VGV4dC5yZXBsYWNlKC9bXFxuXS9nLCAnJyk7IC8vIHJlbW92ZSBuZXcgbGluZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29sbGVjdG9yLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IHRoaXMuZ2V0U3VnZ2VzdGlvbktpbmQodHlwZSksXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uOiB0aGlzLmZyb21NYXJrdXAocy5tYXJrZG93bkRlc2NyaXB0aW9uKSB8fCBzLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0LFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBtYWluLkluc2VydFRleHRGb3JtYXQuU25pcHBldCxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyVGV4dFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGhhc1Byb3Bvc2FscyA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc1Byb3Bvc2FscyAmJiB0eXBlb2Ygc2NoZW1hLml0ZW1zID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShzY2hlbWEuaXRlbXMpICYmIGFycmF5RGVwdGggPCA1IC8qIGJld2FyZSBvZiByZWN1cnNpb24gKi8pIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGVmYXVsdFZhbHVlQ29tcGxldGlvbnMoc2NoZW1hLml0ZW1zLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yLCBhcnJheURlcHRoICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkRW51bVZhbHVlQ29tcGxldGlvbnMoc2NoZW1hLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKSB7XG4gICAgICAgIGlmIChpc0RlZmluZWQoc2NoZW1hLmNvbnN0KSkge1xuICAgICAgICAgICAgY29sbGVjdG9yLmFkZCh7XG4gICAgICAgICAgICAgICAga2luZDogdGhpcy5nZXRTdWdnZXN0aW9uS2luZChzY2hlbWEudHlwZSksXG4gICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMuZ2V0TGFiZWxGb3JWYWx1ZShzY2hlbWEuY29uc3QpLFxuICAgICAgICAgICAgICAgIGluc2VydFRleHQ6IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKHNjaGVtYS5jb25zdCwgc2VwYXJhdG9yQWZ0ZXIpLFxuICAgICAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IG1haW4uSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LFxuICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb246IHRoaXMuZnJvbU1hcmt1cChzY2hlbWEubWFya2Rvd25EZXNjcmlwdGlvbikgfHwgc2NoZW1hLmRlc2NyaXB0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuZW51bSkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBzY2hlbWEuZW51bS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVubSA9IHNjaGVtYS5lbnVtW2ldO1xuICAgICAgICAgICAgICAgIGxldCBkb2N1bWVudGF0aW9uID0gdGhpcy5mcm9tTWFya3VwKHNjaGVtYS5tYXJrZG93bkRlc2NyaXB0aW9uKSB8fCBzY2hlbWEuZGVzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYS5tYXJrZG93bkVudW1EZXNjcmlwdGlvbnMgJiYgaSA8IHNjaGVtYS5tYXJrZG93bkVudW1EZXNjcmlwdGlvbnMubGVuZ3RoICYmIHRoaXMuZG9lc1N1cHBvcnRNYXJrZG93bigpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb24gPSB0aGlzLmZyb21NYXJrdXAoc2NoZW1hLm1hcmtkb3duRW51bURlc2NyaXB0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjaGVtYS5lbnVtRGVzY3JpcHRpb25zICYmIGkgPCBzY2hlbWEuZW51bURlc2NyaXB0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRhdGlvbiA9IHNjaGVtYS5lbnVtRGVzY3JpcHRpb25zW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2xsZWN0b3IuYWRkKHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogdGhpcy5nZXRTdWdnZXN0aW9uS2luZChzY2hlbWEudHlwZSksXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiB0aGlzLmdldExhYmVsRm9yVmFsdWUoZW5tKSxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogdGhpcy5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUoZW5tLCBzZXBhcmF0b3JBZnRlciksXG4gICAgICAgICAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IG1haW4uSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LFxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29sbGVjdFR5cGVzKHNjaGVtYSwgdHlwZXMpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLmVudW0pIHx8IGlzRGVmaW5lZChzY2hlbWEuY29uc3QpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZSA9IHNjaGVtYS50eXBlO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgICAgICAgdHlwZS5mb3JFYWNoKHQgPT4gdHlwZXNbdF0gPSB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlKSB7XG4gICAgICAgICAgICB0eXBlc1t0eXBlXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkRmlsbGVyVmFsdWVDb21wbGV0aW9ucyh0eXBlcywgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3Rvcikge1xuICAgICAgICBpZiAodHlwZXNbJ29iamVjdCddKSB7XG4gICAgICAgICAgICBjb2xsZWN0b3IuYWRkKHtcbiAgICAgICAgICAgICAgICBraW5kOiB0aGlzLmdldFN1Z2dlc3Rpb25LaW5kKCdvYmplY3QnKSxcbiAgICAgICAgICAgICAgICBsYWJlbDogJ3t9JyxcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0OiB0aGlzLmdldEluc2VydFRleHRGb3JHdWVzc2VkVmFsdWUoe30sIHNlcGFyYXRvckFmdGVyKSxcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBtYWluLkluc2VydFRleHRGb3JtYXQuU25pcHBldCxcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHQoJ05ldyBvYmplY3QnKSxcbiAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uOiAnJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVzWydhcnJheSddKSB7XG4gICAgICAgICAgICBjb2xsZWN0b3IuYWRkKHtcbiAgICAgICAgICAgICAgICBraW5kOiB0aGlzLmdldFN1Z2dlc3Rpb25LaW5kKCdhcnJheScpLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnW10nLFxuICAgICAgICAgICAgICAgIGluc2VydFRleHQ6IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvckd1ZXNzZWRWYWx1ZShbXSwgc2VwYXJhdG9yQWZ0ZXIpLFxuICAgICAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IG1haW4uSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LFxuICAgICAgICAgICAgICAgIGRldGFpbDogdCgnTmV3IGFycmF5JyksXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRhdGlvbjogJydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEJvb2xlYW5WYWx1ZUNvbXBsZXRpb24odmFsdWUsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpIHtcbiAgICAgICAgY29sbGVjdG9yLmFkZCh7XG4gICAgICAgICAgICBraW5kOiB0aGlzLmdldFN1Z2dlc3Rpb25LaW5kKCdib29sZWFuJyksXG4gICAgICAgICAgICBsYWJlbDogdmFsdWUgPyAndHJ1ZScgOiAnZmFsc2UnLFxuICAgICAgICAgICAgaW5zZXJ0VGV4dDogdGhpcy5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUodmFsdWUsIHNlcGFyYXRvckFmdGVyKSxcbiAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IG1haW4uSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LFxuICAgICAgICAgICAgZG9jdW1lbnRhdGlvbjogJydcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZE51bGxWYWx1ZUNvbXBsZXRpb24oc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3Rvcikge1xuICAgICAgICBjb2xsZWN0b3IuYWRkKHtcbiAgICAgICAgICAgIGtpbmQ6IHRoaXMuZ2V0U3VnZ2VzdGlvbktpbmQoJ251bGwnKSxcbiAgICAgICAgICAgIGxhYmVsOiAnbnVsbCcsXG4gICAgICAgICAgICBpbnNlcnRUZXh0OiAnbnVsbCcgKyBzZXBhcmF0b3JBZnRlcixcbiAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IG1haW4uSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LFxuICAgICAgICAgICAgZG9jdW1lbnRhdGlvbjogJydcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZERvbGxhclNjaGVtYUNvbXBsZXRpb25zKHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hSWRzID0gdGhpcy5zY2hlbWFTZXJ2aWNlLmdldFJlZ2lzdGVyZWRTY2hlbWFJZHMoc2NoZW1hID0+IHNjaGVtYSA9PT0gJ2h0dHAnIHx8IHNjaGVtYSA9PT0gJ2h0dHBzJyk7XG4gICAgICAgIHNjaGVtYUlkcy5mb3JFYWNoKHNjaGVtYUlkID0+IGNvbGxlY3Rvci5hZGQoe1xuICAgICAgICAgICAga2luZDogbWFpbi5Db21wbGV0aW9uSXRlbUtpbmQuTW9kdWxlLFxuICAgICAgICAgICAgbGFiZWw6IHRoaXMuZ2V0TGFiZWxGb3JWYWx1ZShzY2hlbWFJZCksXG4gICAgICAgICAgICBmaWx0ZXJUZXh0OiB0aGlzLmdldEZpbHRlclRleHRGb3JWYWx1ZShzY2hlbWFJZCksXG4gICAgICAgICAgICBpbnNlcnRUZXh0OiB0aGlzLmdldEluc2VydFRleHRGb3JWYWx1ZShzY2hlbWFJZCwgc2VwYXJhdG9yQWZ0ZXIpLFxuICAgICAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogbWFpbi5JbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsIGRvY3VtZW50YXRpb246ICcnXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIH1cbiAgICBnZXRWYWx1ZUZyb21MYWJlbCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIGdldEZpbHRlclRleHRGb3JWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIH1cbiAgICBnZXRGaWx0ZXJUZXh0Rm9yU25pcHBldFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXFwkXFx7XFxkKzooW159XSspXFx9fFxcJFxcZCsvZywgJyQxJyk7XG4gICAgfVxuICAgIGdldExhYmVsRm9yU25pcHBldFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICByZXR1cm4gbGFiZWwucmVwbGFjZSgvXFwkXFx7XFxkKzooW159XSspXFx9fFxcJFxcZCsvZywgJyQxJyk7XG4gICAgfVxuICAgIGdldEluc2VydFRleHRGb3JQbGFpblRleHQodGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9bXFxcXFxcJFxcfV0vZywgJ1xcXFwkJicpOyAvLyBlc2NhcGUgJCwgXFwgYW5kIH1cbiAgICB9XG4gICAgZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKHZhbHVlLCBzZXBhcmF0b3JBZnRlcikge1xuICAgICAgICBjb25zdCB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkodmFsdWUsIG51bGwsICdcXHQnKTtcbiAgICAgICAgaWYgKHRleHQgPT09ICd7fScpIHtcbiAgICAgICAgICAgIHJldHVybiAneyQxfScgKyBzZXBhcmF0b3JBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0ZXh0ID09PSAnW10nKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1skMV0nICsgc2VwYXJhdG9yQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclBsYWluVGV4dCh0ZXh0ICsgc2VwYXJhdG9yQWZ0ZXIpO1xuICAgIH1cbiAgICBnZXRJbnNlcnRUZXh0Rm9yU25pcHBldFZhbHVlKHZhbHVlLCBzZXBhcmF0b3JBZnRlcikge1xuICAgICAgICBjb25zdCByZXBsYWNlciA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVbMF0gPT09ICdeJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3QodmFsdWUsICcnLCByZXBsYWNlcikgKyBzZXBhcmF0b3JBZnRlcjtcbiAgICB9XG4gICAgZ2V0SW5zZXJ0VGV4dEZvckd1ZXNzZWRWYWx1ZSh2YWx1ZSwgc2VwYXJhdG9yQWZ0ZXIpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJHsxOm51bGx9JyArIHNlcGFyYXRvckFmdGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUodmFsdWUsIHNlcGFyYXRvckFmdGVyKTtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgbGV0IHNuaXBwZXRWYWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBzbmlwcGV0VmFsdWUgPSBzbmlwcGV0VmFsdWUuc3Vic3RyKDEsIHNuaXBwZXRWYWx1ZS5sZW5ndGggLSAyKTsgLy8gcmVtb3ZlIHF1b3Rlc1xuICAgICAgICAgICAgICAgIHNuaXBwZXRWYWx1ZSA9IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclBsYWluVGV4dChzbmlwcGV0VmFsdWUpOyAvLyBlc2NhcGUgXFwgYW5kIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJ1wiJHsxOicgKyBzbmlwcGV0VmFsdWUgKyAnfVwiJyArIHNlcGFyYXRvckFmdGVyO1xuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgIHJldHVybiAnJHsxOicgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnfScgKyBzZXBhcmF0b3JBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUodmFsdWUsIHNlcGFyYXRvckFmdGVyKTtcbiAgICB9XG4gICAgZ2V0U3VnZ2VzdGlvbktpbmQodHlwZSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgICAgICAgY29uc3QgYXJyYXkgPSB0eXBlO1xuICAgICAgICAgICAgdHlwZSA9IGFycmF5Lmxlbmd0aCA+IDAgPyBhcnJheVswXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWluLkNvbXBsZXRpb25JdGVtS2luZC5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6IHJldHVybiBtYWluLkNvbXBsZXRpb25JdGVtS2luZC5WYWx1ZTtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6IHJldHVybiBtYWluLkNvbXBsZXRpb25JdGVtS2luZC5Nb2R1bGU7XG4gICAgICAgICAgICBjYXNlICdwcm9wZXJ0eSc6IHJldHVybiBtYWluLkNvbXBsZXRpb25JdGVtS2luZC5Qcm9wZXJ0eTtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBtYWluLkNvbXBsZXRpb25JdGVtS2luZC5WYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRMYWJlbFRleHRGb3JNYXRjaGluZ05vZGUobm9kZSwgZG9jdW1lbnQpIHtcbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1tdJztcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd7fSc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5nZXRUZXh0KCkuc3Vic3RyKG5vZGUub2Zmc2V0LCBub2RlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0SW5zZXJ0VGV4dEZvck1hdGNoaW5nTm9kZShub2RlLCBkb2N1bWVudCwgc2VwYXJhdG9yQWZ0ZXIpIHtcbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUoW10sIHNlcGFyYXRvckFmdGVyKTtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKHt9LCBzZXBhcmF0b3JBZnRlcik7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5nZXRUZXh0KCkuc3Vic3RyKG5vZGUub2Zmc2V0LCBub2RlLmxlbmd0aCkgKyBzZXBhcmF0b3JBZnRlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yUGxhaW5UZXh0KGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEluc2VydFRleHRGb3JQcm9wZXJ0eShrZXksIHByb3BlcnR5U2NoZW1hLCBhZGRWYWx1ZSwgc2VwYXJhdG9yQWZ0ZXIpIHtcbiAgICAgICAgY29uc3QgcHJvcGVydHlUZXh0ID0gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUoa2V5LCAnJyk7XG4gICAgICAgIGlmICghYWRkVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eVRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0VGV4dCA9IHByb3BlcnR5VGV4dCArICc6ICc7XG4gICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgbGV0IG5WYWx1ZVByb3Bvc2FscyA9IDA7XG4gICAgICAgIGlmIChwcm9wZXJ0eVNjaGVtYSkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcGVydHlTY2hlbWEuZGVmYXVsdFNuaXBwZXRzKSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eVNjaGVtYS5kZWZhdWx0U25pcHBldHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBwcm9wZXJ0eVNjaGVtYS5kZWZhdWx0U25pcHBldHNbMF0uYm9keTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChib2R5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldEluc2VydFRleHRGb3JTbmlwcGV0VmFsdWUoYm9keSwgJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5WYWx1ZVByb3Bvc2FscyArPSBwcm9wZXJ0eVNjaGVtYS5kZWZhdWx0U25pcHBldHMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3BlcnR5U2NoZW1hLmVudW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlICYmIHByb3BlcnR5U2NoZW1hLmVudW0ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yR3Vlc3NlZFZhbHVlKHByb3BlcnR5U2NoZW1hLmVudW1bMF0sICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgblZhbHVlUHJvcG9zYWxzICs9IHByb3BlcnR5U2NoZW1hLmVudW0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChwcm9wZXJ0eVNjaGVtYS5jb25zdCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yR3Vlc3NlZFZhbHVlKHByb3BlcnR5U2NoZW1hLmNvbnN0LCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5WYWx1ZVByb3Bvc2FscysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChwcm9wZXJ0eVNjaGVtYS5kZWZhdWx0KSkge1xuICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldEluc2VydFRleHRGb3JHdWVzc2VkVmFsdWUocHJvcGVydHlTY2hlbWEuZGVmYXVsdCwgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuVmFsdWVQcm9wb3NhbHMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BlcnR5U2NoZW1hLmV4YW1wbGVzKSAmJiBwcm9wZXJ0eVNjaGVtYS5leGFtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yR3Vlc3NlZFZhbHVlKHByb3BlcnR5U2NoZW1hLmV4YW1wbGVzWzBdLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5WYWx1ZVByb3Bvc2FscyArPSBwcm9wZXJ0eVNjaGVtYS5leGFtcGxlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoblZhbHVlUHJvcG9zYWxzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHR5cGUgPSBBcnJheS5pc0FycmF5KHByb3BlcnR5U2NoZW1hLnR5cGUpID8gcHJvcGVydHlTY2hlbWEudHlwZVswXSA6IHByb3BlcnR5U2NoZW1hLnR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eVNjaGVtYS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ29iamVjdCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcGVydHlTY2hlbWEuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnYXJyYXknO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJyQxJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnXCIkMVwiJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAneyQxfSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnWyQxXSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaW50ZWdlcic6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICckezE6MH0nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnJHsxOm51bGx9JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5VGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWx1ZSB8fCBuVmFsdWVQcm9wb3NhbHMgPiAxKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICckMSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFRleHQgKyB2YWx1ZSArIHNlcGFyYXRvckFmdGVyO1xuICAgIH1cbiAgICBnZXRDdXJyZW50V29yZChkb2N1bWVudCwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBpID0gb2Zmc2V0IC0gMTtcbiAgICAgICAgY29uc3QgdGV4dCA9IGRvY3VtZW50LmdldFRleHQoKTtcbiAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiAnIFxcdFxcblxcclxcdlwiOntbLF19Jy5pbmRleE9mKHRleHQuY2hhckF0KGkpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dC5zdWJzdHJpbmcoaSArIDEsIG9mZnNldCk7XG4gICAgfVxuICAgIGV2YWx1YXRlU2VwYXJhdG9yQWZ0ZXIoZG9jdW1lbnQsIG9mZnNldCkge1xuICAgICAgICBjb25zdCBzY2FubmVyID0gbWFpbl9jcmVhdGVTY2FubmVyKGRvY3VtZW50LmdldFRleHQoKSwgdHJ1ZSk7XG4gICAgICAgIHNjYW5uZXIuc2V0UG9zaXRpb24ob2Zmc2V0KTtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBzY2FubmVyLnNjYW4oKTtcbiAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAgICAgY2FzZSA1IC8qIEpzb24uU3ludGF4S2luZC5Db21tYVRva2VuICovOlxuICAgICAgICAgICAgY2FzZSAyIC8qIEpzb24uU3ludGF4S2luZC5DbG9zZUJyYWNlVG9rZW4gKi86XG4gICAgICAgICAgICBjYXNlIDQgLyogSnNvbi5TeW50YXhLaW5kLkNsb3NlQnJhY2tldFRva2VuICovOlxuICAgICAgICAgICAgY2FzZSAxNyAvKiBKc29uLlN5bnRheEtpbmQuRU9GICovOlxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICcsJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kSXRlbUF0T2Zmc2V0KG5vZGUsIGRvY3VtZW50LCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3Qgc2Nhbm5lciA9IG1haW5fY3JlYXRlU2Nhbm5lcihkb2N1bWVudC5nZXRUZXh0KCksIHRydWUpO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuaXRlbXM7XG4gICAgICAgIGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPiBjaGlsZC5vZmZzZXQgKyBjaGlsZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzY2FubmVyLnNldFBvc2l0aW9uKGNoaWxkLm9mZnNldCArIGNoaWxkLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW4gPSBzY2FubmVyLnNjYW4oKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IDUgLyogSnNvbi5TeW50YXhLaW5kLkNvbW1hVG9rZW4gKi8gJiYgb2Zmc2V0ID49IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSArIHNjYW5uZXIuZ2V0VG9rZW5MZW5ndGgoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob2Zmc2V0ID49IGNoaWxkLm9mZnNldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpc0luQ29tbWVudChkb2N1bWVudCwgc3RhcnQsIG9mZnNldCkge1xuICAgICAgICBjb25zdCBzY2FubmVyID0gbWFpbl9jcmVhdGVTY2FubmVyKGRvY3VtZW50LmdldFRleHQoKSwgZmFsc2UpO1xuICAgICAgICBzY2FubmVyLnNldFBvc2l0aW9uKHN0YXJ0KTtcbiAgICAgICAgbGV0IHRva2VuID0gc2Nhbm5lci5zY2FuKCk7XG4gICAgICAgIHdoaWxlICh0b2tlbiAhPT0gMTcgLyogSnNvbi5TeW50YXhLaW5kLkVPRiAqLyAmJiAoc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpICsgc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpIDwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgdG9rZW4gPSBzY2FubmVyLnNjYW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRva2VuID09PSAxMiAvKiBKc29uLlN5bnRheEtpbmQuTGluZUNvbW1lbnRUcml2aWEgKi8gfHwgdG9rZW4gPT09IDEzIC8qIEpzb24uU3ludGF4S2luZC5CbG9ja0NvbW1lbnRUcml2aWEgKi8pICYmIHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSA8PSBvZmZzZXQ7XG4gICAgfVxuICAgIGZyb21NYXJrdXAobWFya3VwU3RyaW5nKSB7XG4gICAgICAgIGlmIChtYXJrdXBTdHJpbmcgJiYgdGhpcy5kb2VzU3VwcG9ydE1hcmtkb3duKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2luZDogbWFpbi5NYXJrdXBLaW5kLk1hcmtkb3duLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBtYXJrdXBTdHJpbmdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZG9lc1N1cHBvcnRNYXJrZG93bigpIHtcbiAgICAgICAgaWYgKCFpc0RlZmluZWQodGhpcy5zdXBwb3J0c01hcmtkb3duKSkge1xuICAgICAgICAgICAgY29uc3QgZG9jdW1lbnRhdGlvbkZvcm1hdCA9IHRoaXMuY2xpZW50Q2FwYWJpbGl0aWVzLnRleHREb2N1bWVudD8uY29tcGxldGlvbj8uY29tcGxldGlvbkl0ZW0/LmRvY3VtZW50YXRpb25Gb3JtYXQ7XG4gICAgICAgICAgICB0aGlzLnN1cHBvcnRzTWFya2Rvd24gPSBBcnJheS5pc0FycmF5KGRvY3VtZW50YXRpb25Gb3JtYXQpICYmIGRvY3VtZW50YXRpb25Gb3JtYXQuaW5kZXhPZihtYWluLk1hcmt1cEtpbmQuTWFya2Rvd24pICE9PSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdXBwb3J0c01hcmtkb3duO1xuICAgIH1cbiAgICBkb2VzU3VwcG9ydHNDb21taXRDaGFyYWN0ZXJzKCkge1xuICAgICAgICBpZiAoIWlzRGVmaW5lZCh0aGlzLnN1cHBvcnRzQ29tbWl0Q2hhcmFjdGVycykpIHtcbiAgICAgICAgICAgIHRoaXMubGFiZWxEZXRhaWxzU3VwcG9ydCA9IHRoaXMuY2xpZW50Q2FwYWJpbGl0aWVzLnRleHREb2N1bWVudD8uY29tcGxldGlvbj8uY29tcGxldGlvbkl0ZW0/LmNvbW1pdENoYXJhY3RlcnNTdXBwb3J0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN1cHBvcnRzQ29tbWl0Q2hhcmFjdGVycztcbiAgICB9XG4gICAgZG9lc1N1cHBvcnRzTGFiZWxEZXRhaWxzKCkge1xuICAgICAgICBpZiAoIWlzRGVmaW5lZCh0aGlzLmxhYmVsRGV0YWlsc1N1cHBvcnQpKSB7XG4gICAgICAgICAgICB0aGlzLmxhYmVsRGV0YWlsc1N1cHBvcnQgPSB0aGlzLmNsaWVudENhcGFiaWxpdGllcy50ZXh0RG9jdW1lbnQ/LmNvbXBsZXRpb24/LmNvbXBsZXRpb25JdGVtPy5sYWJlbERldGFpbHNTdXBwb3J0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVsRGV0YWlsc1N1cHBvcnQ7XG4gICAgfVxufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL3NlcnZpY2VzL2pzb25Ib3Zlci5qc1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuY2xhc3MgSlNPTkhvdmVyIHtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWFTZXJ2aWNlLCBjb250cmlidXRpb25zID0gW10sIHByb21pc2VDb25zdHJ1Y3Rvcikge1xuICAgICAgICB0aGlzLnNjaGVtYVNlcnZpY2UgPSBzY2hlbWFTZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbnRyaWJ1dGlvbnMgPSBjb250cmlidXRpb25zO1xuICAgICAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlQ29uc3RydWN0b3IgfHwgUHJvbWlzZTtcbiAgICB9XG4gICAgZG9Ib3Zlcihkb2N1bWVudCwgcG9zaXRpb24sIGRvYykge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBkb2N1bWVudC5vZmZzZXRBdChwb3NpdGlvbik7XG4gICAgICAgIGxldCBub2RlID0gZG9jLmdldE5vZGVGcm9tT2Zmc2V0KG9mZnNldCk7XG4gICAgICAgIGlmICghbm9kZSB8fCAobm9kZS50eXBlID09PSAnb2JqZWN0JyB8fCBub2RlLnR5cGUgPT09ICdhcnJheScpICYmIG9mZnNldCA+IG5vZGUub2Zmc2V0ICsgMSAmJiBvZmZzZXQgPCBub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhvdmVyUmFuZ2VOb2RlID0gbm9kZTtcbiAgICAgICAgLy8gdXNlIHRoZSBwcm9wZXJ0eSBkZXNjcmlwdGlvbiB3aGVuIGhvdmVyaW5nIG92ZXIgYW4gb2JqZWN0IGtleVxuICAgICAgICBpZiAobm9kZS50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC50eXBlID09PSAncHJvcGVydHknICYmIHBhcmVudC5rZXlOb2RlID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudC52YWx1ZU5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaG92ZXJSYW5nZSA9IG1haW4uUmFuZ2UuY3JlYXRlKGRvY3VtZW50LnBvc2l0aW9uQXQoaG92ZXJSYW5nZU5vZGUub2Zmc2V0KSwgZG9jdW1lbnQucG9zaXRpb25BdChob3ZlclJhbmdlTm9kZS5vZmZzZXQgKyBob3ZlclJhbmdlTm9kZS5sZW5ndGgpKTtcbiAgICAgICAgY29uc3QgY3JlYXRlSG92ZXIgPSAoY29udGVudHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBjb250ZW50czogY29udGVudHMsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IGhvdmVyUmFuZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IGpzb25QYXJzZXJfZ2V0Tm9kZVBhdGgobm9kZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmNvbnRyaWJ1dGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyaWJ1dGlvbiA9IHRoaXMuY29udHJpYnV0aW9uc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBjb250cmlidXRpb24uZ2V0SW5mb0NvbnRyaWJ1dGlvbihkb2N1bWVudC51cmksIGxvY2F0aW9uKTtcbiAgICAgICAgICAgIGlmIChwcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihodG1sQ29udGVudCA9PiBjcmVhdGVIb3ZlcihodG1sQ29udGVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVtYVNlcnZpY2UuZ2V0U2NoZW1hRm9yUmVzb3VyY2UoZG9jdW1lbnQudXJpLCBkb2MpLnRoZW4oKHNjaGVtYSkgPT4ge1xuICAgICAgICAgICAgaWYgKHNjaGVtYSAmJiBub2RlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmdTY2hlbWFzID0gZG9jLmdldE1hdGNoaW5nU2NoZW1hcyhzY2hlbWEuc2NoZW1hLCBub2RlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgbGV0IHRpdGxlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGxldCBtYXJrZG93bkRlc2NyaXB0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGxldCBtYXJrZG93bkVudW1WYWx1ZURlc2NyaXB0aW9uID0gdW5kZWZpbmVkLCBlbnVtVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbWF0Y2hpbmdTY2hlbWFzLmV2ZXJ5KChzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLm5vZGUgPT09IG5vZGUgJiYgIXMuaW52ZXJ0ZWQgJiYgcy5zY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlID0gdGl0bGUgfHwgcy5zY2hlbWEudGl0bGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrZG93bkRlc2NyaXB0aW9uID0gbWFya2Rvd25EZXNjcmlwdGlvbiB8fCBzLnNjaGVtYS5tYXJrZG93bkRlc2NyaXB0aW9uIHx8IHRvTWFya2Rvd24ocy5zY2hlbWEuZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMuc2NoZW1hLmVudW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpZHggPSBzLnNjaGVtYS5lbnVtLmluZGV4T2YoanNvblBhcnNlcl9nZXROb2RlVmFsdWUobm9kZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzLnNjaGVtYS5tYXJrZG93bkVudW1EZXNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya2Rvd25FbnVtVmFsdWVEZXNjcmlwdGlvbiA9IHMuc2NoZW1hLm1hcmtkb3duRW51bURlc2NyaXB0aW9uc1tpZHhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzLnNjaGVtYS5lbnVtRGVzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtkb3duRW51bVZhbHVlRGVzY3JpcHRpb24gPSB0b01hcmtkb3duKHMuc2NoZW1hLmVudW1EZXNjcmlwdGlvbnNbaWR4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXJrZG93bkVudW1WYWx1ZURlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1WYWx1ZSA9IHMuc2NoZW1hLmVudW1baWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnVtVmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtVmFsdWUgPSBKU09OLnN0cmluZ2lmeShlbnVtVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAodGl0bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdG9NYXJrZG93bih0aXRsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXJrZG93bkRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxuXFxuXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IG1hcmtkb3duRGVzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXJrZG93bkVudW1WYWx1ZURlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxuXFxuXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGBcXGAke3RvTWFya2Rvd25Db2RlQmxvY2soZW51bVZhbHVlKX1cXGA6ICR7bWFya2Rvd25FbnVtVmFsdWVEZXNjcmlwdGlvbn1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSG92ZXIoW3Jlc3VsdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvTWFya2Rvd24ocGxhaW4pIHtcbiAgICBpZiAocGxhaW4pIHtcbiAgICAgICAgY29uc3QgcmVzID0gcGxhaW4ucmVwbGFjZSgvKFteXFxuXFxyXSkoXFxyP1xcbikoW15cXG5cXHJdKS9nbSwgJyQxXFxuXFxuJDMnKTsgLy8gc2luZ2xlIG5ldyBsaW5lcyB0byBcXG5cXG4gKE1hcmtkb3duIHBhcmFncmFwaClcbiAgICAgICAgcmV0dXJuIHJlcy5yZXBsYWNlKC9bXFxcXGAqX3t9W1xcXSgpIytcXC0uIV0vZywgXCJcXFxcJCZcIik7IC8vIGVzY2FwZSBtYXJrZG93biBzeW50YXggdG9rZW5zOiBodHRwOi8vZGFyaW5nZmlyZWJhbGwubmV0L3Byb2plY3RzL21hcmtkb3duL3N5bnRheCNiYWNrc2xhc2hcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHRvTWFya2Rvd25Db2RlQmxvY2soY29udGVudCkge1xuICAgIC8vIHNlZSBodHRwczovL2RhcmluZ2ZpcmViYWxsLm5ldC9wcm9qZWN0cy9tYXJrZG93bi9zeW50YXgjcHJlY29kZVxuICAgIGlmIChjb250ZW50LmluZGV4T2YoJ2AnKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuICdgYCAnICsgY29udGVudCArICcgYGAnO1xuICAgIH1cbiAgICByZXR1cm4gY29udGVudDtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2UvbGliL2VzbS9zZXJ2aWNlcy9qc29uVmFsaWRhdGlvbi5qc1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXG5jbGFzcyBKU09OVmFsaWRhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoanNvblNjaGVtYVNlcnZpY2UsIHByb21pc2VDb25zdHJ1Y3Rvcikge1xuICAgICAgICB0aGlzLmpzb25TY2hlbWFTZXJ2aWNlID0ganNvblNjaGVtYVNlcnZpY2U7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2VDb25zdHJ1Y3RvcjtcbiAgICAgICAgdGhpcy52YWxpZGF0aW9uRW5hYmxlZCA9IHRydWU7XG4gICAgfVxuICAgIGNvbmZpZ3VyZShyYXcpIHtcbiAgICAgICAgaWYgKHJhdykge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0aW9uRW5hYmxlZCA9IHJhdy52YWxpZGF0ZSAhPT0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmNvbW1lbnRTZXZlcml0eSA9IHJhdy5hbGxvd0NvbW1lbnRzID8gdW5kZWZpbmVkIDogbWFpbi5EaWFnbm9zdGljU2V2ZXJpdHkuRXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZG9WYWxpZGF0aW9uKHRleHREb2N1bWVudCwganNvbkRvY3VtZW50LCBkb2N1bWVudFNldHRpbmdzLCBzY2hlbWEpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkYXRpb25FbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlLnJlc29sdmUoW10pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpYWdub3N0aWNzID0gW107XG4gICAgICAgIGNvbnN0IGFkZGVkID0ge307XG4gICAgICAgIGNvbnN0IGFkZFByb2JsZW0gPSAocHJvYmxlbSkgPT4ge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGR1cGxpY2F0ZWQgbWVzc2FnZXNcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHByb2JsZW0ucmFuZ2Uuc3RhcnQubGluZSArICcgJyArIHByb2JsZW0ucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyICsgJyAnICsgcHJvYmxlbS5tZXNzYWdlO1xuICAgICAgICAgICAgaWYgKCFhZGRlZFtzaWduYXR1cmVdKSB7XG4gICAgICAgICAgICAgICAgYWRkZWRbc2lnbmF0dXJlXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZGlhZ25vc3RpY3MucHVzaChwcm9ibGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZ2V0RGlhZ25vc3RpY3MgPSAoc2NoZW1hKSA9PiB7XG4gICAgICAgICAgICBsZXQgdHJhaWxpbmdDb21tYVNldmVyaXR5ID0gZG9jdW1lbnRTZXR0aW5ncz8udHJhaWxpbmdDb21tYXMgPyB0b0RpYWdub3N0aWNTZXZlcml0eShkb2N1bWVudFNldHRpbmdzLnRyYWlsaW5nQ29tbWFzKSA6IG1haW4uRGlhZ25vc3RpY1NldmVyaXR5LkVycm9yO1xuICAgICAgICAgICAgbGV0IGNvbW1lbnRTZXZlcml0eSA9IGRvY3VtZW50U2V0dGluZ3M/LmNvbW1lbnRzID8gdG9EaWFnbm9zdGljU2V2ZXJpdHkoZG9jdW1lbnRTZXR0aW5ncy5jb21tZW50cykgOiB0aGlzLmNvbW1lbnRTZXZlcml0eTtcbiAgICAgICAgICAgIGxldCBzY2hlbWFWYWxpZGF0aW9uID0gZG9jdW1lbnRTZXR0aW5ncz8uc2NoZW1hVmFsaWRhdGlvbiA/IHRvRGlhZ25vc3RpY1NldmVyaXR5KGRvY3VtZW50U2V0dGluZ3Muc2NoZW1hVmFsaWRhdGlvbikgOiBtYWluLkRpYWdub3N0aWNTZXZlcml0eS5XYXJuaW5nO1xuICAgICAgICAgICAgbGV0IHNjaGVtYVJlcXVlc3QgPSBkb2N1bWVudFNldHRpbmdzPy5zY2hlbWFSZXF1ZXN0ID8gdG9EaWFnbm9zdGljU2V2ZXJpdHkoZG9jdW1lbnRTZXR0aW5ncy5zY2hlbWFSZXF1ZXN0KSA6IG1haW4uRGlhZ25vc3RpY1NldmVyaXR5Lldhcm5pbmc7XG4gICAgICAgICAgICBpZiAoc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRkU2NoZW1hUHJvYmxlbSA9IChlcnJvck1lc3NhZ2UsIGVycm9yQ29kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoanNvbkRvY3VtZW50LnJvb3QgJiYgc2NoZW1hUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXN0Um9vdCA9IGpzb25Eb2N1bWVudC5yb290O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHkgPSBhc3RSb290LnR5cGUgPT09ICdvYmplY3QnID8gYXN0Um9vdC5wcm9wZXJ0aWVzWzBdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmtleU5vZGUudmFsdWUgPT09ICckc2NoZW1hJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBwcm9wZXJ0eS52YWx1ZU5vZGUgfHwgcHJvcGVydHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBtYWluLlJhbmdlLmNyZWF0ZSh0ZXh0RG9jdW1lbnQucG9zaXRpb25BdChub2RlLm9mZnNldCksIHRleHREb2N1bWVudC5wb3NpdGlvbkF0KG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRQcm9ibGVtKG1haW4uRGlhZ25vc3RpYy5jcmVhdGUocmFuZ2UsIGVycm9yTWVzc2FnZSwgc2NoZW1hUmVxdWVzdCwgZXJyb3JDb2RlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IG1haW4uUmFuZ2UuY3JlYXRlKHRleHREb2N1bWVudC5wb3NpdGlvbkF0KGFzdFJvb3Qub2Zmc2V0KSwgdGV4dERvY3VtZW50LnBvc2l0aW9uQXQoYXN0Um9vdC5vZmZzZXQgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUHJvYmxlbShtYWluLkRpYWdub3N0aWMuY3JlYXRlKHJhbmdlLCBlcnJvck1lc3NhZ2UsIHNjaGVtYVJlcXVlc3QsIGVycm9yQ29kZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU2NoZW1hUHJvYmxlbShzY2hlbWEuZXJyb3JzWzBdLCBFcnJvckNvZGUuU2NoZW1hUmVzb2x2ZUVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2NoZW1hVmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHdhcm5pbmcgb2Ygc2NoZW1hLndhcm5pbmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRTY2hlbWFQcm9ibGVtKHdhcm5pbmcsIEVycm9yQ29kZS5TY2hlbWFVbnN1cHBvcnRlZEZlYXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbWFudGljRXJyb3JzID0ganNvbkRvY3VtZW50LnZhbGlkYXRlKHRleHREb2N1bWVudCwgc2NoZW1hLnNjaGVtYSwgc2NoZW1hVmFsaWRhdGlvbiwgZG9jdW1lbnRTZXR0aW5ncz8uc2NoZW1hRHJhZnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VtYW50aWNFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbWFudGljRXJyb3JzLmZvckVhY2goYWRkUHJvYmxlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYUFsbG93c0NvbW1lbnRzKHNjaGVtYS5zY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnRTZXZlcml0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYUFsbG93c1RyYWlsaW5nQ29tbWFzKHNjaGVtYS5zY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nQ29tbWFTZXZlcml0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YganNvbkRvY3VtZW50LnN5bnRheEVycm9ycykge1xuICAgICAgICAgICAgICAgIGlmIChwLmNvZGUgPT09IEVycm9yQ29kZS5UcmFpbGluZ0NvbW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdHJhaWxpbmdDb21tYVNldmVyaXR5ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcC5zZXZlcml0eSA9IHRyYWlsaW5nQ29tbWFTZXZlcml0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkUHJvYmxlbShwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29tbWVudFNldmVyaXR5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0KCdDb21tZW50cyBhcmUgbm90IHBlcm1pdHRlZCBpbiBKU09OLicpO1xuICAgICAgICAgICAgICAgIGpzb25Eb2N1bWVudC5jb21tZW50cy5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhZGRQcm9ibGVtKG1haW4uRGlhZ25vc3RpYy5jcmVhdGUoYywgbWVzc2FnZSwgY29tbWVudFNldmVyaXR5LCBFcnJvckNvZGUuQ29tbWVudE5vdFBlcm1pdHRlZCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRpYWdub3N0aWNzO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoc2NoZW1hKSB7XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBzY2hlbWEuaWQgfHwgKCdzY2hlbWFzZXJ2aWNlOi8vdW50aXRsZWQvJyArIGlkQ291bnRlcisrKTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IHRoaXMuanNvblNjaGVtYVNlcnZpY2UucmVnaXN0ZXJFeHRlcm5hbFNjaGVtYSh7IHVyaSwgc2NoZW1hIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZS5nZXRSZXNvbHZlZFNjaGVtYSgpLnRoZW4ocmVzb2x2ZWRTY2hlbWEgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXREaWFnbm9zdGljcyhyZXNvbHZlZFNjaGVtYSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5qc29uU2NoZW1hU2VydmljZS5nZXRTY2hlbWFGb3JSZXNvdXJjZSh0ZXh0RG9jdW1lbnQudXJpLCBqc29uRG9jdW1lbnQpLnRoZW4oc2NoZW1hID0+IHtcbiAgICAgICAgICAgIHJldHVybiBnZXREaWFnbm9zdGljcyhzY2hlbWEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0TGFuZ3VhZ2VTdGF0dXModGV4dERvY3VtZW50LCBqc29uRG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHsgc2NoZW1hczogdGhpcy5qc29uU2NoZW1hU2VydmljZS5nZXRTY2hlbWFVUklzRm9yUmVzb3VyY2UodGV4dERvY3VtZW50LnVyaSwganNvbkRvY3VtZW50KSB9O1xuICAgIH1cbn1cbmxldCBpZENvdW50ZXIgPSAwO1xuZnVuY3Rpb24gc2NoZW1hQWxsb3dzQ29tbWVudHMoc2NoZW1hUmVmKSB7XG4gICAgaWYgKHNjaGVtYVJlZiAmJiB0eXBlb2Ygc2NoZW1hUmVmID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoaXNCb29sZWFuKHNjaGVtYVJlZi5hbGxvd0NvbW1lbnRzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYVJlZi5hbGxvd0NvbW1lbnRzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWFSZWYuYWxsT2YpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2NoZW1hIG9mIHNjaGVtYVJlZi5hbGxPZikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFsbG93ID0gc2NoZW1hQWxsb3dzQ29tbWVudHMoc2NoZW1hKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNCb29sZWFuKGFsbG93KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWxsb3c7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBzY2hlbWFBbGxvd3NUcmFpbGluZ0NvbW1hcyhzY2hlbWFSZWYpIHtcbiAgICBpZiAoc2NoZW1hUmVmICYmIHR5cGVvZiBzY2hlbWFSZWYgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChpc0Jvb2xlYW4oc2NoZW1hUmVmLmFsbG93VHJhaWxpbmdDb21tYXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hUmVmLmFsbG93VHJhaWxpbmdDb21tYXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVwclNjaGVtYVJlZiA9IHNjaGVtYVJlZjtcbiAgICAgICAgaWYgKGlzQm9vbGVhbihkZXByU2NoZW1hUmVmWydhbGxvd3NUcmFpbGluZ0NvbW1hcyddKSkgeyAvLyBkZXByZWNhdGVkXG4gICAgICAgICAgICByZXR1cm4gZGVwclNjaGVtYVJlZlsnYWxsb3dzVHJhaWxpbmdDb21tYXMnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hUmVmLmFsbE9mKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNjaGVtYSBvZiBzY2hlbWFSZWYuYWxsT2YpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxvdyA9IHNjaGVtYUFsbG93c1RyYWlsaW5nQ29tbWFzKHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzQm9vbGVhbihhbGxvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFsbG93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gdG9EaWFnbm9zdGljU2V2ZXJpdHkoc2V2ZXJpdHlMZXZlbCkge1xuICAgIHN3aXRjaCAoc2V2ZXJpdHlMZXZlbCkge1xuICAgICAgICBjYXNlICdlcnJvcic6IHJldHVybiBtYWluLkRpYWdub3N0aWNTZXZlcml0eS5FcnJvcjtcbiAgICAgICAgY2FzZSAnd2FybmluZyc6IHJldHVybiBtYWluLkRpYWdub3N0aWNTZXZlcml0eS5XYXJuaW5nO1xuICAgICAgICBjYXNlICdpZ25vcmUnOiByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL3V0aWxzL2NvbG9ycy5qc1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5jb25zdCBEaWdpdDAgPSA0ODtcbmNvbnN0IERpZ2l0OSA9IDU3O1xuY29uc3QgQSA9IDY1O1xuY29uc3QgYSA9IDk3O1xuY29uc3QgZiA9IDEwMjtcbmZ1bmN0aW9uIGhleERpZ2l0KGNoYXJDb2RlKSB7XG4gICAgaWYgKGNoYXJDb2RlIDwgRGlnaXQwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoY2hhckNvZGUgPD0gRGlnaXQ5KSB7XG4gICAgICAgIHJldHVybiBjaGFyQ29kZSAtIERpZ2l0MDtcbiAgICB9XG4gICAgaWYgKGNoYXJDb2RlIDwgYSkge1xuICAgICAgICBjaGFyQ29kZSArPSAoYSAtIEEpO1xuICAgIH1cbiAgICBpZiAoY2hhckNvZGUgPj0gYSAmJiBjaGFyQ29kZSA8PSBmKSB7XG4gICAgICAgIHJldHVybiBjaGFyQ29kZSAtIGEgKyAxMDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBjb2xvckZyb21IZXgodGV4dCkge1xuICAgIGlmICh0ZXh0WzBdICE9PSAnIycpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc3dpdGNoICh0ZXh0Lmxlbmd0aCkge1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlZDogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgxKSkgKiAweDExKSAvIDI1NS4wLFxuICAgICAgICAgICAgICAgIGdyZWVuOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDIpKSAqIDB4MTEpIC8gMjU1LjAsXG4gICAgICAgICAgICAgICAgYmx1ZTogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgzKSkgKiAweDExKSAvIDI1NS4wLFxuICAgICAgICAgICAgICAgIGFscGhhOiAxXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlZDogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgxKSkgKiAweDExKSAvIDI1NS4wLFxuICAgICAgICAgICAgICAgIGdyZWVuOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDIpKSAqIDB4MTEpIC8gMjU1LjAsXG4gICAgICAgICAgICAgICAgYmx1ZTogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgzKSkgKiAweDExKSAvIDI1NS4wLFxuICAgICAgICAgICAgICAgIGFscGhhOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDQpKSAqIDB4MTEpIC8gMjU1LjAsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlZDogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgxKSkgKiAweDEwICsgaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDIpKSkgLyAyNTUuMCxcbiAgICAgICAgICAgICAgICBncmVlbjogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgzKSkgKiAweDEwICsgaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDQpKSkgLyAyNTUuMCxcbiAgICAgICAgICAgICAgICBibHVlOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDUpKSAqIDB4MTAgKyBoZXhEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoNikpKSAvIDI1NS4wLFxuICAgICAgICAgICAgICAgIGFscGhhOiAxXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlZDogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgxKSkgKiAweDEwICsgaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDIpKSkgLyAyNTUuMCxcbiAgICAgICAgICAgICAgICBncmVlbjogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgzKSkgKiAweDEwICsgaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDQpKSkgLyAyNTUuMCxcbiAgICAgICAgICAgICAgICBibHVlOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDUpKSAqIDB4MTAgKyBoZXhEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoNikpKSAvIDI1NS4wLFxuICAgICAgICAgICAgICAgIGFscGhhOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDcpKSAqIDB4MTAgKyBoZXhEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoOCkpKSAvIDI1NS4wXG4gICAgICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gY29sb3JGcm9tMjU2UkdCKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhID0gMS4wKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVkOiByZWQgLyAyNTUuMCxcbiAgICAgICAgZ3JlZW46IGdyZWVuIC8gMjU1LjAsXG4gICAgICAgIGJsdWU6IGJsdWUgLyAyNTUuMCxcbiAgICAgICAgYWxwaGFcbiAgICB9O1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL3NlcnZpY2VzL2pzb25Eb2N1bWVudFN5bWJvbHMuanNcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblxuXG5cbmNsYXNzIEpTT05Eb2N1bWVudFN5bWJvbHMge1xuICAgIGNvbnN0cnVjdG9yKHNjaGVtYVNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5zY2hlbWFTZXJ2aWNlID0gc2NoZW1hU2VydmljZTtcbiAgICB9XG4gICAgZmluZERvY3VtZW50U3ltYm9scyhkb2N1bWVudCwgZG9jLCBjb250ZXh0ID0geyByZXN1bHRMaW1pdDogTnVtYmVyLk1BWF9WQUxVRSB9KSB7XG4gICAgICAgIGNvbnN0IHJvb3QgPSBkb2Mucm9vdDtcbiAgICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxpbWl0ID0gY29udGV4dC5yZXN1bHRMaW1pdCB8fCBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAvLyBzcGVjaWFsIGhhbmRsaW5nIGZvciBrZXkgYmluZGluZ3NcbiAgICAgICAgY29uc3QgcmVzb3VyY2VTdHJpbmcgPSBkb2N1bWVudC51cmk7XG4gICAgICAgIGlmICgocmVzb3VyY2VTdHJpbmcgPT09ICd2c2NvZGU6Ly9kZWZhdWx0c2V0dGluZ3Mva2V5YmluZGluZ3MuanNvbicpIHx8IGVuZHNXaXRoKHJlc291cmNlU3RyaW5nLnRvTG93ZXJDYXNlKCksICcvdXNlci9rZXliaW5kaW5ncy5qc29uJykpIHtcbiAgICAgICAgICAgIGlmIChyb290LnR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygcm9vdC5pdGVtcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBpdGVtLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkua2V5Tm9kZS52YWx1ZSA9PT0gJ2tleScgJiYgcHJvcGVydHkudmFsdWVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gbWFpbi5Mb2NhdGlvbi5jcmVhdGUoZG9jdW1lbnQudXJpLCBnZXRSYW5nZShkb2N1bWVudCwgaXRlbSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IG5hbWU6IGdldE5hbWUocHJvcGVydHkudmFsdWVOb2RlKSwga2luZDogbWFpbi5TeW1ib2xLaW5kLkZ1bmN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW1pdCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Lm9uUmVzdWx0TGltaXRFeGNlZWRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25SZXN1bHRMaW1pdEV4Y2VlZGVkKHJlc291cmNlU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b1Zpc2l0ID0gW1xuICAgICAgICAgICAgeyBub2RlOiByb290LCBjb250YWluZXJOYW1lOiAnJyB9XG4gICAgICAgIF07XG4gICAgICAgIGxldCBuZXh0VG9WaXNpdCA9IDA7XG4gICAgICAgIGxldCBsaW1pdEV4Y2VlZGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBjb25zdCBjb2xsZWN0T3V0bGluZUVudHJpZXMgPSAobm9kZSwgY29udGFpbmVyTmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgIG5vZGUuaXRlbXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvVmlzaXQucHVzaCh7IG5vZGUsIGNvbnRhaW5lck5hbWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBub2RlLnByb3BlcnRpZXMuZm9yRWFjaCgocHJvcGVydHkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVOb2RlID0gcHJvcGVydHkudmFsdWVOb2RlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGltaXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGltaXQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IG1haW4uTG9jYXRpb24uY3JlYXRlKGRvY3VtZW50LnVyaSwgZ2V0UmFuZ2UoZG9jdW1lbnQsIHByb3BlcnR5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRDb250YWluZXJOYW1lID0gY29udGFpbmVyTmFtZSA/IGNvbnRhaW5lck5hbWUgKyAnLicgKyBwcm9wZXJ0eS5rZXlOb2RlLnZhbHVlIDogcHJvcGVydHkua2V5Tm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IG5hbWU6IHRoaXMuZ2V0S2V5TGFiZWwocHJvcGVydHkpLCBraW5kOiB0aGlzLmdldFN5bWJvbEtpbmQodmFsdWVOb2RlLnR5cGUpLCBsb2NhdGlvbjogbG9jYXRpb24sIGNvbnRhaW5lck5hbWU6IGNvbnRhaW5lck5hbWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9WaXNpdC5wdXNoKHsgbm9kZTogdmFsdWVOb2RlLCBjb250YWluZXJOYW1lOiBjaGlsZENvbnRhaW5lck5hbWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW1pdEV4Y2VlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBicmVhdGggZmlyc3QgdHJhdmVyc2FsXG4gICAgICAgIHdoaWxlIChuZXh0VG9WaXNpdCA8IHRvVmlzaXQubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gdG9WaXNpdFtuZXh0VG9WaXNpdCsrXTtcbiAgICAgICAgICAgIGNvbGxlY3RPdXRsaW5lRW50cmllcyhuZXh0Lm5vZGUsIG5leHQuY29udGFpbmVyTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbWl0RXhjZWVkZWQgJiYgY29udGV4dCAmJiBjb250ZXh0Lm9uUmVzdWx0TGltaXRFeGNlZWRlZCkge1xuICAgICAgICAgICAgY29udGV4dC5vblJlc3VsdExpbWl0RXhjZWVkZWQocmVzb3VyY2VTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZpbmREb2N1bWVudFN5bWJvbHMyKGRvY3VtZW50LCBkb2MsIGNvbnRleHQgPSB7IHJlc3VsdExpbWl0OiBOdW1iZXIuTUFYX1ZBTFVFIH0pIHtcbiAgICAgICAgY29uc3Qgcm9vdCA9IGRvYy5yb290O1xuICAgICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGltaXQgPSBjb250ZXh0LnJlc3VsdExpbWl0IHx8IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIC8vIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGtleSBiaW5kaW5nc1xuICAgICAgICBjb25zdCByZXNvdXJjZVN0cmluZyA9IGRvY3VtZW50LnVyaTtcbiAgICAgICAgaWYgKChyZXNvdXJjZVN0cmluZyA9PT0gJ3ZzY29kZTovL2RlZmF1bHRzZXR0aW5ncy9rZXliaW5kaW5ncy5qc29uJykgfHwgZW5kc1dpdGgocmVzb3VyY2VTdHJpbmcudG9Mb3dlckNhc2UoKSwgJy91c2VyL2tleWJpbmRpbmdzLmpzb24nKSkge1xuICAgICAgICAgICAgaWYgKHJvb3QudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiByb290Lml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIGl0ZW0ucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eS5rZXlOb2RlLnZhbHVlID09PSAna2V5JyAmJiBwcm9wZXJ0eS52YWx1ZU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBnZXRSYW5nZShkb2N1bWVudCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvblJhbmdlID0gZ2V0UmFuZ2UoZG9jdW1lbnQsIHByb3BlcnR5LmtleU5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IG5hbWU6IGdldE5hbWUocHJvcGVydHkudmFsdWVOb2RlKSwga2luZDogbWFpbi5TeW1ib2xLaW5kLkZ1bmN0aW9uLCByYW5nZSwgc2VsZWN0aW9uUmFuZ2UgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW1pdCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Lm9uUmVzdWx0TGltaXRFeGNlZWRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25SZXN1bHRMaW1pdEV4Y2VlZGVkKHJlc291cmNlU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgY29uc3QgdG9WaXNpdCA9IFtcbiAgICAgICAgICAgIHsgbm9kZTogcm9vdCwgcmVzdWx0IH1cbiAgICAgICAgXTtcbiAgICAgICAgbGV0IG5leHRUb1Zpc2l0ID0gMDtcbiAgICAgICAgbGV0IGxpbWl0RXhjZWVkZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY29sbGVjdE91dGxpbmVFbnRyaWVzID0gKG5vZGUsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgIG5vZGUuaXRlbXMuZm9yRWFjaCgobm9kZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW1pdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW1pdC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gZ2V0UmFuZ2UoZG9jdW1lbnQsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvblJhbmdlID0gcmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IFN0cmluZyhpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ltYm9sID0geyBuYW1lLCBraW5kOiB0aGlzLmdldFN5bWJvbEtpbmQobm9kZS50eXBlKSwgcmFuZ2UsIHNlbGVjdGlvblJhbmdlLCBjaGlsZHJlbjogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvVmlzaXQucHVzaCh7IHJlc3VsdDogc3ltYm9sLmNoaWxkcmVuLCBub2RlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGltaXRFeGNlZWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBub2RlLnByb3BlcnRpZXMuZm9yRWFjaCgocHJvcGVydHkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVOb2RlID0gcHJvcGVydHkudmFsdWVOb2RlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGltaXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGltaXQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IGdldFJhbmdlKGRvY3VtZW50LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uUmFuZ2UgPSBnZXRSYW5nZShkb2N1bWVudCwgcHJvcGVydHkua2V5Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzeW1ib2wgPSB7IG5hbWU6IHRoaXMuZ2V0S2V5TGFiZWwocHJvcGVydHkpLCBraW5kOiB0aGlzLmdldFN5bWJvbEtpbmQodmFsdWVOb2RlLnR5cGUpLCByYW5nZSwgc2VsZWN0aW9uUmFuZ2UsIGNoaWxkcmVuLCBkZXRhaWw6IHRoaXMuZ2V0RGV0YWlsKHZhbHVlTm9kZSkgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvVmlzaXQucHVzaCh7IHJlc3VsdDogY2hpbGRyZW4sIG5vZGU6IHZhbHVlTm9kZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0RXhjZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIGJyZWF0aCBmaXJzdCB0cmF2ZXJzYWxcbiAgICAgICAgd2hpbGUgKG5leHRUb1Zpc2l0IDwgdG9WaXNpdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSB0b1Zpc2l0W25leHRUb1Zpc2l0KytdO1xuICAgICAgICAgICAgY29sbGVjdE91dGxpbmVFbnRyaWVzKG5leHQubm9kZSwgbmV4dC5yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW1pdEV4Y2VlZGVkICYmIGNvbnRleHQgJiYgY29udGV4dC5vblJlc3VsdExpbWl0RXhjZWVkZWQpIHtcbiAgICAgICAgICAgIGNvbnRleHQub25SZXN1bHRMaW1pdEV4Y2VlZGVkKHJlc291cmNlU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBnZXRTeW1ib2xLaW5kKG5vZGVUeXBlKSB7XG4gICAgICAgIHN3aXRjaCAobm9kZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1haW4uU3ltYm9sS2luZC5Nb2R1bGU7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIHJldHVybiBtYWluLlN5bWJvbEtpbmQuU3RyaW5nO1xuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFpbi5TeW1ib2xLaW5kLk51bWJlcjtcbiAgICAgICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFpbi5TeW1ib2xLaW5kLkFycmF5O1xuICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1haW4uU3ltYm9sS2luZC5Cb29sZWFuO1xuICAgICAgICAgICAgZGVmYXVsdDogLy8gJ251bGwnXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1haW4uU3ltYm9sS2luZC5WYXJpYWJsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRLZXlMYWJlbChwcm9wZXJ0eSkge1xuICAgICAgICBsZXQgbmFtZSA9IHByb3BlcnR5LmtleU5vZGUudmFsdWU7XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC9bXFxuXS9nLCAn4oa1Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgJiYgbmFtZS50cmltKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgXCIke25hbWV9XCJgO1xuICAgIH1cbiAgICBnZXREZXRhaWwobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2Jvb2xlYW4nIHx8IG5vZGUudHlwZSA9PT0gJ251bWJlcicgfHwgbm9kZS50eXBlID09PSAnbnVsbCcgfHwgbm9kZS50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhub2RlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5sZW5ndGggPyB1bmRlZmluZWQgOiAnW10nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLmxlbmd0aCA/IHVuZGVmaW5lZCA6ICd7fSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZmluZERvY3VtZW50Q29sb3JzKGRvY3VtZW50LCBkb2MsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NoZW1hU2VydmljZS5nZXRTY2hlbWFGb3JSZXNvdXJjZShkb2N1bWVudC51cmksIGRvYykudGhlbihzY2hlbWEgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBpZiAoc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxpbWl0ID0gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5yZXN1bHRMaW1pdCA9PT0gJ251bWJlcicgPyBjb250ZXh0LnJlc3VsdExpbWl0IDogTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGluZ1NjaGVtYXMgPSBkb2MuZ2V0TWF0Y2hpbmdTY2hlbWFzKHNjaGVtYS5zY2hlbWEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpc2l0ZWROb2RlID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzIG9mIG1hdGNoaW5nU2NoZW1hcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXMuaW52ZXJ0ZWQgJiYgcy5zY2hlbWEgJiYgKHMuc2NoZW1hLmZvcm1hdCA9PT0gJ2NvbG9yJyB8fCBzLnNjaGVtYS5mb3JtYXQgPT09ICdjb2xvci1oZXgnKSAmJiBzLm5vZGUgJiYgcy5ub2RlLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlSWQgPSBTdHJpbmcocy5ub2RlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWROb2RlW25vZGVJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IGNvbG9yRnJvbUhleChqc29uUGFyc2VyX2dldE5vZGVWYWx1ZShzLm5vZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBnZXRSYW5nZShkb2N1bWVudCwgcy5ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBjb2xvciwgcmFuZ2UgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0ZWROb2RlW25vZGVJZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5vblJlc3VsdExpbWl0RXhjZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25SZXN1bHRMaW1pdEV4Y2VlZGVkKGRvY3VtZW50LnVyaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0Q29sb3JQcmVzZW50YXRpb25zKGRvY3VtZW50LCBkb2MsIGNvbG9yLCByYW5nZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgY29uc3QgcmVkMjU2ID0gTWF0aC5yb3VuZChjb2xvci5yZWQgKiAyNTUpLCBncmVlbjI1NiA9IE1hdGgucm91bmQoY29sb3IuZ3JlZW4gKiAyNTUpLCBibHVlMjU2ID0gTWF0aC5yb3VuZChjb2xvci5ibHVlICogMjU1KTtcbiAgICAgICAgZnVuY3Rpb24gdG9Ud29EaWdpdEhleChuKSB7XG4gICAgICAgICAgICBjb25zdCByID0gbi50b1N0cmluZygxNik7XG4gICAgICAgICAgICByZXR1cm4gci5sZW5ndGggIT09IDIgPyAnMCcgKyByIDogcjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGFiZWw7XG4gICAgICAgIGlmIChjb2xvci5hbHBoYSA9PT0gMSkge1xuICAgICAgICAgICAgbGFiZWwgPSBgIyR7dG9Ud29EaWdpdEhleChyZWQyNTYpfSR7dG9Ud29EaWdpdEhleChncmVlbjI1Nil9JHt0b1R3b0RpZ2l0SGV4KGJsdWUyNTYpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsYWJlbCA9IGAjJHt0b1R3b0RpZ2l0SGV4KHJlZDI1Nil9JHt0b1R3b0RpZ2l0SGV4KGdyZWVuMjU2KX0ke3RvVHdvRGlnaXRIZXgoYmx1ZTI1Nil9JHt0b1R3b0RpZ2l0SGV4KE1hdGgucm91bmQoY29sb3IuYWxwaGEgKiAyNTUpKX1gO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHsgbGFiZWw6IGxhYmVsLCB0ZXh0RWRpdDogbWFpbi5UZXh0RWRpdC5yZXBsYWNlKHJhbmdlLCBKU09OLnN0cmluZ2lmeShsYWJlbCkpIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFJhbmdlKGRvY3VtZW50LCBub2RlKSB7XG4gICAgcmV0dXJuIG1haW4uUmFuZ2UuY3JlYXRlKGRvY3VtZW50LnBvc2l0aW9uQXQobm9kZS5vZmZzZXQpLCBkb2N1bWVudC5wb3NpdGlvbkF0KG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGgpKTtcbn1cbmZ1bmN0aW9uIGdldE5hbWUobm9kZSkge1xuICAgIHJldHVybiBqc29uUGFyc2VyX2dldE5vZGVWYWx1ZShub2RlKSB8fCB0KCc8ZW1wdHk+Jyk7XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL2xpYi9lc20vc2VydmljZXMvY29uZmlndXJhdGlvbi5qc1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbmNvbnN0IHNjaGVtYUNvbnRyaWJ1dGlvbnMgPSB7XG4gICAgc2NoZW1hQXNzb2NpYXRpb25zOiBbXSxcbiAgICBzY2hlbWFzOiB7XG4gICAgICAgIC8vIHJlZmVyIHRvIHRoZSBsYXRlc3Qgc2NoZW1hXG4gICAgICAgICdodHRwOi8vanNvbi1zY2hlbWEub3JnL3NjaGVtYSMnOiB7XG4gICAgICAgICAgICAkcmVmOiAnaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjJ1xuICAgICAgICB9LFxuICAgICAgICAvLyBidW5kbGUgdGhlIHNjaGVtYS1zY2hlbWEgdG8gaW5jbHVkZSAobG9jYWxpemVkKSBkZXNjcmlwdGlvbnNcbiAgICAgICAgJ2h0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hIyc6IHtcbiAgICAgICAgICAgICckc2NoZW1hJzogJ2h0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hIycsXG4gICAgICAgICAgICAnZGVmaW5pdGlvbnMnOiB7XG4gICAgICAgICAgICAgICAgJ3NjaGVtYUFycmF5Jzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgICAgICdtaW5JdGVtcyc6IDEsXG4gICAgICAgICAgICAgICAgICAgICdpdGVtcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwb3NpdGl2ZUludGVnZXInOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2ludGVnZXInLFxuICAgICAgICAgICAgICAgICAgICAnbWluaW11bSc6IDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwb3NpdGl2ZUludGVnZXJEZWZhdWx0MCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FsbE9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMvZGVmaW5pdGlvbnMvcG9zaXRpdmVJbnRlZ2VyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGVmYXVsdCc6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3NpbXBsZVR5cGVzJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAnZW51bSc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcnJheScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYm9vbGVhbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW50ZWdlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbnVsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3N0cmluZ0FycmF5Jzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgICAgICdpdGVtcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ21pbkl0ZW1zJzogMSxcbiAgICAgICAgICAgICAgICAgICAgJ3VuaXF1ZUl0ZW1zJzogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndHlwZSc6ICdvYmplY3QnLFxuICAgICAgICAgICAgJ3Byb3BlcnRpZXMnOiB7XG4gICAgICAgICAgICAgICAgJ2lkJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAnZm9ybWF0JzogJ3VyaSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICckc2NoZW1hJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAnZm9ybWF0JzogJ3VyaSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd0aXRsZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2Rlc2NyaXB0aW9uJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZGVmYXVsdCc6IHt9LFxuICAgICAgICAgICAgICAgICdtdWx0aXBsZU9mJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAgICAgICAgICAgICAnbWluaW11bSc6IDAsXG4gICAgICAgICAgICAgICAgICAgICdleGNsdXNpdmVNaW5pbXVtJzogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ21heGltdW0nOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ251bWJlcidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdleGNsdXNpdmVNYXhpbXVtJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ21pbmltdW0nOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ251bWJlcidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdleGNsdXNpdmVNaW5pbXVtJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ21heExlbmd0aCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FsbE9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMvZGVmaW5pdGlvbnMvcG9zaXRpdmVJbnRlZ2VyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnbWluTGVuZ3RoJzoge1xuICAgICAgICAgICAgICAgICAgICAnYWxsT2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9wb3NpdGl2ZUludGVnZXJEZWZhdWx0MCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3BhdHRlcm4nOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICdmb3JtYXQnOiAncmVnZXgnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnYWRkaXRpb25hbEl0ZW1zJzoge1xuICAgICAgICAgICAgICAgICAgICAnYW55T2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIydcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiB7fVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2l0ZW1zJzoge1xuICAgICAgICAgICAgICAgICAgICAnYW55T2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIydcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiB7fVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ21heEl0ZW1zJzoge1xuICAgICAgICAgICAgICAgICAgICAnYWxsT2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9wb3NpdGl2ZUludGVnZXInXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdtaW5JdGVtcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FsbE9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMvZGVmaW5pdGlvbnMvcG9zaXRpdmVJbnRlZ2VyRGVmYXVsdDAnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd1bmlxdWVJdGVtcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgICAgICAgICAgICAgICAgICdkZWZhdWx0JzogZmFsc2VcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdtYXhQcm9wZXJ0aWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAnYWxsT2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9wb3NpdGl2ZUludGVnZXInXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdtaW5Qcm9wZXJ0aWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAnYWxsT2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9wb3NpdGl2ZUludGVnZXJEZWZhdWx0MCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3JlcXVpcmVkJzoge1xuICAgICAgICAgICAgICAgICAgICAnYWxsT2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9zdHJpbmdBcnJheSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAnYW55T2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIydcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiB7fVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2RlZmluaXRpb25zJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdvYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICAnYWRkaXRpb25hbFByb3BlcnRpZXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnZGVmYXVsdCc6IHt9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJvcGVydGllcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIydcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiB7fVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3BhdHRlcm5Qcm9wZXJ0aWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdvYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICAnYWRkaXRpb25hbFByb3BlcnRpZXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnZGVmYXVsdCc6IHt9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZGVwZW5kZW5jaWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdvYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICAnYWRkaXRpb25hbFByb3BlcnRpZXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnYW55T2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjL2RlZmluaXRpb25zL3N0cmluZ0FycmF5J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2VudW0nOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2FycmF5JyxcbiAgICAgICAgICAgICAgICAgICAgJ21pbkl0ZW1zJzogMSxcbiAgICAgICAgICAgICAgICAgICAgJ3VuaXF1ZUl0ZW1zJzogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbnlPZic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjL2RlZmluaXRpb25zL3NpbXBsZVR5cGVzJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2l0ZW1zJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjL2RlZmluaXRpb25zL3NpbXBsZVR5cGVzJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21pbkl0ZW1zJzogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndW5pcXVlSXRlbXMnOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdmb3JtYXQnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbnlPZic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdlbnVtJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0ZS10aW1lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3VyaScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdlbWFpbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdob3N0bmFtZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpcHY0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lwdjYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmVnZXgnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdhbGxPZic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FsbE9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXknXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdhbnlPZic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FsbE9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXknXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdvbmVPZic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FsbE9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXknXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdub3QnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbGxPZic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdkZXBlbmRlbmNpZXMnOiB7XG4gICAgICAgICAgICAgICAgJ2V4Y2x1c2l2ZU1heGltdW0nOiBbXG4gICAgICAgICAgICAgICAgICAgICdtYXhpbXVtJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgJ2V4Y2x1c2l2ZU1pbmltdW0nOiBbXG4gICAgICAgICAgICAgICAgICAgICdtaW5pbXVtJ1xuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZGVmYXVsdCc6IHt9XG4gICAgICAgIH0sXG4gICAgICAgICdodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSMnOiB7XG4gICAgICAgICAgICAnZGVmaW5pdGlvbnMnOiB7XG4gICAgICAgICAgICAgICAgJ3NjaGVtYUFycmF5Jzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgICAgICdtaW5JdGVtcyc6IDEsXG4gICAgICAgICAgICAgICAgICAgICdpdGVtcyc6IHsgJyRyZWYnOiAnIycgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ25vbk5lZ2F0aXZlSW50ZWdlcic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnaW50ZWdlcicsXG4gICAgICAgICAgICAgICAgICAgICdtaW5pbXVtJzogMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ25vbk5lZ2F0aXZlSW50ZWdlckRlZmF1bHQwJzoge1xuICAgICAgICAgICAgICAgICAgICAnYWxsT2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7ICckcmVmJzogJyMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyAnZGVmYXVsdCc6IDAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnc2ltcGxlVHlwZXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdlbnVtJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FycmF5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdib29sZWFuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbnRlZ2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdudWxsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdudW1iZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnc3RyaW5nQXJyYXknOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2FycmF5JyxcbiAgICAgICAgICAgICAgICAgICAgJ2l0ZW1zJzogeyAndHlwZSc6ICdzdHJpbmcnIH0sXG4gICAgICAgICAgICAgICAgICAgICd1bmlxdWVJdGVtcyc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICdkZWZhdWx0JzogW11cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3R5cGUnOiBbJ29iamVjdCcsICdib29sZWFuJ10sXG4gICAgICAgICAgICAncHJvcGVydGllcyc6IHtcbiAgICAgICAgICAgICAgICAnJGlkJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAnZm9ybWF0JzogJ3VyaS1yZWZlcmVuY2UnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnJHNjaGVtYSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgJ2Zvcm1hdCc6ICd1cmknXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnJHJlZic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgJ2Zvcm1hdCc6ICd1cmktcmVmZXJlbmNlJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJyRjb21tZW50Jzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAndGl0bGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdkZXNjcmlwdGlvbic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdyZWFkT25seSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgICAgICAgICAgICAgICAgICdkZWZhdWx0JzogZmFsc2VcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdleGFtcGxlcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnYXJyYXknLFxuICAgICAgICAgICAgICAgICAgICAnaXRlbXMnOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnbXVsdGlwbGVPZic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICAgICAgJ2V4Y2x1c2l2ZU1pbmltdW0nOiAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnbWF4aW11bSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2V4Y2x1c2l2ZU1heGltdW0nOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ251bWJlcidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdtaW5pbXVtJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdudW1iZXInXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZXhjbHVzaXZlTWluaW11bSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ21heExlbmd0aCc6IHsgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXInIH0sXG4gICAgICAgICAgICAgICAgJ21pbkxlbmd0aCc6IHsgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJEZWZhdWx0MCcgfSxcbiAgICAgICAgICAgICAgICAncGF0dGVybic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgJ2Zvcm1hdCc6ICdyZWdleCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdhZGRpdGlvbmFsSXRlbXMnOiB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgJ2l0ZW1zJzoge1xuICAgICAgICAgICAgICAgICAgICAnYW55T2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7ICckcmVmJzogJyMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXknIH1cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnbWF4SXRlbXMnOiB7ICckcmVmJzogJyMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyJyB9LFxuICAgICAgICAgICAgICAgICdtaW5JdGVtcyc6IHsgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJEZWZhdWx0MCcgfSxcbiAgICAgICAgICAgICAgICAndW5pcXVlSXRlbXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgICAgICAgICAnZGVmYXVsdCc6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnY29udGFpbnMnOiB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgJ21heFByb3BlcnRpZXMnOiB7ICckcmVmJzogJyMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyJyB9LFxuICAgICAgICAgICAgICAgICdtaW5Qcm9wZXJ0aWVzJzogeyAnJHJlZic6ICcjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlckRlZmF1bHQwJyB9LFxuICAgICAgICAgICAgICAgICdyZXF1aXJlZCc6IHsgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9zdHJpbmdBcnJheScgfSxcbiAgICAgICAgICAgICAgICAnYWRkaXRpb25hbFByb3BlcnRpZXMnOiB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgJ2RlZmluaXRpb25zJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdvYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICAnYWRkaXRpb25hbFByb3BlcnRpZXMnOiB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgICAgICdkZWZhdWx0Jzoge31cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcm9wZXJ0aWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdvYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICAnYWRkaXRpb25hbFByb3BlcnRpZXMnOiB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgICAgICdkZWZhdWx0Jzoge31cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwYXR0ZXJuUHJvcGVydGllcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJzogeyAnJHJlZic6ICcjJyB9LFxuICAgICAgICAgICAgICAgICAgICAncHJvcGVydHlOYW1lcyc6IHsgJ2Zvcm1hdCc6ICdyZWdleCcgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiB7fVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2RlcGVuZGVuY2llcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FueU9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgJyRyZWYnOiAnIycgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ICckcmVmJzogJyMvZGVmaW5pdGlvbnMvc3RyaW5nQXJyYXknIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3Byb3BlcnR5TmFtZXMnOiB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgJ2NvbnN0JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZW51bSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnYXJyYXknLFxuICAgICAgICAgICAgICAgICAgICAnaXRlbXMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAnbWluSXRlbXMnOiAxLFxuICAgICAgICAgICAgICAgICAgICAndW5pcXVlSXRlbXMnOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAndHlwZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FueU9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyAnJHJlZic6ICcjL2RlZmluaXRpb25zL3NpbXBsZVR5cGVzJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2FycmF5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaXRlbXMnOiB7ICckcmVmJzogJyMvZGVmaW5pdGlvbnMvc2ltcGxlVHlwZXMnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21pbkl0ZW1zJzogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndW5pcXVlSXRlbXMnOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdmb3JtYXQnOiB7ICd0eXBlJzogJ3N0cmluZycgfSxcbiAgICAgICAgICAgICAgICAnY29udGVudE1lZGlhVHlwZSc6IHsgJ3R5cGUnOiAnc3RyaW5nJyB9LFxuICAgICAgICAgICAgICAgICdjb250ZW50RW5jb2RpbmcnOiB7ICd0eXBlJzogJ3N0cmluZycgfSxcbiAgICAgICAgICAgICAgICAnaWYnOiB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgJ3RoZW4nOiB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgJ2Vsc2UnOiB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgJ2FsbE9mJzogeyAnJHJlZic6ICcjL2RlZmluaXRpb25zL3NjaGVtYUFycmF5JyB9LFxuICAgICAgICAgICAgICAgICdhbnlPZic6IHsgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheScgfSxcbiAgICAgICAgICAgICAgICAnb25lT2YnOiB7ICckcmVmJzogJyMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXknIH0sXG4gICAgICAgICAgICAgICAgJ25vdCc6IHsgJyRyZWYnOiAnIycgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdkZWZhdWx0JzogdHJ1ZVxuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGRlc2NyaXB0aW9ucyA9IHtcbiAgICBpZDogdChcIkEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBzY2hlbWEuXCIpLFxuICAgICRzY2hlbWE6IHQoXCJUaGUgc2NoZW1hIHRvIHZlcmlmeSB0aGlzIGRvY3VtZW50IGFnYWluc3QuXCIpLFxuICAgIHRpdGxlOiB0KFwiQSBkZXNjcmlwdGl2ZSB0aXRsZSBvZiB0aGUgZWxlbWVudC5cIiksXG4gICAgZGVzY3JpcHRpb246IHQoXCJBIGxvbmcgZGVzY3JpcHRpb24gb2YgdGhlIGVsZW1lbnQuIFVzZWQgaW4gaG92ZXIgbWVudXMgYW5kIHN1Z2dlc3Rpb25zLlwiKSxcbiAgICBkZWZhdWx0OiB0KFwiQSBkZWZhdWx0IHZhbHVlLiBVc2VkIGJ5IHN1Z2dlc3Rpb25zLlwiKSxcbiAgICBtdWx0aXBsZU9mOiB0KFwiQSBudW1iZXIgdGhhdCBzaG91bGQgY2xlYW5seSBkaXZpZGUgdGhlIGN1cnJlbnQgdmFsdWUgKGkuZS4gaGF2ZSBubyByZW1haW5kZXIpLlwiKSxcbiAgICBtYXhpbXVtOiB0KFwiVGhlIG1heGltdW0gbnVtZXJpY2FsIHZhbHVlLCBpbmNsdXNpdmUgYnkgZGVmYXVsdC5cIiksXG4gICAgZXhjbHVzaXZlTWF4aW11bTogdChcIk1ha2VzIHRoZSBtYXhpbXVtIHByb3BlcnR5IGV4Y2x1c2l2ZS5cIiksXG4gICAgbWluaW11bTogdChcIlRoZSBtaW5pbXVtIG51bWVyaWNhbCB2YWx1ZSwgaW5jbHVzaXZlIGJ5IGRlZmF1bHQuXCIpLFxuICAgIGV4Y2x1c2l2ZU1pbmltdW06IHQoXCJNYWtlcyB0aGUgbWluaW11bSBwcm9wZXJ0eSBleGNsdXNpdmUuXCIpLFxuICAgIG1heExlbmd0aDogdChcIlRoZSBtYXhpbXVtIGxlbmd0aCBvZiBhIHN0cmluZy5cIiksXG4gICAgbWluTGVuZ3RoOiB0KFwiVGhlIG1pbmltdW0gbGVuZ3RoIG9mIGEgc3RyaW5nLlwiKSxcbiAgICBwYXR0ZXJuOiB0KFwiQSByZWd1bGFyIGV4cHJlc3Npb24gdG8gbWF0Y2ggdGhlIHN0cmluZyBhZ2FpbnN0LiBJdCBpcyBub3QgaW1wbGljaXRseSBhbmNob3JlZC5cIiksXG4gICAgYWRkaXRpb25hbEl0ZW1zOiB0KFwiRm9yIGFycmF5cywgb25seSB3aGVuIGl0ZW1zIGlzIHNldCBhcyBhbiBhcnJheS4gSWYgaXQgaXMgYSBzY2hlbWEsIHRoZW4gdGhpcyBzY2hlbWEgdmFsaWRhdGVzIGl0ZW1zIGFmdGVyIHRoZSBvbmVzIHNwZWNpZmllZCBieSB0aGUgaXRlbXMgYXJyYXkuIElmIGl0IGlzIGZhbHNlLCB0aGVuIGFkZGl0aW9uYWwgaXRlbXMgd2lsbCBjYXVzZSB2YWxpZGF0aW9uIHRvIGZhaWwuXCIpLFxuICAgIGl0ZW1zOiB0KFwiRm9yIGFycmF5cy4gQ2FuIGVpdGhlciBiZSBhIHNjaGVtYSB0byB2YWxpZGF0ZSBldmVyeSBlbGVtZW50IGFnYWluc3Qgb3IgYW4gYXJyYXkgb2Ygc2NoZW1hcyB0byB2YWxpZGF0ZSBlYWNoIGl0ZW0gYWdhaW5zdCBpbiBvcmRlciAodGhlIGZpcnN0IHNjaGVtYSB3aWxsIHZhbGlkYXRlIHRoZSBmaXJzdCBlbGVtZW50LCB0aGUgc2Vjb25kIHNjaGVtYSB3aWxsIHZhbGlkYXRlIHRoZSBzZWNvbmQgZWxlbWVudCwgYW5kIHNvIG9uLlwiKSxcbiAgICBtYXhJdGVtczogdChcIlRoZSBtYXhpbXVtIG51bWJlciBvZiBpdGVtcyB0aGF0IGNhbiBiZSBpbnNpZGUgYW4gYXJyYXkuIEluY2x1c2l2ZS5cIiksXG4gICAgbWluSXRlbXM6IHQoXCJUaGUgbWluaW11bSBudW1iZXIgb2YgaXRlbXMgdGhhdCBjYW4gYmUgaW5zaWRlIGFuIGFycmF5LiBJbmNsdXNpdmUuXCIpLFxuICAgIHVuaXF1ZUl0ZW1zOiB0KFwiSWYgYWxsIG9mIHRoZSBpdGVtcyBpbiB0aGUgYXJyYXkgbXVzdCBiZSB1bmlxdWUuIERlZmF1bHRzIHRvIGZhbHNlLlwiKSxcbiAgICBtYXhQcm9wZXJ0aWVzOiB0KFwiVGhlIG1heGltdW0gbnVtYmVyIG9mIHByb3BlcnRpZXMgYW4gb2JqZWN0IGNhbiBoYXZlLiBJbmNsdXNpdmUuXCIpLFxuICAgIG1pblByb3BlcnRpZXM6IHQoXCJUaGUgbWluaW11bSBudW1iZXIgb2YgcHJvcGVydGllcyBhbiBvYmplY3QgY2FuIGhhdmUuIEluY2x1c2l2ZS5cIiksXG4gICAgcmVxdWlyZWQ6IHQoXCJBbiBhcnJheSBvZiBzdHJpbmdzIHRoYXQgbGlzdHMgdGhlIG5hbWVzIG9mIGFsbCBwcm9wZXJ0aWVzIHJlcXVpcmVkIG9uIHRoaXMgb2JqZWN0LlwiKSxcbiAgICBhZGRpdGlvbmFsUHJvcGVydGllczogdChcIkVpdGhlciBhIHNjaGVtYSBvciBhIGJvb2xlYW4uIElmIGEgc2NoZW1hLCB0aGVuIHVzZWQgdG8gdmFsaWRhdGUgYWxsIHByb3BlcnRpZXMgbm90IG1hdGNoZWQgYnkgJ3Byb3BlcnRpZXMnIG9yICdwYXR0ZXJuUHJvcGVydGllcycuIElmIGZhbHNlLCB0aGVuIGFueSBwcm9wZXJ0aWVzIG5vdCBtYXRjaGVkIGJ5IGVpdGhlciB3aWxsIGNhdXNlIHRoaXMgc2NoZW1hIHRvIGZhaWwuXCIpLFxuICAgIGRlZmluaXRpb25zOiB0KFwiTm90IHVzZWQgZm9yIHZhbGlkYXRpb24uIFBsYWNlIHN1YnNjaGVtYXMgaGVyZSB0aGF0IHlvdSB3aXNoIHRvIHJlZmVyZW5jZSBpbmxpbmUgd2l0aCAkcmVmLlwiKSxcbiAgICBwcm9wZXJ0aWVzOiB0KFwiQSBtYXAgb2YgcHJvcGVydHkgbmFtZXMgdG8gc2NoZW1hcyBmb3IgZWFjaCBwcm9wZXJ0eS5cIiksXG4gICAgcGF0dGVyblByb3BlcnRpZXM6IHQoXCJBIG1hcCBvZiByZWd1bGFyIGV4cHJlc3Npb25zIG9uIHByb3BlcnR5IG5hbWVzIHRvIHNjaGVtYXMgZm9yIG1hdGNoaW5nIHByb3BlcnRpZXMuXCIpLFxuICAgIGRlcGVuZGVuY2llczogdChcIkEgbWFwIG9mIHByb3BlcnR5IG5hbWVzIHRvIGVpdGhlciBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBvciBhIHNjaGVtYS4gQW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgbWVhbnMgdGhlIHByb3BlcnR5IG5hbWVkIGluIHRoZSBrZXkgZGVwZW5kcyBvbiB0aGUgcHJvcGVydGllcyBpbiB0aGUgYXJyYXkgYmVpbmcgcHJlc2VudCBpbiB0aGUgb2JqZWN0IGluIG9yZGVyIHRvIGJlIHZhbGlkLiBJZiB0aGUgdmFsdWUgaXMgYSBzY2hlbWEsIHRoZW4gdGhlIHNjaGVtYSBpcyBvbmx5IGFwcGxpZWQgdG8gdGhlIG9iamVjdCBpZiB0aGUgcHJvcGVydHkgaW4gdGhlIGtleSBleGlzdHMgb24gdGhlIG9iamVjdC5cIiksXG4gICAgZW51bTogdChcIlRoZSBzZXQgb2YgbGl0ZXJhbCB2YWx1ZXMgdGhhdCBhcmUgdmFsaWQuXCIpLFxuICAgIHR5cGU6IHQoXCJFaXRoZXIgYSBzdHJpbmcgb2Ygb25lIG9mIHRoZSBiYXNpYyBzY2hlbWEgdHlwZXMgKG51bWJlciwgaW50ZWdlciwgbnVsbCwgYXJyYXksIG9iamVjdCwgYm9vbGVhbiwgc3RyaW5nKSBvciBhbiBhcnJheSBvZiBzdHJpbmdzIHNwZWNpZnlpbmcgYSBzdWJzZXQgb2YgdGhvc2UgdHlwZXMuXCIpLFxuICAgIGZvcm1hdDogdChcIkRlc2NyaWJlcyB0aGUgZm9ybWF0IGV4cGVjdGVkIGZvciB0aGUgdmFsdWUuXCIpLFxuICAgIGFsbE9mOiB0KFwiQW4gYXJyYXkgb2Ygc2NoZW1hcywgYWxsIG9mIHdoaWNoIG11c3QgbWF0Y2guXCIpLFxuICAgIGFueU9mOiB0KFwiQW4gYXJyYXkgb2Ygc2NoZW1hcywgd2hlcmUgYXQgbGVhc3Qgb25lIG11c3QgbWF0Y2guXCIpLFxuICAgIG9uZU9mOiB0KFwiQW4gYXJyYXkgb2Ygc2NoZW1hcywgZXhhY3RseSBvbmUgb2Ygd2hpY2ggbXVzdCBtYXRjaC5cIiksXG4gICAgbm90OiB0KFwiQSBzY2hlbWEgd2hpY2ggbXVzdCBub3QgbWF0Y2guXCIpLFxuICAgICRpZDogdChcIkEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBzY2hlbWEuXCIpLFxuICAgICRyZWY6IHQoXCJSZWZlcmVuY2UgYSBkZWZpbml0aW9uIGhvc3RlZCBvbiBhbnkgbG9jYXRpb24uXCIpLFxuICAgICRjb21tZW50OiB0KFwiQ29tbWVudHMgZnJvbSBzY2hlbWEgYXV0aG9ycyB0byByZWFkZXJzIG9yIG1haW50YWluZXJzIG9mIHRoZSBzY2hlbWEuXCIpLFxuICAgIHJlYWRPbmx5OiB0KFwiSW5kaWNhdGVzIHRoYXQgdGhlIHZhbHVlIG9mIHRoZSBpbnN0YW5jZSBpcyBtYW5hZ2VkIGV4Y2x1c2l2ZWx5IGJ5IHRoZSBvd25pbmcgYXV0aG9yaXR5LlwiKSxcbiAgICBleGFtcGxlczogdChcIlNhbXBsZSBKU09OIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggYSBwYXJ0aWN1bGFyIHNjaGVtYSwgZm9yIHRoZSBwdXJwb3NlIG9mIGlsbHVzdHJhdGluZyB1c2FnZS5cIiksXG4gICAgY29udGFpbnM6IHQoXCJBbiBhcnJheSBpbnN0YW5jZSBpcyB2YWxpZCBhZ2FpbnN0IFxcXCJjb250YWluc1xcXCIgaWYgYXQgbGVhc3Qgb25lIG9mIGl0cyBlbGVtZW50cyBpcyB2YWxpZCBhZ2FpbnN0IHRoZSBnaXZlbiBzY2hlbWEuXCIpLFxuICAgIHByb3BlcnR5TmFtZXM6IHQoXCJJZiB0aGUgaW5zdGFuY2UgaXMgYW4gb2JqZWN0LCB0aGlzIGtleXdvcmQgdmFsaWRhdGVzIGlmIGV2ZXJ5IHByb3BlcnR5IG5hbWUgaW4gdGhlIGluc3RhbmNlIHZhbGlkYXRlcyBhZ2FpbnN0IHRoZSBwcm92aWRlZCBzY2hlbWEuXCIpLFxuICAgIGNvbnN0OiB0KFwiQW4gaW5zdGFuY2UgdmFsaWRhdGVzIHN1Y2Nlc3NmdWxseSBhZ2FpbnN0IHRoaXMga2V5d29yZCBpZiBpdHMgdmFsdWUgaXMgZXF1YWwgdG8gdGhlIHZhbHVlIG9mIHRoZSBrZXl3b3JkLlwiKSxcbiAgICBjb250ZW50TWVkaWFUeXBlOiB0KFwiRGVzY3JpYmVzIHRoZSBtZWRpYSB0eXBlIG9mIGEgc3RyaW5nIHByb3BlcnR5LlwiKSxcbiAgICBjb250ZW50RW5jb2Rpbmc6IHQoXCJEZXNjcmliZXMgdGhlIGNvbnRlbnQgZW5jb2Rpbmcgb2YgYSBzdHJpbmcgcHJvcGVydHkuXCIpLFxuICAgIGlmOiB0KFwiVGhlIHZhbGlkYXRpb24gb3V0Y29tZSBvZiB0aGUgXFxcImlmXFxcIiBzdWJzY2hlbWEgY29udHJvbHMgd2hpY2ggb2YgdGhlIFxcXCJ0aGVuXFxcIiBvciBcXFwiZWxzZVxcXCIga2V5d29yZHMgYXJlIGV2YWx1YXRlZC5cIiksXG4gICAgdGhlbjogdChcIlRoZSBcXFwiaWZcXFwiIHN1YnNjaGVtYSBpcyB1c2VkIGZvciB2YWxpZGF0aW9uIHdoZW4gdGhlIFxcXCJpZlxcXCIgc3Vic2NoZW1hIHN1Y2NlZWRzLlwiKSxcbiAgICBlbHNlOiB0KFwiVGhlIFxcXCJlbHNlXFxcIiBzdWJzY2hlbWEgaXMgdXNlZCBmb3IgdmFsaWRhdGlvbiB3aGVuIHRoZSBcXFwiaWZcXFwiIHN1YnNjaGVtYSBmYWlscy5cIilcbn07XG5mb3IgKGNvbnN0IHNjaGVtYU5hbWUgaW4gc2NoZW1hQ29udHJpYnV0aW9ucy5zY2hlbWFzKSB7XG4gICAgY29uc3Qgc2NoZW1hID0gc2NoZW1hQ29udHJpYnV0aW9ucy5zY2hlbWFzW3NjaGVtYU5hbWVdO1xuICAgIGZvciAoY29uc3QgcHJvcGVydHkgaW4gc2NoZW1hLnByb3BlcnRpZXMpIHtcbiAgICAgICAgbGV0IHByb3BlcnR5T2JqZWN0ID0gc2NoZW1hLnByb3BlcnRpZXNbcHJvcGVydHldO1xuICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5T2JqZWN0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHByb3BlcnR5T2JqZWN0ID0gc2NoZW1hLnByb3BlcnRpZXNbcHJvcGVydHldID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbnNbcHJvcGVydHldO1xuICAgICAgICBpZiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHByb3BlcnR5T2JqZWN0WydkZXNjcmlwdGlvbiddID0gZGVzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICB9XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLXVyaS9saWIvZXNtL2luZGV4LmpzXG4vKiBwcm92aWRlZCBkZXBlbmRlbmN5ICovIHZhciBwcm9jZXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NDA2KTtcbnZhciBMSUI7KCgpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9ezQ3MDp0PT57ZnVuY3Rpb24gZSh0KXtpZihcInN0cmluZ1wiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGF0aCBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZCBcIitKU09OLnN0cmluZ2lmeSh0KSl9ZnVuY3Rpb24gcih0LGUpe2Zvcih2YXIgcixuPVwiXCIsbz0wLGk9LTEsYT0wLGg9MDtoPD10Lmxlbmd0aDsrK2gpe2lmKGg8dC5sZW5ndGgpcj10LmNoYXJDb2RlQXQoaCk7ZWxzZXtpZig0Nz09PXIpYnJlYWs7cj00N31pZig0Nz09PXIpe2lmKGk9PT1oLTF8fDE9PT1hKTtlbHNlIGlmKGkhPT1oLTEmJjI9PT1hKXtpZihuLmxlbmd0aDwyfHwyIT09b3x8NDYhPT1uLmNoYXJDb2RlQXQobi5sZW5ndGgtMSl8fDQ2IT09bi5jaGFyQ29kZUF0KG4ubGVuZ3RoLTIpKWlmKG4ubGVuZ3RoPjIpe3ZhciBzPW4ubGFzdEluZGV4T2YoXCIvXCIpO2lmKHMhPT1uLmxlbmd0aC0xKXstMT09PXM/KG49XCJcIixvPTApOm89KG49bi5zbGljZSgwLHMpKS5sZW5ndGgtMS1uLmxhc3RJbmRleE9mKFwiL1wiKSxpPWgsYT0wO2NvbnRpbnVlfX1lbHNlIGlmKDI9PT1uLmxlbmd0aHx8MT09PW4ubGVuZ3RoKXtuPVwiXCIsbz0wLGk9aCxhPTA7Y29udGludWV9ZSYmKG4ubGVuZ3RoPjA/bis9XCIvLi5cIjpuPVwiLi5cIixvPTIpfWVsc2Ugbi5sZW5ndGg+MD9uKz1cIi9cIit0LnNsaWNlKGkrMSxoKTpuPXQuc2xpY2UoaSsxLGgpLG89aC1pLTE7aT1oLGE9MH1lbHNlIDQ2PT09ciYmLTEhPT1hPysrYTphPS0xfXJldHVybiBufXZhciBuPXtyZXNvbHZlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0LG49XCJcIixvPSExLGk9YXJndW1lbnRzLmxlbmd0aC0xO2k+PS0xJiYhbztpLS0pe3ZhciBhO2k+PTA/YT1hcmd1bWVudHNbaV06KHZvaWQgMD09PXQmJih0PXByb2Nlc3MuY3dkKCkpLGE9dCksZShhKSwwIT09YS5sZW5ndGgmJihuPWErXCIvXCIrbixvPTQ3PT09YS5jaGFyQ29kZUF0KDApKX1yZXR1cm4gbj1yKG4sIW8pLG8/bi5sZW5ndGg+MD9cIi9cIituOlwiL1wiOm4ubGVuZ3RoPjA/bjpcIi5cIn0sbm9ybWFsaXplOmZ1bmN0aW9uKHQpe2lmKGUodCksMD09PXQubGVuZ3RoKXJldHVyblwiLlwiO3ZhciBuPTQ3PT09dC5jaGFyQ29kZUF0KDApLG89NDc9PT10LmNoYXJDb2RlQXQodC5sZW5ndGgtMSk7cmV0dXJuIDAhPT0odD1yKHQsIW4pKS5sZW5ndGh8fG58fCh0PVwiLlwiKSx0Lmxlbmd0aD4wJiZvJiYodCs9XCIvXCIpLG4/XCIvXCIrdDp0fSxpc0Fic29sdXRlOmZ1bmN0aW9uKHQpe3JldHVybiBlKHQpLHQubGVuZ3RoPjAmJjQ3PT09dC5jaGFyQ29kZUF0KDApfSxqb2luOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuXCIuXCI7Zm9yKHZhciB0LHI9MDtyPGFyZ3VtZW50cy5sZW5ndGg7KytyKXt2YXIgbz1hcmd1bWVudHNbcl07ZShvKSxvLmxlbmd0aD4wJiYodm9pZCAwPT09dD90PW86dCs9XCIvXCIrbyl9cmV0dXJuIHZvaWQgMD09PXQ/XCIuXCI6bi5ub3JtYWxpemUodCl9LHJlbGF0aXZlOmZ1bmN0aW9uKHQscil7aWYoZSh0KSxlKHIpLHQ9PT1yKXJldHVyblwiXCI7aWYoKHQ9bi5yZXNvbHZlKHQpKT09PShyPW4ucmVzb2x2ZShyKSkpcmV0dXJuXCJcIjtmb3IodmFyIG89MTtvPHQubGVuZ3RoJiY0Nz09PXQuY2hhckNvZGVBdChvKTsrK28pO2Zvcih2YXIgaT10Lmxlbmd0aCxhPWktbyxoPTE7aDxyLmxlbmd0aCYmNDc9PT1yLmNoYXJDb2RlQXQoaCk7KytoKTtmb3IodmFyIHM9ci5sZW5ndGgtaCxjPWE8cz9hOnMsZj0tMSx1PTA7dTw9YzsrK3Upe2lmKHU9PT1jKXtpZihzPmMpe2lmKDQ3PT09ci5jaGFyQ29kZUF0KGgrdSkpcmV0dXJuIHIuc2xpY2UoaCt1KzEpO2lmKDA9PT11KXJldHVybiByLnNsaWNlKGgrdSl9ZWxzZSBhPmMmJig0Nz09PXQuY2hhckNvZGVBdChvK3UpP2Y9dTowPT09dSYmKGY9MCkpO2JyZWFrfXZhciBsPXQuY2hhckNvZGVBdChvK3UpO2lmKGwhPT1yLmNoYXJDb2RlQXQoaCt1KSlicmVhazs0Nz09PWwmJihmPXUpfXZhciBwPVwiXCI7Zm9yKHU9bytmKzE7dTw9aTsrK3UpdSE9PWkmJjQ3IT09dC5jaGFyQ29kZUF0KHUpfHwoMD09PXAubGVuZ3RoP3ArPVwiLi5cIjpwKz1cIi8uLlwiKTtyZXR1cm4gcC5sZW5ndGg+MD9wK3Iuc2xpY2UoaCtmKTooaCs9Ziw0Nz09PXIuY2hhckNvZGVBdChoKSYmKytoLHIuc2xpY2UoaCkpfSxfbWFrZUxvbmc6ZnVuY3Rpb24odCl7cmV0dXJuIHR9LGRpcm5hbWU6ZnVuY3Rpb24odCl7aWYoZSh0KSwwPT09dC5sZW5ndGgpcmV0dXJuXCIuXCI7Zm9yKHZhciByPXQuY2hhckNvZGVBdCgwKSxuPTQ3PT09cixvPS0xLGk9ITAsYT10Lmxlbmd0aC0xO2E+PTE7LS1hKWlmKDQ3PT09KHI9dC5jaGFyQ29kZUF0KGEpKSl7aWYoIWkpe289YTticmVha319ZWxzZSBpPSExO3JldHVybi0xPT09bz9uP1wiL1wiOlwiLlwiOm4mJjE9PT1vP1wiLy9cIjp0LnNsaWNlKDAsbyl9LGJhc2VuYW1lOmZ1bmN0aW9uKHQscil7aWYodm9pZCAwIT09ciYmXCJzdHJpbmdcIiE9dHlwZW9mIHIpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJleHRcIiBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJyk7ZSh0KTt2YXIgbixvPTAsaT0tMSxhPSEwO2lmKHZvaWQgMCE9PXImJnIubGVuZ3RoPjAmJnIubGVuZ3RoPD10Lmxlbmd0aCl7aWYoci5sZW5ndGg9PT10Lmxlbmd0aCYmcj09PXQpcmV0dXJuXCJcIjt2YXIgaD1yLmxlbmd0aC0xLHM9LTE7Zm9yKG49dC5sZW5ndGgtMTtuPj0wOy0tbil7dmFyIGM9dC5jaGFyQ29kZUF0KG4pO2lmKDQ3PT09Yyl7aWYoIWEpe289bisxO2JyZWFrfX1lbHNlLTE9PT1zJiYoYT0hMSxzPW4rMSksaD49MCYmKGM9PT1yLmNoYXJDb2RlQXQoaCk/LTE9PS0taCYmKGk9bik6KGg9LTEsaT1zKSl9cmV0dXJuIG89PT1pP2k9czotMT09PWkmJihpPXQubGVuZ3RoKSx0LnNsaWNlKG8saSl9Zm9yKG49dC5sZW5ndGgtMTtuPj0wOy0tbilpZig0Nz09PXQuY2hhckNvZGVBdChuKSl7aWYoIWEpe289bisxO2JyZWFrfX1lbHNlLTE9PT1pJiYoYT0hMSxpPW4rMSk7cmV0dXJuLTE9PT1pP1wiXCI6dC5zbGljZShvLGkpfSxleHRuYW1lOmZ1bmN0aW9uKHQpe2UodCk7Zm9yKHZhciByPS0xLG49MCxvPS0xLGk9ITAsYT0wLGg9dC5sZW5ndGgtMTtoPj0wOy0taCl7dmFyIHM9dC5jaGFyQ29kZUF0KGgpO2lmKDQ3IT09cyktMT09PW8mJihpPSExLG89aCsxKSw0Nj09PXM/LTE9PT1yP3I9aDoxIT09YSYmKGE9MSk6LTEhPT1yJiYoYT0tMSk7ZWxzZSBpZighaSl7bj1oKzE7YnJlYWt9fXJldHVybi0xPT09cnx8LTE9PT1vfHwwPT09YXx8MT09PWEmJnI9PT1vLTEmJnI9PT1uKzE/XCJcIjp0LnNsaWNlKHIsbyl9LGZvcm1hdDpmdW5jdGlvbih0KXtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwicGF0aE9iamVjdFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyt0eXBlb2YgdCk7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dmFyIHI9ZS5kaXJ8fGUucm9vdCxuPWUuYmFzZXx8KGUubmFtZXx8XCJcIikrKGUuZXh0fHxcIlwiKTtyZXR1cm4gcj9yPT09ZS5yb290P3IrbjpyK1wiL1wiK246bn0oMCx0KX0scGFyc2U6ZnVuY3Rpb24odCl7ZSh0KTt2YXIgcj17cm9vdDpcIlwiLGRpcjpcIlwiLGJhc2U6XCJcIixleHQ6XCJcIixuYW1lOlwiXCJ9O2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gcjt2YXIgbixvPXQuY2hhckNvZGVBdCgwKSxpPTQ3PT09bztpPyhyLnJvb3Q9XCIvXCIsbj0xKTpuPTA7Zm9yKHZhciBhPS0xLGg9MCxzPS0xLGM9ITAsZj10Lmxlbmd0aC0xLHU9MDtmPj1uOy0tZilpZig0NyE9PShvPXQuY2hhckNvZGVBdChmKSkpLTE9PT1zJiYoYz0hMSxzPWYrMSksNDY9PT1vPy0xPT09YT9hPWY6MSE9PXUmJih1PTEpOi0xIT09YSYmKHU9LTEpO2Vsc2UgaWYoIWMpe2g9ZisxO2JyZWFrfXJldHVybi0xPT09YXx8LTE9PT1zfHwwPT09dXx8MT09PXUmJmE9PT1zLTEmJmE9PT1oKzE/LTEhPT1zJiYoci5iYXNlPXIubmFtZT0wPT09aCYmaT90LnNsaWNlKDEscyk6dC5zbGljZShoLHMpKTooMD09PWgmJmk/KHIubmFtZT10LnNsaWNlKDEsYSksci5iYXNlPXQuc2xpY2UoMSxzKSk6KHIubmFtZT10LnNsaWNlKGgsYSksci5iYXNlPXQuc2xpY2UoaCxzKSksci5leHQ9dC5zbGljZShhLHMpKSxoPjA/ci5kaXI9dC5zbGljZSgwLGgtMSk6aSYmKHIuZGlyPVwiL1wiKSxyfSxzZXA6XCIvXCIsZGVsaW1pdGVyOlwiOlwiLHdpbjMyOm51bGwscG9zaXg6bnVsbH07bi5wb3NpeD1uLHQuZXhwb3J0cz1ufX0sZT17fTtmdW5jdGlvbiByKG4pe3ZhciBvPWVbbl07aWYodm9pZCAwIT09bylyZXR1cm4gby5leHBvcnRzO3ZhciBpPWVbbl09e2V4cG9ydHM6e319O3JldHVybiB0W25dKGksaS5leHBvcnRzLHIpLGkuZXhwb3J0c31yLmQ9KHQsZSk9Pntmb3IodmFyIG4gaW4gZSlyLm8oZSxuKSYmIXIubyh0LG4pJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLHtlbnVtZXJhYmxlOiEwLGdldDplW25dfSl9LHIubz0odCxlKT0+T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSksci5yPXQ9PntcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfTt2YXIgbj17fTsoKCk9Pnt2YXIgdDtpZihyLnIobiksci5kKG4se1VSSTooKT0+ZyxVdGlsczooKT0+T30pLFwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzKXQ9XCJ3aW4zMlwiPT09cHJvY2Vzcy5wbGF0Zm9ybTtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBuYXZpZ2F0b3Ipe3ZhciBlPW5hdmlnYXRvci51c2VyQWdlbnQ7dD1lLmluZGV4T2YoXCJXaW5kb3dzXCIpPj0wfXZhciBvLGksYT0obz1mdW5jdGlvbih0LGUpe3JldHVybiBvPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbih0LGUpe3QuX19wcm90b19fPWV9fHxmdW5jdGlvbih0LGUpe2Zvcih2YXIgciBpbiBlKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiYodFtyXT1lW3JdKX0sbyh0LGUpfSxmdW5jdGlvbih0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiK1N0cmluZyhlKStcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO2Z1bmN0aW9uIHIoKXt0aGlzLmNvbnN0cnVjdG9yPXR9byh0LGUpLHQucHJvdG90eXBlPW51bGw9PT1lP09iamVjdC5jcmVhdGUoZSk6KHIucHJvdG90eXBlPWUucHJvdG90eXBlLG5ldyByKX0pLGg9L15cXHdbXFx3XFxkKy4tXSokLyxzPS9eXFwvLyxjPS9eXFwvXFwvLztmdW5jdGlvbiBmKHQsZSl7aWYoIXQuc2NoZW1lJiZlKXRocm93IG5ldyBFcnJvcignW1VyaUVycm9yXTogU2NoZW1lIGlzIG1pc3Npbmc6IHtzY2hlbWU6IFwiXCIsIGF1dGhvcml0eTogXCInLmNvbmNhdCh0LmF1dGhvcml0eSwnXCIsIHBhdGg6IFwiJykuY29uY2F0KHQucGF0aCwnXCIsIHF1ZXJ5OiBcIicpLmNvbmNhdCh0LnF1ZXJ5LCdcIiwgZnJhZ21lbnQ6IFwiJykuY29uY2F0KHQuZnJhZ21lbnQsJ1wifScpKTtpZih0LnNjaGVtZSYmIWgudGVzdCh0LnNjaGVtZSkpdGhyb3cgbmV3IEVycm9yKFwiW1VyaUVycm9yXTogU2NoZW1lIGNvbnRhaW5zIGlsbGVnYWwgY2hhcmFjdGVycy5cIik7aWYodC5wYXRoKWlmKHQuYXV0aG9yaXR5KXtpZighcy50ZXN0KHQucGF0aCkpdGhyb3cgbmV3IEVycm9yKCdbVXJpRXJyb3JdOiBJZiBhIFVSSSBjb250YWlucyBhbiBhdXRob3JpdHkgY29tcG9uZW50LCB0aGVuIHRoZSBwYXRoIGNvbXBvbmVudCBtdXN0IGVpdGhlciBiZSBlbXB0eSBvciBiZWdpbiB3aXRoIGEgc2xhc2ggKFwiL1wiKSBjaGFyYWN0ZXInKX1lbHNlIGlmKGMudGVzdCh0LnBhdGgpKXRocm93IG5ldyBFcnJvcignW1VyaUVycm9yXTogSWYgYSBVUkkgZG9lcyBub3QgY29udGFpbiBhbiBhdXRob3JpdHkgY29tcG9uZW50LCB0aGVuIHRoZSBwYXRoIGNhbm5vdCBiZWdpbiB3aXRoIHR3byBzbGFzaCBjaGFyYWN0ZXJzIChcIi8vXCIpJyl9dmFyIHU9XCJcIixsPVwiL1wiLHA9L14oKFteOi8/I10rPyk6KT8oXFwvXFwvKFteLz8jXSopKT8oW14/I10qKShcXD8oW14jXSopKT8oIyguKikpPy8sZz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxlLHIsbixvLGkpe3ZvaWQgMD09PWkmJihpPSExKSxcIm9iamVjdFwiPT10eXBlb2YgdD8odGhpcy5zY2hlbWU9dC5zY2hlbWV8fHUsdGhpcy5hdXRob3JpdHk9dC5hdXRob3JpdHl8fHUsdGhpcy5wYXRoPXQucGF0aHx8dSx0aGlzLnF1ZXJ5PXQucXVlcnl8fHUsdGhpcy5mcmFnbWVudD10LmZyYWdtZW50fHx1KToodGhpcy5zY2hlbWU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdHx8ZT90OlwiZmlsZVwifSh0LGkpLHRoaXMuYXV0aG9yaXR5PWV8fHUsdGhpcy5wYXRoPWZ1bmN0aW9uKHQsZSl7c3dpdGNoKHQpe2Nhc2VcImh0dHBzXCI6Y2FzZVwiaHR0cFwiOmNhc2VcImZpbGVcIjplP2VbMF0hPT1sJiYoZT1sK2UpOmU9bH1yZXR1cm4gZX0odGhpcy5zY2hlbWUscnx8dSksdGhpcy5xdWVyeT1ufHx1LHRoaXMuZnJhZ21lbnQ9b3x8dSxmKHRoaXMsaSkpfXJldHVybiBlLmlzVXJpPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgZXx8ISF0JiZcInN0cmluZ1wiPT10eXBlb2YgdC5hdXRob3JpdHkmJlwic3RyaW5nXCI9PXR5cGVvZiB0LmZyYWdtZW50JiZcInN0cmluZ1wiPT10eXBlb2YgdC5wYXRoJiZcInN0cmluZ1wiPT10eXBlb2YgdC5xdWVyeSYmXCJzdHJpbmdcIj09dHlwZW9mIHQuc2NoZW1lJiZcInN0cmluZ1wiPT10eXBlb2YgdC5mc1BhdGgmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQud2l0aCYmXCJmdW5jdGlvblwiPT10eXBlb2YgdC50b1N0cmluZ30sT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwiZnNQYXRoXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBDKHRoaXMsITEpfSxlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pLGUucHJvdG90eXBlLndpdGg9ZnVuY3Rpb24odCl7aWYoIXQpcmV0dXJuIHRoaXM7dmFyIGU9dC5zY2hlbWUscj10LmF1dGhvcml0eSxuPXQucGF0aCxvPXQucXVlcnksaT10LmZyYWdtZW50O3JldHVybiB2b2lkIDA9PT1lP2U9dGhpcy5zY2hlbWU6bnVsbD09PWUmJihlPXUpLHZvaWQgMD09PXI/cj10aGlzLmF1dGhvcml0eTpudWxsPT09ciYmKHI9dSksdm9pZCAwPT09bj9uPXRoaXMucGF0aDpudWxsPT09biYmKG49dSksdm9pZCAwPT09bz9vPXRoaXMucXVlcnk6bnVsbD09PW8mJihvPXUpLHZvaWQgMD09PWk/aT10aGlzLmZyYWdtZW50Om51bGw9PT1pJiYoaT11KSxlPT09dGhpcy5zY2hlbWUmJnI9PT10aGlzLmF1dGhvcml0eSYmbj09PXRoaXMucGF0aCYmbz09PXRoaXMucXVlcnkmJmk9PT10aGlzLmZyYWdtZW50P3RoaXM6bmV3IHYoZSxyLG4sbyxpKX0sZS5wYXJzZT1mdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPSExKTt2YXIgcj1wLmV4ZWModCk7cmV0dXJuIHI/bmV3IHYoclsyXXx8dSxfKHJbNF18fHUpLF8ocls1XXx8dSksXyhyWzddfHx1KSxfKHJbOV18fHUpLGUpOm5ldyB2KHUsdSx1LHUsdSl9LGUuZmlsZT1mdW5jdGlvbihlKXt2YXIgcj11O2lmKHQmJihlPWUucmVwbGFjZSgvXFxcXC9nLGwpKSxlWzBdPT09bCYmZVsxXT09PWwpe3ZhciBuPWUuaW5kZXhPZihsLDIpOy0xPT09bj8ocj1lLnN1YnN0cmluZygyKSxlPWwpOihyPWUuc3Vic3RyaW5nKDIsbiksZT1lLnN1YnN0cmluZyhuKXx8bCl9cmV0dXJuIG5ldyB2KFwiZmlsZVwiLHIsZSx1LHUpfSxlLmZyb209ZnVuY3Rpb24odCl7dmFyIGU9bmV3IHYodC5zY2hlbWUsdC5hdXRob3JpdHksdC5wYXRoLHQucXVlcnksdC5mcmFnbWVudCk7cmV0dXJuIGYoZSwhMCksZX0sZS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PSExKSxBKHRoaXMsdCl9LGUucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzfSxlLnJldml2ZT1mdW5jdGlvbih0KXtpZih0KXtpZih0IGluc3RhbmNlb2YgZSlyZXR1cm4gdDt2YXIgcj1uZXcgdih0KTtyZXR1cm4gci5fZm9ybWF0dGVkPXQuZXh0ZXJuYWwsci5fZnNQYXRoPXQuX3NlcD09PWQ/dC5mc1BhdGg6bnVsbCxyfXJldHVybiB0fSxlfSgpLGQ9dD8xOnZvaWQgMCx2PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt2YXIgZT1udWxsIT09dCYmdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXM7cmV0dXJuIGUuX2Zvcm1hdHRlZD1udWxsLGUuX2ZzUGF0aD1udWxsLGV9cmV0dXJuIGEoZSx0KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJmc1BhdGhcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2ZzUGF0aHx8KHRoaXMuX2ZzUGF0aD1DKHRoaXMsITEpKSx0aGlzLl9mc1BhdGh9LGVudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksZS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PSExKSx0P0EodGhpcywhMCk6KHRoaXMuX2Zvcm1hdHRlZHx8KHRoaXMuX2Zvcm1hdHRlZD1BKHRoaXMsITEpKSx0aGlzLl9mb3JtYXR0ZWQpfSxlLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXt2YXIgdD17JG1pZDoxfTtyZXR1cm4gdGhpcy5fZnNQYXRoJiYodC5mc1BhdGg9dGhpcy5fZnNQYXRoLHQuX3NlcD1kKSx0aGlzLl9mb3JtYXR0ZWQmJih0LmV4dGVybmFsPXRoaXMuX2Zvcm1hdHRlZCksdGhpcy5wYXRoJiYodC5wYXRoPXRoaXMucGF0aCksdGhpcy5zY2hlbWUmJih0LnNjaGVtZT10aGlzLnNjaGVtZSksdGhpcy5hdXRob3JpdHkmJih0LmF1dGhvcml0eT10aGlzLmF1dGhvcml0eSksdGhpcy5xdWVyeSYmKHQucXVlcnk9dGhpcy5xdWVyeSksdGhpcy5mcmFnbWVudCYmKHQuZnJhZ21lbnQ9dGhpcy5mcmFnbWVudCksdH0sZX0oZykseT0oKGk9e30pWzU4XT1cIiUzQVwiLGlbNDddPVwiJTJGXCIsaVs2M109XCIlM0ZcIixpWzM1XT1cIiUyM1wiLGlbOTFdPVwiJTVCXCIsaVs5M109XCIlNURcIixpWzY0XT1cIiU0MFwiLGlbMzNdPVwiJTIxXCIsaVszNl09XCIlMjRcIixpWzM4XT1cIiUyNlwiLGlbMzldPVwiJTI3XCIsaVs0MF09XCIlMjhcIixpWzQxXT1cIiUyOVwiLGlbNDJdPVwiJTJBXCIsaVs0M109XCIlMkJcIixpWzQ0XT1cIiUyQ1wiLGlbNTldPVwiJTNCXCIsaVs2MV09XCIlM0RcIixpWzMyXT1cIiUyMFwiLGkpO2Z1bmN0aW9uIG0odCxlLHIpe2Zvcih2YXIgbj12b2lkIDAsbz0tMSxpPTA7aTx0Lmxlbmd0aDtpKyspe3ZhciBhPXQuY2hhckNvZGVBdChpKTtpZihhPj05NyYmYTw9MTIyfHxhPj02NSYmYTw9OTB8fGE+PTQ4JiZhPD01N3x8NDU9PT1hfHw0Nj09PWF8fDk1PT09YXx8MTI2PT09YXx8ZSYmNDc9PT1hfHxyJiY5MT09PWF8fHImJjkzPT09YXx8ciYmNTg9PT1hKS0xIT09byYmKG4rPWVuY29kZVVSSUNvbXBvbmVudCh0LnN1YnN0cmluZyhvLGkpKSxvPS0xKSx2b2lkIDAhPT1uJiYobis9dC5jaGFyQXQoaSkpO2Vsc2V7dm9pZCAwPT09biYmKG49dC5zdWJzdHIoMCxpKSk7dmFyIGg9eVthXTt2b2lkIDAhPT1oPygtMSE9PW8mJihuKz1lbmNvZGVVUklDb21wb25lbnQodC5zdWJzdHJpbmcobyxpKSksbz0tMSksbis9aCk6LTE9PT1vJiYobz1pKX19cmV0dXJuLTEhPT1vJiYobis9ZW5jb2RlVVJJQ29tcG9uZW50KHQuc3Vic3RyaW5nKG8pKSksdm9pZCAwIT09bj9uOnR9ZnVuY3Rpb24gYih0KXtmb3IodmFyIGU9dm9pZCAwLHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIG49dC5jaGFyQ29kZUF0KHIpOzM1PT09bnx8NjM9PT1uPyh2b2lkIDA9PT1lJiYoZT10LnN1YnN0cigwLHIpKSxlKz15W25dKTp2b2lkIDAhPT1lJiYoZSs9dFtyXSl9cmV0dXJuIHZvaWQgMCE9PWU/ZTp0fWZ1bmN0aW9uIEMoZSxyKXt2YXIgbjtyZXR1cm4gbj1lLmF1dGhvcml0eSYmZS5wYXRoLmxlbmd0aD4xJiZcImZpbGVcIj09PWUuc2NoZW1lP1wiLy9cIi5jb25jYXQoZS5hdXRob3JpdHkpLmNvbmNhdChlLnBhdGgpOjQ3PT09ZS5wYXRoLmNoYXJDb2RlQXQoMCkmJihlLnBhdGguY2hhckNvZGVBdCgxKT49NjUmJmUucGF0aC5jaGFyQ29kZUF0KDEpPD05MHx8ZS5wYXRoLmNoYXJDb2RlQXQoMSk+PTk3JiZlLnBhdGguY2hhckNvZGVBdCgxKTw9MTIyKSYmNTg9PT1lLnBhdGguY2hhckNvZGVBdCgyKT9yP2UucGF0aC5zdWJzdHIoMSk6ZS5wYXRoWzFdLnRvTG93ZXJDYXNlKCkrZS5wYXRoLnN1YnN0cigyKTplLnBhdGgsdCYmKG49bi5yZXBsYWNlKC9cXC8vZyxcIlxcXFxcIikpLG59ZnVuY3Rpb24gQSh0LGUpe3ZhciByPWU/YjptLG49XCJcIixvPXQuc2NoZW1lLGk9dC5hdXRob3JpdHksYT10LnBhdGgsaD10LnF1ZXJ5LHM9dC5mcmFnbWVudDtpZihvJiYobis9byxuKz1cIjpcIiksKGl8fFwiZmlsZVwiPT09bykmJihuKz1sLG4rPWwpLGkpe3ZhciBjPWkuaW5kZXhPZihcIkBcIik7aWYoLTEhPT1jKXt2YXIgZj1pLnN1YnN0cigwLGMpO2k9aS5zdWJzdHIoYysxKSwtMT09PShjPWYubGFzdEluZGV4T2YoXCI6XCIpKT9uKz1yKGYsITEsITEpOihuKz1yKGYuc3Vic3RyKDAsYyksITEsITEpLG4rPVwiOlwiLG4rPXIoZi5zdWJzdHIoYysxKSwhMSwhMCkpLG4rPVwiQFwifS0xPT09KGM9KGk9aS50b0xvd2VyQ2FzZSgpKS5sYXN0SW5kZXhPZihcIjpcIikpP24rPXIoaSwhMSwhMCk6KG4rPXIoaS5zdWJzdHIoMCxjKSwhMSwhMCksbis9aS5zdWJzdHIoYykpfWlmKGEpe2lmKGEubGVuZ3RoPj0zJiY0Nz09PWEuY2hhckNvZGVBdCgwKSYmNTg9PT1hLmNoYXJDb2RlQXQoMikpKHU9YS5jaGFyQ29kZUF0KDEpKT49NjUmJnU8PTkwJiYoYT1cIi9cIi5jb25jYXQoU3RyaW5nLmZyb21DaGFyQ29kZSh1KzMyKSxcIjpcIikuY29uY2F0KGEuc3Vic3RyKDMpKSk7ZWxzZSBpZihhLmxlbmd0aD49MiYmNTg9PT1hLmNoYXJDb2RlQXQoMSkpe3ZhciB1Oyh1PWEuY2hhckNvZGVBdCgwKSk+PTY1JiZ1PD05MCYmKGE9XCJcIi5jb25jYXQoU3RyaW5nLmZyb21DaGFyQ29kZSh1KzMyKSxcIjpcIikuY29uY2F0KGEuc3Vic3RyKDIpKSl9bis9cihhLCEwLCExKX1yZXR1cm4gaCYmKG4rPVwiP1wiLG4rPXIoaCwhMSwhMSkpLHMmJihuKz1cIiNcIixuKz1lP3M6bShzLCExLCExKSksbn1mdW5jdGlvbiB3KHQpe3RyeXtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHQpfWNhdGNoKGUpe3JldHVybiB0Lmxlbmd0aD4zP3Quc3Vic3RyKDAsMykrdyh0LnN1YnN0cigzKSk6dH19dmFyIHg9LyglWzAtOUEtWmEtel1bMC05QS1aYS16XSkrL2c7ZnVuY3Rpb24gXyh0KXtyZXR1cm4gdC5tYXRjaCh4KT90LnJlcGxhY2UoeCwoZnVuY3Rpb24odCl7cmV0dXJuIHcodCl9KSk6dH12YXIgTyxQPXIoNDcwKSxqPWZ1bmN0aW9uKHQsZSxyKXtpZihyfHwyPT09YXJndW1lbnRzLmxlbmd0aClmb3IodmFyIG4sbz0wLGk9ZS5sZW5ndGg7bzxpO28rKykhbiYmbyBpbiBlfHwobnx8KG49QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZSwwLG8pKSxuW29dPWVbb10pO3JldHVybiB0LmNvbmNhdChufHxBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlKSl9LEk9UC5wb3NpeHx8UCxVPVwiL1wiOyFmdW5jdGlvbih0KXt0LmpvaW5QYXRoPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxyPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyllW3ItMV09YXJndW1lbnRzW3JdO3JldHVybiB0LndpdGgoe3BhdGg6SS5qb2luLmFwcGx5KEksaihbdC5wYXRoXSxlLCExKSl9KX0sdC5yZXNvbHZlUGF0aD1mdW5jdGlvbih0KXtmb3IodmFyIGU9W10scj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspZVtyLTFdPWFyZ3VtZW50c1tyXTt2YXIgbj10LnBhdGgsbz0hMTtuWzBdIT09VSYmKG49VStuLG89ITApO3ZhciBpPUkucmVzb2x2ZS5hcHBseShJLGooW25dLGUsITEpKTtyZXR1cm4gbyYmaVswXT09PVUmJiF0LmF1dGhvcml0eSYmKGk9aS5zdWJzdHJpbmcoMSkpLHQud2l0aCh7cGF0aDppfSl9LHQuZGlybmFtZT1mdW5jdGlvbih0KXtpZigwPT09dC5wYXRoLmxlbmd0aHx8dC5wYXRoPT09VSlyZXR1cm4gdDt2YXIgZT1JLmRpcm5hbWUodC5wYXRoKTtyZXR1cm4gMT09PWUubGVuZ3RoJiY0Nj09PWUuY2hhckNvZGVBdCgwKSYmKGU9XCJcIiksdC53aXRoKHtwYXRoOmV9KX0sdC5iYXNlbmFtZT1mdW5jdGlvbih0KXtyZXR1cm4gSS5iYXNlbmFtZSh0LnBhdGgpfSx0LmV4dG5hbWU9ZnVuY3Rpb24odCl7cmV0dXJuIEkuZXh0bmFtZSh0LnBhdGgpfX0oT3x8KE89e30pKX0pKCksTElCPW59KSgpO2NvbnN0e1VSSSxVdGlsc309TElCO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL3V0aWxzL2dsb2IuanNcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgQ29weXJpZ2h0IChjKSAyMDEzLCBOaWNrIEZpdHpnZXJhbGRcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMSUNFTkNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlZ2V4KGdsb2IsIG9wdHMpIHtcbiAgICBpZiAodHlwZW9mIGdsb2IgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHN0ciA9IFN0cmluZyhnbG9iKTtcbiAgICAvLyBUaGUgcmVnZXhwIHdlIGFyZSBidWlsZGluZywgYXMgYSBzdHJpbmcuXG4gICAgbGV0IHJlU3RyID0gXCJcIjtcbiAgICAvLyBXaGV0aGVyIHdlIGFyZSBtYXRjaGluZyBzbyBjYWxsZWQgXCJleHRlbmRlZFwiIGdsb2JzIChsaWtlIGJhc2gpIGFuZCBzaG91bGRcbiAgICAvLyBzdXBwb3J0IHNpbmdsZSBjaGFyYWN0ZXIgbWF0Y2hpbmcsIG1hdGNoaW5nIHJhbmdlcyBvZiBjaGFyYWN0ZXJzLCBncm91cFxuICAgIC8vIG1hdGNoaW5nLCBldGMuXG4gICAgY29uc3QgZXh0ZW5kZWQgPSBvcHRzID8gISFvcHRzLmV4dGVuZGVkIDogZmFsc2U7XG4gICAgLy8gV2hlbiBnbG9ic3RhciBpcyBfZmFsc2VfIChkZWZhdWx0KSwgJy9mb28vKicgaXMgdHJhbnNsYXRlZCBhIHJlZ2V4cCBsaWtlXG4gICAgLy8gJ15cXC9mb29cXC8uKiQnIHdoaWNoIHdpbGwgbWF0Y2ggYW55IHN0cmluZyBiZWdpbm5pbmcgd2l0aCAnL2Zvby8nXG4gICAgLy8gV2hlbiBnbG9ic3RhciBpcyBfdHJ1ZV8sICcvZm9vLyonIGlzIHRyYW5zbGF0ZWQgdG8gcmVnZXhwIGxpa2VcbiAgICAvLyAnXlxcL2Zvb1xcL1teL10qJCcgd2hpY2ggd2lsbCBtYXRjaCBhbnkgc3RyaW5nIGJlZ2lubmluZyB3aXRoICcvZm9vLycgQlVUXG4gICAgLy8gd2hpY2ggZG9lcyBub3QgaGF2ZSBhICcvJyB0byB0aGUgcmlnaHQgb2YgaXQuXG4gICAgLy8gRS5nLiB3aXRoICcvZm9vLyonIHRoZXNlIHdpbGwgbWF0Y2g6ICcvZm9vL2JhcicsICcvZm9vL2Jhci50eHQnIGJ1dFxuICAgIC8vIHRoZXNlIHdpbGwgbm90ICcvZm9vL2Jhci9iYXonLCAnL2Zvby9iYXIvYmF6LnR4dCdcbiAgICAvLyBMYXN0ZWx5LCB3aGVuIGdsb2JzdGFyIGlzIF90cnVlXywgJy9mb28vKionIGlzIGVxdWl2ZWxhbnQgdG8gJy9mb28vKicgd2hlblxuICAgIC8vIGdsb2JzdGFyIGlzIF9mYWxzZV9cbiAgICBjb25zdCBnbG9ic3RhciA9IG9wdHMgPyAhIW9wdHMuZ2xvYnN0YXIgOiBmYWxzZTtcbiAgICAvLyBJZiB3ZSBhcmUgZG9pbmcgZXh0ZW5kZWQgbWF0Y2hpbmcsIHRoaXMgYm9vbGVhbiBpcyB0cnVlIHdoZW4gd2UgYXJlIGluc2lkZVxuICAgIC8vIGEgZ3JvdXAgKGVnIHsqLmh0bWwsKi5qc30pLCBhbmQgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgIGxldCBpbkdyb3VwID0gZmFsc2U7XG4gICAgLy8gUmVnRXhwIGZsYWdzIChlZyBcImlcIiApIHRvIHBhc3MgaW4gdG8gUmVnRXhwIGNvbnN0cnVjdG9yLlxuICAgIGNvbnN0IGZsYWdzID0gb3B0cyAmJiB0eXBlb2YgKG9wdHMuZmxhZ3MpID09PSBcInN0cmluZ1wiID8gb3B0cy5mbGFncyA6IFwiXCI7XG4gICAgbGV0IGM7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjID0gc3RyW2ldO1xuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgIGNhc2UgXCIvXCI6XG4gICAgICAgICAgICBjYXNlIFwiJFwiOlxuICAgICAgICAgICAgY2FzZSBcIl5cIjpcbiAgICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICBjYXNlIFwiLlwiOlxuICAgICAgICAgICAgY2FzZSBcIihcIjpcbiAgICAgICAgICAgIGNhc2UgXCIpXCI6XG4gICAgICAgICAgICBjYXNlIFwiPVwiOlxuICAgICAgICAgICAgY2FzZSBcIiFcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ8XCI6XG4gICAgICAgICAgICAgICAgcmVTdHIgKz0gXCJcXFxcXCIgKyBjO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIj9cIjpcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVTdHIgKz0gXCIuXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJbXCI6XG4gICAgICAgICAgICBjYXNlIFwiXVwiOlxuICAgICAgICAgICAgICAgIGlmIChleHRlbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZVN0ciArPSBjO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwie1wiOlxuICAgICAgICAgICAgICAgIGlmIChleHRlbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpbkdyb3VwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmVTdHIgKz0gXCIoXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ9XCI6XG4gICAgICAgICAgICAgICAgaWYgKGV4dGVuZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGluR3JvdXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmVTdHIgKz0gXCIpXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCIsXCI6XG4gICAgICAgICAgICAgICAgaWYgKGluR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVTdHIgKz0gXCJ8XCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZVN0ciArPSBcIlxcXFxcIiArIGM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgICAgICAgIC8vIE1vdmUgb3ZlciBhbGwgY29uc2VjdXRpdmUgXCIqXCIncy5cbiAgICAgICAgICAgICAgICAvLyBBbHNvIHN0b3JlIHRoZSBwcmV2aW91cyBhbmQgbmV4dCBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkNoYXIgPSBzdHJbaSAtIDFdO1xuICAgICAgICAgICAgICAgIGxldCBzdGFyQ291bnQgPSAxO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHJbaSArIDFdID09PSBcIipcIikge1xuICAgICAgICAgICAgICAgICAgICBzdGFyQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hhciA9IHN0cltpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKCFnbG9ic3Rhcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBnbG9ic3RhciBpcyBkaXNhYmxlZCwgc28gdHJlYXQgYW55IG51bWJlciBvZiBcIipcIiBhcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgcmVTdHIgKz0gXCIuKlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2xvYnN0YXIgaXMgZW5hYmxlZCwgc28gZGV0ZXJtaW5lIGlmIHRoaXMgaXMgYSBnbG9ic3RhciBzZWdtZW50XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzR2xvYnN0YXIgPSBzdGFyQ291bnQgPiAxIC8vIG11bHRpcGxlIFwiKlwiJ3NcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIChwcmV2Q2hhciA9PT0gXCIvXCIgfHwgcHJldkNoYXIgPT09IHVuZGVmaW5lZCB8fCBwcmV2Q2hhciA9PT0gJ3snIHx8IHByZXZDaGFyID09PSAnLCcpIC8vIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBzZWdtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAobmV4dENoYXIgPT09IFwiL1wiIHx8IG5leHRDaGFyID09PSB1bmRlZmluZWQgfHwgbmV4dENoYXIgPT09ICcsJyB8fCBuZXh0Q2hhciA9PT0gJ30nKTsgLy8gdG8gdGhlIGVuZCBvZiB0aGUgc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNHbG9ic3Rhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID09PSBcIi9cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkrKzsgLy8gbW92ZSBvdmVyIHRoZSBcIi9cIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocHJldkNoYXIgPT09ICcvJyAmJiByZVN0ci5lbmRzV2l0aCgnXFxcXC8nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlU3RyID0gcmVTdHIuc3Vic3RyKDAsIHJlU3RyLmxlbmd0aCAtIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBhIGdsb2JzdGFyLCBzbyBtYXRjaCB6ZXJvIG9yIG1vcmUgcGF0aCBzZWdtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVTdHIgKz0gXCIoKD86W14vXSooPzpcXC98JCkpKilcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0J3Mgbm90IGEgZ2xvYnN0YXIsIHNvIG9ubHkgbWF0Y2ggb25lIHBhdGggc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVTdHIgKz0gXCIoW14vXSopXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlU3RyICs9IGM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gV2hlbiByZWdleHAgJ2cnIGZsYWcgaXMgc3BlY2lmaWVkIGRvbid0XG4gICAgLy8gY29uc3RyYWluIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gd2l0aCBeICYgJFxuICAgIGlmICghZmxhZ3MgfHwgIX5mbGFncy5pbmRleE9mKCdnJykpIHtcbiAgICAgICAgcmVTdHIgPSBcIl5cIiArIHJlU3RyICsgXCIkXCI7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVnRXhwKHJlU3RyLCBmbGFncyk7XG59XG47XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL2xpYi9lc20vc2VydmljZXMvanNvblNjaGVtYVNlcnZpY2UuanNcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblxuXG5cblxuXG5jb25zdCBCQU5HID0gJyEnO1xuY29uc3QgUEFUSF9TRVAgPSAnLyc7XG5jbGFzcyBGaWxlUGF0dGVybkFzc29jaWF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJuLCBmb2xkZXJVcmksIHVyaXMpIHtcbiAgICAgICAgdGhpcy5mb2xkZXJVcmkgPSBmb2xkZXJVcmk7XG4gICAgICAgIHRoaXMudXJpcyA9IHVyaXM7XG4gICAgICAgIHRoaXMuZ2xvYldyYXBwZXJzID0gW107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwYXR0ZXJuU3RyaW5nIG9mIHBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmNsdWRlID0gcGF0dGVyblN0cmluZ1swXSAhPT0gQkFORztcbiAgICAgICAgICAgICAgICBpZiAoIWluY2x1ZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVyblN0cmluZyA9IHBhdHRlcm5TdHJpbmcuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGF0dGVyblN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuU3RyaW5nWzBdID09PSBQQVRIX1NFUCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVyblN0cmluZyA9IHBhdHRlcm5TdHJpbmcuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2xvYldyYXBwZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhwOiBjcmVhdGVSZWdleCgnKiovJyArIHBhdHRlcm5TdHJpbmcsIHsgZXh0ZW5kZWQ6IHRydWUsIGdsb2JzdGFyOiB0cnVlIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZTogaW5jbHVkZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgaWYgKGZvbGRlclVyaSkge1xuICAgICAgICAgICAgICAgIGZvbGRlclVyaSA9IG5vcm1hbGl6ZVJlc291cmNlRm9yTWF0Y2hpbmcoZm9sZGVyVXJpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZvbGRlclVyaS5lbmRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbGRlclVyaSA9IGZvbGRlclVyaSArICcvJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5mb2xkZXJVcmkgPSBmb2xkZXJVcmk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYldyYXBwZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLnVyaXMgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXRjaGVzUGF0dGVybihmaWxlTmFtZSkge1xuICAgICAgICBpZiAodGhpcy5mb2xkZXJVcmkgJiYgIWZpbGVOYW1lLnN0YXJ0c1dpdGgodGhpcy5mb2xkZXJVcmkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1hdGNoID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgeyByZWdleHAsIGluY2x1ZGUgfSBvZiB0aGlzLmdsb2JXcmFwcGVycykge1xuICAgICAgICAgICAgaWYgKHJlZ2V4cC50ZXN0KGZpbGVOYW1lKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gaW5jbHVkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuICAgIGdldFVSSXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVyaXM7XG4gICAgfVxufVxuY2xhc3MgU2NoZW1hSGFuZGxlIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlLCB1cmksIHVucmVzb2x2ZWRTY2hlbWFDb250ZW50KSB7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgICAgIHRoaXMudXJpID0gdXJpO1xuICAgICAgICB0aGlzLmRlcGVuZGVuY2llcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5hbmNob3JzID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodW5yZXNvbHZlZFNjaGVtYUNvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMudW5yZXNvbHZlZFNjaGVtYSA9IHRoaXMuc2VydmljZS5wcm9taXNlLnJlc29sdmUobmV3IFVucmVzb2x2ZWRTY2hlbWEodW5yZXNvbHZlZFNjaGVtYUNvbnRlbnQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRVbnJlc29sdmVkU2NoZW1hKCkge1xuICAgICAgICBpZiAoIXRoaXMudW5yZXNvbHZlZFNjaGVtYSkge1xuICAgICAgICAgICAgdGhpcy51bnJlc29sdmVkU2NoZW1hID0gdGhpcy5zZXJ2aWNlLmxvYWRTY2hlbWEodGhpcy51cmkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnVucmVzb2x2ZWRTY2hlbWE7XG4gICAgfVxuICAgIGdldFJlc29sdmVkU2NoZW1hKCkge1xuICAgICAgICBpZiAoIXRoaXMucmVzb2x2ZWRTY2hlbWEpIHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZWRTY2hlbWEgPSB0aGlzLmdldFVucmVzb2x2ZWRTY2hlbWEoKS50aGVuKHVucmVzb2x2ZWQgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcnZpY2UucmVzb2x2ZVNjaGVtYUNvbnRlbnQodW5yZXNvbHZlZCwgdGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlZFNjaGVtYTtcbiAgICB9XG4gICAgY2xlYXJTY2hlbWEoKSB7XG4gICAgICAgIGNvbnN0IGhhc0NoYW5nZXMgPSAhIXRoaXMudW5yZXNvbHZlZFNjaGVtYTtcbiAgICAgICAgdGhpcy5yZXNvbHZlZFNjaGVtYSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy51bnJlc29sdmVkU2NoZW1hID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmRlcGVuZGVuY2llcy5jbGVhcigpO1xuICAgICAgICB0aGlzLmFuY2hvcnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBoYXNDaGFuZ2VzO1xuICAgIH1cbn1cbmNsYXNzIFVucmVzb2x2ZWRTY2hlbWEge1xuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSwgZXJyb3JzID0gW10pIHtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIH1cbn1cbmNsYXNzIFJlc29sdmVkU2NoZW1hIHtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEsIGVycm9ycyA9IFtdLCB3YXJuaW5ncyA9IFtdLCBzY2hlbWFEcmFmdCkge1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHRoaXMud2FybmluZ3MgPSB3YXJuaW5ncztcbiAgICAgICAgdGhpcy5zY2hlbWFEcmFmdCA9IHNjaGVtYURyYWZ0O1xuICAgIH1cbiAgICBnZXRTZWN0aW9uKHBhdGgpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hUmVmID0gdGhpcy5nZXRTZWN0aW9uUmVjdXJzaXZlKHBhdGgsIHRoaXMuc2NoZW1hKTtcbiAgICAgICAgaWYgKHNjaGVtYVJlZikge1xuICAgICAgICAgICAgcmV0dXJuIGFzU2NoZW1hKHNjaGVtYVJlZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0U2VjdGlvblJlY3Vyc2l2ZShwYXRoLCBzY2hlbWEpIHtcbiAgICAgICAgaWYgKCFzY2hlbWEgfHwgdHlwZW9mIHNjaGVtYSA9PT0gJ2Jvb2xlYW4nIHx8IHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHQgPSBwYXRoLnNoaWZ0KCk7XG4gICAgICAgIGlmIChzY2hlbWEucHJvcGVydGllcyAmJiB0eXBlb2Ygc2NoZW1hLnByb3BlcnRpZXNbbmV4dF0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNlY3Rpb25SZWN1cnNpdmUocGF0aCwgc2NoZW1hLnByb3BlcnRpZXNbbmV4dF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIE9iamVjdC5rZXlzKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IGV4dGVuZGVkUmVnRXhwKHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgIGlmIChyZWdleD8udGVzdChuZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTZWN0aW9uUmVjdXJzaXZlKHBhdGgsIHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllc1twYXR0ZXJuXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTZWN0aW9uUmVjdXJzaXZlKHBhdGgsIHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV4dC5tYXRjaCgnWzAtOV0rJykpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5pdGVtcykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHBhcnNlSW50KG5leHQsIDEwKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKGluZGV4KSAmJiBzY2hlbWEuaXRlbXNbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNlY3Rpb25SZWN1cnNpdmUocGF0aCwgc2NoZW1hLml0ZW1zW2luZGV4XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2NoZW1hLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VjdGlvblJlY3Vyc2l2ZShwYXRoLCBzY2hlbWEuaXRlbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuY2xhc3MgSlNPTlNjaGVtYVNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKHJlcXVlc3RTZXJ2aWNlLCBjb250ZXh0U2VydmljZSwgcHJvbWlzZUNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHRoaXMuY29udGV4dFNlcnZpY2UgPSBjb250ZXh0U2VydmljZTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0U2VydmljZSA9IHJlcXVlc3RTZXJ2aWNlO1xuICAgICAgICB0aGlzLnByb21pc2VDb25zdHJ1Y3RvciA9IHByb21pc2VDb25zdHJ1Y3RvciB8fCBQcm9taXNlO1xuICAgICAgICB0aGlzLmNhbGxPbkRpc3Bvc2UgPSBbXTtcbiAgICAgICAgdGhpcy5jb250cmlidXRpb25TY2hlbWFzID0ge307XG4gICAgICAgIHRoaXMuY29udHJpYnV0aW9uQXNzb2NpYXRpb25zID0gW107XG4gICAgICAgIHRoaXMuc2NoZW1hc0J5SWQgPSB7fTtcbiAgICAgICAgdGhpcy5maWxlUGF0dGVybkFzc29jaWF0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRTY2hlbWFzSWRzID0ge307XG4gICAgfVxuICAgIGdldFJlZ2lzdGVyZWRTY2hlbWFJZHMoZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnJlZ2lzdGVyZWRTY2hlbWFzSWRzKS5maWx0ZXIoaWQgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1lID0gVVJJLnBhcnNlKGlkKS5zY2hlbWU7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1lICE9PSAnc2NoZW1hc2VydmljZScgJiYgKCFmaWx0ZXIgfHwgZmlsdGVyKHNjaGVtZSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IHByb21pc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb21pc2VDb25zdHJ1Y3RvcjtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY2FsbE9uRGlzcG9zZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxPbkRpc3Bvc2UucG9wKCkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvblJlc291cmNlQ2hhbmdlKHVyaSkge1xuICAgICAgICAvLyBhbHdheXMgY2xlYXIgdGhpcyBsb2NhbCBjYWNoZSB3aGVuIGEgcmVzb3VyY2UgY2hhbmdlc1xuICAgICAgICB0aGlzLmNhY2hlZFNjaGVtYUZvclJlc291cmNlID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgaGFzQ2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICB1cmkgPSBub3JtYWxpemVJZCh1cmkpO1xuICAgICAgICBjb25zdCB0b1dhbGsgPSBbdXJpXTtcbiAgICAgICAgY29uc3QgYWxsID0gT2JqZWN0LmtleXModGhpcy5zY2hlbWFzQnlJZCkubWFwKGtleSA9PiB0aGlzLnNjaGVtYXNCeUlkW2tleV0pO1xuICAgICAgICB3aGlsZSAodG9XYWxrLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgY3VyciA9IHRvV2Fsay5wb3AoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gYWxsW2ldO1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGUgJiYgKGhhbmRsZS51cmkgPT09IGN1cnIgfHwgaGFuZGxlLmRlcGVuZGVuY2llcy5oYXMoY3VycikpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGUudXJpICE9PSBjdXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1dhbGsucHVzaChoYW5kbGUudXJpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlLmNsZWFyU2NoZW1hKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFsbFtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhc0NoYW5nZXM7XG4gICAgfVxuICAgIHNldFNjaGVtYUNvbnRyaWJ1dGlvbnMoc2NoZW1hQ29udHJpYnV0aW9ucykge1xuICAgICAgICBpZiAoc2NoZW1hQ29udHJpYnV0aW9ucy5zY2hlbWFzKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWFzID0gc2NoZW1hQ29udHJpYnV0aW9ucy5zY2hlbWFzO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpZCBpbiBzY2hlbWFzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkID0gbm9ybWFsaXplSWQoaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udHJpYnV0aW9uU2NoZW1hc1tub3JtYWxpemVkSWRdID0gdGhpcy5hZGRTY2hlbWFIYW5kbGUobm9ybWFsaXplZElkLCBzY2hlbWFzW2lkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hQ29udHJpYnV0aW9ucy5zY2hlbWFBc3NvY2lhdGlvbnMpKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWFBc3NvY2lhdGlvbnMgPSBzY2hlbWFDb250cmlidXRpb25zLnNjaGVtYUFzc29jaWF0aW9ucztcbiAgICAgICAgICAgIGZvciAobGV0IHNjaGVtYUFzc29jaWF0aW9uIG9mIHNjaGVtYUFzc29jaWF0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVyaXMgPSBzY2hlbWFBc3NvY2lhdGlvbi51cmlzLm1hcChub3JtYWxpemVJZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYXNzb2NpYXRpb24gPSB0aGlzLmFkZEZpbGVQYXR0ZXJuQXNzb2NpYXRpb24oc2NoZW1hQXNzb2NpYXRpb24ucGF0dGVybiwgc2NoZW1hQXNzb2NpYXRpb24uZm9sZGVyVXJpLCB1cmlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyaWJ1dGlvbkFzc29jaWF0aW9ucy5wdXNoKGFzc29jaWF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRTY2hlbWFIYW5kbGUoaWQsIHVucmVzb2x2ZWRTY2hlbWFDb250ZW50KSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYUhhbmRsZSA9IG5ldyBTY2hlbWFIYW5kbGUodGhpcywgaWQsIHVucmVzb2x2ZWRTY2hlbWFDb250ZW50KTtcbiAgICAgICAgdGhpcy5zY2hlbWFzQnlJZFtpZF0gPSBzY2hlbWFIYW5kbGU7XG4gICAgICAgIHJldHVybiBzY2hlbWFIYW5kbGU7XG4gICAgfVxuICAgIGdldE9yQWRkU2NoZW1hSGFuZGxlKGlkLCB1bnJlc29sdmVkU2NoZW1hQ29udGVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2hlbWFzQnlJZFtpZF0gfHwgdGhpcy5hZGRTY2hlbWFIYW5kbGUoaWQsIHVucmVzb2x2ZWRTY2hlbWFDb250ZW50KTtcbiAgICB9XG4gICAgYWRkRmlsZVBhdHRlcm5Bc3NvY2lhdGlvbihwYXR0ZXJuLCBmb2xkZXJVcmksIHVyaXMpIHtcbiAgICAgICAgY29uc3QgZnBhID0gbmV3IEZpbGVQYXR0ZXJuQXNzb2NpYXRpb24ocGF0dGVybiwgZm9sZGVyVXJpLCB1cmlzKTtcbiAgICAgICAgdGhpcy5maWxlUGF0dGVybkFzc29jaWF0aW9ucy5wdXNoKGZwYSk7XG4gICAgICAgIHJldHVybiBmcGE7XG4gICAgfVxuICAgIHJlZ2lzdGVyRXh0ZXJuYWxTY2hlbWEoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGlkID0gbm9ybWFsaXplSWQoY29uZmlnLnVyaSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZFNjaGVtYXNJZHNbaWRdID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jYWNoZWRTY2hlbWFGb3JSZXNvdXJjZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGNvbmZpZy5maWxlTWF0Y2ggJiYgY29uZmlnLmZpbGVNYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRmlsZVBhdHRlcm5Bc3NvY2lhdGlvbihjb25maWcuZmlsZU1hdGNoLCBjb25maWcuZm9sZGVyVXJpLCBbaWRdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uZmlnLnNjaGVtYSA/IHRoaXMuYWRkU2NoZW1hSGFuZGxlKGlkLCBjb25maWcuc2NoZW1hKSA6IHRoaXMuZ2V0T3JBZGRTY2hlbWFIYW5kbGUoaWQpO1xuICAgIH1cbiAgICBjbGVhckV4dGVybmFsU2NoZW1hcygpIHtcbiAgICAgICAgdGhpcy5zY2hlbWFzQnlJZCA9IHt9O1xuICAgICAgICB0aGlzLmZpbGVQYXR0ZXJuQXNzb2NpYXRpb25zID0gW107XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZFNjaGVtYXNJZHMgPSB7fTtcbiAgICAgICAgdGhpcy5jYWNoZWRTY2hlbWFGb3JSZXNvdXJjZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBpZCBpbiB0aGlzLmNvbnRyaWJ1dGlvblNjaGVtYXMpIHtcbiAgICAgICAgICAgIHRoaXMuc2NoZW1hc0J5SWRbaWRdID0gdGhpcy5jb250cmlidXRpb25TY2hlbWFzW2lkXTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZFNjaGVtYXNJZHNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGNvbnRyaWJ1dGlvbkFzc29jaWF0aW9uIG9mIHRoaXMuY29udHJpYnV0aW9uQXNzb2NpYXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmZpbGVQYXR0ZXJuQXNzb2NpYXRpb25zLnB1c2goY29udHJpYnV0aW9uQXNzb2NpYXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFJlc29sdmVkU2NoZW1hKHNjaGVtYUlkKSB7XG4gICAgICAgIGNvbnN0IGlkID0gbm9ybWFsaXplSWQoc2NoZW1hSWQpO1xuICAgICAgICBjb25zdCBzY2hlbWFIYW5kbGUgPSB0aGlzLnNjaGVtYXNCeUlkW2lkXTtcbiAgICAgICAgaWYgKHNjaGVtYUhhbmRsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYUhhbmRsZS5nZXRSZXNvbHZlZFNjaGVtYSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIH1cbiAgICBsb2FkU2NoZW1hKHVybCkge1xuICAgICAgICBpZiAoIXRoaXMucmVxdWVzdFNlcnZpY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHQoJ1VuYWJsZSB0byBsb2FkIHNjaGVtYSBmcm9tIFxcJ3swfVxcJy4gTm8gc2NoZW1hIHJlcXVlc3Qgc2VydmljZSBhdmFpbGFibGUnLCB0b0Rpc3BsYXlTdHJpbmcodXJsKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlLnJlc29sdmUobmV3IFVucmVzb2x2ZWRTY2hlbWEoe30sIFtlcnJvck1lc3NhZ2VdKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFNlcnZpY2UodXJsKS50aGVuKGNvbnRlbnQgPT4ge1xuICAgICAgICAgICAgaWYgKCFjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gdCgnVW5hYmxlIHRvIGxvYWQgc2NoZW1hIGZyb20gXFwnezB9XFwnOiBObyBjb250ZW50LicsIHRvRGlzcGxheVN0cmluZyh1cmwpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVucmVzb2x2ZWRTY2hlbWEoe30sIFtlcnJvck1lc3NhZ2VdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICAgICAgaWYgKGNvbnRlbnQuY2hhckNvZGVBdCgwKSA9PT0gNjUyNzkpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh0KCdQcm9ibGVtIHJlYWRpbmcgY29udGVudCBmcm9tIFxcJ3swfVxcJzogVVRGLTggd2l0aCBCT00gZGV0ZWN0ZWQsIG9ubHkgVVRGIDggaXMgYWxsb3dlZC4nLCB0b0Rpc3BsYXlTdHJpbmcodXJsKSkpO1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnRyaW1TdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNjaGVtYUNvbnRlbnQgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGpzb25FcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIHNjaGVtYUNvbnRlbnQgPSBtYWluX3BhcnNlKGNvbnRlbnQsIGpzb25FcnJvcnMpO1xuICAgICAgICAgICAgaWYgKGpzb25FcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2godCgnVW5hYmxlIHRvIHBhcnNlIGNvbnRlbnQgZnJvbSBcXCd7MH1cXCc6IFBhcnNlIGVycm9yIGF0IG9mZnNldCB7MX0uJywgdG9EaXNwbGF5U3RyaW5nKHVybCksIGpzb25FcnJvcnNbMF0ub2Zmc2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVucmVzb2x2ZWRTY2hlbWEoc2NoZW1hQ29udGVudCwgZXJyb3JzKTtcbiAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gZXJyb3IudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yU3BsaXQgPSBlcnJvci50b1N0cmluZygpLnNwbGl0KCdFcnJvcjogJyk7XG4gICAgICAgICAgICBpZiAoZXJyb3JTcGxpdC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gbW9yZSBjb25jaXNlIGVycm9yIG1lc3NhZ2UsIFVSTCBhbmQgY29udGV4dCBhcmUgYXR0YWNoZWQgYnkgY2FsbGVyIGFueXdheXNcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvclNwbGl0WzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZHNXaXRoKGVycm9yTWVzc2FnZSwgJy4nKSkge1xuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yTWVzc2FnZS5zdWJzdHIoMCwgZXJyb3JNZXNzYWdlLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVbnJlc29sdmVkU2NoZW1hKHt9LCBbdCgnVW5hYmxlIHRvIGxvYWQgc2NoZW1hIGZyb20gXFwnezB9XFwnOiB7MX0uJywgdG9EaXNwbGF5U3RyaW5nKHVybCksIGVycm9yTWVzc2FnZSldKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc29sdmVTY2hlbWFDb250ZW50KHNjaGVtYVRvUmVzb2x2ZSwgaGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVFcnJvcnMgPSBzY2hlbWFUb1Jlc29sdmUuZXJyb3JzLnNsaWNlKDApO1xuICAgICAgICBjb25zdCBzY2hlbWEgPSBzY2hlbWFUb1Jlc29sdmUuc2NoZW1hO1xuICAgICAgICBsZXQgc2NoZW1hRHJhZnQgPSBzY2hlbWEuJHNjaGVtYSA/IG5vcm1hbGl6ZUlkKHNjaGVtYS4kc2NoZW1hKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHNjaGVtYURyYWZ0ID09PSAnaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wMy9zY2hlbWEnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlLnJlc29sdmUobmV3IFJlc29sdmVkU2NoZW1hKHt9LCBbdChcIkRyYWZ0LTAzIHNjaGVtYXMgYXJlIG5vdCBzdXBwb3J0ZWQuXCIpXSwgW10sIHNjaGVtYURyYWZ0KSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHVzZXNVbnN1cHBvcnRlZEZlYXR1cmVzID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBjb250ZXh0U2VydmljZSA9IHRoaXMuY29udGV4dFNlcnZpY2U7XG4gICAgICAgIGNvbnN0IGZpbmRTZWN0aW9uQnlKU09OUG9pbnRlciA9IChzY2hlbWEsIHBhdGgpID0+IHtcbiAgICAgICAgICAgIHBhdGggPSBkZWNvZGVVUklDb21wb25lbnQocGF0aCk7XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IHNjaGVtYTtcbiAgICAgICAgICAgIGlmIChwYXRoWzBdID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRoLnNwbGl0KCcvJykuc29tZSgocGFydCkgPT4ge1xuICAgICAgICAgICAgICAgIHBhcnQgPSBwYXJ0LnJlcGxhY2UoL34xL2csICcvJykucmVwbGFjZSgvfjAvZywgJ34nKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudFtwYXJ0XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWN1cnJlbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBmaW5kU2NoZW1hQnlJZCA9IChzY2hlbWEsIGhhbmRsZSwgaWQpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlLmFuY2hvcnMpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGUuYW5jaG9ycyA9IGNvbGxlY3RBbmNob3JzKHNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlLmFuY2hvcnMuZ2V0KGlkKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbWVyZ2UgPSAodGFyZ2V0LCBzZWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlY3Rpb24uaGFzT3duUHJvcGVydHkoa2V5KSAmJiBrZXkgIT09ICdpZCcgJiYga2V5ICE9PSAnJGlkJykge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNlY3Rpb25ba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1lcmdlUmVmID0gKHRhcmdldCwgc291cmNlUm9vdCwgc291cmNlSGFuZGxlLCByZWZTZWdtZW50KSA9PiB7XG4gICAgICAgICAgICBsZXQgc2VjdGlvbjtcbiAgICAgICAgICAgIGlmIChyZWZTZWdtZW50ID09PSB1bmRlZmluZWQgfHwgcmVmU2VnbWVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9uID0gc291cmNlUm9vdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlZlNlZ21lbnQuY2hhckF0KDApID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICAvLyBBICRyZWYgdG8gYSBKU09OIFBvaW50ZXIgKGkuZSAjL2RlZmluaXRpb25zL2ZvbylcbiAgICAgICAgICAgICAgICBzZWN0aW9uID0gZmluZFNlY3Rpb25CeUpTT05Qb2ludGVyKHNvdXJjZVJvb3QsIHJlZlNlZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQSAkcmVmIHRvIGEgc3ViLXNjaGVtYSB3aXRoIGFuICRpZCAoaS5lICNoZWxsbylcbiAgICAgICAgICAgICAgICBzZWN0aW9uID0gZmluZFNjaGVtYUJ5SWQoc291cmNlUm9vdCwgc291cmNlSGFuZGxlLCByZWZTZWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2UodGFyZ2V0LCBzZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmVFcnJvcnMucHVzaCh0KCckcmVmIFxcJ3swfVxcJyBpbiBcXCd7MX1cXCcgY2FuIG5vdCBiZSByZXNvbHZlZC4nLCByZWZTZWdtZW50IHx8ICcnLCBzb3VyY2VIYW5kbGUudXJpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc29sdmVFeHRlcm5hbExpbmsgPSAobm9kZSwgdXJpLCByZWZTZWdtZW50LCBwYXJlbnRIYW5kbGUpID0+IHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0U2VydmljZSAmJiAhL15bQS1aYS16XVtBLVphLXowLTkrXFwtLitdKjpcXC9cXC8uKi8udGVzdCh1cmkpKSB7XG4gICAgICAgICAgICAgICAgdXJpID0gY29udGV4dFNlcnZpY2UucmVzb2x2ZVJlbGF0aXZlUGF0aCh1cmksIHBhcmVudEhhbmRsZS51cmkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXJpID0gbm9ybWFsaXplSWQodXJpKTtcbiAgICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZWRIYW5kbGUgPSB0aGlzLmdldE9yQWRkU2NoZW1hSGFuZGxlKHVyaSk7XG4gICAgICAgICAgICByZXR1cm4gcmVmZXJlbmNlZEhhbmRsZS5nZXRVbnJlc29sdmVkU2NoZW1hKCkudGhlbih1bnJlc29sdmVkU2NoZW1hID0+IHtcbiAgICAgICAgICAgICAgICBwYXJlbnRIYW5kbGUuZGVwZW5kZW5jaWVzLmFkZCh1cmkpO1xuICAgICAgICAgICAgICAgIGlmICh1bnJlc29sdmVkU2NoZW1hLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jID0gcmVmU2VnbWVudCA/IHVyaSArICcjJyArIHJlZlNlZ21lbnQgOiB1cmk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVFcnJvcnMucHVzaCh0KCdQcm9ibGVtcyBsb2FkaW5nIHJlZmVyZW5jZSBcXCd7MH1cXCc6IHsxfScsIGxvYywgdW5yZXNvbHZlZFNjaGVtYS5lcnJvcnNbMF0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWVyZ2VSZWYobm9kZSwgdW5yZXNvbHZlZFNjaGVtYS5zY2hlbWEsIHJlZmVyZW5jZWRIYW5kbGUsIHJlZlNlZ21lbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlUmVmcyhub2RlLCB1bnJlc29sdmVkU2NoZW1hLnNjaGVtYSwgcmVmZXJlbmNlZEhhbmRsZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZVJlZnMgPSAobm9kZSwgcGFyZW50U2NoZW1hLCBwYXJlbnRIYW5kbGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9wZW5Qcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy50cmF2ZXJzZU5vZGVzKG5vZGUsIG5leHQgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlZW5SZWZzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0LiRyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmID0gbmV4dC4kcmVmO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWdtZW50cyA9IHJlZi5zcGxpdCgnIycsIDIpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbmV4dC4kcmVmO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VnbWVudHNbMF0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHJlZmVyZW5jZSB0byBhbiBleHRlcm5hbCBzY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5Qcm9taXNlcy5wdXNoKHJlc29sdmVFeHRlcm5hbExpbmsobmV4dCwgc2VnbWVudHNbMF0sIHNlZ21lbnRzWzFdLCBwYXJlbnRIYW5kbGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSByZWZlcmVuY2UgaW5zaWRlIHRoZSBjdXJyZW50IHNjaGVtYVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWVuUmVmcy5oYXMocmVmKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gc2VnbWVudHNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VSZWYobmV4dCwgcGFyZW50U2NoZW1hLCBwYXJlbnRIYW5kbGUsIGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWVuUmVmcy5hZGQocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dC4kcmVjdXJzaXZlUmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZXNVbnN1cHBvcnRlZEZlYXR1cmVzLmFkZCgnJHJlY3Vyc2l2ZVJlZicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dC4kZHluYW1pY1JlZikge1xuICAgICAgICAgICAgICAgICAgICB1c2VzVW5zdXBwb3J0ZWRGZWF0dXJlcy5hZGQoJyRkeW5hbWljUmVmJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlLmFsbChvcGVuUHJvbWlzZXMpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb2xsZWN0QW5jaG9ycyA9IChyb290KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLnRyYXZlcnNlTm9kZXMocm9vdCwgbmV4dCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBuZXh0LiRpZCB8fCBuZXh0LmlkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IGlzU3RyaW5nKGlkKSAmJiBpZC5jaGFyQXQoMCkgPT09ICcjJyA/IGlkLnN1YnN0cmluZygxKSA6IG5leHQuJGFuY2hvcjtcbiAgICAgICAgICAgICAgICBpZiAoYW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuaGFzKGFuY2hvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVFcnJvcnMucHVzaCh0KCdEdXBsaWNhdGUgYW5jaG9yIGRlY2xhcmF0aW9uOiBcXCd7MH1cXCcnLCBhbmNob3IpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoYW5jaG9yLCBuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dC4kcmVjdXJzaXZlQW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZXNVbnN1cHBvcnRlZEZlYXR1cmVzLmFkZCgnJHJlY3Vyc2l2ZUFuY2hvcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dC4kZHluYW1pY0FuY2hvcikge1xuICAgICAgICAgICAgICAgICAgICB1c2VzVW5zdXBwb3J0ZWRGZWF0dXJlcy5hZGQoJyRkeW5hbWljQW5jaG9yJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVzb2x2ZVJlZnMoc2NoZW1hLCBzY2hlbWEsIGhhbmRsZSkudGhlbihfID0+IHtcbiAgICAgICAgICAgIGxldCByZXNvbHZlV2FybmluZ3MgPSBbXTtcbiAgICAgICAgICAgIGlmICh1c2VzVW5zdXBwb3J0ZWRGZWF0dXJlcy5zaXplKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVdhcm5pbmdzLnB1c2godCgnVGhlIHNjaGVtYSB1c2VzIG1ldGEtc2NoZW1hIGZlYXR1cmVzICh7MH0pIHRoYXQgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkIGJ5IHRoZSB2YWxpZGF0b3IuJywgQXJyYXkuZnJvbSh1c2VzVW5zdXBwb3J0ZWRGZWF0dXJlcy5rZXlzKCkpLmpvaW4oJywgJykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZWRTY2hlbWEoc2NoZW1hLCByZXNvbHZlRXJyb3JzLCByZXNvbHZlV2FybmluZ3MsIHNjaGVtYURyYWZ0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRyYXZlcnNlTm9kZXMocm9vdCwgaGFuZGxlKSB7XG4gICAgICAgIGlmICghcm9vdCB8fCB0eXBlb2Ygcm9vdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgY29sbGVjdEVudHJpZXMgPSAoLi4uZW50cmllcykgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGVudHJ5KSkge1xuICAgICAgICAgICAgICAgICAgICB0b1dhbGsucHVzaChlbnRyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb2xsZWN0TWFwRW50cmllcyA9ICguLi5tYXBzKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1hcCBvZiBtYXBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KG1hcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrIGluIG1hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gbWFwW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QoZW50cnkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9XYWxrLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb2xsZWN0QXJyYXlFbnRyaWVzID0gKC4uLmFycmF5cykgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBhcnJheSBvZiBhcnJheXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBhcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGVudHJ5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvV2Fsay5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29sbGVjdEVudHJ5T3JBcnJheUVudHJpZXMgPSAoaXRlbXMpID0+IHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGVudHJ5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9XYWxrLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QoaXRlbXMpKSB7XG4gICAgICAgICAgICAgICAgdG9XYWxrLnB1c2goaXRlbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0b1dhbGsgPSBbcm9vdF07XG4gICAgICAgIGxldCBuZXh0ID0gdG9XYWxrLnBvcCgpO1xuICAgICAgICB3aGlsZSAobmV4dCkge1xuICAgICAgICAgICAgaWYgKCFzZWVuLmhhcyhuZXh0KSkge1xuICAgICAgICAgICAgICAgIHNlZW4uYWRkKG5leHQpO1xuICAgICAgICAgICAgICAgIGhhbmRsZShuZXh0KTtcbiAgICAgICAgICAgICAgICBjb2xsZWN0RW50cmllcyhuZXh0LmFkZGl0aW9uYWxJdGVtcywgbmV4dC5hZGRpdGlvbmFsUHJvcGVydGllcywgbmV4dC5ub3QsIG5leHQuY29udGFpbnMsIG5leHQucHJvcGVydHlOYW1lcywgbmV4dC5pZiwgbmV4dC50aGVuLCBuZXh0LmVsc2UsIG5leHQudW5ldmFsdWF0ZWRJdGVtcywgbmV4dC51bmV2YWx1YXRlZFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICAgIGNvbGxlY3RNYXBFbnRyaWVzKG5leHQuZGVmaW5pdGlvbnMsIG5leHQuJGRlZnMsIG5leHQucHJvcGVydGllcywgbmV4dC5wYXR0ZXJuUHJvcGVydGllcywgbmV4dC5kZXBlbmRlbmNpZXMsIG5leHQuZGVwZW5kZW50U2NoZW1hcyk7XG4gICAgICAgICAgICAgICAgY29sbGVjdEFycmF5RW50cmllcyhuZXh0LmFueU9mLCBuZXh0LmFsbE9mLCBuZXh0Lm9uZU9mLCBuZXh0LnByZWZpeEl0ZW1zKTtcbiAgICAgICAgICAgICAgICBjb2xsZWN0RW50cnlPckFycmF5RW50cmllcyhuZXh0Lml0ZW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQgPSB0b1dhbGsucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIGdldFNjaGVtYUZyb21Qcm9wZXJ0eShyZXNvdXJjZSwgZG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50LnJvb3Q/LnR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgZG9jdW1lbnQucm9vdC5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHAua2V5Tm9kZS52YWx1ZSA9PT0gJyRzY2hlbWEnICYmIHAudmFsdWVOb2RlPy50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2NoZW1hSWQgPSBwLnZhbHVlTm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dFNlcnZpY2UgJiYgIS9eXFx3W1xcd1xcZCsuLV0qOi8udGVzdChzY2hlbWFJZCkpIHsgLy8gaGFzIHNjaGVtZVxuICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hSWQgPSB0aGlzLmNvbnRleHRTZXJ2aWNlLnJlc29sdmVSZWxhdGl2ZVBhdGgoc2NoZW1hSWQsIHJlc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NoZW1hSWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldEFzc29jaWF0ZWRTY2hlbWFzKHJlc291cmNlKSB7XG4gICAgICAgIGNvbnN0IHNlZW4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBjb25zdCBzY2hlbWFzID0gW107XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRSZXNvdXJjZSA9IG5vcm1hbGl6ZVJlc291cmNlRm9yTWF0Y2hpbmcocmVzb3VyY2UpO1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMuZmlsZVBhdHRlcm5Bc3NvY2lhdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChlbnRyeS5tYXRjaGVzUGF0dGVybihub3JtYWxpemVkUmVzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzY2hlbWFJZCBvZiBlbnRyeS5nZXRVUklzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWVuW3NjaGVtYUlkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hcy5wdXNoKHNjaGVtYUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZW5bc2NoZW1hSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NoZW1hcztcbiAgICB9XG4gICAgZ2V0U2NoZW1hVVJJc0ZvclJlc291cmNlKHJlc291cmNlLCBkb2N1bWVudCkge1xuICAgICAgICBsZXQgc2NoZW1lSWQgPSBkb2N1bWVudCAmJiB0aGlzLmdldFNjaGVtYUZyb21Qcm9wZXJ0eShyZXNvdXJjZSwgZG9jdW1lbnQpO1xuICAgICAgICBpZiAoc2NoZW1lSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBbc2NoZW1lSWRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFzc29jaWF0ZWRTY2hlbWFzKHJlc291cmNlKTtcbiAgICB9XG4gICAgZ2V0U2NoZW1hRm9yUmVzb3VyY2UocmVzb3VyY2UsIGRvY3VtZW50KSB7XG4gICAgICAgIGlmIChkb2N1bWVudCkge1xuICAgICAgICAgICAgLy8gZmlyc3QgdXNlICRzY2hlbWEgaWYgcHJlc2VudFxuICAgICAgICAgICAgbGV0IHNjaGVtZUlkID0gdGhpcy5nZXRTY2hlbWFGcm9tUHJvcGVydHkocmVzb3VyY2UsIGRvY3VtZW50KTtcbiAgICAgICAgICAgIGlmIChzY2hlbWVJZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gbm9ybWFsaXplSWQoc2NoZW1lSWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE9yQWRkU2NoZW1hSGFuZGxlKGlkKS5nZXRSZXNvbHZlZFNjaGVtYSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhY2hlZFNjaGVtYUZvclJlc291cmNlICYmIHRoaXMuY2FjaGVkU2NoZW1hRm9yUmVzb3VyY2UucmVzb3VyY2UgPT09IHJlc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZWRTY2hlbWFGb3JSZXNvdXJjZS5yZXNvbHZlZFNjaGVtYTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY2hlbWFzID0gdGhpcy5nZXRBc3NvY2lhdGVkU2NoZW1hcyhyZXNvdXJjZSk7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkU2NoZW1hID0gc2NoZW1hcy5sZW5ndGggPiAwID8gdGhpcy5jcmVhdGVDb21iaW5lZFNjaGVtYShyZXNvdXJjZSwgc2NoZW1hcykuZ2V0UmVzb2x2ZWRTY2hlbWEoKSA6IHRoaXMucHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuY2FjaGVkU2NoZW1hRm9yUmVzb3VyY2UgPSB7IHJlc291cmNlLCByZXNvbHZlZFNjaGVtYSB9O1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWRTY2hlbWE7XG4gICAgfVxuICAgIGNyZWF0ZUNvbWJpbmVkU2NoZW1hKHJlc291cmNlLCBzY2hlbWFJZHMpIHtcbiAgICAgICAgaWYgKHNjaGVtYUlkcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE9yQWRkU2NoZW1hSGFuZGxlKHNjaGVtYUlkc1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjb21iaW5lZFNjaGVtYUlkID0gJ3NjaGVtYXNlcnZpY2U6Ly9jb21iaW5lZFNjaGVtYS8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHJlc291cmNlKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbWJpbmVkU2NoZW1hID0ge1xuICAgICAgICAgICAgICAgIGFsbE9mOiBzY2hlbWFJZHMubWFwKHNjaGVtYUlkID0+ICh7ICRyZWY6IHNjaGVtYUlkIH0pKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZFNjaGVtYUhhbmRsZShjb21iaW5lZFNjaGVtYUlkLCBjb21iaW5lZFNjaGVtYSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TWF0Y2hpbmdTY2hlbWFzKGRvY3VtZW50LCBqc29uRG9jdW1lbnQsIHNjaGVtYSkge1xuICAgICAgICBpZiAoc2NoZW1hKSB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IHNjaGVtYS5pZCB8fCAoJ3NjaGVtYXNlcnZpY2U6Ly91bnRpdGxlZC9tYXRjaGluZ1NjaGVtYXMvJyArIGpzb25TY2hlbWFTZXJ2aWNlX2lkQ291bnRlcisrKTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IHRoaXMuYWRkU2NoZW1hSGFuZGxlKGlkLCBzY2hlbWEpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZS5nZXRSZXNvbHZlZFNjaGVtYSgpLnRoZW4ocmVzb2x2ZWRTY2hlbWEgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBqc29uRG9jdW1lbnQuZ2V0TWF0Y2hpbmdTY2hlbWFzKHJlc29sdmVkU2NoZW1hLnNjaGVtYSkuZmlsdGVyKHMgPT4gIXMuaW52ZXJ0ZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2NoZW1hRm9yUmVzb3VyY2UoZG9jdW1lbnQudXJpLCBqc29uRG9jdW1lbnQpLnRoZW4oc2NoZW1hID0+IHtcbiAgICAgICAgICAgIGlmIChzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ganNvbkRvY3VtZW50LmdldE1hdGNoaW5nU2NoZW1hcyhzY2hlbWEuc2NoZW1hKS5maWx0ZXIocyA9PiAhcy5pbnZlcnRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmxldCBqc29uU2NoZW1hU2VydmljZV9pZENvdW50ZXIgPSAwO1xuZnVuY3Rpb24gbm9ybWFsaXplSWQoaWQpIHtcbiAgICAvLyByZW1vdmUgdHJhaWxpbmcgJyMnLCBub3JtYWxpemUgZHJpdmUgY2FwaXRhbGl6YXRpb25cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gVVJJLnBhcnNlKGlkKS50b1N0cmluZyh0cnVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlc291cmNlRm9yTWF0Y2hpbmcocmVzb3VyY2UpIHtcbiAgICAvLyByZW1vdmUgcXVlcmllcyBhbmQgZnJhZ21lbnRzLCBub3JtYWxpemUgZHJpdmUgY2FwaXRhbGl6YXRpb25cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gVVJJLnBhcnNlKHJlc291cmNlKS53aXRoKHsgZnJhZ21lbnQ6IG51bGwsIHF1ZXJ5OiBudWxsIH0pLnRvU3RyaW5nKHRydWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gcmVzb3VyY2U7XG4gICAgfVxufVxuZnVuY3Rpb24gdG9EaXNwbGF5U3RyaW5nKHVybCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHVyaSA9IFVSSS5wYXJzZSh1cmwpO1xuICAgICAgICBpZiAodXJpLnNjaGVtZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICAgICAgICByZXR1cm4gdXJpLmZzUGF0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpZ25vcmVcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2UvbGliL2VzbS9zZXJ2aWNlcy9qc29uRm9sZGluZy5qc1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuZnVuY3Rpb24gZ2V0Rm9sZGluZ1Jhbmdlcyhkb2N1bWVudCwgY29udGV4dCkge1xuICAgIGNvbnN0IHJhbmdlcyA9IFtdO1xuICAgIGNvbnN0IG5lc3RpbmdMZXZlbHMgPSBbXTtcbiAgICBjb25zdCBzdGFjayA9IFtdO1xuICAgIGxldCBwcmV2U3RhcnQgPSAtMTtcbiAgICBjb25zdCBzY2FubmVyID0gbWFpbl9jcmVhdGVTY2FubmVyKGRvY3VtZW50LmdldFRleHQoKSwgZmFsc2UpO1xuICAgIGxldCB0b2tlbiA9IHNjYW5uZXIuc2NhbigpO1xuICAgIGZ1bmN0aW9uIGFkZFJhbmdlKHJhbmdlKSB7XG4gICAgICAgIHJhbmdlcy5wdXNoKHJhbmdlKTtcbiAgICAgICAgbmVzdGluZ0xldmVscy5wdXNoKHN0YWNrLmxlbmd0aCk7XG4gICAgfVxuICAgIHdoaWxlICh0b2tlbiAhPT0gMTcgLyogU3ludGF4S2luZC5FT0YgKi8pIHtcbiAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAgICAgY2FzZSAxIC8qIFN5bnRheEtpbmQuT3BlbkJyYWNlVG9rZW4gKi86XG4gICAgICAgICAgICBjYXNlIDMgLyogU3ludGF4S2luZC5PcGVuQnJhY2tldFRva2VuICovOiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRMaW5lID0gZG9jdW1lbnQucG9zaXRpb25BdChzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkpLmxpbmU7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB7IHN0YXJ0TGluZSwgZW5kTGluZTogc3RhcnRMaW5lLCBraW5kOiB0b2tlbiA9PT0gMSAvKiBTeW50YXhLaW5kLk9wZW5CcmFjZVRva2VuICovID8gJ29iamVjdCcgOiAnYXJyYXknIH07XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChyYW5nZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDIgLyogU3ludGF4S2luZC5DbG9zZUJyYWNlVG9rZW4gKi86XG4gICAgICAgICAgICBjYXNlIDQgLyogU3ludGF4S2luZC5DbG9zZUJyYWNrZXRUb2tlbiAqLzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtpbmQgPSB0b2tlbiA9PT0gMiAvKiBTeW50YXhLaW5kLkNsb3NlQnJhY2VUb2tlbiAqLyA/ICdvYmplY3QnIDogJ2FycmF5JztcbiAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCAmJiBzdGFja1tzdGFjay5sZW5ndGggLSAxXS5raW5kID09PSBraW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBkb2N1bWVudC5wb3NpdGlvbkF0KHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSkubGluZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlICYmIGxpbmUgPiByYW5nZS5zdGFydExpbmUgKyAxICYmIHByZXZTdGFydCAhPT0gcmFuZ2Uuc3RhcnRMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5lbmRMaW5lID0gbGluZSAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2U3RhcnQgPSByYW5nZS5zdGFydExpbmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDEzIC8qIFN5bnRheEtpbmQuQmxvY2tDb21tZW50VHJpdmlhICovOiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRMaW5lID0gZG9jdW1lbnQucG9zaXRpb25BdChzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkpLmxpbmU7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kTGluZSA9IGRvY3VtZW50LnBvc2l0aW9uQXQoc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpICsgc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpKS5saW5lO1xuICAgICAgICAgICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuRXJyb3IoKSA9PT0gMSAvKiBTY2FuRXJyb3IuVW5leHBlY3RlZEVuZE9mQ29tbWVudCAqLyAmJiBzdGFydExpbmUgKyAxIDwgZG9jdW1lbnQubGluZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHNjYW5uZXIuc2V0UG9zaXRpb24oZG9jdW1lbnQub2Zmc2V0QXQobWFpbi5Qb3NpdGlvbi5jcmVhdGUoc3RhcnRMaW5lICsgMSwgMCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydExpbmUgPCBlbmRMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRSYW5nZSh7IHN0YXJ0TGluZSwgZW5kTGluZSwga2luZDogbWFpbi5Gb2xkaW5nUmFuZ2VLaW5kLkNvbW1lbnQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2U3RhcnQgPSBzdGFydExpbmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDEyIC8qIFN5bnRheEtpbmQuTGluZUNvbW1lbnRUcml2aWEgKi86IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gZG9jdW1lbnQuZ2V0VGV4dCgpLnN1YnN0cihzY2FubmVyLmdldFRva2VuT2Zmc2V0KCksIHNjYW5uZXIuZ2V0VG9rZW5MZW5ndGgoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IHRleHQubWF0Y2goL15cXC9cXC9cXHMqIyhyZWdpb25cXGIpfChlbmRyZWdpb25cXGIpLyk7XG4gICAgICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluZSA9IGRvY3VtZW50LnBvc2l0aW9uQXQoc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpKS5saW5lO1xuICAgICAgICAgICAgICAgICAgICBpZiAobVsxXSkgeyAvLyBzdGFydCBwYXR0ZXJuIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IHsgc3RhcnRMaW5lOiBsaW5lLCBlbmRMaW5lOiBsaW5lLCBraW5kOiBtYWluLkZvbGRpbmdSYW5nZUtpbmQuUmVnaW9uIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpID0gc3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpID49IDAgJiYgc3RhY2tbaV0ua2luZCAhPT0gbWFpbi5Gb2xkaW5nUmFuZ2VLaW5kLlJlZ2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IHN0YWNrW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLmxlbmd0aCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUgPiByYW5nZS5zdGFydExpbmUgJiYgcHJldlN0YXJ0ICE9PSByYW5nZS5zdGFydExpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UuZW5kTGluZSA9IGxpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldlN0YXJ0ID0gcmFuZ2Uuc3RhcnRMaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b2tlbiA9IHNjYW5uZXIuc2NhbigpO1xuICAgIH1cbiAgICBjb25zdCByYW5nZUxpbWl0ID0gY29udGV4dCAmJiBjb250ZXh0LnJhbmdlTGltaXQ7XG4gICAgaWYgKHR5cGVvZiByYW5nZUxpbWl0ICE9PSAnbnVtYmVyJyB8fCByYW5nZXMubGVuZ3RoIDw9IHJhbmdlTGltaXQpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICB9XG4gICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5vblJhbmdlTGltaXRFeGNlZWRlZCkge1xuICAgICAgICBjb250ZXh0Lm9uUmFuZ2VMaW1pdEV4Y2VlZGVkKGRvY3VtZW50LnVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGNvdW50cyA9IFtdO1xuICAgIGZvciAobGV0IGxldmVsIG9mIG5lc3RpbmdMZXZlbHMpIHtcbiAgICAgICAgaWYgKGxldmVsIDwgMzApIHtcbiAgICAgICAgICAgIGNvdW50c1tsZXZlbF0gPSAoY291bnRzW2xldmVsXSB8fCAwKSArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGVudHJpZXMgPSAwO1xuICAgIGxldCBtYXhMZXZlbCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbiA9IGNvdW50c1tpXTtcbiAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgIGlmIChuICsgZW50cmllcyA+IHJhbmdlTGltaXQpIHtcbiAgICAgICAgICAgICAgICBtYXhMZXZlbCA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnRyaWVzICs9IG47XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSBuZXN0aW5nTGV2ZWxzW2ldO1xuICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaWYgKGxldmVsIDwgbWF4TGV2ZWwgfHwgKGxldmVsID09PSBtYXhMZXZlbCAmJiBlbnRyaWVzKysgPCByYW5nZUxpbWl0KSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJhbmdlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2UvbGliL2VzbS9zZXJ2aWNlcy9qc29uU2VsZWN0aW9uUmFuZ2VzLmpzXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25SYW5nZXMoZG9jdW1lbnQsIHBvc2l0aW9ucywgZG9jKSB7XG4gICAgZnVuY3Rpb24gZ2V0U2VsZWN0aW9uUmFuZ2UocG9zaXRpb24pIHtcbiAgICAgICAgbGV0IG9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KHBvc2l0aW9uKTtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2MuZ2V0Tm9kZUZyb21PZmZzZXQob2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgICAgICAgICAgICAgIC8vIHJhbmdlIHdpdGhvdXQgXCIsIFsgb3Ige1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjU3RhcnQgPSBub2RlLm9mZnNldCArIDEsIGNFbmQgPSBub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNTdGFydCA8IGNFbmQgJiYgb2Zmc2V0ID49IGNTdGFydCAmJiBvZmZzZXQgPD0gY0VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3UmFuZ2UoY1N0YXJ0LCBjRW5kKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3UmFuZ2Uobm9kZS5vZmZzZXQsIG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgICAgICAgICBjYXNlICdwcm9wZXJ0eSc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld1JhbmdlKG5vZGUub2Zmc2V0LCBub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ3Byb3BlcnR5JyB8fCBub2RlLnBhcmVudCAmJiBub2RlLnBhcmVudC50eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWZ0ZXJDb21tYU9mZnNldCA9IGdldE9mZnNldEFmdGVyTmV4dFRva2VuKG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGgsIDUgLyogU3ludGF4S2luZC5Db21tYVRva2VuICovKTtcbiAgICAgICAgICAgICAgICBpZiAoYWZ0ZXJDb21tYU9mZnNldCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3UmFuZ2Uobm9kZS5vZmZzZXQsIGFmdGVyQ29tbWFPZmZzZXQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gcmVzdWx0Lmxlbmd0aCAtIDE7IGluZGV4ID49IDA7IGluZGV4LS0pIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBtYWluLlNlbGVjdGlvblJhbmdlLmNyZWF0ZShyZXN1bHRbaW5kZXhdLCBjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBtYWluLlNlbGVjdGlvblJhbmdlLmNyZWF0ZShtYWluLlJhbmdlLmNyZWF0ZShwb3NpdGlvbiwgcG9zaXRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbmV3UmFuZ2Uoc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gbWFpbi5SYW5nZS5jcmVhdGUoZG9jdW1lbnQucG9zaXRpb25BdChzdGFydCksIGRvY3VtZW50LnBvc2l0aW9uQXQoZW5kKSk7XG4gICAgfVxuICAgIGNvbnN0IHNjYW5uZXIgPSBtYWluX2NyZWF0ZVNjYW5uZXIoZG9jdW1lbnQuZ2V0VGV4dCgpLCB0cnVlKTtcbiAgICBmdW5jdGlvbiBnZXRPZmZzZXRBZnRlck5leHRUb2tlbihvZmZzZXQsIGV4cGVjdGVkVG9rZW4pIHtcbiAgICAgICAgc2Nhbm5lci5zZXRQb3NpdGlvbihvZmZzZXQpO1xuICAgICAgICBsZXQgdG9rZW4gPSBzY2FubmVyLnNjYW4oKTtcbiAgICAgICAgaWYgKHRva2VuID09PSBleHBlY3RlZFRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpICsgc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc2l0aW9ucy5tYXAoZ2V0U2VsZWN0aW9uUmFuZ2UpO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL3V0aWxzL2Zvcm1hdC5qc1xuXG5cbmZ1bmN0aW9uIHV0aWxzX2Zvcm1hdF9mb3JtYXQoZG9jdW1lbnRUb0Zvcm1hdCwgZm9ybWF0dGluZ09wdGlvbnMsIGZvcm1hdHRpbmdSYW5nZSkge1xuICAgIGxldCByYW5nZSA9IHVuZGVmaW5lZDtcbiAgICBpZiAoZm9ybWF0dGluZ1JhbmdlKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGRvY3VtZW50VG9Gb3JtYXQub2Zmc2V0QXQoZm9ybWF0dGluZ1JhbmdlLnN0YXJ0KTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZG9jdW1lbnRUb0Zvcm1hdC5vZmZzZXRBdChmb3JtYXR0aW5nUmFuZ2UuZW5kKSAtIG9mZnNldDtcbiAgICAgICAgcmFuZ2UgPSB7IG9mZnNldCwgbGVuZ3RoIH07XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIHRhYlNpemU6IGZvcm1hdHRpbmdPcHRpb25zID8gZm9ybWF0dGluZ09wdGlvbnMudGFiU2l6ZSA6IDQsXG4gICAgICAgIGluc2VydFNwYWNlczogZm9ybWF0dGluZ09wdGlvbnM/Lmluc2VydFNwYWNlcyA9PT0gdHJ1ZSxcbiAgICAgICAgaW5zZXJ0RmluYWxOZXdsaW5lOiBmb3JtYXR0aW5nT3B0aW9ucz8uaW5zZXJ0RmluYWxOZXdsaW5lID09PSB0cnVlLFxuICAgICAgICBlb2w6ICdcXG4nLFxuICAgICAgICBrZWVwTGluZXM6IGZvcm1hdHRpbmdPcHRpb25zPy5rZWVwTGluZXMgPT09IHRydWVcbiAgICB9O1xuICAgIHJldHVybiBtYWluX2Zvcm1hdChkb2N1bWVudFRvRm9ybWF0LmdldFRleHQoKSwgcmFuZ2UsIG9wdGlvbnMpLm1hcChlZGl0ID0+IHtcbiAgICAgICAgcmV0dXJuIG1haW4uVGV4dEVkaXQucmVwbGFjZShtYWluLlJhbmdlLmNyZWF0ZShkb2N1bWVudFRvRm9ybWF0LnBvc2l0aW9uQXQoZWRpdC5vZmZzZXQpLCBkb2N1bWVudFRvRm9ybWF0LnBvc2l0aW9uQXQoZWRpdC5vZmZzZXQgKyBlZGl0Lmxlbmd0aCkpLCBlZGl0LmNvbnRlbnQpO1xuICAgIH0pO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL3V0aWxzL3Byb3BlcnR5VHJlZS5qc1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG52YXIgQ29udGFpbmVyO1xuKGZ1bmN0aW9uIChDb250YWluZXIpIHtcbiAgICBDb250YWluZXJbQ29udGFpbmVyW1wiT2JqZWN0XCJdID0gMF0gPSBcIk9iamVjdFwiO1xuICAgIENvbnRhaW5lcltDb250YWluZXJbXCJBcnJheVwiXSA9IDFdID0gXCJBcnJheVwiO1xufSkoQ29udGFpbmVyIHx8IChDb250YWluZXIgPSB7fSkpO1xuY2xhc3MgUHJvcGVydHlUcmVlIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eU5hbWUsIGJlZ2lubmluZ0xpbmVOdW1iZXIpIHtcbiAgICAgICAgdGhpcy5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWUgPz8gJyc7XG4gICAgICAgIHRoaXMuYmVnaW5uaW5nTGluZU51bWJlciA9IGJlZ2lubmluZ0xpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5Qcm9wZXJ0aWVzID0gW107XG4gICAgICAgIHRoaXMubGFzdFByb3BlcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMubm9LZXlOYW1lID0gZmFsc2U7XG4gICAgfVxuICAgIGFkZENoaWxkUHJvcGVydHkoY2hpbGRQcm9wZXJ0eSkge1xuICAgICAgICBjaGlsZFByb3BlcnR5LnBhcmVudCA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuUHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgaW5zZXJ0aW9uSW5kZXggPSAwO1xuICAgICAgICAgICAgaWYgKGNoaWxkUHJvcGVydHkubm9LZXlOYW1lKSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0aW9uSW5kZXggPSB0aGlzLmNoaWxkcmVuUHJvcGVydGllcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRpb25JbmRleCA9IGJpbmFyeVNlYXJjaE9uUHJvcGVydHlBcnJheSh0aGlzLmNoaWxkcmVuUHJvcGVydGllcywgY2hpbGRQcm9wZXJ0eSwgY29tcGFyZVByb3BlcnRpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluc2VydGlvbkluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIGluc2VydGlvbkluZGV4ID0gKGluc2VydGlvbkluZGV4ICogLTEpIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5Qcm9wZXJ0aWVzLnNwbGljZShpbnNlcnRpb25JbmRleCwgMCwgY2hpbGRQcm9wZXJ0eSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuUHJvcGVydGllcy5wdXNoKGNoaWxkUHJvcGVydHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZFByb3BlcnR5O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBhcmVQcm9wZXJ0aWVzKHByb3BlcnR5VHJlZTEsIHByb3BlcnR5VHJlZTIpIHtcbiAgICBjb25zdCBwcm9wZXJ0eU5hbWUxID0gcHJvcGVydHlUcmVlMS5wcm9wZXJ0eU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBwcm9wZXJ0eU5hbWUyID0gcHJvcGVydHlUcmVlMi5wcm9wZXJ0eU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAocHJvcGVydHlOYW1lMSA8IHByb3BlcnR5TmFtZTIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9wZXJ0eU5hbWUxID4gcHJvcGVydHlOYW1lMikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBiaW5hcnlTZWFyY2hPblByb3BlcnR5QXJyYXkocHJvcGVydHlUcmVlQXJyYXksIHByb3BlcnR5VHJlZSwgY29tcGFyZV9mbikge1xuICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IHByb3BlcnR5VHJlZS5wcm9wZXJ0eU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBmaXJzdFByb3BlcnR5SW5BcnJheU5hbWUgPSBwcm9wZXJ0eVRyZWVBcnJheVswXS5wcm9wZXJ0eU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBsYXN0UHJvcGVydHlJbkFycmF5TmFtZSA9IHByb3BlcnR5VHJlZUFycmF5W3Byb3BlcnR5VHJlZUFycmF5Lmxlbmd0aCAtIDFdLnByb3BlcnR5TmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChwcm9wZXJ0eU5hbWUgPCBmaXJzdFByb3BlcnR5SW5BcnJheU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChwcm9wZXJ0eU5hbWUgPiBsYXN0UHJvcGVydHlJbkFycmF5TmFtZSkge1xuICAgICAgICByZXR1cm4gcHJvcGVydHlUcmVlQXJyYXkubGVuZ3RoO1xuICAgIH1cbiAgICBsZXQgbSA9IDA7XG4gICAgbGV0IG4gPSBwcm9wZXJ0eVRyZWVBcnJheS5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChtIDw9IG4pIHtcbiAgICAgICAgbGV0IGsgPSAobiArIG0pID4+IDE7XG4gICAgICAgIGxldCBjbXAgPSBjb21wYXJlX2ZuKHByb3BlcnR5VHJlZSwgcHJvcGVydHlUcmVlQXJyYXlba10pO1xuICAgICAgICBpZiAoY21wID4gMCkge1xuICAgICAgICAgICAgbSA9IGsgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNtcCA8IDApIHtcbiAgICAgICAgICAgIG4gPSBrIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtbSAtIDE7XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL2xpYi9lc20vdXRpbHMvc29ydC5qc1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vLyBpbXBvcnQgeyBUZXh0RWRpdH0gZnJvbSAndnNjb2RlLWxhbmd1YWdlc2VydmVyLXRleHRkb2N1bWVudCc7XG5cblxuXG5cbmZ1bmN0aW9uIHNvcnQoZG9jdW1lbnRUb1NvcnQsIGZvcm1hdHRpbmdPcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgLi4uZm9ybWF0dGluZ09wdGlvbnMsXG4gICAgICAgIGtlZXBMaW5lczogZmFsc2UsIC8vIGtlZXBMaW5lcyBtdXN0IGJlIGZhbHNlIHNvIHRoYXQgdGhlIHByb3BlcnRpZXMgYXJlIG9uIHNlcGFyYXRlIGxpbmVzIGZvciB0aGUgc29ydGluZ1xuICAgIH07XG4gICAgY29uc3QgZm9ybWF0dGVkSnNvblN0cmluZyA9IGVzbV9tYWluLyogVGV4dERvY3VtZW50ICovLm4uYXBwbHlFZGl0cyhkb2N1bWVudFRvU29ydCwgdXRpbHNfZm9ybWF0X2Zvcm1hdChkb2N1bWVudFRvU29ydCwgb3B0aW9ucywgdW5kZWZpbmVkKSk7XG4gICAgY29uc3QgZm9ybWF0dGVkSnNvbkRvY3VtZW50ID0gZXNtX21haW4vKiBUZXh0RG9jdW1lbnQgKi8ubi5jcmVhdGUoJ3Rlc3Q6Ly90ZXN0Lmpzb24nLCAnanNvbicsIDAsIGZvcm1hdHRlZEpzb25TdHJpbmcpO1xuICAgIGNvbnN0IGpzb25Qcm9wZXJ0eVRyZWUgPSBmaW5kSnNvbmNQcm9wZXJ0eVRyZWUoZm9ybWF0dGVkSnNvbkRvY3VtZW50KTtcbiAgICBjb25zdCBzb3J0ZWRKc29uRG9jdW1lbnQgPSBzb3J0SnNvbmNEb2N1bWVudChmb3JtYXR0ZWRKc29uRG9jdW1lbnQsIGpzb25Qcm9wZXJ0eVRyZWUpO1xuICAgIGNvbnN0IGVkaXRzID0gdXRpbHNfZm9ybWF0X2Zvcm1hdChzb3J0ZWRKc29uRG9jdW1lbnQsIG9wdGlvbnMsIHVuZGVmaW5lZCk7XG4gICAgY29uc3Qgc29ydGVkQW5kRm9ybWF0dGVkSnNvbkRvY3VtZW50ID0gZXNtX21haW4vKiBUZXh0RG9jdW1lbnQgKi8ubi5hcHBseUVkaXRzKHNvcnRlZEpzb25Eb2N1bWVudCwgZWRpdHMpO1xuICAgIHJldHVybiBbbWFpbi5UZXh0RWRpdC5yZXBsYWNlKG1haW4uUmFuZ2UuY3JlYXRlKG1haW4uUG9zaXRpb24uY3JlYXRlKDAsIDApLCBkb2N1bWVudFRvU29ydC5wb3NpdGlvbkF0KGRvY3VtZW50VG9Tb3J0LmdldFRleHQoKS5sZW5ndGgpKSwgc29ydGVkQW5kRm9ybWF0dGVkSnNvbkRvY3VtZW50KV07XG59XG5mdW5jdGlvbiBmaW5kSnNvbmNQcm9wZXJ0eVRyZWUoZm9ybWF0dGVkRG9jdW1lbnQpIHtcbiAgICBjb25zdCBmb3JtYXR0ZWRTdHJpbmcgPSBmb3JtYXR0ZWREb2N1bWVudC5nZXRUZXh0KCk7XG4gICAgY29uc3Qgc2Nhbm5lciA9IG1haW5fY3JlYXRlU2Nhbm5lcihmb3JtYXR0ZWRTdHJpbmcsIGZhbHNlKTtcbiAgICAvLyBUaGUgdHJlZSB0aGF0IHdpbGwgYmUgcmV0dXJuZWRcbiAgICBsZXQgcm9vdFRyZWUgPSBuZXcgUHJvcGVydHlUcmVlKCk7XG4gICAgLy8gVGhlIHRyZWUgd2hlcmUgdGhlIGN1cnJlbnQgcHJvcGVydGllcyBjYW4gYmUgYWRkZWQgYXMgY2hpbGRyZW5cbiAgICBsZXQgY3VycmVudFRyZWUgPSByb290VHJlZTtcbiAgICAvLyBUaGUgdHJlZSByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgcHJvcGVydHkgYW5hbHl6ZWRcbiAgICBsZXQgY3VycmVudFByb3BlcnR5ID0gcm9vdFRyZWU7XG4gICAgLy8gVGhlIHRyZWUgcmVwcmVzZW50aW5nIHRoZSBwcmV2aW91cyBwcm9wZXJ0eSBhbmFseXplZFxuICAgIGxldCBsYXN0UHJvcGVydHkgPSByb290VHJlZTtcbiAgICAvLyBUaGUgY3VycmVudCBzY2FubmVkIHRva2VuXG4gICAgbGV0IHRva2VuID0gdW5kZWZpbmVkO1xuICAgIC8vIExpbmUgbnVtYmVyIG9mIHRoZSBsYXN0IHRva2VuIGZvdW5kXG4gICAgbGV0IGxhc3RUb2tlbkxpbmUgPSAwO1xuICAgIC8vIFRvdGFsIG51bWJlciBvZiBjaGFyYWN0ZXJzIG9uIHRoZSBsaW5lcyBwcmlvciB0byBjdXJyZW50IGxpbmUgXG4gICAgbGV0IG51bWJlck9mQ2hhcmFjdGVyc09uUHJldmlvdXNMaW5lcyA9IDA7XG4gICAgLy8gVGhlIGxhc3QgdG9rZW4gc2Nhbm5lZCB0aGF0IGlzIG5vdCB0cml2aWFsLCBub3IgYSBjb21tZW50XG4gICAgbGV0IGxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgLy8gVGhlIHNlY29uZCB0byBsYXN0IHRva2VuIHNjYW5uZWQgdGhhdCBpcyBub3QgdHJpdmlhbCwgbm9yIGEgY29tbWVudFxuICAgIGxldCBzZWNvbmRUb0xhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgLy8gTGluZSBudW1iZXIgb2YgbGFzdCB0b2tlbiB0aGF0IGlzIG5vdCB0cml2aWFsLCBub3IgYSBjb21tZW50XG4gICAgbGV0IGxpbmVPZkxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPSAtMTtcbiAgICAvLyBFbmQgaW5kZXggb24gaXRzIGxpbmUgb2YgbGFzdCB0b2tlbiB0aGF0IGlzIG5vdCB0cml2aWFsLCBub3IgYSBjb21tZW50XG4gICAgbGV0IGVuZEluZGV4T2ZMYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID0gLTE7XG4gICAgLy8gTGluZSBudW1iZXIgb2YgdGhlIHN0YXJ0IG9mIHRoZSByYW5nZSBvZiBjdXJyZW50L25leHQgcHJvcGVydHlcbiAgICBsZXQgYmVnaW5uaW5nTGluZU51bWJlciA9IDA7XG4gICAgLy8gTGluZSBudW1iZXIgb2YgdGhlIGVuZCBvZiB0aGUgcmFuZ2Ugb2YgY3VycmVudC9uZXh0IHByb3BlcnR5XG4gICAgbGV0IGVuZExpbmVOdW1iZXIgPSAwO1xuICAgIC8vIFN0YWNrIGluZGljYXRpbmcgd2hldGhlciB3ZSBhcmUgaW5zaWRlIG9mIGFuIG9iamVjdCBvciBhbiBhcnJheVxuICAgIGxldCBjdXJyZW50Q29udGFpbmVyU3RhY2sgPSBbXTtcbiAgICAvLyBCb29sZWFuIGluZGljYXRpbmcgdGhhdCB0aGUgY3VycmVudCBwcm9wZXJ0eSBlbmQgbGluZSBudW1iZXIgbmVlZHMgdG8gYmUgdXBkYXRlZC4gVXNlZCBvbmx5IHdoZW4gYmxvY2sgY29tbWVudHMgYXJlIGVuY291bnRlcmVkLlxuICAgIGxldCB1cGRhdGVMYXN0UHJvcGVydHlFbmRMaW5lTnVtYmVyID0gZmFsc2U7XG4gICAgLy8gQm9vbGVhbiBpbmRpY2F0aW5nIHRoYXQgdGhlIGJlZ2lubmluZyBsaW5lIG51bWJlciBzaG91bGQgYmUgdXBkYXRlZC4gVXNlZCBvbmx5IHdoZW4gYmxvY2sgY29tbWVudHMgYXJlIGVuY291bnRlcmVkLiBcbiAgICBsZXQgdXBkYXRlQmVnaW5uaW5nTGluZU51bWJlciA9IGZhbHNlO1xuICAgIHdoaWxlICgodG9rZW4gPSBzY2FubmVyLnNjYW4oKSkgIT09IDE3IC8qIFN5bnRheEtpbmQuRU9GICovKSB7XG4gICAgICAgIC8vIEluIHRoZSBjYXNlIHdoZW4gYSBibG9jayBjb21tZW50IGhhcyBiZWVuIGVuY291bnRlcmVkIHRoYXQgc3RhcnRzIG9uIHRoZSBzYW1lIGxpbmUgYXMgdGhlIGNvbW1hIGVuZGluZyBhIHByb3BlcnR5LCB1cGRhdGUgdGhlIGVuZCBsaW5lIG9mIHRoYXRcbiAgICAgICAgLy8gcHJvcGVydHkgc28gdGhhdCBpdCBjb3ZlcnMgdGhlIGJsb2NrIGNvbW1lbnQuIEZvciBleGFtcGxlLCBpZiB3ZSBoYXZlOiBcbiAgICAgICAgLy8gMS4gXCJrZXlcIiA6IHt9LCAvKiBzb21lIGJsb2NrXG4gICAgICAgIC8vIDIuIGNvbW1lbnQgKi9cbiAgICAgICAgLy8gVGhlbiwgdGhlIGVuZCBsaW5lIG9mIHRoZSBwcm9wZXJ0eSBcImtleVwiIHNob3VsZCBiZSBsaW5lIDIgbm90IGxpbmUgMVxuICAgICAgICBpZiAodXBkYXRlTGFzdFByb3BlcnR5RW5kTGluZU51bWJlciA9PT0gdHJ1ZVxuICAgICAgICAgICAgJiYgdG9rZW4gIT09IDE0IC8qIFN5bnRheEtpbmQuTGluZUJyZWFrVHJpdmlhICovXG4gICAgICAgICAgICAmJiB0b2tlbiAhPT0gMTUgLyogU3ludGF4S2luZC5Ucml2aWEgKi9cbiAgICAgICAgICAgICYmIHRva2VuICE9PSAxMiAvKiBTeW50YXhLaW5kLkxpbmVDb21tZW50VHJpdmlhICovXG4gICAgICAgICAgICAmJiB0b2tlbiAhPT0gMTMgLyogU3ludGF4S2luZC5CbG9ja0NvbW1lbnRUcml2aWEgKi9cbiAgICAgICAgICAgICYmIGN1cnJlbnRQcm9wZXJ0eS5lbmRMaW5lTnVtYmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBlbmRMaW5lTnVtYmVyID0gc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBlbmQgbGluZSBudW1iZXIgaW4gdGhlIGNhc2Ugd2hlbiB0aGUgbGFzdCBwcm9wZXJ0eSB2aXNpdGVkIGlzIGEgY29udGFpbmVyIChvYmplY3Qgb3IgYXJyYXkpXG4gICAgICAgICAgICBpZiAoc2Vjb25kVG9MYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID09PSAyIC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICovXG4gICAgICAgICAgICAgICAgfHwgc2Vjb25kVG9MYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID09PSA0IC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFja2V0VG9rZW4gKi8pIHtcbiAgICAgICAgICAgICAgICBsYXN0UHJvcGVydHkuZW5kTGluZU51bWJlciA9IGVuZExpbmVOdW1iZXIgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBlbmQgbGluZSBudW1iZXIgaW4gdGhlIGNhc2Ugd2hlbiB0aGUgbGFzdCBwcm9wZXJ0eSB2aXNpdGVkIGlzIGEgc2ltcGxlIHByb3BlcnR5IFxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFByb3BlcnR5LmVuZExpbmVOdW1iZXIgPSBlbmRMaW5lTnVtYmVyIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJlZ2lubmluZ0xpbmVOdW1iZXIgPSBlbmRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgdXBkYXRlTGFzdFByb3BlcnR5RW5kTGluZU51bWJlciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gYSBibG9jayBjb21tZW50IGZvbGxvd3MgYW4gb3BlbiBicmFjZSBvciBhbiBvcGVuIGJyYWNrZXQsIHRoYXQgYmxvY2sgY29tbWVudCBzaG91bGQgYmUgYXNzb2NpYXRlZCB0byB0aGF0IGJyYWNlIG9yIGJyYWNrZXQsIG5vdCB0aGUgcHJvcGVydHkgYmVsb3cgaXQuIEZvciBleGFtcGxlLCBmb3I6XG4gICAgICAgIC8vIDEuIHsgLypcbiAgICAgICAgLy8gMi4gLi4uICovXG4gICAgICAgIC8vIDMuIFwia2V5XCIgOiB7fVxuICAgICAgICAvLyA0LiB9XG4gICAgICAgIC8vIEluc3RlYWQgb2YgYXNzb2NpYXRpbmcgdGhlIGJsb2NrIGNvbW1lbnQgdG8gdGhlIHByb3BlcnR5IG9uIGxpbmUgMywgaXQgaXMgYXNzb2NpYXRlIHRvIHRoZSBwcm9wZXJ0eSBvbiBsaW5lIDFcbiAgICAgICAgaWYgKHVwZGF0ZUJlZ2lubmluZ0xpbmVOdW1iZXIgPT09IHRydWVcbiAgICAgICAgICAgICYmIHRva2VuICE9PSAxNCAvKiBTeW50YXhLaW5kLkxpbmVCcmVha1RyaXZpYSAqL1xuICAgICAgICAgICAgJiYgdG9rZW4gIT09IDE1IC8qIFN5bnRheEtpbmQuVHJpdmlhICovXG4gICAgICAgICAgICAmJiB0b2tlbiAhPT0gMTIgLyogU3ludGF4S2luZC5MaW5lQ29tbWVudFRyaXZpYSAqL1xuICAgICAgICAgICAgJiYgdG9rZW4gIT09IDEzIC8qIFN5bnRheEtpbmQuQmxvY2tDb21tZW50VHJpdmlhICovKSB7XG4gICAgICAgICAgICBiZWdpbm5pbmdMaW5lTnVtYmVyID0gc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpO1xuICAgICAgICAgICAgdXBkYXRlQmVnaW5uaW5nTGluZU51bWJlciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgb24gYWxsIHRoZSBwcmV2aW91cyBsaW5lcyBlYWNoIHRpbWUgdGhlIG5ldyB0b2tlbiBpcyBvbiBhIGRpZmZlcmVudCBsaW5lIHRvIHRoZSBwcmV2aW91cyB0b2tlblxuICAgICAgICBpZiAoc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpICE9PSBsYXN0VG9rZW5MaW5lKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbGFzdFRva2VuTGluZTsgaSA8IHNjYW5uZXIuZ2V0VG9rZW5TdGFydExpbmUoKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoT2ZMaW5lID0gZm9ybWF0dGVkRG9jdW1lbnQuZ2V0VGV4dChtYWluLlJhbmdlLmNyZWF0ZShtYWluLlBvc2l0aW9uLmNyZWF0ZShpLCAwKSwgbWFpbi5Qb3NpdGlvbi5jcmVhdGUoaSArIDEsIDApKSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIG51bWJlck9mQ2hhcmFjdGVyc09uUHJldmlvdXNMaW5lcyA9IG51bWJlck9mQ2hhcmFjdGVyc09uUHJldmlvdXNMaW5lcyArIGxlbmd0aE9mTGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RUb2tlbkxpbmUgPSBzY2FubmVyLmdldFRva2VuU3RhcnRMaW5lKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAgICAgLy8gV2hlbiBhIHN0cmluZyBpcyBmb3VuZCwgaWYgaXQgZm9sbG93cyBhbiBvcGVuIGJyYWNlIG9yIGEgY29tbWEgdG9rZW4gYW5kIGl0IGlzIHdpdGhpbiBhbiBvYmplY3QsIHRoZW4gaXQgY29ycmVzcG9uZHMgdG8gYSBrZXkgbmFtZSwgbm90IGEgc2ltcGxlIHN0cmluZ1xuICAgICAgICAgICAgY2FzZSAxMCAvKiBTeW50YXhLaW5kLlN0cmluZ0xpdGVyYWwgKi86IHtcbiAgICAgICAgICAgICAgICBpZiAoKGxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICB8fCBsYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID09PSAxIC8qIFN5bnRheEtpbmQuT3BlbkJyYWNlVG9rZW4gKi9cbiAgICAgICAgICAgICAgICAgICAgfHwgKGxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IDUgLyogU3ludGF4S2luZC5Db21tYVRva2VuICovXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBjdXJyZW50Q29udGFpbmVyU3RhY2tbY3VycmVudENvbnRhaW5lclN0YWNrLmxlbmd0aCAtIDFdID09PSBDb250YWluZXIuT2JqZWN0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhhdCBjYXNlIGNyZWF0ZSB0aGUgY2hpbGQgcHJvcGVydHkgd2hpY2ggc3RhcnRzIGF0IGJlZ2lubmluZ0xpbmVOdW1iZXIsIGFkZCBpdCB0byB0aGUgY3VycmVudCB0cmVlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkUHJvcGVydHkgPSBuZXcgUHJvcGVydHlUcmVlKHNjYW5uZXIuZ2V0VG9rZW5WYWx1ZSgpLCBiZWdpbm5pbmdMaW5lTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFByb3BlcnR5ID0gY3VycmVudFByb3BlcnR5O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvcGVydHkgPSBjdXJyZW50VHJlZS5hZGRDaGlsZFByb3BlcnR5KGNoaWxkUHJvcGVydHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIHRva2VuIGlzIGFuIG9wZW4gYnJhY2tldCwgdGhlbiB3ZSBlbnRlciBpbnRvIGFuIGFycmF5XG4gICAgICAgICAgICBjYXNlIDMgLyogU3ludGF4S2luZC5PcGVuQnJhY2tldFRva2VuICovOiB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJvb3QgdHJlZSBiZWdpbm5pbmcgbGluZSBudW1iZXIgaXMgbm90IGRlZmluZWQsIHRoZW4gdGhpcyBvcGVuIGJyYWNrZXQgaXMgdGhlIGZpcnN0IG9wZW4gYnJhY2tldCBpbiB0aGUgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICBpZiAocm9vdFRyZWUuYmVnaW5uaW5nTGluZU51bWJlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RUcmVlLmJlZ2lubmluZ0xpbmVOdW1iZXIgPSBzY2FubmVyLmdldFRva2VuU3RhcnRMaW5lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFN1cHBvc2Ugd2UgYXJlIGluc2lkZSBvZiBhbiBvYmplY3QsIHRoZW4gdGhlIGN1cnJlbnQgYXJyYXkgaXMgYXNzb2NpYXRlZCB0byBhIGtleSwgYW5kIGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZFxuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdGhlIGZvbGxvd2luZyBjb25maWd1cmF0aW9uOiB7XCJhXCI6IFwidmFsXCIsIFwiYXJyYXlcIjogWy4uLl0sIFwiYlwiOiBcInZhbFwifVxuICAgICAgICAgICAgICAgIC8vIEluIHRoYXQgY2FzZSBuYXZpZ2F0ZSBkb3duIHRvIHRoZSBjaGlsZCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q29udGFpbmVyU3RhY2tbY3VycmVudENvbnRhaW5lclN0YWNrLmxlbmd0aCAtIDFdID09PSBDb250YWluZXIuT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUcmVlID0gY3VycmVudFByb3BlcnR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTdXBwb3NlIHdlIGFyZSBpbnNpZGUgb2YgYW4gYXJyYXksIHRoZW4gc2luY2UgdGhlIGN1cnJlbnQgYXJyYXkgaXMgbm90IGFzc29jaWF0ZWQgdG8gYSBrZXksIGl0IGhhcyBub3QgYmVlbiBjcmVhdGVkIHlldFxuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdGhlIGZvbGxvd2luZyBjb25maWd1cmF0aW9uOiBbXCJhXCIsIFsuLi5dLCBcImJcIl1cbiAgICAgICAgICAgICAgICAvLyBJbiB0aGF0IGNhc2UgY3JlYXRlIHRoZSBwcm9wZXJ0eSBhbmQgbmF2aWdhdGUgZG93blxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRDb250YWluZXJTdGFja1tjdXJyZW50Q29udGFpbmVyU3RhY2subGVuZ3RoIC0gMV0gPT09IENvbnRhaW5lci5BcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZFByb3BlcnR5ID0gbmV3IFByb3BlcnR5VHJlZShzY2FubmVyLmdldFRva2VuVmFsdWUoKSwgYmVnaW5uaW5nTGluZU51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkUHJvcGVydHkubm9LZXlOYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFByb3BlcnR5ID0gY3VycmVudFByb3BlcnR5O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvcGVydHkgPSBjdXJyZW50VHJlZS5hZGRDaGlsZFByb3BlcnR5KGNoaWxkUHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VHJlZSA9IGN1cnJlbnRQcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRhaW5lclN0YWNrLnB1c2goQ29udGFpbmVyLkFycmF5KTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJvcGVydHkudHlwZSA9IENvbnRhaW5lci5BcnJheTtcbiAgICAgICAgICAgICAgICBiZWdpbm5pbmdMaW5lTnVtYmVyID0gc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpO1xuICAgICAgICAgICAgICAgIGJlZ2lubmluZ0xpbmVOdW1iZXIrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIHRva2VuIGlzIGFuIG9wZW4gYnJhY2UsIHRoZW4gd2UgZW50ZXIgaW50byBhbiBvYmplY3RcbiAgICAgICAgICAgIGNhc2UgMSAvKiBTeW50YXhLaW5kLk9wZW5CcmFjZVRva2VuICovOiB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJvb3QgdHJlZSBiZWdpbm5pbmcgbGluZSBudW1iZXIgaXMgbm90IGRlZmluZWQsIHRoZW4gdGhpcyBvcGVuIGJyYWNlIGlzIHRoZSBmaXJzdCBvcGVuIGJyYWNlIGluIHRoZSBkb2N1bWVudFxuICAgICAgICAgICAgICAgIGlmIChyb290VHJlZS5iZWdpbm5pbmdMaW5lTnVtYmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdFRyZWUuYmVnaW5uaW5nTGluZU51bWJlciA9IHNjYW5uZXIuZ2V0VG9rZW5TdGFydExpbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gMS4gSWYgd2UgYXJlIGluc2lkZSBvZiBhbiBvYmpldCwgdGhlIGN1cnJlbnQgb2JqZWN0IGlzIGFzc29jaWF0ZWQgdG8gYSBrZXkgYW5kIGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZFxuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdGhlIGZvbGxvd2luZyBjb25maWd1cmF0aW9uOiB7XCJhXCI6IFwidmFsXCIsIFwib2JqZWN0XCI6IHsuLi59LCBcImJcIjogXCJ2YWxcIn1cbiAgICAgICAgICAgICAgICAvLyAyLiBPdGhlcndpc2UgdGhlIGN1cnJlbnQgb2JqZWN0IHByb3BlcnR5IGlzIGluc2lkZSBvZiBhbiBhcnJheSwgbm90IGFzc29jaWF0ZWQgdG8gYSBrZXkgbmFtZSBhbmQgdGhlIHByb3BlcnR5IGhhcyBub3QgeWV0IGJlZW4gY3JlYXRlZFxuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdGhlIGZvbGxvd2luZyBjb25maWd1cmF0aW9uOiBbXCJhXCIsIHsuLi59LCBcImJcIl1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50Q29udGFpbmVyU3RhY2tbY3VycmVudENvbnRhaW5lclN0YWNrLmxlbmd0aCAtIDFdID09PSBDb250YWluZXIuQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRQcm9wZXJ0eSA9IG5ldyBQcm9wZXJ0eVRyZWUoc2Nhbm5lci5nZXRUb2tlblZhbHVlKCksIGJlZ2lubmluZ0xpbmVOdW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFByb3BlcnR5Lm5vS2V5TmFtZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RQcm9wZXJ0eSA9IGN1cnJlbnRQcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb3BlcnR5ID0gY3VycmVudFRyZWUuYWRkQ2hpbGRQcm9wZXJ0eShjaGlsZFByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudFByb3BlcnR5LnR5cGUgPSBDb250YWluZXIuT2JqZWN0O1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250YWluZXJTdGFjay5wdXNoKENvbnRhaW5lci5PYmplY3QpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUcmVlID0gY3VycmVudFByb3BlcnR5O1xuICAgICAgICAgICAgICAgIGJlZ2lubmluZ0xpbmVOdW1iZXIgPSBzY2FubmVyLmdldFRva2VuU3RhcnRMaW5lKCk7XG4gICAgICAgICAgICAgICAgYmVnaW5uaW5nTGluZU51bWJlcisrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSA0IC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFja2V0VG9rZW4gKi86IHtcbiAgICAgICAgICAgICAgICBlbmRMaW5lTnVtYmVyID0gc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250YWluZXJTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbGFzdCBub24tdHJpdmlhbCBub24tY29tbWVudCB0b2tlbiBpcyBhIGNsb3NpbmcgYnJhY2Ugb3IgYnJhY2tldCwgdGhlbiB0aGUgY3VycmVudFByb3BlcnR5IGVuZCBsaW5lIG51bWJlciBoYXMgbm90IGJlZW4gc2V0IHlldCBzbyBzZXQgaXRcbiAgICAgICAgICAgICAgICAvLyBUaGUgY29uZmlndXJhdGlvbiBjb25zaWRlcmVkIGlzOiBbLi4uLCB7fV0gb3IgWy4uLiwgW11dXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9wZXJ0eS5lbmRMaW5lTnVtYmVyID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgJiYgKGxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IDIgLyogU3ludGF4S2luZC5DbG9zZUJyYWNlVG9rZW4gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IGxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IDQgLyogU3ludGF4S2luZC5DbG9zZUJyYWNrZXRUb2tlbiAqLykpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb3BlcnR5LmVuZExpbmVOdW1iZXIgPSBlbmRMaW5lTnVtYmVyIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb3BlcnR5Lmxhc3RQcm9wZXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eS5saW5lV2hlcmVUb0FkZENvbW1hID0gbGluZU9mTGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbjtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb3BlcnR5LmluZGV4V2hlcmVUb0FkZENvbWEgPSBlbmRJbmRleE9mTGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbjtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFByb3BlcnR5ID0gY3VycmVudFByb3BlcnR5O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvcGVydHkgPSBjdXJyZW50UHJvcGVydHkgPyBjdXJyZW50UHJvcGVydHkucGFyZW50IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VHJlZSA9IGN1cnJlbnRQcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcm9vdFRyZWUuZW5kTGluZU51bWJlciA9IGVuZExpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgYmVnaW5uaW5nTGluZU51bWJlciA9IGVuZExpbmVOdW1iZXIgKyAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAyIC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICovOiB7XG4gICAgICAgICAgICAgICAgZW5kTGluZU51bWJlciA9IHNjYW5uZXIuZ2V0VG9rZW5TdGFydExpbmUoKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIG5vdCBpbnNpZGUgb2YgYW4gZW1wdHkgb2JqZWN0IGFuZCBjdXJyZW50IHByb3BlcnR5IGVuZCBsaW5lIG51bWJlciBoYXMgbm90IHlldCBiZWVuIGRlZmluZWQsIGRlZmluZSBpdFxuICAgICAgICAgICAgICAgIGlmIChsYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuICE9PSAxIC8qIFN5bnRheEtpbmQuT3BlbkJyYWNlVG9rZW4gKi9cbiAgICAgICAgICAgICAgICAgICAgJiYgY3VycmVudFByb3BlcnR5LmVuZExpbmVOdW1iZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvcGVydHkuZW5kTGluZU51bWJlciA9IGVuZExpbmVOdW1iZXIgLSAxO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY3VycmVudCBwcm9wZXJ0eSBpcyBhbHNvIHRoZSBsYXN0IHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eS5sYXN0UHJvcGVydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbGFzdCBwcm9wZXJ0eSBvZiBhbiBvYmplY3QgaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBsaW5lIGFuZCBpbmRleCBvZiB3aGVyZSB0byBhZGQgdGhlIGNvbW1hLCBpbiBjYXNlIGFmdGVyIHNvcnRpbmcsIGl0IGlzIG5vIGxvbmdlciB0aGUgbGFzdCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvcGVydHkubGluZVdoZXJlVG9BZGRDb21tYSA9IGxpbmVPZkxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eS5pbmRleFdoZXJlVG9BZGRDb21hID0gZW5kSW5kZXhPZkxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGxhc3RQcm9wZXJ0eSA9IGN1cnJlbnRQcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb3BlcnR5ID0gY3VycmVudFByb3BlcnR5ID8gY3VycmVudFByb3BlcnR5LnBhcmVudCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRyZWUgPSBjdXJyZW50UHJvcGVydHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJvb3RUcmVlLmVuZExpbmVOdW1iZXIgPSBzY2FubmVyLmdldFRva2VuU3RhcnRMaW5lKCk7XG4gICAgICAgICAgICAgICAgYmVnaW5uaW5nTGluZU51bWJlciA9IGVuZExpbmVOdW1iZXIgKyAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSA1IC8qIFN5bnRheEtpbmQuQ29tbWFUb2tlbiAqLzoge1xuICAgICAgICAgICAgICAgIGVuZExpbmVOdW1iZXIgPSBzY2FubmVyLmdldFRva2VuU3RhcnRMaW5lKCk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgY29udGFpbmVyIGlzIGFuIG9iamVjdCBvciB0aGUgY3VycmVudCBjb250YWluZXIgaXMgYW4gYXJyYXkgYW5kIHRoZSBsYXN0IG5vbi10cml2aWEgbm9uLWNvbW1lbnQgdG9rZW4gaXMgYSBjbG9zaW5nIGJyYWNlIG9yIGEgY2xvc2luZyBicmFja2V0XG4gICAgICAgICAgICAgICAgLy8gVGhlbiB1cGRhdGUgdGhlIGVuZCBsaW5lIG51bWJlciBvZiB0aGUgY3VycmVudCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UHJvcGVydHkuZW5kTGluZU51bWJlciA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICYmIChjdXJyZW50Q29udGFpbmVyU3RhY2tbY3VycmVudENvbnRhaW5lclN0YWNrLmxlbmd0aCAtIDFdID09PSBDb250YWluZXIuT2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICB8fCAoY3VycmVudENvbnRhaW5lclN0YWNrW2N1cnJlbnRDb250YWluZXJTdGFjay5sZW5ndGggLSAxXSA9PT0gQ29udGFpbmVyLkFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKGxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IDIgLyogU3ludGF4S2luZC5DbG9zZUJyYWNlVG9rZW4gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgbGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiA9PT0gNCAvKiBTeW50YXhLaW5kLkNsb3NlQnJhY2tldFRva2VuICovKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eS5lbmRMaW5lTnVtYmVyID0gZW5kTGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGxpbmUgYW5kIHRoZSBpbmRleCBvZiB0aGUgY29tbWEgaW4gY2FzZSBpdCBuZWVkcyB0byBiZSByZW1vdmVkIGR1cmluZyB0aGUgc29ydGluZ1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvcGVydHkuY29tbWFJbmRleCA9IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSAtIG51bWJlck9mQ2hhcmFjdGVyc09uUHJldmlvdXNMaW5lcztcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb3BlcnR5LmNvbW1hTGluZSA9IGVuZExpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID09PSAyIC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICovXG4gICAgICAgICAgICAgICAgICAgIHx8IGxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IDQgLyogU3ludGF4S2luZC5DbG9zZUJyYWNrZXRUb2tlbiAqLykge1xuICAgICAgICAgICAgICAgICAgICBsYXN0UHJvcGVydHkgPSBjdXJyZW50UHJvcGVydHk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eSA9IGN1cnJlbnRQcm9wZXJ0eSA/IGN1cnJlbnRQcm9wZXJ0eS5wYXJlbnQgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUcmVlID0gY3VycmVudFByb3BlcnR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiZWdpbm5pbmdMaW5lTnVtYmVyID0gZW5kTGluZU51bWJlciArIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDEzIC8qIFN5bnRheEtpbmQuQmxvY2tDb21tZW50VHJpdmlhICovOiB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGxhc3Qgbm9uIHRyaXZpYSBub24tY29tbWVudCB0b2tlbiBpcyBhIGNvbW1hIGFuZCB0aGUgYmxvY2sgY29tbWVudCBzdGFydHMgb24gdGhlIHNhbWUgbGluZSBhcyB0aGUgY29tbWEsIHRoZW4gdXBkYXRlIHRoZSBlbmQgbGluZSBudW1iZXIgb2YgdGhlIGN1cnJlbnQgcHJvcGVydHkuIEZvciBleGFtcGxlIGlmOlxuICAgICAgICAgICAgICAgIC8vIDEuIHt9LCAvKiAuLi5cbiAgICAgICAgICAgICAgICAvLyAyLiAuLiovXG4gICAgICAgICAgICAgICAgLy8gVGhlIHRoZSBwcm9wZXJ0eSBvbiBsaW5lIDEgc2hvdWQgZW5kIG9uIGxpbmUgMiwgbm90IGxpbmUgMVxuICAgICAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIHdlIGFyZSBpbiBhbiBhcnJheSB3ZSB1cGRhdGUgdGhlIGVuZCBsaW5lIG51bWJlciBvbmx5IGlmIHRoZSBzZWNvbmQgdG8gbGFzdCBub24tdHJpdmlhIG5vbi1jb21tZW50IHRva2VuIGlzIGEgY2xvc2luZyBicmFjZSBvciBicmFja2V0XG4gICAgICAgICAgICAgICAgaWYgKGxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IDUgLyogU3ludGF4S2luZC5Db21tYVRva2VuICovXG4gICAgICAgICAgICAgICAgICAgICYmIGxpbmVPZkxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IHNjYW5uZXIuZ2V0VG9rZW5TdGFydExpbmUoKVxuICAgICAgICAgICAgICAgICAgICAmJiAoY3VycmVudENvbnRhaW5lclN0YWNrW2N1cnJlbnRDb250YWluZXJTdGFjay5sZW5ndGggLSAxXSA9PT0gQ29udGFpbmVyLkFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAoc2Vjb25kVG9MYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID09PSAyIC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgc2Vjb25kVG9MYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID09PSA0IC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFja2V0VG9rZW4gKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBjdXJyZW50Q29udGFpbmVyU3RhY2tbY3VycmVudENvbnRhaW5lclN0YWNrLmxlbmd0aCAtIDFdID09PSBDb250YWluZXIuT2JqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudENvbnRhaW5lclN0YWNrW2N1cnJlbnRDb250YWluZXJTdGFjay5sZW5ndGggLSAxXSA9PT0gQ29udGFpbmVyLkFycmF5ICYmIChzZWNvbmRUb0xhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IDIgLyogU3ludGF4S2luZC5DbG9zZUJyYWNlVG9rZW4gKi8gfHwgc2Vjb25kVG9MYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID09PSA0IC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFja2V0VG9rZW4gKi8pIHx8IGN1cnJlbnRDb250YWluZXJTdGFja1tjdXJyZW50Q29udGFpbmVyU3RhY2subGVuZ3RoIC0gMV0gPT09IENvbnRhaW5lci5PYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eS5lbmRMaW5lTnVtYmVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlTGFzdFByb3BlcnR5RW5kTGluZU51bWJlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgYmxvY2sgY29tbWVudCBmb2xsb3dzIGFuIG9wZW4gYnJhY2Ugb3IgYW4gb3BlbiB0b2tlbiwgd2UgaGF2ZSB0aGUgZm9sbG93aW5nIHNjZW5hcmlvOlxuICAgICAgICAgICAgICAgIC8vIHsgLyoqXG4gICAgICAgICAgICAgICAgLy8gLi4vXG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIC8vIFRoZSBibG9jayBjb21tZW50IHNob3VsZCBiZSBhc3NpZ25lZCB0byB0aGUgb3BlbiBicmFjZSBub3QgdGhlIGZpcnN0IHByb3BlcnR5IGJlbG93IGl0XG4gICAgICAgICAgICAgICAgaWYgKChsYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID09PSAxIC8qIFN5bnRheEtpbmQuT3BlbkJyYWNlVG9rZW4gKi9cbiAgICAgICAgICAgICAgICAgICAgfHwgbGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiA9PT0gMyAvKiBTeW50YXhLaW5kLk9wZW5CcmFja2V0VG9rZW4gKi8pXG4gICAgICAgICAgICAgICAgICAgICYmIGxpbmVPZkxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IHNjYW5uZXIuZ2V0VG9rZW5TdGFydExpbmUoKSkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVCZWdpbm5pbmdMaW5lTnVtYmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBsYXN0IGFuZCBzZWNvbmQgdG8gbGFzdCBub24tdHJpdmlhIG5vbi1jb21tZW50IHRva2Vuc1xuICAgICAgICBpZiAodG9rZW4gIT09IDE0IC8qIFN5bnRheEtpbmQuTGluZUJyZWFrVHJpdmlhICovXG4gICAgICAgICAgICAmJiB0b2tlbiAhPT0gMTMgLyogU3ludGF4S2luZC5CbG9ja0NvbW1lbnRUcml2aWEgKi9cbiAgICAgICAgICAgICYmIHRva2VuICE9PSAxMiAvKiBTeW50YXhLaW5kLkxpbmVDb21tZW50VHJpdmlhICovXG4gICAgICAgICAgICAmJiB0b2tlbiAhPT0gMTUgLyogU3ludGF4S2luZC5Ucml2aWEgKi8pIHtcbiAgICAgICAgICAgIHNlY29uZFRvTGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiA9IGxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW47XG4gICAgICAgICAgICBsYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID0gdG9rZW47XG4gICAgICAgICAgICBsaW5lT2ZMYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID0gc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpO1xuICAgICAgICAgICAgZW5kSW5kZXhPZkxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPSBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkgKyBzY2FubmVyLmdldFRva2VuTGVuZ3RoKCkgLSBudW1iZXJPZkNoYXJhY3RlcnNPblByZXZpb3VzTGluZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJvb3RUcmVlO1xufVxuZnVuY3Rpb24gc29ydEpzb25jRG9jdW1lbnQoanNvbkRvY3VtZW50LCBwcm9wZXJ0eVRyZWUpIHtcbiAgICBpZiAocHJvcGVydHlUcmVlLmNoaWxkcmVuUHJvcGVydGllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGpzb25Eb2N1bWVudDtcbiAgICB9XG4gICAgY29uc3Qgc29ydGVkSnNvbkRvY3VtZW50ID0gZXNtX21haW4vKiBUZXh0RG9jdW1lbnQgKi8ubi5jcmVhdGUoJ3Rlc3Q6Ly90ZXN0Lmpzb24nLCAnanNvbicsIDAsIGpzb25Eb2N1bWVudC5nZXRUZXh0KCkpO1xuICAgIGNvbnN0IHF1ZXVlVG9Tb3J0ID0gW107XG4gICAgdXBkYXRlU29ydGluZ1F1ZXVlKHF1ZXVlVG9Tb3J0LCBwcm9wZXJ0eVRyZWUsIHByb3BlcnR5VHJlZS5iZWdpbm5pbmdMaW5lTnVtYmVyKTtcbiAgICB3aGlsZSAocXVldWVUb1NvcnQubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBkYXRhVG9Tb3J0ID0gcXVldWVUb1NvcnQuc2hpZnQoKTtcbiAgICAgICAgY29uc3QgcHJvcGVydHlUcmVlQXJyYXkgPSBkYXRhVG9Tb3J0LnByb3BlcnR5VHJlZUFycmF5O1xuICAgICAgICBsZXQgYmVnaW5uaW5nTGluZU51bWJlciA9IGRhdGFUb1NvcnQuYmVnaW5uaW5nTGluZU51bWJlcjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wZXJ0eVRyZWVBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydHlUcmVlID0gcHJvcGVydHlUcmVlQXJyYXlbaV07XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IG1haW4uUmFuZ2UuY3JlYXRlKG1haW4uUG9zaXRpb24uY3JlYXRlKHByb3BlcnR5VHJlZS5iZWdpbm5pbmdMaW5lTnVtYmVyLCAwKSwgbWFpbi5Qb3NpdGlvbi5jcmVhdGUocHJvcGVydHlUcmVlLmVuZExpbmVOdW1iZXIgKyAxLCAwKSk7XG4gICAgICAgICAgICBjb25zdCBqc29uQ29udGVudFRvUmVwbGFjZSA9IGpzb25Eb2N1bWVudC5nZXRUZXh0KHJhbmdlKTtcbiAgICAgICAgICAgIGNvbnN0IGpzb25Eb2N1bWVudFRvUmVwbGFjZSA9IGVzbV9tYWluLyogVGV4dERvY3VtZW50ICovLm4uY3JlYXRlKCd0ZXN0Oi8vdGVzdC5qc29uJywgJ2pzb24nLCAwLCBqc29uQ29udGVudFRvUmVwbGFjZSk7XG4gICAgICAgICAgICBpZiAocHJvcGVydHlUcmVlLmxhc3RQcm9wZXJ0eSA9PT0gdHJ1ZSAmJiBpICE9PSBwcm9wZXJ0eVRyZWVBcnJheS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZVdoZXJlVG9BZGRDb21tYSA9IHByb3BlcnR5VHJlZS5saW5lV2hlcmVUb0FkZENvbW1hIC0gcHJvcGVydHlUcmVlLmJlZ2lubmluZ0xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXhXaGVyZVRvQWRkQ29tbWEgPSBwcm9wZXJ0eVRyZWUuaW5kZXhXaGVyZVRvQWRkQ29tYTtcbiAgICAgICAgICAgICAgICBjb25zdCBlZGl0ID0ge1xuICAgICAgICAgICAgICAgICAgICByYW5nZTogbWFpbi5SYW5nZS5jcmVhdGUobWFpbi5Qb3NpdGlvbi5jcmVhdGUobGluZVdoZXJlVG9BZGRDb21tYSwgaW5kZXhXaGVyZVRvQWRkQ29tbWEpLCBtYWluLlBvc2l0aW9uLmNyZWF0ZShsaW5lV2hlcmVUb0FkZENvbW1hLCBpbmRleFdoZXJlVG9BZGRDb21tYSkpLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnLCdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGVzbV9tYWluLyogVGV4dERvY3VtZW50ICovLm4udXBkYXRlKGpzb25Eb2N1bWVudFRvUmVwbGFjZSwgW2VkaXRdLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3BlcnR5VHJlZS5sYXN0UHJvcGVydHkgPT09IGZhbHNlICYmIGkgPT09IHByb3BlcnR5VHJlZUFycmF5Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21tYUluZGV4ID0gcHJvcGVydHlUcmVlLmNvbW1hSW5kZXg7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWFMaW5lID0gcHJvcGVydHlUcmVlLmNvbW1hTGluZTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lV2hlcmVUb1JlbW92ZUNvbW1hID0gY29tbWFMaW5lIC0gcHJvcGVydHlUcmVlLmJlZ2lubmluZ0xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgY29uc3QgZWRpdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IG1haW4uUmFuZ2UuY3JlYXRlKG1haW4uUG9zaXRpb24uY3JlYXRlKGxpbmVXaGVyZVRvUmVtb3ZlQ29tbWEsIGNvbW1hSW5kZXgpLCBtYWluLlBvc2l0aW9uLmNyZWF0ZShsaW5lV2hlcmVUb1JlbW92ZUNvbW1hLCBjb21tYUluZGV4ICsgMSkpLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZXNtX21haW4vKiBUZXh0RG9jdW1lbnQgKi8ubi51cGRhdGUoanNvbkRvY3VtZW50VG9SZXBsYWNlLCBbZWRpdF0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcHJvcGVydHlUcmVlLmVuZExpbmVOdW1iZXIgLSBwcm9wZXJ0eVRyZWUuYmVnaW5uaW5nTGluZU51bWJlciArIDE7XG4gICAgICAgICAgICBjb25zdCBlZGl0ID0ge1xuICAgICAgICAgICAgICAgIHJhbmdlOiBtYWluLlJhbmdlLmNyZWF0ZShtYWluLlBvc2l0aW9uLmNyZWF0ZShiZWdpbm5pbmdMaW5lTnVtYmVyLCAwKSwgbWFpbi5Qb3NpdGlvbi5jcmVhdGUoYmVnaW5uaW5nTGluZU51bWJlciArIGxlbmd0aCwgMCkpLFxuICAgICAgICAgICAgICAgIHRleHQ6IGpzb25Eb2N1bWVudFRvUmVwbGFjZS5nZXRUZXh0KClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlc21fbWFpbi8qIFRleHREb2N1bWVudCAqLy5uLnVwZGF0ZShzb3J0ZWRKc29uRG9jdW1lbnQsIFtlZGl0XSwgMSk7XG4gICAgICAgICAgICB1cGRhdGVTb3J0aW5nUXVldWUocXVldWVUb1NvcnQsIHByb3BlcnR5VHJlZSwgYmVnaW5uaW5nTGluZU51bWJlcik7XG4gICAgICAgICAgICBiZWdpbm5pbmdMaW5lTnVtYmVyID0gYmVnaW5uaW5nTGluZU51bWJlciArIGxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc29ydGVkSnNvbkRvY3VtZW50O1xufVxuZnVuY3Rpb24gdXBkYXRlU29ydGluZ1F1ZXVlKHF1ZXVlLCBwcm9wZXJ0eVRyZWUsIGJlZ2lubmluZ0xpbmVOdW1iZXIpIHtcbiAgICBpZiAocHJvcGVydHlUcmVlLmNoaWxkcmVuUHJvcGVydGllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocHJvcGVydHlUcmVlLnR5cGUgPT09IENvbnRhaW5lci5PYmplY3QpIHtcbiAgICAgICAgbGV0IG1pbmltdW1CZWdpbm5pbmdMaW5lTnVtYmVyID0gSW5maW5pdHk7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGRQcm9wZXJ0eSBvZiBwcm9wZXJ0eVRyZWUuY2hpbGRyZW5Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRQcm9wZXJ0eS5iZWdpbm5pbmdMaW5lTnVtYmVyIDwgbWluaW11bUJlZ2lubmluZ0xpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICBtaW5pbXVtQmVnaW5uaW5nTGluZU51bWJlciA9IGNoaWxkUHJvcGVydHkuYmVnaW5uaW5nTGluZU51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaWZmID0gbWluaW11bUJlZ2lubmluZ0xpbmVOdW1iZXIgLSBwcm9wZXJ0eVRyZWUuYmVnaW5uaW5nTGluZU51bWJlcjtcbiAgICAgICAgYmVnaW5uaW5nTGluZU51bWJlciA9IGJlZ2lubmluZ0xpbmVOdW1iZXIgKyBkaWZmO1xuICAgICAgICBxdWV1ZS5wdXNoKG5ldyBTb3J0aW5nUmFuZ2UoYmVnaW5uaW5nTGluZU51bWJlciwgcHJvcGVydHlUcmVlLmNoaWxkcmVuUHJvcGVydGllcykpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9wZXJ0eVRyZWUudHlwZSA9PT0gQ29udGFpbmVyLkFycmF5KSB7XG4gICAgICAgIHVwZGF0ZVNvcnRpbmdRdWV1ZUZvckFycmF5UHJvcGVydGllcyhxdWV1ZSwgcHJvcGVydHlUcmVlLCBiZWdpbm5pbmdMaW5lTnVtYmVyKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVTb3J0aW5nUXVldWVGb3JBcnJheVByb3BlcnRpZXMocXVldWUsIHByb3BlcnR5VHJlZSwgYmVnaW5uaW5nTGluZU51bWJlcikge1xuICAgIGZvciAoY29uc3Qgc3ViT2JqZWN0IG9mIHByb3BlcnR5VHJlZS5jaGlsZHJlblByb3BlcnRpZXMpIHtcbiAgICAgICAgLy8gSWYgdGhlIGNoaWxkIHByb3BlcnR5IG9mIHRoZSBhcnJheSBpcyBhbiBvYmplY3QsIHRoZW4geW91IGNhbiBzb3J0IHRoZSBwcm9wZXJ0aWVzIHdpdGhpbiB0aGlzIG9iamVjdFxuICAgICAgICBpZiAoc3ViT2JqZWN0LnR5cGUgPT09IENvbnRhaW5lci5PYmplY3QpIHtcbiAgICAgICAgICAgIGxldCBtaW5pbXVtQmVnaW5uaW5nTGluZU51bWJlciA9IEluZmluaXR5O1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZFByb3BlcnR5IG9mIHN1Yk9iamVjdC5jaGlsZHJlblByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRQcm9wZXJ0eS5iZWdpbm5pbmdMaW5lTnVtYmVyIDwgbWluaW11bUJlZ2lubmluZ0xpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bUJlZ2lubmluZ0xpbmVOdW1iZXIgPSBjaGlsZFByb3BlcnR5LmJlZ2lubmluZ0xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGlmZiA9IG1pbmltdW1CZWdpbm5pbmdMaW5lTnVtYmVyIC0gc3ViT2JqZWN0LmJlZ2lubmluZ0xpbmVOdW1iZXI7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKG5ldyBTb3J0aW5nUmFuZ2UoYmVnaW5uaW5nTGluZU51bWJlciArIHN1Yk9iamVjdC5iZWdpbm5pbmdMaW5lTnVtYmVyIC0gcHJvcGVydHlUcmVlLmJlZ2lubmluZ0xpbmVOdW1iZXIgKyBkaWZmLCBzdWJPYmplY3QuY2hpbGRyZW5Qcm9wZXJ0aWVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGNoaWxkIHByb3BlcnR5IG9mIHRoZSBhcnJheSBpcyBhbiBhcnJheSwgdGhlbiB5b3UgbmVlZCB0byByZWN1cnNlIG9uIHRoZSBjaGlsZHJlbiBwcm9wZXJ0aWVzLCB1bnRpbCB5b3UgZmluZCBhbiBvYmplY3QgdG8gc29ydFxuICAgICAgICBpZiAoc3ViT2JqZWN0LnR5cGUgPT09IENvbnRhaW5lci5BcnJheSkge1xuICAgICAgICAgICAgdXBkYXRlU29ydGluZ1F1ZXVlRm9yQXJyYXlQcm9wZXJ0aWVzKHF1ZXVlLCBzdWJPYmplY3QsIGJlZ2lubmluZ0xpbmVOdW1iZXIgKyBzdWJPYmplY3QuYmVnaW5uaW5nTGluZU51bWJlciAtIHByb3BlcnR5VHJlZS5iZWdpbm5pbmdMaW5lTnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFNvcnRpbmdSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoYmVnaW5uaW5nTGluZU51bWJlciwgcHJvcGVydHlUcmVlQXJyYXkpIHtcbiAgICAgICAgdGhpcy5iZWdpbm5pbmdMaW5lTnVtYmVyID0gYmVnaW5uaW5nTGluZU51bWJlcjtcbiAgICAgICAgdGhpcy5wcm9wZXJ0eVRyZWVBcnJheSA9IHByb3BlcnR5VHJlZUFycmF5O1xuICAgIH1cbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2UvbGliL2VzbS9zZXJ2aWNlcy9qc29uTGlua3MuanNcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5mdW5jdGlvbiBmaW5kTGlua3MoZG9jdW1lbnQsIGRvYykge1xuICAgIGNvbnN0IGxpbmtzID0gW107XG4gICAgZG9jLnZpc2l0KG5vZGUgPT4ge1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSBcInByb3BlcnR5XCIgJiYgbm9kZS5rZXlOb2RlLnZhbHVlID09PSBcIiRyZWZcIiAmJiBub2RlLnZhbHVlTm9kZT8udHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBub2RlLnZhbHVlTm9kZS52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBmaW5kVGFyZ2V0Tm9kZShkb2MsIHBhdGgpO1xuICAgICAgICAgICAgaWYgKHRhcmdldE5vZGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRQb3MgPSBkb2N1bWVudC5wb3NpdGlvbkF0KHRhcmdldE5vZGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBsaW5rcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBgJHtkb2N1bWVudC51cml9IyR7dGFyZ2V0UG9zLmxpbmUgKyAxfSwke3RhcmdldFBvcy5jaGFyYWN0ZXIgKyAxfWAsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBjcmVhdGVSYW5nZShkb2N1bWVudCwgbm9kZS52YWx1ZU5vZGUpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShsaW5rcyk7XG59XG5mdW5jdGlvbiBjcmVhdGVSYW5nZShkb2N1bWVudCwgbm9kZSkge1xuICAgIHJldHVybiBtYWluLlJhbmdlLmNyZWF0ZShkb2N1bWVudC5wb3NpdGlvbkF0KG5vZGUub2Zmc2V0ICsgMSksIGRvY3VtZW50LnBvc2l0aW9uQXQobm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aCAtIDEpKTtcbn1cbmZ1bmN0aW9uIGZpbmRUYXJnZXROb2RlKGRvYywgcGF0aCkge1xuICAgIGNvbnN0IHRva2VucyA9IHBhcnNlSlNPTlBvaW50ZXIocGF0aCk7XG4gICAgaWYgKCF0b2tlbnMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBmaW5kTm9kZSh0b2tlbnMsIGRvYy5yb290KTtcbn1cbmZ1bmN0aW9uIGZpbmROb2RlKHBvaW50ZXIsIG5vZGUpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChwb2ludGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgY29uc3QgdG9rZW4gPSBwb2ludGVyLnNoaWZ0KCk7XG4gICAgaWYgKG5vZGUgJiYgbm9kZS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCBwcm9wZXJ0eU5vZGUgPSBub2RlLnByb3BlcnRpZXMuZmluZCgocHJvcGVydHlOb2RlKSA9PiBwcm9wZXJ0eU5vZGUua2V5Tm9kZS52YWx1ZSA9PT0gdG9rZW4pO1xuICAgICAgICBpZiAoIXByb3BlcnR5Tm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbmROb2RlKHBvaW50ZXIsIHByb3BlcnR5Tm9kZS52YWx1ZU5vZGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlICYmIG5vZGUudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICBpZiAodG9rZW4ubWF0Y2goL14oMHxbMS05XVswLTldKikkLykpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gTnVtYmVyLnBhcnNlSW50KHRva2VuKTtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5SXRlbSA9IG5vZGUuaXRlbXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKCFhcnJheUl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaW5kTm9kZShwb2ludGVyLCBhcnJheUl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VKU09OUG9pbnRlcihwYXRoKSB7XG4gICAgaWYgKHBhdGggPT09IFwiI1wiKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKHBhdGhbMF0gIT09ICcjJyB8fCBwYXRoWzFdICE9PSAnLycpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBwYXRoLnN1YnN0cmluZygyKS5zcGxpdCgvXFwvLykubWFwKGpzb25MaW5rc191bmVzY2FwZSk7XG59XG5mdW5jdGlvbiBqc29uTGlua3NfdW5lc2NhcGUoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+MS9nLCAnLycpLnJlcGxhY2UoL34wL2csICd+Jyk7XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL2xpYi9lc20vanNvbkxhbmd1YWdlU2VydmljZS5qc1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIGdldExhbmd1YWdlU2VydmljZShwYXJhbXMpIHtcbiAgICBjb25zdCBwcm9taXNlID0gcGFyYW1zLnByb21pc2VDb25zdHJ1Y3RvciB8fCBQcm9taXNlO1xuICAgIGNvbnN0IGpzb25TY2hlbWFTZXJ2aWNlID0gbmV3IEpTT05TY2hlbWFTZXJ2aWNlKHBhcmFtcy5zY2hlbWFSZXF1ZXN0U2VydmljZSwgcGFyYW1zLndvcmtzcGFjZUNvbnRleHQsIHByb21pc2UpO1xuICAgIGpzb25TY2hlbWFTZXJ2aWNlLnNldFNjaGVtYUNvbnRyaWJ1dGlvbnMoc2NoZW1hQ29udHJpYnV0aW9ucyk7XG4gICAgY29uc3QganNvbkNvbXBsZXRpb24gPSBuZXcgSlNPTkNvbXBsZXRpb24oanNvblNjaGVtYVNlcnZpY2UsIHBhcmFtcy5jb250cmlidXRpb25zLCBwcm9taXNlLCBwYXJhbXMuY2xpZW50Q2FwYWJpbGl0aWVzKTtcbiAgICBjb25zdCBqc29uSG92ZXIgPSBuZXcgSlNPTkhvdmVyKGpzb25TY2hlbWFTZXJ2aWNlLCBwYXJhbXMuY29udHJpYnV0aW9ucywgcHJvbWlzZSk7XG4gICAgY29uc3QganNvbkRvY3VtZW50U3ltYm9scyA9IG5ldyBKU09ORG9jdW1lbnRTeW1ib2xzKGpzb25TY2hlbWFTZXJ2aWNlKTtcbiAgICBjb25zdCBqc29uVmFsaWRhdGlvbiA9IG5ldyBKU09OVmFsaWRhdGlvbihqc29uU2NoZW1hU2VydmljZSwgcHJvbWlzZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29uZmlndXJlOiAoc2V0dGluZ3MpID0+IHtcbiAgICAgICAgICAgIGpzb25TY2hlbWFTZXJ2aWNlLmNsZWFyRXh0ZXJuYWxTY2hlbWFzKCk7XG4gICAgICAgICAgICBzZXR0aW5ncy5zY2hlbWFzPy5mb3JFYWNoKGpzb25TY2hlbWFTZXJ2aWNlLnJlZ2lzdGVyRXh0ZXJuYWxTY2hlbWEuYmluZChqc29uU2NoZW1hU2VydmljZSkpO1xuICAgICAgICAgICAganNvblZhbGlkYXRpb24uY29uZmlndXJlKHNldHRpbmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXRTY2hlbWE6ICh1cmkpID0+IGpzb25TY2hlbWFTZXJ2aWNlLm9uUmVzb3VyY2VDaGFuZ2UodXJpKSxcbiAgICAgICAgZG9WYWxpZGF0aW9uOiBqc29uVmFsaWRhdGlvbi5kb1ZhbGlkYXRpb24uYmluZChqc29uVmFsaWRhdGlvbiksXG4gICAgICAgIGdldExhbmd1YWdlU3RhdHVzOiBqc29uVmFsaWRhdGlvbi5nZXRMYW5ndWFnZVN0YXR1cy5iaW5kKGpzb25WYWxpZGF0aW9uKSxcbiAgICAgICAgcGFyc2VKU09ORG9jdW1lbnQ6IChkb2N1bWVudCkgPT4ganNvblBhcnNlcl9wYXJzZShkb2N1bWVudCwgeyBjb2xsZWN0Q29tbWVudHM6IHRydWUgfSksXG4gICAgICAgIG5ld0pTT05Eb2N1bWVudDogKHJvb3QsIGRpYWdub3N0aWNzKSA9PiBuZXdKU09ORG9jdW1lbnQocm9vdCwgZGlhZ25vc3RpY3MpLFxuICAgICAgICBnZXRNYXRjaGluZ1NjaGVtYXM6IGpzb25TY2hlbWFTZXJ2aWNlLmdldE1hdGNoaW5nU2NoZW1hcy5iaW5kKGpzb25TY2hlbWFTZXJ2aWNlKSxcbiAgICAgICAgZG9SZXNvbHZlOiBqc29uQ29tcGxldGlvbi5kb1Jlc29sdmUuYmluZChqc29uQ29tcGxldGlvbiksXG4gICAgICAgIGRvQ29tcGxldGU6IGpzb25Db21wbGV0aW9uLmRvQ29tcGxldGUuYmluZChqc29uQ29tcGxldGlvbiksXG4gICAgICAgIGZpbmREb2N1bWVudFN5bWJvbHM6IGpzb25Eb2N1bWVudFN5bWJvbHMuZmluZERvY3VtZW50U3ltYm9scy5iaW5kKGpzb25Eb2N1bWVudFN5bWJvbHMpLFxuICAgICAgICBmaW5kRG9jdW1lbnRTeW1ib2xzMjoganNvbkRvY3VtZW50U3ltYm9scy5maW5kRG9jdW1lbnRTeW1ib2xzMi5iaW5kKGpzb25Eb2N1bWVudFN5bWJvbHMpLFxuICAgICAgICBmaW5kRG9jdW1lbnRDb2xvcnM6IGpzb25Eb2N1bWVudFN5bWJvbHMuZmluZERvY3VtZW50Q29sb3JzLmJpbmQoanNvbkRvY3VtZW50U3ltYm9scyksXG4gICAgICAgIGdldENvbG9yUHJlc2VudGF0aW9uczoganNvbkRvY3VtZW50U3ltYm9scy5nZXRDb2xvclByZXNlbnRhdGlvbnMuYmluZChqc29uRG9jdW1lbnRTeW1ib2xzKSxcbiAgICAgICAgZG9Ib3ZlcjoganNvbkhvdmVyLmRvSG92ZXIuYmluZChqc29uSG92ZXIpLFxuICAgICAgICBnZXRGb2xkaW5nUmFuZ2VzOiBnZXRGb2xkaW5nUmFuZ2VzLFxuICAgICAgICBnZXRTZWxlY3Rpb25SYW5nZXM6IGdldFNlbGVjdGlvblJhbmdlcyxcbiAgICAgICAgZmluZERlZmluaXRpb246ICgpID0+IFByb21pc2UucmVzb2x2ZShbXSksXG4gICAgICAgIGZpbmRMaW5rczogZmluZExpbmtzLFxuICAgICAgICBmb3JtYXQ6IChkb2N1bWVudCwgcmFuZ2UsIG9wdGlvbnMpID0+IHV0aWxzX2Zvcm1hdF9mb3JtYXQoZG9jdW1lbnQsIG9wdGlvbnMsIHJhbmdlKSxcbiAgICAgICAgc29ydDogKGRvY3VtZW50LCBvcHRpb25zKSA9PiBzb3J0KGRvY3VtZW50LCBvcHRpb25zKVxuICAgIH07XG59XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1sYW5ndWFnZXNlcnZlci1wcm90b2NvbC9saWIvYnJvd3Nlci9tYWluLmpzXG52YXIgYnJvd3Nlcl9tYWluID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOTQpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy91dGlscy50c1xudmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Mjk3KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9hY2UvcmFuZ2Utc2luZ2xldG9uLnRzXG5mdW5jdGlvbiBfZGVmaW5lX3Byb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5jbGFzcyBBY2VSYW5nZSB7XG4gICAgc3RhdGljIGdldENvbnN0cnVjdG9yKGVkaXRvcikge1xuICAgICAgICBpZiAoIUFjZVJhbmdlLl9pbnN0YW5jZSAmJiBlZGl0b3IpIHtcbiAgICAgICAgICAgIEFjZVJhbmdlLl9pbnN0YW5jZSA9IGVkaXRvci5nZXRTZWxlY3Rpb25SYW5nZSgpLmNvbnN0cnVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBY2VSYW5nZS5faW5zdGFuY2U7XG4gICAgfVxufVxuX2RlZmluZV9wcm9wZXJ0eShBY2VSYW5nZSwgXCJfaW5zdGFuY2VcIiwgdm9pZCAwKTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3R5cGUtY29udmVydGVycy9jb21tb24tY29udmVydGVycy50c1xuXG5cblxudmFyIGNvbW1vbl9jb252ZXJ0ZXJzX0NvbW1vbkNvbnZlcnRlcjtcbihmdW5jdGlvbihDb21tb25Db252ZXJ0ZXIpIHtcbiAgICBmdW5jdGlvbiBub3JtYWxpemVSYW5nZXMoY29tcGxldGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRpb25zICYmIGNvbXBsZXRpb25zLm1hcCgoZWwpPT57XG4gICAgICAgICAgICBpZiAoZWxbXCJyYW5nZVwiXSkge1xuICAgICAgICAgICAgICAgIGVsW1wicmFuZ2VcIl0gPSB0b1JhbmdlKGVsW1wicmFuZ2VcIl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgQ29tbW9uQ29udmVydGVyLm5vcm1hbGl6ZVJhbmdlcyA9IG5vcm1hbGl6ZVJhbmdlcztcbiAgICBmdW5jdGlvbiBjbGVhbkh0bWwoaHRtbCkge1xuICAgICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKC88YVxccy8sIFwiPGEgdGFyZ2V0PSdfYmxhbmsnIFwiKTtcbiAgICB9XG4gICAgQ29tbW9uQ29udmVydGVyLmNsZWFuSHRtbCA9IGNsZWFuSHRtbDtcbiAgICBmdW5jdGlvbiB0b1JhbmdlKHJhbmdlKSB7XG4gICAgICAgIGlmICghcmFuZ2UgfHwgIXJhbmdlLnN0YXJ0IHx8ICFyYW5nZS5lbmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgUmFuZ2UgPSBBY2VSYW5nZS5nZXRDb25zdHJ1Y3RvcigpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBSYW5nZS5mcm9tUG9pbnRzKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpO1xuICAgIH1cbiAgICBDb21tb25Db252ZXJ0ZXIudG9SYW5nZSA9IHRvUmFuZ2U7XG4gICAgZnVuY3Rpb24gY29udmVydEtpbmQoa2luZCkge1xuICAgICAgICBzd2l0Y2goa2luZCl7XG4gICAgICAgICAgICBjYXNlIFwicHJpbWl0aXZlVHlwZVwiOlxuICAgICAgICAgICAgY2FzZSBcImtleXdvcmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYnJvd3Nlcl9tYWluLkNvbXBsZXRpb25JdGVtS2luZC5LZXl3b3JkO1xuICAgICAgICAgICAgY2FzZSBcInZhcmlhYmxlXCI6XG4gICAgICAgICAgICBjYXNlIFwibG9jYWxWYXJpYWJsZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBicm93c2VyX21haW4uQ29tcGxldGlvbkl0ZW1LaW5kLlZhcmlhYmxlO1xuICAgICAgICAgICAgY2FzZSBcIm1lbWJlclZhcmlhYmxlXCI6XG4gICAgICAgICAgICBjYXNlIFwibWVtYmVyR2V0QWNjZXNzb3JcIjpcbiAgICAgICAgICAgIGNhc2UgXCJtZW1iZXJTZXRBY2Nlc3NvclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBicm93c2VyX21haW4uQ29tcGxldGlvbkl0ZW1LaW5kLkZpZWxkO1xuICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICBjYXNlIFwibWVtYmVyRnVuY3Rpb25cIjpcbiAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RTaWduYXR1cmVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJjYWxsU2lnbmF0dXJlXCI6XG4gICAgICAgICAgICBjYXNlIFwiaW5kZXhTaWduYXR1cmVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYnJvd3Nlcl9tYWluLkNvbXBsZXRpb25JdGVtS2luZC5GdW5jdGlvbjtcbiAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJyb3dzZXJfbWFpbi5Db21wbGV0aW9uSXRlbUtpbmQuRW51bTtcbiAgICAgICAgICAgIGNhc2UgXCJtb2R1bGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYnJvd3Nlcl9tYWluLkNvbXBsZXRpb25JdGVtS2luZC5Nb2R1bGU7XG4gICAgICAgICAgICBjYXNlIFwiY2xhc3NcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYnJvd3Nlcl9tYWluLkNvbXBsZXRpb25JdGVtS2luZC5DbGFzcztcbiAgICAgICAgICAgIGNhc2UgXCJpbnRlcmZhY2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYnJvd3Nlcl9tYWluLkNvbXBsZXRpb25JdGVtS2luZC5JbnRlcmZhY2U7XG4gICAgICAgICAgICBjYXNlIFwid2FybmluZ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBicm93c2VyX21haW4uQ29tcGxldGlvbkl0ZW1LaW5kLkZpbGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJyb3dzZXJfbWFpbi5Db21wbGV0aW9uSXRlbUtpbmQuUHJvcGVydHk7XG4gICAgfVxuICAgIENvbW1vbkNvbnZlcnRlci5jb252ZXJ0S2luZCA9IGNvbnZlcnRLaW5kO1xuICAgIGZ1bmN0aW9uIGV4Y2x1ZGVCeUVycm9yTWVzc2FnZShkaWFnbm9zdGljcywgZXJyb3JNZXNzYWdlc1RvSWdub3JlLCBmaWVsZE5hbWUgPSBcIm1lc3NhZ2VcIikge1xuICAgICAgICBpZiAoIWVycm9yTWVzc2FnZXNUb0lnbm9yZSkgcmV0dXJuIGRpYWdub3N0aWNzO1xuICAgICAgICByZXR1cm4gZGlhZ25vc3RpY3MuZmlsdGVyKChlbCk9PiEoMCx1dGlscy8qIGNoZWNrVmFsdWVBZ2FpbnN0UmVnZXhwQXJyYXkgKi8uJHApKGVsW2ZpZWxkTmFtZV0sIGVycm9yTWVzc2FnZXNUb0lnbm9yZSkpO1xuICAgIH1cbiAgICBDb21tb25Db252ZXJ0ZXIuZXhjbHVkZUJ5RXJyb3JNZXNzYWdlID0gZXhjbHVkZUJ5RXJyb3JNZXNzYWdlO1xufSkoY29tbW9uX2NvbnZlcnRlcnNfQ29tbW9uQ29udmVydGVyIHx8IChjb21tb25fY29udmVydGVyc19Db21tb25Db252ZXJ0ZXIgPSB7fSkpO1xuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdHlwZS1jb252ZXJ0ZXJzL2xzcC1jb252ZXJ0ZXJzLnRzXG5cblxuXG5cbmZ1bmN0aW9uIGZyb21SYW5nZShyYW5nZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICBsaW5lOiByYW5nZS5zdGFydC5yb3csXG4gICAgICAgICAgICBjaGFyYWN0ZXI6IHJhbmdlLnN0YXJ0LmNvbHVtblxuICAgICAgICB9LFxuICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgIGxpbmU6IHJhbmdlLmVuZC5yb3csXG4gICAgICAgICAgICBjaGFyYWN0ZXI6IHJhbmdlLmVuZC5jb2x1bW5cbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiByYW5nZUZyb21Qb3NpdGlvbnMoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgZW5kOiBlbmRcbiAgICB9O1xufVxuZnVuY3Rpb24gdG9SYW5nZShyYW5nZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICByb3c6IHJhbmdlLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IHJhbmdlLnN0YXJ0LmNoYXJhY3RlclxuICAgICAgICB9LFxuICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgIHJvdzogcmFuZ2UuZW5kLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IHJhbmdlLmVuZC5jaGFyYWN0ZXJcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBmcm9tUG9pbnQocG9pbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBsaW5lOiBwb2ludC5yb3csXG4gICAgICAgIGNoYXJhY3RlcjogcG9pbnQuY29sdW1uXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvUG9pbnQocG9zaXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByb3c6IHBvc2l0aW9uLmxpbmUsXG4gICAgICAgIGNvbHVtbjogcG9zaXRpb24uY2hhcmFjdGVyXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvQW5ub3RhdGlvbnMoZGlhZ25vc3RpY3MpIHtcbiAgICB2YXIgX2RpYWdub3N0aWNzO1xuICAgIHJldHVybiAoX2RpYWdub3N0aWNzID0gZGlhZ25vc3RpY3MpID09PSBudWxsIHx8IF9kaWFnbm9zdGljcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RpYWdub3N0aWNzLm1hcCgoZWwpPT57XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb3c6IGVsLnJhbmdlLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IGVsLnJhbmdlLnN0YXJ0LmNoYXJhY3RlcixcbiAgICAgICAgICAgIHRleHQ6IGVsLm1lc3NhZ2UsXG4gICAgICAgICAgICB0eXBlOiBlbC5zZXZlcml0eSA9PT0gMSA/IFwiZXJyb3JcIiA6IGVsLnNldmVyaXR5ID09PSAyID8gXCJ3YXJuaW5nXCIgOiBcImluZm9cIlxuICAgICAgICB9O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gdG9Db21wbGV0aW9uKGl0ZW0pIHtcbiAgICB2YXIgX2l0ZW1fdGV4dEVkaXQsIF9pdGVtX2NvbW1hbmQ7XG4gICAgbGV0IGl0ZW1LaW5kID0gaXRlbS5raW5kO1xuICAgIGxldCBraW5kID0gaXRlbUtpbmQgPyBPYmplY3Qua2V5cyhDb21wbGV0aW9uSXRlbUtpbmQpW09iamVjdC52YWx1ZXMoQ29tcGxldGlvbkl0ZW1LaW5kKS5pbmRleE9mKGl0ZW1LaW5kKV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIF9pdGVtX3RleHRFZGl0X25ld1RleHQsIF9yZWY7XG4gICAgbGV0IHRleHQgPSAoX3JlZiA9IChfaXRlbV90ZXh0RWRpdF9uZXdUZXh0ID0gKF9pdGVtX3RleHRFZGl0ID0gaXRlbS50ZXh0RWRpdCkgPT09IG51bGwgfHwgX2l0ZW1fdGV4dEVkaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9pdGVtX3RleHRFZGl0Lm5ld1RleHQpICE9PSBudWxsICYmIF9pdGVtX3RleHRFZGl0X25ld1RleHQgIT09IHZvaWQgMCA/IF9pdGVtX3RleHRFZGl0X25ld1RleHQgOiBpdGVtLmluc2VydFRleHQpICE9PSBudWxsICYmIF9yZWYgIT09IHZvaWQgMCA/IF9yZWYgOiBpdGVtLmxhYmVsO1xuICAgIGxldCBjb21tYW5kID0gKChfaXRlbV9jb21tYW5kID0gaXRlbS5jb21tYW5kKSA9PT0gbnVsbCB8fCBfaXRlbV9jb21tYW5kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaXRlbV9jb21tYW5kLmNvbW1hbmQpID09IFwiZWRpdG9yLmFjdGlvbi50cmlnZ2VyU3VnZ2VzdFwiID8gXCJzdGFydEF1dG9jb21wbGV0ZVwiIDogdW5kZWZpbmVkO1xuICAgIGxldCByYW5nZSA9IGl0ZW0udGV4dEVkaXQgPyBnZXRUZXh0RWRpdFJhbmdlKGl0ZW0udGV4dEVkaXQpIDogdW5kZWZpbmVkO1xuICAgIGxldCBjb21wbGV0aW9uID0ge1xuICAgICAgICBtZXRhOiBraW5kLFxuICAgICAgICBjYXB0aW9uOiBpdGVtLmxhYmVsLFxuICAgICAgICBzY29yZTogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBjb21wbGV0aW9uW1wiY29tbWFuZFwiXSA9IGNvbW1hbmQ7XG4gICAgY29tcGxldGlvbltcInJhbmdlXCJdID0gcmFuZ2U7XG4gICAgY29tcGxldGlvbltcIml0ZW1cIl0gPSBpdGVtO1xuICAgIGlmIChpdGVtLmluc2VydFRleHRGb3JtYXQgPT0gSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0KSB7XG4gICAgICAgIGNvbXBsZXRpb25bXCJzbmlwcGV0XCJdID0gdGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb21wbGV0aW9uW1widmFsdWVcIl0gPSB0ZXh0ICE9PSBudWxsICYmIHRleHQgIT09IHZvaWQgMCA/IHRleHQgOiBcIlwiO1xuICAgIH1cbiAgICBjb21wbGV0aW9uW1wiZG9jdW1lbnRhdGlvblwiXSA9IGl0ZW0uZG9jdW1lbnRhdGlvbjsgLy9UT0RPOiB0aGlzIGlzIHdvcmthcm91bmQgZm9yIHNlcnZpY2VzIHdpdGggaW5zdGFudCBjb21wbGV0aW9uXG4gICAgY29tcGxldGlvbltcInBvc2l0aW9uXCJdID0gaXRlbVtcInBvc2l0aW9uXCJdO1xuICAgIGNvbXBsZXRpb25bXCJzZXJ2aWNlXCJdID0gaXRlbVtcInNlcnZpY2VcIl07IC8vVE9ETzogc2luY2Ugd2UgaGF2ZSBtdWx0aXBsZSBzZXJ2ZXJzLCB3ZSBuZWVkIHRvIGRldGVybWluZSB3aGljaFxuICAgIC8vIHNlcnZlciB0byB1c2UgZm9yIHJlc29sdmluZ1xuICAgIHJldHVybiBjb21wbGV0aW9uO1xufVxuZnVuY3Rpb24gdG9Db21wbGV0aW9ucyhjb21wbGV0aW9ucykge1xuICAgIGlmIChjb21wbGV0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBjb21iaW5lZENvbXBsZXRpb25zID0gY29tcGxldGlvbnMubWFwKChlbCk9PntcbiAgICAgICAgICAgIGlmICghZWwuY29tcGxldGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYWxsQ29tcGxldGlvbnM7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlbC5jb21wbGV0aW9ucykpIHtcbiAgICAgICAgICAgICAgICBhbGxDb21wbGV0aW9ucyA9IGVsLmNvbXBsZXRpb25zO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbGxDb21wbGV0aW9ucyA9IGVsLmNvbXBsZXRpb25zLml0ZW1zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFsbENvbXBsZXRpb25zLm1hcCgoaXRlbSk9PntcbiAgICAgICAgICAgICAgICBpdGVtW1wic2VydmljZVwiXSA9IGVsLnNlcnZpY2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkuZmxhdCgpO1xuICAgICAgICByZXR1cm4gY29tYmluZWRDb21wbGV0aW9ucy5tYXAoKGl0ZW0pPT50b0NvbXBsZXRpb24oaXRlbSkpO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5mdW5jdGlvbiB0b1Jlc29sdmVkQ29tcGxldGlvbihjb21wbGV0aW9uLCBpdGVtKSB7XG4gICAgY29tcGxldGlvbltcImRvY01hcmtkb3duXCJdID0gZnJvbU1hcmt1cENvbnRlbnQoaXRlbS5kb2N1bWVudGF0aW9uKTtcbiAgICByZXR1cm4gY29tcGxldGlvbjtcbn1cbmZ1bmN0aW9uIHRvQ29tcGxldGlvbkl0ZW0oY29tcGxldGlvbikge1xuICAgIGxldCBjb21tYW5kO1xuICAgIGlmIChjb21wbGV0aW9uW1wiY29tbWFuZFwiXSkge1xuICAgICAgICBjb21tYW5kID0ge1xuICAgICAgICAgICAgdGl0bGU6IFwidHJpZ2dlclN1Z2dlc3RcIixcbiAgICAgICAgICAgIGNvbW1hbmQ6IGNvbXBsZXRpb25bXCJjb21tYW5kXCJdXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBfY29tcGxldGlvbl9jYXB0aW9uO1xuICAgIGxldCBjb21wbGV0aW9uSXRlbSA9IHtcbiAgICAgICAgbGFiZWw6IChfY29tcGxldGlvbl9jYXB0aW9uID0gY29tcGxldGlvbi5jYXB0aW9uKSAhPT0gbnVsbCAmJiBfY29tcGxldGlvbl9jYXB0aW9uICE9PSB2b2lkIDAgPyBfY29tcGxldGlvbl9jYXB0aW9uIDogXCJcIixcbiAgICAgICAga2luZDogQ29tbW9uQ29udmVydGVyLmNvbnZlcnRLaW5kKGNvbXBsZXRpb24ubWV0YSksXG4gICAgICAgIGNvbW1hbmQ6IGNvbW1hbmQsXG4gICAgICAgIGluc2VydFRleHRGb3JtYXQ6IGNvbXBsZXRpb25bXCJzbmlwcGV0XCJdID8gSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0IDogSW5zZXJ0VGV4dEZvcm1hdC5QbGFpblRleHQsXG4gICAgICAgIGRvY3VtZW50YXRpb246IGNvbXBsZXRpb25bXCJkb2N1bWVudGF0aW9uXCJdXG4gICAgfTtcbiAgICBpZiAoY29tcGxldGlvbltcInJhbmdlXCJdKSB7XG4gICAgICAgIHZhciBfY29tcGxldGlvbl9zbmlwcGV0O1xuICAgICAgICBjb21wbGV0aW9uSXRlbS50ZXh0RWRpdCA9IHtcbiAgICAgICAgICAgIHJhbmdlOiBmcm9tUmFuZ2UoY29tcGxldGlvbltcInJhbmdlXCJdKSxcbiAgICAgICAgICAgIG5ld1RleHQ6IChfY29tcGxldGlvbl9zbmlwcGV0ID0gY29tcGxldGlvbltcInNuaXBwZXRcIl0pICE9PSBudWxsICYmIF9jb21wbGV0aW9uX3NuaXBwZXQgIT09IHZvaWQgMCA/IF9jb21wbGV0aW9uX3NuaXBwZXQgOiBjb21wbGV0aW9uW1widmFsdWVcIl1cbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2NvbXBsZXRpb25fc25pcHBldDE7XG4gICAgICAgIGNvbXBsZXRpb25JdGVtLmluc2VydFRleHQgPSAoX2NvbXBsZXRpb25fc25pcHBldDEgPSBjb21wbGV0aW9uW1wic25pcHBldFwiXSkgIT09IG51bGwgJiYgX2NvbXBsZXRpb25fc25pcHBldDEgIT09IHZvaWQgMCA/IF9jb21wbGV0aW9uX3NuaXBwZXQxIDogY29tcGxldGlvbltcInZhbHVlXCJdO1xuICAgIH1cbiAgICBjb21wbGV0aW9uSXRlbVtcImZpbGVOYW1lXCJdID0gY29tcGxldGlvbltcImZpbGVOYW1lXCJdO1xuICAgIGNvbXBsZXRpb25JdGVtW1wicG9zaXRpb25cIl0gPSBjb21wbGV0aW9uW1wicG9zaXRpb25cIl07XG4gICAgY29tcGxldGlvbkl0ZW1bXCJpdGVtXCJdID0gY29tcGxldGlvbltcIml0ZW1cIl07XG4gICAgY29tcGxldGlvbkl0ZW1bXCJzZXJ2aWNlXCJdID0gY29tcGxldGlvbltcInNlcnZpY2VcIl07IC8vVE9ETzpcbiAgICByZXR1cm4gY29tcGxldGlvbkl0ZW07XG59XG5mdW5jdGlvbiBnZXRUZXh0RWRpdFJhbmdlKHRleHRFZGl0KSB7XG4gICAgaWYgKHRleHRFZGl0Lmhhc093blByb3BlcnR5KFwiaW5zZXJ0XCIpICYmIHRleHRFZGl0Lmhhc093blByb3BlcnR5KFwicmVwbGFjZVwiKSkge1xuICAgICAgICB0ZXh0RWRpdCA9IHRleHRFZGl0O1xuICAgICAgICBsZXQgbWVyZ2VkUmFuZ2VzID0gbWVyZ2VSYW5nZXMoW1xuICAgICAgICAgICAgdG9SYW5nZSh0ZXh0RWRpdC5pbnNlcnQpLFxuICAgICAgICAgICAgdG9SYW5nZSh0ZXh0RWRpdC5yZXBsYWNlKVxuICAgICAgICBdKTtcbiAgICAgICAgcmV0dXJuIG1lcmdlZFJhbmdlc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0RWRpdCA9IHRleHRFZGl0O1xuICAgICAgICByZXR1cm4gdG9SYW5nZSh0ZXh0RWRpdC5yYW5nZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdG9Ub29sdGlwKGhvdmVyKSB7XG4gICAgdmFyIF9ob3Zlcl9maW5kO1xuICAgIGlmICghaG92ZXIpIHJldHVybjtcbiAgICBsZXQgY29udGVudCA9IGhvdmVyLm1hcCgoZWwpPT57XG4gICAgICAgIGlmICghZWwgfHwgIWVsLmNvbnRlbnRzKSByZXR1cm47XG4gICAgICAgIGlmIChNYXJrdXBDb250ZW50LmlzKGVsLmNvbnRlbnRzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21NYXJrdXBDb250ZW50KGVsLmNvbnRlbnRzKTtcbiAgICAgICAgfSBlbHNlIGlmIChNYXJrZWRTdHJpbmcuaXMoZWwuY29udGVudHMpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVsLmNvbnRlbnRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsLmNvbnRlbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwiYGBgXCIgKyBlbC5jb250ZW50cy52YWx1ZSArIFwiYGBgXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgY29udGVudHMgPSBlbC5jb250ZW50cy5tYXAoKGVsKT0+e1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBcXGBcXGBcXGAke2VsLnZhbHVlfVxcYFxcYFxcYGA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRzLmpvaW4oXCJcXG5cXG5cIik7XG4gICAgICAgIH1cbiAgICB9KS5maWx0ZXIobm90RW1wdHkpO1xuICAgIGlmIChjb250ZW50Lmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIC8vVE9ETzogaXQgY291bGQgYmUgbWVyZ2VkIHdpdGhpbiBhbGwgcmFuZ2VzIGluIGZ1dHVyZVxuICAgIGxldCBsc3BSYW5nZSA9IChfaG92ZXJfZmluZCA9IGhvdmVyLmZpbmQoKGVsKT0+e1xuICAgICAgICB2YXIgX2VsO1xuICAgICAgICByZXR1cm4gKF9lbCA9IGVsKSA9PT0gbnVsbCB8fCBfZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lbC5yYW5nZTtcbiAgICB9KSkgPT09IG51bGwgfHwgX2hvdmVyX2ZpbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ob3Zlcl9maW5kLnJhbmdlO1xuICAgIGxldCByYW5nZTtcbiAgICBpZiAobHNwUmFuZ2UpIHJhbmdlID0gdG9SYW5nZShsc3BSYW5nZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgdHlwZTogXCJtYXJrZG93blwiLFxuICAgICAgICAgICAgdGV4dDogY29udGVudC5qb2luKFwiXFxuXFxuXCIpXG4gICAgICAgIH0sXG4gICAgICAgIHJhbmdlOiByYW5nZVxuICAgIH07XG59XG5mdW5jdGlvbiBmcm9tU2lnbmF0dXJlSGVscChzaWduYXR1cmVIZWxwKSB7XG4gICAgaWYgKCFzaWduYXR1cmVIZWxwKSByZXR1cm47XG4gICAgbGV0IGNvbnRlbnQgPSBzaWduYXR1cmVIZWxwLm1hcCgoZWwpPT57XG4gICAgICAgIHZhciBfZWwsIF9lbDE7XG4gICAgICAgIGlmICghZWwpIHJldHVybjtcbiAgICAgICAgbGV0IHNpZ25hdHVyZUluZGV4ID0gKChfZWwgPSBlbCkgPT09IG51bGwgfHwgX2VsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZWwuYWN0aXZlU2lnbmF0dXJlKSB8fCAwO1xuICAgICAgICBsZXQgYWN0aXZlU2lnbmF0dXJlID0gZWwuc2lnbmF0dXJlc1tzaWduYXR1cmVJbmRleF07XG4gICAgICAgIGlmICghYWN0aXZlU2lnbmF0dXJlKSByZXR1cm47XG4gICAgICAgIGxldCBhY3RpdmVQYXJhbSA9IChfZWwxID0gZWwpID09PSBudWxsIHx8IF9lbDEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lbDEuYWN0aXZlUGFyYW1ldGVyO1xuICAgICAgICBsZXQgY29udGVudHMgPSBhY3RpdmVTaWduYXR1cmUubGFiZWw7XG4gICAgICAgIGlmIChhY3RpdmVQYXJhbSAhPSB1bmRlZmluZWQgJiYgYWN0aXZlU2lnbmF0dXJlLnBhcmFtZXRlcnMgJiYgYWN0aXZlU2lnbmF0dXJlLnBhcmFtZXRlcnNbYWN0aXZlUGFyYW1dKSB7XG4gICAgICAgICAgICBsZXQgcGFyYW0gPSBhY3RpdmVTaWduYXR1cmUucGFyYW1ldGVyc1thY3RpdmVQYXJhbV0ubGFiZWw7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50cyA9IGNvbnRlbnRzLnJlcGxhY2UocGFyYW0sIGAqKiR7cGFyYW19KipgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aXZlU2lnbmF0dXJlLmRvY3VtZW50YXRpb24pIHtcbiAgICAgICAgICAgIGlmIChNYXJrdXBDb250ZW50LmlzKGFjdGl2ZVNpZ25hdHVyZS5kb2N1bWVudGF0aW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50cyArIFwiXFxuXFxuXCIgKyBmcm9tTWFya3VwQ29udGVudChhY3RpdmVTaWduYXR1cmUuZG9jdW1lbnRhdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRzICs9IFwiXFxuXFxuXCIgKyBhY3RpdmVTaWduYXR1cmUuZG9jdW1lbnRhdGlvbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGVudHM7XG4gICAgICAgIH1cbiAgICB9KS5maWx0ZXIobm90RW1wdHkpO1xuICAgIGlmIChjb250ZW50Lmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFwibWFya2Rvd25cIixcbiAgICAgICAgICAgIHRleHQ6IGNvbnRlbnQuam9pbihcIlxcblxcblwiKVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZyb21NYXJrdXBDb250ZW50KGNvbnRlbnQpIHtcbiAgICBpZiAoIWNvbnRlbnQpIHJldHVybjtcbiAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQudmFsdWU7XG4gICAgfVxufVxuZnVuY3Rpb24gZnJvbUFjZURlbHRhKGRlbHRhLCBlb2wpIHtcbiAgICBjb25zdCB0ZXh0ID0gZGVsdGEubGluZXMubGVuZ3RoID4gMSA/IGRlbHRhLmxpbmVzLmpvaW4oZW9sKSA6IGRlbHRhLmxpbmVzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJhbmdlOiBkZWx0YS5hY3Rpb24gPT09IFwiaW5zZXJ0XCIgPyByYW5nZUZyb21Qb3NpdGlvbnMoZnJvbVBvaW50KGRlbHRhLnN0YXJ0KSwgZnJvbVBvaW50KGRlbHRhLnN0YXJ0KSkgOiByYW5nZUZyb21Qb3NpdGlvbnMoZnJvbVBvaW50KGRlbHRhLnN0YXJ0KSwgZnJvbVBvaW50KGRlbHRhLmVuZCkpLFxuICAgICAgICB0ZXh0OiBkZWx0YS5hY3Rpb24gPT09IFwiaW5zZXJ0XCIgPyB0ZXh0IDogXCJcIlxuICAgIH07XG59XG5mdW5jdGlvbiBmaWx0ZXJEaWFnbm9zdGljcyhkaWFnbm9zdGljcywgZmlsdGVyRXJyb3JzKSB7XG4gICAgcmV0dXJuIGNvbW1vbl9jb252ZXJ0ZXJzX0NvbW1vbkNvbnZlcnRlci5leGNsdWRlQnlFcnJvck1lc3NhZ2UoZGlhZ25vc3RpY3MsIGZpbHRlckVycm9ycy5lcnJvck1lc3NhZ2VzVG9JZ25vcmUpLm1hcCgoZWwpPT57XG4gICAgICAgIGlmICgoMCx1dGlscy8qIGNoZWNrVmFsdWVBZ2FpbnN0UmVnZXhwQXJyYXkgKi8uJHApKGVsLm1lc3NhZ2UsIGZpbHRlckVycm9ycy5lcnJvck1lc3NhZ2VzVG9UcmVhdEFzV2FybmluZykpIHtcbiAgICAgICAgICAgIGVsLnNldmVyaXR5ID0gYnJvd3Nlcl9tYWluLkRpYWdub3N0aWNTZXZlcml0eS5XYXJuaW5nO1xuICAgICAgICB9IGVsc2UgaWYgKCgwLHV0aWxzLyogY2hlY2tWYWx1ZUFnYWluc3RSZWdleHBBcnJheSAqLy4kcCkoZWwubWVzc2FnZSwgZmlsdGVyRXJyb3JzLmVycm9yTWVzc2FnZXNUb1RyZWF0QXNJbmZvKSkge1xuICAgICAgICAgICAgZWwuc2V2ZXJpdHkgPSBicm93c2VyX21haW4uRGlhZ25vc3RpY1NldmVyaXR5LkluZm9ybWF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZyb21Eb2N1bWVudEhpZ2hsaWdodHMoZG9jdW1lbnRIaWdobGlnaHRzKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50SGlnaGxpZ2h0cy5tYXAoZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgbGV0IGNsYXNzTmFtZSA9IGVsLmtpbmQgPT0gMiA/IFwibGFuZ3VhZ2VfaGlnaGxpZ2h0X3JlYWRcIiA6IGVsLmtpbmQgPT0gMyA/IFwibGFuZ3VhZ2VfaGlnaGxpZ2h0X3dyaXRlXCIgOiBcImxhbmd1YWdlX2hpZ2hsaWdodF90ZXh0XCI7XG4gICAgICAgIHJldHVybiB0b01hcmtlckdyb3VwSXRlbShDb21tb25Db252ZXJ0ZXIudG9SYW5nZSh0b1JhbmdlKGVsLnJhbmdlKSksIGNsYXNzTmFtZSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB0b01hcmtlckdyb3VwSXRlbShyYW5nZSwgY2xhc3NOYW1lLCB0b29sdGlwVGV4dCkge1xuICAgIGxldCBtYXJrZXJHcm91cEl0ZW0gPSB7XG4gICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgICB9O1xuICAgIGlmICh0b29sdGlwVGV4dCkge1xuICAgICAgICBtYXJrZXJHcm91cEl0ZW1bXCJ0b29sdGlwVGV4dFwiXSA9IHRvb2x0aXBUZXh0O1xuICAgIH1cbiAgICByZXR1cm4gbWFya2VyR3JvdXBJdGVtO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc2VydmljZXMvanNvbi9qc29uLXNlcnZpY2UudHNcbmZ1bmN0aW9uIGpzb25fc2VydmljZV9kZWZpbmVfcHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cblxuXG5cbmNsYXNzIEpzb25TZXJ2aWNlIGV4dGVuZHMgYmFzZV9zZXJ2aWNlLkJhc2VTZXJ2aWNlIHtcbiAgICAkZ2V0SnNvblNjaGVtYVVyaShzZXNzaW9uSUQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKHNlc3Npb25JRCwgXCJzY2hlbWFVcmlcIik7XG4gICAgfVxuICAgIGFkZERvY3VtZW50KGRvY3VtZW50KSB7XG4gICAgICAgIHN1cGVyLmFkZERvY3VtZW50KGRvY3VtZW50KTtcbiAgICAgICAgdGhpcy4kY29uZmlndXJlU2VydmljZShkb2N1bWVudC51cmkpO1xuICAgIH1cbiAgICAkY29uZmlndXJlU2VydmljZShzZXNzaW9uSUQpIHtcbiAgICAgICAgdmFyIF9zY2hlbWFzO1xuICAgICAgICBsZXQgc2NoZW1hcyA9IHRoaXMuZ2V0T3B0aW9uKHNlc3Npb25JRCAhPT0gbnVsbCAmJiBzZXNzaW9uSUQgIT09IHZvaWQgMCA/IHNlc3Npb25JRCA6IFwiXCIsIFwic2NoZW1hc1wiKTtcbiAgICAgICAgbGV0IHNlc3Npb25JRHMgPSBzZXNzaW9uSUQgPyBbXSA6IE9iamVjdC5rZXlzKHRoaXMuZG9jdW1lbnRzKTtcbiAgICAgICAgKF9zY2hlbWFzID0gc2NoZW1hcykgPT09IG51bGwgfHwgX3NjaGVtYXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zY2hlbWFzLmZvckVhY2goKGVsKT0+e1xuICAgICAgICAgICAgaWYgKHNlc3Npb25JRCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRnZXRKc29uU2NoZW1hVXJpKHNlc3Npb25JRCkgPT0gZWwudXJpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfZWw7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfZmlsZU1hdGNoO1xuICAgICAgICAgICAgICAgICAgICAoX2ZpbGVNYXRjaCA9IChfZWwgPSBlbCkuZmlsZU1hdGNoKSAhPT0gbnVsbCAmJiBfZmlsZU1hdGNoICE9PSB2b2lkIDAgPyBfZmlsZU1hdGNoIDogX2VsLmZpbGVNYXRjaCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBlbC5maWxlTWF0Y2gucHVzaChzZXNzaW9uSUQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWwuZmlsZU1hdGNoID0gc2Vzc2lvbklEcy5maWx0ZXIoKHNlc3Npb25JRCk9PnRoaXMuJGdldEpzb25TY2hlbWFVcmkoc2Vzc2lvbklEKSA9PSBlbC51cmkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9lbF9zY2hlbWE7XG4gICAgICAgICAgICBsZXQgc2NoZW1hID0gKF9lbF9zY2hlbWEgPSBlbC5zY2hlbWEpICE9PSBudWxsICYmIF9lbF9zY2hlbWEgIT09IHZvaWQgMCA/IF9lbF9zY2hlbWEgOiB0aGlzLnNjaGVtYXNbZWwudXJpXTtcbiAgICAgICAgICAgIGlmIChzY2hlbWEpIHRoaXMuc2NoZW1hc1tlbC51cmldID0gc2NoZW1hO1xuICAgICAgICAgICAgdGhpcy4kc2VydmljZS5yZXNldFNjaGVtYShlbC51cmkpO1xuICAgICAgICAgICAgZWwuc2NoZW1hID0gdW5kZWZpbmVkO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4kc2VydmljZS5jb25maWd1cmUoe1xuICAgICAgICAgICAgc2NoZW1hczogc2NoZW1hcyxcbiAgICAgICAgICAgIGFsbG93Q29tbWVudHM6IHRoaXMubW9kZSA9PT0gXCJqc29uNVwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVEb2N1bWVudChkb2N1bWVudCkge1xuICAgICAgICB2YXIgX3NjaGVtYXM7XG4gICAgICAgIHN1cGVyLnJlbW92ZURvY3VtZW50KGRvY3VtZW50KTtcbiAgICAgICAgbGV0IHNjaGVtYXMgPSB0aGlzLmdldE9wdGlvbihkb2N1bWVudC51cmksIFwic2NoZW1hc1wiKTtcbiAgICAgICAgKF9zY2hlbWFzID0gc2NoZW1hcykgPT09IG51bGwgfHwgX3NjaGVtYXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zY2hlbWFzLmZvckVhY2goKGVsKT0+e1xuICAgICAgICAgICAgaWYgKGVsLnVyaSA9PT0gdGhpcy4kZ2V0SnNvblNjaGVtYVVyaShkb2N1bWVudC51cmkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9lbF9maWxlTWF0Y2g7XG4gICAgICAgICAgICAgICAgZWwuZmlsZU1hdGNoID0gKF9lbF9maWxlTWF0Y2ggPSBlbC5maWxlTWF0Y2gpID09PSBudWxsIHx8IF9lbF9maWxlTWF0Y2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lbF9maWxlTWF0Y2guZmlsdGVyKChwYXR0ZXJuKT0+cGF0dGVybiAhPSBkb2N1bWVudC51cmkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4kc2VydmljZS5jb25maWd1cmUoe1xuICAgICAgICAgICAgc2NoZW1hczogc2NoZW1hcyxcbiAgICAgICAgICAgIGFsbG93Q29tbWVudHM6IHRoaXMubW9kZSA9PT0gXCJqc29uNVwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXRPcHRpb25zKHNlc3Npb25JRCwgb3B0aW9ucywgbWVyZ2UgPSBmYWxzZSkge1xuICAgICAgICBzdXBlci5zZXRPcHRpb25zKHNlc3Npb25JRCwgb3B0aW9ucywgbWVyZ2UpO1xuICAgICAgICB0aGlzLiRjb25maWd1cmVTZXJ2aWNlKHNlc3Npb25JRCk7XG4gICAgfVxuICAgIHNldEdsb2JhbE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBzdXBlci5zZXRHbG9iYWxPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLiRjb25maWd1cmVTZXJ2aWNlKCk7XG4gICAgfVxuICAgIGZvcm1hdChkb2N1bWVudCwgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGZ1bGxEb2N1bWVudCA9IHRoaXMuZ2V0RG9jdW1lbnQoZG9jdW1lbnQudXJpKTtcbiAgICAgICAgaWYgKCFmdWxsRG9jdW1lbnQpIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuJHNlcnZpY2UuZm9ybWF0KGZ1bGxEb2N1bWVudCwgcmFuZ2UsIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgYXN5bmMgZG9Ib3Zlcihkb2N1bWVudCwgcG9zaXRpb24pIHtcbiAgICAgICAgbGV0IGZ1bGxEb2N1bWVudCA9IHRoaXMuZ2V0RG9jdW1lbnQoZG9jdW1lbnQudXJpKTtcbiAgICAgICAgaWYgKCFmdWxsRG9jdW1lbnQpIHJldHVybiBudWxsO1xuICAgICAgICBsZXQganNvbkRvY3VtZW50ID0gdGhpcy4kc2VydmljZS5wYXJzZUpTT05Eb2N1bWVudChmdWxsRG9jdW1lbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy4kc2VydmljZS5kb0hvdmVyKGZ1bGxEb2N1bWVudCwgcG9zaXRpb24sIGpzb25Eb2N1bWVudCk7XG4gICAgfVxuICAgIGFzeW5jIGRvVmFsaWRhdGlvbihkb2N1bWVudCkge1xuICAgICAgICBsZXQgZnVsbERvY3VtZW50ID0gdGhpcy5nZXREb2N1bWVudChkb2N1bWVudC51cmkpO1xuICAgICAgICBpZiAoIWZ1bGxEb2N1bWVudCkgcmV0dXJuIFtdO1xuICAgICAgICBsZXQganNvbkRvY3VtZW50ID0gdGhpcy4kc2VydmljZS5wYXJzZUpTT05Eb2N1bWVudChmdWxsRG9jdW1lbnQpO1xuICAgICAgICBsZXQgZGlhZ25vc3RpY3MgPSBhd2FpdCB0aGlzLiRzZXJ2aWNlLmRvVmFsaWRhdGlvbihmdWxsRG9jdW1lbnQsIGpzb25Eb2N1bWVudCwge1xuICAgICAgICAgICAgdHJhaWxpbmdDb21tYXM6IHRoaXMubW9kZSA9PT0gXCJqc29uNVwiID8gXCJpZ25vcmVcIiA6IFwiZXJyb3JcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZpbHRlckRpYWdub3N0aWNzKGRpYWdub3N0aWNzLCB0aGlzLm9wdGlvbnNUb0ZpbHRlckRpYWdub3N0aWNzKTtcbiAgICB9XG4gICAgYXN5bmMgZG9Db21wbGV0ZShkb2N1bWVudCwgcG9zaXRpb24pIHtcbiAgICAgICAgbGV0IGZ1bGxEb2N1bWVudCA9IHRoaXMuZ2V0RG9jdW1lbnQoZG9jdW1lbnQudXJpKTtcbiAgICAgICAgaWYgKCFmdWxsRG9jdW1lbnQpIHJldHVybiBudWxsO1xuICAgICAgICBsZXQganNvbkRvY3VtZW50ID0gdGhpcy4kc2VydmljZS5wYXJzZUpTT05Eb2N1bWVudChmdWxsRG9jdW1lbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy4kc2VydmljZS5kb0NvbXBsZXRlKGZ1bGxEb2N1bWVudCwgcG9zaXRpb24sIGpzb25Eb2N1bWVudCk7XG4gICAgfVxuICAgIGFzeW5jIGRvUmVzb2x2ZShpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRzZXJ2aWNlLmRvUmVzb2x2ZShpdGVtKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobW9kZSl7XG4gICAgICAgIHN1cGVyKG1vZGUpO1xuICAgICAgICBqc29uX3NlcnZpY2VfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwiJHNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICAgICAganNvbl9zZXJ2aWNlX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInNjaGVtYXNcIiwge30pO1xuICAgICAgICBqc29uX3NlcnZpY2VfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwic2VydmljZUNhcGFiaWxpdGllc1wiLCB7XG4gICAgICAgICAgICBjb21wbGV0aW9uUHJvdmlkZXI6IHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyQ2hhcmFjdGVyczogW1xuICAgICAgICAgICAgICAgICAgICAnXCInLFxuICAgICAgICAgICAgICAgICAgICAnOidcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlhZ25vc3RpY1Byb3ZpZGVyOiB7XG4gICAgICAgICAgICAgICAgaW50ZXJGaWxlRGVwZW5kZW5jaWVzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHdvcmtzcGFjZURpYWdub3N0aWNzOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdQcm92aWRlcjogdHJ1ZSxcbiAgICAgICAgICAgIGRvY3VtZW50Rm9ybWF0dGluZ1Byb3ZpZGVyOiB0cnVlLFxuICAgICAgICAgICAgaG92ZXJQcm92aWRlcjogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4kc2VydmljZSA9IGdldExhbmd1YWdlU2VydmljZSh7XG4gICAgICAgICAgICBzY2hlbWFSZXF1ZXN0U2VydmljZTogKHVyaSk9PntcbiAgICAgICAgICAgICAgICB1cmkgPSB1cmkucmVwbGFjZShcImZpbGU6Ly8vXCIsIFwiXCIpO1xuICAgICAgICAgICAgICAgIGxldCBqc29uU2NoZW1hID0gdGhpcy5zY2hlbWFzW3VyaV07XG4gICAgICAgICAgICAgICAgaWYgKGpzb25TY2hlbWEpIHJldHVybiBQcm9taXNlLnJlc29sdmUoanNvblNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGBVbmFibGUgdG8gbG9hZCBzY2hlbWEgYXQgJHt1cml9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxufSkoKTtcblxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pOyJdLCJuYW1lcyI6WyJ3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsInJvb3QiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsImEiLCJpIiwiX193ZWJwYWNrX21vZHVsZXNfXyIsIl9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJwcm9jZXNzIiwiY29uc29sZSIsIl90eXBlb2YiLCJvYmoiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9yZXF1aXJlIiwiX3JlcXVpcmUkY29kZXMiLCJjb2RlcyIsIkVSUl9BTUJJR1VPVVNfQVJHVU1FTlQiLCJFUlJfSU5WQUxJRF9BUkdfVFlQRSIsIkVSUl9JTlZBTElEX0FSR19WQUxVRSIsIkVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSIsIkVSUl9NSVNTSU5HX0FSR1MiLCJBc3NlcnRpb25FcnJvciIsIl9yZXF1aXJlMiIsImluc3BlY3QiLCJfcmVxdWlyZSR0eXBlcyIsInR5cGVzIiwiaXNQcm9taXNlIiwiaXNSZWdFeHAiLCJvYmplY3RBc3NpZ24iLCJPYmplY3QiLCJhc3NpZ24iLCJvYmplY3RJcyIsImlzIiwiZXJyb3JDYWNoZSIsIk1hcCIsImlzRGVlcEVxdWFsIiwiaXNEZWVwU3RyaWN0RXF1YWwiLCJwYXJzZUV4cHJlc3Npb25BdCIsImZpbmROb2RlQXJvdW5kIiwiZGVjb2RlciIsImxhenlMb2FkQ29tcGFyaXNvbiIsImNvbXBhcmlzb24iLCJlc2NhcGVTZXF1ZW5jZXNSZWdFeHAiLCJtZXRhIiwiZXNjYXBlRm4iLCJzdHIiLCJjaGFyQ29kZUF0Iiwid2FybmVkIiwiYXNzZXJ0Iiwib2siLCJOT19FWENFUFRJT05fU0VOVElORUwiLCJpbm5lckZhaWwiLCJtZXNzYWdlIiwiRXJyb3IiLCJmYWlsIiwiYWN0dWFsIiwiZXhwZWN0ZWQiLCJvcGVyYXRvciIsInN0YWNrU3RhcnRGbiIsImFyZ3NMZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJpbnRlcm5hbE1lc3NhZ2UiLCJ1bmRlZmluZWQiLCJ3YXJuIiwiZW1pdFdhcm5pbmciLCJiaW5kIiwiZXJyQXJncyIsImVyciIsImdlbmVyYXRlZE1lc3NhZ2UiLCJpbm5lck9rIiwiZm4iLCJhcmdMZW4iLCJ2YWx1ZSIsIl9sZW4iLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwiYXBwbHkiLCJjb25jYXQiLCJlcXVhbCIsIm5vdEVxdWFsIiwiZGVlcEVxdWFsIiwibm90RGVlcEVxdWFsIiwiZGVlcFN0cmljdEVxdWFsIiwibm90RGVlcFN0cmljdEVxdWFsIiwic3RyaWN0RXF1YWwiLCJub3RTdHJpY3RFcXVhbCIsIkNvbXBhcmlzb24iLCJrZXlzIiwiX3RoaXMiLCJmb3JFYWNoIiwia2V5IiwidGVzdCIsImNvbXBhcmVFeGNlcHRpb25LZXkiLCJiIiwibmFtZSIsImV4cGVjdGVkRXhjZXB0aW9uIiwibXNnIiwicHVzaCIsImlzUHJvdG90eXBlT2YiLCJjYWxsIiwiZ2V0QWN0dWFsIiwiZSIsImNoZWNrSXNQcm9taXNlIiwidGhlbiIsImNhdGNoIiwid2FpdEZvckFjdHVhbCIsInByb21pc2VGbiIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVzdWx0UHJvbWlzZSIsImV4cGVjdHNFcnJvciIsImVycm9yIiwiZGV0YWlscyIsImZuVHlwZSIsImV4cGVjdHNOb0Vycm9yIiwidGhyb3dzIiwiX2xlbjIiLCJfa2V5MiIsInJlamVjdHMiLCJfbGVuMyIsIl9rZXkzIiwicmVzdWx0IiwiZG9lc05vdFRocm93IiwiX2xlbjQiLCJfa2V5NCIsImRvZXNOb3RSZWplY3QiLCJfbGVuNSIsIl9rZXk1IiwiaWZFcnJvciIsIm5ld0VyciIsIm9yaWdTdGFjayIsInN0YWNrIiwidG1wMiIsInNwbGl0Iiwic2hpZnQiLCJ0bXAxIiwicG9zIiwiaW5kZXhPZiIsInNsaWNlIiwiam9pbiIsInN0cmljdCIsIl9sZW42IiwiX2tleTYiLCJfb2JqZWN0U3ByZWFkIiwidGFyZ2V0Iiwic291cmNlIiwib3duS2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsInN5bSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJfZGVmaW5lUHJvcGVydHkiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInNlbGYiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiUmVmZXJlbmNlRXJyb3IiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJfd3JhcE5hdGl2ZVN1cGVyIiwiQ2xhc3MiLCJfY2FjaGUiLCJfaXNOYXRpdmVGdW5jdGlvbiIsImhhcyIsImdldCIsInNldCIsIldyYXBwZXIiLCJfY29uc3RydWN0IiwiX2dldFByb3RvdHlwZU9mIiwiaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsInNoYW0iLCJQcm94eSIsIkRhdGUiLCJ0b1N0cmluZyIsIlBhcmVudCIsIkZ1bmN0aW9uIiwibyIsInAiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsImdldFByb3RvdHlwZU9mIiwiZW5kc1dpdGgiLCJzZWFyY2giLCJ0aGlzX2xlbiIsInN1YnN0cmluZyIsInJlcGVhdCIsImNvdW50IiwiTWF0aCIsImZsb29yIiwibWF4Q291bnQiLCJsb2ciLCJibHVlIiwiZ3JlZW4iLCJyZWQiLCJ3aGl0ZSIsImtSZWFkYWJsZU9wZXJhdG9yIiwic3RyaWN0RXF1YWxPYmplY3QiLCJub3RTdHJpY3RFcXVhbE9iamVjdCIsIm5vdElkZW50aWNhbCIsImtNYXhTaG9ydExlbmd0aCIsImNvcHlFcnJvciIsImluc3BlY3RWYWx1ZSIsInZhbCIsImNvbXBhY3QiLCJjdXN0b21JbnNwZWN0IiwiZGVwdGgiLCJtYXhBcnJheUxlbmd0aCIsIkluZmluaXR5Iiwic2hvd0hpZGRlbiIsImJyZWFrTGVuZ3RoIiwic2hvd1Byb3h5Iiwic29ydGVkIiwiZ2V0dGVycyIsImNyZWF0ZUVyckRpZmYiLCJvdGhlciIsInJlcyIsImxhc3RQb3MiLCJlbmQiLCJza2lwcGVkIiwiYWN0dWFsSW5zcGVjdGVkIiwiYWN0dWFsTGluZXMiLCJleHBlY3RlZExpbmVzIiwiaW5kaWNhdG9yIiwiaW5wdXRMZW5ndGgiLCJtYXhMZW5ndGgiLCJzdGRlcnIiLCJpc1RUWSIsImNvbHVtbnMiLCJwb3AiLCJtYXhMaW5lcyIsIm1heCIsIl9hY3R1YWxMaW5lcyIsInByaW50ZWRMaW5lcyIsInNraXBwZWRNc2ciLCJjdXIiLCJleHBlY3RlZExpbmUiLCJhY3R1YWxMaW5lIiwiZGl2ZXJnaW5nTGluZXMiLCJfRXJyb3IiLCJvcHRpb25zIiwibGltaXQiLCJzdGFja1RyYWNlTGltaXQiLCJTdHJpbmciLCJnZXRDb2xvckRlcHRoIiwiYmFzZSIsIl9yZXMiLCJrbm93bk9wZXJhdG9ycyIsImNvZGUiLCJjYXB0dXJlU3RhY2tUcmFjZSIsImN1c3RvbSIsInJlY3Vyc2VUaW1lcyIsImN0eCIsInV0aWwiLCJjcmVhdGVFcnJvclR5cGUiLCJCYXNlIiwiZ2V0TWVzc2FnZSIsImFyZzEiLCJhcmcyIiwiYXJnMyIsIk5vZGVFcnJvciIsIl9CYXNlIiwib25lT2YiLCJ0aGluZyIsImlzQXJyYXkiLCJsZW4iLCJtYXAiLCJzdGFydHNXaXRoIiwic3Vic3RyIiwiaW5jbHVkZXMiLCJzdGFydCIsImRldGVybWluZXIiLCJyZXBsYWNlIiwidHlwZSIsInJlYXNvbiIsImluc3BlY3RlZCIsIlJhbmdlRXJyb3IiLCJpbnB1dCIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX25vbkl0ZXJhYmxlUmVzdCIsIl9hcnIiLCJfbiIsIl9kIiwiX2UiLCJfaSIsIl9zIiwibmV4dCIsImRvbmUiLCJyZWdleEZsYWdzU3VwcG9ydGVkIiwiZmxhZ3MiLCJhcnJheUZyb21TZXQiLCJhcnJheSIsImFycmF5RnJvbU1hcCIsIm9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyIsIm51bWJlcklzTmFOIiwiTnVtYmVyIiwiaXNOYU4iLCJ1bmN1cnJ5VGhpcyIsImYiLCJoYXNPd25Qcm9wZXJ0eSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwib2JqZWN0VG9TdHJpbmciLCJpc0FueUFycmF5QnVmZmVyIiwiaXNBcnJheUJ1ZmZlclZpZXciLCJpc0RhdGUiLCJpc01hcCIsImlzU2V0IiwiaXNOYXRpdmVFcnJvciIsImlzQm94ZWRQcmltaXRpdmUiLCJpc051bWJlck9iamVjdCIsImlzU3RyaW5nT2JqZWN0IiwiaXNCb29sZWFuT2JqZWN0IiwiaXNCaWdJbnRPYmplY3QiLCJpc1N5bWJvbE9iamVjdCIsImlzRmxvYXQzMkFycmF5IiwiaXNGbG9hdDY0QXJyYXkiLCJpc05vbkluZGV4IiwicG93IiwiZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzIiwiY29tcGFyZSIsIngiLCJ5IiwibWluIiwiT05MWV9FTlVNRVJBQkxFIiwia1N0cmljdCIsImtMb29zZSIsImtOb0l0ZXJhdG9yIiwia0lzQXJyYXkiLCJrSXNTZXQiLCJrSXNNYXAiLCJhcmVTaW1pbGFyUmVnRXhwcyIsIlJlZ0V4cCIsImFyZVNpbWlsYXJGbG9hdEFycmF5cyIsImJ5dGVMZW5ndGgiLCJvZmZzZXQiLCJhcmVTaW1pbGFyVHlwZWRBcnJheXMiLCJVaW50OEFycmF5IiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImFyZUVxdWFsQXJyYXlCdWZmZXJzIiwiYnVmMSIsImJ1ZjIiLCJpc0VxdWFsQm94ZWRQcmltaXRpdmUiLCJ2YWwxIiwidmFsMiIsInZhbHVlT2YiLCJCb29sZWFuIiwiQmlnSW50IiwiaW5uZXJEZWVwRXF1YWwiLCJtZW1vcyIsInZhbDFUYWciLCJ2YWwyVGFnIiwia2V5czEiLCJrZXlzMiIsImtleUNoZWNrIiwiZ2V0VGltZSIsIl9rZXlzIiwiX2tleXMyIiwic2l6ZSIsImdldEVudW1lcmFibGVzIiwiayIsIml0ZXJhdGlvblR5cGUiLCJhS2V5cyIsImJLZXlzIiwic3ltYm9sS2V5c0EiLCJzeW1ib2xLZXlzQiIsIl9zeW1ib2xLZXlzQiIsInBvc2l0aW9uIiwidmFsMk1lbW9BIiwidmFsMk1lbW9CIiwiYXJlRXEiLCJvYmpFcXVpdiIsImRlbGV0ZSIsInNldEhhc0VxdWFsRWxlbWVudCIsIm1lbW8iLCJzZXRWYWx1ZXMiLCJmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMiLCJwcmltIiwic2V0TWlnaHRIYXZlTG9vc2VQcmltIiwiYWx0VmFsdWUiLCJtYXBNaWdodEhhdmVMb29zZVByaW0iLCJpdGVtIiwiY3VyQiIsInNldEVxdWl2IiwiYVZhbHVlcyIsIlNldCIsImFkZCIsImJWYWx1ZXMiLCJfdmFsIiwibWFwSGFzRXF1YWxFbnRyeSIsImtleTEiLCJpdGVtMSIsImtleTIiLCJtYXBFcXVpdiIsImFFbnRyaWVzIiwiX2FFbnRyaWVzJGkiLCJpdGVtMiIsImJFbnRyaWVzIiwiX2kyIiwiX2JFbnRyaWVzJF9pIiwia2V5c0EiLCJHZXRJbnRyaW5zaWMiLCJjYWxsQmluZCIsIiRpbmRleE9mIiwiY2FsbEJvdW5kSW50cmluc2ljIiwiYWxsb3dNaXNzaW5nIiwiaW50cmluc2ljIiwiJGFwcGx5IiwiJGNhbGwiLCIkcmVmbGVjdEFwcGx5IiwiJGdPUEQiLCIkZGVmaW5lUHJvcGVydHkiLCIkbWF4Iiwib3JpZ2luYWxGdW5jdGlvbiIsImZ1bmMiLCJkZXNjIiwiYXBwbHlCaW5kIiwibm93IiwidGltZXMiLCJnIiwid2luZG93IiwiZnVuY3Rpb25zIiwiaW5mbyIsInRpbWUiLCJ0aW1lRW5kIiwidHJhY2UiLCJkaXIiLCJjb25zb2xlQXNzZXJ0IiwidHVwbGUiLCJsYWJlbCIsImR1cmF0aW9uIiwiZm9ybWF0Iiwib2JqZWN0IiwiZXhwcmVzc2lvbiIsImhhc1N5bWJvbHMiLCJ0b1N0ciIsIm9yaWdEZWZpbmVQcm9wZXJ0eSIsImlzRnVuY3Rpb24iLCJoYXNQcm9wZXJ0eURlc2NyaXB0b3JzIiwic3VwcG9ydHNEZXNjcmlwdG9ycyIsInByZWRpY2F0ZSIsImRlZmluZVByb3BlcnRpZXMiLCJwcmVkaWNhdGVzIiwiZmlyc3RTb3VyY2UiLCJ0byIsIm5leHRTb3VyY2UiLCJrZXlzQXJyYXkiLCJuZXh0SW5kZXgiLCJuZXh0S2V5IiwicG9seWZpbGwiLCJpc0NhbGxhYmxlIiwiZm9yRWFjaEFycmF5IiwicmVjZWl2ZXIiLCJmb3JFYWNoU3RyaW5nIiwic3RyaW5nIiwiY2hhckF0IiwiZm9yRWFjaE9iamVjdCIsImxpc3QiLCJ0aGlzQXJnIiwiRVJST1JfTUVTU0FHRSIsImZ1bmNUeXBlIiwidGhhdCIsImJvdW5kIiwiYmluZGVyIiwiYm91bmRMZW5ndGgiLCJib3VuZEFyZ3MiLCJFbXB0eSIsImltcGxlbWVudGF0aW9uIiwiJFN5bnRheEVycm9yIiwiU3ludGF4RXJyb3IiLCIkRnVuY3Rpb24iLCIkVHlwZUVycm9yIiwiZ2V0RXZhbGxlZENvbnN0cnVjdG9yIiwiZXhwcmVzc2lvblN5bnRheCIsInRocm93VHlwZUVycm9yIiwiVGhyb3dUeXBlRXJyb3IiLCJjYWxsZWUiLCJjYWxsZWVUaHJvd3MiLCJnT1BEdGhyb3dzIiwiaGFzUHJvdG8iLCJnZXRQcm90byIsIm5lZWRzRXZhbCIsIlR5cGVkQXJyYXkiLCJJTlRSSU5TSUNTIiwiQWdncmVnYXRlRXJyb3IiLCJBcnJheUJ1ZmZlciIsIkF0b21pY3MiLCJCaWdJbnQ2NEFycmF5IiwiQmlnVWludDY0QXJyYXkiLCJEYXRhVmlldyIsImRlY29kZVVSSSIsImRlY29kZVVSSUNvbXBvbmVudCIsImVuY29kZVVSSSIsImVuY29kZVVSSUNvbXBvbmVudCIsImV2YWwiLCJFdmFsRXJyb3IiLCJGbG9hdDMyQXJyYXkiLCJGbG9hdDY0QXJyYXkiLCJGaW5hbGl6YXRpb25SZWdpc3RyeSIsIkludDhBcnJheSIsIkludDE2QXJyYXkiLCJJbnQzMkFycmF5IiwiaXNGaW5pdGUiLCJKU09OIiwicGFyc2VGbG9hdCIsInBhcnNlSW50IiwiU2hhcmVkQXJyYXlCdWZmZXIiLCJVaW50OENsYW1wZWRBcnJheSIsIlVpbnQxNkFycmF5IiwiVWludDMyQXJyYXkiLCJVUklFcnJvciIsIldlYWtNYXAiLCJXZWFrUmVmIiwiV2Vha1NldCIsImVycm9yUHJvdG8iLCJkb0V2YWwiLCJnZW4iLCJMRUdBQ1lfQUxJQVNFUyIsImhhc093biIsIiRjb25jYXQiLCIkc3BsaWNlQXBwbHkiLCJzcGxpY2UiLCIkcmVwbGFjZSIsIiRzdHJTbGljZSIsIiRleGVjIiwiZXhlYyIsInJlUHJvcE5hbWUiLCJyZUVzY2FwZUNoYXIiLCJzdHJpbmdUb1BhdGgiLCJmaXJzdCIsImxhc3QiLCJtYXRjaCIsIm51bWJlciIsInF1b3RlIiwic3ViU3RyaW5nIiwiZ2V0QmFzZUludHJpbnNpYyIsImludHJpbnNpY05hbWUiLCJhbGlhcyIsInBhcnRzIiwiaW50cmluc2ljQmFzZU5hbWUiLCJpbnRyaW5zaWNSZWFsTmFtZSIsInNraXBGdXJ0aGVyQ2FjaGluZyIsImlzT3duIiwicGFydCIsImhhc0FycmF5TGVuZ3RoRGVmaW5lQnVnIiwiZm9vIiwiJE9iamVjdCIsIm9yaWdTeW1ib2wiLCJoYXNTeW1ib2xTaGFtIiwiaGFzTmF0aXZlU3ltYm9scyIsInN5bU9iaiIsInN5bVZhbCIsImdldE93blByb3BlcnR5TmFtZXMiLCJzeW1zIiwiaGFzVG9TdHJpbmdUYWdTaGFtcyIsInRvU3RyaW5nVGFnIiwiaW5oZXJpdHMiLCJjdG9yIiwic3VwZXJDdG9yIiwic3VwZXJfIiwiVGVtcEN0b3IiLCJoYXNUb1N0cmluZ1RhZyIsImNhbGxCb3VuZCIsIiR0b1N0cmluZyIsImlzU3RhbmRhcmRBcmd1bWVudHMiLCJpc0FyZ3VtZW50cyIsImlzTGVnYWN5QXJndW1lbnRzIiwic3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyIsImZuVG9TdHIiLCJyZWZsZWN0QXBwbHkiLCJiYWRBcnJheUxpa2UiLCJpc0NhbGxhYmxlTWFya2VyIiwiXyIsImNvbnN0cnVjdG9yUmVnZXgiLCJpc0VTNkNsYXNzRm4iLCJpc0VTNkNsYXNzRnVuY3Rpb24iLCJmblN0ciIsInRyeUZ1bmN0aW9uT2JqZWN0IiwidHJ5RnVuY3Rpb25Ub1N0ciIsIm9iamVjdENsYXNzIiwiZm5DbGFzcyIsImdlbkNsYXNzIiwiZGRhQ2xhc3MiLCJkZGFDbGFzczIiLCJkZGFDbGFzczMiLCJpc0lFNjgiLCJpc0REQSIsImlzRG9jdW1lbnREb3RBbGwiLCJkb2N1bWVudCIsImFsbCIsInN0ckNsYXNzIiwiaXNGblJlZ2V4IiwiZ2V0R2VuZXJhdG9yRnVuYyIsIkdlbmVyYXRvckZ1bmN0aW9uIiwiaXNHZW5lcmF0b3JGdW5jdGlvbiIsImdlbmVyYXRvckZ1bmMiLCJnZXRQb2x5ZmlsbCIsInNoaW0iLCJOYU4iLCJzaGltTnVtYmVySXNOYU4iLCJ0ZXN0SXNOYU4iLCJ3aGljaFR5cGVkQXJyYXkiLCJpc1R5cGVkQXJyYXkiLCJzaGltT2JqZWN0SXMiLCJ0ZXN0T2JqZWN0SXMiLCJrZXlzU2hpbSIsImlzQXJncyIsImlzRW51bWVyYWJsZSIsImhhc0RvbnRFbnVtQnVnIiwiaGFzUHJvdG9FbnVtQnVnIiwiZG9udEVudW1zIiwiZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUiLCJleGNsdWRlZEtleXMiLCIkYXBwbGljYXRpb25DYWNoZSIsIiRjb25zb2xlIiwiJGV4dGVybmFsIiwiJGZyYW1lIiwiJGZyYW1lRWxlbWVudCIsIiRmcmFtZXMiLCIkaW5uZXJIZWlnaHQiLCIkaW5uZXJXaWR0aCIsIiRvbm1vemZ1bGxzY3JlZW5jaGFuZ2UiLCIkb25tb3pmdWxsc2NyZWVuZXJyb3IiLCIkb3V0ZXJIZWlnaHQiLCIkb3V0ZXJXaWR0aCIsIiRwYWdlWE9mZnNldCIsIiRwYWdlWU9mZnNldCIsIiRwYXJlbnQiLCIkc2Nyb2xsTGVmdCIsIiRzY3JvbGxUb3AiLCIkc2Nyb2xsWCIsIiRzY3JvbGxZIiwiJHNlbGYiLCIkd2Via2l0SW5kZXhlZERCIiwiJHdlYmtpdFN0b3JhZ2VJbmZvIiwiJHdpbmRvdyIsImhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1ZyIsImVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneSIsImlzT2JqZWN0IiwiaXNTdHJpbmciLCJ0aGVLZXlzIiwic2tpcFByb3RvIiwiaiIsInNraXBDb25zdHJ1Y3RvciIsIm9yaWdLZXlzIiwib3JpZ2luYWxLZXlzIiwic2hpbU9iamVjdEtleXMiLCJrZXlzV29ya3NXaXRoQXJndW1lbnRzIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJydW5DbGVhclRpbWVvdXQiLCJtYXJrZXIiLCJxdWV1ZSIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwicnVuIiwibmV4dFRpY2siLCJJdGVtIiwidGl0bGUiLCJicm93c2VyIiwiZW52IiwiYXJndiIsInZlcnNpb24iLCJ2ZXJzaW9ucyIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsInByZXBlbmRMaXN0ZW5lciIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJiaW5kaW5nIiwiY3dkIiwiY2hkaXIiLCJ1bWFzayIsIl9fdW51c2VkX3dlYnBhY2tfbW9kdWxlIiwiX193ZWJwYWNrX2V4cG9ydHNfXyIsImQiLCJCYXNlU2VydmljZSIsIl91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fIiwidnNjb2RlX2xhbmd1YWdlc2VydmVyX3RleHRkb2N1bWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fIiwiX2RlZmluZV9wcm9wZXJ0eSIsImFkZERvY3VtZW50IiwiZG9jdW1lbnRzIiwidXJpIiwibiIsImxhbmd1YWdlSWQiLCJ0ZXh0IiwiZ2V0RG9jdW1lbnQiLCJyZW1vdmVEb2N1bWVudCIsImdldERvY3VtZW50VmFsdWUiLCJfdGhpc19nZXREb2N1bWVudCIsImdldFRleHQiLCJzZXRWYWx1ZSIsImlkZW50aWZpZXIiLCJzZXRHbG9iYWxPcHRpb25zIiwiZ2xvYmFsT3B0aW9ucyIsInNldE9wdGlvbnMiLCJzZXNzaW9uSUQiLCJtZXJnZSIsIlBNIiwiZ2V0T3B0aW9uIiwib3B0aW9uTmFtZSIsImFwcGx5RGVsdGFzIiwiZGVsdGFzIiwidXBkYXRlIiwiZG9Db21wbGV0ZSIsImRvSG92ZXIiLCJkb1Jlc29sdmUiLCJkb1ZhbGlkYXRpb24iLCJyYW5nZSIsInByb3ZpZGVTaWduYXR1cmVIZWxwIiwiZmluZERvY3VtZW50SGlnaGxpZ2h0cyIsIm9wdGlvbnNUb0ZpbHRlckRpYWdub3N0aWNzIiwiX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9JZ25vcmUiLCJfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nIiwiX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9UcmVhdEFzSW5mbyIsIl90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvSWdub3JlIiwiX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9UcmVhdEFzV2FybmluZyIsIl90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc0luZm8iLCJlcnJvckNvZGVzVG9JZ25vcmUiLCJlcnJvckNvZGVzVG9UcmVhdEFzV2FybmluZyIsImVycm9yQ29kZXNUb1RyZWF0QXNJbmZvIiwiZXJyb3JNZXNzYWdlc1RvSWdub3JlIiwiZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmciLCJlcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbyIsImRpc3Bvc2UiLCJtb2RlIiwiJHAiLCJjaGVja1ZhbHVlQWdhaW5zdFJlZ2V4cEFycmF5IiwibWVyZ2VPYmplY3RzIiwib2JqMSIsIm9iajIiLCJtZXJnZWRPYmplY3RzIiwibm90RW1wdHkiLCJtZXJnZVJhbmdlcyIsInJhbmdlcyIsInNvcnQiLCJjb21wYXJlUG9pbnRzIiwiY21wIiwiaXNFbXB0eSIsInJvdyIsImNvbHVtbiIsInAxIiwicDIiLCJyZWdleHBBcnJheSIsImlzQnVmZmVyIiwiYXJnIiwiY29weSIsImZpbGwiLCJyZWFkVUludDgiLCJpc0FyZ3VtZW50c09iamVjdCIsIkJpZ0ludFN1cHBvcnRlZCIsIlN5bWJvbFN1cHBvcnRlZCIsIk9iamVjdFRvU3RyaW5nIiwibnVtYmVyVmFsdWUiLCJzdHJpbmdWYWx1ZSIsImJvb2xlYW5WYWx1ZSIsImJpZ0ludFZhbHVlIiwic3ltYm9sVmFsdWUiLCJjaGVja0JveGVkUHJpbWl0aXZlIiwicHJvdG90eXBlVmFsdWVPZiIsImlzVmlldyIsImlzRGF0YVZpZXciLCJpc1VpbnQ4QXJyYXkiLCJpc1VpbnQ4Q2xhbXBlZEFycmF5IiwiaXNVaW50MTZBcnJheSIsImlzVWludDMyQXJyYXkiLCJpc0ludDhBcnJheSIsImlzSW50MTZBcnJheSIsImlzSW50MzJBcnJheSIsImlzQmlnSW50NjRBcnJheSIsImlzQmlnVWludDY0QXJyYXkiLCJpc01hcFRvU3RyaW5nIiwid29ya2luZyIsImlzU2V0VG9TdHJpbmciLCJpc1dlYWtNYXBUb1N0cmluZyIsImlzV2Vha01hcCIsImlzV2Vha1NldFRvU3RyaW5nIiwiaXNXZWFrU2V0IiwiaXNBcnJheUJ1ZmZlclRvU3RyaW5nIiwiaXNBcnJheUJ1ZmZlciIsImlzRGF0YVZpZXdUb1N0cmluZyIsIlNoYXJlZEFycmF5QnVmZmVyQ29weSIsImlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyIsImlzU2hhcmVkQXJyYXlCdWZmZXIiLCJpc0FzeW5jRnVuY3Rpb24iLCJpc01hcEl0ZXJhdG9yIiwiaXNTZXRJdGVyYXRvciIsImlzR2VuZXJhdG9yT2JqZWN0IiwiaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlIiwibWV0aG9kIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlc2NyaXB0b3JzIiwiZm9ybWF0UmVnRXhwIiwib2JqZWN0cyIsInN0cmluZ2lmeSIsImlzTnVsbCIsImRlcHJlY2F0ZSIsIm5vRGVwcmVjYXRpb24iLCJkZXByZWNhdGVkIiwidGhyb3dEZXByZWNhdGlvbiIsInRyYWNlRGVwcmVjYXRpb24iLCJkZWJ1Z3MiLCJkZWJ1Z0VudlJlZ2V4IiwiTk9ERV9ERUJVRyIsImRlYnVnRW52IiwidG9VcHBlckNhc2UiLCJkZWJ1Z2xvZyIsInBpZCIsIm9wdHMiLCJzZWVuIiwic3R5bGl6ZSIsInN0eWxpemVOb0NvbG9yIiwiY29sb3JzIiwiaXNCb29sZWFuIiwiX2V4dGVuZCIsImlzVW5kZWZpbmVkIiwic3R5bGl6ZVdpdGhDb2xvciIsImZvcm1hdFZhbHVlIiwic3R5bGVzIiwic3R5bGVUeXBlIiwic3R5bGUiLCJhcnJheVRvSGFzaCIsImhhc2giLCJpZHgiLCJyZXQiLCJwcmltaXRpdmUiLCJmb3JtYXRQcmltaXRpdmUiLCJ2aXNpYmxlS2V5cyIsImlzRXJyb3IiLCJmb3JtYXRFcnJvciIsImJyYWNlcyIsInRvVVRDU3RyaW5nIiwib3V0cHV0IiwiZm9ybWF0QXJyYXkiLCJmb3JtYXRQcm9wZXJ0eSIsInJlZHVjZVRvU2luZ2xlU3RyaW5nIiwic2ltcGxlIiwiaXNOdW1iZXIiLCJsIiwibGluZSIsIm51bUxpbmVzRXN0IiwicmVkdWNlIiwicHJldiIsImFyIiwiaXNOdWxsT3JVbmRlZmluZWQiLCJpc1N5bWJvbCIsInJlIiwiaXNQcmltaXRpdmUiLCJwYWQiLCJtb250aHMiLCJ0aW1lc3RhbXAiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwiZ2V0RGF0ZSIsImdldE1vbnRoIiwib3JpZ2luIiwicHJvcCIsImtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCIsInByb21pc2lmeSIsIm9yaWdpbmFsIiwicHJvbWlzZVJlc29sdmUiLCJwcm9taXNlUmVqZWN0IiwicHJvbWlzZSIsInJlamVjdCIsImNhbGxiYWNraWZ5T25SZWplY3RlZCIsImNiIiwibmV3UmVhc29uIiwiY2FsbGJhY2tpZnkiLCJjYWxsYmFja2lmaWVkIiwibWF5YmVDYiIsInJlaiIsIl9fY3JlYXRlQmluZGluZyIsIm0iLCJrMiIsIl9fZXNNb2R1bGUiLCJfX2V4cG9ydFN0YXIiLCJjcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiIsIkJyb3dzZXJNZXNzYWdlV3JpdGVyIiwiQnJvd3Nlck1lc3NhZ2VSZWFkZXIiLCJyaWxfMSIsImRlZmF1bHQiLCJpbnN0YWxsIiwiYXBpXzEiLCJBYnN0cmFjdE1lc3NhZ2VSZWFkZXIiLCJsaXN0ZW4iLCJjYWxsYmFjayIsIl9vbkRhdGEiLCJldmVudCIsInBvcnQiLCJFbWl0dGVyIiwiX21lc3NhZ2VMaXN0ZW5lciIsImZpcmUiLCJkYXRhIiwiYWRkRXZlbnRMaXN0ZW5lciIsImZpcmVFcnJvciIsIm9ubWVzc2FnZSIsIkFic3RyYWN0TWVzc2FnZVdyaXRlciIsIndyaXRlIiwicG9zdE1lc3NhZ2UiLCJoYW5kbGVFcnJvciIsImVycm9yQ291bnQiLCJyZWFkZXIiLCJ3cml0ZXIiLCJsb2dnZXIiLCJOdWxsTG9nZ2VyIiwiQ29ubmVjdGlvblN0cmF0ZWd5IiwiY29ubmVjdGlvblN0cmF0ZWd5IiwiTWVzc2FnZUJ1ZmZlciIsIkFic3RyYWN0TWVzc2FnZUJ1ZmZlciIsImVtcHR5QnVmZmVyIiwiZnJvbVN0cmluZyIsIl9lbmNvZGluZyIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwiZW5jb2RpbmciLCJhc2NpaURlY29kZXIiLCJkZWNvZGUiLCJUZXh0RGVjb2RlciIsImFzTmF0aXZlIiwiYWxsb2NOYXRpdmUiLCJSZWFkYWJsZVN0cmVhbVdyYXBwZXIiLCJvbkNsb3NlIiwibGlzdGVuZXIiLCJzb2NrZXQiLCJEaXNwb3NhYmxlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9uRXJyb3IiLCJvbkVuZCIsIm9uRGF0YSIsImJsb2IiLCJhcnJheUJ1ZmZlciIsIlJBTCIsIldyaXRhYmxlU3RyZWFtV3JhcHBlciIsInNlbmQiLCJjbG9zZSIsIl90ZXh0RW5jb2RlciIsIl9yaWwiLCJmcmVlemUiLCJtZXNzYWdlQnVmZmVyIiwiYXBwbGljYXRpb25Kc29uIiwiZW5jb2RlciIsImNoYXJzZXQiLCJwYXJzZSIsInN0cmVhbSIsImFzUmVhZGFibGVTdHJlYW0iLCJhc1dyaXRhYmxlU3RyZWFtIiwidGltZXIiLCJtcyIsImhhbmRsZSIsInNldEltbWVkaWF0ZSIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsIlJJTCIsIlByb2dyZXNzVHlwZSIsIlByb2dyZXNzVG9rZW4iLCJDb25uZWN0aW9uT3B0aW9ucyIsIldyaXRlYWJsZVN0cmVhbU1lc3NhZ2VXcml0ZXIiLCJNZXNzYWdlV3JpdGVyIiwiUmVhZGFibGVTdHJlYW1NZXNzYWdlUmVhZGVyIiwiTWVzc2FnZVJlYWRlciIsIlNoYXJlZEFycmF5UmVjZWl2ZXJTdHJhdGVneSIsIlNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3kiLCJDYW5jZWxsYXRpb25Ub2tlbiIsIkNhbmNlbGxhdGlvblRva2VuU291cmNlIiwiRXZlbnQiLCJMUlVDYWNoZSIsIlRvdWNoIiwiTGlua2VkTWFwIiwiUGFyYW1ldGVyU3RydWN0dXJlcyIsIk5vdGlmaWNhdGlvblR5cGU5IiwiTm90aWZpY2F0aW9uVHlwZTgiLCJOb3RpZmljYXRpb25UeXBlNyIsIk5vdGlmaWNhdGlvblR5cGU2IiwiTm90aWZpY2F0aW9uVHlwZTUiLCJOb3RpZmljYXRpb25UeXBlNCIsIk5vdGlmaWNhdGlvblR5cGUzIiwiTm90aWZpY2F0aW9uVHlwZTIiLCJOb3RpZmljYXRpb25UeXBlMSIsIk5vdGlmaWNhdGlvblR5cGUwIiwiTm90aWZpY2F0aW9uVHlwZSIsIkVycm9yQ29kZXMiLCJSZXNwb25zZUVycm9yIiwiUmVxdWVzdFR5cGU5IiwiUmVxdWVzdFR5cGU4IiwiUmVxdWVzdFR5cGU3IiwiUmVxdWVzdFR5cGU2IiwiUmVxdWVzdFR5cGU1IiwiUmVxdWVzdFR5cGU0IiwiUmVxdWVzdFR5cGUzIiwiUmVxdWVzdFR5cGUyIiwiUmVxdWVzdFR5cGUxIiwiUmVxdWVzdFR5cGUwIiwiUmVxdWVzdFR5cGUiLCJNZXNzYWdlIiwiTWVzc2FnZVN0cmF0ZWd5IiwiQ2FuY2VsbGF0aW9uU3RyYXRlZ3kiLCJDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneSIsIkNhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kiLCJDb25uZWN0aW9uRXJyb3IiLCJDb25uZWN0aW9uRXJyb3JzIiwiTG9nVHJhY2VOb3RpZmljYXRpb24iLCJTZXRUcmFjZU5vdGlmaWNhdGlvbiIsIlRyYWNlRm9ybWF0IiwiVHJhY2VWYWx1ZXMiLCJUcmFjZSIsIm1lc3NhZ2VzXzEiLCJsaW5rZWRNYXBfMSIsImRpc3Bvc2FibGVfMSIsImV2ZW50c18xIiwiY2FuY2VsbGF0aW9uXzEiLCJzaGFyZWRBcnJheUNhbmNlbGxhdGlvbl8xIiwibWVzc2FnZVJlYWRlcl8xIiwibWVzc2FnZVdyaXRlcl8xIiwibWVzc2FnZUJ1ZmZlcl8xIiwiY29ubmVjdGlvbl8xIiwicmFsXzEiLCJJcyIsIk5vbmUiLCJpc0NhbmNlbGxhdGlvblJlcXVlc3RlZCIsIm9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkIiwiQ2FuY2VsbGVkIiwiY2FuZGlkYXRlIiwiYm9vbGVhbiIsInNob3J0Y3V0RXZlbnQiLCJjb250ZXh0IiwiTXV0YWJsZVRva2VuIiwiY2FuY2VsIiwiX2lzQ2FuY2VsbGVkIiwiX2VtaXR0ZXIiLCJ0b2tlbiIsIl90b2tlbiIsIlJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5IiwiSWRDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5IiwiQ2FuY2VsTm90aWZpY2F0aW9uIiwiUHJvZ3Jlc3NOb3RpZmljYXRpb24iLCJTdGFyUmVxdWVzdEhhbmRsZXIiLCJPZmYiLCJNZXNzYWdlcyIsIkNvbXBhY3QiLCJWZXJib3NlIiwidG9Mb3dlckNhc2UiLCJUZXh0IiwiY2FuY2VsVW5kaXNwYXRjaGVkIiwia2luZCIsImNyZWF0ZUNhbmNlbGxhdGlvblRva2VuU291cmNlIiwic2VuZENhbmNlbGxhdGlvbiIsImNvbm4iLCJpZCIsInNlbmROb3RpZmljYXRpb24iLCJjbGVhbnVwIiwic2VuZGVyIiwiaGFuZGxlTWVzc2FnZSIsImNhbmNlbGxhdGlvblN0cmF0ZWd5IiwibWVzc2FnZVN0cmF0ZWd5IiwiQ29ubmVjdGlvblN0YXRlIiwibWVzc2FnZVJlYWRlciIsIm1lc3NhZ2VXcml0ZXIiLCJfbG9nZ2VyIiwic2VxdWVuY2VOdW1iZXIiLCJub3RpZmljYXRpb25TZXF1ZW5jZU51bWJlciIsInVua25vd25SZXNwb25zZVNlcXVlbmNlTnVtYmVyIiwic3RhclJlcXVlc3RIYW5kbGVyIiwicmVxdWVzdEhhbmRsZXJzIiwic3Rhck5vdGlmaWNhdGlvbkhhbmRsZXIiLCJub3RpZmljYXRpb25IYW5kbGVycyIsInByb2dyZXNzSGFuZGxlcnMiLCJtZXNzYWdlUXVldWUiLCJyZXNwb25zZVByb21pc2VzIiwia25vd25DYW5jZWxlZFJlcXVlc3RzIiwicmVxdWVzdFRva2VucyIsInRyYWNlRm9ybWF0IiwidHJhY2VyIiwic3RhdGUiLCJOZXciLCJlcnJvckVtaXR0ZXIiLCJjbG9zZUVtaXR0ZXIiLCJ1bmhhbmRsZWROb3RpZmljYXRpb25FbWl0dGVyIiwidW5oYW5kbGVkUHJvZ3Jlc3NFbWl0dGVyIiwiZGlzcG9zZUVtaXR0ZXIiLCJjcmVhdGVSZXF1ZXN0UXVldWVLZXkiLCJjcmVhdGVSZXNwb25zZVF1ZXVlS2V5IiwiY3JlYXRlTm90aWZpY2F0aW9uUXVldWVLZXkiLCJhZGRNZXNzYWdlVG9RdWV1ZSIsImlzUmVxdWVzdCIsImlzUmVzcG9uc2UiLCJfbWVzc2FnZSIsImlzTGlzdGVuaW5nIiwiTGlzdGVuaW5nIiwiaXNDbG9zZWQiLCJDbG9zZWQiLCJpc0Rpc3Bvc2VkIiwiRGlzcG9zZWQiLCJjbG9zZUhhbmRsZXIiLCJyZWFkRXJyb3JIYW5kbGVyIiwid3JpdGVFcnJvckhhbmRsZXIiLCJ0cmlnZ2VyTWVzc2FnZVF1ZXVlIiwicHJvY2Vzc01lc3NhZ2VRdWV1ZSIsImhhbmRsZVJlcXVlc3QiLCJpc05vdGlmaWNhdGlvbiIsImhhbmRsZU5vdGlmaWNhdGlvbiIsImhhbmRsZVJlc3BvbnNlIiwiaGFuZGxlSW52YWxpZE1lc3NhZ2UiLCJjYW5jZWxJZCIsInBhcmFtcyIsInRvQ2FuY2VsIiwic3RyYXRlZ3kiLCJyZXNwb25zZSIsInRyYWNlU2VuZGluZ1Jlc3BvbnNlIiwiY2FuY2VsbGF0aW9uVG9rZW4iLCJ0cmFjZVJlY2VpdmVkTm90aWZpY2F0aW9uIiwicmVxdWVzdE1lc3NhZ2UiLCJyZXBseSIsInJlc3VsdE9yRXJyb3IiLCJzdGFydFRpbWUiLCJqc29ucnBjIiwidG9Kc29uIiwicmVwbHlFcnJvciIsInJlcGx5U3VjY2VzcyIsInRyYWNlUmVjZWl2ZWRSZXF1ZXN0IiwiZWxlbWVudCIsInJlcXVlc3RIYW5kbGVyIiwiaGFuZGxlciIsInRva2VuS2V5IiwiY2FuY2VsbGF0aW9uU291cmNlIiwiaGFuZGxlclJlc3VsdCIsIm51bWJlck9mUGFyYW1zIiwiSW52YWxpZFBhcmFtcyIsInBhcmFtZXRlclN0cnVjdHVyZXMiLCJieU5hbWUiLCJieVBvc2l0aW9uIiwiSW50ZXJuYWxFcnJvciIsIk1ldGhvZE5vdEZvdW5kIiwicmVzcG9uc2VNZXNzYWdlIiwicmVzcG9uc2VQcm9taXNlIiwidHJhY2VSZWNlaXZlZFJlc3BvbnNlIiwibm90aWZpY2F0aW9uSGFuZGxlciIsInJlc3BvbnNlSGFuZGxlciIsInN0cmluZ2lmeVRyYWNlIiwidHJhY2VTZW5kaW5nUmVxdWVzdCIsImxvZ0xTUE1lc3NhZ2UiLCJ0cmFjZVNlbmRpbmdOb3RpZmljYXRpb24iLCJ0aW1lclN0YXJ0IiwibHNwTWVzc2FnZSIsImlzTFNQTWVzc2FnZSIsInRocm93SWZDbG9zZWRPckRpc3Bvc2VkIiwidGhyb3dJZkxpc3RlbmluZyIsIkFscmVhZHlMaXN0ZW5pbmciLCJ0aHJvd0lmTm90TGlzdGVuaW5nIiwidW5kZWZpbmVkVG9OdWxsIiwicGFyYW0iLCJudWxsVG9VbmRlZmluZWQiLCJpc05hbWVkUGFyYW0iLCJjb21wdXRlU2luZ2xlUGFyYW0iLCJhdXRvIiwiY29tcHV0ZU1lc3NhZ2VQYXJhbXMiLCJjb25uZWN0aW9uIiwibWVzc2FnZVBhcmFtcyIsInBhcmFtU3RhcnQiLCJwYXJhbUVuZCIsIm5vdGlmaWNhdGlvbk1lc3NhZ2UiLCJvbk5vdGlmaWNhdGlvbiIsIm9uUHJvZ3Jlc3MiLCJfdHlwZSIsInNlbmRQcm9ncmVzcyIsIm9uVW5oYW5kbGVkUHJvZ3Jlc3MiLCJzZW5kUmVxdWVzdCIsImRpc3Bvc2FibGUiLCJlbmFibGVDYW5jZWxsYXRpb24iLCJyZXNvbHZlV2l0aENsZWFudXAiLCJyIiwicmVqZWN0V2l0aENsZWFudXAiLCJNZXNzYWdlV3JpdGVFcnJvciIsIm9uUmVxdWVzdCIsImhhc1BlbmRpbmdSZXNwb25zZSIsIl92YWx1ZSIsIl90cmFjZXIiLCJzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMiLCJfc2VuZE5vdGlmaWNhdGlvbiIsIl90cmFjZUZvcm1hdCIsIm9uVW5oYW5kbGVkTm90aWZpY2F0aW9uIiwib25EaXNwb3NlIiwiUGVuZGluZ1Jlc3BvbnNlUmVqZWN0ZWQiLCJ2YWx1ZXMiLCJ2ZXJib3NlIiwiX2Rpc3Bvc2FibGUiLCJDYWxsYmFja0xpc3QiLCJidWNrZXQiLCJfY2FsbGJhY2tzIiwiX2NvbnRleHRzIiwicmVtb3ZlIiwiZm91bmRDYWxsYmFja1dpdGhEaWZmZXJlbnRDb250ZXh0IiwiaW52b2tlIiwiY2FsbGJhY2tzIiwiY29udGV4dHMiLCJfZXZlbnQiLCJ0aGlzQXJncyIsImRpc3Bvc2FibGVzIiwiX29wdGlvbnMiLCJvbkZpcnN0TGlzdGVuZXJBZGQiLCJfbm9vcCIsIm9uTGFzdExpc3RlbmVyUmVtb3ZlIiwic3RyaW5nQXJyYXkiLCJldmVyeSIsImVsZW0iLCJfYSIsIkZpcnN0IiwiQXNPbGQiLCJMYXN0IiwiQXNOZXciLCJjbGVhciIsIl9tYXAiLCJfaGVhZCIsIl90YWlsIiwiX3NpemUiLCJfc3RhdGUiLCJ0b3VjaCIsInByZXZpb3VzIiwiYWRkSXRlbUxhc3QiLCJhZGRJdGVtRmlyc3QiLCJyZW1vdmVJdGVtIiwiY2FsbGJhY2tmbiIsImN1cnJlbnQiLCJlbnRyaWVzIiwidHJpbU9sZCIsIm5ld1NpemUiLCJjdXJyZW50U2l6ZSIsInRvSlNPTiIsImZyb21KU09OIiwiX2xpbWl0IiwiY2hlY2tUcmltIiwicmF0aW8iLCJfcmF0aW8iLCJwZWVrIiwicm91bmQiLCJDUiIsIkxGIiwiQ1JMRiIsImFwcGVuZCIsImNodW5rIiwidG9BcHBlbmQiLCJfY2h1bmtzIiwiX3RvdGFsTGVuZ3RoIiwidHJ5UmVhZEhlYWRlcnMiLCJsb3dlckNhc2VLZXlzIiwiY2h1bmtJbmRleCIsImNodW5rQnl0ZXNSZWFkIiwiX3JlYWQiLCJoZWFkZXJzIiwiaGVhZGVyIiwiaW5kZXgiLCJ0cmltIiwidHJ5UmVhZEJvZHkiLCJudW1iZXJPZkJ5dGVzIiwiYnl0ZUNvdW50IiwicmVzdWx0T2Zmc2V0IiwiY2h1bmtQYXJ0Iiwic2VtYXBob3JlXzEiLCJvblBhcnRpYWxNZXNzYWdlIiwiYXNFcnJvciIsImZpcmVDbG9zZSIsInBhcnRpYWxNZXNzYWdlRW1pdHRlciIsImZpcmVQYXJ0aWFsTWVzc2FnZSIsIlJlc29sdmVkTWVzc2FnZVJlYWRlck9wdGlvbnMiLCJmcm9tT3B0aW9ucyIsImNvbnRlbnREZWNvZGVyIiwiY29udGVudERlY29kZXJzIiwiY29udGVudFR5cGVEZWNvZGVyIiwiY29udGVudFR5cGVEZWNvZGVycyIsInBhcnRpYWxNZXNzYWdlVGltZW91dCIsIl9wYXJ0aWFsTWVzc2FnZVRpbWVvdXQiLCJuZXh0TWVzc2FnZUxlbmd0aCIsIm1lc3NhZ2VUb2tlbiIsInBhcnRpYWxNZXNzYWdlVGltZXIiLCJyZWFkYWJsZSIsImNvbnRlbnRMZW5ndGgiLCJib2R5Iiwic2V0UGFydGlhbE1lc3NhZ2VUaW1lciIsImNsZWFyUGFydGlhbE1lc3NhZ2VUaW1lciIsInJlYWRTZW1hcGhvcmUiLCJsb2NrIiwiYnl0ZXMiLCJ3YWl0aW5nVGltZSIsIlNlbWFwaG9yZSIsIkNvbnRlbnRMZW5ndGgiLCJSZXNvbHZlZE1lc3NhZ2VXcml0ZXJPcHRpb25zIiwiY29udGVudFR5cGVFbmNvZGVyIiwiY29udGVudEVuY29kZXIiLCJ3cml0ZVNlbWFwaG9yZSIsInBheWxvYWQiLCJkb1dyaXRlIiwiQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIiwiUGFyc2VFcnJvciIsIkludmFsaWRSZXF1ZXN0IiwianNvbnJwY1Jlc2VydmVkRXJyb3JSYW5nZVN0YXJ0Iiwic2VydmVyRXJyb3JTdGFydCIsIk1lc3NhZ2VSZWFkRXJyb3IiLCJDb25uZWN0aW9uSW5hY3RpdmUiLCJTZXJ2ZXJOb3RJbml0aWFsaXplZCIsIlVua25vd25FcnJvckNvZGUiLCJqc29ucnBjUmVzZXJ2ZWRFcnJvclJhbmdlRW5kIiwic2VydmVyRXJyb3JFbmQiLCJfcGFyYW1ldGVyU3RydWN0dXJlcyIsIl9yYWwiLCJyYWwiLCJ0aHVuayIsIl93YWl0aW5nIiwicnVuTmV4dCIsImFjdGl2ZSIsIl9hY3RpdmUiLCJfY2FwYWNpdHkiLCJkb1J1bk5leHQiLCJjYXBhY2l0eSIsIkNhbmNlbGxhdGlvblN0YXRlIiwiQ29udGludWUiLCJyZXF1ZXN0IiwiYnVmZmVycyIsIiRjYW5jZWxsYXRpb25EYXRhIiwiX2Nvbm4iLCJzdG9yZSIsIlNoYXJlZEFycmF5QnVmZmVyQ2FuY2VsbGF0aW9uVG9rZW4iLCJsb2FkIiwiU2hhcmVkQXJyYXlCdWZmZXJDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSIsImNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbiIsImJyb3dzZXJfMSIsIkxTUEVycm9yQ29kZXMiLCJsc3BSZXNlcnZlZEVycm9yUmFuZ2VTdGFydCIsIlJlcXVlc3RGYWlsZWQiLCJTZXJ2ZXJDYW5jZWxsZWQiLCJDb250ZW50TW9kaWZpZWQiLCJSZXF1ZXN0Q2FuY2VsbGVkIiwibHNwUmVzZXJ2ZWRFcnJvclJhbmdlRW5kIiwidnNjb2RlX2pzb25ycGNfMSIsIlByb3RvY29sTm90aWZpY2F0aW9uVHlwZSIsIlByb3RvY29sTm90aWZpY2F0aW9uVHlwZTAiLCJQcm90b2NvbFJlcXVlc3RUeXBlIiwiUHJvdG9jb2xSZXF1ZXN0VHlwZTAiLCJSZWdpc3RyYXRpb25UeXBlIiwiTWVzc2FnZURpcmVjdGlvbiIsIkNhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdCIsIkNhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdCIsIkNhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCIsIm1lc3NhZ2VEaXJlY3Rpb24iLCJjbGllbnRUb1NlcnZlciIsIkNvbG9yUHJlc2VudGF0aW9uUmVxdWVzdCIsIkRvY3VtZW50Q29sb3JSZXF1ZXN0IiwiQ29uZmlndXJhdGlvblJlcXVlc3QiLCJzZXJ2ZXJUb0NsaWVudCIsIkRlY2xhcmF0aW9uUmVxdWVzdCIsIl9fbm9EeW5hbWljSW1wb3J0IiwiRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0IiwiV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QiLCJEb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0IiwiRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZCIsIkRpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhIiwicmV0cmlnZ2VyUmVxdWVzdCIsIkZ1bGwiLCJVbmNoYW5nZWQiLCJwYXJ0aWFsUmVzdWx0IiwiV2lsbERlbGV0ZUZpbGVzUmVxdWVzdCIsIkRpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uIiwiRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24iLCJXaWxsUmVuYW1lRmlsZXNSZXF1ZXN0IiwiRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24iLCJXaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0IiwiRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kIiwiZmlsZSIsImZvbGRlciIsIkZvbGRpbmdSYW5nZVJlcXVlc3QiLCJJbXBsZW1lbnRhdGlvblJlcXVlc3QiLCJJbmxheUhpbnRSZWZyZXNoUmVxdWVzdCIsIklubGF5SGludFJlc29sdmVSZXF1ZXN0IiwiSW5sYXlIaW50UmVxdWVzdCIsIklubGluZVZhbHVlUmVmcmVzaFJlcXVlc3QiLCJJbmxpbmVWYWx1ZVJlcXVlc3QiLCJXb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0IiwiQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0IiwiQ29kZUFjdGlvblJlcXVlc3QiLCJEb2N1bWVudFN5bWJvbFJlcXVlc3QiLCJEb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QiLCJSZWZlcmVuY2VzUmVxdWVzdCIsIkRlZmluaXRpb25SZXF1ZXN0IiwiU2lnbmF0dXJlSGVscFJlcXVlc3QiLCJTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQiLCJIb3ZlclJlcXVlc3QiLCJDb21wbGV0aW9uUmVzb2x2ZVJlcXVlc3QiLCJDb21wbGV0aW9uUmVxdWVzdCIsIkNvbXBsZXRpb25UcmlnZ2VyS2luZCIsIlB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbiIsIldhdGNoS2luZCIsIlJlbGF0aXZlUGF0dGVybiIsIkZpbGVDaGFuZ2VUeXBlIiwiRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uIiwiV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0IiwiV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24iLCJUZXh0RG9jdW1lbnRTYXZlUmVhc29uIiwiRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiIsIkRpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uIiwiRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uIiwiVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50IiwiRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbiIsIlRleHREb2N1bWVudFN5bmNLaW5kIiwiVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24iLCJMb2dNZXNzYWdlTm90aWZpY2F0aW9uIiwiU2hvd01lc3NhZ2VSZXF1ZXN0IiwiU2hvd01lc3NhZ2VOb3RpZmljYXRpb24iLCJNZXNzYWdlVHlwZSIsIkRpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24iLCJFeGl0Tm90aWZpY2F0aW9uIiwiU2h1dGRvd25SZXF1ZXN0IiwiSW5pdGlhbGl6ZWROb3RpZmljYXRpb24iLCJJbml0aWFsaXplRXJyb3JDb2RlcyIsIkluaXRpYWxpemVSZXF1ZXN0IiwiV29ya0RvbmVQcm9ncmVzc09wdGlvbnMiLCJUZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zIiwiU3RhdGljUmVnaXN0cmF0aW9uT3B0aW9ucyIsIlBvc2l0aW9uRW5jb2RpbmdLaW5kIiwiRmFpbHVyZUhhbmRsaW5nS2luZCIsIlJlc291cmNlT3BlcmF0aW9uS2luZCIsIlVucmVnaXN0cmF0aW9uUmVxdWVzdCIsIlJlZ2lzdHJhdGlvblJlcXVlc3QiLCJEb2N1bWVudFNlbGVjdG9yIiwiTm90ZWJvb2tDZWxsVGV4dERvY3VtZW50RmlsdGVyIiwiTm90ZWJvb2tEb2N1bWVudEZpbHRlciIsIlRleHREb2N1bWVudEZpbHRlciIsIlR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QiLCJUeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QiLCJNb25pa2VyUmVxdWVzdCIsIk1vbmlrZXJLaW5kIiwiVW5pcXVlbmVzc0xldmVsIiwiTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdCIsIlNob3dEb2N1bWVudFJlcXVlc3QiLCJTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUiLCJTZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0IiwiU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QiLCJTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdCIsIlNlbWFudGljVG9rZW5zUmVxdWVzdCIsIlRva2VuRm9ybWF0IiwiV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbiIsIldvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0IiwiV29ya0RvbmVQcm9ncmVzcyIsIlNlbGVjdGlvblJhbmdlUmVxdWVzdCIsIkRpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24iLCJXb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCIsIlR5cGVEZWZpbml0aW9uUmVxdWVzdCIsIkFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3QiLCJFeGVjdXRlQ29tbWFuZFJlcXVlc3QiLCJQcmVwYXJlUmVuYW1lUmVxdWVzdCIsIlJlbmFtZVJlcXVlc3QiLCJQcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvciIsIkRvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QiLCJEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QiLCJEb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0IiwiRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QiLCJEb2N1bWVudExpbmtSZXF1ZXN0IiwiQ29kZUxlbnNSZWZyZXNoUmVxdWVzdCIsIkNvZGVMZW5zUmVzb2x2ZVJlcXVlc3QiLCJDb2RlTGVuc1JlcXVlc3QiLCJXb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdCIsIkRpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiIsIkRpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uIiwiRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiIsIk5vdGVib29rQ2VsbEFycmF5Q2hhbmdlIiwiRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24iLCJOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUiLCJOb3RlYm9va0RvY3VtZW50IiwiTm90ZWJvb2tDZWxsIiwiRXhlY3V0aW9uU3VtbWFyeSIsIk5vdGVib29rQ2VsbEtpbmQiLCJUeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QiLCJ2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdHlwZXNfMSIsInByb3RvY29sX2ltcGxlbWVudGF0aW9uXzEiLCJwcm90b2NvbF90eXBlRGVmaW5pdGlvbl8xIiwicHJvdG9jb2xfd29ya3NwYWNlRm9sZGVyXzEiLCJwcm90b2NvbF9jb25maWd1cmF0aW9uXzEiLCJwcm90b2NvbF9jb2xvclByb3ZpZGVyXzEiLCJwcm90b2NvbF9mb2xkaW5nUmFuZ2VfMSIsInByb3RvY29sX2RlY2xhcmF0aW9uXzEiLCJwcm90b2NvbF9zZWxlY3Rpb25SYW5nZV8xIiwicHJvdG9jb2xfcHJvZ3Jlc3NfMSIsInByb3RvY29sX2NhbGxIaWVyYXJjaHlfMSIsInByb3RvY29sX3NlbWFudGljVG9rZW5zXzEiLCJwcm90b2NvbF9zaG93RG9jdW1lbnRfMSIsInByb3RvY29sX2xpbmtlZEVkaXRpbmdSYW5nZV8xIiwicHJvdG9jb2xfZmlsZU9wZXJhdGlvbnNfMSIsInByb3RvY29sX21vbmlrZXJfMSIsInByb3RvY29sX3R5cGVIaWVyYXJjaHlfMSIsInByb3RvY29sX2lubGluZVZhbHVlXzEiLCJwcm90b2NvbF9pbmxheUhpbnRfMSIsInByb3RvY29sX2RpYWdub3N0aWNfMSIsInByb3RvY29sX25vdGVib29rXzEiLCJsYW5ndWFnZSIsInNjaGVtZSIsInBhdHRlcm4iLCJvYmplY3RMaXRlcmFsIiwibm90ZWJvb2tUeXBlIiwibm90ZWJvb2siLCJDcmVhdGUiLCJSZW5hbWUiLCJEZWxldGUiLCJBYm9ydCIsIlRyYW5zYWN0aW9uYWwiLCJUZXh0T25seVRyYW5zYWN0aW9uYWwiLCJVbmRvIiwiVVRGOCIsIlVURjE2IiwiVVRGMzIiLCJoYXNJZCIsImRvY3VtZW50U2VsZWN0b3IiLCJ3b3JrRG9uZVByb2dyZXNzIiwiaGFzV29ya0RvbmVQcm9ncmVzcyIsInVua25vd25Qcm90b2NvbFZlcnNpb24iLCJXYXJuaW5nIiwiSW5mbyIsIkxvZyIsIkluY3JlbWVudGFsIiwiaXNJbmNyZW1lbnRhbCIsInJhbmdlTGVuZ3RoIiwiaXNGdWxsIiwiTWFudWFsIiwiQWZ0ZXJEZWxheSIsIkZvY3VzT3V0IiwiQ3JlYXRlZCIsIkNoYW5nZWQiLCJEZWxldGVkIiwiVVJJIiwiYmFzZVVyaSIsIldvcmtzcGFjZUZvbGRlciIsIkNoYW5nZSIsIkludm9rZWQiLCJUcmlnZ2VyQ2hhcmFjdGVyIiwiVHJpZ2dlckZvckluY29tcGxldGVDb21wbGV0aW9ucyIsIkNvbnRlbnRDaGFuZ2UiLCJJZGVudGlmaWVyIiwicHJvamVjdCIsImdyb3VwIiwiZ2xvYmFsIiwiJGltcG9ydCIsIiRleHBvcnQiLCJsb2NhbCIsIk1hcmt1cCIsIkNvZGUiLCJleGVjdXRpb25PcmRlciIsInN1Y2Nlc3MiLCJ1aW50ZWdlciIsImVxdWFscyIsIm9uZSIsIkRvY3VtZW50VXJpIiwibWV0YWRhdGEiLCJkaWZmIiwidHdvIiwiZXhlY3V0aW9uU3VtbWFyeSIsImVxdWFsc01ldGFkYXRhIiwib25lQXJyYXkiLCJvdGhlckFycmF5Iiwib25lS2V5cyIsIm90aGVyS2V5cyIsImNlbGxzIiwiaW50ZWdlciIsInR5cGVkQXJyYXkiLCJyZWdpc3RyYXRpb25NZXRob2QiLCJkZWxldGVDb3VudCIsIlJlbGF0aXZlIiwiY2hlY2siLCJUZXh0RG9jdW1lbnQiLCJfX3NwcmVhZEFycmF5IiwiZnJvbSIsInBhY2siLCJGdWxsVGV4dERvY3VtZW50IiwiY29udGVudCIsIl91cmkiLCJfbGFuZ3VhZ2VJZCIsIl92ZXJzaW9uIiwiX2NvbnRlbnQiLCJfbGluZU9mZnNldHMiLCJvZmZzZXRBdCIsImNoYW5nZXMiLCJjaGFuZ2VzXzEiLCJjaGFuZ2UiLCJnZXRXZWxsZm9ybWVkUmFuZ2UiLCJzdGFydE9mZnNldCIsImVuZE9mZnNldCIsInN0YXJ0TGluZSIsImVuZExpbmUiLCJsaW5lT2Zmc2V0cyIsImFkZGVkTGluZU9mZnNldHMiLCJjb21wdXRlTGluZU9mZnNldHMiLCJnZXRMaW5lT2Zmc2V0cyIsInBvc2l0aW9uQXQiLCJsb3ciLCJoaWdoIiwiY2hhcmFjdGVyIiwibWlkIiwibGluZU9mZnNldCIsIm5leHRMaW5lT2Zmc2V0IiwiYXBwbHlFZGl0cyIsImVkaXRzIiwic29ydGVkRWRpdHMiLCJtZXJnZVNvcnQiLCJnZXRXZWxsZm9ybWVkRWRpdCIsImxhc3RNb2RpZmllZE9mZnNldCIsInNwYW5zIiwic29ydGVkRWRpdHNfMSIsIm5ld1RleHQiLCJsZWZ0IiwicmlnaHQiLCJsZWZ0SWR4IiwicmlnaHRJZHgiLCJpc0F0TGluZVN0YXJ0IiwidGV4dE9mZnNldCIsImNoIiwidGV4dEVkaXQiLCJBbm5vdGF0ZWRUZXh0RWRpdCIsIkNoYW5nZUFubm90YXRpb24iLCJDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllciIsIkNvZGVBY3Rpb24iLCJDb2RlQWN0aW9uQ29udGV4dCIsIkNvZGVBY3Rpb25LaW5kIiwiQ29kZUFjdGlvblRyaWdnZXJLaW5kIiwiQ29kZURlc2NyaXB0aW9uIiwiQ29kZUxlbnMiLCJDb2xvciIsIkNvbG9ySW5mb3JtYXRpb24iLCJDb2xvclByZXNlbnRhdGlvbiIsIkNvbW1hbmQiLCJDb21wbGV0aW9uSXRlbSIsIkNvbXBsZXRpb25JdGVtS2luZCIsIkNvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzIiwiQ29tcGxldGlvbkl0ZW1UYWciLCJDb21wbGV0aW9uTGlzdCIsIkNyZWF0ZUZpbGUiLCJEZWxldGVGaWxlIiwiRGlhZ25vc3RpYyIsIkRpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24iLCJEaWFnbm9zdGljU2V2ZXJpdHkiLCJEaWFnbm9zdGljVGFnIiwiRG9jdW1lbnRIaWdobGlnaHQiLCJEb2N1bWVudEhpZ2hsaWdodEtpbmQiLCJEb2N1bWVudExpbmsiLCJEb2N1bWVudFN5bWJvbCIsIkVPTCIsIkZvbGRpbmdSYW5nZSIsIkZvbGRpbmdSYW5nZUtpbmQiLCJGb3JtYXR0aW5nT3B0aW9ucyIsIkhvdmVyIiwiSW5sYXlIaW50IiwiSW5sYXlIaW50S2luZCIsIklubGF5SGludExhYmVsUGFydCIsIklubGluZVZhbHVlQ29udGV4dCIsIklubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uIiwiSW5saW5lVmFsdWVUZXh0IiwiSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cCIsIkluc2VydFJlcGxhY2VFZGl0IiwiSW5zZXJ0VGV4dEZvcm1hdCIsIkluc2VydFRleHRNb2RlIiwiTG9jYXRpb24iLCJMb2NhdGlvbkxpbmsiLCJNYXJrZWRTdHJpbmciLCJNYXJrdXBDb250ZW50IiwiTWFya3VwS2luZCIsIk9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciIsIlBhcmFtZXRlckluZm9ybWF0aW9uIiwiUG9zaXRpb24iLCJSYW5nZSIsIlJlbmFtZUZpbGUiLCJTZWxlY3Rpb25SYW5nZSIsIlNlbWFudGljVG9rZW5Nb2RpZmllcnMiLCJTZW1hbnRpY1Rva2VuVHlwZXMiLCJTZW1hbnRpY1Rva2VucyIsIlNpZ25hdHVyZUluZm9ybWF0aW9uIiwiU3ltYm9sSW5mb3JtYXRpb24iLCJTeW1ib2xLaW5kIiwiU3ltYm9sVGFnIiwiVGV4dERvY3VtZW50RWRpdCIsIlRleHREb2N1bWVudElkZW50aWZpZXIiLCJUZXh0RG9jdW1lbnRJdGVtIiwiVGV4dEVkaXQiLCJWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIiwiV29ya3NwYWNlQ2hhbmdlIiwiV29ya3NwYWNlRWRpdCIsIldvcmtzcGFjZVN5bWJvbCIsIk1JTl9WQUxVRSIsIk1BWF9WQUxVRSIsInRocmVlIiwiZm91ciIsInRhcmdldFVyaSIsInRhcmdldFJhbmdlIiwidGFyZ2V0U2VsZWN0aW9uUmFuZ2UiLCJvcmlnaW5TZWxlY3Rpb25SYW5nZSIsImFscGhhIiwibnVtYmVyUmFuZ2UiLCJjb2xvciIsImFkZGl0aW9uYWxUZXh0RWRpdHMiLCJDb21tZW50IiwiSW1wb3J0cyIsIlJlZ2lvbiIsInN0YXJ0Q2hhcmFjdGVyIiwiZW5kQ2hhcmFjdGVyIiwiY29sbGFwc2VkVGV4dCIsImRlZmluZWQiLCJsb2NhdGlvbiIsIkluZm9ybWF0aW9uIiwiSGludCIsIlVubmVjZXNzYXJ5IiwiRGVwcmVjYXRlZCIsImhyZWYiLCJzZXZlcml0eSIsInJlbGF0ZWRJbmZvcm1hdGlvbiIsImNvZGVEZXNjcmlwdGlvbiIsImNvbW1hbmQiLCJpbnNlcnQiLCJkZWwiLCJuZWVkc0NvbmZpcm1hdGlvbiIsImRlc2NyaXB0aW9uIiwiYW5ub3RhdGlvbiIsImFubm90YXRpb25JZCIsInRleHREb2N1bWVudCIsIm92ZXJ3cml0ZSIsImlnbm9yZUlmRXhpc3RzIiwib2xkVXJpIiwibmV3VXJpIiwicmVjdXJzaXZlIiwiaWdub3JlSWZOb3RFeGlzdHMiLCJkb2N1bWVudENoYW5nZXMiLCJUZXh0RWRpdENoYW5nZUltcGwiLCJjaGFuZ2VBbm5vdGF0aW9ucyIsImVkaXQiLCJhc3NlcnRDaGFuZ2VBbm5vdGF0aW9ucyIsIm1hbmFnZSIsIkNoYW5nZUFubm90YXRpb25zIiwiYW5ub3RhdGlvbnMiLCJfYW5ub3RhdGlvbnMiLCJfY291bnRlciIsImlkT3JBbm5vdGF0aW9uIiwibmV4dElkIiwid29ya3NwYWNlRWRpdCIsIl90ZXh0RWRpdENoYW5nZXMiLCJfd29ya3NwYWNlRWRpdCIsIl9jaGFuZ2VBbm5vdGF0aW9ucyIsInRleHRFZGl0Q2hhbmdlIiwiaW5pdERvY3VtZW50Q2hhbmdlcyIsImdldFRleHRFZGl0Q2hhbmdlIiwidGV4dERvY3VtZW50RWRpdCIsImluaXRDaGFuZ2VzIiwiY3JlYXRlRmlsZSIsIm9wdGlvbnNPckFubm90YXRpb24iLCJvcGVyYXRpb24iLCJyZW5hbWVGaWxlIiwiZGVsZXRlRmlsZSIsIlBsYWluVGV4dCIsIk1hcmtkb3duIiwiTWV0aG9kIiwiRmllbGQiLCJWYXJpYWJsZSIsIkludGVyZmFjZSIsIk1vZHVsZSIsIlByb3BlcnR5IiwiVW5pdCIsIlZhbHVlIiwiRW51bSIsIktleXdvcmQiLCJTbmlwcGV0IiwiRmlsZSIsIlJlZmVyZW5jZSIsIkZvbGRlciIsIkVudW1NZW1iZXIiLCJDb25zdGFudCIsIlN0cnVjdCIsIk9wZXJhdG9yIiwiVHlwZVBhcmFtZXRlciIsImFzSXMiLCJhZGp1c3RJbmRlbnRhdGlvbiIsImRldGFpbCIsIml0ZW1zIiwiaXNJbmNvbXBsZXRlIiwiZnJvbVBsYWluVGV4dCIsInBsYWluVGV4dCIsImNvbnRlbnRzIiwiZG9jdW1lbnRhdGlvbiIsInBhcmFtZXRlcnMiLCJSZWFkIiwiV3JpdGUiLCJOYW1lc3BhY2UiLCJQYWNrYWdlIiwiS2V5IiwiTnVsbCIsImNvbnRhaW5lck5hbWUiLCJzZWxlY3Rpb25SYW5nZSIsImNoaWxkcmVuIiwidGFncyIsIlF1aWNrRml4IiwiUmVmYWN0b3IiLCJSZWZhY3RvckV4dHJhY3QiLCJSZWZhY3RvcklubGluZSIsIlJlZmFjdG9yUmV3cml0ZSIsIlNvdXJjZSIsIlNvdXJjZU9yZ2FuaXplSW1wb3J0cyIsIlNvdXJjZUZpeEFsbCIsIkF1dG9tYXRpYyIsImRpYWdub3N0aWNzIiwib25seSIsInRyaWdnZXJLaW5kIiwia2luZE9yQ29tbWFuZE9yRWRpdCIsImNoZWNrS2luZCIsImlzUHJlZmVycmVkIiwidGFiU2l6ZSIsImluc2VydFNwYWNlcyIsInBhcmVudCIsInJlc3VsdElkIiwidmFyaWFibGVOYW1lIiwiY2FzZVNlbnNpdGl2ZUxvb2t1cCIsImZyYW1lSWQiLCJzdG9wcGVkTG9jYXRpb24iLCJUeXBlIiwiUGFyYW1ldGVyIiwidG9vbHRpcCIsInRleHRFZGl0cyIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwibGluZUNvdW50IiwiaXNMaW5lU3RhcnQiLCJhdmFpbGFibGVUeXBlZEFycmF5cyIsImdPUEQiLCJnbG9iYWxUaGlzIiwidHlwZWRBcnJheXMiLCIkc2xpY2UiLCJjYWNoZSIsInByb3RvIiwic3VwZXJQcm90byIsInRyeVR5cGVkQXJyYXlzIiwidHJ5QWxsVHlwZWRBcnJheXMiLCJmb3VuZCIsImdldHRlciIsInRyeVNsaWNlcyIsInRyeUFsbFNsaWNlcyIsInRhZyIsInBvc3NpYmxlTmFtZXMiLCJvdXQiLCJfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18iLCJtb2R1bGVJZCIsImNhY2hlZE1vZHVsZSIsImRlZmluaXRpb24iLCJKc29uU2VydmljZSIsImJhc2Vfc2VydmljZSIsImNyZWF0ZVNjYW5uZXIiLCJpZ25vcmVUcml2aWEiLCJ0b2tlbk9mZnNldCIsImxpbmVOdW1iZXIiLCJsaW5lU3RhcnRPZmZzZXQiLCJ0b2tlbkxpbmVTdGFydE9mZnNldCIsInByZXZUb2tlbkxpbmVTdGFydE9mZnNldCIsInNjYW5FcnJvciIsInNjYW5IZXhEaWdpdHMiLCJleGFjdCIsImRpZ2l0cyIsInNldFBvc2l0aW9uIiwibmV3UG9zaXRpb24iLCJzY2FuTnVtYmVyIiwiaXNEaWdpdCIsInNjYW5TdHJpbmciLCJjaDIiLCJjaDMiLCJmcm9tQ2hhckNvZGUiLCJpc0xpbmVCcmVhayIsInNjYW5OZXh0IiwiaXNXaGl0ZVNwYWNlIiwic2FmZUxlbmd0aCIsImNvbW1lbnRDbG9zZWQiLCJpc1Vua25vd25Db250ZW50Q2hhcmFjdGVyIiwic2Nhbk5leHROb25Ucml2aWEiLCJnZXRQb3NpdGlvbiIsInNjYW4iLCJnZXRUb2tlbiIsImdldFRva2VuVmFsdWUiLCJnZXRUb2tlbk9mZnNldCIsImdldFRva2VuTGVuZ3RoIiwiZ2V0VG9rZW5TdGFydExpbmUiLCJnZXRUb2tlblN0YXJ0Q2hhcmFjdGVyIiwiZ2V0VG9rZW5FcnJvciIsIkNoYXJhY3RlckNvZGVzIiwiZm9ybWF0X2Zvcm1hdCIsImRvY3VtZW50VGV4dCIsImluaXRpYWxJbmRlbnRMZXZlbCIsImZvcm1hdFRleHQiLCJmb3JtYXRUZXh0U3RhcnQiLCJyYW5nZVN0YXJ0IiwicmFuZ2VFbmQiLCJmb3JtYXRfaXNFT0wiLCJjb21wdXRlSW5kZW50TGV2ZWwiLCJlb2wiLCJnZXRFT0wiLCJudW1iZXJMaW5lQnJlYWtzIiwiaW5kZW50TGV2ZWwiLCJpbmRlbnRWYWx1ZSIsInNjYW5uZXIiLCJoYXNFcnJvciIsIm5ld0xpbmVzQW5kSW5kZW50Iiwia2VlcExpbmVzIiwiZWRpdE9wZXJhdGlvbnMiLCJhZGRFZGl0IiwiZmlyc3RUb2tlbiIsImZpcnN0VG9rZW5TdGFydCIsImluaXRpYWxJbmRlbnQiLCJmaXJzdFRva2VuRW5kIiwic2Vjb25kVG9rZW4iLCJyZXBsYWNlQ29udGVudCIsIm5lZWRzTGluZUJyZWFrIiwiY29tbWVudFRva2VuU3RhcnQiLCJpbnNlcnRGaW5hbE5ld2xpbmUiLCJzZWNvbmRUb2tlblN0YXJ0IiwicyIsIm5DaGFycyIsIlBhcnNlT3B0aW9ucyIsIkRFRkFVTFQiLCJhbGxvd1RyYWlsaW5nQ29tbWEiLCJnZXRMb2NhdGlvbiIsInNlZ21lbnRzIiwiZWFybHlSZXR1cm5FeGNlcHRpb24iLCJwcmV2aW91c05vZGUiLCJwcmV2aW91c05vZGVJbnN0IiwiaXNBdFByb3BlcnR5S2V5Iiwic2V0UHJldmlvdXNOb2RlIiwiY29sb25PZmZzZXQiLCJ2aXNpdCIsIm9uT2JqZWN0QmVnaW4iLCJvbk9iamVjdFByb3BlcnR5Iiwib25PYmplY3RFbmQiLCJvbkFycmF5QmVnaW4iLCJvbkFycmF5RW5kIiwib25MaXRlcmFsVmFsdWUiLCJnZXROb2RlVHlwZSIsIm9uU2VwYXJhdG9yIiwic2VwIiwicGF0aCIsIm1hdGNoZXMiLCJlcnJvcnMiLCJjdXJyZW50UHJvcGVydHkiLCJjdXJyZW50UGFyZW50IiwicHJldmlvdXNQYXJlbnRzIiwib25WYWx1ZSIsInZpc2l0b3IiLCJwYXJzZXJfcGFyc2VUcmVlIiwiZW5zdXJlUHJvcGVydHlDb21wbGV0ZSIsInZhbHVlTm9kZSIsInBhcnNlcl9maW5kTm9kZUF0TG9jYXRpb24iLCJub2RlIiwic2VnbWVudCIsInByb3BlcnR5Tm9kZSIsImdldE5vZGVQYXRoIiwiZ2V0Tm9kZVZhbHVlIiwiY29udGFpbnMiLCJpbmNsdWRlUmlnaHRCb3VuZCIsImZpbmROb2RlQXRPZmZzZXQiLCJfc2Nhbm5lciIsIl9qc29uUGF0aCIsInRvTm9BcmdWaXNpdCIsInZpc2l0RnVuY3Rpb24iLCJ0b05vQXJnVmlzaXRXaXRoUGF0aCIsInRvT25lQXJnVmlzaXQiLCJ0b09uZUFyZ1Zpc2l0V2l0aFBhdGgiLCJvbkNvbW1lbnQiLCJkaXNhbGxvd0NvbW1lbnRzIiwic2tpcFVudGlsQWZ0ZXIiLCJza2lwVW50aWwiLCJwYXJzZVN0cmluZyIsImlzVmFsdWUiLCJwYXJzZUxpdGVyYWwiLCJ0b2tlblZhbHVlIiwicGFyc2VQcm9wZXJ0eSIsInBhcnNlVmFsdWUiLCJwYXJzZU9iamVjdCIsIm5lZWRzQ29tbWEiLCJwYXJzZUFycmF5IiwiaXNGaXJzdEVsZW1lbnQiLCJhbGxvd0VtcHR5Q29udGVudCIsInN0cmlwQ29tbWVudHMiLCJyZXBsYWNlQ2giLCJyZW1vdmVQcm9wZXJ0eSIsInNldFByb3BlcnR5Iiwib3JpZ2luYWxQYXRoIiwicGFyc2VUcmVlIiwibGFzdFNlZ21lbnQiLCJmaW5kTm9kZUF0TG9jYXRpb24iLCJ3aXRoRm9ybWF0dGluZyIsImV4aXN0aW5nIiwicHJvcGVydHlJbmRleCIsInJlbW92ZUJlZ2luIiwicmVtb3ZlRW5kIiwibmV3UHJvcGVydHkiLCJnZXRJbnNlcnRpb25JbmRleCIsImluc2VydEluZGV4IiwicmVtb3ZhbEluZGV4IiwidG9SZW1vdmUiLCJwYXJlbnRFbmRPZmZzZXQiLCJpc0FycmF5SW5zZXJ0aW9uIiwidG9Nb2RpZnkiLCJmb3JtYXR0aW5nT3B0aW9ucyIsImFwcGx5RWRpdCIsImJlZ2luIiwiaXNFT0wiLCJlZGl0TGVuZ3RoIiwiaXNXUyIsIm1haW5fY3JlYXRlU2Nhbm5lciIsIlNjYW5FcnJvciIsIlN5bnRheEtpbmQiLCJtYWluX2dldExvY2F0aW9uIiwibWFpbl9wYXJzZSIsIm1haW5fcGFyc2VUcmVlIiwibWFpbl9maW5kTm9kZUF0TG9jYXRpb24iLCJtYWluX2ZpbmROb2RlQXRPZmZzZXQiLCJtYWluX2dldE5vZGVQYXRoIiwibWFpbl9nZXROb2RlVmFsdWUiLCJtYWluX3Zpc2l0IiwibWFpbl9zdHJpcENvbW1lbnRzIiwiUGFyc2VFcnJvckNvZGUiLCJwcmludFBhcnNlRXJyb3JDb2RlIiwibWFpbl9mb3JtYXQiLCJtb2RpZnkiLCJpc0RlZmluZWQiLCJoYXlzdGFjayIsIm5lZWRsZSIsImxhc3RJbmRleE9mIiwiY29udmVydFNpbXBsZTJSZWdFeHBQYXR0ZXJuIiwic3RyaW5nc19yZXBlYXQiLCJleHRlbmRlZFJlZ0V4cCIsInN0cmluZ0xlbmd0aCIsIm1haW4iLCJlc21fbWFpbiIsIkVycm9yQ29kZSIsIlNjaGVtYURyYWZ0IiwiQ2xpZW50Q2FwYWJpbGl0aWVzIiwiTEFURVNUIiwiY29tcGxldGlvbiIsImNvbXBsZXRpb25JdGVtIiwiZG9jdW1lbnRhdGlvbkZvcm1hdCIsImNvbW1pdENoYXJhY3RlcnNTdXBwb3J0IiwibGFiZWxEZXRhaWxzU3VwcG9ydCIsInJlYWRGaWxlRnJvbVVyaSIsInByb3RvY29sIiwiZmV0Y2giLCJyZWFkRmlsZUZyb21Gc1BhdGgiLCJidW5kbGUiLCJjb25maWciLCJjb25maWcyIiwiZmlsZUNvbnRlbnQiLCJmc1BhdGgiLCJpc0J1aWx0aW5FeHRlbnNpb24iLCJVUkwiLCJ1cmlDb250ZW50IiwidCIsImZpcnN0QXJnIiwiZm9ybWF0QXJncyIsImNvbW1lbnQiLCJicm93c2VyX2Zvcm1hdCIsIm1lc3NhZ2VGcm9tQnVuZGxlIiwiX2Zvcm1hdDJSZWdleHAiLCJ0ZW1wbGF0ZSIsImpzb24iLCJmb3JtYXRzIiwiZXJyb3JNZXNzYWdlIiwiQVNUTm9kZUltcGwiLCJOdWxsQVNUTm9kZUltcGwiLCJCb29sZWFuQVNUTm9kZUltcGwiLCJib29sVmFsdWUiLCJBcnJheUFTVE5vZGVJbXBsIiwiTnVtYmVyQVNUTm9kZUltcGwiLCJpc0ludGVnZXIiLCJTdHJpbmdBU1ROb2RlSW1wbCIsIlByb3BlcnR5QVNUTm9kZUltcGwiLCJrZXlOb2RlIiwiT2JqZWN0QVNUTm9kZUltcGwiLCJwcm9wZXJ0aWVzIiwiYXNTY2hlbWEiLCJzY2hlbWEiLCJFbnVtTWF0Y2giLCJzY2hlbWFEcmFmdEZyb21JZCIsInYzIiwidjQiLCJ2NiIsInY3IiwidjIwMTlfMDkiLCJ2MjAyMF8xMiIsIkV2YWx1YXRpb25Db250ZXh0Iiwic2NoZW1hRHJhZnQiLCJTY2hlbWFDb2xsZWN0b3IiLCJzY2hlbWFzIiwiaW5jbHVkZSIsImZvY3VzT2Zmc2V0IiwianNvblBhcnNlcl9jb250YWlucyIsImV4Y2x1ZGUiLCJuZXdTdWIiLCJOb09wU2NoZW1hQ29sbGVjdG9yIiwiX3NjaGVtYSIsIl9vdGhlciIsIl9ub2RlIiwiVmFsaWRhdGlvblJlc3VsdCIsImhhc1Byb2JsZW1zIiwicHJvYmxlbXMiLCJ2YWxpZGF0aW9uUmVzdWx0IiwicHJvcGVydGllc01hdGNoZXMiLCJwcm9wZXJ0aWVzVmFsdWVNYXRjaGVzIiwibWVyZ2VQcm9jZXNzZWRQcm9wZXJ0aWVzIiwibWVyZ2VFbnVtVmFsdWVzIiwiZW51bVZhbHVlTWF0Y2giLCJlbnVtVmFsdWVzIiwiRW51bVZhbHVlTWlzbWF0Y2giLCJ2IiwibWVyZ2VQcm9wZXJ0eU1hdGNoIiwicHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0IiwicHJpbWFyeVZhbHVlTWF0Y2hlcyIsInByb2Nlc3NlZFByb3BlcnRpZXMiLCJuZXdKU09ORG9jdW1lbnQiLCJKU09ORG9jdW1lbnQiLCJqc29uUGFyc2VyX2dldE5vZGVWYWx1ZSIsImpzb25QYXJzZXJfZ2V0Tm9kZVBhdGgiLCJnZXROb2RlRnJvbU9mZnNldCIsImRvVmlzaXQiLCJjdG4iLCJ2YWxpZGF0ZSIsImdldFNjaGVtYURyYWZ0IiwiZ2V0TWF0Y2hpbmdTY2hlbWFzIiwibWF0Y2hpbmdTY2hlbWFzIiwic3ludGF4RXJyb3JzIiwiY29tbWVudHMiLCJmYWxsQmFjayIsInNjaGVtYUlkIiwiJHNjaGVtYSIsIl92YWxpZGF0ZU5vZGUiLCJfdmFsaWRhdGVPYmplY3ROb2RlIiwiX3ZhbGlkYXRlQXJyYXlOb2RlIiwiX3ZhbGlkYXRlU3RyaW5nTm9kZSIsIl92YWxpZGF0ZU51bWJlck5vZGUiLCJtYXRjaGVzVHlwZSIsInNvbWUiLCJhbGxPZiIsInN1YlNjaGVtYVJlZiIsInN1YlZhbGlkYXRpb25SZXN1bHQiLCJzdWJNYXRjaGluZ1NjaGVtYXMiLCJub3RTY2hlbWEiLCJub3QiLCJpbnZlcnRlZCIsInRlc3RBbHRlcm5hdGl2ZXMiLCJhbHRlcm5hdGl2ZXMiLCJtYXhPbmVNYXRjaCIsImJlc3RNYXRjaCIsInN1YlNjaGVtYSIsImNvbXBhcmVSZXN1bHQiLCJhbnlPZiIsInRlc3RCcmFuY2giLCJ0ZXN0Q29uZGl0aW9uIiwiaWZTY2hlbWEiLCJ0aGVuU2NoZW1hIiwiZWxzZVNjaGVtYSIsImlmIiwiZWxzZSIsImVudW0iLCJjb25zdCIsImRlcHJlY2F0aW9uTWVzc2FnZSIsIm5vcm1hbGl6ZUZsb2F0cyIsImZsb2F0IiwibXVsdGlwbGllciIsIm11bHRpcGxlT2YiLCJyZW1haW5kZXIiLCJub3JtTXVsdGlwbGVPZiIsIm5vcm1WYWx1ZSIsImFicyIsImdldEV4Y2x1c2l2ZUxpbWl0IiwiZXhjbHVzaXZlIiwiZ2V0TGltaXQiLCJleGNsdXNpdmVNaW5pbXVtIiwibWluaW11bSIsImV4Y2x1c2l2ZU1heGltdW0iLCJtYXhpbXVtIiwibWluTGVuZ3RoIiwicmVnZXgiLCJwYXR0ZXJuRXJyb3JNZXNzYWdlIiwicHJlZml4SXRlbXNTY2hlbWFzIiwiYWRkaXRpb25hbEl0ZW1TY2hlbWEiLCJwcmVmaXhJdGVtcyIsImFkZGl0aW9uYWxJdGVtcyIsIml0ZW1WYWxpZGF0aW9uUmVzdWx0IiwiY29udGFpbnNTY2hlbWEiLCJjb250YWluc0NvdW50IiwibWluQ29udGFpbnMiLCJtYXhDb250YWlucyIsInVuZXZhbHVhdGVkSXRlbXMiLCJtaW5JdGVtcyIsIm1heEl0ZW1zIiwidW5pcXVlSXRlbXMiLCJkdXBsaWNhdGVzIiwic2VlbktleXMiLCJ1bnByb2Nlc3NlZFByb3BlcnRpZXMiLCJyZXF1aXJlZCIsInByb3BlcnR5TmFtZSIsInByb3BlcnR5UHJvY2Vzc2VkIiwicHJvcGVydHlTY2hlbWEiLCJjaGlsZCIsInBhdHRlcm5Qcm9wZXJ0aWVzIiwicHJvcGVydHlQYXR0ZXJuIiwicHJvY2Vzc2VkIiwiYWRkaXRpb25hbFByb3BlcnRpZXMiLCJ1bmV2YWx1YXRlZFByb3BlcnRpZXMiLCJtYXhQcm9wZXJ0aWVzIiwibWluUHJvcGVydGllcyIsImRlcGVuZGVudFJlcXVpcmVkIiwicHJvcGVydHlEZXBzIiwiX3ZhbGlkYXRlUHJvcGVydHlEZXBlbmRlbmNpZXMiLCJkZXBlbmRlbnRTY2hlbWFzIiwiZGVwZW5kZW5jaWVzIiwicHJvcGVydHlOYW1lcyIsInByb3BlcnR5RGVwIiwicmVxdWlyZWRQcm9wIiwianNvblBhcnNlcl9wYXJzZSIsImxhc3RQcm9ibGVtT2Zmc2V0IiwiY29tbWVudFJhbmdlcyIsImNvbGxlY3RDb21tZW50cyIsIl9zY2FuTmV4dCIsIl9jaGVja1NjYW5FcnJvciIsIl9hY2NlcHQiLCJfZXJyb3JBdFJhbmdlIiwiX2Vycm9yIiwiX2ZpbmFsaXplIiwiSW52YWxpZFVuaWNvZGUiLCJJbnZhbGlkRXNjYXBlQ2hhcmFjdGVyIiwiVW5leHBlY3RlZEVuZE9mTnVtYmVyIiwiVW5leHBlY3RlZEVuZE9mQ29tbWVudCIsIlVuZXhwZWN0ZWRFbmRPZlN0cmluZyIsIkludmFsaWRDaGFyYWN0ZXIiLCJfcGFyc2VBcnJheSIsIlZhbHVlRXhwZWN0ZWQiLCJjb21tYU9mZnNldCIsIlRyYWlsaW5nQ29tbWEiLCJDb21tYUV4cGVjdGVkIiwiX3BhcnNlVmFsdWUiLCJDb21tYU9yQ2xvc2VCYWNrZXRFeHBlY3RlZCIsImtleVBsYWNlaG9sZGVyIiwiX3BhcnNlUHJvcGVydHkiLCJrZXlzU2VlbiIsIl9wYXJzZVN0cmluZyIsIlVuZGVmaW5lZCIsIkR1cGxpY2F0ZUtleSIsIkNvbG9uRXhwZWN0ZWQiLCJfcGFyc2VPYmplY3QiLCJQcm9wZXJ0eUV4cGVjdGVkIiwicHJvcGVydHkiLCJDb21tYU9yQ2xvc2VCcmFjZUV4cGVjdGVkIiwiX3BhcnNlTnVtYmVyIiwiX3BhcnNlTGl0ZXJhbCIsIl9yb290Iiwic3RyaW5naWZ5T2JqZWN0IiwiaW5kZW50Iiwic3RyaW5naWZ5TGl0ZXJhbCIsIm5ld0luZGVudCIsInZhbHVlQ29tbWl0Q2hhcmFjdGVycyIsInByb3BlcnR5Q29tbWl0Q2hhcmFjdGVycyIsIkpTT05Db21wbGV0aW9uIiwiY29udHJpYnV0aW9ucyIsInJlc29sdmVDb21wbGV0aW9uIiwicmVzb2x2ZXIiLCJwcm9taXNlQ29uc3RydWN0b3IiLCJkb2MiLCJpc0luQ29tbWVudCIsImN1cnJlbnRXb3JkIiwiZ2V0Q3VycmVudFdvcmQiLCJvdmVyd3JpdGVSYW5nZSIsIm92ZXJ3cml0ZVN0YXJ0Iiwic3VwcG9ydHNDb21taXRDaGFyYWN0ZXJzIiwicHJvcG9zZWQiLCJjb2xsZWN0b3IiLCJzdWdnZXN0aW9uIiwic2hvcnRlbmRlZExhYmVsIiwiaW5zZXJ0VGV4dCIsImNvbW1pdENoYXJhY3RlcnMiLCJsYWJlbERldGFpbHMiLCJzZXRBc0luY29tcGxldGUiLCJnZXROdW1iZXJPZlByb3Bvc2FscyIsInNjaGVtYVNlcnZpY2UiLCJnZXRTY2hlbWFGb3JSZXNvdXJjZSIsImNvbGxlY3Rpb25Qcm9taXNlcyIsImFkZFZhbHVlIiwiY3VycmVudEtleSIsInNlcGFyYXRvckFmdGVyIiwiZXZhbHVhdGVTZXBhcmF0b3JBZnRlciIsImdldFByb3BlcnR5Q29tcGxldGlvbnMiLCJnZXRTY2hlbWFMZXNzUHJvcGVydHlDb21wbGV0aW9ucyIsImNvbnRyaWJ1dGlvbiIsImNvbGxlY3RQcm9taXNlIiwiY29sbGVjdFByb3BlcnR5Q29tcGxldGlvbnMiLCJnZXRMYWJlbEZvclZhbHVlIiwiZ2V0SW5zZXJ0VGV4dEZvclByb3BlcnR5IiwiaW5zZXJ0VGV4dEZvcm1hdCIsImdldFZhbHVlQ29tcGxldGlvbnMiLCJnZXRTY2hlbWFMZXNzVmFsdWVDb21wbGV0aW9ucyIsImdldENvbnRyaWJ1dGVkVmFsdWVDb21wbGV0aW9ucyIsIm9mZnNldEZvclNlcGFyYXRvciIsImFkZEZpbGxlclZhbHVlQ29tcGxldGlvbnMiLCJzY2hlbWFQcm9wZXJ0aWVzIiwiZG9Ob3RTdWdnZXN0IiwicHJvcG9zYWwiLCJmaWx0ZXJUZXh0IiwiZ2V0RmlsdGVyVGV4dEZvclZhbHVlIiwiZnJvbU1hcmt1cCIsIm1hcmtkb3duRGVzY3JpcHRpb24iLCJzdWdnZXN0U29ydFRleHQiLCJzb3J0VGV4dCIsInNjaGVtYVByb3BlcnR5TmFtZXMiLCJwcm9wZXJ0eU5hbWVDb21wbGV0aW9uSXRlbSIsImVudW1EZXNjcmlwdGlvbiIsIm1hcmtkb3duRW51bURlc2NyaXB0aW9ucyIsImVudW1EZXNjcmlwdGlvbnMiLCJjb2xsZWN0Q29tcGxldGlvbnNGb3JTaW1pbGFyT2JqZWN0IiwiZ2V0SW5zZXJ0VGV4dEZvclZhbHVlIiwicGFyZW50S2V5IiwiZ2V0U3VnZ2VzdGlvbktpbmQiLCJjb2xsZWN0U3VnZ2VzdGlvbnNGb3JWYWx1ZXMiLCJnZXRMYWJlbFRleHRGb3JNYXRjaGluZ05vZGUiLCJnZXRJbnNlcnRUZXh0Rm9yTWF0Y2hpbmdOb2RlIiwiYWRkQm9vbGVhblZhbHVlQ29tcGxldGlvbiIsImFkZERvbGxhclNjaGVtYUNvbXBsZXRpb25zIiwiYWRkU2NoZW1hVmFsdWVDb21wbGV0aW9ucyIsImMiLCJleGlzdGluZ1ZhbHVlcyIsImZpbmRJdGVtQXRPZmZzZXQiLCJwcm9wZXJ0eU1hdGNoZWQiLCJhZGROdWxsVmFsdWVDb21wbGV0aW9uIiwiY29sbGVjdERlZmF1bHRDb21wbGV0aW9ucyIsImNvbGxlY3RWYWx1ZUNvbXBsZXRpb25zIiwiYWRkRW51bVZhbHVlQ29tcGxldGlvbnMiLCJhZGREZWZhdWx0VmFsdWVDb21wbGV0aW9ucyIsImNvbGxlY3RUeXBlcyIsImFycmF5RGVwdGgiLCJoYXNQcm9wb3NhbHMiLCJkb2VzU3VwcG9ydHNMYWJlbERldGFpbHMiLCJleGFtcGxlcyIsImV4YW1wbGUiLCJkZWZhdWx0U25pcHBldHMiLCJnZXRJbnNlcnRUZXh0Rm9yU25pcHBldFZhbHVlIiwiZ2V0RmlsdGVyVGV4dEZvclNuaXBwZXRWYWx1ZSIsImdldExhYmVsRm9yU25pcHBldFZhbHVlIiwiYm9keVRleHQiLCJwcmVmaXgiLCJzdWZmaXgiLCJlbm0iLCJkb2VzU3VwcG9ydE1hcmtkb3duIiwiZ2V0SW5zZXJ0VGV4dEZvckd1ZXNzZWRWYWx1ZSIsInNjaGVtYUlkcyIsImdldFJlZ2lzdGVyZWRTY2hlbWFJZHMiLCJnZXRWYWx1ZUZyb21MYWJlbCIsImdldEluc2VydFRleHRGb3JQbGFpblRleHQiLCJyZXBsYWNlciIsInNuaXBwZXRWYWx1ZSIsInByb3BlcnR5VGV4dCIsInJlc3VsdFRleHQiLCJuVmFsdWVQcm9wb3NhbHMiLCJtYXJrdXBTdHJpbmciLCJzdXBwb3J0c01hcmtkb3duIiwiY2xpZW50Q2FwYWJpbGl0aWVzIiwiZG9lc1N1cHBvcnRzQ29tbWl0Q2hhcmFjdGVycyIsIkpTT05Ib3ZlciIsImhvdmVyUmFuZ2VOb2RlIiwiaG92ZXJSYW5nZSIsImNyZWF0ZUhvdmVyIiwiZ2V0SW5mb0NvbnRyaWJ1dGlvbiIsImh0bWxDb250ZW50IiwibWFya2Rvd25FbnVtVmFsdWVEZXNjcmlwdGlvbiIsImVudW1WYWx1ZSIsInRvTWFya2Rvd24iLCJ0b01hcmtkb3duQ29kZUJsb2NrIiwicGxhaW4iLCJKU09OVmFsaWRhdGlvbiIsImNvbmZpZ3VyZSIsInJhdyIsInZhbGlkYXRpb25FbmFibGVkIiwiY29tbWVudFNldmVyaXR5IiwiYWxsb3dDb21tZW50cyIsImpzb25Eb2N1bWVudCIsImRvY3VtZW50U2V0dGluZ3MiLCJhZGRlZCIsImFkZFByb2JsZW0iLCJwcm9ibGVtIiwic2lnbmF0dXJlIiwiZ2V0RGlhZ25vc3RpY3MiLCJ0cmFpbGluZ0NvbW1hU2V2ZXJpdHkiLCJ0cmFpbGluZ0NvbW1hcyIsInRvRGlhZ25vc3RpY1NldmVyaXR5Iiwic2NoZW1hVmFsaWRhdGlvbiIsInNjaGVtYVJlcXVlc3QiLCJhZGRTY2hlbWFQcm9ibGVtIiwiZXJyb3JDb2RlIiwiYXN0Um9vdCIsIlNjaGVtYVJlc29sdmVFcnJvciIsIndhcm5pbmciLCJ3YXJuaW5ncyIsIlNjaGVtYVVuc3VwcG9ydGVkRmVhdHVyZSIsInNlbWFudGljRXJyb3JzIiwic2NoZW1hQWxsb3dzQ29tbWVudHMiLCJzY2hlbWFBbGxvd3NUcmFpbGluZ0NvbW1hcyIsIkNvbW1lbnROb3RQZXJtaXR0ZWQiLCJpZENvdW50ZXIiLCJqc29uU2NoZW1hU2VydmljZSIsInJlZ2lzdGVyRXh0ZXJuYWxTY2hlbWEiLCJnZXRSZXNvbHZlZFNjaGVtYSIsInJlc29sdmVkU2NoZW1hIiwiZ2V0TGFuZ3VhZ2VTdGF0dXMiLCJnZXRTY2hlbWFVUklzRm9yUmVzb3VyY2UiLCJzY2hlbWFSZWYiLCJhbGxvdyIsImFsbG93VHJhaWxpbmdDb21tYXMiLCJkZXByU2NoZW1hUmVmIiwic2V2ZXJpdHlMZXZlbCIsIkRpZ2l0MCIsIkRpZ2l0OSIsIkEiLCJoZXhEaWdpdCIsImNoYXJDb2RlIiwiY29sb3JGcm9tSGV4IiwiY29sb3JGcm9tMjU2UkdCIiwiSlNPTkRvY3VtZW50U3ltYm9scyIsImZpbmREb2N1bWVudFN5bWJvbHMiLCJyZXN1bHRMaW1pdCIsInJlc291cmNlU3RyaW5nIiwiZ2V0UmFuZ2UiLCJnZXROYW1lIiwib25SZXN1bHRMaW1pdEV4Y2VlZGVkIiwidG9WaXNpdCIsIm5leHRUb1Zpc2l0IiwibGltaXRFeGNlZWRlZCIsImNvbGxlY3RPdXRsaW5lRW50cmllcyIsImNoaWxkQ29udGFpbmVyTmFtZSIsImdldEtleUxhYmVsIiwiZ2V0U3ltYm9sS2luZCIsImZpbmREb2N1bWVudFN5bWJvbHMyIiwic3ltYm9sIiwiZ2V0RGV0YWlsIiwibm9kZVR5cGUiLCJmaW5kRG9jdW1lbnRDb2xvcnMiLCJ2aXNpdGVkTm9kZSIsIm5vZGVJZCIsImdldENvbG9yUHJlc2VudGF0aW9ucyIsInJlZDI1NiIsImdyZWVuMjU2IiwiYmx1ZTI1NiIsInRvVHdvRGlnaXRIZXgiLCJzY2hlbWFDb250cmlidXRpb25zIiwic2NoZW1hQXNzb2NpYXRpb25zIiwiJHJlZiIsImRlc2NyaXB0aW9ucyIsImRlZmluaXRpb25zIiwiJGlkIiwiJGNvbW1lbnQiLCJyZWFkT25seSIsImNvbnRlbnRNZWRpYVR5cGUiLCJjb250ZW50RW5jb2RpbmciLCJzY2hlbWFOYW1lIiwicHJvcGVydHlPYmplY3QiLCJMSUIiLCJoIiwibm9ybWFsaXplIiwiaXNBYnNvbHV0ZSIsInJlbGF0aXZlIiwidSIsIl9tYWtlTG9uZyIsImRpcm5hbWUiLCJiYXNlbmFtZSIsImV4dG5hbWUiLCJleHQiLCJkZWxpbWl0ZXIiLCJ3aW4zMiIsInBvc2l4IiwiVXRpbHMiLCJPIiwicGxhdGZvcm0iLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJhdXRob3JpdHkiLCJxdWVyeSIsImZyYWdtZW50IiwiaXNVcmkiLCJ3aXRoIiwiQyIsInJldml2ZSIsIl9mb3JtYXR0ZWQiLCJleHRlcm5hbCIsIl9mc1BhdGgiLCJfc2VwIiwiJG1pZCIsInciLCJQIiwiSSIsIlUiLCJqb2luUGF0aCIsInJlc29sdmVQYXRoIiwiY3JlYXRlUmVnZXgiLCJnbG9iIiwicmVTdHIiLCJleHRlbmRlZCIsImdsb2JzdGFyIiwiaW5Hcm91cCIsInByZXZDaGFyIiwic3RhckNvdW50IiwibmV4dENoYXIiLCJpc0dsb2JzdGFyIiwiQkFORyIsIlBBVEhfU0VQIiwiRmlsZVBhdHRlcm5Bc3NvY2lhdGlvbiIsIm1hdGNoZXNQYXR0ZXJuIiwiZmlsZU5hbWUiLCJmb2xkZXJVcmkiLCJyZWdleHAiLCJnbG9iV3JhcHBlcnMiLCJnZXRVUklzIiwidXJpcyIsInBhdHRlcm5TdHJpbmciLCJub3JtYWxpemVSZXNvdXJjZUZvck1hdGNoaW5nIiwiU2NoZW1hSGFuZGxlIiwiZ2V0VW5yZXNvbHZlZFNjaGVtYSIsInVucmVzb2x2ZWRTY2hlbWEiLCJzZXJ2aWNlIiwibG9hZFNjaGVtYSIsInVucmVzb2x2ZWQiLCJyZXNvbHZlU2NoZW1hQ29udGVudCIsImNsZWFyU2NoZW1hIiwiaGFzQ2hhbmdlcyIsImFuY2hvcnMiLCJ1bnJlc29sdmVkU2NoZW1hQ29udGVudCIsIlVucmVzb2x2ZWRTY2hlbWEiLCJSZXNvbHZlZFNjaGVtYSIsImdldFNlY3Rpb24iLCJnZXRTZWN0aW9uUmVjdXJzaXZlIiwiSlNPTlNjaGVtYVNlcnZpY2UiLCJyZWdpc3RlcmVkU2NoZW1hc0lkcyIsImNhbGxPbkRpc3Bvc2UiLCJvblJlc291cmNlQ2hhbmdlIiwiY2FjaGVkU2NoZW1hRm9yUmVzb3VyY2UiLCJub3JtYWxpemVJZCIsInRvV2FsayIsInNjaGVtYXNCeUlkIiwiY3VyciIsInNldFNjaGVtYUNvbnRyaWJ1dGlvbnMiLCJub3JtYWxpemVkSWQiLCJjb250cmlidXRpb25TY2hlbWFzIiwiYWRkU2NoZW1hSGFuZGxlIiwic2NoZW1hQXNzb2NpYXRpb24iLCJhc3NvY2lhdGlvbiIsImFkZEZpbGVQYXR0ZXJuQXNzb2NpYXRpb24iLCJjb250cmlidXRpb25Bc3NvY2lhdGlvbnMiLCJzY2hlbWFIYW5kbGUiLCJnZXRPckFkZFNjaGVtYUhhbmRsZSIsImZwYSIsImZpbGVQYXR0ZXJuQXNzb2NpYXRpb25zIiwiZmlsZU1hdGNoIiwiY2xlYXJFeHRlcm5hbFNjaGVtYXMiLCJjb250cmlidXRpb25Bc3NvY2lhdGlvbiIsInVybCIsInJlcXVlc3RTZXJ2aWNlIiwidG9EaXNwbGF5U3RyaW5nIiwidHJpbVN0YXJ0Iiwic2NoZW1hQ29udGVudCIsImpzb25FcnJvcnMiLCJlcnJvclNwbGl0Iiwic2NoZW1hVG9SZXNvbHZlIiwicmVzb2x2ZUVycm9ycyIsInVzZXNVbnN1cHBvcnRlZEZlYXR1cmVzIiwiY29udGV4dFNlcnZpY2UiLCJmaW5kU2VjdGlvbkJ5SlNPTlBvaW50ZXIiLCJmaW5kU2NoZW1hQnlJZCIsImNvbGxlY3RBbmNob3JzIiwic2VjdGlvbiIsIm1lcmdlUmVmIiwic291cmNlUm9vdCIsInNvdXJjZUhhbmRsZSIsInJlZlNlZ21lbnQiLCJyZXNvbHZlRXh0ZXJuYWxMaW5rIiwicGFyZW50SGFuZGxlIiwicmVzb2x2ZVJlbGF0aXZlUGF0aCIsInJlZmVyZW5jZWRIYW5kbGUiLCJsb2MiLCJyZXNvbHZlUmVmcyIsInBhcmVudFNjaGVtYSIsIm9wZW5Qcm9taXNlcyIsInRyYXZlcnNlTm9kZXMiLCJzZWVuUmVmcyIsInJlZiIsIiRyZWN1cnNpdmVSZWYiLCIkZHluYW1pY1JlZiIsImFuY2hvciIsIiRhbmNob3IiLCIkcmVjdXJzaXZlQW5jaG9yIiwiJGR5bmFtaWNBbmNob3IiLCJyZXNvbHZlV2FybmluZ3MiLCJjb2xsZWN0RW50cmllcyIsImVudHJ5IiwiY29sbGVjdE1hcEVudHJpZXMiLCJtYXBzIiwiY29sbGVjdEFycmF5RW50cmllcyIsImFycmF5cyIsImNvbGxlY3RFbnRyeU9yQXJyYXlFbnRyaWVzIiwiJGRlZnMiLCJnZXRTY2hlbWFGcm9tUHJvcGVydHkiLCJyZXNvdXJjZSIsImdldEFzc29jaWF0ZWRTY2hlbWFzIiwibm9ybWFsaXplZFJlc291cmNlIiwic2NoZW1lSWQiLCJjcmVhdGVDb21iaW5lZFNjaGVtYSIsImNvbWJpbmVkU2NoZW1hSWQiLCJjb21iaW5lZFNjaGVtYSIsImpzb25TY2hlbWFTZXJ2aWNlX2lkQ291bnRlciIsImdldEZvbGRpbmdSYW5nZXMiLCJuZXN0aW5nTGV2ZWxzIiwicHJldlN0YXJ0IiwiYWRkUmFuZ2UiLCJyYW5nZUxpbWl0Iiwib25SYW5nZUxpbWl0RXhjZWVkZWQiLCJjb3VudHMiLCJsZXZlbCIsIm1heExldmVsIiwiZ2V0U2VsZWN0aW9uUmFuZ2VzIiwicG9zaXRpb25zIiwiZ2V0U2VsZWN0aW9uUmFuZ2UiLCJjU3RhcnQiLCJjRW5kIiwibmV3UmFuZ2UiLCJhZnRlckNvbW1hT2Zmc2V0IiwiZ2V0T2Zmc2V0QWZ0ZXJOZXh0VG9rZW4iLCJleHBlY3RlZFRva2VuIiwidXRpbHNfZm9ybWF0X2Zvcm1hdCIsImRvY3VtZW50VG9Gb3JtYXQiLCJmb3JtYXR0aW5nUmFuZ2UiLCJDb250YWluZXIiLCJQcm9wZXJ0eVRyZWUiLCJhZGRDaGlsZFByb3BlcnR5IiwiY2hpbGRQcm9wZXJ0eSIsImNoaWxkcmVuUHJvcGVydGllcyIsImluc2VydGlvbkluZGV4Iiwibm9LZXlOYW1lIiwiYmluYXJ5U2VhcmNoT25Qcm9wZXJ0eUFycmF5IiwiY29tcGFyZVByb3BlcnRpZXMiLCJiZWdpbm5pbmdMaW5lTnVtYmVyIiwibGFzdFByb3BlcnR5IiwicHJvcGVydHlUcmVlMSIsInByb3BlcnR5VHJlZTIiLCJwcm9wZXJ0eU5hbWUxIiwicHJvcGVydHlOYW1lMiIsInByb3BlcnR5VHJlZUFycmF5IiwicHJvcGVydHlUcmVlIiwiY29tcGFyZV9mbiIsImZpcnN0UHJvcGVydHlJbkFycmF5TmFtZSIsImxhc3RQcm9wZXJ0eUluQXJyYXlOYW1lIiwiZG9jdW1lbnRUb1NvcnQiLCJmb3JtYXR0ZWRKc29uU3RyaW5nIiwiZm9ybWF0dGVkSnNvbkRvY3VtZW50IiwianNvblByb3BlcnR5VHJlZSIsImZpbmRKc29uY1Byb3BlcnR5VHJlZSIsInNvcnRlZEpzb25Eb2N1bWVudCIsInNvcnRKc29uY0RvY3VtZW50Iiwic29ydGVkQW5kRm9ybWF0dGVkSnNvbkRvY3VtZW50IiwiZm9ybWF0dGVkRG9jdW1lbnQiLCJmb3JtYXR0ZWRTdHJpbmciLCJyb290VHJlZSIsImN1cnJlbnRUcmVlIiwibGFzdFRva2VuTGluZSIsIm51bWJlck9mQ2hhcmFjdGVyc09uUHJldmlvdXNMaW5lcyIsImxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4iLCJzZWNvbmRUb0xhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4iLCJsaW5lT2ZMYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuIiwiZW5kSW5kZXhPZkxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4iLCJlbmRMaW5lTnVtYmVyIiwiY3VycmVudENvbnRhaW5lclN0YWNrIiwidXBkYXRlTGFzdFByb3BlcnR5RW5kTGluZU51bWJlciIsInVwZGF0ZUJlZ2lubmluZ0xpbmVOdW1iZXIiLCJsZW5ndGhPZkxpbmUiLCJsaW5lV2hlcmVUb0FkZENvbW1hIiwiaW5kZXhXaGVyZVRvQWRkQ29tYSIsImNvbW1hSW5kZXgiLCJjb21tYUxpbmUiLCJxdWV1ZVRvU29ydCIsInVwZGF0ZVNvcnRpbmdRdWV1ZSIsImRhdGFUb1NvcnQiLCJqc29uQ29udGVudFRvUmVwbGFjZSIsImpzb25Eb2N1bWVudFRvUmVwbGFjZSIsImluZGV4V2hlcmVUb0FkZENvbW1hIiwibGluZVdoZXJlVG9SZW1vdmVDb21tYSIsIm1pbmltdW1CZWdpbm5pbmdMaW5lTnVtYmVyIiwiU29ydGluZ1JhbmdlIiwidXBkYXRlU29ydGluZ1F1ZXVlRm9yQXJyYXlQcm9wZXJ0aWVzIiwic3ViT2JqZWN0IiwiZmluZExpbmtzIiwibGlua3MiLCJ0YXJnZXROb2RlIiwiZmluZFRhcmdldE5vZGUiLCJ0YXJnZXRQb3MiLCJjcmVhdGVSYW5nZSIsInRva2VucyIsInBhcnNlSlNPTlBvaW50ZXIiLCJmaW5kTm9kZSIsInBvaW50ZXIiLCJmaW5kIiwiYXJyYXlJdGVtIiwianNvbkxpbmtzX3VuZXNjYXBlIiwiZ2V0TGFuZ3VhZ2VTZXJ2aWNlIiwic2NoZW1hUmVxdWVzdFNlcnZpY2UiLCJ3b3Jrc3BhY2VDb250ZXh0IiwianNvbkNvbXBsZXRpb24iLCJqc29uSG92ZXIiLCJqc29uRG9jdW1lbnRTeW1ib2xzIiwianNvblZhbGlkYXRpb24iLCJzZXR0aW5ncyIsInJlc2V0U2NoZW1hIiwicGFyc2VKU09ORG9jdW1lbnQiLCJmaW5kRGVmaW5pdGlvbiIsImJyb3dzZXJfbWFpbiIsInV0aWxzIiwiQWNlUmFuZ2UiLCJnZXRDb25zdHJ1Y3RvciIsImVkaXRvciIsIl9pbnN0YW5jZSIsImNvbW1vbl9jb252ZXJ0ZXJzX0NvbW1vbkNvbnZlcnRlciIsIkNvbW1vbkNvbnZlcnRlciIsIm5vcm1hbGl6ZVJhbmdlcyIsImNvbXBsZXRpb25zIiwiZWwiLCJ0b1JhbmdlIiwiY2xlYW5IdG1sIiwiaHRtbCIsImZyb21Qb2ludHMiLCJjb252ZXJ0S2luZCIsImV4Y2x1ZGVCeUVycm9yTWVzc2FnZSIsImZpZWxkTmFtZSIsImZyb21SYW5nZSIsInJhbmdlRnJvbVBvc2l0aW9ucyIsImZyb21Qb2ludCIsInBvaW50IiwidG9Qb2ludCIsInRvQW5ub3RhdGlvbnMiLCJfZGlhZ25vc3RpY3MiLCJ0b0NvbXBsZXRpb24iLCJfaXRlbV90ZXh0RWRpdCIsIl9pdGVtX2NvbW1hbmQiLCJpdGVtS2luZCIsIl9pdGVtX3RleHRFZGl0X25ld1RleHQiLCJfcmVmIiwiZ2V0VGV4dEVkaXRSYW5nZSIsImNhcHRpb24iLCJzY29yZSIsInRvQ29tcGxldGlvbnMiLCJjb21iaW5lZENvbXBsZXRpb25zIiwiYWxsQ29tcGxldGlvbnMiLCJmbGF0IiwidG9SZXNvbHZlZENvbXBsZXRpb24iLCJmcm9tTWFya3VwQ29udGVudCIsInRvQ29tcGxldGlvbkl0ZW0iLCJfY29tcGxldGlvbl9jYXB0aW9uIiwiX2NvbXBsZXRpb25fc25pcHBldCIsIl9jb21wbGV0aW9uX3NuaXBwZXQxIiwibWVyZ2VkUmFuZ2VzIiwidG9Ub29sdGlwIiwiaG92ZXIiLCJfaG92ZXJfZmluZCIsImxzcFJhbmdlIiwiX2VsIiwiZnJvbVNpZ25hdHVyZUhlbHAiLCJzaWduYXR1cmVIZWxwIiwiX2VsMSIsInNpZ25hdHVyZUluZGV4IiwiYWN0aXZlU2lnbmF0dXJlIiwic2lnbmF0dXJlcyIsImFjdGl2ZVBhcmFtIiwiYWN0aXZlUGFyYW1ldGVyIiwiZnJvbUFjZURlbHRhIiwiZGVsdGEiLCJsaW5lcyIsImFjdGlvbiIsImZpbHRlckRpYWdub3N0aWNzIiwiZmlsdGVyRXJyb3JzIiwiZnJvbURvY3VtZW50SGlnaGxpZ2h0cyIsImRvY3VtZW50SGlnaGxpZ2h0cyIsImNsYXNzTmFtZSIsInRvTWFya2VyR3JvdXBJdGVtIiwidG9vbHRpcFRleHQiLCJtYXJrZXJHcm91cEl0ZW0iLCJqc29uX3NlcnZpY2VfZGVmaW5lX3Byb3BlcnR5IiwiJGdldEpzb25TY2hlbWFVcmkiLCIkY29uZmlndXJlU2VydmljZSIsIl9zY2hlbWFzIiwic2Vzc2lvbklEcyIsIl9maWxlTWF0Y2giLCJfZWxfc2NoZW1hIiwiJHNlcnZpY2UiLCJfZWxfZmlsZU1hdGNoIiwiZnVsbERvY3VtZW50IiwiY29tcGxldGlvblByb3ZpZGVyIiwidHJpZ2dlckNoYXJhY3RlcnMiLCJkaWFnbm9zdGljUHJvdmlkZXIiLCJpbnRlckZpbGVEZXBlbmRlbmNpZXMiLCJ3b3Jrc3BhY2VEaWFnbm9zdGljcyIsImRvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUHJvdmlkZXIiLCJkb2N1bWVudEZvcm1hdHRpbmdQcm92aWRlciIsImhvdmVyUHJvdmlkZXIiLCJqc29uU2NoZW1hIl0sInNvdXJjZVJvb3QiOiIifQ==