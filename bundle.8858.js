(self["webpackChunkace_linters_root"] = self["webpackChunkace_linters_root"] || []).push([[8858],{

/***/ 38858:
/***/ ((module) => {

function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes(arr) {
    if (Array.isArray(arr)) return arr;
}
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _assert_this_initialized(self1) {
    if (self1 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self1;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self1 = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self1, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _construct(Parent, args, Class) {
    if (_is_native_reflect_construct()) {
        _construct = Reflect.construct;
    } else {
        _construct = function construct(Parent, args, Class) {
            var a = [
                null
            ];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();
            if (Class) _set_prototype_of(instance, Class.prototype);
            return instance;
        };
    }
    return _construct.apply(null, arguments);
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
    } else {
        _get = function get(target, property, receiver) {
            var base = _super_prop_base(target, property);
            if (!base) return;
            var desc = Object.getOwnPropertyDescriptor(base, property);
            if (desc.get) {
                return desc.get.call(receiver || target);
            }
            return desc.value;
        };
    }
    return _get(target, property, receiver || target);
}
function _get_prototype_of(o) {
    _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of(o);
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of(subClass, superClass);
}
function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _is_native_function(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _iterable_to_array_limit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _possible_constructor_return(self1, call) {
    if (call && (_type_of(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized(self1);
}
function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of(o, p);
}
function _sliced_to_array(arr, i) {
    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _super_prop_base(object, property) {
    while(!Object.prototype.hasOwnProperty.call(object, property)){
        object = _get_prototype_of(object);
        if (object === null) break;
    }
    return object;
}
function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _type_of(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
function _wrap_native_super(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    _wrap_native_super = function wrapNativeSuper(Class) {
        if (Class === null || !_is_native_function(Class)) return Class;
        if (typeof Class !== "function") {
            throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
            if (_cache.has(Class)) return _cache.get(Class);
            _cache.set(Class, Wrapper);
        }
        function Wrapper() {
            return _construct(Class, arguments, _get_prototype_of(this).constructor);
        }
        Wrapper.prototype = Object.create(Class.prototype, {
            constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        return _set_prototype_of(Wrapper, Class);
    };
    return _wrap_native_super(Class);
}
function _is_native_reflect_construct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _create_super(Derived) {
    var hasNativeReflectConstruct = _is_native_reflect_construct();
    return function _createSuperInternal() {
        var Super = _get_prototype_of(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _get_prototype_of(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possible_constructor_return(this, result);
    };
}
function _ts_generator(thisArg, body) {
    var f, y, t, g, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    };
    return(g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g);
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
(function webpackUniversalModuleDefinition(root, factory) {
    if (true) module.exports = factory();
    else { var i, a; }
})(self, function() {
    return /******/ function() {
        /******/ var __webpack_modules__ = {
            /***/ 8151: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_12718__) {
                "use strict";
                /**
 * The main class required to set up an Ace instance in the browser.
 *
 * @class Ace
 **/ "include loader_build";
                var dom = __nested_webpack_require_12718__(5336);
                var Range = __nested_webpack_require_12718__(3069)/* .Range */ .e;
                var Editor = __nested_webpack_require_12718__(7180)/* .Editor */ .M;
                var EditSession = __nested_webpack_require_12718__(8827)/* .EditSession */ .m;
                var UndoManager = __nested_webpack_require_12718__(1966)/* .UndoManager */ .H;
                var Renderer = __nested_webpack_require_12718__(8390)/* .VirtualRenderer */ ._;
                // The following require()s are for inclusion in the built ace file
                __nested_webpack_require_12718__(1583);
                __nested_webpack_require_12718__(4739);
                __nested_webpack_require_12718__(8916);
                __nested_webpack_require_12718__(5403);
                __nested_webpack_require_12718__(9372);
                __nested_webpack_require_12718__(9609);
                __nested_webpack_require_12718__(585);
                exports1.config = __nested_webpack_require_12718__(3294);
                /**
 * Embeds the Ace editor into the DOM, at the element provided by `el`.
 * @param {String | Element} el Either the id of an element, or the element itself
 * @param {Object } options Options for the editor
 *
 **/ exports1.edit = function(el, options) {
                    if (typeof el == "string") {
                        var _id = el;
                        el = document.getElementById(_id);
                        if (!el) throw new Error("ace.edit can't find div #" + _id);
                    }
                    if (el && el.env && _instanceof(el.env.editor, Editor)) return el.env.editor;
                    var value = "";
                    if (el && /input|textarea/i.test(el.tagName)) {
                        var oldNode = el;
                        value = oldNode.value;
                        el = dom.createElement("pre");
                        oldNode.parentNode.replaceChild(el, oldNode);
                    } else if (el) {
                        value = el.textContent;
                        el.innerHTML = "";
                    }
                    var doc = exports1.createEditSession(value);
                    var editor = new Editor(new Renderer(el), doc, options);
                    var env = {
                        document: doc,
                        editor: editor,
                        onResize: editor.resize.bind(editor, null)
                    };
                    if (oldNode) env.textarea = oldNode;
                    editor.on("destroy", function() {
                        env.editor.container.env = null; // prevent memory leak on old ie
                    });
                    editor.container.env = editor.env = env;
                    return editor;
                };
                /**
 * Creates a new [[EditSession]], and returns the associated [[Document]].
 * @param {Document | String} text {:textParam}
 * @param {TextMode} mode {:modeParam}
 *
 **/ exports1.createEditSession = function(text, mode) {
                    var doc = new EditSession(text, mode);
                    doc.setUndoManager(new UndoManager());
                    return doc;
                };
                exports1.Range = Range;
                exports1.Editor = Editor;
                exports1.EditSession = EditSession;
                exports1.UndoManager = UndoManager;
                exports1.VirtualRenderer = Renderer;
                exports1.version = exports1.config.version;
            /***/ },
            /***/ 8558: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_16374__) {
                "use strict";
                var $pointsInOrder = function $pointsInOrder(point1, point2, equalPointsInOrder) {
                    var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
                    return point1.row < point2.row || point1.row == point2.row && bColIsAfter;
                };
                var $getTransformedPoint = function $getTransformedPoint(delta, point, moveIfEqual) {
                    // Get delta info.
                    var deltaIsInsert = delta.action == "insert";
                    var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);
                    var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
                    var deltaStart = delta.start;
                    var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.
                    // DELTA AFTER POINT: No change needed.
                    if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
                        return {
                            row: point.row,
                            column: point.column
                        };
                    }
                    // DELTA BEFORE POINT: Move point by delta shift.
                    if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
                        return {
                            row: point.row + deltaRowShift,
                            column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
                        };
                    }
                    // DELTA ENVELOPS POINT (delete only): Move point to delta start.
                    // TODO warn if delta.action != "remove" ?
                    return {
                        row: deltaStart.row,
                        column: deltaStart.column
                    };
                };
                var oop = __nested_webpack_require_16374__(2011);
                var EventEmitter = __nested_webpack_require_16374__(7858)/* .EventEmitter */ .v;
                /**
 * Defines a floating pointer in the document. Whenever text is inserted or deleted before the cursor, the position of the anchor is updated.
 **/ var Anchor = /*#__PURE__*/ function() {
                    function Anchor(doc, row, column) {
                        _class_call_check(this, Anchor);
                        this.$onChange = this.onChange.bind(this);
                        this.attach(doc);
                        if (typeof column == "undefined") this.setPosition(row.row, row.column);
                        else this.setPosition(row, column);
                    }
                    _create_class(Anchor, [
                        {
                            /**
     * Returns an object identifying the `row` and `column` position of the current anchor.
     * @returns {Ace.Point}
     **/ key: "getPosition",
                            value: function getPosition() {
                                return this.$clipPositionToDocument(this.row, this.column);
                            }
                        },
                        {
                            /**
     *
     * Returns the current document.
     * @returns {Document}
     **/ key: "getDocument",
                            value: function getDocument() {
                                return this.document;
                            }
                        },
                        {
                            /**
     * Fires whenever the anchor position changes.
     *
     * Both of these objects have a `row` and `column` property corresponding to the position.
     *
     * Events that can trigger this function include [[Anchor.setPosition `setPosition()`]].
     *
     * @event change
     * @param {Object} e  An object containing information about the anchor position. It has two properties:
     *  - `old`: An object describing the old Anchor position
     *  - `value`: An object describing the new Anchor position
     *
     **/ /**
     * Internal function called when `"change"` event fired.
     * @param {Ace.Delta} delta
     */ key: "onChange",
                            value: function onChange(delta) {
                                if (delta.start.row == delta.end.row && delta.start.row != this.row) return;
                                if (delta.start.row > this.row) return;
                                var point = $getTransformedPoint(delta, {
                                    row: this.row,
                                    column: this.column
                                }, this.$insertRight);
                                this.setPosition(point.row, point.column, true);
                            }
                        },
                        {
                            /**
     * Sets the anchor position to the specified row and column. If `noClip` is `true`, the position is not clipped.
     * @param {Number} row The row index to move the anchor to
     * @param {Number} column The column index to move the anchor to
     * @param {Boolean} noClip Identifies if you want the position to be clipped
     *
     **/ key: "setPosition",
                            value: function setPosition(row, column, noClip) {
                                var pos;
                                if (noClip) {
                                    pos = {
                                        row: row,
                                        column: column
                                    };
                                } else {
                                    pos = this.$clipPositionToDocument(row, column);
                                }
                                if (this.row == pos.row && this.column == pos.column) return;
                                var old = {
                                    row: this.row,
                                    column: this.column
                                };
                                this.row = pos.row;
                                this.column = pos.column;
                                this._signal("change", {
                                    old: old,
                                    value: pos
                                });
                            }
                        },
                        {
                            /**
     * When called, the `"change"` event listener is removed.
     *
     **/ key: "detach",
                            value: function detach() {
                                this.document.off("change", this.$onChange);
                            }
                        },
                        {
                            /**
     * When called, the `"change"` event listener is appended.
     * @param {Document} doc The document to associate with
     *
     **/ key: "attach",
                            value: function attach(doc) {
                                this.document = doc || this.document;
                                this.document.on("change", this.$onChange);
                            }
                        },
                        {
                            /**
     * Clips the anchor position to the specified row and column.
     * @param {Number} row The row index to clip the anchor to
     * @param {Number} column The column index to clip the anchor to
     * @returns {Ace.Point}
     *
     **/ key: "$clipPositionToDocument",
                            value: function $clipPositionToDocument(row, column) {
                                var pos = {};
                                if (row >= this.document.getLength()) {
                                    pos.row = Math.max(0, this.document.getLength() - 1);
                                    pos.column = this.document.getLine(pos.row).length;
                                } else if (row < 0) {
                                    pos.row = 0;
                                    pos.column = 0;
                                } else {
                                    pos.row = row;
                                    pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
                                }
                                if (column < 0) pos.column = 0;
                                return pos;
                            }
                        }
                    ]);
                    return Anchor;
                }();
                /**
 * experimental: allows anchor to stick to the next on the left
 */ Anchor.prototype.$insertRight = false;
                oop.implement(Anchor.prototype, EventEmitter);
                exports1.e = Anchor;
            /***/ },
            /***/ 4096: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_25263__) {
                "use strict";
                var throwDeltaError = function throwDeltaError(delta, errorText) {
                    console.log("Invalid Delta:", delta);
                    throw "Invalid Delta: " + errorText;
                };
                var positionInDocument = function positionInDocument(docLines, position) {
                    return position.row >= 0 && position.row < docLines.length && position.column >= 0 && position.column <= docLines[position.row].length;
                };
                var validateDelta = function validateDelta(docLines, delta) {
                    // Validate action string.
                    if (delta.action != "insert" && delta.action != "remove") throwDeltaError(delta, "delta.action must be 'insert' or 'remove'");
                    // Validate lines type.
                    if (!_instanceof(delta.lines, Array)) throwDeltaError(delta, "delta.lines must be an Array");
                    // Validate range type.
                    if (!delta.start || !delta.end) throwDeltaError(delta, "delta.start/end must be an present");
                    // Validate that the start point is contained in the document.
                    var start = delta.start;
                    if (!positionInDocument(docLines, delta.start)) throwDeltaError(delta, "delta.start must be contained in document");
                    // Validate that the end point is contained in the document (remove deltas only).
                    var end = delta.end;
                    if (delta.action == "remove" && !positionInDocument(docLines, end)) throwDeltaError(delta, "delta.end must contained in document for 'remove' actions");
                    // Validate that the .range size matches the .lines size.
                    var numRangeRows = end.row - start.row;
                    var numRangeLastLineChars = end.column - (numRangeRows == 0 ? start.column : 0);
                    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars) throwDeltaError(delta, "delta.range must match delta lines");
                };
                /* provided dependency */ var console = __nested_webpack_require_25263__(3716);
                exports1.B = function(docLines, delta, doNotValidate) {
                    // disabled validation since it breaks autocompletion popup
                    // if (!doNotValidate)
                    //    validateDelta(docLines, delta);
                    var row = delta.start.row;
                    var startColumn = delta.start.column;
                    var line = docLines[row] || "";
                    switch(delta.action){
                        case "insert":
                            var lines = delta.lines;
                            if (lines.length === 1) {
                                docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
                            } else {
                                var args = [
                                    row,
                                    1
                                ].concat(delta.lines);
                                docLines.splice.apply(docLines, args);
                                docLines[row] = line.substring(0, startColumn) + docLines[row];
                                docLines[row + delta.lines.length - 1] += line.substring(startColumn);
                            }
                            break;
                        case "remove":
                            var endColumn = delta.end.column;
                            var endRow = delta.end.row;
                            if (row === endRow) {
                                docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
                            } else {
                                docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));
                            }
                            break;
                    }
                };
            /***/ },
            /***/ 3486: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_29469__) {
                "use strict";
                var oop = __nested_webpack_require_29469__(2011);
                var EventEmitter = __nested_webpack_require_29469__(7858)/* .EventEmitter */ .v;
                /**
 * Tokenizes the current [[Document `Document`]] in the background, and caches the tokenized rows for future use. 
 * 
 * If a certain row is changed, everything below that row is re-tokenized.
 **/ var BackgroundTokenizer = /*#__PURE__*/ function() {
                    function BackgroundTokenizer(tokenizer, editor) {
                        _class_call_check(this, BackgroundTokenizer);
                        this.running = false;
                        this.lines = [];
                        this.states = [];
                        this.currentLine = 0;
                        this.tokenizer = tokenizer;
                        var _$self = this;
                        this.$worker = function() {
                            if (!_$self.running) {
                                return;
                            }
                            var workerStart = new Date();
                            var currentLine = _$self.currentLine;
                            var endLine = -1;
                            var doc = _$self.doc;
                            var startLine = currentLine;
                            while(_$self.lines[currentLine])currentLine++;
                            var len = doc.getLength();
                            var processedLines = 0;
                            _$self.running = false;
                            while(currentLine < len){
                                _$self.$tokenizeRow(currentLine);
                                endLine = currentLine;
                                do {
                                    currentLine++;
                                }while (_$self.lines[currentLine]);
                                // only check every 5 lines
                                processedLines++;
                                if (processedLines % 5 === 0 && new Date() - workerStart > 20) {
                                    _$self.running = setTimeout(_$self.$worker, 20);
                                    break;
                                }
                            }
                            _$self.currentLine = currentLine;
                            if (endLine == -1) endLine = currentLine;
                            if (startLine <= endLine) _$self.fireUpdateEvent(startLine, endLine);
                        };
                    }
                    _create_class(BackgroundTokenizer, [
                        {
                            /**
     * Sets a new tokenizer for this object.
     * @param {Tokenizer} tokenizer The new tokenizer to use
     **/ key: "setTokenizer",
                            value: function setTokenizer(tokenizer) {
                                this.tokenizer = tokenizer;
                                this.lines = [];
                                this.states = [];
                                this.start(0);
                            }
                        },
                        {
                            /**
     * Sets a new document to associate with this object.
     * @param {Document} doc The new document to associate with
     **/ key: "setDocument",
                            value: function setDocument(doc) {
                                this.doc = doc;
                                this.lines = [];
                                this.states = [];
                                this.stop();
                            }
                        },
                        {
                            /**
     * Fires whenever the background tokeniziers between a range of rows are going to be updated.
     * 
     * @event update
     * @param {Object} e An object containing two properties, `first` and `last`, which indicate the rows of the region being updated.
     *
     **/ /**
     * Emits the `'update'` event. `firstRow` and `lastRow` are used to define the boundaries of the region to be updated.
     * @param {Number} firstRow The starting row region
     * @param {Number} lastRow The final row region
     **/ key: "fireUpdateEvent",
                            value: function fireUpdateEvent(firstRow, lastRow) {
                                var data = {
                                    first: firstRow,
                                    last: lastRow
                                };
                                this._signal("update", {
                                    data: data
                                });
                            }
                        },
                        {
                            /**
     * Starts tokenizing at the row indicated.
     * @param {Number} startRow The row to start at
     **/ key: "start",
                            value: function start(startRow) {
                                this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
                                // remove all cached items below this line
                                this.lines.splice(this.currentLine, this.lines.length);
                                this.states.splice(this.currentLine, this.states.length);
                                this.stop();
                                // pretty long delay to prevent the tokenizer from interfering with the user
                                this.running = setTimeout(this.$worker, 700);
                            }
                        },
                        {
                            /**
     * Sets pretty long delay to prevent the tokenizer from interfering with the user
     */ key: "scheduleStart",
                            value: function scheduleStart() {
                                if (!this.running) this.running = setTimeout(this.$worker, 700);
                            }
                        },
                        {
                            key: "$updateOnChange",
                            value: function $updateOnChange(delta) {
                                var startRow = delta.start.row;
                                var len = delta.end.row - startRow;
                                if (len === 0) {
                                    this.lines[startRow] = null;
                                } else if (delta.action == "remove") {
                                    this.lines.splice(startRow, len + 1, null);
                                    this.states.splice(startRow, len + 1, null);
                                } else {
                                    var args = Array(len + 1);
                                    args.unshift(startRow, 1);
                                    this.lines.splice.apply(this.lines, args);
                                    this.states.splice.apply(this.states, args);
                                }
                                this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());
                                this.stop();
                            }
                        },
                        {
                            /**
     * Stops tokenizing.
     **/ key: "stop",
                            value: function stop() {
                                if (this.running) clearTimeout(this.running);
                                this.running = false;
                            }
                        },
                        {
                            /**
     * Gives list of [[Token]]'s of the row. (tokens are cached)
     * @param {Number} row The row to get tokens at
     * @returns {Token[]}
     **/ key: "getTokens",
                            value: function getTokens(row) {
                                return this.lines[row] || this.$tokenizeRow(row);
                            }
                        },
                        {
                            /**
     * Returns the state of tokenization at the end of a row.
     * @param {Number} row The row to get state at
     * @returns {string}
     **/ key: "getState",
                            value: function getState(row) {
                                if (this.currentLine == row) this.$tokenizeRow(row);
                                return this.states[row] || "start";
                            }
                        },
                        {
                            key: "$tokenizeRow",
                            value: function $tokenizeRow(row) {
                                var line = this.doc.getLine(row);
                                var state = this.states[row - 1];
                                var data = this.tokenizer.getLineTokens(line, state, row);
                                if (this.states[row] + "" !== data.state + "") {
                                    this.states[row] = data.state;
                                    this.lines[row + 1] = null;
                                    if (this.currentLine > row + 1) this.currentLine = row + 1;
                                } else if (this.currentLine == row) {
                                    this.currentLine = row + 1;
                                }
                                return this.lines[row] = data.tokens;
                            }
                        },
                        {
                            key: "cleanup",
                            value: function cleanup() {
                                this.running = false;
                                this.lines = [];
                                this.states = [];
                                this.currentLine = 0;
                                this.removeAllListeners();
                            }
                        }
                    ]);
                    return BackgroundTokenizer;
                }();
                oop.implement(BackgroundTokenizer.prototype, EventEmitter);
                exports1.V = BackgroundTokenizer;
            /***/ },
            /***/ 9457: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_39687__) {
                "use strict";
                var bidiUtil = __nested_webpack_require_39687__(7199);
                var lang = __nested_webpack_require_39687__(732);
                var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\u202B]/;
                /**
 * This object is used to ensure Bi-Directional support (for languages with text flowing from right to left, like Arabic or Hebrew)
 * including correct caret positioning, text selection mouse and keyboard arrows functioning
 **/ var BidiHandler = /*#__PURE__*/ function() {
                    function BidiHandler(session) {
                        _class_call_check(this, BidiHandler);
                        this.session = session;
                        this.bidiMap = {};
                        /* current screen row */ this.currentRow = null;
                        this.bidiUtil = bidiUtil;
                        /* Arabic/Hebrew character width differs from regular character width */ this.charWidths = [];
                        this.EOL = "\xac";
                        this.showInvisibles = true;
                        this.isRtlDir = false;
                        this.$isRtl = false;
                        this.line = "";
                        this.wrapIndent = 0;
                        this.EOF = "\xb6";
                        this.RLE = "‫";
                        this.contentWidth = 0;
                        this.fontMetrics = null;
                        this.rtlLineOffset = 0;
                        this.wrapOffset = 0;
                        this.isMoveLeftOperation = false;
                        this.seenBidi = bidiRE.test(session.getValue());
                    }
                    _create_class(BidiHandler, [
                        {
                            /**
     * Returns 'true' if row contains Bidi characters, in such case
     * creates Bidi map to be used in operations related to selection
     * (keyboard arrays, mouse click, select)
     * @param {Number} screenRow the screen row to be checked
     * @param {Number} docRow the document row to be checked [optional]
     * @param {Number} splitIndex the wrapped screen line index [ optional]
    **/ key: "isBidiRow",
                            value: function isBidiRow(screenRow, docRow, splitIndex) {
                                if (!this.seenBidi) return false;
                                if (screenRow !== this.currentRow) {
                                    this.currentRow = screenRow;
                                    this.updateRowLine(docRow, splitIndex);
                                    this.updateBidiMap();
                                }
                                return this.bidiMap.bidiLevels;
                            }
                        },
                        {
                            key: "onChange",
                            value: function onChange(delta) {
                                if (!this.seenBidi) {
                                    if (delta.action == "insert" && bidiRE.test(delta.lines.join("\n"))) {
                                        this.seenBidi = true;
                                        this.currentRow = null;
                                    }
                                } else {
                                    this.currentRow = null;
                                }
                            }
                        },
                        {
                            key: "getDocumentRow",
                            value: function getDocumentRow() {
                                var docRow = 0;
                                var rowCache = this.session.$screenRowCache;
                                if (rowCache.length) {
                                    var index = this.session.$getRowCacheIndex(rowCache, this.currentRow);
                                    if (index >= 0) docRow = this.session.$docRowCache[index];
                                }
                                return docRow;
                            }
                        },
                        {
                            key: "getSplitIndex",
                            value: function getSplitIndex() {
                                var splitIndex = 0;
                                var rowCache = this.session.$screenRowCache;
                                if (rowCache.length) {
                                    var currentIndex, prevIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow);
                                    while(this.currentRow - splitIndex > 0){
                                        currentIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow - splitIndex - 1);
                                        if (currentIndex !== prevIndex) break;
                                        prevIndex = currentIndex;
                                        splitIndex++;
                                    }
                                } else {
                                    splitIndex = this.currentRow;
                                }
                                return splitIndex;
                            }
                        },
                        {
                            key: "updateRowLine",
                            value: function updateRowLine(docRow, splitIndex) {
                                if (docRow === undefined) docRow = this.getDocumentRow();
                                var isLastRow = docRow === this.session.getLength() - 1, endOfLine = isLastRow ? this.EOF : this.EOL;
                                this.wrapIndent = 0;
                                this.line = this.session.getLine(docRow);
                                this.isRtlDir = this.$isRtl || this.line.charAt(0) === this.RLE;
                                if (this.session.$useWrapMode) {
                                    var splits = this.session.$wrapData[docRow];
                                    if (splits) {
                                        if (splitIndex === undefined) splitIndex = this.getSplitIndex();
                                        if (splitIndex > 0 && splits.length) {
                                            this.wrapIndent = splits.indent;
                                            this.wrapOffset = this.wrapIndent * this.charWidths[bidiUtil.L];
                                            this.line = splitIndex < splits.length ? this.line.substring(splits[splitIndex - 1], splits[splitIndex]) : this.line.substring(splits[splits.length - 1]);
                                        } else {
                                            this.line = this.line.substring(0, splits[splitIndex]);
                                        }
                                        if (splitIndex == splits.length) {
                                            this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;
                                        }
                                    }
                                } else {
                                    this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;
                                }
                                /* replace tab and wide characters by commensurate spaces */ var session = this.session, shift = 0, size;
                                this.line = this.line.replace(/\t|[\u1100-\u2029, \u202F-\uFFE6]/g, function(ch, i) {
                                    if (ch === "	" || session.isFullWidth(ch.charCodeAt(0))) {
                                        size = ch === "	" ? session.getScreenTabSize(i + shift) : 2;
                                        shift += size - 1;
                                        return lang.stringRepeat(bidiUtil.DOT, size);
                                    }
                                    return ch;
                                });
                                if (this.isRtlDir) {
                                    this.fontMetrics.$main.textContent = this.line.charAt(this.line.length - 1) == bidiUtil.DOT ? this.line.substr(0, this.line.length - 1) : this.line;
                                    this.rtlLineOffset = this.contentWidth - this.fontMetrics.$main.getBoundingClientRect().width;
                                }
                            }
                        },
                        {
                            key: "updateBidiMap",
                            value: function updateBidiMap() {
                                var textCharTypes = [];
                                if (bidiUtil.hasBidiCharacters(this.line, textCharTypes) || this.isRtlDir) {
                                    this.bidiMap = bidiUtil.doBidiReorder(this.line, textCharTypes, this.isRtlDir);
                                } else {
                                    this.bidiMap = {};
                                }
                            }
                        },
                        {
                            /**
     * Resets stored info related to current screen row
    **/ key: "markAsDirty",
                            value: function markAsDirty() {
                                this.currentRow = null;
                            }
                        },
                        {
                            /**
     * Updates array of character widths
     * @param {Object} fontMetrics metrics
     *
    **/ key: "updateCharacterWidths",
                            value: function updateCharacterWidths(fontMetrics) {
                                if (this.characterWidth === fontMetrics.$characterSize.width) return;
                                this.fontMetrics = fontMetrics;
                                var characterWidth = this.characterWidth = fontMetrics.$characterSize.width;
                                var bidiCharWidth = fontMetrics.$measureCharWidth("ה");
                                this.charWidths[bidiUtil.L] = this.charWidths[bidiUtil.EN] = this.charWidths[bidiUtil.ON_R] = characterWidth;
                                this.charWidths[bidiUtil.R] = this.charWidths[bidiUtil.AN] = bidiCharWidth;
                                this.charWidths[bidiUtil.R_H] = bidiCharWidth * 0.45;
                                this.charWidths[bidiUtil.B] = this.charWidths[bidiUtil.RLE] = 0;
                                this.currentRow = null;
                            }
                        },
                        {
                            key: "setShowInvisibles",
                            value: function setShowInvisibles(showInvisibles) {
                                this.showInvisibles = showInvisibles;
                                this.currentRow = null;
                            }
                        },
                        {
                            key: "setEolChar",
                            value: function setEolChar(eolChar) {
                                this.EOL = eolChar;
                            }
                        },
                        {
                            key: "setContentWidth",
                            value: function setContentWidth(width) {
                                this.contentWidth = width;
                            }
                        },
                        {
                            key: "isRtlLine",
                            value: function isRtlLine(row) {
                                if (this.$isRtl) return true;
                                if (row != undefined) return this.session.getLine(row).charAt(0) == this.RLE;
                                else return this.isRtlDir;
                            }
                        },
                        {
                            key: "setRtlDirection",
                            value: function setRtlDirection(editor, isRtlDir) {
                                var cursor = editor.getCursorPosition();
                                for(var row = editor.selection.getSelectionAnchor().row; row <= cursor.row; row++){
                                    if (!isRtlDir && editor.session.getLine(row).charAt(0) === editor.session.$bidiHandler.RLE) editor.session.doc.removeInLine(row, 0, 1);
                                    else if (isRtlDir && editor.session.getLine(row).charAt(0) !== editor.session.$bidiHandler.RLE) editor.session.doc.insert({
                                        column: 0,
                                        row: row
                                    }, editor.session.$bidiHandler.RLE);
                                }
                            }
                        },
                        {
                            /**
     * Returns offset of character at position defined by column.
     * @param {Number} col the screen column position
     *
     * @return {Number} horizontal pixel offset of given screen column
     **/ key: "getPosLeft",
                            value: function getPosLeft(col) {
                                col -= this.wrapIndent;
                                var leftBoundary = this.line.charAt(0) === this.RLE ? 1 : 0;
                                var logicalIdx = col > leftBoundary ? this.session.getOverwrite() ? col : col - 1 : leftBoundary;
                                var visualIdx = bidiUtil.getVisualFromLogicalIdx(logicalIdx, this.bidiMap), levels = this.bidiMap.bidiLevels, left = 0;
                                if (!this.session.getOverwrite() && col <= leftBoundary && levels[visualIdx] % 2 !== 0) visualIdx++;
                                for(var i = 0; i < visualIdx; i++){
                                    left += this.charWidths[levels[i]];
                                }
                                if (!this.session.getOverwrite() && col > leftBoundary && levels[visualIdx] % 2 === 0) left += this.charWidths[levels[visualIdx]];
                                if (this.wrapIndent) left += this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset;
                                if (this.isRtlDir) left += this.rtlLineOffset;
                                return left;
                            }
                        },
                        {
                            /**
     * Returns 'selections' - array of objects defining set of selection rectangles
     * @param {Number} startCol the start column position
     * @param {Number} endCol the end column position
     *
     * @return {Object[]} Each object contains 'left' and 'width' values defining selection rectangle.
    **/ key: "getSelections",
                            value: function getSelections(startCol, endCol) {
                                var map = this.bidiMap, levels = map.bidiLevels, level, selections = [], offset = 0, selColMin = Math.min(startCol, endCol) - this.wrapIndent, selColMax = Math.max(startCol, endCol) - this.wrapIndent, isSelected = false, isSelectedPrev = false, selectionStart = 0;
                                if (this.wrapIndent) offset += this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset;
                                for(var logIdx, visIdx = 0; visIdx < levels.length; visIdx++){
                                    logIdx = map.logicalFromVisual[visIdx];
                                    level = levels[visIdx];
                                    isSelected = logIdx >= selColMin && logIdx < selColMax;
                                    if (isSelected && !isSelectedPrev) {
                                        selectionStart = offset;
                                    } else if (!isSelected && isSelectedPrev) {
                                        selections.push({
                                            left: selectionStart,
                                            width: offset - selectionStart
                                        });
                                    }
                                    offset += this.charWidths[level];
                                    isSelectedPrev = isSelected;
                                }
                                if (isSelected && visIdx === levels.length) {
                                    selections.push({
                                        left: selectionStart,
                                        width: offset - selectionStart
                                    });
                                }
                                if (this.isRtlDir) {
                                    for(var i = 0; i < selections.length; i++){
                                        selections[i].left += this.rtlLineOffset;
                                    }
                                }
                                return selections;
                            }
                        },
                        {
                            /**
     * Converts character coordinates on the screen to respective document column number
     * @param {Number} posX character horizontal offset
     *
     * @return {Number} screen column number corresponding to given pixel offset
    **/ key: "offsetToCol",
                            value: function offsetToCol(posX) {
                                if (this.isRtlDir) posX -= this.rtlLineOffset;
                                var logicalIdx = 0, posX = Math.max(posX, 0), offset = 0, visualIdx = 0, levels = this.bidiMap.bidiLevels, charWidth = this.charWidths[levels[visualIdx]];
                                if (this.wrapIndent) posX -= this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset;
                                while(posX > offset + charWidth / 2){
                                    offset += charWidth;
                                    if (visualIdx === levels.length - 1) {
                                        /* quit when we on the right of the last character, flag this by charWidth = 0 */ charWidth = 0;
                                        break;
                                    }
                                    charWidth = this.charWidths[levels[++visualIdx]];
                                }
                                if (visualIdx > 0 && levels[visualIdx - 1] % 2 !== 0 && levels[visualIdx] % 2 === 0) {
                                    /* Bidi character on the left and None Bidi character on the right */ if (posX < offset) visualIdx--;
                                    logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
                                } else if (visualIdx > 0 && levels[visualIdx - 1] % 2 === 0 && levels[visualIdx] % 2 !== 0) {
                                    /* None Bidi character on the left and Bidi character on the right */ logicalIdx = 1 + (posX > offset ? this.bidiMap.logicalFromVisual[visualIdx] : this.bidiMap.logicalFromVisual[visualIdx - 1]);
                                } else if (this.isRtlDir && visualIdx === levels.length - 1 && charWidth === 0 && levels[visualIdx - 1] % 2 === 0 || !this.isRtlDir && visualIdx === 0 && levels[visualIdx] % 2 !== 0) {
                                    /* To the right of last character, which is None Bidi, in RTL direction or */ /* to the left of first Bidi character, in LTR direction */ logicalIdx = 1 + this.bidiMap.logicalFromVisual[visualIdx];
                                } else {
                                    /* Tweak visual position when Bidi character on the left in order to map it to corresponding logical position */ if (visualIdx > 0 && levels[visualIdx - 1] % 2 !== 0 && charWidth !== 0) visualIdx--;
                                    /* Regular case */ logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
                                }
                                if (logicalIdx === 0 && this.isRtlDir) logicalIdx++;
                                return logicalIdx + this.wrapIndent;
                            }
                        }
                    ]);
                    return BidiHandler;
                }();
                exports1.l = BidiHandler;
            /***/ },
            /***/ 6514: /***/ function(module1) {
                "use strict";
                var $cancelT;
                module1.exports = {
                    lineMode: false,
                    pasteCancelled: function pasteCancelled() {
                        if ($cancelT && $cancelT > Date.now() - 50) return true;
                        return $cancelT = false;
                    },
                    cancel: function cancel() {
                        $cancelT = Date.now();
                    }
                };
            /***/ },
            /***/ 4278: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_60446__) {
                "use strict";
                var oop = __nested_webpack_require_60446__(2011);
                var MultiHashHandler = __nested_webpack_require_60446__(4739).MultiHashHandler;
                var EventEmitter = __nested_webpack_require_60446__(7858)/* .EventEmitter */ .v;
                var CommandManager = /*#__PURE__*/ function(MultiHashHandler) {
                    _inherits(CommandManager, MultiHashHandler);
                    var _super = _create_super(CommandManager);
                    function CommandManager(platform, commands) {
                        _class_call_check(this, CommandManager);
                        var _this;
                        _this = _super.call(this, commands, platform);
                        _this.byName = _this.commands;
                        _this.setDefaultHandler("exec", function(e) {
                            if (!e.args) {
                                return e.command.exec(e.editor, {}, e.event, true);
                            }
                            return e.command.exec(e.editor, e.args, e.event, false);
                        });
                        return _this;
                    }
                    _create_class(CommandManager, [
                        {
                            key: "exec",
                            value: function exec(command, editor, args) {
                                if (Array.isArray(command)) {
                                    for(var i = command.length; i--;){
                                        if (this.exec(command[i], editor, args)) return true;
                                    }
                                    return false;
                                }
                                if (typeof command === "string") command = this.commands[command];
                                if (!command) return false;
                                if (editor && editor.$readOnly && !command.readOnly) return false;
                                if (this.$checkCommandState != false && command.isAvailable && !command.isAvailable(editor)) return false;
                                var e = {
                                    editor: editor,
                                    command: command,
                                    args: args
                                };
                                e.returnValue = this._emit("exec", e);
                                this._signal("afterExec", e);
                                return e.returnValue === false ? false : true;
                            }
                        },
                        {
                            key: "toggleRecording",
                            value: function toggleRecording(editor) {
                                if (this.$inReplay) return;
                                editor && editor._emit("changeStatus");
                                if (this.recording) {
                                    this.macro.pop();
                                    this.off("exec", this.$addCommandToMacro);
                                    if (!this.macro.length) this.macro = this.oldMacro;
                                    return this.recording = false;
                                }
                                if (!this.$addCommandToMacro) {
                                    this.$addCommandToMacro = (function(e) {
                                        this.macro.push([
                                            e.command,
                                            e.args
                                        ]);
                                    }).bind(this);
                                }
                                this.oldMacro = this.macro;
                                this.macro = [];
                                this.on("exec", this.$addCommandToMacro);
                                return this.recording = true;
                            }
                        },
                        {
                            key: "replay",
                            value: function replay(editor) {
                                if (this.$inReplay || !this.macro) return;
                                if (this.recording) return this.toggleRecording(editor);
                                try {
                                    this.$inReplay = true;
                                    this.macro.forEach(function(x) {
                                        if (typeof x == "string") this.exec(x, editor);
                                        else this.exec(x[0], editor, x[1]);
                                    }, this);
                                } finally{
                                    this.$inReplay = false;
                                }
                            }
                        },
                        {
                            key: "trimMacro",
                            value: function trimMacro(m) {
                                return m.map(function(x) {
                                    if (typeof x[0] != "string") x[0] = x[0].name;
                                    if (!x[1]) x = x[0];
                                    return x;
                                });
                            }
                        }
                    ]);
                    return CommandManager;
                }(MultiHashHandler);
                oop.implement(CommandManager.prototype, EventEmitter);
                exports1.f = CommandManager;
            /***/ },
            /***/ 4922: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_66097__) {
                "use strict";
                var bindKey = function bindKey(win, mac) {
                    return {
                        win: win,
                        mac: mac
                    };
                };
                var lang = __nested_webpack_require_66097__(732);
                var config = __nested_webpack_require_66097__(3294);
                var Range = __nested_webpack_require_66097__(3069)/* .Range */ .e;
                /*
    multiSelectAction: "forEach"|"forEachLine"|function|undefined,
    scrollIntoView: true|"cursor"|"center"|"selectionPart"
*/ exports1.C = [
                    {
                        name: "showSettingsMenu",
                        description: "Show settings menu",
                        bindKey: bindKey("Ctrl-,", "Command-,"),
                        exec: function exec(editor) {
                            config.loadModule("ace/ext/settings_menu", function(module1) {
                                module1.init(editor);
                                editor.showSettingsMenu();
                            });
                        },
                        readOnly: true
                    },
                    {
                        name: "goToNextError",
                        description: "Go to next error",
                        bindKey: bindKey("Alt-E", "F4"),
                        exec: function exec(editor) {
                            config.loadModule("ace/ext/error_marker", function(module1) {
                                module1.showErrorMarker(editor, 1);
                            });
                        },
                        scrollIntoView: "animate",
                        readOnly: true
                    },
                    {
                        name: "goToPreviousError",
                        description: "Go to previous error",
                        bindKey: bindKey("Alt-Shift-E", "Shift-F4"),
                        exec: function exec(editor) {
                            config.loadModule("ace/ext/error_marker", function(module1) {
                                module1.showErrorMarker(editor, -1);
                            });
                        },
                        scrollIntoView: "animate",
                        readOnly: true
                    },
                    {
                        name: "selectall",
                        description: "Select all",
                        bindKey: bindKey("Ctrl-A", "Command-A"),
                        exec: function exec(editor) {
                            editor.selectAll();
                        },
                        readOnly: true
                    },
                    {
                        name: "centerselection",
                        description: "Center selection",
                        bindKey: bindKey(null, "Ctrl-L"),
                        exec: function exec(editor) {
                            editor.centerSelection();
                        },
                        readOnly: true
                    },
                    {
                        name: "gotoline",
                        description: "Go to line...",
                        bindKey: bindKey("Ctrl-L", "Command-L"),
                        exec: function exec(editor, line) {
                            // backwards compatibility
                            if (typeof line === "number" && !isNaN(line)) editor.gotoLine(line);
                            editor.prompt({
                                $type: "gotoLine"
                            });
                        },
                        readOnly: true
                    },
                    {
                        name: "fold",
                        bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
                        exec: function exec(editor) {
                            editor.session.toggleFold(false);
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "center",
                        readOnly: true
                    },
                    {
                        name: "unfold",
                        bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
                        exec: function exec(editor) {
                            editor.session.toggleFold(true);
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "center",
                        readOnly: true
                    },
                    {
                        name: "toggleFoldWidget",
                        description: "Toggle fold widget",
                        bindKey: bindKey("F2", "F2"),
                        exec: function exec(editor) {
                            editor.session.toggleFoldWidget();
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "center",
                        readOnly: true
                    },
                    {
                        name: "toggleParentFoldWidget",
                        description: "Toggle parent fold widget",
                        bindKey: bindKey("Alt-F2", "Alt-F2"),
                        exec: function exec(editor) {
                            editor.session.toggleFoldWidget(true);
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "center",
                        readOnly: true
                    },
                    {
                        name: "foldall",
                        description: "Fold all",
                        bindKey: bindKey(null, "Ctrl-Command-Option-0"),
                        exec: function exec(editor) {
                            editor.session.foldAll();
                        },
                        scrollIntoView: "center",
                        readOnly: true
                    },
                    {
                        name: "foldAllComments",
                        description: "Fold all comments",
                        bindKey: bindKey(null, "Ctrl-Command-Option-0"),
                        exec: function exec(editor) {
                            editor.session.foldAllComments();
                        },
                        scrollIntoView: "center",
                        readOnly: true
                    },
                    {
                        name: "foldOther",
                        description: "Fold other",
                        bindKey: bindKey("Alt-0", "Command-Option-0"),
                        exec: function exec(editor) {
                            editor.session.foldAll();
                            editor.session.unfold(editor.selection.getAllRanges());
                        },
                        scrollIntoView: "center",
                        readOnly: true
                    },
                    {
                        name: "unfoldall",
                        description: "Unfold all",
                        bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
                        exec: function exec(editor) {
                            editor.session.unfold();
                        },
                        scrollIntoView: "center",
                        readOnly: true
                    },
                    {
                        name: "findnext",
                        description: "Find next",
                        bindKey: bindKey("Ctrl-K", "Command-G"),
                        exec: function exec(editor) {
                            editor.findNext();
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "center",
                        readOnly: true
                    },
                    {
                        name: "findprevious",
                        description: "Find previous",
                        bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
                        exec: function exec(editor) {
                            editor.findPrevious();
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "center",
                        readOnly: true
                    },
                    {
                        name: "selectOrFindNext",
                        description: "Select or find next",
                        bindKey: bindKey("Alt-K", "Ctrl-G"),
                        exec: function exec(editor) {
                            if (editor.selection.isEmpty()) editor.selection.selectWord();
                            else editor.findNext();
                        },
                        readOnly: true
                    },
                    {
                        name: "selectOrFindPrevious",
                        description: "Select or find previous",
                        bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
                        exec: function exec(editor) {
                            if (editor.selection.isEmpty()) editor.selection.selectWord();
                            else editor.findPrevious();
                        },
                        readOnly: true
                    },
                    {
                        name: "find",
                        description: "Find",
                        bindKey: bindKey("Ctrl-F", "Command-F"),
                        exec: function exec(editor) {
                            config.loadModule("ace/ext/searchbox", function(e) {
                                e.Search(editor);
                            });
                        },
                        readOnly: true
                    },
                    {
                        name: "overwrite",
                        description: "Overwrite",
                        bindKey: "Insert",
                        exec: function exec(editor) {
                            editor.toggleOverwrite();
                        },
                        readOnly: true
                    },
                    {
                        name: "selecttostart",
                        description: "Select to start",
                        bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Home|Command-Shift-Up"),
                        exec: function exec(editor) {
                            editor.getSelection().selectFileStart();
                        },
                        multiSelectAction: "forEach",
                        readOnly: true,
                        scrollIntoView: "animate",
                        aceCommandGroup: "fileJump"
                    },
                    {
                        name: "gotostart",
                        description: "Go to start",
                        bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
                        exec: function exec(editor) {
                            editor.navigateFileStart();
                        },
                        multiSelectAction: "forEach",
                        readOnly: true,
                        scrollIntoView: "animate",
                        aceCommandGroup: "fileJump"
                    },
                    {
                        name: "selectup",
                        description: "Select up",
                        bindKey: bindKey("Shift-Up", "Shift-Up|Ctrl-Shift-P"),
                        exec: function exec(editor) {
                            editor.getSelection().selectUp();
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor",
                        readOnly: true
                    },
                    {
                        name: "golineup",
                        description: "Go line up",
                        bindKey: bindKey("Up", "Up|Ctrl-P"),
                        exec: function exec(editor, args) {
                            editor.navigateUp(args.times);
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor",
                        readOnly: true
                    },
                    {
                        name: "selecttoend",
                        description: "Select to end",
                        bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-End|Command-Shift-Down"),
                        exec: function exec(editor) {
                            editor.getSelection().selectFileEnd();
                        },
                        multiSelectAction: "forEach",
                        readOnly: true,
                        scrollIntoView: "animate",
                        aceCommandGroup: "fileJump"
                    },
                    {
                        name: "gotoend",
                        description: "Go to end",
                        bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
                        exec: function exec(editor) {
                            editor.navigateFileEnd();
                        },
                        multiSelectAction: "forEach",
                        readOnly: true,
                        scrollIntoView: "animate",
                        aceCommandGroup: "fileJump"
                    },
                    {
                        name: "selectdown",
                        description: "Select down",
                        bindKey: bindKey("Shift-Down", "Shift-Down|Ctrl-Shift-N"),
                        exec: function exec(editor) {
                            editor.getSelection().selectDown();
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor",
                        readOnly: true
                    },
                    {
                        name: "golinedown",
                        description: "Go line down",
                        bindKey: bindKey("Down", "Down|Ctrl-N"),
                        exec: function exec(editor, args) {
                            editor.navigateDown(args.times);
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor",
                        readOnly: true
                    },
                    {
                        name: "selectwordleft",
                        description: "Select word left",
                        bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
                        exec: function exec(editor) {
                            editor.getSelection().selectWordLeft();
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor",
                        readOnly: true
                    },
                    {
                        name: "gotowordleft",
                        description: "Go to word left",
                        bindKey: bindKey("Ctrl-Left", "Option-Left"),
                        exec: function exec(editor) {
                            editor.navigateWordLeft();
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor",
                        readOnly: true
                    },
                    {
                        name: "selecttolinestart",
                        description: "Select to line start",
                        bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left|Ctrl-Shift-A"),
                        exec: function exec(editor) {
                            editor.getSelection().selectLineStart();
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor",
                        readOnly: true
                    },
                    {
                        name: "gotolinestart",
                        description: "Go to line start",
                        bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
                        exec: function exec(editor) {
                            editor.navigateLineStart();
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor",
                        readOnly: true
                    },
                    {
                        name: "selectleft",
                        description: "Select left",
                        bindKey: bindKey("Shift-Left", "Shift-Left|Ctrl-Shift-B"),
                        exec: function exec(editor) {
                            editor.getSelection().selectLeft();
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor",
                        readOnly: true
                    },
                    {
                        name: "gotoleft",
                        description: "Go to left",
                        bindKey: bindKey("Left", "Left|Ctrl-B"),
                        exec: function exec(editor, args) {
                            editor.navigateLeft(args.times);
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor",
                        readOnly: true
                    },
                    {
                        name: "selectwordright",
                        description: "Select word right",
                        bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
                        exec: function exec(editor) {
                            editor.getSelection().selectWordRight();
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor",
                        readOnly: true
                    },
                    {
                        name: "gotowordright",
                        description: "Go to word right",
                        bindKey: bindKey("Ctrl-Right", "Option-Right"),
                        exec: function exec(editor) {
                            editor.navigateWordRight();
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor",
                        readOnly: true
                    },
                    {
                        name: "selecttolineend",
                        description: "Select to line end",
                        bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right|Shift-End|Ctrl-Shift-E"),
                        exec: function exec(editor) {
                            editor.getSelection().selectLineEnd();
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor",
                        readOnly: true
                    },
                    {
                        name: "gotolineend",
                        description: "Go to line end",
                        bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
                        exec: function exec(editor) {
                            editor.navigateLineEnd();
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor",
                        readOnly: true
                    },
                    {
                        name: "selectright",
                        description: "Select right",
                        bindKey: bindKey("Shift-Right", "Shift-Right"),
                        exec: function exec(editor) {
                            editor.getSelection().selectRight();
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor",
                        readOnly: true
                    },
                    {
                        name: "gotoright",
                        description: "Go to right",
                        bindKey: bindKey("Right", "Right|Ctrl-F"),
                        exec: function exec(editor, args) {
                            editor.navigateRight(args.times);
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor",
                        readOnly: true
                    },
                    {
                        name: "selectpagedown",
                        description: "Select page down",
                        bindKey: "Shift-PageDown",
                        exec: function exec(editor) {
                            editor.selectPageDown();
                        },
                        readOnly: true
                    },
                    {
                        name: "pagedown",
                        description: "Page down",
                        bindKey: bindKey(null, "Option-PageDown"),
                        exec: function exec(editor) {
                            editor.scrollPageDown();
                        },
                        readOnly: true
                    },
                    {
                        name: "gotopagedown",
                        description: "Go to page down",
                        bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
                        exec: function exec(editor) {
                            editor.gotoPageDown();
                        },
                        readOnly: true
                    },
                    {
                        name: "selectpageup",
                        description: "Select page up",
                        bindKey: "Shift-PageUp",
                        exec: function exec(editor) {
                            editor.selectPageUp();
                        },
                        readOnly: true
                    },
                    {
                        name: "pageup",
                        description: "Page up",
                        bindKey: bindKey(null, "Option-PageUp"),
                        exec: function exec(editor) {
                            editor.scrollPageUp();
                        },
                        readOnly: true
                    },
                    {
                        name: "gotopageup",
                        description: "Go to page up",
                        bindKey: "PageUp",
                        exec: function exec(editor) {
                            editor.gotoPageUp();
                        },
                        readOnly: true
                    },
                    {
                        name: "scrollup",
                        description: "Scroll up",
                        bindKey: bindKey("Ctrl-Up", null),
                        exec: function exec(e) {
                            e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight);
                        },
                        readOnly: true
                    },
                    {
                        name: "scrolldown",
                        description: "Scroll down",
                        bindKey: bindKey("Ctrl-Down", null),
                        exec: function exec(e) {
                            e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight);
                        },
                        readOnly: true
                    },
                    {
                        name: "selectlinestart",
                        description: "Select line start",
                        bindKey: "Shift-Home",
                        exec: function exec(editor) {
                            editor.getSelection().selectLineStart();
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor",
                        readOnly: true
                    },
                    {
                        name: "selectlineend",
                        description: "Select line end",
                        bindKey: "Shift-End",
                        exec: function exec(editor) {
                            editor.getSelection().selectLineEnd();
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor",
                        readOnly: true
                    },
                    {
                        name: "togglerecording",
                        description: "Toggle recording",
                        bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
                        exec: function exec(editor) {
                            editor.commands.toggleRecording(editor);
                        },
                        readOnly: true
                    },
                    {
                        name: "replaymacro",
                        description: "Replay macro",
                        bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
                        exec: function exec(editor) {
                            editor.commands.replay(editor);
                        },
                        readOnly: true
                    },
                    {
                        name: "jumptomatching",
                        description: "Jump to matching",
                        bindKey: bindKey("Ctrl-\\|Ctrl-P", "Command-\\"),
                        exec: function exec(editor) {
                            editor.jumpToMatching();
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "animate",
                        readOnly: true
                    },
                    {
                        name: "selecttomatching",
                        description: "Select to matching",
                        bindKey: bindKey("Ctrl-Shift-\\|Ctrl-Shift-P", "Command-Shift-\\"),
                        exec: function exec(editor) {
                            editor.jumpToMatching(true);
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "animate",
                        readOnly: true
                    },
                    {
                        name: "expandToMatching",
                        description: "Expand to matching",
                        bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
                        exec: function exec(editor) {
                            editor.jumpToMatching(true, true);
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "animate",
                        readOnly: true
                    },
                    {
                        name: "passKeysToBrowser",
                        description: "Pass keys to browser",
                        bindKey: bindKey(null, null),
                        exec: function exec() {},
                        passEvent: true,
                        readOnly: true
                    },
                    {
                        name: "copy",
                        description: "Copy",
                        exec: function exec(editor) {
                        // placeholder for replay macro
                        },
                        readOnly: true
                    },
                    // commands disabled in readOnly mode
                    {
                        name: "cut",
                        description: "Cut",
                        exec: function exec(editor) {
                            var cutLine = editor.$copyWithEmptySelection && editor.selection.isEmpty();
                            var range = cutLine ? editor.selection.getLineRange() : editor.selection.getRange();
                            editor._emit("cut", range);
                            if (!range.isEmpty()) editor.session.remove(range);
                            editor.clearSelection();
                        },
                        scrollIntoView: "cursor",
                        multiSelectAction: "forEach"
                    },
                    {
                        name: "paste",
                        description: "Paste",
                        exec: function exec(editor, args) {
                            editor.$handlePaste(args);
                        },
                        scrollIntoView: "cursor"
                    },
                    {
                        name: "removeline",
                        description: "Remove line",
                        bindKey: bindKey("Ctrl-D", "Command-D"),
                        exec: function exec(editor) {
                            editor.removeLines();
                        },
                        scrollIntoView: "cursor",
                        multiSelectAction: "forEachLine"
                    },
                    {
                        name: "duplicateSelection",
                        description: "Duplicate selection",
                        bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
                        exec: function exec(editor) {
                            editor.duplicateSelection();
                        },
                        scrollIntoView: "cursor",
                        multiSelectAction: "forEach"
                    },
                    {
                        name: "sortlines",
                        description: "Sort lines",
                        bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
                        exec: function exec(editor) {
                            editor.sortLines();
                        },
                        scrollIntoView: "selection",
                        multiSelectAction: "forEachLine"
                    },
                    {
                        name: "togglecomment",
                        description: "Toggle comment",
                        bindKey: bindKey("Ctrl-/", "Command-/"),
                        exec: function exec(editor) {
                            editor.toggleCommentLines();
                        },
                        multiSelectAction: "forEachLine",
                        scrollIntoView: "selectionPart"
                    },
                    {
                        name: "toggleBlockComment",
                        description: "Toggle block comment",
                        bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
                        exec: function exec(editor) {
                            editor.toggleBlockComment();
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "selectionPart"
                    },
                    {
                        name: "modifyNumberUp",
                        description: "Modify number up",
                        bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
                        exec: function exec(editor) {
                            editor.modifyNumber(1);
                        },
                        scrollIntoView: "cursor",
                        multiSelectAction: "forEach"
                    },
                    {
                        name: "modifyNumberDown",
                        description: "Modify number down",
                        bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
                        exec: function exec(editor) {
                            editor.modifyNumber(-1);
                        },
                        scrollIntoView: "cursor",
                        multiSelectAction: "forEach"
                    },
                    {
                        name: "replace",
                        description: "Replace",
                        bindKey: bindKey("Ctrl-H", "Command-Option-F"),
                        exec: function exec(editor) {
                            config.loadModule("ace/ext/searchbox", function(e) {
                                e.Search(editor, true);
                            });
                        }
                    },
                    {
                        name: "undo",
                        description: "Undo",
                        bindKey: bindKey("Ctrl-Z", "Command-Z"),
                        exec: function exec(editor) {
                            editor.undo();
                        }
                    },
                    {
                        name: "redo",
                        description: "Redo",
                        bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
                        exec: function exec(editor) {
                            editor.redo();
                        }
                    },
                    {
                        name: "copylinesup",
                        description: "Copy lines up",
                        bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
                        exec: function exec(editor) {
                            editor.copyLinesUp();
                        },
                        scrollIntoView: "cursor"
                    },
                    {
                        name: "movelinesup",
                        description: "Move lines up",
                        bindKey: bindKey("Alt-Up", "Option-Up"),
                        exec: function exec(editor) {
                            editor.moveLinesUp();
                        },
                        scrollIntoView: "cursor"
                    },
                    {
                        name: "copylinesdown",
                        description: "Copy lines down",
                        bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
                        exec: function exec(editor) {
                            editor.copyLinesDown();
                        },
                        scrollIntoView: "cursor"
                    },
                    {
                        name: "movelinesdown",
                        description: "Move lines down",
                        bindKey: bindKey("Alt-Down", "Option-Down"),
                        exec: function exec(editor) {
                            editor.moveLinesDown();
                        },
                        scrollIntoView: "cursor"
                    },
                    {
                        name: "del",
                        description: "Delete",
                        bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
                        exec: function exec(editor) {
                            editor.remove("right");
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor"
                    },
                    {
                        name: "backspace",
                        description: "Backspace",
                        bindKey: bindKey("Shift-Backspace|Backspace", "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"),
                        exec: function exec(editor) {
                            editor.remove("left");
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor"
                    },
                    {
                        name: "cut_or_delete",
                        description: "Cut or delete",
                        bindKey: bindKey("Shift-Delete", null),
                        exec: function exec(editor) {
                            if (editor.selection.isEmpty()) {
                                editor.remove("left");
                            } else {
                                return false;
                            }
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor"
                    },
                    {
                        name: "removetolinestart",
                        description: "Remove to line start",
                        bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
                        exec: function exec(editor) {
                            editor.removeToLineStart();
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor"
                    },
                    {
                        name: "removetolineend",
                        description: "Remove to line end",
                        bindKey: bindKey("Alt-Delete", "Ctrl-K|Command-Delete"),
                        exec: function exec(editor) {
                            editor.removeToLineEnd();
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor"
                    },
                    {
                        name: "removetolinestarthard",
                        description: "Remove to line start hard",
                        bindKey: bindKey("Ctrl-Shift-Backspace", null),
                        exec: function exec(editor) {
                            var range = editor.selection.getRange();
                            range.start.column = 0;
                            editor.session.remove(range);
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor"
                    },
                    {
                        name: "removetolineendhard",
                        description: "Remove to line end hard",
                        bindKey: bindKey("Ctrl-Shift-Delete", null),
                        exec: function exec(editor) {
                            var range = editor.selection.getRange();
                            range.end.column = Number.MAX_VALUE;
                            editor.session.remove(range);
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor"
                    },
                    {
                        name: "removewordleft",
                        description: "Remove word left",
                        bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
                        exec: function exec(editor) {
                            editor.removeWordLeft();
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor"
                    },
                    {
                        name: "removewordright",
                        description: "Remove word right",
                        bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
                        exec: function exec(editor) {
                            editor.removeWordRight();
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor"
                    },
                    {
                        name: "outdent",
                        description: "Outdent",
                        bindKey: bindKey("Shift-Tab", "Shift-Tab"),
                        exec: function exec(editor) {
                            editor.blockOutdent();
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "selectionPart"
                    },
                    {
                        name: "indent",
                        description: "Indent",
                        bindKey: bindKey("Tab", "Tab"),
                        exec: function exec(editor) {
                            editor.indent();
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "selectionPart"
                    },
                    {
                        name: "blockoutdent",
                        description: "Block outdent",
                        bindKey: bindKey("Ctrl-[", "Ctrl-["),
                        exec: function exec(editor) {
                            editor.blockOutdent();
                        },
                        multiSelectAction: "forEachLine",
                        scrollIntoView: "selectionPart"
                    },
                    {
                        name: "blockindent",
                        description: "Block indent",
                        bindKey: bindKey("Ctrl-]", "Ctrl-]"),
                        exec: function exec(editor) {
                            editor.blockIndent();
                        },
                        multiSelectAction: "forEachLine",
                        scrollIntoView: "selectionPart"
                    },
                    {
                        name: "insertstring",
                        description: "Insert string",
                        exec: function exec(editor, str) {
                            editor.insert(str);
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor"
                    },
                    {
                        name: "inserttext",
                        description: "Insert text",
                        exec: function exec(editor, args) {
                            editor.insert(lang.stringRepeat(args.text || "", args.times || 1));
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor"
                    },
                    {
                        name: "splitline",
                        description: "Split line",
                        bindKey: bindKey(null, "Ctrl-O"),
                        exec: function exec(editor) {
                            editor.splitLine();
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor"
                    },
                    {
                        name: "transposeletters",
                        description: "Transpose letters",
                        bindKey: bindKey("Alt-Shift-X", "Ctrl-T"),
                        exec: function exec(editor) {
                            editor.transposeLetters();
                        },
                        multiSelectAction: function multiSelectAction(editor) {
                            editor.transposeSelections(1);
                        },
                        scrollIntoView: "cursor"
                    },
                    {
                        name: "touppercase",
                        description: "To uppercase",
                        bindKey: bindKey("Ctrl-U", "Ctrl-U"),
                        exec: function exec(editor) {
                            editor.toUpperCase();
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor"
                    },
                    {
                        name: "tolowercase",
                        description: "To lowercase",
                        bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
                        exec: function exec(editor) {
                            editor.toLowerCase();
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor"
                    },
                    {
                        name: "autoindent",
                        description: "Auto Indent",
                        bindKey: bindKey(null, null),
                        exec: function exec(editor) {
                            editor.autoIndent();
                        },
                        multiSelectAction: "forEachLine",
                        scrollIntoView: "animate"
                    },
                    {
                        name: "expandtoline",
                        description: "Expand to line",
                        bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
                        exec: function exec(editor) {
                            var range = editor.selection.getRange();
                            range.start.column = range.end.column = 0;
                            range.end.row++;
                            editor.selection.setRange(range, false);
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor",
                        readOnly: true
                    },
                    {
                        name: "openlink",
                        bindKey: bindKey("Ctrl+F3", "F3"),
                        exec: function exec(editor) {
                            editor.openLink();
                        }
                    },
                    {
                        name: "joinlines",
                        description: "Join lines",
                        bindKey: bindKey(null, null),
                        exec: function exec(editor) {
                            var isBackwards = editor.selection.isBackwards();
                            var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
                            var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
                            var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
                            var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
                            var selectedCount = selectedText.replace(/\n\s*/, " ").length;
                            var insertLine = editor.session.doc.getLine(selectionStart.row);
                            for(var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++){
                                var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));
                                if (curLine.length !== 0) {
                                    curLine = " " + curLine;
                                }
                                insertLine += curLine;
                            }
                            if (selectionEnd.row + 1 < editor.session.doc.getLength() - 1) {
                                // Don't insert a newline at the end of the document
                                insertLine += editor.session.doc.getNewLineCharacter();
                            }
                            editor.clearSelection();
                            editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);
                            if (selectedCount > 0) {
                                // Select the text that was previously selected
                                editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
                                editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
                            } else {
                                // If the joined line had something in it, start the cursor at that something
                                firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? firstLineEndCol + 1 : firstLineEndCol;
                                editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
                            }
                        },
                        multiSelectAction: "forEach",
                        readOnly: true
                    },
                    {
                        name: "invertSelection",
                        description: "Invert selection",
                        bindKey: bindKey(null, null),
                        exec: function exec(editor) {
                            var endRow = editor.session.doc.getLength() - 1;
                            var endCol = editor.session.doc.getLine(endRow).length;
                            var ranges = editor.selection.rangeList.ranges;
                            var newRanges = [];
                            // If multiple selections don't exist, rangeList will return 0 so replace with single range
                            if (ranges.length < 1) {
                                ranges = [
                                    editor.selection.getRange()
                                ];
                            }
                            for(var i = 0; i < ranges.length; i++){
                                if (i == ranges.length - 1) {
                                    // The last selection must connect to the end of the document, unless it already does
                                    if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {
                                        newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));
                                    }
                                }
                                if (i === 0) {
                                    // The first selection must connect to the start of the document, unless it already does
                                    if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {
                                        newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));
                                    }
                                } else {
                                    newRanges.push(new Range(ranges[i - 1].end.row, ranges[i - 1].end.column, ranges[i].start.row, ranges[i].start.column));
                                }
                            }
                            editor.exitMultiSelectMode();
                            editor.clearSelection();
                            for(var i = 0; i < newRanges.length; i++){
                                editor.selection.addRange(newRanges[i], false);
                            }
                        },
                        readOnly: true,
                        scrollIntoView: "none"
                    },
                    {
                        name: "addLineAfter",
                        description: "Add new line after the current line",
                        exec: function exec(editor) {
                            editor.selection.clearSelection();
                            editor.navigateLineEnd();
                            editor.insert("\n");
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor"
                    },
                    {
                        name: "addLineBefore",
                        description: "Add new line before the current line",
                        exec: function exec(editor) {
                            editor.selection.clearSelection();
                            var cursor = editor.getCursorPosition();
                            editor.selection.moveTo(cursor.row - 1, Number.MAX_VALUE);
                            editor.insert("\n");
                            if (cursor.row === 0) editor.navigateUp();
                        },
                        multiSelectAction: "forEach",
                        scrollIntoView: "cursor"
                    },
                    {
                        name: "openCommandPallete",
                        description: "Open command palette",
                        bindKey: bindKey("F1", "F1"),
                        exec: function exec(editor) {
                            editor.prompt({
                                $type: "commands"
                            });
                        },
                        readOnly: true
                    },
                    {
                        name: "modeSelect",
                        description: "Change language mode...",
                        bindKey: bindKey(null, null),
                        exec: function exec(editor) {
                            editor.prompt({
                                $type: "modes"
                            });
                        },
                        readOnly: true
                    }
                ];
                for(var i = 1; i < 9; i++){
                    exports1.C.push({
                        name: "foldToLevel" + i,
                        description: "Fold To Level " + i,
                        level: i,
                        exec: function exec(editor) {
                            editor.session.foldToLevel(this.level);
                        },
                        scrollIntoView: "center",
                        readOnly: true
                    });
                }
            /***/ },
            /***/ 2051: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_119608__) {
                // commands to enter multiselect mode
                exports1.defaultCommands = [
                    {
                        name: "addCursorAbove",
                        description: "Add cursor above",
                        exec: function exec(editor) {
                            editor.selectMoreLines(-1);
                        },
                        bindKey: {
                            win: "Ctrl-Alt-Up",
                            mac: "Ctrl-Alt-Up"
                        },
                        scrollIntoView: "cursor",
                        readOnly: true
                    },
                    {
                        name: "addCursorBelow",
                        description: "Add cursor below",
                        exec: function exec(editor) {
                            editor.selectMoreLines(1);
                        },
                        bindKey: {
                            win: "Ctrl-Alt-Down",
                            mac: "Ctrl-Alt-Down"
                        },
                        scrollIntoView: "cursor",
                        readOnly: true
                    },
                    {
                        name: "addCursorAboveSkipCurrent",
                        description: "Add cursor above (skip current)",
                        exec: function exec(editor) {
                            editor.selectMoreLines(-1, true);
                        },
                        bindKey: {
                            win: "Ctrl-Alt-Shift-Up",
                            mac: "Ctrl-Alt-Shift-Up"
                        },
                        scrollIntoView: "cursor",
                        readOnly: true
                    },
                    {
                        name: "addCursorBelowSkipCurrent",
                        description: "Add cursor below (skip current)",
                        exec: function exec(editor) {
                            editor.selectMoreLines(1, true);
                        },
                        bindKey: {
                            win: "Ctrl-Alt-Shift-Down",
                            mac: "Ctrl-Alt-Shift-Down"
                        },
                        scrollIntoView: "cursor",
                        readOnly: true
                    },
                    {
                        name: "selectMoreBefore",
                        description: "Select more before",
                        exec: function exec(editor) {
                            editor.selectMore(-1);
                        },
                        bindKey: {
                            win: "Ctrl-Alt-Left",
                            mac: "Ctrl-Alt-Left"
                        },
                        scrollIntoView: "cursor",
                        readOnly: true
                    },
                    {
                        name: "selectMoreAfter",
                        description: "Select more after",
                        exec: function exec(editor) {
                            editor.selectMore(1);
                        },
                        bindKey: {
                            win: "Ctrl-Alt-Right",
                            mac: "Ctrl-Alt-Right"
                        },
                        scrollIntoView: "cursor",
                        readOnly: true
                    },
                    {
                        name: "selectNextBefore",
                        description: "Select next before",
                        exec: function exec(editor) {
                            editor.selectMore(-1, true);
                        },
                        bindKey: {
                            win: "Ctrl-Alt-Shift-Left",
                            mac: "Ctrl-Alt-Shift-Left"
                        },
                        scrollIntoView: "cursor",
                        readOnly: true
                    },
                    {
                        name: "selectNextAfter",
                        description: "Select next after",
                        exec: function exec(editor) {
                            editor.selectMore(1, true);
                        },
                        bindKey: {
                            win: "Ctrl-Alt-Shift-Right",
                            mac: "Ctrl-Alt-Shift-Right"
                        },
                        scrollIntoView: "cursor",
                        readOnly: true
                    },
                    {
                        name: "toggleSplitSelectionIntoLines",
                        description: "Split selection into lines",
                        exec: function exec(editor) {
                            if (editor.multiSelect.rangeCount > 1) editor.multiSelect.joinSelections();
                            else editor.multiSelect.splitIntoLines();
                        },
                        bindKey: {
                            win: "Ctrl-Alt-L",
                            mac: "Ctrl-Alt-L"
                        },
                        readOnly: true
                    },
                    {
                        name: "splitSelectionIntoLines",
                        description: "Split into lines",
                        exec: function exec(editor) {
                            editor.multiSelect.splitIntoLines();
                        },
                        readOnly: true
                    },
                    {
                        name: "alignCursors",
                        description: "Align cursors",
                        exec: function exec(editor) {
                            editor.alignCursors();
                        },
                        bindKey: {
                            win: "Ctrl-Alt-A",
                            mac: "Ctrl-Alt-A"
                        },
                        scrollIntoView: "cursor"
                    },
                    {
                        name: "findAll",
                        description: "Find all",
                        exec: function exec(editor) {
                            editor.findAll();
                        },
                        bindKey: {
                            win: "Ctrl-Alt-K",
                            mac: "Ctrl-Alt-G"
                        },
                        scrollIntoView: "cursor",
                        readOnly: true
                    }
                ];
                // commands active only in multiselect mode
                exports1.multiSelectCommands = [
                    {
                        name: "singleSelection",
                        description: "Single selection",
                        bindKey: "esc",
                        exec: function exec(editor) {
                            editor.exitMultiSelectMode();
                        },
                        scrollIntoView: "cursor",
                        readOnly: true,
                        isAvailable: function isAvailable(editor) {
                            return editor && editor.inMultiSelectMode;
                        }
                    }
                ];
                var HashHandler = __nested_webpack_require_119608__(4739).HashHandler;
                exports1.keyboardHandler = new HashHandler(exports1.multiSelectCommands);
            /***/ },
            /***/ 3294: /***/ function(module1, exports1, __nested_webpack_require_127061__) {
                "no use strict";
                /* provided dependency */ var console = __nested_webpack_require_127061__(3716);
                var lang = __nested_webpack_require_127061__(732);
                var net = __nested_webpack_require_127061__(8999);
                var dom = __nested_webpack_require_127061__(5336);
                var AppConfig = __nested_webpack_require_127061__(5704)/* .AppConfig */ .X;
                module1.exports = exports1 = new AppConfig();
                var options = {
                    packaged: false,
                    workerPath: null,
                    modePath: null,
                    themePath: null,
                    basePath: "",
                    suffix: ".js",
                    $moduleUrls: {},
                    loadWorkerFromBlob: true,
                    sharedPopups: false,
                    useStrictCSP: null
                };
                exports1.get = function(key) {
                    if (!options.hasOwnProperty(key)) throw new Error("Unknown config key: " + key);
                    return options[key];
                };
                exports1.set = function(key, value) {
                    if (options.hasOwnProperty(key)) options[key] = value;
                    else if (this.setDefaultValue("", key, value) == false) throw new Error("Unknown config key: " + key);
                    if (key == "useStrictCSP") dom.useStrictCSP(value);
                };
                exports1.all = function() {
                    return lang.copyObject(options);
                };
                exports1.$modes = {};
                // module loading
                exports1.moduleUrl = function(name, component) {
                    if (options.$moduleUrls[name]) return options.$moduleUrls[name];
                    var parts = name.split("/");
                    component = component || parts[parts.length - 2] || "";
                    // todo make this configurable or get rid of '-'
                    var sep = component == "snippets" ? "/" : "-";
                    var base = parts[parts.length - 1];
                    if (component == "worker" && sep == "-") {
                        var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
                        base = base.replace(re, "");
                    }
                    if ((!base || base == component) && parts.length > 1) base = parts[parts.length - 2];
                    var path = options[component + "Path"];
                    if (path == null) {
                        path = options.basePath;
                    } else if (sep == "/") {
                        component = sep = "";
                    }
                    if (path && path.slice(-1) != "/") path += "/";
                    return path + component + sep + base + this.get("suffix");
                };
                exports1.setModuleUrl = function(name, subst) {
                    return options.$moduleUrls[name] = subst;
                };
                var loader = function loader(moduleName, cb) {
                    if (moduleName === "ace/theme/textmate" || moduleName === "./theme/textmate") return cb(null, __nested_webpack_require_127061__(9609));
                    return console.error("loader is not configured");
                };
                exports1.setLoader = function(cb) {
                    loader = cb;
                };
                exports1.dynamicModules = Object.create(null);
                exports1.$loading = {};
                exports1.loadModule = function(moduleName, onLoad) {
                    var _$module, moduleType;
                    if (Array.isArray(moduleName)) {
                        moduleType = moduleName[0];
                        moduleName = moduleName[1];
                    }
                    var load = function load(module1) {
                        // require(moduleName) can return empty object if called after require([moduleName], callback)
                        if (module1 && !exports1.$loading[moduleName]) return onLoad && onLoad(module1);
                        if (!exports1.$loading[moduleName]) exports1.$loading[moduleName] = [];
                        exports1.$loading[moduleName].push(onLoad);
                        if (exports1.$loading[moduleName].length > 1) return;
                        var afterLoad = function afterLoad() {
                            loader(moduleName, function(err, module1) {
                                exports1._emit("load.module", {
                                    name: moduleName,
                                    module: module1
                                });
                                var listeners = exports1.$loading[moduleName];
                                exports1.$loading[moduleName] = null;
                                listeners.forEach(function(onLoad) {
                                    onLoad && onLoad(module1);
                                });
                            });
                        };
                        if (!exports1.get("packaged")) return afterLoad();
                        net.loadScript(exports1.moduleUrl(moduleName, moduleType), afterLoad);
                        reportErrorIfPathIsNotConfigured();
                    };
                    if (exports1.dynamicModules[moduleName]) {
                        exports1.dynamicModules[moduleName]().then(function(module1) {
                            if (module1.default) {
                                load(module1.default);
                            } else {
                                load(module1);
                            }
                        });
                    } else {
                        try {
                            _$module = __nested_webpack_require_127061__(5267)(moduleName);
                        } catch (e) {}
                        load(_$module);
                    }
                };
                exports1.setModuleLoader = function(moduleName, onLoad) {
                    exports1.dynamicModules[moduleName] = onLoad;
                };
                var reportErrorIfPathIsNotConfigured = function reportErrorIfPathIsNotConfigured1() {
                    if (!options.basePath && !options.workerPath && !options.modePath && !options.themePath && !Object.keys(options.$moduleUrls).length) {
                        console.error("Unable to infer path to ace from script src,", "use ace.config.set('basePath', 'path') to enable dynamic loading of modes and themes", "or with webpack use ace/webpack-resolver");
                        reportErrorIfPathIsNotConfigured = function reportErrorIfPathIsNotConfigured() {};
                    }
                };
                exports1.version = "1.17.0";
            /***/ },
            /***/ 5043: /***/ function(module1) {
                /*
styles = []
for (var i = 1; i < 16; i++) {
    styles.push(".ace_br" + i + "{" + (
        ["top-left", "top-right", "bottom-right", "bottom-left"]
    ).map(function(x, j) {
        return i & (1<<j) ? "border-" + x + "-radius: 3px;" : "" 
    }).filter(Boolean).join(" ") + "}")
}
styles.join("\\n")
*/ module1.exports = '\n.ace_br1 {border-top-left-radius    : 3px;}\n.ace_br2 {border-top-right-radius   : 3px;}\n.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}\n.ace_br4 {border-bottom-right-radius: 3px;}\n.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}\n.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}\n.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}\n.ace_br8 {border-bottom-left-radius : 3px;}\n.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}\n.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}\n.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}\n.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\n.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\n.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\n.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}\n\n\n.ace_editor {\n    position: relative;\n    overflow: hidden;\n    padding: 0;\n    font: 12px/normal \'Monaco\', \'Menlo\', \'Ubuntu Mono\', \'Consolas\', \'Source Code Pro\', \'source-code-pro\', monospace;\n    direction: ltr;\n    text-align: left;\n    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n}\n\n.ace_scroller {\n    position: absolute;\n    overflow: hidden;\n    top: 0;\n    bottom: 0;\n    background-color: inherit;\n    -ms-user-select: none;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    user-select: none;\n    cursor: text;\n}\n\n.ace_content {\n    position: absolute;\n    box-sizing: border-box;\n    min-width: 100%;\n    contain: style size layout;\n    font-variant-ligatures: no-common-ligatures;\n}\n\n.ace_keyboard-focus:focus {\n    box-shadow: inset 0 0 0 2px #5E9ED6;\n    outline: none;\n}\n\n.ace_dragging .ace_scroller:before{\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    content: \'\';\n    background: rgba(250, 250, 250, 0.01);\n    z-index: 1000;\n}\n.ace_dragging.ace_dark .ace_scroller:before{\n    background: rgba(0, 0, 0, 0.01);\n}\n\n.ace_gutter {\n    position: absolute;\n    overflow : hidden;\n    width: auto;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    cursor: default;\n    z-index: 4;\n    -ms-user-select: none;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    user-select: none;\n    contain: style size layout;\n}\n\n.ace_gutter-active-line {\n    position: absolute;\n    left: 0;\n    right: 0;\n}\n\n.ace_scroller.ace_scroll-left:after {\n    content: "";\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\n    pointer-events: none;\n}\n\n.ace_gutter-cell, .ace_gutter-cell_svg-icons  {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    padding-left: 19px;\n    padding-right: 6px;\n    background-repeat: no-repeat;\n}\n\n.ace_gutter-cell_svg-icons .ace_icon_svg{\n    margin-left: -14px;\n    float: left;\n}\n\n.ace_gutter-cell.ace_error, .ace_icon.ace_error {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==");\n    background-repeat: no-repeat;\n    background-position: 2px center;\n}\n\n.ace_gutter-cell.ace_warning, .ace_icon.ace_warning {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==");\n    background-repeat: no-repeat;\n    background-position: 2px center;\n}\n\n.ace_gutter-cell.ace_info, .ace_icon.ace_info {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=");\n    background-repeat: no-repeat;\n    background-position: 2px center;\n}\n.ace_dark .ace_gutter-cell.ace_info, .ace_dark .ace_icon.ace_info {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC");\n}\n\n.ace_icon_svg.ace_error {\n    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJyZWQiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KPGNpcmNsZSBmaWxsPSJub25lIiBjeD0iOCIgY3k9IjgiIHI9IjciIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPGxpbmUgeDE9IjExIiB5MT0iNSIgeDI9IjUiIHkyPSIxMSIvPgo8bGluZSB4MT0iMTEiIHkxPSIxMSIgeDI9IjUiIHkyPSI1Ii8+CjwvZz4KPC9zdmc+");\n    background-color: crimson;\n}\n.ace_icon_svg.ace_warning {\n    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJkYXJrb3JhbmdlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+Cjxwb2x5Z29uIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGZpbGw9Im5vbmUiIHBvaW50cz0iOCAxIDE1IDE1IDEgMTUgOCAxIi8+CjxyZWN0IHg9IjgiIHk9IjEyIiB3aWR0aD0iMC4wMSIgaGVpZ2h0PSIwLjAxIi8+CjxsaW5lIHgxPSI4IiB5MT0iNiIgeDI9IjgiIHkyPSIxMCIvPgo8L2c+Cjwvc3ZnPg==");\n    background-color: darkorange;\n}\n.ace_icon_svg.ace_info {\n    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJibHVlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+CjxjaXJjbGUgZmlsbD0ibm9uZSIgY3g9IjgiIGN5PSI4IiByPSI3IiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjxwb2x5bGluZSBwb2ludHM9IjggMTEgOCA4Ii8+Cjxwb2x5bGluZSBwb2ludHM9IjkgOCA2IDgiLz4KPGxpbmUgeDE9IjEwIiB5MT0iMTEiIHgyPSI2IiB5Mj0iMTEiLz4KPHJlY3QgeD0iOCIgeT0iNSIgd2lkdGg9IjAuMDEiIGhlaWdodD0iMC4wMSIvPgo8L2c+Cjwvc3ZnPg==");\n    background-color: royalblue;\n}\n\n.ace_scrollbar {\n    contain: strict;\n    position: absolute;\n    right: 0;\n    bottom: 0;\n    z-index: 6;\n}\n\n.ace_scrollbar-inner {\n    position: absolute;\n    cursor: text;\n    left: 0;\n    top: 0;\n}\n\n.ace_scrollbar-v{\n    overflow-x: hidden;\n    overflow-y: scroll;\n    top: 0;\n}\n\n.ace_scrollbar-h {\n    overflow-x: scroll;\n    overflow-y: hidden;\n    left: 0;\n}\n\n.ace_print-margin {\n    position: absolute;\n    height: 100%;\n}\n\n.ace_text-input {\n    position: absolute;\n    z-index: 0;\n    width: 0.5em;\n    height: 1em;\n    opacity: 0;\n    background: transparent;\n    -moz-appearance: none;\n    appearance: none;\n    border: none;\n    resize: none;\n    outline: none;\n    overflow: hidden;\n    font: inherit;\n    padding: 0 1px;\n    margin: 0 -1px;\n    contain: strict;\n    -ms-user-select: text;\n    -moz-user-select: text;\n    -webkit-user-select: text;\n    user-select: text;\n    /*with `pre-line` chrome inserts &nbsp; instead of space*/\n    white-space: pre!important;\n}\n.ace_text-input.ace_composition {\n    background: transparent;\n    color: inherit;\n    z-index: 1000;\n    opacity: 1;\n}\n.ace_composition_placeholder { color: transparent }\n.ace_composition_marker { \n    border-bottom: 1px solid;\n    position: absolute;\n    border-radius: 0;\n    margin-top: 1px;\n}\n\n[ace_nocontext=true] {\n    transform: none!important;\n    filter: none!important;\n    clip-path: none!important;\n    mask : none!important;\n    contain: none!important;\n    perspective: none!important;\n    mix-blend-mode: initial!important;\n    z-index: auto;\n}\n\n.ace_layer {\n    z-index: 1;\n    position: absolute;\n    overflow: hidden;\n    /* workaround for chrome bug https://github.com/ajaxorg/ace/issues/2312*/\n    word-wrap: normal;\n    white-space: pre;\n    height: 100%;\n    width: 100%;\n    box-sizing: border-box;\n    /* setting pointer-events: auto; on node under the mouse, which changes\n        during scroll, will break mouse wheel scrolling in Safari */\n    pointer-events: none;\n}\n\n.ace_gutter-layer {\n    position: relative;\n    width: auto;\n    text-align: right;\n    pointer-events: auto;\n    height: 1000000px;\n    contain: style size layout;\n}\n\n.ace_text-layer {\n    font: inherit !important;\n    position: absolute;\n    height: 1000000px;\n    width: 1000000px;\n    contain: style size layout;\n}\n\n.ace_text-layer > .ace_line, .ace_text-layer > .ace_line_group {\n    contain: style size layout;\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n}\n\n.ace_hidpi .ace_text-layer,\n.ace_hidpi .ace_gutter-layer,\n.ace_hidpi .ace_content,\n.ace_hidpi .ace_gutter {\n    contain: strict;\n}\n.ace_hidpi .ace_text-layer > .ace_line, \n.ace_hidpi .ace_text-layer > .ace_line_group {\n    contain: strict;\n}\n\n.ace_cjk {\n    display: inline-block;\n    text-align: center;\n}\n\n.ace_cursor-layer {\n    z-index: 4;\n}\n\n.ace_cursor {\n    z-index: 4;\n    position: absolute;\n    box-sizing: border-box;\n    border-left: 2px solid;\n    /* workaround for smooth cursor repaintng whole screen in chrome */\n    transform: translatez(0);\n}\n\n.ace_multiselect .ace_cursor {\n    border-left-width: 1px;\n}\n\n.ace_slim-cursors .ace_cursor {\n    border-left-width: 1px;\n}\n\n.ace_overwrite-cursors .ace_cursor {\n    border-left-width: 0;\n    border-bottom: 1px solid;\n}\n\n.ace_hidden-cursors .ace_cursor {\n    opacity: 0.2;\n}\n\n.ace_hasPlaceholder .ace_hidden-cursors .ace_cursor {\n    opacity: 0;\n}\n\n.ace_smooth-blinking .ace_cursor {\n    transition: opacity 0.18s;\n}\n\n.ace_animate-blinking .ace_cursor {\n    animation-duration: 1000ms;\n    animation-timing-function: step-end;\n    animation-name: blink-ace-animate;\n    animation-iteration-count: infinite;\n}\n\n.ace_animate-blinking.ace_smooth-blinking .ace_cursor {\n    animation-duration: 1000ms;\n    animation-timing-function: ease-in-out;\n    animation-name: blink-ace-animate-smooth;\n}\n    \n@keyframes blink-ace-animate {\n    from, to { opacity: 1; }\n    60% { opacity: 0; }\n}\n\n@keyframes blink-ace-animate-smooth {\n    from, to { opacity: 1; }\n    45% { opacity: 1; }\n    60% { opacity: 0; }\n    85% { opacity: 0; }\n}\n\n.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\n    position: absolute;\n    z-index: 3;\n}\n\n.ace_marker-layer .ace_selection {\n    position: absolute;\n    z-index: 5;\n}\n\n.ace_marker-layer .ace_bracket {\n    position: absolute;\n    z-index: 6;\n}\n\n.ace_marker-layer .ace_error_bracket {\n    position: absolute;\n    border-bottom: 1px solid #DE5555;\n    border-radius: 0;\n}\n\n.ace_marker-layer .ace_active-line {\n    position: absolute;\n    z-index: 2;\n}\n\n.ace_marker-layer .ace_selected-word {\n    position: absolute;\n    z-index: 4;\n    box-sizing: border-box;\n}\n\n.ace_line .ace_fold {\n    box-sizing: border-box;\n\n    display: inline-block;\n    height: 11px;\n    margin-top: -2px;\n    vertical-align: middle;\n\n    background-image:\n        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),\n        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=");\n    background-repeat: no-repeat, repeat-x;\n    background-position: center center, top left;\n    color: transparent;\n\n    border: 1px solid black;\n    border-radius: 2px;\n\n    cursor: pointer;\n    pointer-events: auto;\n}\n\n.ace_dark .ace_fold {\n}\n\n.ace_fold:hover{\n    background-image:\n        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),\n        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC");\n}\n\n.ace_tooltip {\n    background-color: #f5f5f5;\n    border: 1px solid gray;\n    border-radius: 1px;\n    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\n    color: black;\n    max-width: 100%;\n    padding: 3px 4px;\n    position: fixed;\n    z-index: 999999;\n    box-sizing: border-box;\n    cursor: default;\n    white-space: pre;\n    word-wrap: break-word;\n    line-height: normal;\n    font-style: normal;\n    font-weight: normal;\n    letter-spacing: normal;\n    pointer-events: none;\n}\n\n.ace_tooltip:focus {\n    outline: 1px solid black;\n}\n\n.ace_gutter-tooltip_header {\n    font-weight: bold;\n}\n\n.ace_gutter-tooltip_body {\n    padding-top: 5px;\n}\n\n.ace_gutter-tooltip .ace_icon {\n    display: inline-block;\n    width: 18px;\n}\n\n.ace_icon_svg {\n    display: inline-block;\n    width: 12px;\n    vertical-align: top;\n    -webkit-mask-repeat: no-repeat;\n    -webkit-mask-size: 12px;\n    -webkit-mask-position: center;\n}\n\n.ace_folding-enabled > .ace_gutter-cell, .ace_folding-enabled > .ace_gutter-cell_svg-icons {\n    padding-right: 13px;\n}\n\n.ace_fold-widget {\n    box-sizing: border-box;\n\n    margin: 0 -12px 0 1px;\n    display: none;\n    width: 11px;\n    vertical-align: top;\n\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==");\n    background-repeat: no-repeat;\n    background-position: center;\n\n    border-radius: 3px;\n    \n    border: 1px solid transparent;\n    cursor: pointer;\n}\n\n.ace_folding-enabled .ace_fold-widget {\n    display: inline-block;   \n}\n\n.ace_fold-widget.ace_end {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==");\n}\n\n.ace_fold-widget.ace_closed {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==");\n}\n\n.ace_fold-widget:hover {\n    border: 1px solid rgba(0, 0, 0, 0.3);\n    background-color: rgba(255, 255, 255, 0.2);\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\n}\n\n.ace_fold-widget:active {\n    border: 1px solid rgba(0, 0, 0, 0.4);\n    background-color: rgba(0, 0, 0, 0.05);\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\n}\n/**\n * Dark version for fold widgets\n */\n.ace_dark .ace_fold-widget {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC");\n}\n.ace_dark .ace_fold-widget.ace_end {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==");\n}\n.ace_dark .ace_fold-widget.ace_closed {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==");\n}\n.ace_dark .ace_fold-widget:hover {\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\n    background-color: rgba(255, 255, 255, 0.1);\n}\n.ace_dark .ace_fold-widget:active {\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\n}\n\n.ace_inline_button {\n    border: 1px solid lightgray;\n    display: inline-block;\n    margin: -1px 8px;\n    padding: 0 5px;\n    pointer-events: auto;\n    cursor: pointer;\n}\n.ace_inline_button:hover {\n    border-color: gray;\n    background: rgba(200,200,200,0.2);\n    display: inline-block;\n    pointer-events: auto;\n}\n\n.ace_fold-widget.ace_invalid {\n    background-color: #FFB4B4;\n    border-color: #DE5555;\n}\n\n.ace_fade-fold-widgets .ace_fold-widget {\n    transition: opacity 0.4s ease 0.05s;\n    opacity: 0;\n}\n\n.ace_fade-fold-widgets:hover .ace_fold-widget {\n    transition: opacity 0.05s ease 0.05s;\n    opacity:1;\n}\n\n.ace_underline {\n    text-decoration: underline;\n}\n\n.ace_bold {\n    font-weight: bold;\n}\n\n.ace_nobold .ace_bold {\n    font-weight: normal;\n}\n\n.ace_italic {\n    font-style: italic;\n}\n\n\n.ace_error-marker {\n    background-color: rgba(255, 0, 0,0.2);\n    position: absolute;\n    z-index: 9;\n}\n\n.ace_highlight-marker {\n    background-color: rgba(255, 255, 0,0.2);\n    position: absolute;\n    z-index: 8;\n}\n\n.ace_mobile-menu {\n    position: absolute;\n    line-height: 1.5;\n    border-radius: 4px;\n    -ms-user-select: none;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    user-select: none;\n    background: white;\n    box-shadow: 1px 3px 2px grey;\n    border: 1px solid #dcdcdc;\n    color: black;\n}\n.ace_dark > .ace_mobile-menu {\n    background: #333;\n    color: #ccc;\n    box-shadow: 1px 3px 2px grey;\n    border: 1px solid #444;\n\n}\n.ace_mobile-button {\n    padding: 2px;\n    cursor: pointer;\n    overflow: hidden;\n}\n.ace_mobile-button:hover {\n    background-color: #eee;\n    opacity:1;\n}\n.ace_mobile-button:active {\n    background-color: #ddd;\n}\n\n.ace_placeholder {\n    font-family: arial;\n    transform: scale(0.9);\n    transform-origin: left;\n    white-space: pre;\n    opacity: 0.7;\n    margin: 0 10px;\n}\n\n.ace_ghost_text {\n    opacity: 0.5;\n    font-style: italic;\n    white-space: pre;\n}';
            /***/ },
            /***/ 4594: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_153853__) {
                "use strict";
                /* provided dependency */ var console = __nested_webpack_require_153853__(3716);
                var oop = __nested_webpack_require_153853__(2011);
                var applyDelta = __nested_webpack_require_153853__(4096)/* .applyDelta */ .B;
                var EventEmitter = __nested_webpack_require_153853__(7858)/* .EventEmitter */ .v;
                var Range = __nested_webpack_require_153853__(3069)/* .Range */ .e;
                var Anchor = __nested_webpack_require_153853__(8558)/* .Anchor */ .e;
                /**
 * Contains the text of the document. Document can be attached to several [[EditSession `EditSession`]]s. 
 * At its core, `Document`s are just an array of strings, with each row in the document matching up to the array index.
 **/ var Document = /*#__PURE__*/ function() {
                    function Document(textOrLines) {
                        _class_call_check(this, Document);
                        this.$lines = [
                            ""
                        ];
                        // There has to be one line at least in the document. If you pass an empty
                        // string to the insert function, nothing will happen. Workaround.
                        if (textOrLines.length === 0) {
                            this.$lines = [
                                ""
                            ];
                        } else if (Array.isArray(textOrLines)) {
                            this.insertMergedLines({
                                row: 0,
                                column: 0
                            }, textOrLines);
                        } else {
                            this.insert({
                                row: 0,
                                column: 0
                            }, textOrLines);
                        }
                    }
                    _create_class(Document, [
                        {
                            /**
     * Replaces all the lines in the current `Document` with the value of `text`.
     *
     * @param {String} text The text to use
     **/ key: "setValue",
                            value: function setValue(text) {
                                var len = this.getLength() - 1;
                                this.remove(new Range(0, 0, len, this.getLine(len).length));
                                this.insert({
                                    row: 0,
                                    column: 0
                                }, text || "");
                            }
                        },
                        {
                            /**
     * Returns all the lines in the document as a single string, joined by the new line character.
     **/ key: "getValue",
                            value: function getValue() {
                                return this.getAllLines().join(this.getNewLineCharacter());
                            }
                        },
                        {
                            /** 
     * Creates a new `Anchor` to define a floating point in the document.
     * @param {Number} row The row number to use
     * @param {Number} column The column number to use
     *
     **/ key: "createAnchor",
                            value: function createAnchor(row, column) {
                                return new Anchor(this, row, column);
                            }
                        },
                        {
                            key: "$detectNewLine",
                            value: function $detectNewLine(text) {
                                var match = text.match(/^.*?(\r\n|\r|\n)/m);
                                this.$autoNewLine = match ? match[1] : "\n";
                                this._signal("changeNewLineMode");
                            }
                        },
                        {
                            /**
     * Returns the newline character that's being used, depending on the value of `newLineMode`. 
     * @returns {String} If `newLineMode == windows`, `\r\n` is returned.  
     *  If `newLineMode == unix`, `\n` is returned.  
     *  If `newLineMode == auto`, the value of `autoNewLine` is returned.
     *
     **/ key: "getNewLineCharacter",
                            value: function getNewLineCharacter() {
                                switch(this.$newLineMode){
                                    case "windows":
                                        return "\r\n";
                                    case "unix":
                                        return "\n";
                                    default:
                                        return this.$autoNewLine || "\n";
                                }
                            }
                        },
                        {
                            /**
     * [Sets the new line mode.]{: #Document.setNewLineMode.desc}
     * @param {String} newLineMode [The newline mode to use; can be either `windows`, `unix`, or `auto`]{: #Document.setNewLineMode.param}
     *
     **/ key: "setNewLineMode",
                            value: function setNewLineMode(newLineMode) {
                                if (this.$newLineMode === newLineMode) return;
                                this.$newLineMode = newLineMode;
                                this._signal("changeNewLineMode");
                            }
                        },
                        {
                            /**
     * [Returns the type of newlines being used; either `windows`, `unix`, or `auto`]{: #Document.getNewLineMode}
     * @returns {String}
     **/ key: "getNewLineMode",
                            value: function getNewLineMode() {
                                return this.$newLineMode;
                            }
                        },
                        {
                            /**
     * Returns `true` if `text` is a newline character (either `\r\n`, `\r`, or `\n`).
     * @param {String} text The text to check
     *
     **/ key: "isNewLine",
                            value: function isNewLine(text) {
                                return text == "\r\n" || text == "\r" || text == "\n";
                            }
                        },
                        {
                            /**
     * Returns a verbatim copy of the given line as it is in the document
     * @param {Number} row The row index to retrieve
     *
     **/ key: "getLine",
                            value: function getLine(row) {
                                return this.$lines[row] || "";
                            }
                        },
                        {
                            /**
     * Returns an array of strings of the rows between `firstRow` and `lastRow`. This function is inclusive of `lastRow`.
     * @param {Number} firstRow The first row index to retrieve
     * @param {Number} lastRow The final row index to retrieve
     *
     **/ key: "getLines",
                            value: function getLines(firstRow, lastRow) {
                                return this.$lines.slice(firstRow, lastRow + 1);
                            }
                        },
                        {
                            /**
     * Returns all lines in the document as string array.
     **/ key: "getAllLines",
                            value: function getAllLines() {
                                return this.getLines(0, this.getLength());
                            }
                        },
                        {
                            /**
     * Returns the number of rows in the document.
     **/ key: "getLength",
                            value: function getLength() {
                                return this.$lines.length;
                            }
                        },
                        {
                            /**
     * Returns all the text within `range` as a single string.
     * @param {Range} range The range to work with.
     * 
     * @returns {String}
     **/ key: "getTextRange",
                            value: function getTextRange(range) {
                                return this.getLinesForRange(range).join(this.getNewLineCharacter());
                            }
                        },
                        {
                            /**
     * Returns all the text within `range` as an array of lines.
     * @param {Range} range The range to work with.
     * 
     * @returns {string[]}
     **/ key: "getLinesForRange",
                            value: function getLinesForRange(range) {
                                var lines;
                                if (range.start.row === range.end.row) {
                                    // Handle a single-line range.
                                    lines = [
                                        this.getLine(range.start.row).substring(range.start.column, range.end.column)
                                    ];
                                } else {
                                    // Handle a multi-line range.
                                    lines = this.getLines(range.start.row, range.end.row);
                                    lines[0] = (lines[0] || "").substring(range.start.column);
                                    var l = lines.length - 1;
                                    if (range.end.row - range.start.row == l) lines[l] = lines[l].substring(0, range.end.column);
                                }
                                return lines;
                            }
                        },
                        {
                            // Deprecated methods retained for backwards compatibility.
                            key: "insertLines",
                            value: function insertLines(row, lines) {
                                console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
                                return this.insertFullLines(row, lines);
                            }
                        },
                        {
                            key: "removeLines",
                            value: function removeLines(firstRow, lastRow) {
                                console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
                                return this.removeFullLines(firstRow, lastRow);
                            }
                        },
                        {
                            key: "insertNewLine",
                            value: function insertNewLine(position) {
                                console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
                                return this.insertMergedLines(position, [
                                    "",
                                    ""
                                ]);
                            }
                        },
                        {
                            /**
     * Inserts a block of `text` at the indicated `position`.
     * @param {Position} position The position to start inserting at; it's an object that looks like `{ row: row, column: column}`
     * @param {String} text A chunk of text to insert
     * @returns {Object} The position ({row, column}) of the last line of `text`. If the length of `text` is 0, this function simply returns `position`. 
     *
     **/ key: "insert",
                            value: function insert(position, text) {
                                // Only detect new lines if the document has no line break yet.
                                if (this.getLength() <= 1) this.$detectNewLine(text);
                                return this.insertMergedLines(position, this.$split(text));
                            }
                        },
                        {
                            /**
     * Inserts `text` into the `position` at the current row. This method also triggers the `"change"` event.
     * 
     * This differs from the `insert` method in two ways:
     *   1. This does NOT handle newline characters (single-line text only).
     *   2. This is faster than the `insert` method for single-line text insertions.
     * 
     * @param {Object} position The position to insert at; it's an object that looks like `{ row: row, column: column}`
     * @param {String} text A chunk of text
     * @returns {Object} Returns an object containing the final row and column, like this:  
     *     ```
     *     {row: endRow, column: 0}
     *     ```
     **/ key: "insertInLine",
                            value: function insertInLine(position, text) {
                                var start = this.clippedPos(position.row, position.column);
                                var end = this.pos(position.row, position.column + text.length);
                                this.applyDelta({
                                    start: start,
                                    end: end,
                                    action: "insert",
                                    lines: [
                                        text
                                    ]
                                }, true);
                                return this.clonePos(end);
                            }
                        },
                        {
                            key: "clippedPos",
                            value: function clippedPos(row, column) {
                                var length = this.getLength();
                                if (row === undefined) {
                                    row = length;
                                } else if (row < 0) {
                                    row = 0;
                                } else if (row >= length) {
                                    row = length - 1;
                                    column = undefined;
                                }
                                var line = this.getLine(row);
                                if (column == undefined) column = line.length;
                                column = Math.min(Math.max(column, 0), line.length);
                                return {
                                    row: row,
                                    column: column
                                };
                            }
                        },
                        {
                            key: "clonePos",
                            value: function clonePos(pos) {
                                return {
                                    row: pos.row,
                                    column: pos.column
                                };
                            }
                        },
                        {
                            key: "pos",
                            value: function pos(row, column) {
                                return {
                                    row: row,
                                    column: column
                                };
                            }
                        },
                        {
                            key: "$clipPosition",
                            value: function $clipPosition(position) {
                                var length = this.getLength();
                                if (position.row >= length) {
                                    position.row = Math.max(0, length - 1);
                                    position.column = this.getLine(length - 1).length;
                                } else {
                                    position.row = Math.max(0, position.row);
                                    position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
                                }
                                return position;
                            }
                        },
                        {
                            /**
     * Fires whenever the document changes.
     *
     * Several methods trigger different `"change"` events. Below is a list of each action type, followed by each property that's also available:
     *
     *  * `"insert"`
     *    * `range`: the [[Range]] of the change within the document
     *    * `lines`: the lines being added
     *  * `"remove"`
     *    * `range`: the [[Range]] of the change within the document
     *    * `lines`: the lines being removed
     *
     * @event change
     * @param {Object} e Contains at least one property called `"action"`. `"action"` indicates the action that triggered the change. Each action also has a set of additional properties.
     *
     **/ /**
     * Inserts the elements in `lines` into the document as full lines (does not merge with existing line), starting at the row index given by `row`. This method also triggers the `"change"` event.
     * @param {Number} row The index of the row to insert at
     * @param {string[]} lines An array of strings
     * @returns {Object} Contains the final row and column, like this:  
     *   ```
     *   {row: endRow, column: 0}
     *   ```  
     *   If `lines` is empty, this function returns an object containing the current row, and column, like this:  
     *   ``` 
     *   {row: row, column: 0}
     *   ```
     *
     **/ key: "insertFullLines",
                            value: function insertFullLines(row, lines) {
                                // Clip to document.
                                // Allow one past the document end.
                                row = Math.min(Math.max(row, 0), this.getLength());
                                // Calculate insertion point.
                                var column = 0;
                                if (row < this.getLength()) {
                                    // Insert before the specified row.
                                    lines = lines.concat([
                                        ""
                                    ]);
                                    column = 0;
                                } else {
                                    // Insert after the last row in the document.
                                    lines = [
                                        ""
                                    ].concat(lines);
                                    row--;
                                    column = this.$lines[row].length;
                                }
                                // Insert.
                                this.insertMergedLines({
                                    row: row,
                                    column: column
                                }, lines);
                            }
                        },
                        {
                            /**
     * Inserts the elements in `lines` into the document, starting at the position index given by `row`. This method also triggers the `"change"` event.
     * @param {Position} position
     * @param {string[]} lines An array of strings
     * @returns {Object} Contains the final row and column, like this:  
     *   ```
     *   {row: endRow, column: 0}
     *   ```  
     *   If `lines` is empty, this function returns an object containing the current row, and column, like this:  
     *   ``` 
     *   {row: row, column: 0}
     *   ```
     *
     **/ key: "insertMergedLines",
                            value: function insertMergedLines(position, lines) {
                                var start = this.clippedPos(position.row, position.column);
                                var end = {
                                    row: start.row + lines.length - 1,
                                    column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
                                };
                                this.applyDelta({
                                    start: start,
                                    end: end,
                                    action: "insert",
                                    lines: lines
                                });
                                return this.clonePos(end);
                            }
                        },
                        {
                            /**
     * Removes the `range` from the document.
     * @param {Range} range A specified Range to remove
     * @returns {Object} Returns the new `start` property of the range, which contains `startRow` and `startColumn`. If `range` is empty, this function returns the unmodified value of `range.start`.
     *
     **/ key: "remove",
                            value: function remove(range) {
                                var start = this.clippedPos(range.start.row, range.start.column);
                                var end = this.clippedPos(range.end.row, range.end.column);
                                this.applyDelta({
                                    start: start,
                                    end: end,
                                    action: "remove",
                                    lines: this.getLinesForRange({
                                        start: start,
                                        end: end
                                    })
                                });
                                return this.clonePos(start);
                            }
                        },
                        {
                            /**
     * Removes the specified columns from the `row`. This method also triggers a `"change"` event.
     * @param {Number} row The row to remove from
     * @param {Number} startColumn The column to start removing at 
     * @param {Number} endColumn The column to stop removing at
     * @returns {Object} Returns an object containing `startRow` and `startColumn`, indicating the new row and column values.<br/>If `startColumn` is equal to `endColumn`, this function returns nothing.
     *
     **/ key: "removeInLine",
                            value: function removeInLine(row, startColumn, endColumn) {
                                var start = this.clippedPos(row, startColumn);
                                var end = this.clippedPos(row, endColumn);
                                this.applyDelta({
                                    start: start,
                                    end: end,
                                    action: "remove",
                                    lines: this.getLinesForRange({
                                        start: start,
                                        end: end
                                    })
                                }, true);
                                return this.clonePos(start);
                            }
                        },
                        {
                            /**
     * Removes a range of full lines. This method also triggers the `"change"` event.
     * @param {Number} firstRow The first row to be removed
     * @param {Number} lastRow The last row to be removed
     * @returns {[String]} Returns all the removed lines.
     *
     **/ key: "removeFullLines",
                            value: function removeFullLines(firstRow, lastRow) {
                                // Clip to document.
                                firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
                                lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);
                                // Calculate deletion range.
                                // Delete the ending new line unless we're at the end of the document.
                                // If we're at the end of the document, delete the starting new line.
                                var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
                                var deleteLastNewLine = lastRow < this.getLength() - 1;
                                var startRow = deleteFirstNewLine ? firstRow - 1 : firstRow;
                                var startCol = deleteFirstNewLine ? this.getLine(startRow).length : 0;
                                var endRow = deleteLastNewLine ? lastRow + 1 : lastRow;
                                var endCol = deleteLastNewLine ? 0 : this.getLine(endRow).length;
                                var range = new Range(startRow, startCol, endRow, endCol);
                                // Store delelted lines with bounding newlines ommitted (maintains previous behavior).
                                var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
                                this.applyDelta({
                                    start: range.start,
                                    end: range.end,
                                    action: "remove",
                                    lines: this.getLinesForRange(range)
                                });
                                // Return the deleted lines.
                                return deletedLines;
                            }
                        },
                        {
                            /**
     * Removes the new line between `row` and the row immediately following it. This method also triggers the `"change"` event.
     * @param {Number} row The row to check
     *
     **/ key: "removeNewLine",
                            value: function removeNewLine(row) {
                                if (row < this.getLength() - 1 && row >= 0) {
                                    this.applyDelta({
                                        start: this.pos(row, this.getLine(row).length),
                                        end: this.pos(row + 1, 0),
                                        action: "remove",
                                        lines: [
                                            "",
                                            ""
                                        ]
                                    });
                                }
                            }
                        },
                        {
                            /**
     * Replaces a range in the document with the new `text`.
     * @param {Range} range A specified Range to replace
     * @param {String} text The new text to use as a replacement
     * @returns {Object} Returns an object containing the final row and column, like this:
     *     {row: endRow, column: 0}
     * If the text and range are empty, this function returns an object containing the current `range.start` value.
     * If the text is the exact same as what currently exists, this function returns an object containing the current `range.end` value.
     *
     **/ key: "replace",
                            value: function replace(range, text) {
                                if (!_instanceof(range, Range)) range = Range.fromPoints(range.start, range.end);
                                if (text.length === 0 && range.isEmpty()) return range.start;
                                // Shortcut: If the text we want to insert is the same as it is already
                                // in the document, we don't have to replace anything.
                                if (text == this.getTextRange(range)) return range.end;
                                this.remove(range);
                                var end;
                                if (text) {
                                    end = this.insert(range.start, text);
                                } else {
                                    end = range.start;
                                }
                                return end;
                            }
                        },
                        {
                            /**
     * Applies all changes in `deltas` to the document.
     * @param {Delta[]} deltas An array of delta objects (can include "insert" and "remove" actions)
     **/ key: "applyDeltas",
                            value: function applyDeltas(deltas) {
                                for(var i = 0; i < deltas.length; i++){
                                    this.applyDelta(deltas[i]);
                                }
                            }
                        },
                        {
                            /**
     * Reverts all changes in `deltas` from the document.
     * @param {Delta[]} deltas An array of delta objects (can include "insert" and "remove" actions)
     **/ key: "revertDeltas",
                            value: function revertDeltas(deltas) {
                                for(var i = deltas.length - 1; i >= 0; i--){
                                    this.revertDelta(deltas[i]);
                                }
                            }
                        },
                        {
                            /**
     * Applies `delta` to the document.
     * @param {Object} delta A delta object (can include "insert" and "remove" actions)
     * @param [doNotValidate]
     **/ key: "applyDelta",
                            value: function applyDelta1(delta, doNotValidate) {
                                var isInsert = delta.action == "insert";
                                // An empty range is a NOOP.
                                if (isInsert ? delta.lines.length <= 1 && !delta.lines[0] : !Range.comparePoints(delta.start, delta.end)) {
                                    return;
                                }
                                if (isInsert && delta.lines.length > 20000) {
                                    this.$splitAndapplyLargeDelta(delta, 20000);
                                } else {
                                    applyDelta(this.$lines, delta, doNotValidate);
                                    this._signal("change", delta);
                                }
                            }
                        },
                        {
                            key: "$safeApplyDelta",
                            value: function $safeApplyDelta(delta) {
                                var docLength = this.$lines.length;
                                // verify that delta is in the document to prevent applyDelta from corrupting lines array 
                                if (delta.action == "remove" && delta.start.row < docLength && delta.end.row < docLength || delta.action == "insert" && delta.start.row <= docLength) {
                                    this.applyDelta(delta);
                                }
                            }
                        },
                        {
                            key: "$splitAndapplyLargeDelta",
                            value: function $splitAndapplyLargeDelta(delta, MAX) {
                                // Split large insert deltas. This is necessary because:
                                //    1. We need to support splicing delta lines into the document via $lines.splice.apply(...)
                                //    2. fn.apply() doesn't work for a large number of params. The smallest threshold is on chrome 40 ~42000.
                                // we use 20000 to leave some space for actual stack
                                // 
                                // To Do: Ideally we'd be consistent and also split 'delete' deltas. We don't do this now, because delete
                                //        delta handling is too slow. If we make delete delta handling faster we can split all large deltas
                                //        as shown in https://gist.github.com/aldendaniels/8367109#file-document-snippet-js
                                //        If we do this, update validateDelta() to limit the number of lines in a delete delta.
                                var lines = delta.lines;
                                var l = lines.length - MAX + 1;
                                var row = delta.start.row;
                                var column = delta.start.column;
                                for(var from = 0, to = 0; from < l; from = to){
                                    to += MAX - 1;
                                    var chunk = lines.slice(from, to);
                                    chunk.push("");
                                    this.applyDelta({
                                        start: this.pos(row + from, column),
                                        end: this.pos(row + to, column = 0),
                                        action: delta.action,
                                        lines: chunk
                                    }, true);
                                }
                                // Update remaining delta.
                                delta.lines = lines.slice(from);
                                delta.start.row = row + from;
                                delta.start.column = column;
                                this.applyDelta(delta, true);
                            }
                        },
                        {
                            /**
     * Reverts `delta` from the document.
     * @param {Object} delta A delta object (can include "insert" and "remove" actions)
     **/ key: "revertDelta",
                            value: function revertDelta(delta) {
                                this.$safeApplyDelta({
                                    start: this.clonePos(delta.start),
                                    end: this.clonePos(delta.end),
                                    action: delta.action == "insert" ? "remove" : "insert",
                                    lines: delta.lines.slice()
                                });
                            }
                        },
                        {
                            /**
     * Converts an index position in a document to a `{row, column}` object.
     *
     * Index refers to the "absolute position" of a character in the document. For example:
     *
     * ```javascript
     * var x = 0; // 10 characters, plus one for newline
     * var y = -1;
     * ```
     * 
     * Here, `y` is an index 15: 11 characters for the first row, and 5 characters until `y` in the second.
     *
     * @param {Number} index An index to convert
     * @param {Number} startRow=0 The row from which to start the conversion
     * @returns {Object} A `{row, column}` object of the `index` position
     */ key: "indexToPosition",
                            value: function indexToPosition(index, startRow) {
                                var lines = this.$lines || this.getAllLines();
                                var newlineLength = this.getNewLineCharacter().length;
                                for(var i = startRow || 0, l = lines.length; i < l; i++){
                                    index -= lines[i].length + newlineLength;
                                    if (index < 0) return {
                                        row: i,
                                        column: index + lines[i].length + newlineLength
                                    };
                                }
                                return {
                                    row: l - 1,
                                    column: index + lines[l - 1].length + newlineLength
                                };
                            }
                        },
                        {
                            /**
     * Converts the `{row, column}` position in a document to the character's index.
     *
     * Index refers to the "absolute position" of a character in the document. For example:
     *
     * ```javascript
     * var x = 0; // 10 characters, plus one for newline
     * var y = -1;
     * ```
     * 
     * Here, `y` is an index 15: 11 characters for the first row, and 5 characters until `y` in the second.
     *
     * @param {Object} pos The `{row, column}` to convert
     * @param {Number} startRow=0 The row from which to start the conversion
     * @returns {Number} The index position in the document
     */ key: "positionToIndex",
                            value: function positionToIndex(pos, startRow) {
                                var lines = this.$lines || this.getAllLines();
                                var newlineLength = this.getNewLineCharacter().length;
                                var index = 0;
                                var row = Math.min(pos.row, lines.length);
                                for(var i = startRow || 0; i < row; ++i)index += lines[i].length + newlineLength;
                                return index + pos.column;
                            }
                        }
                    ]);
                    return Document;
                }();
                /**
 * Splits a string of text on any newline (`\n`) or carriage-return (`\r`) characters.
 *
 * @method $split
 * @param {String} text The text to work with
 * @returns {String} A String array, with each index containing a piece of the original `text` string.
 *
 **/ // check for IE split bug
                Document.prototype.$split = "aaa".split(/a/).length === 0 ? function(text) {
                    return text.replace(/\r\n|\r/g, "\n").split("\n");
                } : function(text) {
                    return text.split(/\r\n|\r|\n/);
                };
                Document.prototype.$autoNewLine = "";
                Document.prototype.$newLineMode = "auto";
                oop.implement(Document.prototype, EventEmitter);
                exports1.B = Document;
            /***/ },
            /***/ 8827: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_191859__) {
                "use strict";
                var isFullWidth = // For every keystroke this gets called once per char in the whole doc!!
                // Wouldn't hurt to make it a bit faster for c >= 0x1100
                function isFullWidth(c) {
                    if (c < 0x1100) return false;
                    return c >= 0x1100 && c <= 0x115F || c >= 0x11A3 && c <= 0x11A7 || c >= 0x11FA && c <= 0x11FF || c >= 0x2329 && c <= 0x232A || c >= 0x2E80 && c <= 0x2E99 || c >= 0x2E9B && c <= 0x2EF3 || c >= 0x2F00 && c <= 0x2FD5 || c >= 0x2FF0 && c <= 0x2FFB || c >= 0x3000 && c <= 0x303E || c >= 0x3041 && c <= 0x3096 || c >= 0x3099 && c <= 0x30FF || c >= 0x3105 && c <= 0x312D || c >= 0x3131 && c <= 0x318E || c >= 0x3190 && c <= 0x31BA || c >= 0x31C0 && c <= 0x31E3 || c >= 0x31F0 && c <= 0x321E || c >= 0x3220 && c <= 0x3247 || c >= 0x3250 && c <= 0x32FE || c >= 0x3300 && c <= 0x4DBF || c >= 0x4E00 && c <= 0xA48C || c >= 0xA490 && c <= 0xA4C6 || c >= 0xA960 && c <= 0xA97C || c >= 0xAC00 && c <= 0xD7A3 || c >= 0xD7B0 && c <= 0xD7C6 || c >= 0xD7CB && c <= 0xD7FB || c >= 0xF900 && c <= 0xFAFF || c >= 0xFE10 && c <= 0xFE19 || c >= 0xFE30 && c <= 0xFE52 || c >= 0xFE54 && c <= 0xFE66 || c >= 0xFE68 && c <= 0xFE6B || c >= 0xFF01 && c <= 0xFF60 || c >= 0xFFE0 && c <= 0xFFE6;
                };
                /* provided dependency */ var console = __nested_webpack_require_191859__(3716);
                var oop = __nested_webpack_require_191859__(2011);
                var lang = __nested_webpack_require_191859__(732);
                var BidiHandler = __nested_webpack_require_191859__(9457)/* .BidiHandler */ .l;
                var config = __nested_webpack_require_191859__(3294);
                var EventEmitter = __nested_webpack_require_191859__(7858)/* .EventEmitter */ .v;
                var Selection = __nested_webpack_require_191859__(4720)/* .Selection */ .Y;
                var TextMode = __nested_webpack_require_191859__(2113)/* .Mode */ .A;
                var Range = __nested_webpack_require_191859__(3069)/* .Range */ .e;
                var Document = __nested_webpack_require_191859__(4594)/* .Document */ .B;
                var BackgroundTokenizer = __nested_webpack_require_191859__(3486)/* .BackgroundTokenizer */ .V;
                var SearchHighlight = __nested_webpack_require_191859__(349)/* .SearchHighlight */ .t;
                //{ events
                /**
 *
 * Emitted when the document changes.
 * @event change
 * @param {Object} e An object containing a `delta` of information about the change.
 **/ /**
 * Emitted when the tab size changes, via [[EditSession.setTabSize]].
 *
 * @event changeTabSize
 **/ /**
 * Emitted when the ability to overwrite text changes, via [[EditSession.setOverwrite]].
 *
 * @event changeOverwrite
 **/ /**
 * Emitted when the gutter changes, either by setting or removing breakpoints, or when the gutter decorations change.
 *
 * @event changeBreakpoint
 **/ /**
 * Emitted when a front marker changes.
 *
 * @event changeFrontMarker
 **/ /**
 * Emitted when a back marker changes.
 *
 * @event changeBackMarker
 **/ /**
 * Emitted when an annotation changes, like through [[EditSession.setAnnotations]].
 *
 * @event changeAnnotation
 **/ /**
 * Emitted when a background tokenizer asynchronously processes new rows.
 * @event tokenizerUpdate
 *
 * @param {Object} e An object containing one property, `"data"`, that contains information about the changing rows
 *
 **/ /**
 * Emitted when the current mode changes.
 *
 * @event changeMode
 *
 **/ /**
 * Emitted when the wrap mode changes.
 *
 * @event changeWrapMode
 *
 **/ /**
 * Emitted when the wrapping limit changes.
 *
 * @event changeWrapLimit
 *
 **/ /**
 * Emitted when a code fold is added or removed.
 *
 * @event changeFold
 *
 **/ /**
 * Emitted when the scroll top changes.
 * @event changeScrollTop
 *
 * @param {Number} scrollTop The new scroll top value
 **/ /**
 * Emitted when the scroll left changes.
 * @event changeScrollLeft
 *
 * @param {Number} scrollLeft The new scroll left value
 **/ //}
                /**
 * Stores all the data about [[Editor `Editor`]] state providing easy way to change editors state.
 *
 * `EditSession` can be attached to only one [[Document `Document`]]. Same `Document` can be attached to several `EditSession`s.
 **/ var EditSession = /*#__PURE__*/ function() {
                    function EditSession(text, mode) {
                        _class_call_check(this, EditSession);
                        this.$breakpoints = [];
                        this.$decorations = [];
                        this.$frontMarkers = {};
                        this.$backMarkers = {};
                        this.$markerId = 1;
                        this.$undoSelect = true;
                        this.$foldData = [];
                        this.id = "session" + ++EditSession.$uid;
                        this.$foldData.toString = function() {
                            return this.join("\n");
                        };
                        // Set default background tokenizer with Text mode until editor session mode is set 
                        this.bgTokenizer = new BackgroundTokenizer(new TextMode().getTokenizer(), this);
                        var _self = this;
                        this.bgTokenizer.on("update", function(e) {
                            _self._signal("tokenizerUpdate", e);
                        });
                        this.on("changeFold", this.onChangeFold.bind(this));
                        this.$onChange = this.onChange.bind(this);
                        if (typeof text != "object" || !text.getLine) text = new Document(text);
                        this.setDocument(text);
                        this.selection = new Selection(this);
                        this.$bidiHandler = new BidiHandler(this);
                        config.resetOptions(this);
                        this.setMode(mode);
                        config._signal("session", this);
                        this.destroyed = false;
                    }
                    _create_class(EditSession, [
                        {
                            /**
     * Sets the `EditSession` to point to a new `Document`. If a `BackgroundTokenizer` exists, it also points to `doc`.
     *
     * @param {Document} doc The new `Document` to use
     *
     **/ key: "setDocument",
                            value: function setDocument(doc) {
                                if (this.doc) this.doc.off("change", this.$onChange);
                                this.doc = doc;
                                doc.on("change", this.$onChange, true);
                                this.bgTokenizer.setDocument(this.getDocument());
                                this.resetCaches();
                            }
                        },
                        {
                            /**
     * Returns the `Document` associated with this session.
     * @return {Document}
     **/ key: "getDocument",
                            value: function getDocument() {
                                return this.doc;
                            }
                        },
                        {
                            /**
     * @param {Number} docRow The row to work with
     *
     **/ key: "$resetRowCache",
                            value: function $resetRowCache(docRow) {
                                if (!docRow) {
                                    this.$docRowCache = [];
                                    this.$screenRowCache = [];
                                    return;
                                }
                                var l = this.$docRowCache.length;
                                var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
                                if (l > i) {
                                    this.$docRowCache.splice(i, l);
                                    this.$screenRowCache.splice(i, l);
                                }
                            }
                        },
                        {
                            key: "$getRowCacheIndex",
                            value: function $getRowCacheIndex(cacheArray, val) {
                                var low = 0;
                                var hi = cacheArray.length - 1;
                                while(low <= hi){
                                    var mid = low + hi >> 1;
                                    var c = cacheArray[mid];
                                    if (val > c) low = mid + 1;
                                    else if (val < c) hi = mid - 1;
                                    else return mid;
                                }
                                return low - 1;
                            }
                        },
                        {
                            key: "resetCaches",
                            value: function resetCaches() {
                                this.$modified = true;
                                this.$wrapData = [];
                                this.$rowLengthCache = [];
                                this.$resetRowCache(0);
                                if (!this.destroyed) this.bgTokenizer.start(0);
                            }
                        },
                        {
                            key: "onChangeFold",
                            value: function onChangeFold(e) {
                                var fold = e.data;
                                this.$resetRowCache(fold.start.row);
                            }
                        },
                        {
                            key: "onChange",
                            value: function onChange(delta) {
                                this.$modified = true;
                                this.$bidiHandler.onChange(delta);
                                this.$resetRowCache(delta.start.row);
                                var removedFolds = this.$updateInternalDataOnChange(delta);
                                if (!this.$fromUndo && this.$undoManager) {
                                    if (removedFolds && removedFolds.length) {
                                        this.$undoManager.add({
                                            action: "removeFolds",
                                            folds: removedFolds
                                        }, this.mergeUndoDeltas);
                                        this.mergeUndoDeltas = true;
                                    }
                                    this.$undoManager.add(delta, this.mergeUndoDeltas);
                                    this.mergeUndoDeltas = true;
                                    this.$informUndoManager.schedule();
                                }
                                this.bgTokenizer.$updateOnChange(delta);
                                this._signal("change", delta);
                            }
                        },
                        {
                            /**
     * Sets the session text.
     * @param {String} text The new text to place
     *
     **/ key: "setValue",
                            value: function setValue(text) {
                                this.doc.setValue(text);
                                this.selection.moveTo(0, 0);
                                this.$resetRowCache(0);
                                this.setUndoManager(this.$undoManager);
                                this.getUndoManager().reset();
                            }
                        },
                        {
                            /**
     * Returns the current [[Document `Document`]] as a string.
     * @method toString
     * @returns {String}
     * @alias EditSession.getValue
     *
     **/ key: "toString",
                            value: function toString() {
                                return this.doc.getValue();
                            }
                        },
                        {
                            /**
     * Returns selection object.
     **/ key: "getSelection",
                            value: function getSelection() {
                                return this.selection;
                            }
                        },
                        {
                            /**
     * {:BackgroundTokenizer.getState}
     * @param {Number} row The row to start at
     *
     * @related BackgroundTokenizer.getState
     **/ key: "getState",
                            value: function getState(row) {
                                return this.bgTokenizer.getState(row);
                            }
                        },
                        {
                            /**
     * Starts tokenizing at the row indicated. Returns a list of objects of the tokenized rows.
     * @param {Number} row The row to start at
     * @returns {Token[]}
     **/ key: "getTokens",
                            value: function getTokens(row) {
                                return this.bgTokenizer.getTokens(row);
                            }
                        },
                        {
                            /**
     * Returns an object indicating the token at the current row. The object has two properties: `index` and `start`.
     * @param {Number} row The row number to retrieve from
     * @param {Number} column The column number to retrieve from
     * @returns {Token}
     *
     **/ key: "getTokenAt",
                            value: function getTokenAt(row, column) {
                                var tokens = this.bgTokenizer.getTokens(row);
                                var token, c = 0;
                                if (column == null) {
                                    var i = tokens.length - 1;
                                    c = this.getLine(row).length;
                                } else {
                                    for(var i = 0; i < tokens.length; i++){
                                        c += tokens[i].value.length;
                                        if (c >= column) break;
                                    }
                                }
                                token = tokens[i];
                                if (!token) return null;
                                token.index = i;
                                token.start = c - token.value.length;
                                return token;
                            }
                        },
                        {
                            /**
     * Sets the undo manager.
     * @param {UndoManager} undoManager The new undo manager
     *
     *
     **/ key: "setUndoManager",
                            value: function setUndoManager(undoManager) {
                                this.$undoManager = undoManager;
                                if (this.$informUndoManager) this.$informUndoManager.cancel();
                                if (undoManager) {
                                    var _$self = this;
                                    undoManager.addSession(this);
                                    this.$syncInformUndoManager = function() {
                                        _$self.$informUndoManager.cancel();
                                        _$self.mergeUndoDeltas = false;
                                    };
                                    this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
                                } else {
                                    this.$syncInformUndoManager = function() {};
                                }
                            }
                        },
                        {
                            /**
     * starts a new group in undo history
     **/ key: "markUndoGroup",
                            value: function markUndoGroup() {
                                if (this.$syncInformUndoManager) this.$syncInformUndoManager();
                            }
                        },
                        {
                            /**
     * Returns the current undo manager.
     **/ key: "getUndoManager",
                            value: function getUndoManager() {
                                return this.$undoManager || this.$defaultUndoManager;
                            }
                        },
                        {
                            /**
     * Returns the current value for tabs. If the user is using soft tabs, this will be a series of spaces (defined by [[EditSession.getTabSize `getTabSize()`]]); otherwise it's simply `'\t'`.
     **/ key: "getTabString",
                            value: function getTabString() {
                                if (this.getUseSoftTabs()) {
                                    return lang.stringRepeat(" ", this.getTabSize());
                                } else {
                                    return "	";
                                }
                            }
                        },
                        {
                            /**
     * Pass `true` to enable the use of soft tabs. Soft tabs means you're using spaces instead of the tab character (`'\t'`).
     * @param {Boolean} val Value indicating whether or not to use soft tabs
     **/ key: "setUseSoftTabs",
                            value: function setUseSoftTabs(val) {
                                this.setOption("useSoftTabs", val);
                            }
                        },
                        {
                            /**
     * Returns `true` if soft tabs are being used, `false` otherwise.
     * @returns {Boolean}
     **/ key: "getUseSoftTabs",
                            value: function getUseSoftTabs() {
                                // todo might need more general way for changing settings from mode, but this is ok for now
                                return this.$useSoftTabs && !this.$mode.$indentWithTabs;
                            }
                        },
                        {
                            /**
     * Set the number of spaces that define a soft tab; for example, passing in `4` transforms the soft tabs to be equivalent to four spaces. This function also emits the `changeTabSize` event.
     * @param {Number} tabSize The new tab size
     **/ key: "setTabSize",
                            value: function setTabSize(tabSize) {
                                this.setOption("tabSize", tabSize);
                            }
                        },
                        {
                            /**
     * Returns the current tab size.
     **/ key: "getTabSize",
                            value: function getTabSize() {
                                return this.$tabSize;
                            }
                        },
                        {
                            /**
     * Returns `true` if the character at the position is a soft tab.
     * @param {Object} position The position to check
     *
     **/ key: "isTabStop",
                            value: function isTabStop(position) {
                                return this.$useSoftTabs && position.column % this.$tabSize === 0;
                            }
                        },
                        {
                            /**
     * Set whether keyboard navigation of soft tabs moves the cursor within the soft tab, rather than over
     * @param {Boolean} navigateWithinSoftTabs Value indicating whether or not to navigate within soft tabs
     **/ key: "setNavigateWithinSoftTabs",
                            value: function setNavigateWithinSoftTabs(navigateWithinSoftTabs) {
                                this.setOption("navigateWithinSoftTabs", navigateWithinSoftTabs);
                            }
                        },
                        {
                            /**
     * Returns `true` if keyboard navigation moves the cursor within soft tabs, `false` if it moves the cursor over soft tabs.
     * @returns {Boolean}
     **/ key: "getNavigateWithinSoftTabs",
                            value: function getNavigateWithinSoftTabs() {
                                return this.$navigateWithinSoftTabs;
                            }
                        },
                        {
                            /**
     * Pass in `true` to enable overwrites in your session, or `false` to disable.
     *
     * If overwrites is enabled, any text you enter will type over any text after it. If the value of `overwrite` changes, this function also emits the `changeOverwrite` event.
     *
     * @param {Boolean} overwrite Defines whether or not to set overwrites
     *
     *
     **/ key: "setOverwrite",
                            value: function setOverwrite(overwrite) {
                                this.setOption("overwrite", overwrite);
                            }
                        },
                        {
                            /**
     * Returns `true` if overwrites are enabled; `false` otherwise.
     **/ key: "getOverwrite",
                            value: function getOverwrite() {
                                return this.$overwrite;
                            }
                        },
                        {
                            /**
     * Sets the value of overwrite to the opposite of whatever it currently is.
     **/ key: "toggleOverwrite",
                            value: function toggleOverwrite() {
                                this.setOverwrite(!this.$overwrite);
                            }
                        },
                        {
                            /**
     * Adds `className` to the `row`, to be used for CSS stylings and whatnot.
     * @param {Number} row The row number
     * @param {String} className The class to add
     *
     **/ key: "addGutterDecoration",
                            value: function addGutterDecoration(row, className) {
                                if (!this.$decorations[row]) this.$decorations[row] = "";
                                this.$decorations[row] += " " + className;
                                this._signal("changeBreakpoint", {});
                            }
                        },
                        {
                            /**
     * Removes `className` from the `row`.
     * @param {Number} row The row number
     * @param {String} className The class to add
     *
     **/ key: "removeGutterDecoration",
                            value: function removeGutterDecoration(row, className) {
                                this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
                                this._signal("changeBreakpoint", {});
                            }
                        },
                        {
                            /**
     * Returns an array of strings, indicating the breakpoint class (if any) applied to each row.
     * @returns {[String]}
     **/ key: "getBreakpoints",
                            value: function getBreakpoints() {
                                return this.$breakpoints;
                            }
                        },
                        {
                            /**
     * Sets a breakpoint on every row number given by `rows`. This function also emites the `'changeBreakpoint'` event.
     * @param {Array} rows An array of row indices
     *
     **/ key: "setBreakpoints",
                            value: function setBreakpoints(rows) {
                                this.$breakpoints = [];
                                for(var i = 0; i < rows.length; i++){
                                    this.$breakpoints[rows[i]] = "ace_breakpoint";
                                }
                                this._signal("changeBreakpoint", {});
                            }
                        },
                        {
                            /**
     * Removes all breakpoints on the rows. This function also emits the `'changeBreakpoint'` event.
     **/ key: "clearBreakpoints",
                            value: function clearBreakpoints() {
                                this.$breakpoints = [];
                                this._signal("changeBreakpoint", {});
                            }
                        },
                        {
                            /**
     * Sets a breakpoint on the row number given by `row`. This function also emits the `'changeBreakpoint'` event.
     * @param {Number} row A row index
     * @param {String} className Class of the breakpoint
     *
     **/ key: "setBreakpoint",
                            value: function setBreakpoint(row, className) {
                                if (className === undefined) className = "ace_breakpoint";
                                if (className) this.$breakpoints[row] = className;
                                else delete this.$breakpoints[row];
                                this._signal("changeBreakpoint", {});
                            }
                        },
                        {
                            /**
     * Removes a breakpoint on the row number given by `row`. This function also emits the `'changeBreakpoint'` event.
     * @param {Number} row A row index
     *
     **/ key: "clearBreakpoint",
                            value: function clearBreakpoint(row) {
                                delete this.$breakpoints[row];
                                this._signal("changeBreakpoint", {});
                            }
                        },
                        {
                            /**
     * Adds a new marker to the given `Range`. If `inFront` is `true`, a front marker is defined, and the `'changeFrontMarker'` event fires; otherwise, the `'changeBackMarker'` event fires.
     * @param {Range} range Define the range of the marker
     * @param {String} clazz Set the CSS class for the marker
     * @param {Function | String} type Identify the type of the marker
     * @param {Boolean} inFront Set to `true` to establish a front marker
     *
     * @return {Number} The new marker id
     **/ key: "addMarker",
                            value: function addMarker(range, clazz, type, inFront) {
                                var id = this.$markerId++;
                                var marker = {
                                    range: range,
                                    type: type || "line",
                                    renderer: typeof type == "function" ? type : null,
                                    clazz: clazz,
                                    inFront: !!inFront,
                                    id: id
                                };
                                if (inFront) {
                                    this.$frontMarkers[id] = marker;
                                    this._signal("changeFrontMarker");
                                } else {
                                    this.$backMarkers[id] = marker;
                                    this._signal("changeBackMarker");
                                }
                                return id;
                            }
                        },
                        {
                            /**
     * Adds a dynamic marker to the session.
     * @param {Object} marker object with update method
     * @param {Boolean} inFront Set to `true` to establish a front marker
     *
     * @return {Object} The added marker
     **/ key: "addDynamicMarker",
                            value: function addDynamicMarker(marker, inFront) {
                                if (!marker.update) return;
                                var id = this.$markerId++;
                                marker.id = id;
                                marker.inFront = !!inFront;
                                if (inFront) {
                                    this.$frontMarkers[id] = marker;
                                    this._signal("changeFrontMarker");
                                } else {
                                    this.$backMarkers[id] = marker;
                                    this._signal("changeBackMarker");
                                }
                                return marker;
                            }
                        },
                        {
                            /**
     * Removes the marker with the specified ID. If this marker was in front, the `'changeFrontMarker'` event is emitted. If the marker was in the back, the `'changeBackMarker'` event is emitted.
     * @param {Number} markerId A number representing a marker
     *
     **/ key: "removeMarker",
                            value: function removeMarker(markerId) {
                                var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
                                if (!marker) return;
                                var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
                                delete markers[markerId];
                                this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
                            }
                        },
                        {
                            /**
     * Returns an object containing all of the markers, either front or back.
     * @param {Boolean} inFront If `true`, indicates you only want front markers; `false` indicates only back markers
     *
     * @returns {Object}
     **/ key: "getMarkers",
                            value: function getMarkers(inFront) {
                                return inFront ? this.$frontMarkers : this.$backMarkers;
                            }
                        },
                        {
                            key: "highlight",
                            value: function highlight(re) {
                                if (!this.$searchHighlight) {
                                    var highlight = new SearchHighlight(null, "ace_selected-word", "text");
                                    this.$searchHighlight = this.addDynamicMarker(highlight);
                                }
                                this.$searchHighlight.setRegexp(re);
                            }
                        },
                        {
                            // experimental
                            key: "highlightLines",
                            value: function highlightLines(startRow, endRow, clazz, inFront) {
                                if (typeof endRow != "number") {
                                    clazz = endRow;
                                    endRow = startRow;
                                }
                                if (!clazz) clazz = "ace_step";
                                var range = new Range(startRow, 0, endRow, Infinity);
                                range.id = this.addMarker(range, clazz, "fullLine", inFront);
                                return range;
                            }
                        },
                        {
                            /*
     * Error:
     *  {
     *    row: 12,
     *    column: 2, //can be undefined
     *    text: "Missing argument",
     *    type: "error" // or "warning" or "info"
     *  }
     */ /**
     * Sets annotations for the `EditSession`. This functions emits the `'changeAnnotation'` event.
     * @param {Annotation[]} annotations A list of annotations
     *
     **/ key: "setAnnotations",
                            value: function setAnnotations(annotations) {
                                this.$annotations = annotations;
                                this._signal("changeAnnotation", {});
                            }
                        },
                        {
                            /**
     * Returns the annotations for the `EditSession`.
     * @returns {Annotation[]}
     **/ key: "getAnnotations",
                            value: function getAnnotations() {
                                return this.$annotations || [];
                            }
                        },
                        {
                            /**
     * Clears all the annotations for this session. This function also triggers the `'changeAnnotation'` event.
     **/ key: "clearAnnotations",
                            value: function clearAnnotations() {
                                this.setAnnotations([]);
                            }
                        },
                        {
                            /**
     * If `text` contains either the newline (`\n`) or carriage-return ('\r') characters, `$autoNewLine` stores that value.
     * @param {String} text A block of text
     *
     **/ key: "$detectNewLine",
                            value: function $detectNewLine(text) {
                                var match = text.match(/^.*?(\r?\n)/m);
                                if (match) {
                                    this.$autoNewLine = match[1];
                                } else {
                                    this.$autoNewLine = "\n";
                                }
                            }
                        },
                        {
                            /**
     * Given a starting row and column, this method returns the `Range` of the first word boundary it finds.
     * @param {Number} row The row to start at
     * @param {Number} column The column to start at
     *
     * @returns {Range}
     **/ key: "getWordRange",
                            value: function getWordRange(row, column) {
                                var line = this.getLine(row);
                                var inToken = false;
                                if (column > 0) inToken = !!line.charAt(column - 1).match(this.tokenRe);
                                if (!inToken) inToken = !!line.charAt(column).match(this.tokenRe);
                                if (inToken) var re = this.tokenRe;
                                else if (/^\s+$/.test(line.slice(column - 1, column + 1))) var re = /\s/;
                                else var re = this.nonTokenRe;
                                var start = column;
                                if (start > 0) {
                                    do {
                                        start--;
                                    }while (start >= 0 && line.charAt(start).match(re));
                                    start++;
                                }
                                var end = column;
                                while(end < line.length && line.charAt(end).match(re)){
                                    end++;
                                }
                                return new Range(row, start, row, end);
                            }
                        },
                        {
                            /**
     * Gets the range of a word, including its right whitespace.
     * @param {Number} row The row number to start from
     * @param {Number} column The column number to start from
     *
     * @return {Range}
     **/ key: "getAWordRange",
                            value: function getAWordRange(row, column) {
                                var wordRange = this.getWordRange(row, column);
                                var line = this.getLine(wordRange.end.row);
                                while(line.charAt(wordRange.end.column).match(/[ \t]/)){
                                    wordRange.end.column += 1;
                                }
                                return wordRange;
                            }
                        },
                        {
                            /**
     * {:Document.setNewLineMode.desc}
     * @param {String} newLineMode {:Document.setNewLineMode.param}
     *
     *
     * @related Document.setNewLineMode
     **/ key: "setNewLineMode",
                            value: function setNewLineMode(newLineMode) {
                                this.doc.setNewLineMode(newLineMode);
                            }
                        },
                        {
                            /**
     *
     * Returns the current new line mode.
     * @returns {String}
     * @related Document.getNewLineMode
     **/ key: "getNewLineMode",
                            value: function getNewLineMode() {
                                return this.doc.getNewLineMode();
                            }
                        },
                        {
                            /**
     * Identifies if you want to use a worker for the `EditSession`.
     * @param {Boolean} useWorker Set to `true` to use a worker
     *
     **/ key: "setUseWorker",
                            value: function setUseWorker(useWorker) {
                                this.setOption("useWorker", useWorker);
                            }
                        },
                        {
                            /**
     * Returns `true` if workers are being used.
     **/ key: "getUseWorker",
                            value: function getUseWorker() {
                                return this.$useWorker;
                            }
                        },
                        {
                            /**
     * Reloads all the tokens on the current session. This function calls [[BackgroundTokenizer.start `BackgroundTokenizer.start ()`]] to all the rows; it also emits the `'tokenizerUpdate'` event.
     **/ key: "onReloadTokenizer",
                            value: function onReloadTokenizer(e) {
                                var rows = e.data;
                                this.bgTokenizer.start(rows.first);
                                this._signal("tokenizerUpdate", e);
                            }
                        },
                        {
                            /**
     * Sets a new text mode for the `EditSession`. This method also emits the `'changeMode'` event. If a [[BackgroundTokenizer `BackgroundTokenizer`]] is set, the `'tokenizerUpdate'` event is also emitted.
     * @param {TextMode} mode Set a new text mode
     * @param {Function} cb optional callback
     *
     **/ key: "setMode",
                            value: function setMode(mode, cb) {
                                if (mode && typeof mode === "object") {
                                    if (mode.getTokenizer) return this.$onChangeMode(mode);
                                    var options = mode;
                                    var path = options.path;
                                } else {
                                    path = mode || "ace/mode/text";
                                }
                                // this is needed if ace isn't on require path (e.g tests in node)
                                if (!this.$modes["ace/mode/text"]) this.$modes["ace/mode/text"] = new TextMode();
                                if (this.$modes[path] && !options) {
                                    this.$onChangeMode(this.$modes[path]);
                                    cb && cb();
                                    return;
                                }
                                // load on demand
                                this.$modeId = path;
                                config.loadModule([
                                    "mode",
                                    path
                                ], (function(m) {
                                    if (this.$modeId !== path) return cb && cb();
                                    if (this.$modes[path] && !options) {
                                        this.$onChangeMode(this.$modes[path]);
                                    } else if (m && m.Mode) {
                                        m = new m.Mode(options);
                                        if (!options) {
                                            this.$modes[path] = m;
                                            m.$id = path;
                                        }
                                        this.$onChangeMode(m);
                                    }
                                    cb && cb();
                                }).bind(this));
                                // set mode to text until loading is finished
                                if (!this.$mode) this.$onChangeMode(this.$modes["ace/mode/text"], true);
                            }
                        },
                        {
                            key: "$onChangeMode",
                            value: function $onChangeMode(mode, $isPlaceholder) {
                                if (!$isPlaceholder) this.$modeId = mode.$id;
                                if (this.$mode === mode) return;
                                var oldMode = this.$mode;
                                this.$mode = mode;
                                this.$stopWorker();
                                if (this.$useWorker) this.$startWorker();
                                var tokenizer = mode.getTokenizer();
                                if (tokenizer.on !== undefined) {
                                    var onReloadTokenizer = this.onReloadTokenizer.bind(this);
                                    tokenizer.on("update", onReloadTokenizer);
                                }
                                this.bgTokenizer.setTokenizer(tokenizer);
                                this.bgTokenizer.setDocument(this.getDocument());
                                this.tokenRe = mode.tokenRe;
                                this.nonTokenRe = mode.nonTokenRe;
                                if (!$isPlaceholder) {
                                    // experimental method, used by c9 findiniles
                                    if (mode.attachToSession) mode.attachToSession(this);
                                    this.$options.wrapMethod.set.call(this, this.$wrapMethod);
                                    this.$setFolding(mode.foldingRules);
                                    this.bgTokenizer.start(0);
                                    this._emit("changeMode", {
                                        oldMode: oldMode,
                                        mode: mode
                                    });
                                }
                            }
                        },
                        {
                            key: "$stopWorker",
                            value: function $stopWorker() {
                                if (this.$worker) {
                                    this.$worker.terminate();
                                    this.$worker = null;
                                }
                            }
                        },
                        {
                            key: "$startWorker",
                            value: function $startWorker() {
                                try {
                                    this.$worker = this.$mode.createWorker(this);
                                } catch (e) {
                                    config.warn("Could not load worker", e);
                                    this.$worker = null;
                                }
                            }
                        },
                        {
                            /**
     * Returns the current text mode.
     * @returns {TextMode} The current text mode
     **/ key: "getMode",
                            value: function getMode() {
                                return this.$mode;
                            }
                        },
                        {
                            /**
     * This function sets the scroll top value. It also emits the `'changeScrollTop'` event.
     * @param {Number} scrollTop The new scroll top value
     *
     **/ key: "setScrollTop",
                            value: function setScrollTop(scrollTop) {
                                // TODO: should we force integer lineheight instead? scrollTop = Math.round(scrollTop); 
                                if (this.$scrollTop === scrollTop || isNaN(scrollTop)) return;
                                this.$scrollTop = scrollTop;
                                this._signal("changeScrollTop", scrollTop);
                            }
                        },
                        {
                            /**
     * [Returns the value of the distance between the top of the editor and the topmost part of the visible content.]{: #EditSession.getScrollTop}
     * @returns {Number}
     **/ key: "getScrollTop",
                            value: function getScrollTop() {
                                return this.$scrollTop;
                            }
                        },
                        {
                            /**
     * [Sets the value of the distance between the left of the editor and the leftmost part of the visible content.]{: #EditSession.setScrollLeft}
     **/ key: "setScrollLeft",
                            value: function setScrollLeft(scrollLeft) {
                                // scrollLeft = Math.round(scrollLeft);
                                if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft)) return;
                                this.$scrollLeft = scrollLeft;
                                this._signal("changeScrollLeft", scrollLeft);
                            }
                        },
                        {
                            /**
     * [Returns the value of the distance between the left of the editor and the leftmost part of the visible content.]{: #EditSession.getScrollLeft}
     * @returns {Number}
     **/ key: "getScrollLeft",
                            value: function getScrollLeft() {
                                return this.$scrollLeft;
                            }
                        },
                        {
                            /**
     * Returns the width of the screen.
     * @returns {Number}
     **/ key: "getScreenWidth",
                            value: function getScreenWidth() {
                                this.$computeWidth();
                                if (this.lineWidgets) return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
                                return this.screenWidth;
                            }
                        },
                        {
                            key: "getLineWidgetMaxWidth",
                            value: function getLineWidgetMaxWidth() {
                                if (this.lineWidgetsWidth != null) return this.lineWidgetsWidth;
                                var width = 0;
                                this.lineWidgets.forEach(function(w) {
                                    if (w && w.screenWidth > width) width = w.screenWidth;
                                });
                                return this.lineWidgetWidth = width;
                            }
                        },
                        {
                            key: "$computeWidth",
                            value: function $computeWidth(force) {
                                if (this.$modified || force) {
                                    this.$modified = false;
                                    if (this.$useWrapMode) return this.screenWidth = this.$wrapLimit;
                                    var lines = this.doc.getAllLines();
                                    var cache = this.$rowLengthCache;
                                    var longestScreenLine = 0;
                                    var foldIndex = 0;
                                    var foldLine = this.$foldData[foldIndex];
                                    var foldStart = foldLine ? foldLine.start.row : Infinity;
                                    var len = lines.length;
                                    for(var i = 0; i < len; i++){
                                        if (i > foldStart) {
                                            i = foldLine.end.row + 1;
                                            if (i >= len) break;
                                            foldLine = this.$foldData[foldIndex++];
                                            foldStart = foldLine ? foldLine.start.row : Infinity;
                                        }
                                        if (cache[i] == null) cache[i] = this.$getStringScreenWidth(lines[i])[0];
                                        if (cache[i] > longestScreenLine) longestScreenLine = cache[i];
                                    }
                                    this.screenWidth = longestScreenLine;
                                }
                            }
                        },
                        {
                            /**
     * Returns a verbatim copy of the given line as it is in the document
     * @param {Number} row The row to retrieve from
     *
     * @returns {String}
     **/ key: "getLine",
                            value: function getLine(row) {
                                return this.doc.getLine(row);
                            }
                        },
                        {
                            /**
     * Returns an array of strings of the rows between `firstRow` and `lastRow`. This function is inclusive of `lastRow`.
     * @param {Number} firstRow The first row index to retrieve
     * @param {Number} lastRow The final row index to retrieve
     *
     * @returns {[String]}
     *
     **/ key: "getLines",
                            value: function getLines(firstRow, lastRow) {
                                return this.doc.getLines(firstRow, lastRow);
                            }
                        },
                        {
                            /**
     * Returns the number of rows in the document.
     * @returns {Number}
     **/ key: "getLength",
                            value: function getLength() {
                                return this.doc.getLength();
                            }
                        },
                        {
                            /**
     * {:Document.getTextRange.desc}
     * @param {Range} range The range to work with
     *
     * @returns {String}
     **/ key: "getTextRange",
                            value: function getTextRange(range) {
                                return this.doc.getTextRange(range || this.selection.getRange());
                            }
                        },
                        {
                            /**
     * Inserts a block of `text` and the indicated `position`.
     * @param {Object} position The position {row, column} to start inserting at
     * @param {String} text A chunk of text to insert
     * @returns {Object} The position of the last line of `text`. If the length of `text` is 0, this function simply returns `position`.
     *
     *
     **/ key: "insert",
                            value: function insert(position, text) {
                                return this.doc.insert(position, text);
                            }
                        },
                        {
                            /**
     * Removes the `range` from the document.
     * @param {Range} range A specified Range to remove
     * @returns {Object} The new `start` property of the range, which contains `startRow` and `startColumn`. If `range` is empty, this function returns the unmodified value of `range.start`.
     *
     * @related Document.remove
     *
     **/ key: "remove",
                            value: function remove(range) {
                                return this.doc.remove(range);
                            }
                        },
                        {
                            /**
     * Removes a range of full lines. This method also triggers the `'change'` event.
     * @param {Number} firstRow The first row to be removed
     * @param {Number} lastRow The last row to be removed
     * @returns {[String]} Returns all the removed lines.
     *
     * @related Document.removeFullLines
     *
     **/ key: "removeFullLines",
                            value: function removeFullLines(firstRow, lastRow) {
                                return this.doc.removeFullLines(firstRow, lastRow);
                            }
                        },
                        {
                            /**
     * Reverts previous changes to your document.
     * @param {Delta[]} deltas An array of previous changes
     * @param {Boolean} dontSelect [If `true`, doesn't select the range of where the change occured]{: #dontSelect}
     **/ key: "undoChanges",
                            value: function undoChanges(deltas, dontSelect) {
                                if (!deltas.length) return;
                                this.$fromUndo = true;
                                for(var i = deltas.length - 1; i != -1; i--){
                                    var delta = deltas[i];
                                    if (delta.action == "insert" || delta.action == "remove") {
                                        this.doc.revertDelta(delta);
                                    } else if (delta.folds) {
                                        this.addFolds(delta.folds);
                                    }
                                }
                                if (!dontSelect && this.$undoSelect) {
                                    if (deltas.selectionBefore) this.selection.fromJSON(deltas.selectionBefore);
                                    else this.selection.setRange(this.$getUndoSelection(deltas, true));
                                }
                                this.$fromUndo = false;
                            }
                        },
                        {
                            /**
     * Re-implements a previously undone change to your document.
     * @param {Delta[]} deltas An array of previous changes
     * @param {Boolean} dontSelect {:dontSelect}
     **/ key: "redoChanges",
                            value: function redoChanges(deltas, dontSelect) {
                                if (!deltas.length) return;
                                this.$fromUndo = true;
                                for(var i = 0; i < deltas.length; i++){
                                    var delta = deltas[i];
                                    if (delta.action == "insert" || delta.action == "remove") {
                                        this.doc.$safeApplyDelta(delta);
                                    }
                                }
                                if (!dontSelect && this.$undoSelect) {
                                    if (deltas.selectionAfter) this.selection.fromJSON(deltas.selectionAfter);
                                    else this.selection.setRange(this.$getUndoSelection(deltas, false));
                                }
                                this.$fromUndo = false;
                            }
                        },
                        {
                            /**
     * Enables or disables highlighting of the range where an undo occurred.
     * @param {Boolean} enable If `true`, selects the range of the reinserted change
     *      
     **/ key: "setUndoSelect",
                            value: function setUndoSelect(enable) {
                                this.$undoSelect = enable;
                            }
                        },
                        {
                            key: "$getUndoSelection",
                            value: function $getUndoSelection(deltas, isUndo) {
                                var isInsert = function isInsert(delta) {
                                    return isUndo ? delta.action !== "insert" : delta.action === "insert";
                                };
                                var range, point;
                                for(var i = 0; i < deltas.length; i++){
                                    var delta = deltas[i];
                                    if (!delta.start) continue; // skip folds
                                    if (!range) {
                                        if (isInsert(delta)) {
                                            range = Range.fromPoints(delta.start, delta.end);
                                        } else {
                                            range = Range.fromPoints(delta.start, delta.start);
                                        }
                                        continue;
                                    }
                                    if (isInsert(delta)) {
                                        point = delta.start;
                                        if (range.compare(point.row, point.column) == -1) {
                                            range.setStart(point);
                                        }
                                        point = delta.end;
                                        if (range.compare(point.row, point.column) == 1) {
                                            range.setEnd(point);
                                        }
                                    } else {
                                        point = delta.start;
                                        if (range.compare(point.row, point.column) == -1) {
                                            range = Range.fromPoints(delta.start, delta.start);
                                        }
                                    }
                                }
                                return range;
                            }
                        },
                        {
                            /**
     * Replaces a range in the document with the new `text`.
     *
     * @param {Range} range A specified Range to replace
     * @param {String} text The new text to use as a replacement
     * @returns {Object} An object containing the final row and column, like this:
     * ```
     * {row: endRow, column: 0}
     * ```
     * If the text and range are empty, this function returns an object containing the current `range.start` value.
     * If the text is the exact same as what currently exists, this function returns an object containing the current `range.end` value.
     *
     * @related Document.replace
     **/ key: "replace",
                            value: function replace(range, text) {
                                return this.doc.replace(range, text);
                            }
                        },
                        {
                            /**
     * Moves a range of text from the given range to the given position. `toPosition` is an object that looks like this:
     *  ```json
     *    { row: newRowLocation, column: newColumnLocation }
     *  ```
     * @param {Range} fromRange The range of text you want moved within the document
     * @param {Object} toPosition The location (row and column) where you want to move the text to
     * @param {boolean} copy
     * @returns {Range} The new range where the text was moved to.
     **/ key: "moveText",
                            value: function moveText(fromRange, toPosition, copy) {
                                var text = this.getTextRange(fromRange);
                                var folds = this.getFoldsInRange(fromRange);
                                var toRange = Range.fromPoints(toPosition, toPosition);
                                if (!copy) {
                                    this.remove(fromRange);
                                    var rowDiff = fromRange.start.row - fromRange.end.row;
                                    var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
                                    if (collDiff) {
                                        if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column) toRange.start.column += collDiff;
                                        if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column) toRange.end.column += collDiff;
                                    }
                                    if (rowDiff && toRange.start.row >= fromRange.end.row) {
                                        toRange.start.row += rowDiff;
                                        toRange.end.row += rowDiff;
                                    }
                                }
                                toRange.end = this.insert(toRange.start, text);
                                if (folds.length) {
                                    var oldStart = fromRange.start;
                                    var newStart = toRange.start;
                                    var rowDiff = newStart.row - oldStart.row;
                                    var collDiff = newStart.column - oldStart.column;
                                    this.addFolds(folds.map(function(x) {
                                        x = x.clone();
                                        if (x.start.row == oldStart.row) x.start.column += collDiff;
                                        if (x.end.row == oldStart.row) x.end.column += collDiff;
                                        x.start.row += rowDiff;
                                        x.end.row += rowDiff;
                                        return x;
                                    }));
                                }
                                return toRange;
                            }
                        },
                        {
                            /**
     * Indents all the rows, from `startRow` to `endRow` (inclusive), by prefixing each row with the token in `indentString`.
     *
     * If `indentString` contains the `'\t'` character, it's replaced by whatever is defined by [[EditSession.getTabString `getTabString()`]].
     * @param {Number} startRow Starting row
     * @param {Number} endRow Ending row
     * @param {String} indentString The indent token
     **/ key: "indentRows",
                            value: function indentRows(startRow, endRow, indentString) {
                                indentString = indentString.replace(/\t/g, this.getTabString());
                                for(var row = startRow; row <= endRow; row++)this.doc.insertInLine({
                                    row: row,
                                    column: 0
                                }, indentString);
                            }
                        },
                        {
                            /**
     * Outdents all the rows defined by the `start` and `end` properties of `range`.
     * @param {Range} range A range of rows
     *
     **/ key: "outdentRows",
                            value: function outdentRows(range) {
                                var rowRange = range.collapseRows();
                                var deleteRange = new Range(0, 0, 0, 0);
                                var size = this.getTabSize();
                                for(var i = rowRange.start.row; i <= rowRange.end.row; ++i){
                                    var line = this.getLine(i);
                                    deleteRange.start.row = i;
                                    deleteRange.end.row = i;
                                    for(var j = 0; j < size; ++j)if (line.charAt(j) != " ") break;
                                    if (j < size && line.charAt(j) == "	") {
                                        deleteRange.start.column = j;
                                        deleteRange.end.column = j + 1;
                                    } else {
                                        deleteRange.start.column = 0;
                                        deleteRange.end.column = j;
                                    }
                                    this.remove(deleteRange);
                                }
                            }
                        },
                        {
                            key: "$moveLines",
                            value: function $moveLines(firstRow, lastRow, dir) {
                                firstRow = this.getRowFoldStart(firstRow);
                                lastRow = this.getRowFoldEnd(lastRow);
                                if (dir < 0) {
                                    var row = this.getRowFoldStart(firstRow + dir);
                                    if (row < 0) return 0;
                                    var diff = row - firstRow;
                                } else if (dir > 0) {
                                    var row = this.getRowFoldEnd(lastRow + dir);
                                    if (row > this.doc.getLength() - 1) return 0;
                                    var diff = row - lastRow;
                                } else {
                                    firstRow = this.$clipRowToDocument(firstRow);
                                    lastRow = this.$clipRowToDocument(lastRow);
                                    var diff = lastRow - firstRow + 1;
                                }
                                var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
                                var folds = this.getFoldsInRange(range).map(function(x) {
                                    x = x.clone();
                                    x.start.row += diff;
                                    x.end.row += diff;
                                    return x;
                                });
                                var lines = dir == 0 ? this.doc.getLines(firstRow, lastRow) : this.doc.removeFullLines(firstRow, lastRow);
                                this.doc.insertFullLines(firstRow + diff, lines);
                                folds.length && this.addFolds(folds);
                                return diff;
                            }
                        },
                        {
                            /**
     * Shifts all the lines in the document up one, starting from `firstRow` and ending at `lastRow`.
     * @param {Number} firstRow The starting row to move up
     * @param {Number} lastRow The final row to move up
     * @returns {Number} If `firstRow` is less-than or equal to 0, this function returns 0. Otherwise, on success, it returns -1.
     *
     **/ key: "moveLinesUp",
                            value: function moveLinesUp(firstRow, lastRow) {
                                return this.$moveLines(firstRow, lastRow, -1);
                            }
                        },
                        {
                            /**
     * Shifts all the lines in the document down one, starting from `firstRow` and ending at `lastRow`.
     * @param {Number} firstRow The starting row to move down
     * @param {Number} lastRow The final row to move down
     * @returns {Number} If `firstRow` is less-than or equal to 0, this function returns 0. Otherwise, on success, it returns -1.
     **/ key: "moveLinesDown",
                            value: function moveLinesDown(firstRow, lastRow) {
                                return this.$moveLines(firstRow, lastRow, 1);
                            }
                        },
                        {
                            /**
     * Duplicates all the text between `firstRow` and `lastRow`.
     * @param {Number} firstRow The starting row to duplicate
     * @param {Number} lastRow The final row to duplicate
     * @returns {Number} Returns the number of new rows added; in other words, `lastRow - firstRow + 1`.
     **/ key: "duplicateLines",
                            value: function duplicateLines(firstRow, lastRow) {
                                return this.$moveLines(firstRow, lastRow, 0);
                            }
                        },
                        {
                            key: "$clipRowToDocument",
                            value: function $clipRowToDocument(row) {
                                return Math.max(0, Math.min(row, this.doc.getLength() - 1));
                            }
                        },
                        {
                            key: "$clipColumnToRow",
                            value: function $clipColumnToRow(row, column) {
                                if (column < 0) return 0;
                                return Math.min(this.doc.getLine(row).length, column);
                            }
                        },
                        {
                            key: "$clipPositionToDocument",
                            value: function $clipPositionToDocument(row, column) {
                                column = Math.max(0, column);
                                if (row < 0) {
                                    row = 0;
                                    column = 0;
                                } else {
                                    var len = this.doc.getLength();
                                    if (row >= len) {
                                        row = len - 1;
                                        column = this.doc.getLine(len - 1).length;
                                    } else {
                                        column = Math.min(this.doc.getLine(row).length, column);
                                    }
                                }
                                return {
                                    row: row,
                                    column: column
                                };
                            }
                        },
                        {
                            key: "$clipRangeToDocument",
                            value: function $clipRangeToDocument(range) {
                                if (range.start.row < 0) {
                                    range.start.row = 0;
                                    range.start.column = 0;
                                } else {
                                    range.start.column = this.$clipColumnToRow(range.start.row, range.start.column);
                                }
                                var len = this.doc.getLength() - 1;
                                if (range.end.row > len) {
                                    range.end.row = len;
                                    range.end.column = this.doc.getLine(len).length;
                                } else {
                                    range.end.column = this.$clipColumnToRow(range.end.row, range.end.column);
                                }
                                return range;
                            }
                        },
                        {
                            /**
     * Sets whether or not line wrapping is enabled. If `useWrapMode` is different than the current value, the `'changeWrapMode'` event is emitted.
     * @param {Boolean} useWrapMode Enable (or disable) wrap mode
     *
     **/ key: "setUseWrapMode",
                            value: function setUseWrapMode(useWrapMode) {
                                if (useWrapMode != this.$useWrapMode) {
                                    this.$useWrapMode = useWrapMode;
                                    this.$modified = true;
                                    this.$resetRowCache(0);
                                    // If wrapMode is activaed, the wrapData array has to be initialized.
                                    if (useWrapMode) {
                                        var len = this.getLength();
                                        this.$wrapData = Array(len);
                                        this.$updateWrapData(0, len - 1);
                                    }
                                    this._signal("changeWrapMode");
                                }
                            }
                        },
                        {
                            /**
     * Returns `true` if wrap mode is being used; `false` otherwise.
     * @returns {Boolean}
     **/ key: "getUseWrapMode",
                            value: function getUseWrapMode() {
                                return this.$useWrapMode;
                            }
                        },
                        {
                            // Allow the wrap limit to move freely between min and max. Either
                            // parameter can be null to allow the wrap limit to be unconstrained
                            // in that direction. Or set both parameters to the same number to pin
                            // the limit to that value.
                            /**
     * Sets the boundaries of wrap. Either value can be `null` to have an unconstrained wrap, or, they can be the same number to pin the limit. If the wrap limits for `min` or `max` are different, this method also emits the `'changeWrapMode'` event.
     * @param {Number} min The minimum wrap value (the left side wrap)
     * @param {Number} max The maximum wrap value (the right side wrap)
     *
     **/ key: "setWrapLimitRange",
                            value: function setWrapLimitRange(min, max) {
                                if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
                                    this.$wrapLimitRange = {
                                        min: min,
                                        max: max
                                    };
                                    this.$modified = true;
                                    this.$bidiHandler.markAsDirty();
                                    // This will force a recalculation of the wrap limit
                                    if (this.$useWrapMode) this._signal("changeWrapMode");
                                }
                            }
                        },
                        {
                            /**
     * This should generally only be called by the renderer when a resize is detected.
     * @param {Number} desiredLimit The new wrap limit
     * @returns {Boolean}
     *
     * @private
     **/ key: "adjustWrapLimit",
                            value: function adjustWrapLimit(desiredLimit, $printMargin) {
                                var limits = this.$wrapLimitRange;
                                if (limits.max < 0) limits = {
                                    min: $printMargin,
                                    max: $printMargin
                                };
                                var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
                                if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
                                    this.$wrapLimit = wrapLimit;
                                    this.$modified = true;
                                    if (this.$useWrapMode) {
                                        this.$updateWrapData(0, this.getLength() - 1);
                                        this.$resetRowCache(0);
                                        this._signal("changeWrapLimit");
                                    }
                                    return true;
                                }
                                return false;
                            }
                        },
                        {
                            key: "$constrainWrapLimit",
                            value: function $constrainWrapLimit(wrapLimit, min, max) {
                                if (min) wrapLimit = Math.max(min, wrapLimit);
                                if (max) wrapLimit = Math.min(max, wrapLimit);
                                return wrapLimit;
                            }
                        },
                        {
                            /**
     * Returns the value of wrap limit.
     * @returns {Number} The wrap limit.
     **/ key: "getWrapLimit",
                            value: function getWrapLimit() {
                                return this.$wrapLimit;
                            }
                        },
                        {
                            /**
     * Sets the line length for soft wrap in the editor. Lines will break
     *  at a minimum of the given length minus 20 chars and at a maximum
     *  of the given number of chars.
     * @param {number} limit The maximum line length in chars, for soft wrapping lines.
     */ key: "setWrapLimit",
                            value: function setWrapLimit(limit) {
                                this.setWrapLimitRange(limit, limit);
                            }
                        },
                        {
                            /**
     * Returns an object that defines the minimum and maximum of the wrap limit; it looks something like this:
     *
     *     { min: wrapLimitRange_min, max: wrapLimitRange_max }
     *
     * @returns {Object}
     **/ key: "getWrapLimitRange",
                            value: function getWrapLimitRange() {
                                // Avoid unexpected mutation by returning a copy
                                return {
                                    min: this.$wrapLimitRange.min,
                                    max: this.$wrapLimitRange.max
                                };
                            }
                        },
                        {
                            key: "$updateInternalDataOnChange",
                            value: function $updateInternalDataOnChange(delta) {
                                var useWrapMode = this.$useWrapMode;
                                var action = delta.action;
                                var start = delta.start;
                                var end = delta.end;
                                var firstRow = start.row;
                                var lastRow = end.row;
                                var len = lastRow - firstRow;
                                var removedFolds = null;
                                this.$updating = true;
                                if (len != 0) {
                                    if (action === "remove") {
                                        this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);
                                        var foldLines = this.$foldData;
                                        removedFolds = this.getFoldsInRange(delta);
                                        this.removeFolds(removedFolds);
                                        var foldLine = this.getFoldLine(end.row);
                                        var idx = 0;
                                        if (foldLine) {
                                            foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                                            foldLine.shiftRow(-len);
                                            var foldLineBefore = this.getFoldLine(firstRow);
                                            if (foldLineBefore && foldLineBefore !== foldLine) {
                                                foldLineBefore.merge(foldLine);
                                                foldLine = foldLineBefore;
                                            }
                                            idx = foldLines.indexOf(foldLine) + 1;
                                        }
                                        for(idx; idx < foldLines.length; idx++){
                                            var foldLine = foldLines[idx];
                                            if (foldLine.start.row >= end.row) {
                                                foldLine.shiftRow(-len);
                                            }
                                        }
                                        lastRow = firstRow;
                                    } else {
                                        var args = Array(len);
                                        args.unshift(firstRow, 0);
                                        var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;
                                        arr.splice.apply(arr, args);
                                        // If some new line is added inside of a foldLine, then split
                                        // the fold line up.
                                        var foldLines = this.$foldData;
                                        var foldLine = this.getFoldLine(firstRow);
                                        var idx = 0;
                                        if (foldLine) {
                                            var cmp = foldLine.range.compareInside(start.row, start.column);
                                            // Inside of the foldLine range. Need to split stuff up.
                                            if (cmp == 0) {
                                                foldLine = foldLine.split(start.row, start.column);
                                                if (foldLine) {
                                                    foldLine.shiftRow(len);
                                                    foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
                                                }
                                            } else // Infront of the foldLine but same row. Need to shift column.
                                            if (cmp == -1) {
                                                foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                                                foldLine.shiftRow(len);
                                            }
                                            // Nothing to do if the insert is after the foldLine.
                                            idx = foldLines.indexOf(foldLine) + 1;
                                        }
                                        for(idx; idx < foldLines.length; idx++){
                                            var foldLine = foldLines[idx];
                                            if (foldLine.start.row >= firstRow) {
                                                foldLine.shiftRow(len);
                                            }
                                        }
                                    }
                                } else {
                                    // Realign folds. E.g. if you add some new chars before a fold, the
                                    // fold should "move" to the right.
                                    len = Math.abs(delta.start.column - delta.end.column);
                                    if (action === "remove") {
                                        // Get all the folds in the change range and remove them.
                                        removedFolds = this.getFoldsInRange(delta);
                                        this.removeFolds(removedFolds);
                                        len = -len;
                                    }
                                    var foldLine = this.getFoldLine(firstRow);
                                    if (foldLine) {
                                        foldLine.addRemoveChars(firstRow, start.column, len);
                                    }
                                }
                                if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
                                    console.error("doc.getLength() and $wrapData.length have to be the same!");
                                }
                                this.$updating = false;
                                if (useWrapMode) this.$updateWrapData(firstRow, lastRow);
                                else this.$updateRowLengthCache(firstRow, lastRow);
                                return removedFolds;
                            }
                        },
                        {
                            key: "$updateRowLengthCache",
                            value: function $updateRowLengthCache(firstRow, lastRow, b) {
                                this.$rowLengthCache[firstRow] = null;
                                this.$rowLengthCache[lastRow] = null;
                            }
                        },
                        {
                            key: "$updateWrapData",
                            value: function $updateWrapData(firstRow, lastRow) {
                                var lines = this.doc.getAllLines();
                                var tabSize = this.getTabSize();
                                var wrapData = this.$wrapData;
                                var wrapLimit = this.$wrapLimit;
                                var tokens;
                                var foldLine;
                                var row = firstRow;
                                lastRow = Math.min(lastRow, lines.length - 1);
                                while(row <= lastRow){
                                    foldLine = this.getFoldLine(row, foldLine);
                                    if (!foldLine) {
                                        tokens = this.$getDisplayTokens(lines[row]);
                                        wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                                        row++;
                                    } else {
                                        tokens = [];
                                        foldLine.walk((function(placeholder, row, column, lastColumn) {
                                            var walkTokens;
                                            if (placeholder != null) {
                                                walkTokens = this.$getDisplayTokens(placeholder, tokens.length);
                                                walkTokens[0] = PLACEHOLDER_START;
                                                for(var i = 1; i < walkTokens.length; i++){
                                                    walkTokens[i] = PLACEHOLDER_BODY;
                                                }
                                            } else {
                                                walkTokens = this.$getDisplayTokens(lines[row].substring(lastColumn, column), tokens.length);
                                            }
                                            tokens = tokens.concat(walkTokens);
                                        }).bind(this), foldLine.end.row, lines[foldLine.end.row].length + 1);
                                        wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                                        row = foldLine.end.row + 1;
                                    }
                                }
                            }
                        },
                        {
                            key: "$computeWrapSplits",
                            value: function $computeWrapSplits(tokens, wrapLimit, tabSize) {
                                var getWrapIndent = function getWrapIndent() {
                                    var indentation = 0;
                                    if (maxIndent === 0) return indentation;
                                    if (indentedSoftWrap) {
                                        for(var i = 0; i < tokens.length; i++){
                                            var token = tokens[i];
                                            if (token == SPACE) indentation += 1;
                                            else if (token == TAB) indentation += tabSize;
                                            else if (token == TAB_SPACE) continue;
                                            else break;
                                        }
                                    }
                                    if (isCode && indentedSoftWrap !== false) indentation += tabSize;
                                    return Math.min(indentation, maxIndent);
                                };
                                var addSplit = function addSplit(screenPos) {
                                    // The document size is the current size - the extra width for tabs
                                    // and multipleWidth characters.
                                    var len = screenPos - lastSplit;
                                    for(var i = lastSplit; i < screenPos; i++){
                                        var ch = tokens[i];
                                        if (ch === 12 || ch === 2) len -= 1;
                                    }
                                    if (!splits.length) {
                                        indent = getWrapIndent();
                                        splits.indent = indent;
                                    }
                                    lastDocSplit += len;
                                    splits.push(lastDocSplit);
                                    lastSplit = screenPos;
                                };
                                if (tokens.length == 0) {
                                    return [];
                                }
                                var splits = [];
                                var displayLength = tokens.length;
                                var lastSplit = 0, lastDocSplit = 0;
                                var isCode = this.$wrapAsCode;
                                var indentedSoftWrap = this.$indentedSoftWrap;
                                var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8) || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);
                                var indent = 0;
                                while(displayLength - lastSplit > wrapLimit - indent){
                                    // This is, where the split should be.
                                    var split = lastSplit + wrapLimit - indent;
                                    // If there is a space or tab at this split position, then making
                                    // a split is simple.
                                    if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
                                        /* disabled see https://github.com/ajaxorg/ace/issues/1186
                // Include all following spaces + tabs in this split as well.
                while (tokens[split] >= SPACE) {
                    split ++;
                } */ addSplit(split);
                                        continue;
                                    }
                                    // === ELSE ===
                                    // Check if split is inside of a placeholder. Placeholder are
                                    // not splitable. Therefore, seek the beginning of the placeholder
                                    // and try to place the split before the placeholder's start.
                                    if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
                                        // Seek the start of the placeholder and do the split
                                        // before the placeholder. By definition there always
                                        // a PLACEHOLDER_START between split and lastSplit.
                                        for(split; split != lastSplit - 1; split--){
                                            if (tokens[split] == PLACEHOLDER_START) {
                                                break;
                                            }
                                        }
                                        // If the PLACEHOLDER_START is not the index of the
                                        // last split, then we can do the split
                                        if (split > lastSplit) {
                                            addSplit(split);
                                            continue;
                                        }
                                        // If the PLACEHOLDER_START IS the index of the last
                                        // split, then we have to place the split after the
                                        // placeholder. So, let's seek for the end of the placeholder.
                                        split = lastSplit + wrapLimit;
                                        for(split; split < tokens.length; split++){
                                            if (tokens[split] != PLACEHOLDER_BODY) {
                                                break;
                                            }
                                        }
                                        // If spilt == tokens.length, then the placeholder is the last
                                        // thing in the line and adding a new split doesn't make sense.
                                        if (split == tokens.length) {
                                            break; // Breaks the while-loop.
                                        }
                                        // Finally, add the split...
                                        addSplit(split);
                                        continue;
                                    }
                                    // === ELSE ===
                                    // Search for the first non space/tab/placeholder/punctuation token backwards.
                                    var minSplit = Math.max(split - (wrapLimit - (wrapLimit >> 2)), lastSplit - 1);
                                    while(split > minSplit && tokens[split] < PLACEHOLDER_START){
                                        split--;
                                    }
                                    if (isCode) {
                                        while(split > minSplit && tokens[split] < PLACEHOLDER_START){
                                            split--;
                                        }
                                        while(split > minSplit && tokens[split] == PUNCTUATION){
                                            split--;
                                        }
                                    } else {
                                        while(split > minSplit && tokens[split] < SPACE){
                                            split--;
                                        }
                                    }
                                    // If we found one, then add the split.
                                    if (split > minSplit) {
                                        addSplit(++split);
                                        continue;
                                    }
                                    // === ELSE ===
                                    split = lastSplit + wrapLimit;
                                    // The split is inside of a CHAR or CHAR_EXT token and no space
                                    // around -> force a split.
                                    if (tokens[split] == CHAR_EXT) split--;
                                    addSplit(split - indent);
                                }
                                return splits;
                            }
                        },
                        {
                            /**
     * Given a string, returns an array of the display characters, including tabs and spaces.
     * @param {String} str The string to check
     * @param {Number} offset The value to start at
     **/ key: "$getDisplayTokens",
                            value: function $getDisplayTokens(str, offset) {
                                var arr = [];
                                var tabSize;
                                offset = offset || 0;
                                for(var i = 0; i < str.length; i++){
                                    var c = str.charCodeAt(i);
                                    // Tab
                                    if (c == 9) {
                                        tabSize = this.getScreenTabSize(arr.length + offset);
                                        arr.push(TAB);
                                        for(var n = 1; n < tabSize; n++){
                                            arr.push(TAB_SPACE);
                                        }
                                    } else if (c == 32) {
                                        arr.push(SPACE);
                                    } else if (c > 39 && c < 48 || c > 57 && c < 64) {
                                        arr.push(PUNCTUATION);
                                    } else if (c >= 0x1100 && isFullWidth(c)) {
                                        arr.push(CHAR, CHAR_EXT);
                                    } else {
                                        arr.push(CHAR);
                                    }
                                }
                                return arr;
                            }
                        },
                        {
                            /**
     * Calculates the width of the string `str` on the screen while assuming that the string starts at the first column on the screen.
     * @param {String} str The string to calculate the screen width of
     * @param {Number} maxScreenColumn
     * @param {Number} screenColumn
     * @returns {[Number]} Returns an `int[]` array with two elements:<br/>
     * The first position indicates the number of columns for `str` on screen.<br/>
     * The second value contains the position of the document column that this function read until.
     **/ key: "$getStringScreenWidth",
                            value: function $getStringScreenWidth(str, maxScreenColumn, screenColumn) {
                                if (maxScreenColumn == 0) return [
                                    0,
                                    0
                                ];
                                if (maxScreenColumn == null) maxScreenColumn = Infinity;
                                screenColumn = screenColumn || 0;
                                var c, column;
                                for(column = 0; column < str.length; column++){
                                    c = str.charCodeAt(column);
                                    // tab
                                    if (c == 9) {
                                        screenColumn += this.getScreenTabSize(screenColumn);
                                    } else if (c >= 0x1100 && isFullWidth(c)) {
                                        screenColumn += 2;
                                    } else {
                                        screenColumn += 1;
                                    }
                                    if (screenColumn > maxScreenColumn) {
                                        break;
                                    }
                                }
                                return [
                                    screenColumn,
                                    column
                                ];
                            }
                        },
                        {
                            /**
     * Returns number of screenrows in a wrapped line.
     * @param {Number} row The row number to check
     *
     * @returns {Number}
     **/ key: "getRowLength",
                            value: function getRowLength(row) {
                                var h = 1;
                                if (this.lineWidgets) h += this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
                                if (!this.$useWrapMode || !this.$wrapData[row]) return h;
                                else return this.$wrapData[row].length + h;
                            }
                        },
                        {
                            key: "getRowLineCount",
                            value: function getRowLineCount(row) {
                                if (!this.$useWrapMode || !this.$wrapData[row]) {
                                    return 1;
                                } else {
                                    return this.$wrapData[row].length + 1;
                                }
                            }
                        },
                        {
                            key: "getRowWrapIndent",
                            value: function getRowWrapIndent(screenRow) {
                                if (this.$useWrapMode) {
                                    var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
                                    var splits = this.$wrapData[pos.row];
                                    return splits.length && splits[0] < pos.column ? splits.indent : 0;
                                } else {
                                    return 0;
                                }
                            }
                        },
                        {
                            /**
     * Returns the position (on screen) for the last character in the provided screen row.
     * @param {Number} screenRow The screen row to check
     * @returns {Number}
     *
     * @related EditSession.documentToScreenColumn
     **/ key: "getScreenLastRowColumn",
                            value: function getScreenLastRowColumn(screenRow) {
                                var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
                                return this.documentToScreenColumn(pos.row, pos.column);
                            }
                        },
                        {
                            /**
     * For the given document row and column, this returns the column position of the last screen row.
     * @param {Number} docRow
     *
     * @param {Number} docColumn
     **/ key: "getDocumentLastRowColumn",
                            value: function getDocumentLastRowColumn(docRow, docColumn) {
                                var screenRow = this.documentToScreenRow(docRow, docColumn);
                                return this.getScreenLastRowColumn(screenRow);
                            }
                        },
                        {
                            /**
     * For the given document row and column, this returns the document position of the last row.
     * @param {Number} docRow
     * @param {Number} docColumn
     *
     **/ key: "getDocumentLastRowColumnPosition",
                            value: function getDocumentLastRowColumnPosition(docRow, docColumn) {
                                var screenRow = this.documentToScreenRow(docRow, docColumn);
                                return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
                            }
                        },
                        {
                            /**
     * For the given row, this returns the split data.
     * @returns {String}
     **/ key: "getRowSplitData",
                            value: function getRowSplitData(row) {
                                if (!this.$useWrapMode) {
                                    return undefined;
                                } else {
                                    return this.$wrapData[row];
                                }
                            }
                        },
                        {
                            /**
     * The distance to the next tab stop at the specified screen column.
     * @param {Number} screenColumn The screen column to check
     *
     * @returns {Number}
     **/ key: "getScreenTabSize",
                            value: function getScreenTabSize(screenColumn) {
                                return this.$tabSize - (screenColumn % this.$tabSize | 0);
                            }
                        },
                        {
                            key: "screenToDocumentRow",
                            value: function screenToDocumentRow(screenRow, screenColumn) {
                                return this.screenToDocumentPosition(screenRow, screenColumn).row;
                            }
                        },
                        {
                            key: "screenToDocumentColumn",
                            value: function screenToDocumentColumn(screenRow, screenColumn) {
                                return this.screenToDocumentPosition(screenRow, screenColumn).column;
                            }
                        },
                        {
                            /**
     * Converts characters coordinates on the screen to characters coordinates within the document. [This takes into account code folding, word wrap, tab size, and any other visual modifications.]{: #conversionConsiderations}
     * @param {Number} screenRow The screen row to check
     * @param {Number} screenColumn The screen column to check
     * @param {Number} offsetX screen character x-offset [optional]
     *
     * @returns {Object} The object returned has two properties: `row` and `column`.
     *
     * @related EditSession.documentToScreenPosition
     **/ key: "screenToDocumentPosition",
                            value: function screenToDocumentPosition(screenRow, screenColumn, offsetX) {
                                if (screenRow < 0) return {
                                    row: 0,
                                    column: 0
                                };
                                var line;
                                var docRow = 0;
                                var docColumn = 0;
                                var column;
                                var row = 0;
                                var rowLength = 0;
                                var rowCache = this.$screenRowCache;
                                var i = this.$getRowCacheIndex(rowCache, screenRow);
                                var l = rowCache.length;
                                if (l && i >= 0) {
                                    var row = rowCache[i];
                                    var docRow = this.$docRowCache[i];
                                    var doCache = screenRow > rowCache[l - 1];
                                } else {
                                    var doCache = !l;
                                }
                                var maxRow = this.getLength() - 1;
                                var foldLine = this.getNextFoldLine(docRow);
                                var foldStart = foldLine ? foldLine.start.row : Infinity;
                                while(row <= screenRow){
                                    rowLength = this.getRowLength(docRow);
                                    if (row + rowLength > screenRow || docRow >= maxRow) {
                                        break;
                                    } else {
                                        row += rowLength;
                                        docRow++;
                                        if (docRow > foldStart) {
                                            docRow = foldLine.end.row + 1;
                                            foldLine = this.getNextFoldLine(docRow, foldLine);
                                            foldStart = foldLine ? foldLine.start.row : Infinity;
                                        }
                                    }
                                    if (doCache) {
                                        this.$docRowCache.push(docRow);
                                        this.$screenRowCache.push(row);
                                    }
                                }
                                if (foldLine && foldLine.start.row <= docRow) {
                                    line = this.getFoldDisplayLine(foldLine);
                                    docRow = foldLine.start.row;
                                } else if (row + rowLength <= screenRow || docRow > maxRow) {
                                    // clip at the end of the document
                                    return {
                                        row: maxRow,
                                        column: this.getLine(maxRow).length
                                    };
                                } else {
                                    line = this.getLine(docRow);
                                    foldLine = null;
                                }
                                var wrapIndent = 0, splitIndex = Math.floor(screenRow - row);
                                if (this.$useWrapMode) {
                                    var splits = this.$wrapData[docRow];
                                    if (splits) {
                                        column = splits[splitIndex];
                                        if (splitIndex > 0 && splits.length) {
                                            wrapIndent = splits.indent;
                                            docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                                            line = line.substring(docColumn);
                                        }
                                    }
                                }
                                if (offsetX !== undefined && this.$bidiHandler.isBidiRow(row + splitIndex, docRow, splitIndex)) screenColumn = this.$bidiHandler.offsetToCol(offsetX);
                                docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];
                                // We remove one character at the end so that the docColumn
                                // position returned is not associated to the next row on the screen.
                                if (this.$useWrapMode && docColumn >= column) docColumn = column - 1;
                                if (foldLine) return foldLine.idxToPosition(docColumn);
                                return {
                                    row: docRow,
                                    column: docColumn
                                };
                            }
                        },
                        {
                            /**
     * Converts document coordinates to screen coordinates. {:conversionConsiderations}
     * @param {Number|Position} docRow The document row to check
     * @param {Number|undefined} [docColumn] The document column to check
     * @returns {Position} The object returned by this method has two properties: `row` and `column`.
     *
     * @related EditSession.screenToDocumentPosition
     **/ key: "documentToScreenPosition",
                            value: function documentToScreenPosition(docRow, docColumn) {
                                // Normalize the passed in arguments.
                                if (typeof docColumn === "undefined") var pos = this.$clipPositionToDocument(docRow.row, docRow.column);
                                else pos = this.$clipPositionToDocument(docRow, docColumn);
                                docRow = pos.row;
                                docColumn = pos.column;
                                var screenRow = 0;
                                var foldStartRow = null;
                                var fold = null;
                                // Clamp the docRow position in case it's inside of a folded block.
                                fold = this.getFoldAt(docRow, docColumn, 1);
                                if (fold) {
                                    docRow = fold.start.row;
                                    docColumn = fold.start.column;
                                }
                                var rowEnd, row = 0;
                                var rowCache = this.$docRowCache;
                                var i = this.$getRowCacheIndex(rowCache, docRow);
                                var l = rowCache.length;
                                if (l && i >= 0) {
                                    var row = rowCache[i];
                                    var screenRow = this.$screenRowCache[i];
                                    var doCache = docRow > rowCache[l - 1];
                                } else {
                                    var doCache = !l;
                                }
                                var foldLine = this.getNextFoldLine(row);
                                var foldStart = foldLine ? foldLine.start.row : Infinity;
                                while(row < docRow){
                                    if (row >= foldStart) {
                                        rowEnd = foldLine.end.row + 1;
                                        if (rowEnd > docRow) break;
                                        foldLine = this.getNextFoldLine(rowEnd, foldLine);
                                        foldStart = foldLine ? foldLine.start.row : Infinity;
                                    } else {
                                        rowEnd = row + 1;
                                    }
                                    screenRow += this.getRowLength(row);
                                    row = rowEnd;
                                    if (doCache) {
                                        this.$docRowCache.push(row);
                                        this.$screenRowCache.push(screenRow);
                                    }
                                }
                                // Calculate the text line that is displayed in docRow on the screen.
                                var textLine = "";
                                // Check if the final row we want to reach is inside of a fold.
                                if (foldLine && row >= foldStart) {
                                    textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
                                    foldStartRow = foldLine.start.row;
                                } else {
                                    textLine = this.getLine(docRow).substring(0, docColumn);
                                    foldStartRow = docRow;
                                }
                                var wrapIndent = 0;
                                // Clamp textLine if in wrapMode.
                                if (this.$useWrapMode) {
                                    var wrapRow = this.$wrapData[foldStartRow];
                                    if (wrapRow) {
                                        var screenRowOffset = 0;
                                        while(textLine.length >= wrapRow[screenRowOffset]){
                                            screenRow++;
                                            screenRowOffset++;
                                        }
                                        textLine = textLine.substring(wrapRow[screenRowOffset - 1] || 0, textLine.length);
                                        wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;
                                    }
                                }
                                if (this.lineWidgets && this.lineWidgets[row] && this.lineWidgets[row].rowsAbove) screenRow += this.lineWidgets[row].rowsAbove;
                                return {
                                    row: screenRow,
                                    column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
                                };
                            }
                        },
                        {
                            /**
     * For the given document row and column, returns the screen column.
     * @param {Number} row
     * @param {Number} docColumn
     * @returns {Number}
     *
     **/ key: "documentToScreenColumn",
                            value: function documentToScreenColumn(row, docColumn) {
                                return this.documentToScreenPosition(row, docColumn).column;
                            }
                        },
                        {
                            /**
     * For the given document row and column, returns the screen row.
     * @param {Number} docRow
     * @param {Number} docColumn
     *
     **/ key: "documentToScreenRow",
                            value: function documentToScreenRow(docRow, docColumn) {
                                return this.documentToScreenPosition(docRow, docColumn).row;
                            }
                        },
                        {
                            /**
     * Returns the length of the screen.
     * @returns {Number}
     **/ key: "getScreenLength",
                            value: function getScreenLength() {
                                var screenRows = 0;
                                var fold = null;
                                if (!this.$useWrapMode) {
                                    screenRows = this.getLength();
                                    // Remove the folded lines again.
                                    var foldData = this.$foldData;
                                    for(var i = 0; i < foldData.length; i++){
                                        fold = foldData[i];
                                        screenRows -= fold.end.row - fold.start.row;
                                    }
                                } else {
                                    var lastRow = this.$wrapData.length;
                                    var row = 0, i = 0;
                                    var fold = this.$foldData[i++];
                                    var foldStart = fold ? fold.start.row : Infinity;
                                    while(row < lastRow){
                                        var splits = this.$wrapData[row];
                                        screenRows += splits ? splits.length + 1 : 1;
                                        row++;
                                        if (row > foldStart) {
                                            row = fold.end.row + 1;
                                            fold = this.$foldData[i++];
                                            foldStart = fold ? fold.start.row : Infinity;
                                        }
                                    }
                                }
                                // todo
                                if (this.lineWidgets) screenRows += this.$getWidgetScreenLength();
                                return screenRows;
                            }
                        },
                        {
                            /**
     * @private
     *
     */ key: "$setFontMetrics",
                            value: function $setFontMetrics(fm) {
                                if (!this.$enableVarChar) return;
                                this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
                                    if (maxScreenColumn === 0) return [
                                        0,
                                        0
                                    ];
                                    if (!maxScreenColumn) maxScreenColumn = Infinity;
                                    screenColumn = screenColumn || 0;
                                    var c, column;
                                    for(column = 0; column < str.length; column++){
                                        c = str.charAt(column);
                                        // tab
                                        if (c === "	") {
                                            screenColumn += this.getScreenTabSize(screenColumn);
                                        } else {
                                            screenColumn += fm.getCharacterWidth(c);
                                        }
                                        if (screenColumn > maxScreenColumn) {
                                            break;
                                        }
                                    }
                                    return [
                                        screenColumn,
                                        column
                                    ];
                                };
                            }
                        },
                        {
                            key: "destroy",
                            value: function destroy() {
                                if (!this.destroyed) {
                                    this.bgTokenizer.setDocument(null);
                                    this.bgTokenizer.cleanup();
                                    this.destroyed = true;
                                }
                                this.$stopWorker();
                                this.removeAllListeners();
                                if (this.doc) {
                                    this.doc.off("change", this.$onChange);
                                }
                                this.selection.detach();
                            }
                        }
                    ]);
                    return EditSession;
                }();
                EditSession.$uid = 0;
                EditSession.prototype.$modes = config.$modes;
                /**
 * Returns the current [[Document `Document`]] as a string.
 * @method getValue
 * @returns {String}
 * @alias EditSession.toString
 **/ EditSession.prototype.getValue = EditSession.prototype.toString;
                EditSession.prototype.$defaultUndoManager = {
                    undo: function undo() {},
                    redo: function redo() {},
                    hasUndo: function hasUndo() {},
                    hasRedo: function hasRedo() {},
                    reset: function reset() {},
                    add: function add() {},
                    addSelection: function addSelection() {},
                    startNewGroup: function startNewGroup() {},
                    addSession: function addSession() {}
                };
                EditSession.prototype.$overwrite = false;
                /**
 *
 * @type {TextMode|null}
 */ EditSession.prototype.$mode = null;
                EditSession.prototype.$modeId = null;
                EditSession.prototype.$scrollTop = 0;
                EditSession.prototype.$scrollLeft = 0;
                // WRAPMODE
                EditSession.prototype.$wrapLimit = 80;
                EditSession.prototype.$useWrapMode = false;
                EditSession.prototype.$wrapLimitRange = {
                    min: null,
                    max: null
                };
                EditSession.prototype.lineWidgets = null;
                EditSession.prototype.isFullWidth = isFullWidth;
                oop.implement(EditSession.prototype, EventEmitter);
                // "Tokens"
                var CHAR = 1, CHAR_EXT = 2, PLACEHOLDER_START = 3, PLACEHOLDER_BODY = 4, PUNCTUATION = 9, SPACE = 10, TAB = 11, TAB_SPACE = 12;
                __nested_webpack_require_191859__(2037)/* .Folding.call */ .x.call(EditSession.prototype);
                __nested_webpack_require_191859__(7799)/* .BracketMatch.call */ .F.call(EditSession.prototype);
                config.defineOptions(EditSession.prototype, "session", {
                    wrap: {
                        set: function set(value) {
                            if (!value || value == "off") value = false;
                            else if (value == "free") value = true;
                            else if (value == "printMargin") value = -1;
                            else if (typeof value == "string") value = parseInt(value, 10) || false;
                            if (this.$wrap == value) return;
                            this.$wrap = value;
                            if (!value) {
                                this.setUseWrapMode(false);
                            } else {
                                var col = typeof value == "number" ? value : null;
                                this.setWrapLimitRange(col, col);
                                this.setUseWrapMode(true);
                            }
                        },
                        get: function get() {
                            if (this.getUseWrapMode()) {
                                if (this.$wrap == -1) return "printMargin";
                                if (!this.getWrapLimitRange().min) return "free";
                                return this.$wrap;
                            }
                            return "off";
                        },
                        handlesSet: true
                    },
                    wrapMethod: {
                        // code|text|auto
                        set: function set(val) {
                            val = val == "auto" ? this.$mode.type != "text" : val != "text";
                            if (val != this.$wrapAsCode) {
                                this.$wrapAsCode = val;
                                if (this.$useWrapMode) {
                                    this.$useWrapMode = false;
                                    this.setUseWrapMode(true);
                                }
                            }
                        },
                        initialValue: "auto"
                    },
                    indentedSoftWrap: {
                        set: function set() {
                            if (this.$useWrapMode) {
                                this.$useWrapMode = false;
                                this.setUseWrapMode(true);
                            }
                        },
                        initialValue: true
                    },
                    firstLineNumber: {
                        set: function set() {
                            this._signal("changeBreakpoint");
                        },
                        initialValue: 1
                    },
                    useWorker: {
                        set: function set(useWorker) {
                            this.$useWorker = useWorker;
                            this.$stopWorker();
                            if (useWorker) this.$startWorker();
                        },
                        initialValue: true
                    },
                    useSoftTabs: {
                        initialValue: true
                    },
                    tabSize: {
                        set: function set(tabSize) {
                            tabSize = parseInt(tabSize);
                            if (tabSize > 0 && this.$tabSize !== tabSize) {
                                this.$modified = true;
                                this.$rowLengthCache = [];
                                this.$tabSize = tabSize;
                                this._signal("changeTabSize");
                            }
                        },
                        initialValue: 4,
                        handlesSet: true
                    },
                    navigateWithinSoftTabs: {
                        initialValue: false
                    },
                    foldStyle: {
                        set: function set(val) {
                            this.setFoldStyle(val);
                        },
                        handlesSet: true
                    },
                    overwrite: {
                        set: function set(val) {
                            this._signal("changeOverwrite");
                        },
                        initialValue: false
                    },
                    newLineMode: {
                        set: function set(val) {
                            this.doc.setNewLineMode(val);
                        },
                        get: function get() {
                            return this.doc.getNewLineMode();
                        },
                        handlesSet: true
                    },
                    mode: {
                        set: function set(val) {
                            this.setMode(val);
                        },
                        get: function get() {
                            return this.$modeId;
                        },
                        handlesSet: true
                    }
                });
                exports1.m = EditSession;
            /***/ },
            /***/ 7799: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_321154__) {
                "use strict";
                var BracketMatch = function BracketMatch() {
                    this.findMatchingBracket = function(position, chr) {
                        if (position.column == 0) return null;
                        var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column - 1);
                        if (charBeforeCursor == "") return null;
                        var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
                        if (!match) return null;
                        if (match[1]) return this.$findClosingBracket(match[1], position);
                        else return this.$findOpeningBracket(match[2], position);
                    };
                    this.getBracketRange = function(pos) {
                        var line = this.getLine(pos.row);
                        var before = true, range;
                        var chr = line.charAt(pos.column - 1);
                        var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
                        if (!match) {
                            chr = line.charAt(pos.column);
                            pos = {
                                row: pos.row,
                                column: pos.column + 1
                            };
                            match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
                            before = false;
                        }
                        if (!match) return null;
                        if (match[1]) {
                            var bracketPos = this.$findClosingBracket(match[1], pos);
                            if (!bracketPos) return null;
                            range = Range.fromPoints(pos, bracketPos);
                            if (!before) {
                                range.end.column++;
                                range.start.column--;
                            }
                            range.cursor = range.end;
                        } else {
                            var bracketPos = this.$findOpeningBracket(match[2], pos);
                            if (!bracketPos) return null;
                            range = Range.fromPoints(bracketPos, pos);
                            if (!before) {
                                range.start.column++;
                                range.end.column--;
                            }
                            range.cursor = range.start;
                        }
                        return range;
                    };
                    /**
     * Returns:
     * * null if there is no any bracket at `pos`;
     * * two Ranges if there is opening and closing brackets;
     * * one Range if there is only one bracket
     *
     * @param {Point} pos
     * @param {boolean} [isBackwards]
     * @returns {null|Range[]}
     */ this.getMatchingBracketRanges = function(pos, isBackwards) {
                        var line = this.getLine(pos.row);
                        var bracketsRegExp = /([\(\[\{])|([\)\]\}])/;
                        var chr = !isBackwards && line.charAt(pos.column - 1);
                        var match = chr && chr.match(bracketsRegExp);
                        if (!match) {
                            chr = (isBackwards === undefined || isBackwards) && line.charAt(pos.column);
                            pos = {
                                row: pos.row,
                                column: pos.column + 1
                            };
                            match = chr && chr.match(bracketsRegExp);
                        }
                        if (!match) return null;
                        var startRange = new Range(pos.row, pos.column - 1, pos.row, pos.column);
                        var bracketPos = match[1] ? this.$findClosingBracket(match[1], pos) : this.$findOpeningBracket(match[2], pos);
                        if (!bracketPos) return [
                            startRange
                        ];
                        var endRange = new Range(bracketPos.row, bracketPos.column, bracketPos.row, bracketPos.column + 1);
                        return [
                            startRange,
                            endRange
                        ];
                    };
                    this.$brackets = {
                        ")": "(",
                        "(": ")",
                        "]": "[",
                        "[": "]",
                        "{": "}",
                        "}": "{",
                        "<": ">",
                        ">": "<"
                    };
                    this.$findOpeningBracket = function(bracket, position, typeRe) {
                        var openBracket = this.$brackets[bracket];
                        var depth = 1;
                        var iterator = new TokenIterator(this, position.row, position.column);
                        var token = iterator.getCurrentToken();
                        if (!token) token = iterator.stepForward();
                        if (!token) return;
                        if (!typeRe) {
                            typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("rparen", ".paren").replace(/\b(?:end)\b/, "(?:start|begin|end)").replace(/-close\b/, "-(close|open)") + ")+");
                        }
                        // Start searching in token, just before the character at position.column
                        var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
                        var value = token.value;
                        while(true){
                            while(valueIndex >= 0){
                                var chr = value.charAt(valueIndex);
                                if (chr == openBracket) {
                                    depth -= 1;
                                    if (depth == 0) {
                                        return {
                                            row: iterator.getCurrentTokenRow(),
                                            column: valueIndex + iterator.getCurrentTokenColumn()
                                        };
                                    }
                                } else if (chr == bracket) {
                                    depth += 1;
                                }
                                valueIndex -= 1;
                            }
                            // Scan backward through the document, looking for the next token
                            // whose type matches typeRe
                            do {
                                token = iterator.stepBackward();
                            }while (token && !typeRe.test(token.type));
                            if (token == null) break;
                            value = token.value;
                            valueIndex = value.length - 1;
                        }
                        return null;
                    };
                    this.$findClosingBracket = function(bracket, position, typeRe) {
                        var closingBracket = this.$brackets[bracket];
                        var depth = 1;
                        var iterator = new TokenIterator(this, position.row, position.column);
                        var token = iterator.getCurrentToken();
                        if (!token) token = iterator.stepForward();
                        if (!token) return;
                        if (!typeRe) {
                            typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("lparen", ".paren").replace(/\b(?:start|begin)\b/, "(?:start|begin|end)").replace(/-open\b/, "-(close|open)") + ")+");
                        }
                        // Start searching in token, after the character at position.column
                        var valueIndex = position.column - iterator.getCurrentTokenColumn();
                        while(true){
                            var value = token.value;
                            var valueLength = value.length;
                            while(valueIndex < valueLength){
                                var chr = value.charAt(valueIndex);
                                if (chr == closingBracket) {
                                    depth -= 1;
                                    if (depth == 0) {
                                        return {
                                            row: iterator.getCurrentTokenRow(),
                                            column: valueIndex + iterator.getCurrentTokenColumn()
                                        };
                                    }
                                } else if (chr == bracket) {
                                    depth += 1;
                                }
                                valueIndex += 1;
                            }
                            // Scan forward through the document, looking for the next token
                            // whose type matches typeRe
                            do {
                                token = iterator.stepForward();
                            }while (token && !typeRe.test(token.type));
                            if (token == null) break;
                            valueIndex = 0;
                        }
                        return null;
                    };
                    /**
     * Returns [[Range]]'s for matching tags and tag names, if there are any
     * @param {Position} pos
     * @returns {{closeTag: Range, closeTagName: Range, openTag: Range, openTagName: Range} | undefined}
     */ this.getMatchingTags = function(pos) {
                        var iterator = new TokenIterator(this, pos.row, pos.column);
                        var token = this.$findTagName(iterator);
                        if (!token) return;
                        var prevToken = iterator.stepBackward();
                        if (prevToken.value === "<") {
                            return this.$findClosingTag(iterator, token);
                        } else {
                            return this.$findOpeningTag(iterator, token);
                        }
                    };
                    this.$findTagName = function(iterator) {
                        var token = iterator.getCurrentToken();
                        var found = false;
                        var backward = false;
                        if (token && token.type.indexOf("tag-name") === -1) {
                            do {
                                if (backward) token = iterator.stepBackward();
                                else token = iterator.stepForward();
                                if (token) {
                                    if (token.value === "/>") {
                                        //changing iterator direction for self-closing tags, when cursor is in between tag
                                        //name and tag closing
                                        backward = true;
                                    } else if (token.type.indexOf("tag-name") !== -1) {
                                        found = true;
                                    }
                                }
                            }while (token && !found);
                        }
                        return token;
                    };
                    this.$findClosingTag = function(iterator, token) {
                        var prevToken;
                        var currentTag = token.value;
                        var tag = token.value;
                        var depth = 0;
                        var openTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                        token = iterator.stepForward();
                        var openTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
                        var foundOpenTagEnd = false;
                        do {
                            prevToken = token;
                            token = iterator.stepForward();
                            if (token) {
                                if (token.value === ">" && !foundOpenTagEnd) {
                                    var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for `>`
                                    foundOpenTagEnd = true;
                                }
                                if (token.type.indexOf("tag-name") !== -1) {
                                    currentTag = token.value;
                                    if (tag === currentTag) {
                                        if (prevToken.value === "<") {
                                            depth++;
                                        } else if (prevToken.value === "</") {
                                            depth--;
                                            if (depth < 0) {
                                                iterator.stepBackward();
                                                var closeTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 2); //Range for </
                                                token = iterator.stepForward();
                                                var closeTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
                                                token = iterator.stepForward();
                                                if (token && token.value === ">") {
                                                    var closeTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for >
                                                } else {
                                                    return;
                                                }
                                            }
                                        }
                                    }
                                } else if (tag === currentTag && token.value === "/>") {
                                    depth--;
                                    if (depth < 0) {
                                        //Example: <tagName attr/>
                                        //`<tagName ` - opening part of tag consist of `openTagStart`, `openTagName` and `openTagEnd`
                                        //`/>` - closing part of tag consist of `closeTagStart`, `closeTagName` and `closeTagEnd`
                                        var closeTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 2);
                                        var closeTagName = closeTagStart;
                                        var closeTagEnd = closeTagName;
                                        var openTagEnd = new Range(openTagName.end.row, openTagName.end.column, openTagName.end.row, openTagName.end.column + 1);
                                    }
                                }
                            }
                        }while (token && depth >= 0);
                        if (openTagStart && openTagEnd && closeTagStart && closeTagEnd && openTagName && closeTagName) {
                            return {
                                openTag: new Range(openTagStart.start.row, openTagStart.start.column, openTagEnd.end.row, openTagEnd.end.column),
                                closeTag: new Range(closeTagStart.start.row, closeTagStart.start.column, closeTagEnd.end.row, closeTagEnd.end.column),
                                openTagName: openTagName,
                                closeTagName: closeTagName
                            };
                        }
                    };
                    this.$findOpeningTag = function(iterator, token) {
                        var prevToken = iterator.getCurrentToken();
                        var tag = token.value;
                        var depth = 0;
                        var startRow = iterator.getCurrentTokenRow();
                        var startColumn = iterator.getCurrentTokenColumn();
                        var endColumn = startColumn + 2;
                        //closing tag
                        var closeTagStart = new Range(startRow, startColumn, startRow, endColumn); //Range for </
                        iterator.stepForward();
                        var closeTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
                        token = iterator.stepForward();
                        if (!token || token.value !== ">") return;
                        var closeTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for >
                        iterator.stepBackward();
                        iterator.stepBackward();
                        do {
                            token = prevToken;
                            startRow = iterator.getCurrentTokenRow();
                            startColumn = iterator.getCurrentTokenColumn();
                            endColumn = startColumn + token.value.length;
                            prevToken = iterator.stepBackward();
                            if (token) {
                                if (token.type.indexOf("tag-name") !== -1) {
                                    if (tag === token.value) {
                                        if (prevToken.value === "<") {
                                            depth++;
                                            if (depth > 0) {
                                                var openTagName = new Range(startRow, startColumn, startRow, endColumn);
                                                var openTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for <
                                                do {
                                                    token = iterator.stepForward();
                                                }while (token && token.value !== ">");
                                                var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for >
                                            }
                                        } else if (prevToken.value === "</") {
                                            depth--;
                                        }
                                    }
                                } else if (token.value === "/>") {
                                    var stepCount = 0;
                                    var tmpToken = prevToken;
                                    while(tmpToken){
                                        if (tmpToken.type.indexOf("tag-name") !== -1 && tmpToken.value === tag) {
                                            depth--;
                                            break;
                                        } else if (tmpToken.value === "<") {
                                            break;
                                        }
                                        tmpToken = iterator.stepBackward();
                                        stepCount++;
                                    }
                                    for(var i = 0; i < stepCount; i++){
                                        iterator.stepForward();
                                    }
                                }
                            }
                        }while (prevToken && depth <= 0);
                        if (openTagStart && openTagEnd && closeTagStart && closeTagEnd && openTagName && closeTagName) {
                            return {
                                openTag: new Range(openTagStart.start.row, openTagStart.start.column, openTagEnd.end.row, openTagEnd.end.column),
                                closeTag: new Range(closeTagStart.start.row, closeTagStart.start.column, closeTagEnd.end.row, closeTagEnd.end.column),
                                openTagName: openTagName,
                                closeTagName: closeTagName
                            };
                        }
                    };
                };
                var TokenIterator = __nested_webpack_require_321154__(7726)/* .TokenIterator */ .N;
                var Range = __nested_webpack_require_321154__(3069)/* .Range */ .e;
                exports1.F = BracketMatch;
            /***/ },
            /***/ 8363: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_342674__) {
                "use strict";
                var consumePoint = function consumePoint(point, anchor) {
                    point.row -= anchor.row;
                    if (point.row == 0) point.column -= anchor.column;
                };
                var consumeRange = function consumeRange(range, anchor) {
                    consumePoint(range.start, anchor);
                    consumePoint(range.end, anchor);
                };
                var restorePoint = function restorePoint(point, anchor) {
                    if (point.row == 0) point.column += anchor.column;
                    point.row += anchor.row;
                };
                var restoreRange = function restoreRange(range, anchor) {
                    restorePoint(range.start, anchor);
                    restorePoint(range.end, anchor);
                };
                var RangeList1 = __nested_webpack_require_342674__(9204)/* .RangeList */ .$;
                /*
 * Simple fold-data struct.
 **/ var Fold = /*#__PURE__*/ function(RangeList1) {
                    _inherits(Fold, RangeList1);
                    var _super = _create_super(Fold);
                    function Fold(range, placeholder) {
                        _class_call_check(this, Fold);
                        var _this;
                        _this = _super.call(this);
                        _this.foldLine = null;
                        _this.placeholder = placeholder;
                        _this.range = range;
                        _this.start = range.start;
                        _this.end = range.end;
                        _this.sameRow = range.start.row == range.end.row;
                        _this.subFolds = _this.ranges = [];
                        return _this;
                    }
                    _create_class(Fold, [
                        {
                            key: "toString",
                            value: function toString() {
                                return '"' + this.placeholder + '" ' + this.range.toString();
                            }
                        },
                        {
                            key: "setFoldLine",
                            value: function setFoldLine(foldLine) {
                                this.foldLine = foldLine;
                                this.subFolds.forEach(function(fold) {
                                    fold.setFoldLine(foldLine);
                                });
                            }
                        },
                        {
                            key: "clone",
                            value: function clone() {
                                var range = this.range.clone();
                                var fold = new Fold(range, this.placeholder);
                                this.subFolds.forEach(function(subFold) {
                                    fold.subFolds.push(subFold.clone());
                                });
                                fold.collapseChildren = this.collapseChildren;
                                return fold;
                            }
                        },
                        {
                            key: "addSubFold",
                            value: function addSubFold(fold) {
                                if (this.range.isEqual(fold)) return;
                                // transform fold to local coordinates
                                consumeRange(fold, this.start);
                                var row = fold.start.row, column = fold.start.column;
                                for(var i = 0, cmp = -1; i < this.subFolds.length; i++){
                                    cmp = this.subFolds[i].range.compare(row, column);
                                    if (cmp != 1) break;
                                }
                                var afterStart = this.subFolds[i];
                                var firstConsumed = 0;
                                if (cmp == 0) {
                                    if (afterStart.range.containsRange(fold)) return afterStart.addSubFold(fold);
                                    else firstConsumed = 1;
                                }
                                // cmp == -1
                                var row = fold.range.end.row, column = fold.range.end.column;
                                for(var j = i, cmp = -1; j < this.subFolds.length; j++){
                                    cmp = this.subFolds[j].range.compare(row, column);
                                    if (cmp != 1) break;
                                }
                                if (cmp == 0) j++;
                                var consumedFolds = this.subFolds.splice(i, j - i, fold);
                                var last = cmp == 0 ? consumedFolds.length - 1 : consumedFolds.length;
                                for(var k = firstConsumed; k < last; k++){
                                    fold.addSubFold(consumedFolds[k]);
                                }
                                fold.setFoldLine(this.foldLine);
                                return fold;
                            }
                        },
                        {
                            key: "restoreRange",
                            value: function restoreRange1(range) {
                                return restoreRange(range, this.start);
                            }
                        }
                    ]);
                    return Fold;
                }(RangeList1);
                exports1.q = Fold;
            /***/ },
            /***/ 4138: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_348401__) {
                "use strict";
                var Range = __nested_webpack_require_348401__(3069)/* .Range */ .e;
                var FoldLine = /*#__PURE__*/ function() {
                    function FoldLine(foldData, folds) {
                        _class_call_check(this, FoldLine);
                        this.foldData = foldData;
                        if (Array.isArray(folds)) {
                            this.folds = folds;
                        } else {
                            folds = this.folds = [
                                folds
                            ];
                        }
                        var last = folds[folds.length - 1];
                        this.range = new Range(folds[0].start.row, folds[0].start.column, last.end.row, last.end.column);
                        this.start = this.range.start;
                        this.end = this.range.end;
                        this.folds.forEach(function(fold) {
                            fold.setFoldLine(this);
                        }, this);
                    }
                    _create_class(FoldLine, [
                        {
                            /*
     * Note: This doesn't update wrapData!
     */ key: "shiftRow",
                            value: function shiftRow(shift) {
                                this.start.row += shift;
                                this.end.row += shift;
                                this.folds.forEach(function(fold) {
                                    fold.start.row += shift;
                                    fold.end.row += shift;
                                });
                            }
                        },
                        {
                            key: "addFold",
                            value: function addFold(fold) {
                                if (fold.sameRow) {
                                    if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
                                        throw new Error("Can't add a fold to this FoldLine as it has no connection");
                                    }
                                    this.folds.push(fold);
                                    this.folds.sort(function(a, b) {
                                        return -a.range.compareEnd(b.start.row, b.start.column);
                                    });
                                    if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
                                        this.end.row = fold.end.row;
                                        this.end.column = fold.end.column;
                                    } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
                                        this.start.row = fold.start.row;
                                        this.start.column = fold.start.column;
                                    }
                                } else if (fold.start.row == this.end.row) {
                                    this.folds.push(fold);
                                    this.end.row = fold.end.row;
                                    this.end.column = fold.end.column;
                                } else if (fold.end.row == this.start.row) {
                                    this.folds.unshift(fold);
                                    this.start.row = fold.start.row;
                                    this.start.column = fold.start.column;
                                } else {
                                    throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
                                }
                                fold.foldLine = this;
                            }
                        },
                        {
                            key: "containsRow",
                            value: function containsRow(row) {
                                return row >= this.start.row && row <= this.end.row;
                            }
                        },
                        {
                            key: "walk",
                            value: function walk(callback, endRow, endColumn) {
                                var lastEnd = 0, folds = this.folds, fold, cmp, stop, isNewRow = true;
                                if (endRow == null) {
                                    endRow = this.end.row;
                                    endColumn = this.end.column;
                                }
                                for(var i = 0; i < folds.length; i++){
                                    fold = folds[i];
                                    cmp = fold.range.compareStart(endRow, endColumn);
                                    // This fold is after the endRow/Column.
                                    if (cmp == -1) {
                                        callback(null, endRow, endColumn, lastEnd, isNewRow);
                                        return;
                                    }
                                    stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
                                    stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
                                    // If the user requested to stop the walk or endRow/endColumn is
                                    // inside of this fold (cmp == 0), then end here.
                                    if (stop || cmp === 0) {
                                        return;
                                    }
                                    // Note the new lastEnd might not be on the same line. However,
                                    // it's the callback's job to recognize this.
                                    isNewRow = !fold.sameRow;
                                    lastEnd = fold.end.column;
                                }
                                callback(null, endRow, endColumn, lastEnd, isNewRow);
                            }
                        },
                        {
                            key: "getNextFoldTo",
                            value: function getNextFoldTo(row, column) {
                                var fold, cmp;
                                for(var i = 0; i < this.folds.length; i++){
                                    fold = this.folds[i];
                                    cmp = fold.range.compareEnd(row, column);
                                    if (cmp == -1) {
                                        return {
                                            fold: fold,
                                            kind: "after"
                                        };
                                    } else if (cmp === 0) {
                                        return {
                                            fold: fold,
                                            kind: "inside"
                                        };
                                    }
                                }
                                return null;
                            }
                        },
                        {
                            key: "addRemoveChars",
                            value: function addRemoveChars(row, column, len) {
                                var ret = this.getNextFoldTo(row, column), fold, folds;
                                if (ret) {
                                    fold = ret.fold;
                                    if (ret.kind == "inside" && fold.start.column != column && fold.start.row != row) {
                                        //throwing here breaks whole editor
                                        //TODO: properly handle this
                                        window.console && window.console.log(row, column, fold);
                                    } else if (fold.start.row == row) {
                                        folds = this.folds;
                                        var i = folds.indexOf(fold);
                                        if (i === 0) {
                                            this.start.column += len;
                                        }
                                        for(i; i < folds.length; i++){
                                            fold = folds[i];
                                            fold.start.column += len;
                                            if (!fold.sameRow) {
                                                return;
                                            }
                                            fold.end.column += len;
                                        }
                                        this.end.column += len;
                                    }
                                }
                            }
                        },
                        {
                            key: "split",
                            value: function split(row, column) {
                                var pos = this.getNextFoldTo(row, column);
                                if (!pos || pos.kind == "inside") return null;
                                var fold = pos.fold;
                                var folds = this.folds;
                                var foldData = this.foldData;
                                var i = folds.indexOf(fold);
                                var foldBefore = folds[i - 1];
                                this.end.row = foldBefore.end.row;
                                this.end.column = foldBefore.end.column;
                                // Remove the folds after row/column and create a new FoldLine
                                // containing these removed folds.
                                folds = folds.splice(i, folds.length - i);
                                var newFoldLine = new FoldLine(foldData, folds);
                                foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
                                return newFoldLine;
                            }
                        },
                        {
                            key: "merge",
                            value: function merge(foldLineNext) {
                                var folds = foldLineNext.folds;
                                for(var i = 0; i < folds.length; i++){
                                    this.addFold(folds[i]);
                                }
                                // Remove the foldLineNext - no longer needed, as
                                // it's merged now with foldLineNext.
                                var foldData = this.foldData;
                                foldData.splice(foldData.indexOf(foldLineNext), 1);
                            }
                        },
                        {
                            key: "toString",
                            value: function toString() {
                                var ret = [
                                    this.range.toString() + ": ["
                                ];
                                this.folds.forEach(function(fold) {
                                    ret.push("  " + fold.toString());
                                });
                                ret.push("]");
                                return ret.join("\n");
                            }
                        },
                        {
                            key: "idxToPosition",
                            value: function idxToPosition(idx) {
                                var lastFoldEndColumn = 0;
                                for(var i = 0; i < this.folds.length; i++){
                                    var fold = this.folds[i];
                                    idx -= fold.start.column - lastFoldEndColumn;
                                    if (idx < 0) {
                                        return {
                                            row: fold.start.row,
                                            column: fold.start.column + idx
                                        };
                                    }
                                    idx -= fold.placeholder.length;
                                    if (idx < 0) {
                                        return fold.start;
                                    }
                                    lastFoldEndColumn = fold.end.column;
                                }
                                return {
                                    row: this.end.row,
                                    column: this.end.column + idx
                                };
                            }
                        }
                    ]);
                    return FoldLine;
                }();
                exports1.z = FoldLine;
            /***/ },
            /***/ 2037: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_361488__) {
                "use strict";
                var Folding = function Folding() {
                    /*
     * Looks up a fold at a given row/column. Possible values for side:
     *   -1: ignore a fold if fold.start = row/column
     *   +1: ignore a fold if fold.end = row/column
     */ this.getFoldAt = function(row, column, side) {
                        var foldLine = this.getFoldLine(row);
                        if (!foldLine) return null;
                        var folds = foldLine.folds;
                        for(var i = 0; i < folds.length; i++){
                            var range = folds[i].range;
                            if (range.contains(row, column)) {
                                if (side == 1 && range.isEnd(row, column) && !range.isEmpty()) {
                                    continue;
                                } else if (side == -1 && range.isStart(row, column) && !range.isEmpty()) {
                                    continue;
                                }
                                return folds[i];
                            }
                        }
                    };
                    /*
     * Returns all folds in the given range. Note, that this will return folds
     *
     */ this.getFoldsInRange = function(range) {
                        var start = range.start;
                        var end = range.end;
                        var foldLines = this.$foldData;
                        var foundFolds = [];
                        start.column += 1;
                        end.column -= 1;
                        for(var i = 0; i < foldLines.length; i++){
                            var cmp = foldLines[i].range.compareRange(range);
                            if (cmp == 2) {
                                continue;
                            } else if (cmp == -2) {
                                break;
                            }
                            var folds = foldLines[i].folds;
                            for(var j = 0; j < folds.length; j++){
                                var fold = folds[j];
                                cmp = fold.range.compareRange(range);
                                if (cmp == -2) {
                                    break;
                                } else if (cmp == 2) {
                                    continue;
                                } else // WTF-state: Can happen due to -1/+1 to start/end column.
                                if (cmp == 42) {
                                    break;
                                }
                                foundFolds.push(fold);
                            }
                        }
                        start.column -= 1;
                        end.column += 1;
                        return foundFolds;
                    };
                    this.getFoldsInRangeList = function(ranges) {
                        if (Array.isArray(ranges)) {
                            var folds = [];
                            ranges.forEach(function(range) {
                                folds = folds.concat(this.getFoldsInRange(range));
                            }, this);
                        } else {
                            var folds = this.getFoldsInRange(ranges);
                        }
                        return folds;
                    };
                    /*
     * Returns all folds in the document
     */ this.getAllFolds = function() {
                        var folds = [];
                        var foldLines = this.$foldData;
                        for(var i = 0; i < foldLines.length; i++)for(var j = 0; j < foldLines[i].folds.length; j++)folds.push(foldLines[i].folds[j]);
                        return folds;
                    };
                    /*
     * Returns the string between folds at the given position.
     * E.g.
     *  foo<fold>b|ar<fold>wolrd -> "bar"
     *  foo<fold>bar<fold>wol|rd -> "world"
     *  foo<fold>bar<fo|ld>wolrd -> <null>
     *
     * where | means the position of row/column
     *
     * The trim option determs if the return string should be trimed according
     * to the "side" passed with the trim value:
     *
     * E.g.
     *  foo<fold>b|ar<fold>wolrd -trim=-1> "b"
     *  foo<fold>bar<fold>wol|rd -trim=+1> "rld"
     *  fo|o<fold>bar<fold>wolrd -trim=00> "foo"
     */ this.getFoldStringAt = function(row, column, trim, foldLine) {
                        foldLine = foldLine || this.getFoldLine(row);
                        if (!foldLine) return null;
                        var lastFold = {
                            end: {
                                column: 0
                            }
                        };
                        // TODO: Refactor to use getNextFoldTo function.
                        var str, fold;
                        for(var i = 0; i < foldLine.folds.length; i++){
                            fold = foldLine.folds[i];
                            var cmp = fold.range.compareEnd(row, column);
                            if (cmp == -1) {
                                str = this.getLine(fold.start.row).substring(lastFold.end.column, fold.start.column);
                                break;
                            } else if (cmp === 0) {
                                return null;
                            }
                            lastFold = fold;
                        }
                        if (!str) str = this.getLine(fold.start.row).substring(lastFold.end.column);
                        if (trim == -1) return str.substring(0, column - lastFold.end.column);
                        else if (trim == 1) return str.substring(column - lastFold.end.column);
                        else return str;
                    };
                    this.getFoldLine = function(docRow, startFoldLine) {
                        var foldData = this.$foldData;
                        var i = 0;
                        if (startFoldLine) i = foldData.indexOf(startFoldLine);
                        if (i == -1) i = 0;
                        for(i; i < foldData.length; i++){
                            var foldLine = foldData[i];
                            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
                                return foldLine;
                            } else if (foldLine.end.row > docRow) {
                                return null;
                            }
                        }
                        return null;
                    };
                    // returns the fold which starts after or contains docRow
                    this.getNextFoldLine = function(docRow, startFoldLine) {
                        var foldData = this.$foldData;
                        var i = 0;
                        if (startFoldLine) i = foldData.indexOf(startFoldLine);
                        if (i == -1) i = 0;
                        for(i; i < foldData.length; i++){
                            var foldLine = foldData[i];
                            if (foldLine.end.row >= docRow) {
                                return foldLine;
                            }
                        }
                        return null;
                    };
                    this.getFoldedRowCount = function(first, last) {
                        var foldData = this.$foldData, rowCount = last - first + 1;
                        for(var i = 0; i < foldData.length; i++){
                            var foldLine = foldData[i], end = foldLine.end.row, start = foldLine.start.row;
                            if (end >= last) {
                                if (start < last) {
                                    if (start >= first) rowCount -= last - start;
                                    else rowCount = 0; // in one fold
                                }
                                break;
                            } else if (end >= first) {
                                if (start >= first) rowCount -= end - start;
                                else rowCount -= end - first + 1;
                            }
                        }
                        return rowCount;
                    };
                    this.$addFoldLine = function(foldLine) {
                        this.$foldData.push(foldLine);
                        this.$foldData.sort(function(a, b) {
                            return a.start.row - b.start.row;
                        });
                        return foldLine;
                    };
                    /**
     * Adds a new fold.
     *
     * @returns
     *      The new created Fold object or an existing fold object in case the
     *      passed in range fits an existing fold exactly.
     */ this.addFold = function(placeholder, range) {
                        var foldData = this.$foldData;
                        var added = false;
                        var fold;
                        if (_instanceof(placeholder, Fold)) fold = placeholder;
                        else {
                            fold = new Fold(range, placeholder);
                            fold.collapseChildren = range.collapseChildren;
                        }
                        this.$clipRangeToDocument(fold.range);
                        var startRow = fold.start.row;
                        var startColumn = fold.start.column;
                        var endRow = fold.end.row;
                        var endColumn = fold.end.column;
                        var startFold = this.getFoldAt(startRow, startColumn, 1);
                        var endFold = this.getFoldAt(endRow, endColumn, -1);
                        if (startFold && endFold == startFold) return startFold.addSubFold(fold);
                        if (startFold && !startFold.range.isStart(startRow, startColumn)) this.removeFold(startFold);
                        if (endFold && !endFold.range.isEnd(endRow, endColumn)) this.removeFold(endFold);
                        // Check if there are folds in the range we create the new fold for.
                        var folds = this.getFoldsInRange(fold.range);
                        if (folds.length > 0) {
                            // Remove the folds from fold data.
                            this.removeFolds(folds);
                            // Add the removed folds as subfolds on the new fold.
                            if (!fold.collapseChildren) {
                                folds.forEach(function(subFold) {
                                    fold.addSubFold(subFold);
                                });
                            }
                        }
                        for(var i = 0; i < foldData.length; i++){
                            var foldLine = foldData[i];
                            if (endRow == foldLine.start.row) {
                                foldLine.addFold(fold);
                                added = true;
                                break;
                            } else if (startRow == foldLine.end.row) {
                                foldLine.addFold(fold);
                                added = true;
                                if (!fold.sameRow) {
                                    // Check if we might have to merge two FoldLines.
                                    var foldLineNext = foldData[i + 1];
                                    if (foldLineNext && foldLineNext.start.row == endRow) {
                                        // We need to merge!
                                        foldLine.merge(foldLineNext);
                                        break;
                                    }
                                }
                                break;
                            } else if (endRow <= foldLine.start.row) {
                                break;
                            }
                        }
                        if (!added) foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));
                        if (this.$useWrapMode) this.$updateWrapData(foldLine.start.row, foldLine.start.row);
                        else this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
                        // Notify that fold data has changed.
                        this.$modified = true;
                        this._signal("changeFold", {
                            data: fold,
                            action: "add"
                        });
                        return fold;
                    };
                    this.addFolds = function(folds) {
                        folds.forEach(function(fold) {
                            this.addFold(fold);
                        }, this);
                    };
                    this.removeFold = function(fold) {
                        var foldLine = fold.foldLine;
                        var startRow = foldLine.start.row;
                        var endRow = foldLine.end.row;
                        var foldLines = this.$foldData;
                        var folds = foldLine.folds;
                        // Simple case where there is only one fold in the FoldLine such that
                        // the entire fold line can get removed directly.
                        if (folds.length == 1) {
                            foldLines.splice(foldLines.indexOf(foldLine), 1);
                        } else // If the fold is the last fold of the foldLine, just remove it.
                        if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
                            folds.pop();
                            foldLine.end.row = folds[folds.length - 1].end.row;
                            foldLine.end.column = folds[folds.length - 1].end.column;
                        } else // If the fold is the first fold of the foldLine, just remove it.
                        if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
                            folds.shift();
                            foldLine.start.row = folds[0].start.row;
                            foldLine.start.column = folds[0].start.column;
                        } else // We know there are more then 2 folds and the fold is not at the edge.
                        // This means, the fold is somewhere in between.
                        //
                        // If the fold is in one row, we just can remove it.
                        if (fold.sameRow) {
                            folds.splice(folds.indexOf(fold), 1);
                        } else // The fold goes over more then one row. This means remvoing this fold
                        // will cause the fold line to get splitted up. newFoldLine is the second part
                        {
                            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
                            folds = newFoldLine.folds;
                            folds.shift();
                            newFoldLine.start.row = folds[0].start.row;
                            newFoldLine.start.column = folds[0].start.column;
                        }
                        if (!this.$updating) {
                            if (this.$useWrapMode) this.$updateWrapData(startRow, endRow);
                            else this.$updateRowLengthCache(startRow, endRow);
                        }
                        // Notify that fold data has changed.
                        this.$modified = true;
                        this._signal("changeFold", {
                            data: fold,
                            action: "remove"
                        });
                    };
                    this.removeFolds = function(folds) {
                        // We need to clone the folds array passed in as it might be the folds
                        // array of a fold line and as we call this.removeFold(fold), folds
                        // are removed from folds and changes the current index.
                        var cloneFolds = [];
                        for(var i = 0; i < folds.length; i++){
                            cloneFolds.push(folds[i]);
                        }
                        cloneFolds.forEach(function(fold) {
                            this.removeFold(fold);
                        }, this);
                        this.$modified = true;
                    };
                    this.expandFold = function(fold) {
                        this.removeFold(fold);
                        fold.subFolds.forEach(function(subFold) {
                            fold.restoreRange(subFold);
                            this.addFold(subFold);
                        }, this);
                        if (fold.collapseChildren > 0) {
                            this.foldAll(fold.start.row + 1, fold.end.row, fold.collapseChildren - 1);
                        }
                        fold.subFolds = [];
                    };
                    this.expandFolds = function(folds) {
                        folds.forEach(function(fold) {
                            this.expandFold(fold);
                        }, this);
                    };
                    this.unfold = function(location, expandInner) {
                        var range, folds;
                        if (location == null) {
                            range = new Range(0, 0, this.getLength(), 0);
                            if (expandInner == null) expandInner = true;
                        } else if (typeof location == "number") {
                            range = new Range(location, 0, location, this.getLine(location).length);
                        } else if ("row" in location) {
                            range = Range.fromPoints(location, location);
                        } else if (Array.isArray(location)) {
                            folds = [];
                            location.forEach(function(range) {
                                folds = folds.concat(this.unfold(range));
                            }, this);
                            return folds;
                        } else {
                            range = location;
                        }
                        folds = this.getFoldsInRangeList(range);
                        var outermostFolds = folds;
                        // if range itself is in a fold, expand that fold instead of removing, 
                        // to not accidentally remove sibling folds
                        while(folds.length == 1 && Range.comparePoints(folds[0].start, range.start) < 0 && Range.comparePoints(folds[0].end, range.end) > 0){
                            this.expandFolds(folds);
                            folds = this.getFoldsInRangeList(range);
                        }
                        if (expandInner != false) {
                            this.removeFolds(folds);
                        } else {
                            this.expandFolds(folds);
                        }
                        if (outermostFolds.length) return outermostFolds;
                    };
                    /*
     * Checks if a given documentRow is folded. This is true if there are some
     * folded parts such that some parts of the line is still visible.
     **/ this.isRowFolded = function(docRow, startFoldRow) {
                        return !!this.getFoldLine(docRow, startFoldRow);
                    };
                    this.getRowFoldEnd = function(docRow, startFoldRow) {
                        var foldLine = this.getFoldLine(docRow, startFoldRow);
                        return foldLine ? foldLine.end.row : docRow;
                    };
                    this.getRowFoldStart = function(docRow, startFoldRow) {
                        var foldLine = this.getFoldLine(docRow, startFoldRow);
                        return foldLine ? foldLine.start.row : docRow;
                    };
                    this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {
                        if (startRow == null) startRow = foldLine.start.row;
                        if (startColumn == null) startColumn = 0;
                        if (endRow == null) endRow = foldLine.end.row;
                        if (endColumn == null) endColumn = this.getLine(endRow).length;
                        // Build the textline using the FoldLine walker.
                        var doc = this.doc;
                        var textLine = "";
                        foldLine.walk(function(placeholder, row, column, lastColumn) {
                            if (row < startRow) return;
                            if (row == startRow) {
                                if (column < startColumn) return;
                                lastColumn = Math.max(startColumn, lastColumn);
                            }
                            if (placeholder != null) {
                                textLine += placeholder;
                            } else {
                                textLine += doc.getLine(row).substring(lastColumn, column);
                            }
                        }, endRow, endColumn);
                        return textLine;
                    };
                    this.getDisplayLine = function(row, endColumn, startRow, startColumn) {
                        var foldLine = this.getFoldLine(row);
                        if (!foldLine) {
                            var line;
                            line = this.doc.getLine(row);
                            return line.substring(startColumn || 0, endColumn || line.length);
                        } else {
                            return this.getFoldDisplayLine(foldLine, row, endColumn, startRow, startColumn);
                        }
                    };
                    this.$cloneFoldData = function() {
                        var fd = [];
                        fd = this.$foldData.map(function(foldLine) {
                            var folds = foldLine.folds.map(function(fold) {
                                return fold.clone();
                            });
                            return new FoldLine(fd, folds);
                        });
                        return fd;
                    };
                    this.toggleFold = function(tryToUnfold) {
                        var selection = this.selection;
                        var range = selection.getRange();
                        var fold;
                        var bracketPos;
                        if (range.isEmpty()) {
                            var cursor = range.start;
                            fold = this.getFoldAt(cursor.row, cursor.column);
                            if (fold) {
                                this.expandFold(fold);
                                return;
                            } else if (bracketPos = this.findMatchingBracket(cursor)) {
                                if (range.comparePoint(bracketPos) == 1) {
                                    range.end = bracketPos;
                                } else {
                                    range.start = bracketPos;
                                    range.start.column++;
                                    range.end.column--;
                                }
                            } else if (bracketPos = this.findMatchingBracket({
                                row: cursor.row,
                                column: cursor.column + 1
                            })) {
                                if (range.comparePoint(bracketPos) == 1) range.end = bracketPos;
                                else range.start = bracketPos;
                                range.start.column++;
                            } else {
                                range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
                            }
                        } else {
                            var folds = this.getFoldsInRange(range);
                            if (tryToUnfold && folds.length) {
                                this.expandFolds(folds);
                                return;
                            } else if (folds.length == 1) {
                                fold = folds[0];
                            }
                        }
                        if (!fold) fold = this.getFoldAt(range.start.row, range.start.column);
                        if (fold && fold.range.toString() == range.toString()) {
                            this.expandFold(fold);
                            return;
                        }
                        var placeholder = "...";
                        if (!range.isMultiLine()) {
                            placeholder = this.getTextRange(range);
                            if (placeholder.length < 4) return;
                            placeholder = placeholder.trim().substring(0, 2) + "..";
                        }
                        this.addFold(placeholder, range);
                    };
                    this.getCommentFoldRange = function(row, column, dir) {
                        var iterator = new TokenIterator(this, row, column);
                        var token = iterator.getCurrentToken();
                        var type = token && token.type;
                        if (token && /^comment|string/.test(type)) {
                            type = type.match(/comment|string/)[0];
                            if (type == "comment") type += "|doc-start";
                            var re = new RegExp(type);
                            var range = new Range();
                            if (dir != 1) {
                                do {
                                    token = iterator.stepBackward();
                                }while (token && re.test(token.type) && !/^comment.end/.test(token.type));
                                token = iterator.stepForward();
                            }
                            range.start.row = iterator.getCurrentTokenRow();
                            range.start.column = iterator.getCurrentTokenColumn() + (/^comment.start/.test(token.type) ? token.value.length : 2);
                            iterator = new TokenIterator(this, row, column);
                            if (dir != -1) {
                                var lastRow = -1;
                                do {
                                    token = iterator.stepForward();
                                    if (lastRow == -1) {
                                        var state = this.getState(iterator.$row);
                                        if (!re.test(state)) lastRow = iterator.$row;
                                    } else if (iterator.$row > lastRow) {
                                        break;
                                    }
                                }while (token && re.test(token.type) && !/^comment.start/.test(token.type));
                                token = iterator.stepBackward();
                            } else token = iterator.getCurrentToken();
                            range.end.row = iterator.getCurrentTokenRow();
                            range.end.column = iterator.getCurrentTokenColumn();
                            if (!/^comment.end/.test(token.type)) {
                                range.end.column += token.value.length - 2;
                            }
                            return range;
                        }
                    };
                    this.foldAll = function(startRow, endRow, depth, test) {
                        if (depth == undefined) depth = 100000; // JSON.stringify doesn't hanle Infinity
                        var foldWidgets = this.foldWidgets;
                        if (!foldWidgets) return; // mode doesn't support folding
                        endRow = endRow || this.getLength();
                        startRow = startRow || 0;
                        for(var row = startRow; row < endRow; row++){
                            if (foldWidgets[row] == null) foldWidgets[row] = this.getFoldWidget(row);
                            if (foldWidgets[row] != "start") continue;
                            if (test && !test(row)) continue;
                            var range = this.getFoldWidgetRange(row);
                            if (range && range.isMultiLine() && range.end.row <= endRow && range.start.row >= startRow) {
                                row = range.end.row;
                                range.collapseChildren = depth;
                                // addFold can change the range
                                this.addFold("...", range);
                            }
                        }
                    };
                    this.foldToLevel = function(level) {
                        this.foldAll();
                        while(level-- > 0)this.unfold(null, false);
                    };
                    this.foldAllComments = function() {
                        var session = this;
                        this.foldAll(null, null, null, function(row) {
                            var tokens = session.getTokens(row);
                            for(var i = 0; i < tokens.length; i++){
                                var token = tokens[i];
                                if (token.type == "text" && /^\s+$/.test(token.value)) continue;
                                if (/comment/.test(token.type)) return true;
                                return false;
                            }
                        });
                    };
                    // structured folding
                    this.$foldStyles = {
                        "manual": 1,
                        "markbegin": 1,
                        "markbeginend": 1
                    };
                    this.$foldStyle = "markbegin";
                    this.setFoldStyle = function(style) {
                        if (!this.$foldStyles[style]) throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
                        if (this.$foldStyle == style) return;
                        this.$foldStyle = style;
                        if (style == "manual") this.unfold();
                        // reset folding
                        var mode = this.$foldMode;
                        this.$setFolding(null);
                        this.$setFolding(mode);
                    };
                    this.$setFolding = function(foldMode) {
                        if (this.$foldMode == foldMode) return;
                        this.$foldMode = foldMode;
                        this.off("change", this.$updateFoldWidgets);
                        this.off("tokenizerUpdate", this.$tokenizerUpdateFoldWidgets);
                        this._signal("changeAnnotation");
                        if (!foldMode || this.$foldStyle == "manual") {
                            this.foldWidgets = null;
                            return;
                        }
                        this.foldWidgets = [];
                        this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
                        this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
                        this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
                        this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
                        this.on("change", this.$updateFoldWidgets);
                        this.on("tokenizerUpdate", this.$tokenizerUpdateFoldWidgets);
                    };
                    this.getParentFoldRangeData = function(row, ignoreCurrent) {
                        var fw = this.foldWidgets;
                        if (!fw || ignoreCurrent && fw[row]) return {};
                        var i = row - 1, firstRange;
                        while(i >= 0){
                            var c = fw[i];
                            if (c == null) c = fw[i] = this.getFoldWidget(i);
                            if (c == "start") {
                                var range = this.getFoldWidgetRange(i);
                                if (!firstRange) firstRange = range;
                                if (range && range.end.row >= row) break;
                            }
                            i--;
                        }
                        return {
                            range: i !== -1 && range,
                            firstRange: firstRange
                        };
                    };
                    this.onFoldWidgetClick = function(row, e) {
                        e = e.domEvent;
                        var options = {
                            children: e.shiftKey,
                            all: e.ctrlKey || e.metaKey,
                            siblings: e.altKey
                        };
                        var range = this.$toggleFoldWidget(row, options);
                        if (!range) {
                            var el = e.target || e.srcElement;
                            if (el && /ace_fold-widget/.test(el.className)) el.className += " ace_invalid";
                        }
                    };
                    this.$toggleFoldWidget = function(row, options) {
                        if (!this.getFoldWidget) return;
                        var type = this.getFoldWidget(row);
                        var line = this.getLine(row);
                        var dir = type === "end" ? -1 : 1;
                        var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);
                        if (fold) {
                            if (options.children || options.all) this.removeFold(fold);
                            else this.expandFold(fold);
                            return fold;
                        }
                        var range = this.getFoldWidgetRange(row, true);
                        // sometimes singleline folds can be missed by the code above
                        if (range && !range.isMultiLine()) {
                            fold = this.getFoldAt(range.start.row, range.start.column, 1);
                            if (fold && range.isEqual(fold.range)) {
                                this.removeFold(fold);
                                return fold;
                            }
                        }
                        if (options.siblings) {
                            var data = this.getParentFoldRangeData(row);
                            if (data.range) {
                                var startRow = data.range.start.row + 1;
                                var endRow = data.range.end.row;
                            }
                            this.foldAll(startRow, endRow, options.all ? 10000 : 0);
                        } else if (options.children) {
                            endRow = range ? range.end.row : this.getLength();
                            this.foldAll(row + 1, endRow, options.all ? 10000 : 0);
                        } else if (range) {
                            if (options.all) range.collapseChildren = 10000;
                            this.addFold("...", range);
                        }
                        return range;
                    };
                    this.toggleFoldWidget = function(toggleParent) {
                        var row = this.selection.getCursor().row;
                        row = this.getRowFoldStart(row);
                        var range = this.$toggleFoldWidget(row, {});
                        if (range) return;
                        // handle toggleParent
                        var data = this.getParentFoldRangeData(row, true);
                        range = data.range || data.firstRange;
                        if (range) {
                            row = range.start.row;
                            var fold = this.getFoldAt(row, this.getLine(row).length, 1);
                            if (fold) {
                                this.removeFold(fold);
                            } else {
                                this.addFold("...", range);
                            }
                        }
                    };
                    this.updateFoldWidgets = function(delta) {
                        var firstRow = delta.start.row;
                        var len = delta.end.row - firstRow;
                        if (len === 0) {
                            this.foldWidgets[firstRow] = null;
                        } else if (delta.action == "remove") {
                            this.foldWidgets.splice(firstRow, len + 1, null);
                        } else {
                            var args = Array(len + 1);
                            args.unshift(firstRow, 1);
                            this.foldWidgets.splice.apply(this.foldWidgets, args);
                        }
                    };
                    this.tokenizerUpdateFoldWidgets = function(e) {
                        var rows = e.data;
                        if (rows.first != rows.last) {
                            if (this.foldWidgets.length > rows.first) this.foldWidgets.splice(rows.first, this.foldWidgets.length);
                        }
                    };
                };
                var Range = __nested_webpack_require_361488__(3069)/* .Range */ .e;
                var FoldLine = __nested_webpack_require_361488__(4138)/* .FoldLine */ .z;
                var Fold = __nested_webpack_require_361488__(8363)/* .Fold */ .q;
                var TokenIterator = __nested_webpack_require_361488__(7726)/* .TokenIterator */ .N;
                exports1.x = Folding;
            /***/ },
            /***/ 7180: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_399492__) {
                "use strict";
                var oop = __nested_webpack_require_399492__(2011);
                var dom = __nested_webpack_require_399492__(5336);
                var lang = __nested_webpack_require_399492__(732);
                var useragent = __nested_webpack_require_399492__(8057);
                var TextInput = __nested_webpack_require_399492__(58)/* .TextInput */ .o;
                var MouseHandler = __nested_webpack_require_399492__(6581)/* .MouseHandler */ .S;
                var FoldHandler = __nested_webpack_require_399492__(6049)/* .FoldHandler */ .z;
                var KeyBinding = __nested_webpack_require_399492__(1058)/* .KeyBinding */ .M;
                var EditSession = __nested_webpack_require_399492__(8827)/* .EditSession */ .m;
                var Search = __nested_webpack_require_399492__(3002)/* .Search */ .o;
                var Range = __nested_webpack_require_399492__(3069)/* .Range */ .e;
                var EventEmitter = __nested_webpack_require_399492__(7858)/* .EventEmitter */ .v;
                var CommandManager = __nested_webpack_require_399492__(4278)/* .CommandManager */ .f;
                var defaultCommands = __nested_webpack_require_399492__(4922)/* .commands */ .C;
                var config = __nested_webpack_require_399492__(3294);
                var TokenIterator = __nested_webpack_require_399492__(7726)/* .TokenIterator */ .N;
                var LineWidgets = __nested_webpack_require_399492__(1252)/* .LineWidgets */ .H;
                var clipboard = __nested_webpack_require_399492__(6514);
                var keys = __nested_webpack_require_399492__(1492);
                /**
 * The main entry point into the Ace functionality.
 *
 * The `Editor` manages the [[EditSession]] (which manages [[Document]]s), as well as the [[VirtualRenderer]], which draws everything to the screen.
 *
 * Event sessions dealing with the mouse and keyboard are bubbled up from `Document` to the `Editor`, which decides what to do with them.
 **/ var Editor = /*#__PURE__*/ function() {
                    function Editor(renderer, session, options) {
                        _class_call_check(this, Editor);
                        this.$toDestroy = [];
                        var container = renderer.getContainerElement();
                        this.container = container;
                        this.renderer = renderer;
                        this.id = "editor" + ++Editor.$uid;
                        this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
                        if (typeof document == "object") {
                            this.textInput = new TextInput(renderer.getTextAreaContainer(), this);
                            this.renderer.textarea = this.textInput.getElement();
                            // TODO detect touch event support
                            this.$mouseHandler = new MouseHandler(this);
                            new FoldHandler(this);
                        }
                        this.keyBinding = new KeyBinding(this);
                        this.$search = new Search().set({
                            wrap: true
                        });
                        this.$historyTracker = this.$historyTracker.bind(this);
                        this.commands.on("exec", this.$historyTracker);
                        this.$initOperationListeners();
                        this._$emitInputEvent = lang.delayedCall((function() {
                            this._signal("input", {});
                            if (this.session && !this.session.destroyed) this.session.bgTokenizer.scheduleStart();
                        }).bind(this));
                        this.on("change", function(_, _self) {
                            _self._$emitInputEvent.schedule(31);
                        });
                        this.setSession(session || options && options.session || new EditSession(""));
                        config.resetOptions(this);
                        if (options) this.setOptions(options);
                        config._signal("editor", this);
                    }
                    _create_class(Editor, [
                        {
                            key: "$initOperationListeners",
                            value: function $initOperationListeners() {
                                this.commands.on("exec", this.startOperation.bind(this), true);
                                this.commands.on("afterExec", this.endOperation.bind(this), true);
                                this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this, true));
                                // todo: add before change events?
                                this.on("change", (function() {
                                    if (!this.curOp) {
                                        this.startOperation();
                                        this.curOp.selectionBefore = this.$lastSel;
                                    }
                                    this.curOp.docChanged = true;
                                }).bind(this), true);
                                this.on("changeSelection", (function() {
                                    if (!this.curOp) {
                                        this.startOperation();
                                        this.curOp.selectionBefore = this.$lastSel;
                                    }
                                    this.curOp.selectionChanged = true;
                                }).bind(this), true);
                            }
                        },
                        {
                            key: "startOperation",
                            value: function startOperation(commandEvent) {
                                if (this.curOp) {
                                    if (!commandEvent || this.curOp.command) return;
                                    this.prevOp = this.curOp;
                                }
                                if (!commandEvent) {
                                    this.previousCommand = null;
                                    commandEvent = {};
                                }
                                this.$opResetTimer.schedule();
                                this.curOp = this.session.curOp = {
                                    command: commandEvent.command || {},
                                    args: commandEvent.args,
                                    scrollTop: this.renderer.scrollTop
                                };
                                this.curOp.selectionBefore = this.selection.toJSON();
                            }
                        },
                        {
                            key: "endOperation",
                            value: function endOperation(e) {
                                if (this.curOp && this.session) {
                                    if (e && e.returnValue === false || !this.session) return this.curOp = null;
                                    if (e == true && this.curOp.command && this.curOp.command.name == "mouse") return;
                                    this._signal("beforeEndOperation");
                                    if (!this.curOp) return;
                                    var command = this.curOp.command;
                                    var scrollIntoView = command && command.scrollIntoView;
                                    if (scrollIntoView) {
                                        switch(scrollIntoView){
                                            case "center-animate":
                                                scrollIntoView = "animate";
                                            /* fall through */ case "center":
                                                this.renderer.scrollCursorIntoView(null, 0.5);
                                                break;
                                            case "animate":
                                            case "cursor":
                                                this.renderer.scrollCursorIntoView();
                                                break;
                                            case "selectionPart":
                                                var range = this.selection.getRange();
                                                var config = this.renderer.layerConfig;
                                                if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {
                                                    this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                                                }
                                                break;
                                            default:
                                                break;
                                        }
                                        if (scrollIntoView == "animate") this.renderer.animateScrolling(this.curOp.scrollTop);
                                    }
                                    var sel = this.selection.toJSON();
                                    this.curOp.selectionAfter = sel;
                                    this.$lastSel = this.selection.toJSON();
                                    // console.log(this.$lastSel+"  endOP")
                                    this.session.getUndoManager().addSelection(sel);
                                    this.prevOp = this.curOp;
                                    this.curOp = null;
                                }
                            }
                        },
                        {
                            key: "$historyTracker",
                            value: function $historyTracker(e) {
                                if (!this.$mergeUndoDeltas) return;
                                var prev = this.prevOp;
                                var mergeableCommands = this.$mergeableCommands;
                                // previous command was the same
                                var shouldMerge = prev.command && e.command.name == prev.command.name;
                                if (e.command.name == "insertstring") {
                                    var text = e.args;
                                    if (this.mergeNextCommand === undefined) this.mergeNextCommand = true;
                                    shouldMerge = shouldMerge && this.mergeNextCommand // previous command allows to coalesce with
                                     && (!/\s/.test(text) || /\s/.test(prev.args)); // previous insertion was of same type
                                    this.mergeNextCommand = true;
                                } else {
                                    shouldMerge = shouldMerge && mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable
                                }
                                if (this.$mergeUndoDeltas != "always" && Date.now() - this.sequenceStartTime > 2000) {
                                    shouldMerge = false; // the sequence is too long
                                }
                                if (shouldMerge) this.session.mergeUndoDeltas = true;
                                else if (mergeableCommands.indexOf(e.command.name) !== -1) this.sequenceStartTime = Date.now();
                            }
                        },
                        {
                            /**
     * Sets a new key handler, such as "vim" or "windows".
     * @param {String} keyboardHandler The new key handler
     *
     **/ key: "setKeyboardHandler",
                            value: function setKeyboardHandler(keyboardHandler, cb) {
                                if (keyboardHandler && typeof keyboardHandler === "string" && keyboardHandler != "ace") {
                                    this.$keybindingId = keyboardHandler;
                                    var _self = this;
                                    config.loadModule([
                                        "keybinding",
                                        keyboardHandler
                                    ], function(module1) {
                                        if (_self.$keybindingId == keyboardHandler) _self.keyBinding.setKeyboardHandler(module1 && module1.handler);
                                        cb && cb();
                                    });
                                } else {
                                    this.$keybindingId = null;
                                    this.keyBinding.setKeyboardHandler(keyboardHandler);
                                    cb && cb();
                                }
                            }
                        },
                        {
                            /**
     * Returns the keyboard handler, such as "vim" or "windows".
     *
     * @returns {String}
     *
     **/ key: "getKeyboardHandler",
                            value: function getKeyboardHandler() {
                                return this.keyBinding.getKeyboardHandler();
                            }
                        },
                        {
                            /**
     * Emitted whenever the [[EditSession]] changes.
     * @event changeSession
     * @param {Object} e An object with two properties, `oldSession` and `session`, that represent the old and new [[EditSession]]s.
     *
     **/ /**
     * Sets a new editsession to use. This method also emits the `'changeSession'` event.
     * @param {EditSession} session The new session to use
     *
     **/ key: "setSession",
                            value: function setSession(session) {
                                if (this.session == session) return;
                                // make sure operationEnd events are not emitted to wrong session
                                if (this.curOp) this.endOperation();
                                this.curOp = {};
                                var oldSession = this.session;
                                if (oldSession) {
                                    this.session.off("change", this.$onDocumentChange);
                                    this.session.off("changeMode", this.$onChangeMode);
                                    this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
                                    this.session.off("changeTabSize", this.$onChangeTabSize);
                                    this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
                                    this.session.off("changeWrapMode", this.$onChangeWrapMode);
                                    this.session.off("changeFold", this.$onChangeFold);
                                    this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
                                    this.session.off("changeBackMarker", this.$onChangeBackMarker);
                                    this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
                                    this.session.off("changeAnnotation", this.$onChangeAnnotation);
                                    this.session.off("changeOverwrite", this.$onCursorChange);
                                    this.session.off("changeScrollTop", this.$onScrollTopChange);
                                    this.session.off("changeScrollLeft", this.$onScrollLeftChange);
                                    var selection = this.session.getSelection();
                                    selection.off("changeCursor", this.$onCursorChange);
                                    selection.off("changeSelection", this.$onSelectionChange);
                                }
                                this.session = session;
                                if (session) {
                                    this.$onDocumentChange = this.onDocumentChange.bind(this);
                                    session.on("change", this.$onDocumentChange);
                                    this.renderer.setSession(session);
                                    this.$onChangeMode = this.onChangeMode.bind(this);
                                    session.on("changeMode", this.$onChangeMode);
                                    this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
                                    session.on("tokenizerUpdate", this.$onTokenizerUpdate);
                                    this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
                                    session.on("changeTabSize", this.$onChangeTabSize);
                                    this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
                                    session.on("changeWrapLimit", this.$onChangeWrapLimit);
                                    this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
                                    session.on("changeWrapMode", this.$onChangeWrapMode);
                                    this.$onChangeFold = this.onChangeFold.bind(this);
                                    session.on("changeFold", this.$onChangeFold);
                                    this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
                                    this.session.on("changeFrontMarker", this.$onChangeFrontMarker);
                                    this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
                                    this.session.on("changeBackMarker", this.$onChangeBackMarker);
                                    this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
                                    this.session.on("changeBreakpoint", this.$onChangeBreakpoint);
                                    this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
                                    this.session.on("changeAnnotation", this.$onChangeAnnotation);
                                    this.$onCursorChange = this.onCursorChange.bind(this);
                                    this.session.on("changeOverwrite", this.$onCursorChange);
                                    this.$onScrollTopChange = this.onScrollTopChange.bind(this);
                                    this.session.on("changeScrollTop", this.$onScrollTopChange);
                                    this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
                                    this.session.on("changeScrollLeft", this.$onScrollLeftChange);
                                    this.selection = session.getSelection();
                                    this.selection.on("changeCursor", this.$onCursorChange);
                                    this.$onSelectionChange = this.onSelectionChange.bind(this);
                                    this.selection.on("changeSelection", this.$onSelectionChange);
                                    this.onChangeMode();
                                    this.onCursorChange();
                                    this.onScrollTopChange();
                                    this.onScrollLeftChange();
                                    this.onSelectionChange();
                                    this.onChangeFrontMarker();
                                    this.onChangeBackMarker();
                                    this.onChangeBreakpoint();
                                    this.onChangeAnnotation();
                                    this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
                                    this.renderer.updateFull();
                                } else {
                                    this.selection = null;
                                    this.renderer.setSession(session);
                                }
                                this._signal("changeSession", {
                                    session: session,
                                    oldSession: oldSession
                                });
                                this.curOp = null;
                                oldSession && oldSession._signal("changeEditor", {
                                    oldEditor: this
                                });
                                session && session._signal("changeEditor", {
                                    editor: this
                                });
                                if (session && !session.destroyed) session.bgTokenizer.scheduleStart();
                            }
                        },
                        {
                            /**
     * Returns the current session being used.
     * @returns {EditSession}
     **/ key: "getSession",
                            value: function getSession() {
                                return this.session;
                            }
                        },
                        {
                            /**
     * Sets the current document to `val`.
     * @param {String} val The new value to set for the document
     * @param {Number} cursorPos Where to set the new value. `undefined` or 0 is selectAll, -1 is at the document start, and 1 is at the end
     *
     * @returns {String} The current document value
     * @related Document.setValue
     **/ key: "setValue",
                            value: function setValue(val, cursorPos) {
                                this.session.doc.setValue(val);
                                if (!cursorPos) this.selectAll();
                                else if (cursorPos == 1) this.navigateFileEnd();
                                else if (cursorPos == -1) this.navigateFileStart();
                                return val;
                            }
                        },
                        {
                            /**
     * Returns the current session's content.
     *
     * @returns {String}
     * @related EditSession.getValue
     **/ key: "getValue",
                            value: function getValue() {
                                return this.session.getValue();
                            }
                        },
                        {
                            /**
     *
     * Returns the currently highlighted selection.
     * @returns {Selection} The selection object
     **/ key: "getSelection",
                            value: function getSelection() {
                                return this.selection;
                            }
                        },
                        {
                            /**
     * {:VirtualRenderer.onResize}
     * @param {Boolean} force If `true`, recomputes the size, even if the height and width haven't changed
     *
     *
     * @related VirtualRenderer.onResize
     **/ key: "resize",
                            value: function resize(force) {
                                this.renderer.onResize(force);
                            }
                        },
                        {
                            /**
     * {:VirtualRenderer.setTheme}
     * @param {String} theme The path to a theme
     * @param {Function} cb optional callback called when theme is loaded
     **/ key: "setTheme",
                            value: function setTheme(theme, cb) {
                                this.renderer.setTheme(theme, cb);
                            }
                        },
                        {
                            /**
     * {:VirtualRenderer.getTheme}
     *
     * @returns {String} The set theme
     * @related VirtualRenderer.getTheme
     **/ key: "getTheme",
                            value: function getTheme() {
                                return this.renderer.getTheme();
                            }
                        },
                        {
                            /**
     * {:VirtualRenderer.setStyle}
     * @param {String} style A class name
     *
     *
     * @related VirtualRenderer.setStyle
     **/ key: "setStyle",
                            value: function setStyle(style) {
                                this.renderer.setStyle(style);
                            }
                        },
                        {
                            /**
     * {:VirtualRenderer.unsetStyle}
     * @related VirtualRenderer.unsetStyle
     **/ key: "unsetStyle",
                            value: function unsetStyle(style) {
                                this.renderer.unsetStyle(style);
                            }
                        },
                        {
                            /**
     * Gets the current font size of the editor text.
     */ key: "getFontSize",
                            value: function getFontSize() {
                                return this.getOption("fontSize") || dom.computedStyle(this.container).fontSize;
                            }
                        },
                        {
                            /**
     * Set a new font size (in pixels) for the editor text.
     * @param {String} size A font size ( _e.g._ "12px")
     *
     *
     **/ key: "setFontSize",
                            value: function setFontSize(size) {
                                this.setOption("fontSize", size);
                            }
                        },
                        {
                            key: "$highlightBrackets",
                            value: function $highlightBrackets() {
                                if (this.$highlightPending) {
                                    return;
                                }
                                // perform highlight async to not block the browser during navigation
                                var _$self = this;
                                this.$highlightPending = true;
                                setTimeout(function() {
                                    _$self.$highlightPending = false;
                                    var session = _$self.session;
                                    if (!session || session.destroyed) return;
                                    if (session.$bracketHighlight) {
                                        session.$bracketHighlight.markerIds.forEach(function(id) {
                                            session.removeMarker(id);
                                        });
                                        session.$bracketHighlight = null;
                                    }
                                    var pos = _$self.getCursorPosition();
                                    var handler = _$self.getKeyboardHandler();
                                    var isBackwards = handler && handler.$getDirectionForHighlight && handler.$getDirectionForHighlight(_$self);
                                    var ranges = session.getMatchingBracketRanges(pos, isBackwards);
                                    if (!ranges) {
                                        var iterator = new TokenIterator(session, pos.row, pos.column);
                                        var token = iterator.getCurrentToken();
                                        if (token && /\b(?:tag-open|tag-name)/.test(token.type)) {
                                            var tagNamesRanges = session.getMatchingTags(pos);
                                            if (tagNamesRanges) ranges = [
                                                tagNamesRanges.openTagName,
                                                tagNamesRanges.closeTagName
                                            ];
                                        }
                                    }
                                    if (!ranges && session.$mode.getMatching) ranges = session.$mode.getMatching(_$self.session);
                                    if (!ranges) {
                                        if (_$self.getHighlightIndentGuides()) _$self.renderer.$textLayer.$highlightIndentGuide();
                                        return;
                                    }
                                    var markerType = "ace_bracket";
                                    if (!Array.isArray(ranges)) {
                                        ranges = [
                                            ranges
                                        ];
                                    } else if (ranges.length == 1) {
                                        markerType = "ace_error_bracket";
                                    }
                                    // show adjacent ranges as one
                                    if (ranges.length == 2) {
                                        if (Range.comparePoints(ranges[0].end, ranges[1].start) == 0) ranges = [
                                            Range.fromPoints(ranges[0].start, ranges[1].end)
                                        ];
                                        else if (Range.comparePoints(ranges[0].start, ranges[1].end) == 0) ranges = [
                                            Range.fromPoints(ranges[1].start, ranges[0].end)
                                        ];
                                    }
                                    session.$bracketHighlight = {
                                        ranges: ranges,
                                        markerIds: ranges.map(function(range) {
                                            return session.addMarker(range, markerType, "text");
                                        })
                                    };
                                    if (_$self.getHighlightIndentGuides()) _$self.renderer.$textLayer.$highlightIndentGuide();
                                }, 50);
                            }
                        },
                        {
                            /**
     *
     * Brings the current `textInput` into focus.
     **/ key: "focus",
                            value: function focus() {
                                this.textInput.focus();
                            }
                        },
                        {
                            /**
     * Returns `true` if the current `textInput` is in focus.
     * @return {Boolean}
     **/ key: "isFocused",
                            value: function isFocused() {
                                return this.textInput.isFocused();
                            }
                        },
                        {
                            /**
     *
     * Blurs the current `textInput`.
     **/ key: "blur",
                            value: function blur() {
                                this.textInput.blur();
                            }
                        },
                        {
                            /**
     * Emitted once the editor comes into focus.
     * @event focus
     *
     *
     **/ key: "onFocus",
                            value: function onFocus(e) {
                                if (this.$isFocused) return;
                                this.$isFocused = true;
                                this.renderer.showCursor();
                                this.renderer.visualizeFocus();
                                this._emit("focus", e);
                            }
                        },
                        {
                            /**
     * Emitted once the editor has been blurred.
     * @event blur
     *
     *
     **/ key: "onBlur",
                            value: function onBlur(e) {
                                if (!this.$isFocused) return;
                                this.$isFocused = false;
                                this.renderer.hideCursor();
                                this.renderer.visualizeBlur();
                                this._emit("blur", e);
                            }
                        },
                        {
                            key: "$cursorChange",
                            value: function $cursorChange() {
                                this.renderer.updateCursor();
                                this.$highlightBrackets();
                                this.$updateHighlightActiveLine();
                            }
                        },
                        {
                            /**
     * Emitted whenever the document is changed.
     * @event change
     * @param {Object} delta Contains a single property, `data`, which has the delta of changes
     *
     *
     *
     **/ key: "onDocumentChange",
                            value: function onDocumentChange(delta) {
                                // Rerender and emit "change" event.
                                var wrap = this.session.$useWrapMode;
                                var lastRow = delta.start.row == delta.end.row ? delta.end.row : Infinity;
                                this.renderer.updateLines(delta.start.row, lastRow, wrap);
                                this._signal("change", delta);
                                // Update cursor because tab characters can influence the cursor position.
                                this.$cursorChange();
                            }
                        },
                        {
                            key: "onTokenizerUpdate",
                            value: function onTokenizerUpdate(e) {
                                var rows = e.data;
                                this.renderer.updateLines(rows.first, rows.last);
                            }
                        },
                        {
                            key: "onScrollTopChange",
                            value: function onScrollTopChange() {
                                this.renderer.scrollToY(this.session.getScrollTop());
                            }
                        },
                        {
                            key: "onScrollLeftChange",
                            value: function onScrollLeftChange() {
                                this.renderer.scrollToX(this.session.getScrollLeft());
                            }
                        },
                        {
                            /**
     * Emitted when the selection changes.
     *
     **/ key: "onCursorChange",
                            value: function onCursorChange() {
                                this.$cursorChange();
                                this._signal("changeSelection");
                            }
                        },
                        {
                            key: "$updateHighlightActiveLine",
                            value: function $updateHighlightActiveLine() {
                                var session = this.getSession();
                                var highlight;
                                if (this.$highlightActiveLine) {
                                    if (this.$selectionStyle != "line" || !this.selection.isMultiLine()) highlight = this.getCursorPosition();
                                    if (this.renderer.theme && this.renderer.theme.$selectionColorConflict && !this.selection.isEmpty()) highlight = false;
                                    if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1)) highlight = false;
                                }
                                if (session.$highlightLineMarker && !highlight) {
                                    session.removeMarker(session.$highlightLineMarker.id);
                                    session.$highlightLineMarker = null;
                                } else if (!session.$highlightLineMarker && highlight) {
                                    var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
                                    range.id = session.addMarker(range, "ace_active-line", "screenLine");
                                    session.$highlightLineMarker = range;
                                } else if (highlight) {
                                    session.$highlightLineMarker.start.row = highlight.row;
                                    session.$highlightLineMarker.end.row = highlight.row;
                                    session.$highlightLineMarker.start.column = highlight.column;
                                    session._signal("changeBackMarker");
                                }
                            }
                        },
                        {
                            key: "onSelectionChange",
                            value: function onSelectionChange(e) {
                                var session = this.session;
                                if (session.$selectionMarker) {
                                    session.removeMarker(session.$selectionMarker);
                                }
                                session.$selectionMarker = null;
                                if (!this.selection.isEmpty()) {
                                    var range = this.selection.getRange();
                                    var style = this.getSelectionStyle();
                                    session.$selectionMarker = session.addMarker(range, "ace_selection", style);
                                } else {
                                    this.$updateHighlightActiveLine();
                                }
                                var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
                                this.session.highlight(re);
                                this._signal("changeSelection");
                            }
                        },
                        {
                            key: "$getSelectionHighLightRegexp",
                            value: function $getSelectionHighLightRegexp() {
                                var session = this.session;
                                var selection = this.getSelectionRange();
                                if (selection.isEmpty() || selection.isMultiLine()) return;
                                var startColumn = selection.start.column;
                                var endColumn = selection.end.column;
                                var line = session.getLine(selection.start.row);
                                var needle = line.substring(startColumn, endColumn);
                                // maximum allowed size for regular expressions in 32000, 
                                // but getting close to it has significant impact on the performance
                                if (needle.length > 5000 || !/[\w\d]/.test(needle)) return;
                                var re = this.$search.$assembleRegExp({
                                    wholeWord: true,
                                    caseSensitive: true,
                                    needle: needle
                                });
                                var wordWithBoundary = line.substring(startColumn - 1, endColumn + 1);
                                if (!re.test(wordWithBoundary)) return;
                                return re;
                            }
                        },
                        {
                            key: "onChangeFrontMarker",
                            value: function onChangeFrontMarker() {
                                this.renderer.updateFrontMarkers();
                            }
                        },
                        {
                            key: "onChangeBackMarker",
                            value: function onChangeBackMarker() {
                                this.renderer.updateBackMarkers();
                            }
                        },
                        {
                            key: "onChangeBreakpoint",
                            value: function onChangeBreakpoint() {
                                this.renderer.updateBreakpoints();
                            }
                        },
                        {
                            key: "onChangeAnnotation",
                            value: function onChangeAnnotation() {
                                this.renderer.setAnnotations(this.session.getAnnotations());
                            }
                        },
                        {
                            key: "onChangeMode",
                            value: function onChangeMode(e) {
                                this.renderer.updateText();
                                this._emit("changeMode", e);
                            }
                        },
                        {
                            key: "onChangeWrapLimit",
                            value: function onChangeWrapLimit() {
                                this.renderer.updateFull();
                            }
                        },
                        {
                            key: "onChangeWrapMode",
                            value: function onChangeWrapMode() {
                                this.renderer.onResize(true);
                            }
                        },
                        {
                            key: "onChangeFold",
                            value: function onChangeFold() {
                                // Update the active line marker as due to folding changes the current
                                // line range on the screen might have changed.
                                this.$updateHighlightActiveLine();
                                // TODO: This might be too much updating. Okay for now.
                                this.renderer.updateFull();
                            }
                        },
                        {
                            /**
     * Returns the string of text currently highlighted.
     * @returns {String}
     **/ key: "getSelectedText",
                            value: function getSelectedText() {
                                return this.session.getTextRange(this.getSelectionRange());
                            }
                        },
                        {
                            /**
     * Emitted when text is copied.
     * @event copy
     * @param {String} text The copied text
     *
     **/ /**
     * Returns the string of text currently highlighted.
     * @returns {String}
     **/ key: "getCopyText",
                            value: function getCopyText() {
                                var text = this.getSelectedText();
                                var nl = this.session.doc.getNewLineCharacter();
                                var copyLine = false;
                                if (!text && this.$copyWithEmptySelection) {
                                    copyLine = true;
                                    var ranges = this.selection.getAllRanges();
                                    for(var i = 0; i < ranges.length; i++){
                                        var range = ranges[i];
                                        if (i && ranges[i - 1].start.row == range.start.row) continue;
                                        text += this.session.getLine(range.start.row) + nl;
                                    }
                                }
                                var e = {
                                    text: text
                                };
                                this._signal("copy", e);
                                clipboard.lineMode = copyLine ? e.text : false;
                                return e.text;
                            }
                        },
                        {
                            /**
     * Called whenever a text "copy" happens.
     **/ key: "onCopy",
                            value: function onCopy() {
                                this.commands.exec("copy", this);
                            }
                        },
                        {
                            /**
     * Called whenever a text "cut" happens.
     **/ key: "onCut",
                            value: function onCut() {
                                this.commands.exec("cut", this);
                            }
                        },
                        {
                            /**
     * Emitted when text is pasted.
     * @event paste
     * @param {Object} an object which contains one property, `text`, that represents the text to be pasted. Editing this property will alter the text that is pasted.
     *
     *
     **/ /**
     * Called whenever a text "paste" happens.
     * @param {String} text The pasted text
     *
     *
     **/ key: "onPaste",
                            value: function onPaste(text, event) {
                                var e = {
                                    text: text,
                                    event: event
                                };
                                this.commands.exec("paste", this, e);
                            }
                        },
                        {
                            key: "$handlePaste",
                            value: function $handlePaste(e) {
                                if (typeof e == "string") e = {
                                    text: e
                                };
                                this._signal("paste", e);
                                var text = e.text;
                                var lineMode = text === clipboard.lineMode;
                                var session = this.session;
                                if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
                                    if (lineMode) session.insert({
                                        row: this.selection.lead.row,
                                        column: 0
                                    }, text);
                                    else this.insert(text);
                                } else if (lineMode) {
                                    this.selection.rangeList.ranges.forEach(function(range) {
                                        session.insert({
                                            row: range.start.row,
                                            column: 0
                                        }, text);
                                    });
                                } else {
                                    var lines = text.split(/\r\n|\r|\n/);
                                    var ranges = this.selection.rangeList.ranges;
                                    var isFullLine = lines.length == 2 && (!lines[0] || !lines[1]);
                                    if (lines.length != ranges.length || isFullLine) return this.commands.exec("insertstring", this, text);
                                    for(var i = ranges.length; i--;){
                                        var range = ranges[i];
                                        if (!range.isEmpty()) session.remove(range);
                                        session.insert(range.start, lines[i]);
                                    }
                                }
                            }
                        },
                        {
                            key: "execCommand",
                            value: function execCommand(command, args) {
                                return this.commands.exec(command, this, args);
                            }
                        },
                        {
                            /**
     * Inserts `text` into wherever the cursor is pointing.
     * @param {String} text The new text to add
     *
     **/ key: "insert",
                            value: function insert(text, pasted) {
                                var session = this.session;
                                var mode = session.getMode();
                                var cursor = this.getCursorPosition();
                                if (this.getBehavioursEnabled() && !pasted) {
                                    // Get a transform if the current mode wants one.
                                    var transform = mode.transformAction(session.getState(cursor.row), "insertion", this, session, text);
                                    if (transform) {
                                        if (text !== transform.text) {
                                            // keep automatic insertion in a separate delta, unless it is in multiselect mode
                                            if (!this.inVirtualSelectionMode) {
                                                this.session.mergeUndoDeltas = false;
                                                this.mergeNextCommand = false;
                                            }
                                        }
                                        text = transform.text;
                                    }
                                }
                                if (text == "	") text = this.session.getTabString();
                                // remove selected text
                                if (!this.selection.isEmpty()) {
                                    var range = this.getSelectionRange();
                                    cursor = this.session.remove(range);
                                    this.clearSelection();
                                } else if (this.session.getOverwrite() && text.indexOf("\n") == -1) {
                                    var range = new Range.fromPoints(cursor, cursor);
                                    range.end.column += text.length;
                                    this.session.remove(range);
                                }
                                if (text == "\n" || text == "\r\n") {
                                    var line = session.getLine(cursor.row);
                                    if (cursor.column > line.search(/\S|$/)) {
                                        var d = line.substr(cursor.column).search(/\S|$/);
                                        session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
                                    }
                                }
                                this.clearSelection();
                                var start = cursor.column;
                                var lineState = session.getState(cursor.row);
                                var line = session.getLine(cursor.row);
                                var shouldOutdent = mode.checkOutdent(lineState, line, text);
                                session.insert(cursor, text);
                                if (transform && transform.selection) {
                                    if (transform.selection.length == 2) {
                                        this.selection.setSelectionRange(new Range(cursor.row, start + transform.selection[0], cursor.row, start + transform.selection[1]));
                                    } else {
                                        this.selection.setSelectionRange(new Range(cursor.row + transform.selection[0], transform.selection[1], cursor.row + transform.selection[2], transform.selection[3]));
                                    }
                                }
                                if (this.$enableAutoIndent) {
                                    if (session.getDocument().isNewLine(text)) {
                                        var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());
                                        session.insert({
                                            row: cursor.row + 1,
                                            column: 0
                                        }, lineIndent);
                                    }
                                    if (shouldOutdent) mode.autoOutdent(lineState, session, cursor.row);
                                }
                            }
                        },
                        {
                            key: "autoIndent",
                            value: function autoIndent() {
                                var session = this.session;
                                var mode = session.getMode();
                                var startRow, endRow;
                                if (this.selection.isEmpty()) {
                                    startRow = 0;
                                    endRow = session.doc.getLength() - 1;
                                } else {
                                    var selectedRange = this.getSelectionRange();
                                    startRow = selectedRange.start.row;
                                    endRow = selectedRange.end.row;
                                }
                                var prevLineState = "";
                                var prevLine = "";
                                var lineIndent = "";
                                var line, currIndent, range;
                                var tab = session.getTabString();
                                for(var row = startRow; row <= endRow; row++){
                                    if (row > 0) {
                                        prevLineState = session.getState(row - 1);
                                        prevLine = session.getLine(row - 1);
                                        lineIndent = mode.getNextLineIndent(prevLineState, prevLine, tab);
                                    }
                                    line = session.getLine(row);
                                    currIndent = mode.$getIndent(line);
                                    if (lineIndent !== currIndent) {
                                        if (currIndent.length > 0) {
                                            range = new Range(row, 0, row, currIndent.length);
                                            session.remove(range);
                                        }
                                        if (lineIndent.length > 0) {
                                            session.insert({
                                                row: row,
                                                column: 0
                                            }, lineIndent);
                                        }
                                    }
                                    mode.autoOutdent(prevLineState, session, row);
                                }
                            }
                        },
                        {
                            key: "onTextInput",
                            value: function onTextInput(text, composition) {
                                if (!composition) return this.keyBinding.onTextInput(text);
                                this.startOperation({
                                    command: {
                                        name: "insertstring"
                                    }
                                });
                                var applyComposition = this.applyComposition.bind(this, text, composition);
                                if (this.selection.rangeCount) this.forEachSelection(applyComposition);
                                else applyComposition();
                                this.endOperation();
                            }
                        },
                        {
                            key: "applyComposition",
                            value: function applyComposition(text, composition) {
                                if (composition.extendLeft || composition.extendRight) {
                                    var r = this.selection.getRange();
                                    r.start.column -= composition.extendLeft;
                                    r.end.column += composition.extendRight;
                                    if (r.start.column < 0) {
                                        r.start.row--;
                                        r.start.column += this.session.getLine(r.start.row).length + 1;
                                    }
                                    this.selection.setRange(r);
                                    if (!text && !r.isEmpty()) this.remove();
                                }
                                if (text || !this.selection.isEmpty()) this.insert(text, true);
                                if (composition.restoreStart || composition.restoreEnd) {
                                    var r = this.selection.getRange();
                                    r.start.column -= composition.restoreStart;
                                    r.end.column -= composition.restoreEnd;
                                    this.selection.setRange(r);
                                }
                            }
                        },
                        {
                            key: "onCommandKey",
                            value: function onCommandKey(e, hashId, keyCode) {
                                return this.keyBinding.onCommandKey(e, hashId, keyCode);
                            }
                        },
                        {
                            /**
     * Pass in `true` to enable overwrites in your session, or `false` to disable. If overwrites is enabled, any text you enter will type over any text after it. If the value of `overwrite` changes, this function also emits the `changeOverwrite` event.
     * @param {Boolean} overwrite Defines whether or not to set overwrites
     *
     *
     * @related EditSession.setOverwrite
     **/ key: "setOverwrite",
                            value: function setOverwrite(overwrite) {
                                this.session.setOverwrite(overwrite);
                            }
                        },
                        {
                            /**
     * Returns `true` if overwrites are enabled; `false` otherwise.
     * @returns {Boolean}
     * @related EditSession.getOverwrite
     **/ key: "getOverwrite",
                            value: function getOverwrite() {
                                return this.session.getOverwrite();
                            }
                        },
                        {
                            /**
     * Sets the value of overwrite to the opposite of whatever it currently is.
     * @related EditSession.toggleOverwrite
     **/ key: "toggleOverwrite",
                            value: function toggleOverwrite() {
                                this.session.toggleOverwrite();
                            }
                        },
                        {
                            /**
     * Sets how fast the mouse scrolling should do.
     * @param {Number} speed A value indicating the new speed (in milliseconds)
     **/ key: "setScrollSpeed",
                            value: function setScrollSpeed(speed) {
                                this.setOption("scrollSpeed", speed);
                            }
                        },
                        {
                            /**
     * Returns the value indicating how fast the mouse scroll speed is (in milliseconds).
     * @returns {Number}
     **/ key: "getScrollSpeed",
                            value: function getScrollSpeed() {
                                return this.getOption("scrollSpeed");
                            }
                        },
                        {
                            /**
     * Sets the delay (in milliseconds) of the mouse drag.
     * @param {Number} dragDelay A value indicating the new delay
     **/ key: "setDragDelay",
                            value: function setDragDelay(dragDelay) {
                                this.setOption("dragDelay", dragDelay);
                            }
                        },
                        {
                            /**
     * Returns the current mouse drag delay.
     * @returns {Number}
     **/ key: "getDragDelay",
                            value: function getDragDelay() {
                                return this.getOption("dragDelay");
                            }
                        },
                        {
                            /**
     * Emitted when the selection style changes, via [[Editor.setSelectionStyle]].
     * @event changeSelectionStyle
     * @param {Object} data Contains one property, `data`, which indicates the new selection style
     **/ /**
     * Draw selection markers spanning whole line, or only over selected text. Default value is "line"
     * @param {String} val The new selection style "line"|"text"
     *
     **/ key: "setSelectionStyle",
                            value: function setSelectionStyle(val) {
                                this.setOption("selectionStyle", val);
                            }
                        },
                        {
                            /**
     * Returns the current selection style.
     * @returns {String}
     **/ key: "getSelectionStyle",
                            value: function getSelectionStyle() {
                                return this.getOption("selectionStyle");
                            }
                        },
                        {
                            /**
     * Determines whether or not the current line should be highlighted.
     * @param {Boolean} shouldHighlight Set to `true` to highlight the current line
     **/ key: "setHighlightActiveLine",
                            value: function setHighlightActiveLine(shouldHighlight) {
                                this.setOption("highlightActiveLine", shouldHighlight);
                            }
                        },
                        {
                            /**
     * Returns `true` if current lines are always highlighted.
     * @return {Boolean}
     **/ key: "getHighlightActiveLine",
                            value: function getHighlightActiveLine() {
                                return this.getOption("highlightActiveLine");
                            }
                        },
                        {
                            key: "setHighlightGutterLine",
                            value: function setHighlightGutterLine(shouldHighlight) {
                                this.setOption("highlightGutterLine", shouldHighlight);
                            }
                        },
                        {
                            key: "getHighlightGutterLine",
                            value: function getHighlightGutterLine() {
                                return this.getOption("highlightGutterLine");
                            }
                        },
                        {
                            /**
     * Determines if the currently selected word should be highlighted.
     * @param {Boolean} shouldHighlight Set to `true` to highlight the currently selected word
     *
     **/ key: "setHighlightSelectedWord",
                            value: function setHighlightSelectedWord(shouldHighlight) {
                                this.setOption("highlightSelectedWord", shouldHighlight);
                            }
                        },
                        {
                            /**
     * Returns `true` if currently highlighted words are to be highlighted.
     * @returns {Boolean}
     **/ key: "getHighlightSelectedWord",
                            value: function getHighlightSelectedWord() {
                                return this.$highlightSelectedWord;
                            }
                        },
                        {
                            key: "setAnimatedScroll",
                            value: function setAnimatedScroll(shouldAnimate) {
                                this.renderer.setAnimatedScroll(shouldAnimate);
                            }
                        },
                        {
                            key: "getAnimatedScroll",
                            value: function getAnimatedScroll() {
                                return this.renderer.getAnimatedScroll();
                            }
                        },
                        {
                            /**
     * If `showInvisibles` is set to `true`, invisible characters&mdash;like spaces or new lines&mdash;are show in the editor.
     * @param {Boolean} showInvisibles Specifies whether or not to show invisible characters
     *
     **/ key: "setShowInvisibles",
                            value: function setShowInvisibles(showInvisibles) {
                                this.renderer.setShowInvisibles(showInvisibles);
                            }
                        },
                        {
                            /**
     * Returns `true` if invisible characters are being shown.
     * @returns {Boolean}
     **/ key: "getShowInvisibles",
                            value: function getShowInvisibles() {
                                return this.renderer.getShowInvisibles();
                            }
                        },
                        {
                            key: "setDisplayIndentGuides",
                            value: function setDisplayIndentGuides(display) {
                                this.renderer.setDisplayIndentGuides(display);
                            }
                        },
                        {
                            key: "getDisplayIndentGuides",
                            value: function getDisplayIndentGuides() {
                                return this.renderer.getDisplayIndentGuides();
                            }
                        },
                        {
                            key: "setHighlightIndentGuides",
                            value: function setHighlightIndentGuides(highlight) {
                                this.renderer.setHighlightIndentGuides(highlight);
                            }
                        },
                        {
                            key: "getHighlightIndentGuides",
                            value: function getHighlightIndentGuides() {
                                return this.renderer.getHighlightIndentGuides();
                            }
                        },
                        {
                            /**
     * If `showPrintMargin` is set to `true`, the print margin is shown in the editor.
     * @param {Boolean} showPrintMargin Specifies whether or not to show the print margin
     *
     **/ key: "setShowPrintMargin",
                            value: function setShowPrintMargin(showPrintMargin) {
                                this.renderer.setShowPrintMargin(showPrintMargin);
                            }
                        },
                        {
                            /**
     * Returns `true` if the print margin is being shown.
     * @returns {Boolean}
     **/ key: "getShowPrintMargin",
                            value: function getShowPrintMargin() {
                                return this.renderer.getShowPrintMargin();
                            }
                        },
                        {
                            /**
     * Sets the column defining where the print margin should be.
     * @param {Number} showPrintMargin Specifies the new print margin
     *
     **/ key: "setPrintMarginColumn",
                            value: function setPrintMarginColumn(showPrintMargin) {
                                this.renderer.setPrintMarginColumn(showPrintMargin);
                            }
                        },
                        {
                            /**
     * Returns the column number of where the print margin is.
     * @returns {Number}
     **/ key: "getPrintMarginColumn",
                            value: function getPrintMarginColumn() {
                                return this.renderer.getPrintMarginColumn();
                            }
                        },
                        {
                            /**
     * If `readOnly` is true, then the editor is set to read-only mode, and none of the content can change.
     * @param {Boolean} readOnly Specifies whether the editor can be modified or not
     *
     **/ key: "setReadOnly",
                            value: function setReadOnly(readOnly) {
                                this.setOption("readOnly", readOnly);
                            }
                        },
                        {
                            /**
     * Returns `true` if the editor is set to read-only mode.
     * @returns {Boolean}
     **/ key: "getReadOnly",
                            value: function getReadOnly() {
                                return this.getOption("readOnly");
                            }
                        },
                        {
                            /**
     * Specifies whether to use behaviors or not. ["Behaviors" in this case is the auto-pairing of special characters, like quotation marks, parenthesis, or brackets.]{: #BehaviorsDef}
     * @param {Boolean} enabled Enables or disables behaviors
     *
     **/ key: "setBehavioursEnabled",
                            value: function setBehavioursEnabled(enabled) {
                                this.setOption("behavioursEnabled", enabled);
                            }
                        },
                        {
                            /**
     * Returns `true` if the behaviors are currently enabled. {:BehaviorsDef}
     *
     * @returns {Boolean}
     **/ key: "getBehavioursEnabled",
                            value: function getBehavioursEnabled() {
                                return this.getOption("behavioursEnabled");
                            }
                        },
                        {
                            /**
     * Specifies whether to use wrapping behaviors or not, i.e. automatically wrapping the selection with characters such as brackets
     * when such a character is typed in.
     * @param {Boolean} enabled Enables or disables wrapping behaviors
     *
     **/ key: "setWrapBehavioursEnabled",
                            value: function setWrapBehavioursEnabled(enabled) {
                                this.setOption("wrapBehavioursEnabled", enabled);
                            }
                        },
                        {
                            /**
     * Returns `true` if the wrapping behaviors are currently enabled.
     **/ key: "getWrapBehavioursEnabled",
                            value: function getWrapBehavioursEnabled() {
                                return this.getOption("wrapBehavioursEnabled");
                            }
                        },
                        {
                            /**
     * Indicates whether the fold widgets should be shown or not.
     * @param {Boolean} show Specifies whether the fold widgets are shown
     **/ key: "setShowFoldWidgets",
                            value: function setShowFoldWidgets(show) {
                                this.setOption("showFoldWidgets", show);
                            }
                        },
                        {
                            /**
     * Returns `true` if the fold widgets are shown.
     * @return {Boolean}
     **/ key: "getShowFoldWidgets",
                            value: function getShowFoldWidgets() {
                                return this.getOption("showFoldWidgets");
                            }
                        },
                        {
                            key: "setFadeFoldWidgets",
                            value: function setFadeFoldWidgets(fade) {
                                this.setOption("fadeFoldWidgets", fade);
                            }
                        },
                        {
                            key: "getFadeFoldWidgets",
                            value: function getFadeFoldWidgets() {
                                return this.getOption("fadeFoldWidgets");
                            }
                        },
                        {
                            /**
     * Removes the current selection or one character.
     * @param {String} dir The direction of the deletion to occur, either "left" or "right"
     *
     **/ key: "remove",
                            value: function remove(dir) {
                                if (this.selection.isEmpty()) {
                                    if (dir == "left") this.selection.selectLeft();
                                    else this.selection.selectRight();
                                }
                                var range = this.getSelectionRange();
                                if (this.getBehavioursEnabled()) {
                                    var session = this.session;
                                    var state = session.getState(range.start.row);
                                    var new_range = session.getMode().transformAction(state, "deletion", this, session, range);
                                    if (range.end.column === 0) {
                                        var text = session.getTextRange(range);
                                        if (text[text.length - 1] == "\n") {
                                            var line = session.getLine(range.end.row);
                                            if (/^\s+$/.test(line)) {
                                                range.end.column = line.length;
                                            }
                                        }
                                    }
                                    if (new_range) range = new_range;
                                }
                                this.session.remove(range);
                                this.clearSelection();
                            }
                        },
                        {
                            /**
     * Removes the word directly to the right of the current selection.
     **/ key: "removeWordRight",
                            value: function removeWordRight() {
                                if (this.selection.isEmpty()) this.selection.selectWordRight();
                                this.session.remove(this.getSelectionRange());
                                this.clearSelection();
                            }
                        },
                        {
                            /**
     * Removes the word directly to the left of the current selection.
     **/ key: "removeWordLeft",
                            value: function removeWordLeft() {
                                if (this.selection.isEmpty()) this.selection.selectWordLeft();
                                this.session.remove(this.getSelectionRange());
                                this.clearSelection();
                            }
                        },
                        {
                            /**
     * Removes all the words to the left of the current selection, until the start of the line.
     **/ key: "removeToLineStart",
                            value: function removeToLineStart() {
                                if (this.selection.isEmpty()) this.selection.selectLineStart();
                                if (this.selection.isEmpty()) this.selection.selectLeft();
                                this.session.remove(this.getSelectionRange());
                                this.clearSelection();
                            }
                        },
                        {
                            /**
     * Removes all the words to the right of the current selection, until the end of the line.
     **/ key: "removeToLineEnd",
                            value: function removeToLineEnd() {
                                if (this.selection.isEmpty()) this.selection.selectLineEnd();
                                var range = this.getSelectionRange();
                                if (range.start.column == range.end.column && range.start.row == range.end.row) {
                                    range.end.column = 0;
                                    range.end.row++;
                                }
                                this.session.remove(range);
                                this.clearSelection();
                            }
                        },
                        {
                            /**
     * Splits the line at the current selection (by inserting an `'\n'`).
     **/ key: "splitLine",
                            value: function splitLine() {
                                if (!this.selection.isEmpty()) {
                                    this.session.remove(this.getSelectionRange());
                                    this.clearSelection();
                                }
                                var cursor = this.getCursorPosition();
                                this.insert("\n");
                                this.moveCursorToPosition(cursor);
                            }
                        },
                        {
                            /**
     * Set the "ghost" text in provided position. "Ghost" text is a kind of
     * preview text inside the editor which can be used to preview some code
     * inline in the editor such as, for example, code completions.
     * 
     * @param {String} text Text to be inserted as "ghost" text
     * @param {object} position Position to insert text to
     */ key: "setGhostText",
                            value: function setGhostText(text, position) {
                                if (!this.session.widgetManager) {
                                    this.session.widgetManager = new LineWidgets(this.session);
                                    this.session.widgetManager.attach(this);
                                }
                                this.renderer.setGhostText(text, position);
                            }
                        },
                        {
                            /**
     * Removes "ghost" text currently displayed in the editor.
     */ key: "removeGhostText",
                            value: function removeGhostText() {
                                if (!this.session.widgetManager) return;
                                this.renderer.removeGhostText();
                            }
                        },
                        {
                            /**
     * Transposes current line.
     **/ key: "transposeLetters",
                            value: function transposeLetters() {
                                if (!this.selection.isEmpty()) {
                                    return;
                                }
                                var cursor = this.getCursorPosition();
                                var column = cursor.column;
                                if (column === 0) return;
                                var line = this.session.getLine(cursor.row);
                                var swap, range;
                                if (column < line.length) {
                                    swap = line.charAt(column) + line.charAt(column - 1);
                                    range = new Range(cursor.row, column - 1, cursor.row, column + 1);
                                } else {
                                    swap = line.charAt(column - 1) + line.charAt(column - 2);
                                    range = new Range(cursor.row, column - 2, cursor.row, column);
                                }
                                this.session.replace(range, swap);
                                this.session.selection.moveToPosition(range.end);
                            }
                        },
                        {
                            /**
     * Converts the current selection entirely into lowercase.
     **/ key: "toLowerCase",
                            value: function toLowerCase() {
                                var originalRange = this.getSelectionRange();
                                if (this.selection.isEmpty()) {
                                    this.selection.selectWord();
                                }
                                var range = this.getSelectionRange();
                                var text = this.session.getTextRange(range);
                                this.session.replace(range, text.toLowerCase());
                                this.selection.setSelectionRange(originalRange);
                            }
                        },
                        {
                            /**
     * Converts the current selection entirely into uppercase.
     **/ key: "toUpperCase",
                            value: function toUpperCase() {
                                var originalRange = this.getSelectionRange();
                                if (this.selection.isEmpty()) {
                                    this.selection.selectWord();
                                }
                                var range = this.getSelectionRange();
                                var text = this.session.getTextRange(range);
                                this.session.replace(range, text.toUpperCase());
                                this.selection.setSelectionRange(originalRange);
                            }
                        },
                        {
                            /**
     * Inserts an indentation into the current cursor position or indents the selected lines.
     *
     * @related EditSession.indentRows
     **/ key: "indent",
                            value: function indent() {
                                var session = this.session;
                                var range = this.getSelectionRange();
                                if (range.start.row < range.end.row) {
                                    var rows = this.$getSelectedRows();
                                    session.indentRows(rows.first, rows.last, "	");
                                    return;
                                } else if (range.start.column < range.end.column) {
                                    var text = session.getTextRange(range);
                                    if (!/^\s+$/.test(text)) {
                                        var rows = this.$getSelectedRows();
                                        session.indentRows(rows.first, rows.last, "	");
                                        return;
                                    }
                                }
                                var line = session.getLine(range.start.row);
                                var position = range.start;
                                var size = session.getTabSize();
                                var column = session.documentToScreenColumn(position.row, position.column);
                                if (this.session.getUseSoftTabs()) {
                                    var count = size - column % size;
                                    var indentString = lang.stringRepeat(" ", count);
                                } else {
                                    var count = column % size;
                                    while(line[range.start.column - 1] == " " && count){
                                        range.start.column--;
                                        count--;
                                    }
                                    this.selection.setSelectionRange(range);
                                    indentString = "	";
                                }
                                return this.insert(indentString);
                            }
                        },
                        {
                            /**
     * Indents the current line.
     * @related EditSession.indentRows
     **/ key: "blockIndent",
                            value: function blockIndent() {
                                var rows = this.$getSelectedRows();
                                this.session.indentRows(rows.first, rows.last, "	");
                            }
                        },
                        {
                            /**
     * Outdents the current line.
     * @related EditSession.outdentRows
     **/ key: "blockOutdent",
                            value: function blockOutdent() {
                                var selection = this.session.getSelection();
                                this.session.outdentRows(selection.getRange());
                            }
                        },
                        {
                            // TODO: move out of core when we have good mechanism for managing extensions
                            key: "sortLines",
                            value: function sortLines() {
                                var rows = this.$getSelectedRows();
                                var session = this.session;
                                var lines = [];
                                for(var i = rows.first; i <= rows.last; i++)lines.push(session.getLine(i));
                                lines.sort(function(a, b) {
                                    if (a.toLowerCase() < b.toLowerCase()) return -1;
                                    if (a.toLowerCase() > b.toLowerCase()) return 1;
                                    return 0;
                                });
                                var deleteRange = new Range(0, 0, 0, 0);
                                for(var i = rows.first; i <= rows.last; i++){
                                    var line = session.getLine(i);
                                    deleteRange.start.row = i;
                                    deleteRange.end.row = i;
                                    deleteRange.end.column = line.length;
                                    session.replace(deleteRange, lines[i - rows.first]);
                                }
                            }
                        },
                        {
                            /**
     * Given the currently selected range, this function either comments all the lines, or uncomments all of them.
     **/ key: "toggleCommentLines",
                            value: function toggleCommentLines() {
                                var state = this.session.getState(this.getCursorPosition().row);
                                var rows = this.$getSelectedRows();
                                this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
                            }
                        },
                        {
                            key: "toggleBlockComment",
                            value: function toggleBlockComment() {
                                var cursor = this.getCursorPosition();
                                var state = this.session.getState(cursor.row);
                                var range = this.getSelectionRange();
                                this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
                            }
                        },
                        {
                            /**
     * Works like [[EditSession.getTokenAt]], except it returns a number.
     * @returns {Number}
     **/ key: "getNumberAt",
                            value: function getNumberAt(row, column) {
                                var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
                                _numberRx.lastIndex = 0;
                                var s = this.session.getLine(row);
                                while(_numberRx.lastIndex < column){
                                    var m = _numberRx.exec(s);
                                    if (m.index <= column && m.index + m[0].length >= column) {
                                        var number = {
                                            value: m[0],
                                            start: m.index,
                                            end: m.index + m[0].length
                                        };
                                        return number;
                                    }
                                }
                                return null;
                            }
                        },
                        {
                            /**
     * If the character before the cursor is a number, this functions changes its value by `amount`.
     * @param {Number} amount The value to change the numeral by (can be negative to decrease value)
     *
     **/ key: "modifyNumber",
                            value: function modifyNumber(amount) {
                                var row = this.selection.getCursor().row;
                                var column = this.selection.getCursor().column;
                                // get the char before the cursor
                                var charRange = new Range(row, column - 1, row, column);
                                var c = this.session.getTextRange(charRange);
                                // if the char is a digit
                                if (!isNaN(parseFloat(c)) && isFinite(c)) {
                                    // get the whole number the digit is part of
                                    var nr = this.getNumberAt(row, column);
                                    // if number found
                                    if (nr) {
                                        var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
                                        var decimals = nr.start + nr.value.length - fp;
                                        var t = parseFloat(nr.value);
                                        t *= Math.pow(10, decimals);
                                        if (fp !== nr.end && column < fp) {
                                            amount *= Math.pow(10, nr.end - column - 1);
                                        } else {
                                            amount *= Math.pow(10, nr.end - column);
                                        }
                                        t += amount;
                                        t /= Math.pow(10, decimals);
                                        var nnr = t.toFixed(decimals);
                                        //update number
                                        var replaceRange = new Range(row, nr.start, row, nr.end);
                                        this.session.replace(replaceRange, nnr);
                                        //reposition the cursor
                                        this.moveCursorTo(row, Math.max(nr.start + 1, column + nnr.length - nr.value.length));
                                    }
                                } else {
                                    this.toggleWord();
                                }
                            }
                        },
                        {
                            key: "toggleWord",
                            value: function toggleWord() {
                                var row = this.selection.getCursor().row;
                                var column = this.selection.getCursor().column;
                                this.selection.selectWord();
                                var currentState = this.getSelectedText();
                                var currWordStart = this.selection.getWordRange().start.column;
                                var wordParts = currentState.replace(/([a-z]+|[A-Z]+)(?=[A-Z_]|$)/g, "$1 ").split(/\s/);
                                var delta = column - currWordStart - 1;
                                if (delta < 0) delta = 0;
                                var curLength = 0, itLength = 0;
                                var that = this;
                                if (currentState.match(/[A-Za-z0-9_]+/)) {
                                    wordParts.forEach(function(item, i) {
                                        itLength = curLength + item.length;
                                        if (delta >= curLength && delta <= itLength) {
                                            currentState = item;
                                            that.selection.clearSelection();
                                            that.moveCursorTo(row, curLength + currWordStart);
                                            that.selection.selectTo(row, itLength + currWordStart);
                                        }
                                        curLength = itLength;
                                    });
                                }
                                var wordPairs = this.$toggleWordPairs;
                                var reg;
                                for(var i = 0; i < wordPairs.length; i++){
                                    var item = wordPairs[i];
                                    for(var j = 0; j <= 1; j++){
                                        var negate = +!j;
                                        var firstCondition = currentState.match(new RegExp("^\\s?_?(" + lang.escapeRegExp(item[j]) + ")\\s?$", "i"));
                                        if (firstCondition) {
                                            var secondCondition = currentState.match(new RegExp("([_]|^|\\s)(" + lang.escapeRegExp(firstCondition[1]) + ")($|\\s)", "g"));
                                            if (secondCondition) {
                                                reg = currentState.replace(new RegExp(lang.escapeRegExp(item[j]), "i"), function(result) {
                                                    var res = item[negate];
                                                    if (result.toUpperCase() == result) {
                                                        res = res.toUpperCase();
                                                    } else if (result.charAt(0).toUpperCase() == result.charAt(0)) {
                                                        res = res.substr(0, 0) + item[negate].charAt(0).toUpperCase() + res.substr(1);
                                                    }
                                                    return res;
                                                });
                                                this.insert(reg);
                                                reg = "";
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        {
                            /**
     * Finds link at defined {row} and {column}
     * @returns {String}
     **/ key: "findLinkAt",
                            value: function findLinkAt(row, column) {
                                var line = this.session.getLine(row);
                                var wordParts = line.split(/((?:https?|ftp):\/\/[\S]+)/);
                                var columnPosition = column;
                                if (columnPosition < 0) columnPosition = 0;
                                var previousPosition = 0, currentPosition = 0, match;
                                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                try {
                                    for(var _iterator = wordParts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                        var item = _step.value;
                                        currentPosition = previousPosition + item.length;
                                        if (columnPosition >= previousPosition && columnPosition <= currentPosition) {
                                            if (item.match(/((?:https?|ftp):\/\/[\S]+)/)) {
                                                match = item.replace(/[\s:.,'";}\]]+$/, "");
                                                break;
                                            }
                                        }
                                        previousPosition = currentPosition;
                                    }
                                } catch (err) {
                                    _didIteratorError = true;
                                    _iteratorError = err;
                                } finally{
                                    try {
                                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                                            _iterator.return();
                                        }
                                    } finally{
                                        if (_didIteratorError) {
                                            throw _iteratorError;
                                        }
                                    }
                                }
                                return match;
                            }
                        },
                        {
                            /**
     * Open valid url under cursor in another tab
     * @returns {Boolean}
     **/ key: "openLink",
                            value: function openLink() {
                                var cursor = this.selection.getCursor();
                                var url = this.findLinkAt(cursor.row, cursor.column);
                                if (url) window.open(url, "_blank");
                                return url != null;
                            }
                        },
                        {
                            /**
     * Removes all the lines in the current selection
     * @related EditSession.remove
     **/ key: "removeLines",
                            value: function removeLines() {
                                var rows = this.$getSelectedRows();
                                this.session.removeFullLines(rows.first, rows.last);
                                this.clearSelection();
                            }
                        },
                        {
                            key: "duplicateSelection",
                            value: function duplicateSelection() {
                                var sel = this.selection;
                                var doc = this.session;
                                var range = sel.getRange();
                                var reverse = sel.isBackwards();
                                if (range.isEmpty()) {
                                    var row = range.start.row;
                                    doc.duplicateLines(row, row);
                                } else {
                                    var point = reverse ? range.start : range.end;
                                    var endPoint = doc.insert(point, doc.getTextRange(range), false);
                                    range.start = point;
                                    range.end = endPoint;
                                    sel.setSelectionRange(range, reverse);
                                }
                            }
                        },
                        {
                            /**
     * Shifts all the selected lines down one row.
     *
     * @returns {Number} On success, it returns -1.
     * @related EditSession.moveLinesUp
     **/ key: "moveLinesDown",
                            value: function moveLinesDown() {
                                this.$moveLines(1, false);
                            }
                        },
                        {
                            /**
     * Shifts all the selected lines up one row.
     * @returns {Number} On success, it returns -1.
     * @related EditSession.moveLinesDown
     **/ key: "moveLinesUp",
                            value: function moveLinesUp() {
                                this.$moveLines(-1, false);
                            }
                        },
                        {
                            /**
     * Moves a range of text from the given range to the given position. `toPosition` is an object that looks like this:
     * ```json
     *    { row: newRowLocation, column: newColumnLocation }
     * ```
     * @param {Range} range The range of text you want moved within the document
     * @param {Object} toPosition The location (row and column) where you want to move the text to
     *
     * @returns {Range} The new range where the text was moved to.
     * @related EditSession.moveText
     **/ key: "moveText",
                            value: function moveText(range, toPosition, copy) {
                                return this.session.moveText(range, toPosition, copy);
                            }
                        },
                        {
                            /**
     * Copies all the selected lines up one row.
     * @returns {Number} On success, returns 0.
     *
     **/ key: "copyLinesUp",
                            value: function copyLinesUp() {
                                this.$moveLines(-1, true);
                            }
                        },
                        {
                            /**
     * Copies all the selected lines down one row.
     * @returns {Number} On success, returns the number of new rows added; in other words, `lastRow - firstRow + 1`.
     * @related EditSession.duplicateLines
     *
     **/ key: "copyLinesDown",
                            value: function copyLinesDown() {
                                this.$moveLines(1, true);
                            }
                        },
                        {
                            /**
     * for internal use
     * @ignore
     *
     **/ key: "$moveLines",
                            value: function $moveLines(dir, copy) {
                                var rows, moved;
                                var selection = this.selection;
                                if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
                                    var range = selection.toOrientedRange();
                                    rows = this.$getSelectedRows(range);
                                    moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
                                    if (copy && dir == -1) moved = 0;
                                    range.moveBy(moved, 0);
                                    selection.fromOrientedRange(range);
                                } else {
                                    var ranges = selection.rangeList.ranges;
                                    selection.rangeList.detach(this.session);
                                    this.inVirtualSelectionMode = true;
                                    var diff = 0;
                                    var totalDiff = 0;
                                    var l = ranges.length;
                                    for(var i = 0; i < l; i++){
                                        var rangeIndex = i;
                                        ranges[i].moveBy(diff, 0);
                                        rows = this.$getSelectedRows(ranges[i]);
                                        var first = rows.first;
                                        var last = rows.last;
                                        while(++i < l){
                                            if (totalDiff) ranges[i].moveBy(totalDiff, 0);
                                            var subRows = this.$getSelectedRows(ranges[i]);
                                            if (copy && subRows.first != last) break;
                                            else if (!copy && subRows.first > last + 1) break;
                                            last = subRows.last;
                                        }
                                        i--;
                                        diff = this.session.$moveLines(first, last, copy ? 0 : dir);
                                        if (copy && dir == -1) rangeIndex = i + 1;
                                        while(rangeIndex <= i){
                                            ranges[rangeIndex].moveBy(diff, 0);
                                            rangeIndex++;
                                        }
                                        if (!copy) diff = 0;
                                        totalDiff += diff;
                                    }
                                    selection.fromOrientedRange(selection.ranges[0]);
                                    selection.rangeList.attach(this.session);
                                    this.inVirtualSelectionMode = false;
                                }
                            }
                        },
                        {
                            /**
     * Returns an object indicating the currently selected rows. The object looks like this:
     *
     * ```json
     * { first: range.start.row, last: range.end.row }
     * ```
     *
     * @returns {Object}
     **/ key: "$getSelectedRows",
                            value: function $getSelectedRows(range) {
                                range = (range || this.getSelectionRange()).collapseRows();
                                return {
                                    first: this.session.getRowFoldStart(range.start.row),
                                    last: this.session.getRowFoldEnd(range.end.row)
                                };
                            }
                        },
                        {
                            key: "onCompositionStart",
                            value: function onCompositionStart(compositionState) {
                                this.renderer.showComposition(compositionState);
                            }
                        },
                        {
                            key: "onCompositionUpdate",
                            value: function onCompositionUpdate(text) {
                                this.renderer.setCompositionText(text);
                            }
                        },
                        {
                            key: "onCompositionEnd",
                            value: function onCompositionEnd() {
                                this.renderer.hideComposition();
                            }
                        },
                        {
                            /**
     * {:VirtualRenderer.getFirstVisibleRow}
     *
     * @returns {Number}
     * @related VirtualRenderer.getFirstVisibleRow
     **/ key: "getFirstVisibleRow",
                            value: function getFirstVisibleRow() {
                                return this.renderer.getFirstVisibleRow();
                            }
                        },
                        {
                            /**
     * {:VirtualRenderer.getLastVisibleRow}
     *
     * @returns {Number}
     * @related VirtualRenderer.getLastVisibleRow
     **/ key: "getLastVisibleRow",
                            value: function getLastVisibleRow() {
                                return this.renderer.getLastVisibleRow();
                            }
                        },
                        {
                            /**
     * Indicates if the row is currently visible on the screen.
     * @param {Number} row The row to check
     *
     * @returns {Boolean}
     **/ key: "isRowVisible",
                            value: function isRowVisible(row) {
                                return row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow();
                            }
                        },
                        {
                            /**
     * Indicates if the entire row is currently visible on the screen.
     * @param {Number} row The row to check
     *
     *
     * @returns {Boolean}
     **/ key: "isRowFullyVisible",
                            value: function isRowFullyVisible(row) {
                                return row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow();
                            }
                        },
                        {
                            /**
     * Returns the number of currently visible rows.
     * @returns {Number}
     **/ key: "$getVisibleRowCount",
                            value: function $getVisibleRowCount() {
                                return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
                            }
                        },
                        {
                            key: "$moveByPage",
                            value: function $moveByPage(dir, select) {
                                var renderer = this.renderer;
                                var config = this.renderer.layerConfig;
                                var rows = dir * Math.floor(config.height / config.lineHeight);
                                if (select === true) {
                                    this.selection.$moveSelection(function() {
                                        this.moveCursorBy(rows, 0);
                                    });
                                } else if (select === false) {
                                    this.selection.moveCursorBy(rows, 0);
                                    this.selection.clearSelection();
                                }
                                var scrollTop = renderer.scrollTop;
                                renderer.scrollBy(0, rows * config.lineHeight);
                                if (select != null) renderer.scrollCursorIntoView(null, 0.5);
                                renderer.animateScrolling(scrollTop);
                            }
                        },
                        {
                            /**
     * Selects the text from the current position of the document until where a "page down" finishes.
     **/ key: "selectPageDown",
                            value: function selectPageDown() {
                                this.$moveByPage(1, true);
                            }
                        },
                        {
                            /**
     * Selects the text from the current position of the document until where a "page up" finishes.
     **/ key: "selectPageUp",
                            value: function selectPageUp() {
                                this.$moveByPage(-1, true);
                            }
                        },
                        {
                            /**
     * Shifts the document to wherever "page down" is, as well as moving the cursor position.
     **/ key: "gotoPageDown",
                            value: function gotoPageDown() {
                                this.$moveByPage(1, false);
                            }
                        },
                        {
                            /**
     * Shifts the document to wherever "page up" is, as well as moving the cursor position.
     **/ key: "gotoPageUp",
                            value: function gotoPageUp() {
                                this.$moveByPage(-1, false);
                            }
                        },
                        {
                            /**
     * Scrolls the document to wherever "page down" is, without changing the cursor position.
     **/ key: "scrollPageDown",
                            value: function scrollPageDown() {
                                this.$moveByPage(1);
                            }
                        },
                        {
                            /**
     * Scrolls the document to wherever "page up" is, without changing the cursor position.
     **/ key: "scrollPageUp",
                            value: function scrollPageUp() {
                                this.$moveByPage(-1);
                            }
                        },
                        {
                            /**
     * Moves the editor to the specified row.
     * @related VirtualRenderer.scrollToRow
     **/ key: "scrollToRow",
                            value: function scrollToRow(row) {
                                this.renderer.scrollToRow(row);
                            }
                        },
                        {
                            /**
     * Scrolls to a line. If `center` is `true`, it puts the line in middle of screen (or attempts to).
     * @param {Number} line The line to scroll to
     * @param {Boolean} center If `true`
     * @param {Boolean} animate If `true` animates scrolling
     * @param {Function} callback Function to be called when the animation has finished
     *
     *
     * @related VirtualRenderer.scrollToLine
     **/ key: "scrollToLine",
                            value: function scrollToLine(line, center, animate, callback) {
                                this.renderer.scrollToLine(line, center, animate, callback);
                            }
                        },
                        {
                            /**
     * Attempts to center the current selection on the screen.
     **/ key: "centerSelection",
                            value: function centerSelection() {
                                var range = this.getSelectionRange();
                                var pos = {
                                    row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
                                    column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
                                };
                                this.renderer.alignCursor(pos, 0.5);
                            }
                        },
                        {
                            /**
     * Gets the current position of the cursor.
     * @returns {Object} An object that looks something like this:
     *
     * ```json
     * { row: currRow, column: currCol }
     * ```
     *
     * @related Selection.getCursor
     **/ key: "getCursorPosition",
                            value: function getCursorPosition() {
                                return this.selection.getCursor();
                            }
                        },
                        {
                            /**
     * Returns the screen position of the cursor.
     * @returns {Position}
     * @related EditSession.documentToScreenPosition
     **/ key: "getCursorPositionScreen",
                            value: function getCursorPositionScreen() {
                                return this.session.documentToScreenPosition(this.getCursorPosition());
                            }
                        },
                        {
                            /**
     * {:Selection.getRange}
     * @returns {Range}
     * @related Selection.getRange
     **/ key: "getSelectionRange",
                            value: function getSelectionRange() {
                                return this.selection.getRange();
                            }
                        },
                        {
                            /**
     * Selects all the text in editor.
     * @related Selection.selectAll
     **/ key: "selectAll",
                            value: function selectAll() {
                                this.selection.selectAll();
                            }
                        },
                        {
                            /**
     * {:Selection.clearSelection}
     * @related Selection.clearSelection
     **/ key: "clearSelection",
                            value: function clearSelection() {
                                this.selection.clearSelection();
                            }
                        },
                        {
                            /**
     * Moves the cursor to the specified row and column. Note that this does not de-select the current selection.
     * @param {Number} row The new row number
     * @param {Number} column The new column number
     * @related Selection.moveCursorTo
     **/ key: "moveCursorTo",
                            value: function moveCursorTo(row, column) {
                                this.selection.moveCursorTo(row, column);
                            }
                        },
                        {
                            /**
     * Moves the cursor to the position indicated by `pos.row` and `pos.column`.
     * @param {Position} pos An object with two properties, row and column
     * @related Selection.moveCursorToPosition
     **/ key: "moveCursorToPosition",
                            value: function moveCursorToPosition(pos) {
                                this.selection.moveCursorToPosition(pos);
                            }
                        },
                        {
                            /**
     * Moves the cursor's row and column to the next matching bracket or HTML tag.
     *
     **/ key: "jumpToMatching",
                            value: function jumpToMatching(select, expand) {
                                var cursor = this.getCursorPosition();
                                var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
                                var prevToken = iterator.getCurrentToken();
                                var tokenCount = 0;
                                if (prevToken && prevToken.type.indexOf("tag-name") !== -1) {
                                    prevToken = iterator.stepBackward();
                                }
                                var token = prevToken || iterator.stepForward();
                                if (!token) return;
                                //get next closing tag or bracket
                                var matchType;
                                var found = false;
                                var depth = {};
                                var i = cursor.column - token.start;
                                var bracketType;
                                var brackets = {
                                    ")": "(",
                                    "(": "(",
                                    "]": "[",
                                    "[": "[",
                                    "{": "{",
                                    "}": "{"
                                };
                                do {
                                    if (token.value.match(/[{}()\[\]]/g)) {
                                        for(; i < token.value.length && !found; i++){
                                            if (!brackets[token.value[i]]) {
                                                continue;
                                            }
                                            bracketType = brackets[token.value[i]] + "." + token.type.replace("rparen", "lparen");
                                            if (isNaN(depth[bracketType])) {
                                                depth[bracketType] = 0;
                                            }
                                            switch(token.value[i]){
                                                case "(":
                                                case "[":
                                                case "{":
                                                    depth[bracketType]++;
                                                    break;
                                                case ")":
                                                case "]":
                                                case "}":
                                                    depth[bracketType]--;
                                                    if (depth[bracketType] === -1) {
                                                        matchType = "bracket";
                                                        found = true;
                                                    }
                                                    break;
                                            }
                                        }
                                    } else if (token.type.indexOf("tag-name") !== -1) {
                                        if (isNaN(depth[token.value])) {
                                            depth[token.value] = 0;
                                        }
                                        if (prevToken.value === "<" && tokenCount > 1) {
                                            depth[token.value]++;
                                        } else if (prevToken.value === "</") {
                                            depth[token.value]--;
                                        }
                                        if (depth[token.value] === -1) {
                                            matchType = "tag";
                                            found = true;
                                        }
                                    }
                                    if (!found) {
                                        prevToken = token;
                                        tokenCount++;
                                        token = iterator.stepForward();
                                        i = 0;
                                    }
                                }while (token && !found);
                                //no match found
                                if (!matchType) return;
                                var range, pos;
                                if (matchType === "bracket") {
                                    range = this.session.getBracketRange(cursor);
                                    if (!range) {
                                        range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1);
                                        pos = range.start;
                                        if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2) range = this.session.getBracketRange(pos);
                                    }
                                } else if (matchType === "tag") {
                                    if (!token || token.type.indexOf("tag-name") === -1) return;
                                    range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2);
                                    //find matching tag
                                    if (range.compare(cursor.row, cursor.column) === 0) {
                                        var tagsRanges = this.session.getMatchingTags(cursor);
                                        if (tagsRanges) {
                                            if (tagsRanges.openTag.contains(cursor.row, cursor.column)) {
                                                range = tagsRanges.closeTag;
                                                pos = range.start;
                                            } else {
                                                range = tagsRanges.openTag;
                                                if (tagsRanges.closeTag.start.row === cursor.row && tagsRanges.closeTag.start.column === cursor.column) pos = range.end;
                                                else pos = range.start;
                                            }
                                        }
                                    }
                                    //we found it
                                    pos = pos || range.start;
                                }
                                pos = range && range.cursor || pos;
                                if (pos) {
                                    if (select) {
                                        if (range && expand) {
                                            this.selection.setRange(range);
                                        } else if (range && range.isEqual(this.getSelectionRange())) {
                                            this.clearSelection();
                                        } else {
                                            this.selection.selectTo(pos.row, pos.column);
                                        }
                                    } else {
                                        this.selection.moveTo(pos.row, pos.column);
                                    }
                                }
                            }
                        },
                        {
                            /**
     * Moves the cursor to the specified line number, and also into the indicated column.
     * @param {Number} lineNumber The line number to go to
     * @param {Number} column A column number to go to
     * @param {Boolean} animate If `true` animates scolling
     *
     **/ key: "gotoLine",
                            value: function gotoLine(lineNumber, column, animate) {
                                this.selection.clearSelection();
                                this.session.unfold({
                                    row: lineNumber - 1,
                                    column: column || 0
                                });
                                // todo: find a way to automatically exit multiselect mode
                                this.exitMultiSelectMode && this.exitMultiSelectMode();
                                this.moveCursorTo(lineNumber - 1, column || 0);
                                if (!this.isRowFullyVisible(lineNumber - 1)) this.scrollToLine(lineNumber - 1, true, animate);
                            }
                        },
                        {
                            /**
     * Moves the cursor to the specified row and column. Note that this does de-select the current selection.
     * @param {Number} row The new row number
     * @param {Number} column The new column number
     *
     *
     * @related Editor.moveCursorTo
     **/ key: "navigateTo",
                            value: function navigateTo(row, column) {
                                this.selection.moveTo(row, column);
                            }
                        },
                        {
                            /**
     * Moves the cursor up in the document the specified number of times. Note that this does de-select the current selection.
     * @param {Number} times The number of times to change navigation
     *
     *
     **/ key: "navigateUp",
                            value: function navigateUp(times) {
                                if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
                                    var selectionStart = this.selection.anchor.getPosition();
                                    return this.moveCursorToPosition(selectionStart);
                                }
                                this.selection.clearSelection();
                                this.selection.moveCursorBy(-times || -1, 0);
                            }
                        },
                        {
                            /**
     * Moves the cursor down in the document the specified number of times. Note that this does de-select the current selection.
     * @param {Number} times The number of times to change navigation
     *
     *
     **/ key: "navigateDown",
                            value: function navigateDown(times) {
                                if (this.selection.isMultiLine() && this.selection.isBackwards()) {
                                    var selectionEnd = this.selection.anchor.getPosition();
                                    return this.moveCursorToPosition(selectionEnd);
                                }
                                this.selection.clearSelection();
                                this.selection.moveCursorBy(times || 1, 0);
                            }
                        },
                        {
                            /**
     * Moves the cursor left in the document the specified number of times. Note that this does de-select the current selection.
     * @param {Number} times The number of times to change navigation
     *
     *
     **/ key: "navigateLeft",
                            value: function navigateLeft(times) {
                                if (!this.selection.isEmpty()) {
                                    var selectionStart = this.getSelectionRange().start;
                                    this.moveCursorToPosition(selectionStart);
                                } else {
                                    times = times || 1;
                                    while(times--){
                                        this.selection.moveCursorLeft();
                                    }
                                }
                                this.clearSelection();
                            }
                        },
                        {
                            /**
     * Moves the cursor right in the document the specified number of times. Note that this does de-select the current selection.
     * @param {Number} times The number of times to change navigation
     *
     *
     **/ key: "navigateRight",
                            value: function navigateRight(times) {
                                if (!this.selection.isEmpty()) {
                                    var selectionEnd = this.getSelectionRange().end;
                                    this.moveCursorToPosition(selectionEnd);
                                } else {
                                    times = times || 1;
                                    while(times--){
                                        this.selection.moveCursorRight();
                                    }
                                }
                                this.clearSelection();
                            }
                        },
                        {
                            /**
     *
     * Moves the cursor to the start of the current line. Note that this does de-select the current selection.
     **/ key: "navigateLineStart",
                            value: function navigateLineStart() {
                                this.selection.moveCursorLineStart();
                                this.clearSelection();
                            }
                        },
                        {
                            /**
     *
     * Moves the cursor to the end of the current line. Note that this does de-select the current selection.
     **/ key: "navigateLineEnd",
                            value: function navigateLineEnd() {
                                this.selection.moveCursorLineEnd();
                                this.clearSelection();
                            }
                        },
                        {
                            /**
     *
     * Moves the cursor to the end of the current file. Note that this does de-select the current selection.
     **/ key: "navigateFileEnd",
                            value: function navigateFileEnd() {
                                this.selection.moveCursorFileEnd();
                                this.clearSelection();
                            }
                        },
                        {
                            /**
     *
     * Moves the cursor to the start of the current file. Note that this does de-select the current selection.
     **/ key: "navigateFileStart",
                            value: function navigateFileStart() {
                                this.selection.moveCursorFileStart();
                                this.clearSelection();
                            }
                        },
                        {
                            /**
     *
     * Moves the cursor to the word immediately to the right of the current position. Note that this does de-select the current selection.
     **/ key: "navigateWordRight",
                            value: function navigateWordRight() {
                                this.selection.moveCursorWordRight();
                                this.clearSelection();
                            }
                        },
                        {
                            /**
     *
     * Moves the cursor to the word immediately to the left of the current position. Note that this does de-select the current selection.
     **/ key: "navigateWordLeft",
                            value: function navigateWordLeft() {
                                this.selection.moveCursorWordLeft();
                                this.clearSelection();
                            }
                        },
                        {
                            /**
     * Replaces the first occurrence of `options.needle` with the value in `replacement`.
     * @param {String} replacement The text to replace with
     * @param {Object} options The [[Search `Search`]] options to use
     *
     *
     **/ key: "replace",
                            value: function replace(replacement, options) {
                                if (options) this.$search.set(options);
                                var range = this.$search.find(this.session);
                                var replaced = 0;
                                if (!range) return replaced;
                                if (this.$tryReplace(range, replacement)) {
                                    replaced = 1;
                                }
                                this.selection.setSelectionRange(range);
                                this.renderer.scrollSelectionIntoView(range.start, range.end);
                                return replaced;
                            }
                        },
                        {
                            /**
     * Replaces all occurrences of `options.needle` with the value in `replacement`.
     * @param {String} replacement The text to replace with
     * @param {Object} options The [[Search `Search`]] options to use
     *
     *
     **/ key: "replaceAll",
                            value: function replaceAll(replacement, options) {
                                if (options) {
                                    this.$search.set(options);
                                }
                                var ranges = this.$search.findAll(this.session);
                                var replaced = 0;
                                if (!ranges.length) return replaced;
                                var selection = this.getSelectionRange();
                                this.selection.moveTo(0, 0);
                                for(var i = ranges.length - 1; i >= 0; --i){
                                    if (this.$tryReplace(ranges[i], replacement)) {
                                        replaced++;
                                    }
                                }
                                this.selection.setSelectionRange(selection);
                                return replaced;
                            }
                        },
                        {
                            key: "$tryReplace",
                            value: function $tryReplace(range, replacement) {
                                var input = this.session.getTextRange(range);
                                replacement = this.$search.replace(input, replacement);
                                if (replacement !== null) {
                                    range.end = this.session.replace(range, replacement);
                                    return range;
                                } else {
                                    return null;
                                }
                            }
                        },
                        {
                            /**
     * {:Search.getOptions} For more information on `options`, see [[Search `Search`]].
     * @related Search.getOptions
     * @returns {Object}
     **/ key: "getLastSearchOptions",
                            value: function getLastSearchOptions() {
                                return this.$search.getOptions();
                            }
                        },
                        {
                            /**
     * Attempts to find `needle` within the document. For more information on `options`, see [[Search `Search`]].
     * @param {String|RegExp|Object} needle The text to search for (optional)
     * @param {Object} options An object defining various search properties
     * @param {Boolean} animate If `true` animate scrolling
     * @related Search.find
     **/ key: "find",
                            value: function find(needle, options, animate) {
                                if (!options) options = {};
                                if (typeof needle == "string" || _instanceof(needle, RegExp)) options.needle = needle;
                                else if (typeof needle == "object") oop.mixin(options, needle);
                                var range = this.selection.getRange();
                                if (options.needle == null) {
                                    needle = this.session.getTextRange(range) || this.$search.$options.needle;
                                    if (!needle) {
                                        range = this.session.getWordRange(range.start.row, range.start.column);
                                        needle = this.session.getTextRange(range);
                                    }
                                    this.$search.set({
                                        needle: needle
                                    });
                                }
                                this.$search.set(options);
                                if (!options.start) this.$search.set({
                                    start: range
                                });
                                var newRange = this.$search.find(this.session);
                                if (options.preventScroll) return newRange;
                                if (newRange) {
                                    this.revealRange(newRange, animate);
                                    return newRange;
                                }
                                // clear selection if nothing is found
                                if (options.backwards) range.start = range.end;
                                else range.end = range.start;
                                this.selection.setRange(range);
                            }
                        },
                        {
                            /**
     * Performs another search for `needle` in the document. For more information on `options`, see [[Search `Search`]].
     * @param {Object} options search options
     * @param {Boolean} animate If `true` animate scrolling
     *
     *
     * @related Editor.find
     **/ key: "findNext",
                            value: function findNext(options, animate) {
                                this.find({
                                    skipCurrent: true,
                                    backwards: false
                                }, options, animate);
                            }
                        },
                        {
                            /**
     * Performs a search for `needle` backwards. For more information on `options`, see [[Search `Search`]].
     * @param {Object} options search options
     * @param {Boolean} animate If `true` animate scrolling
     *
     *
     * @related Editor.find
     **/ key: "findPrevious",
                            value: function findPrevious(options, animate) {
                                this.find(options, {
                                    skipCurrent: true,
                                    backwards: true
                                }, animate);
                            }
                        },
                        {
                            key: "revealRange",
                            value: function revealRange(range, animate) {
                                this.session.unfold(range);
                                this.selection.setSelectionRange(range);
                                var scrollTop = this.renderer.scrollTop;
                                this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
                                if (animate !== false) this.renderer.animateScrolling(scrollTop);
                            }
                        },
                        {
                            /**
     * {:UndoManager.undo}
     * @related UndoManager.undo
     **/ key: "undo",
                            value: function undo() {
                                this.session.getUndoManager().undo(this.session);
                                this.renderer.scrollCursorIntoView(null, 0.5);
                            }
                        },
                        {
                            /**
     * {:UndoManager.redo}
     * @related UndoManager.redo
     **/ key: "redo",
                            value: function redo() {
                                this.session.getUndoManager().redo(this.session);
                                this.renderer.scrollCursorIntoView(null, 0.5);
                            }
                        },
                        {
                            /**
     *
     * Cleans up the entire editor.
     **/ key: "destroy",
                            value: function destroy() {
                                if (this.$toDestroy) {
                                    this.$toDestroy.forEach(function(el) {
                                        el.destroy();
                                    });
                                    this.$toDestroy = null;
                                }
                                if (this.$mouseHandler) this.$mouseHandler.destroy();
                                this.renderer.destroy();
                                this._signal("destroy", this);
                                if (this.session) this.session.destroy();
                                if (this._$emitInputEvent) this._$emitInputEvent.cancel();
                                this.removeAllListeners();
                            }
                        },
                        {
                            /**
     * Enables automatic scrolling of the cursor into view when editor itself is inside scrollable element
     * @param {Boolean} enable default true
     **/ key: "setAutoScrollEditorIntoView",
                            value: function setAutoScrollEditorIntoView(enable) {
                                if (!enable) return;
                                var rect;
                                var _$self = this;
                                var shouldScroll = false;
                                if (!this.$scrollAnchor) this.$scrollAnchor = document.createElement("div");
                                var scrollAnchor = this.$scrollAnchor;
                                scrollAnchor.style.cssText = "position:absolute";
                                this.container.insertBefore(scrollAnchor, this.container.firstChild);
                                var onChangeSelection = this.on("changeSelection", function() {
                                    shouldScroll = true;
                                });
                                // needed to not trigger sync reflow
                                var onBeforeRender = this.renderer.on("beforeRender", function() {
                                    if (shouldScroll) rect = _$self.renderer.container.getBoundingClientRect();
                                });
                                var onAfterRender = this.renderer.on("afterRender", function() {
                                    if (shouldScroll && rect && (_$self.isFocused() || _$self.searchBox && _$self.searchBox.isFocused())) {
                                        var renderer = _$self.renderer;
                                        var pos = renderer.$cursorLayer.$pixelPos;
                                        var config = renderer.layerConfig;
                                        var top = pos.top - config.offset;
                                        if (pos.top >= 0 && top + rect.top < 0) {
                                            shouldScroll = true;
                                        } else if (pos.top < config.height && pos.top + rect.top + config.lineHeight > window.innerHeight) {
                                            shouldScroll = false;
                                        } else {
                                            shouldScroll = null;
                                        }
                                        if (shouldScroll != null) {
                                            scrollAnchor.style.top = top + "px";
                                            scrollAnchor.style.left = pos.left + "px";
                                            scrollAnchor.style.height = config.lineHeight + "px";
                                            scrollAnchor.scrollIntoView(shouldScroll);
                                        }
                                        shouldScroll = rect = null;
                                    }
                                });
                                this.setAutoScrollEditorIntoView = function(enable) {
                                    if (enable) return;
                                    delete this.setAutoScrollEditorIntoView;
                                    this.off("changeSelection", onChangeSelection);
                                    this.renderer.off("afterRender", onAfterRender);
                                    this.renderer.off("beforeRender", onBeforeRender);
                                };
                            }
                        },
                        {
                            key: "$resetCursorStyle",
                            value: function $resetCursorStyle() {
                                var style = this.$cursorStyle || "ace";
                                var cursorLayer = this.renderer.$cursorLayer;
                                if (!cursorLayer) return;
                                cursorLayer.setSmoothBlinking(/smooth/.test(style));
                                cursorLayer.isBlinking = !this.$readOnly && style != "wide";
                                dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
                            }
                        },
                        {
                            /**
     * opens a prompt displaying message
     **/ key: "prompt",
                            value: function prompt(message, options, callback) {
                                var editor = this;
                                config.loadModule("ace/ext/prompt", function(module1) {
                                    module1.prompt(editor, message, options, callback);
                                });
                            }
                        }
                    ]);
                    return Editor;
                }();
                Editor.$uid = 0;
                Editor.prototype.curOp = null;
                Editor.prototype.prevOp = {};
                // TODO use property on commands instead of this
                Editor.prototype.$mergeableCommands = [
                    "backspace",
                    "del",
                    "insertstring"
                ];
                Editor.prototype.$toggleWordPairs = [
                    [
                        "first",
                        "last"
                    ],
                    [
                        "true",
                        "false"
                    ],
                    [
                        "yes",
                        "no"
                    ],
                    [
                        "width",
                        "height"
                    ],
                    [
                        "top",
                        "bottom"
                    ],
                    [
                        "right",
                        "left"
                    ],
                    [
                        "on",
                        "off"
                    ],
                    [
                        "x",
                        "y"
                    ],
                    [
                        "get",
                        "set"
                    ],
                    [
                        "max",
                        "min"
                    ],
                    [
                        "horizontal",
                        "vertical"
                    ],
                    [
                        "show",
                        "hide"
                    ],
                    [
                        "add",
                        "remove"
                    ],
                    [
                        "up",
                        "down"
                    ],
                    [
                        "before",
                        "after"
                    ],
                    [
                        "even",
                        "odd"
                    ],
                    [
                        "in",
                        "out"
                    ],
                    [
                        "inside",
                        "outside"
                    ],
                    [
                        "next",
                        "previous"
                    ],
                    [
                        "increase",
                        "decrease"
                    ],
                    [
                        "attach",
                        "detach"
                    ],
                    [
                        "&&",
                        "||"
                    ],
                    [
                        "==",
                        "!="
                    ]
                ];
                oop.implement(Editor.prototype, EventEmitter);
                config.defineOptions(Editor.prototype, "editor", {
                    selectionStyle: {
                        set: function set(style) {
                            this.onSelectionChange();
                            this._signal("changeSelectionStyle", {
                                data: style
                            });
                        },
                        initialValue: "line"
                    },
                    highlightActiveLine: {
                        set: function set() {
                            this.$updateHighlightActiveLine();
                        },
                        initialValue: true
                    },
                    highlightSelectedWord: {
                        set: function set(shouldHighlight) {
                            this.$onSelectionChange();
                        },
                        initialValue: true
                    },
                    readOnly: {
                        set: function set(readOnly) {
                            this.textInput.setReadOnly(readOnly);
                            this.$resetCursorStyle();
                        },
                        initialValue: false
                    },
                    copyWithEmptySelection: {
                        set: function set(value) {
                            this.textInput.setCopyWithEmptySelection(value);
                        },
                        initialValue: false
                    },
                    cursorStyle: {
                        set: function set(val) {
                            this.$resetCursorStyle();
                        },
                        values: [
                            "ace",
                            "slim",
                            "smooth",
                            "wide"
                        ],
                        initialValue: "ace"
                    },
                    mergeUndoDeltas: {
                        values: [
                            false,
                            true,
                            "always"
                        ],
                        initialValue: true
                    },
                    behavioursEnabled: {
                        initialValue: true
                    },
                    wrapBehavioursEnabled: {
                        initialValue: true
                    },
                    enableAutoIndent: {
                        initialValue: true
                    },
                    autoScrollEditorIntoView: {
                        set: function set(val) {
                            this.setAutoScrollEditorIntoView(val);
                        }
                    },
                    keyboardHandler: {
                        set: function set(val) {
                            this.setKeyboardHandler(val);
                        },
                        get: function get() {
                            return this.$keybindingId;
                        },
                        handlesSet: true
                    },
                    value: {
                        set: function set(val) {
                            this.session.setValue(val);
                        },
                        get: function get() {
                            return this.getValue();
                        },
                        handlesSet: true,
                        hidden: true
                    },
                    session: {
                        set: function set(val) {
                            this.setSession(val);
                        },
                        get: function get() {
                            return this.session;
                        },
                        handlesSet: true,
                        hidden: true
                    },
                    showLineNumbers: {
                        set: function set(show) {
                            this.renderer.$gutterLayer.setShowLineNumbers(show);
                            this.renderer.$loop.schedule(this.renderer.CHANGE_GUTTER);
                            if (show && this.$relativeLineNumbers) relativeNumberRenderer.attach(this);
                            else relativeNumberRenderer.detach(this);
                        },
                        initialValue: true
                    },
                    relativeLineNumbers: {
                        set: function set(value) {
                            if (this.$showLineNumbers && value) relativeNumberRenderer.attach(this);
                            else relativeNumberRenderer.detach(this);
                        }
                    },
                    placeholder: {
                        set: function set(message) {
                            if (!this.$updatePlaceholder) {
                                this.$updatePlaceholder = (function() {
                                    var value = this.session && (this.renderer.$composition || this.getValue());
                                    if (value && this.renderer.placeholderNode) {
                                        this.renderer.off("afterRender", this.$updatePlaceholder);
                                        dom.removeCssClass(this.container, "ace_hasPlaceholder");
                                        this.renderer.placeholderNode.remove();
                                        this.renderer.placeholderNode = null;
                                    } else if (!value && !this.renderer.placeholderNode) {
                                        this.renderer.on("afterRender", this.$updatePlaceholder);
                                        dom.addCssClass(this.container, "ace_hasPlaceholder");
                                        var el = dom.createElement("div");
                                        el.className = "ace_placeholder";
                                        el.textContent = this.$placeholder || "";
                                        this.renderer.placeholderNode = el;
                                        this.renderer.content.appendChild(this.renderer.placeholderNode);
                                    } else if (!value && this.renderer.placeholderNode) {
                                        this.renderer.placeholderNode.textContent = this.$placeholder || "";
                                    }
                                }).bind(this);
                                this.on("input", this.$updatePlaceholder);
                            }
                            this.$updatePlaceholder();
                        }
                    },
                    enableKeyboardAccessibility: {
                        set: function set(value) {
                            var blurCommand = {
                                name: "blurTextInput",
                                description: "Set focus to the editor content div to allow tabbing through the page",
                                bindKey: "Esc",
                                exec: function exec(editor) {
                                    editor.blur();
                                    editor.renderer.content.focus();
                                },
                                readOnly: true
                            };
                            var focusOnEnterKeyup = function focusOnEnterKeyup(e) {
                                if (e.target == this.renderer.content && e.keyCode === keys["enter"]) {
                                    e.stopPropagation();
                                    e.preventDefault();
                                    this.focus();
                                }
                            };
                            var keyboardFocusClassName = "ace_keyboard-focus";
                            // Prevent focus to be captured when tabbing through the page. When focus is set to the content div, 
                            // press Enter key to give focus to Ace and press Esc to again allow to tab through the page.
                            if (value) {
                                this.textInput.getElement().setAttribute("tabindex", -1);
                                this.renderer.content.setAttribute("tabindex", 0);
                                this.renderer.content.classList.add(keyboardFocusClassName);
                                this.renderer.content.setAttribute("aria-label", "Editor, press Enter key to start editing, press Escape key to exit");
                                this.renderer.content.addEventListener("keyup", focusOnEnterKeyup.bind(this));
                                this.commands.addCommand(blurCommand);
                            } else {
                                this.textInput.getElement().setAttribute("tabindex", 0);
                                this.renderer.content.setAttribute("tabindex", -1);
                                this.renderer.content.classList.remove(keyboardFocusClassName);
                                this.renderer.content.setAttribute("aria-label", "");
                                this.renderer.content.removeEventListener("keyup", focusOnEnterKeyup.bind(this));
                                this.commands.removeCommand(blurCommand);
                            }
                        },
                        initialValue: false
                    },
                    customScrollbar: "renderer",
                    hScrollBarAlwaysVisible: "renderer",
                    vScrollBarAlwaysVisible: "renderer",
                    highlightGutterLine: "renderer",
                    animatedScroll: "renderer",
                    showInvisibles: "renderer",
                    showPrintMargin: "renderer",
                    printMarginColumn: "renderer",
                    printMargin: "renderer",
                    fadeFoldWidgets: "renderer",
                    showFoldWidgets: "renderer",
                    displayIndentGuides: "renderer",
                    highlightIndentGuides: "renderer",
                    showGutter: "renderer",
                    fontSize: "renderer",
                    fontFamily: "renderer",
                    maxLines: "renderer",
                    minLines: "renderer",
                    scrollPastEnd: "renderer",
                    fixedWidthGutter: "renderer",
                    theme: "renderer",
                    hasCssTransforms: "renderer",
                    maxPixelHeight: "renderer",
                    useTextareaForIME: "renderer",
                    useResizeObserver: "renderer",
                    useSvgGutterIcons: "renderer",
                    scrollSpeed: "$mouseHandler",
                    dragDelay: "$mouseHandler",
                    dragEnabled: "$mouseHandler",
                    focusTimeout: "$mouseHandler",
                    tooltipFollowsMouse: "$mouseHandler",
                    firstLineNumber: "session",
                    overwrite: "session",
                    newLineMode: "session",
                    useWorker: "session",
                    useSoftTabs: "session",
                    navigateWithinSoftTabs: "session",
                    tabSize: "session",
                    wrap: "session",
                    indentedSoftWrap: "session",
                    foldStyle: "session",
                    mode: "session"
                });
                var relativeNumberRenderer = {
                    getText: function getText(session, row) {
                        return (Math.abs(session.selection.lead.row - row) || row + 1 + (row < 9 ? "\xb7" : "")) + "";
                    },
                    getWidth: function getWidth(session, lastLineNumber, config) {
                        return Math.max(lastLineNumber.toString().length, (config.lastRow + 1).toString().length, 2) * config.characterWidth;
                    },
                    update: function update(e, editor) {
                        editor.renderer.$loop.schedule(editor.renderer.CHANGE_GUTTER);
                    },
                    attach: function attach(editor) {
                        editor.renderer.$gutterLayer.$renderer = this;
                        editor.on("changeSelection", this.update);
                        this.update(null, editor);
                    },
                    detach: function detach(editor) {
                        if (editor.renderer.$gutterLayer.$renderer == this) editor.renderer.$gutterLayer.$renderer = null;
                        editor.off("changeSelection", this.update);
                        this.update(null, editor);
                    }
                };
                exports1.M = Editor;
            /***/ },
            /***/ 585: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_563750__) {
                "use strict";
                var binarySearch = function binarySearch(array, needle, comparator) {
                    var first = 0;
                    var last = array.length - 1;
                    while(first <= last){
                        var mid = first + last >> 1;
                        var c = comparator(needle, array[mid]);
                        if (c > 0) first = mid + 1;
                        else if (c < 0) last = mid - 1;
                        else return mid;
                    }
                    // Return the nearest lesser index, "-1" means "0, "-2" means "1", etc.
                    return -(first + 1);
                };
                var findAnnotations = function findAnnotations(session, row, dir) {
                    var annotations = session.getAnnotations().sort(Range.comparePoints);
                    if (!annotations.length) return;
                    var i = binarySearch(annotations, {
                        row: row,
                        column: -1
                    }, Range.comparePoints);
                    if (i < 0) i = -i - 1;
                    if (i >= annotations.length) i = dir > 0 ? 0 : annotations.length - 1;
                    else if (i === 0 && dir < 0) i = annotations.length - 1;
                    var annotation = annotations[i];
                    if (!annotation || !dir) return;
                    if (annotation.row === row) {
                        do {
                            annotation = annotations[i += dir];
                        }while (annotation && annotation.row === row);
                        if (!annotation) return annotations.slice();
                    }
                    var matched = [];
                    row = annotation.row;
                    do {
                        matched[dir < 0 ? "unshift" : "push"](annotation);
                        annotation = annotations[i += dir];
                    }while (annotation && annotation.row == row);
                    return matched.length && matched;
                };
                var LineWidgets = __nested_webpack_require_563750__(1252)/* .LineWidgets */ .H;
                var dom = __nested_webpack_require_563750__(5336);
                var Range = __nested_webpack_require_563750__(3069)/* .Range */ .e;
                exports1.showErrorMarker = function(editor, dir) {
                    var session = editor.session;
                    if (!session.widgetManager) {
                        session.widgetManager = new LineWidgets(session);
                        session.widgetManager.attach(editor);
                    }
                    var pos = editor.getCursorPosition();
                    var row = pos.row;
                    var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function(w) {
                        return w.type == "errorMarker";
                    })[0];
                    if (oldWidget) {
                        oldWidget.destroy();
                    } else {
                        row -= dir;
                    }
                    var annotations = findAnnotations(session, row, dir);
                    var gutterAnno;
                    if (annotations) {
                        var annotation = annotations[0];
                        pos.column = (annotation.pos && typeof annotation.column != "number" ? annotation.pos.sc : annotation.column) || 0;
                        pos.row = annotation.row;
                        gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
                    } else if (oldWidget) {
                        return;
                    } else {
                        gutterAnno = {
                            text: [
                                "Looks good!"
                            ],
                            className: "ace_ok"
                        };
                    }
                    editor.session.unfold(pos.row);
                    editor.selection.moveToPosition(pos);
                    var w = {
                        row: pos.row,
                        fixedWidth: true,
                        coverGutter: true,
                        el: dom.createElement("div"),
                        type: "errorMarker"
                    };
                    var el = w.el.appendChild(dom.createElement("div"));
                    var arrow = w.el.appendChild(dom.createElement("div"));
                    arrow.className = "error_widget_arrow " + gutterAnno.className;
                    var left = editor.renderer.$cursorLayer.getPixelPosition(pos).left;
                    arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";
                    w.el.className = "error_widget_wrapper";
                    el.className = "error_widget " + gutterAnno.className;
                    el.innerHTML = gutterAnno.text.join("<br>");
                    el.appendChild(dom.createElement("div"));
                    var kb = function kb(_, hashId, keyString) {
                        if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
                            w.destroy();
                            return {
                                command: "null"
                            };
                        }
                    };
                    w.destroy = function() {
                        if (editor.$mouseHandler.isMousePressed) return;
                        editor.keyBinding.removeKeyboardHandler(kb);
                        session.widgetManager.removeLineWidget(w);
                        editor.off("changeSelection", w.destroy);
                        editor.off("changeSession", w.destroy);
                        editor.off("mouseup", w.destroy);
                        editor.off("change", w.destroy);
                    };
                    editor.keyBinding.addKeyboardHandler(kb);
                    editor.on("changeSelection", w.destroy);
                    editor.on("changeSession", w.destroy);
                    editor.on("mouseup", w.destroy);
                    editor.on("change", w.destroy);
                    editor.session.widgetManager.addLineWidget(w);
                    w.el.onmousedown = editor.focus.bind(editor);
                    editor.renderer.scrollCursorIntoView(null, 0.5, {
                        bottom: w.el.offsetHeight
                    });
                };
                dom.importCssString("\n    .error_widget_wrapper {\n        background: inherit;\n        color: inherit;\n        border:none\n    }\n    .error_widget {\n        border-top: solid 2px;\n        border-bottom: solid 2px;\n        margin: 5px 0;\n        padding: 10px 40px;\n        white-space: pre-wrap;\n    }\n    .error_widget.ace_error, .error_widget_arrow.ace_error{\n        border-color: #ff5a5a\n    }\n    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\n        border-color: #F1D817\n    }\n    .error_widget.ace_info, .error_widget_arrow.ace_info{\n        border-color: #5a5a5a\n    }\n    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\n        border-color: #5aaa5a\n    }\n    .error_widget_arrow {\n        position: absolute;\n        border: solid 5px;\n        border-top-color: transparent!important;\n        border-right-color: transparent!important;\n        border-left-color: transparent!important;\n        top: -5px;\n    }\n", "error_marker.css", false);
            /***/ },
            /***/ 4739: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_571309__) {
                "use strict";
                var HashHandler = function HashHandler(config, platform) {
                    this.platform = platform || (useragent.isMac ? "mac" : "win");
                    this.commands = {};
                    this.commandKeyBinding = {};
                    this.addCommands(config);
                    this.$singleCommand = true;
                };
                var MultiHashHandler = function MultiHashHandler(config, platform) {
                    HashHandler.call(this, config, platform);
                    this.$singleCommand = false;
                };
                /* provided dependency */ var console = __nested_webpack_require_571309__(3716);
                var keyUtil = __nested_webpack_require_571309__(1492);
                var useragent = __nested_webpack_require_571309__(8057);
                var KEY_MODS = keyUtil.KEY_MODS;
                MultiHashHandler.prototype = HashHandler.prototype;
                (function() {
                    var getPosition = function getPosition(command) {
                        return typeof command == "object" && command.bindKey && command.bindKey.position || (command.isDefault ? -100 : 0);
                    };
                    this.addCommand = function(command) {
                        if (this.commands[command.name]) this.removeCommand(command);
                        this.commands[command.name] = command;
                        if (command.bindKey) this._buildKeyHash(command);
                    };
                    this.removeCommand = function(command, keepCommand) {
                        var name = command && (typeof command === "string" ? command : command.name);
                        command = this.commands[name];
                        if (!keepCommand) delete this.commands[name];
                        // exhaustive search is brute force but since removeCommand is
                        // not a performance critical operation this should be OK
                        var ckb = this.commandKeyBinding;
                        for(var keyId in ckb){
                            var cmdGroup = ckb[keyId];
                            if (cmdGroup == command) {
                                delete ckb[keyId];
                            } else if (Array.isArray(cmdGroup)) {
                                var i = cmdGroup.indexOf(command);
                                if (i != -1) {
                                    cmdGroup.splice(i, 1);
                                    if (cmdGroup.length == 1) ckb[keyId] = cmdGroup[0];
                                }
                            }
                        }
                    };
                    this.bindKey = function(key, command, position) {
                        if (typeof key == "object" && key) {
                            if (position == undefined) position = key.position;
                            key = key[this.platform];
                        }
                        if (!key) return;
                        if (typeof command == "function") return this.addCommand({
                            exec: command,
                            bindKey: key,
                            name: command.name || key
                        });
                        key.split("|").forEach(function(keyPart) {
                            var chain = "";
                            if (keyPart.indexOf(" ") != -1) {
                                var parts = keyPart.split(/\s+/);
                                keyPart = parts.pop();
                                parts.forEach(function(keyPart) {
                                    var binding = this.parseKeys(keyPart);
                                    var id = KEY_MODS[binding.hashId] + binding.key;
                                    chain += (chain ? " " : "") + id;
                                    this._addCommandToBinding(chain, "chainKeys");
                                }, this);
                                chain += " ";
                            }
                            var binding = this.parseKeys(keyPart);
                            var id = KEY_MODS[binding.hashId] + binding.key;
                            this._addCommandToBinding(chain + id, command, position);
                        }, this);
                    };
                    this._addCommandToBinding = function(keyId, command, position) {
                        var ckb = this.commandKeyBinding, i;
                        if (!command) {
                            delete ckb[keyId];
                        } else if (!ckb[keyId] || this.$singleCommand) {
                            ckb[keyId] = command;
                        } else {
                            if (!Array.isArray(ckb[keyId])) {
                                ckb[keyId] = [
                                    ckb[keyId]
                                ];
                            } else if ((i = ckb[keyId].indexOf(command)) != -1) {
                                ckb[keyId].splice(i, 1);
                            }
                            if (typeof position != "number") {
                                position = getPosition(command);
                            }
                            var commands = ckb[keyId];
                            for(i = 0; i < commands.length; i++){
                                var other = commands[i];
                                var otherPos = getPosition(other);
                                if (otherPos > position) break;
                            }
                            commands.splice(i, 0, command);
                        }
                    };
                    this.addCommands = function(commands) {
                        commands && Object.keys(commands).forEach(function(name) {
                            var command = commands[name];
                            if (!command) return;
                            if (typeof command === "string") return this.bindKey(command, name);
                            if (typeof command === "function") command = {
                                exec: command
                            };
                            if (typeof command !== "object") return;
                            if (!command.name) command.name = name;
                            this.addCommand(command);
                        }, this);
                    };
                    this.removeCommands = function(commands) {
                        Object.keys(commands).forEach(function(name) {
                            this.removeCommand(commands[name]);
                        }, this);
                    };
                    this.bindKeys = function(keyList) {
                        Object.keys(keyList).forEach(function(key) {
                            this.bindKey(key, keyList[key]);
                        }, this);
                    };
                    this._buildKeyHash = function(command) {
                        this.bindKey(command.bindKey, command);
                    };
                    // accepts keys in the form ctrl+Enter or ctrl-Enter
                    // keys without modifiers or shift only 
                    this.parseKeys = function(keys) {
                        var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x) {
                            return x;
                        });
                        var key = parts.pop();
                        var keyCode = keyUtil[key];
                        if (keyUtil.FUNCTION_KEYS[keyCode]) key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
                        else if (!parts.length) return {
                            key: key,
                            hashId: -1
                        };
                        else if (parts.length == 1 && parts[0] == "shift") return {
                            key: key.toUpperCase(),
                            hashId: -1
                        };
                        var hashId = 0;
                        for(var i = parts.length; i--;){
                            var modifier = keyUtil.KEY_MODS[parts[i]];
                            if (modifier == null) {
                                if (typeof console != "undefined") console.error("invalid modifier " + parts[i] + " in " + keys);
                                return false;
                            }
                            hashId |= modifier;
                        }
                        return {
                            key: key,
                            hashId: hashId
                        };
                    };
                    this.findKeyCommand = function findKeyCommand(hashId, keyString) {
                        var key = KEY_MODS[hashId] + keyString;
                        return this.commandKeyBinding[key];
                    };
                    this.handleKeyboard = function(data, hashId, keyString, keyCode) {
                        if (keyCode < 0) return;
                        var key = KEY_MODS[hashId] + keyString;
                        var command = this.commandKeyBinding[key];
                        if (data.$keyChain) {
                            data.$keyChain += " " + key;
                            command = this.commandKeyBinding[data.$keyChain] || command;
                        }
                        if (command) {
                            if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
                                data.$keyChain = data.$keyChain || key;
                                return {
                                    command: "null"
                                };
                            }
                        }
                        if (data.$keyChain) {
                            if ((!hashId || hashId == 4) && keyString.length == 1) data.$keyChain = data.$keyChain.slice(0, -key.length - 1); // wait for input
                            else if (hashId == -1 || keyCode > 0) data.$keyChain = ""; // reset keyChain
                        }
                        return {
                            command: command
                        };
                    };
                    this.getStatusText = function(editor, data) {
                        return data.$keyChain || "";
                    };
                }).call(HashHandler.prototype);
                exports1.HashHandler = HashHandler;
                exports1.MultiHashHandler = MultiHashHandler;
            /***/ },
            /***/ 1058: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_581981__) {
                "use strict";
                var keyUtil = __nested_webpack_require_581981__(1492);
                var event = __nested_webpack_require_581981__(8215);
                var KeyBinding = /*#__PURE__*/ function() {
                    function KeyBinding(editor) {
                        _class_call_check(this, KeyBinding);
                        this.$editor = editor;
                        this.$data = {
                            editor: editor
                        };
                        this.$handlers = [];
                        this.setDefaultHandler(editor.commands);
                    }
                    _create_class(KeyBinding, [
                        {
                            key: "setDefaultHandler",
                            value: function setDefaultHandler(kb) {
                                this.removeKeyboardHandler(this.$defaultHandler);
                                this.$defaultHandler = kb;
                                this.addKeyboardHandler(kb, 0);
                            }
                        },
                        {
                            key: "setKeyboardHandler",
                            value: function setKeyboardHandler(kb) {
                                var h = this.$handlers;
                                if (h[h.length - 1] == kb) return;
                                while(h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)this.removeKeyboardHandler(h[h.length - 1]);
                                this.addKeyboardHandler(kb, 1);
                            }
                        },
                        {
                            key: "addKeyboardHandler",
                            value: function addKeyboardHandler(kb, pos) {
                                if (!kb) return;
                                if (typeof kb == "function" && !kb.handleKeyboard) kb.handleKeyboard = kb;
                                var i = this.$handlers.indexOf(kb);
                                if (i != -1) this.$handlers.splice(i, 1);
                                if (pos == undefined) this.$handlers.push(kb);
                                else this.$handlers.splice(pos, 0, kb);
                                if (i == -1 && kb.attach) kb.attach(this.$editor);
                            }
                        },
                        {
                            key: "removeKeyboardHandler",
                            value: function removeKeyboardHandler(kb) {
                                var i = this.$handlers.indexOf(kb);
                                if (i == -1) return false;
                                this.$handlers.splice(i, 1);
                                kb.detach && kb.detach(this.$editor);
                                return true;
                            }
                        },
                        {
                            key: "getKeyboardHandler",
                            value: function getKeyboardHandler() {
                                return this.$handlers[this.$handlers.length - 1];
                            }
                        },
                        {
                            key: "getStatusText",
                            value: function getStatusText() {
                                var data = this.$data;
                                var editor = data.editor;
                                return this.$handlers.map(function(h) {
                                    return h.getStatusText && h.getStatusText(editor, data) || "";
                                }).filter(Boolean).join(" ");
                            }
                        },
                        {
                            key: "$callKeyboardHandlers",
                            value: function $callKeyboardHandlers(hashId, keyString, keyCode, e) {
                                var toExecute;
                                var success = false;
                                var commands = this.$editor.commands;
                                for(var i = this.$handlers.length; i--;){
                                    toExecute = this.$handlers[i].handleKeyboard(this.$data, hashId, keyString, keyCode, e);
                                    if (!toExecute || !toExecute.command) continue;
                                    // allow keyboardHandler to consume keys
                                    if (toExecute.command == "null") {
                                        success = true;
                                    } else {
                                        success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
                                    }
                                    // do not stop input events to not break repeating
                                    if (success && e && hashId != -1 && toExecute.passEvent != true && toExecute.command.passEvent != true) {
                                        event.stopEvent(e);
                                    }
                                    if (success) break;
                                }
                                if (!success && hashId == -1) {
                                    toExecute = {
                                        command: "insertstring"
                                    };
                                    success = commands.exec("insertstring", this.$editor, keyString);
                                }
                                if (success && this.$editor._signal) this.$editor._signal("keyboardActivity", toExecute);
                                return success;
                            }
                        },
                        {
                            key: "onCommandKey",
                            value: function onCommandKey(e, hashId, keyCode) {
                                var keyString = keyUtil.keyCodeToString(keyCode);
                                return this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
                            }
                        },
                        {
                            key: "onTextInput",
                            value: function onTextInput(text) {
                                return this.$callKeyboardHandlers(-1, text);
                            }
                        }
                    ]);
                    return KeyBinding;
                }();
                exports1.M = KeyBinding;
            /***/ },
            /***/ 58: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_588604__) {
                "use strict";
                var __webpack_unused_export__;
                var event = __nested_webpack_require_588604__(8215);
                var useragent = __nested_webpack_require_588604__(8057);
                var dom = __nested_webpack_require_588604__(5336);
                var lang = __nested_webpack_require_588604__(732);
                var clipboard = __nested_webpack_require_588604__(6514);
                var BROKEN_SETDATA = useragent.isChrome < 18;
                var USE_IE_MIME_TYPE = useragent.isIE;
                var HAS_FOCUS_ARGS = useragent.isChrome > 63;
                var MAX_LINE_LENGTH = 400;
                var KEYS = __nested_webpack_require_588604__(1492);
                var MODS = KEYS.KEY_MODS;
                var isIOS = useragent.isIOS;
                var valueResetRegex = isIOS ? /\s/ : /\n/;
                var isMobile = useragent.isMobile;
                var TextInput = function TextInput(parentNode, host) {
                    var cancelComposition = function cancelComposition() {
                        // force end composition
                        ignoreFocusEvents = true;
                        text.blur();
                        text.focus();
                        ignoreFocusEvents = false;
                    };
                    var onKeyup = function onKeyup(e) {
                        // workaround for a bug in ie where pressing esc silently moves selection out of textarea
                        if (e.keyCode == 27 && text.value.length < text.selectionStart) {
                            if (!inComposition) lastValue = text.value;
                            lastSelectionStart = lastSelectionEnd = -1;
                            resetSelection();
                        }
                        syncComposition();
                    };
                    var onContextMenuClose = function onContextMenuClose() {
                        clearTimeout(closeTimeout);
                        closeTimeout = setTimeout(function() {
                            if (tempStyle) {
                                text.style.cssText = tempStyle;
                                tempStyle = "";
                            }
                            host.renderer.$isMousePressed = false;
                            if (host.renderer.$keepTextAreaAtCursor) host.renderer.$moveTextAreaToCursor();
                        }, 0);
                    };
                    var addIosSelectionHandler = function addIosSelectionHandler(parentNode, host, text) {
                        var typingResetTimeout = null;
                        var typing = false;
                        text.addEventListener("keydown", function(e) {
                            if (typingResetTimeout) clearTimeout(typingResetTimeout);
                            typing = true;
                        }, true);
                        text.addEventListener("keyup", function(e) {
                            typingResetTimeout = setTimeout(function() {
                                typing = false;
                            }, 100);
                        }, true);
                        // IOS doesn't fire events for arrow keys, but this unique hack changes everything!
                        var detectArrowKeys = function detectArrowKeys(e) {
                            if (document.activeElement !== text) return;
                            if (typing || inComposition || host.$mouseHandler.isMousePressed) return;
                            if (copied) {
                                return;
                            }
                            var selectionStart = text.selectionStart;
                            var selectionEnd = text.selectionEnd;
                            var key = null;
                            var modifier = 0;
                            // console.log(selectionStart, selectionEnd);
                            if (selectionStart == 0) {
                                key = KEYS.up;
                            } else if (selectionStart == 1) {
                                key = KEYS.home;
                            } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd] == "\n") {
                                key = KEYS.end;
                            } else if (selectionStart < lastSelectionStart && lastValue[selectionStart - 1] == " ") {
                                key = KEYS.left;
                                modifier = MODS.option;
                            } else if (selectionStart < lastSelectionStart || selectionStart == lastSelectionStart && lastSelectionEnd != lastSelectionStart && selectionStart == selectionEnd) {
                                key = KEYS.left;
                            } else if (selectionEnd > lastSelectionEnd && lastValue.slice(0, selectionEnd).split("\n").length > 2) {
                                key = KEYS.down;
                            } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd - 1] == " ") {
                                key = KEYS.right;
                                modifier = MODS.option;
                            } else if (selectionEnd > lastSelectionEnd || selectionEnd == lastSelectionEnd && lastSelectionEnd != lastSelectionStart && selectionStart == selectionEnd) {
                                key = KEYS.right;
                            }
                            if (selectionStart !== selectionEnd) modifier |= MODS.shift;
                            if (key) {
                                var result = host.onCommandKey({}, modifier, key);
                                if (!result && host.commands) {
                                    key = KEYS.keyCodeToString(key);
                                    var command = host.commands.findKeyCommand(modifier, key);
                                    if (command) host.execCommand(command);
                                }
                                lastSelectionStart = selectionStart;
                                lastSelectionEnd = selectionEnd;
                                resetSelection("");
                            }
                        };
                        // On iOS, "selectionchange" can only be attached to the document object...
                        document.addEventListener("selectionchange", detectArrowKeys);
                        host.on("destroy", function() {
                            document.removeEventListener("selectionchange", detectArrowKeys);
                        });
                    };
                    var text = dom.createElement("textarea");
                    text.className = "ace_text-input";
                    text.setAttribute("wrap", "off");
                    text.setAttribute("autocorrect", "off");
                    text.setAttribute("autocapitalize", "off");
                    text.setAttribute("spellcheck", false);
                    text.style.opacity = "0";
                    parentNode.insertBefore(text, parentNode.firstChild);
                    var copied = false;
                    var pasted = false;
                    var inComposition = false;
                    var sendingText = false;
                    var tempStyle = "";
                    if (!isMobile) text.style.fontSize = "1px";
                    var commandMode = false;
                    var ignoreFocusEvents = false;
                    var lastValue = "";
                    var lastSelectionStart = 0;
                    var lastSelectionEnd = 0;
                    var lastRestoreEnd = 0;
                    // FOCUS
                    // ie9 throws error if document.activeElement is accessed too soon
                    try {
                        var isFocused = document.activeElement === text;
                    } catch (e) {}
                    this.setAriaOptions = function(options) {
                        if (options.activeDescendant) {
                            text.setAttribute("aria-haspopup", "true");
                            text.setAttribute("aria-autocomplete", options.inline ? "both" : "list");
                            text.setAttribute("aria-activedescendant", options.activeDescendant);
                        } else {
                            text.setAttribute("aria-haspopup", "false");
                            text.setAttribute("aria-autocomplete", "both");
                            text.removeAttribute("aria-activedescendant");
                        }
                        if (options.role) {
                            text.setAttribute("role", options.role);
                        }
                    };
                    this.setAriaOptions({
                        role: "textbox"
                    });
                    event.addListener(text, "blur", function(e) {
                        if (ignoreFocusEvents) return;
                        host.onBlur(e);
                        isFocused = false;
                        if (isMobile && !isIOS) document.removeEventListener("selectionchange", detectSelectionChange);
                    }, host);
                    event.addListener(text, "focus", function(e) {
                        if (ignoreFocusEvents) return;
                        isFocused = true;
                        if (useragent.isEdge) {
                            // on edge focus event is fired even if document itself is not focused
                            try {
                                if (!document.hasFocus()) return;
                            } catch (e) {}
                        }
                        host.onFocus(e);
                        if (useragent.isEdge) setTimeout(resetSelection);
                        else resetSelection();
                        if (isMobile && !isIOS) document.addEventListener("selectionchange", detectSelectionChange);
                    }, host);
                    this.$focusScroll = false;
                    this.focus = function() {
                        if (tempStyle || HAS_FOCUS_ARGS || this.$focusScroll == "browser") return text.focus({
                            preventScroll: true
                        });
                        var top = text.style.top;
                        text.style.position = "fixed";
                        text.style.top = "0px";
                        try {
                            var isTransformed = text.getBoundingClientRect().top != 0;
                        } catch (e) {
                            // getBoundingClientRect on IE throws error if element is not in the dom tree
                            return;
                        }
                        var ancestors = [];
                        if (isTransformed) {
                            var t = text.parentElement;
                            while(t && t.nodeType == 1){
                                ancestors.push(t);
                                t.setAttribute("ace_nocontext", true);
                                if (!t.parentElement && t.getRootNode) t = t.getRootNode().host;
                                else t = t.parentElement;
                            }
                        }
                        text.focus({
                            preventScroll: true
                        });
                        if (isTransformed) {
                            ancestors.forEach(function(p) {
                                p.removeAttribute("ace_nocontext");
                            });
                        }
                        setTimeout(function() {
                            text.style.position = "";
                            if (text.style.top == "0px") text.style.top = top;
                        }, 0);
                    };
                    this.blur = function() {
                        text.blur();
                    };
                    this.isFocused = function() {
                        return isFocused;
                    };
                    host.on("beforeEndOperation", function() {
                        var curOp = host.curOp;
                        var commandName = curOp && curOp.command && curOp.command.name;
                        if (commandName == "insertstring") return;
                        var isUserAction = commandName && (curOp.docChanged || curOp.selectionChanged);
                        if (inComposition && isUserAction) {
                            // exit composition from commands other than insertstring
                            lastValue = text.value = "";
                            onCompositionEnd();
                        }
                        // sync value of textarea
                        resetSelection();
                    });
                    var resetSelection = isIOS ? function resetSelection(value) {
                        if (!isFocused || copied && !value || sendingText) return;
                        if (!value) value = "";
                        var newValue = "\n ab" + value + "cde fg\n";
                        if (newValue != text.value) text.value = lastValue = newValue;
                        var selectionStart = 4;
                        var selectionEnd = 4 + (value.length || (host.selection.isEmpty() ? 0 : 1));
                        if (lastSelectionStart != selectionStart || lastSelectionEnd != selectionEnd) {
                            text.setSelectionRange(selectionStart, selectionEnd);
                        }
                        lastSelectionStart = selectionStart;
                        lastSelectionEnd = selectionEnd;
                    } : function() {
                        if (inComposition || sendingText) return;
                        // modifying selection of blured textarea can focus it (chrome mac/linux)
                        if (!isFocused && !afterContextMenu) return;
                        // this prevents infinite recursion on safari 8 
                        // see https://github.com/ajaxorg/ace/issues/2114
                        inComposition = true;
                        var selectionStart = 0;
                        var selectionEnd = 0;
                        var line = "";
                        if (host.session) {
                            var selection = host.selection;
                            var range = selection.getRange();
                            var row = selection.cursor.row;
                            selectionStart = range.start.column;
                            selectionEnd = range.end.column;
                            line = host.session.getLine(row);
                            if (range.start.row != row) {
                                var prevLine = host.session.getLine(row - 1);
                                selectionStart = range.start.row < row - 1 ? 0 : selectionStart;
                                selectionEnd += prevLine.length + 1;
                                line = prevLine + "\n" + line;
                            } else if (range.end.row != row) {
                                var nextLine = host.session.getLine(row + 1);
                                selectionEnd = range.end.row > row + 1 ? nextLine.length : selectionEnd;
                                selectionEnd += line.length + 1;
                                line = line + "\n" + nextLine;
                            } else if (isMobile && row > 0) {
                                line = "\n" + line;
                                selectionEnd += 1;
                                selectionStart += 1;
                            }
                            if (line.length > MAX_LINE_LENGTH) {
                                if (selectionStart < MAX_LINE_LENGTH && selectionEnd < MAX_LINE_LENGTH) {
                                    line = line.slice(0, MAX_LINE_LENGTH);
                                } else {
                                    line = "\n";
                                    if (selectionStart == selectionEnd) {
                                        selectionStart = selectionEnd = 0;
                                    } else {
                                        selectionStart = 0;
                                        selectionEnd = 1;
                                    }
                                }
                            }
                        }
                        var newValue = line + "\n\n";
                        if (newValue != lastValue) {
                            text.value = lastValue = newValue;
                            lastSelectionStart = lastSelectionEnd = newValue.length;
                        }
                        // contextmenu on mac may change the selection
                        if (afterContextMenu) {
                            lastSelectionStart = text.selectionStart;
                            lastSelectionEnd = text.selectionEnd;
                        }
                        // on firefox this throws if textarea is hidden
                        if (lastSelectionEnd != selectionEnd || lastSelectionStart != selectionStart || text.selectionEnd != lastSelectionEnd // on ie edge selectionEnd changes silently after the initialization
                        ) {
                            try {
                                text.setSelectionRange(selectionStart, selectionEnd);
                                lastSelectionStart = selectionStart;
                                lastSelectionEnd = selectionEnd;
                            } catch (e) {}
                        }
                        inComposition = false;
                    };
                    this.resetSelection = resetSelection;
                    if (isFocused) host.onFocus();
                    var isAllSelected = function isAllSelected(text) {
                        return text.selectionStart === 0 && text.selectionEnd >= lastValue.length && text.value === lastValue && lastValue && text.selectionEnd !== lastSelectionEnd;
                    };
                    var onSelect = function onSelect(e) {
                        if (inComposition) return;
                        if (copied) {
                            copied = false;
                        } else if (isAllSelected(text)) {
                            host.selectAll();
                            resetSelection();
                        } else if (isMobile && text.selectionStart != lastSelectionStart) {
                            resetSelection();
                        }
                    };
                    function detectSelectionChange(e) {
                        if (!text || !text.parentNode) document.removeEventListener("selectionchange", detectSelectionChange);
                        if (inComposition) return;
                        if (text.selectionStart !== text.selectionEnd) return;
                        var startDiff = text.selectionStart - lastSelectionStart;
                        var oldLenght = lastSelectionEnd - lastSelectionStart;
                        if (startDiff > 0) {
                            startDiff = Math.max(startDiff - oldLenght, 1);
                        } else if (startDiff === 0 && oldLenght) {
                            startDiff = -1;
                        }
                        var repeat = Math.abs(startDiff);
                        var key = startDiff > 0 ? KEYS.right : KEYS.left;
                        for(var i = 0; i < repeat; i++){
                            host.onCommandKey({}, 0, key);
                        }
                    }
                    var inputHandler = null;
                    this.setInputHandler = function(cb) {
                        inputHandler = cb;
                    };
                    this.getInputHandler = function() {
                        return inputHandler;
                    };
                    var afterContextMenu = false;
                    var sendText = function sendText(value, fromInput) {
                        if (afterContextMenu) afterContextMenu = false;
                        if (pasted) {
                            resetSelection();
                            if (value) host.onPaste(value);
                            pasted = false;
                            return "";
                        } else {
                            var selectionStart = text.selectionStart;
                            var selectionEnd = text.selectionEnd;
                            var extendLeft = lastSelectionStart;
                            var extendRight = lastValue.length - lastSelectionEnd;
                            var inserted = value;
                            var restoreStart = value.length - selectionStart;
                            var restoreEnd = value.length - selectionEnd;
                            var i = 0;
                            while(extendLeft > 0 && lastValue[i] == value[i]){
                                i++;
                                extendLeft--;
                            }
                            inserted = inserted.slice(i);
                            i = 1;
                            while(extendRight > 0 && lastValue.length - i > lastSelectionStart - 1 && lastValue[lastValue.length - i] == value[value.length - i]){
                                i++;
                                extendRight--;
                            }
                            restoreStart -= i - 1;
                            restoreEnd -= i - 1;
                            var endIndex = inserted.length - i + 1;
                            if (endIndex < 0) {
                                extendLeft = -endIndex;
                                endIndex = 0;
                            }
                            inserted = inserted.slice(0, endIndex);
                            // composition update can be called without any change
                            if (!fromInput && !inserted && !restoreStart && !extendLeft && !extendRight && !restoreEnd) return "";
                            sendingText = true;
                            // some android keyboards converts two spaces into sentence end, which is not useful for code
                            var shouldReset = false;
                            if (useragent.isAndroid && inserted == ". ") {
                                inserted = "  ";
                                shouldReset = true;
                            }
                            if (inserted && !extendLeft && !extendRight && !restoreStart && !restoreEnd || commandMode) {
                                host.onTextInput(inserted);
                            } else {
                                host.onTextInput(inserted, {
                                    extendLeft: extendLeft,
                                    extendRight: extendRight,
                                    restoreStart: restoreStart,
                                    restoreEnd: restoreEnd
                                });
                            }
                            sendingText = false;
                            lastValue = value;
                            lastSelectionStart = selectionStart;
                            lastSelectionEnd = selectionEnd;
                            lastRestoreEnd = restoreEnd;
                            return shouldReset ? "\n" : inserted;
                        }
                    };
                    var onInput = function onInput(e) {
                        if (inComposition) return onCompositionUpdate();
                        if (e && e.inputType) {
                            if (e.inputType == "historyUndo") return host.execCommand("undo");
                            if (e.inputType == "historyRedo") return host.execCommand("redo");
                        }
                        var data = text.value;
                        var inserted = sendText(data, true);
                        if (data.length > MAX_LINE_LENGTH + 100 || valueResetRegex.test(inserted) || isMobile && lastSelectionStart < 1 && lastSelectionStart == lastSelectionEnd) {
                            resetSelection();
                        }
                    };
                    var handleClipboardData = function handleClipboardData1(e, data, forceIEMime) {
                        var clipboardData = e.clipboardData || window.clipboardData;
                        if (!clipboardData || BROKEN_SETDATA) return;
                        // using "Text" doesn't work on old webkit but ie needs it
                        var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
                        try {
                            if (data) {
                                // Safari 5 has clipboardData object, but does not handle setData()
                                return clipboardData.setData(mime, data) !== false;
                            } else {
                                return clipboardData.getData(mime);
                            }
                        } catch (e) {
                            if (!forceIEMime) return handleClipboardData(e, data, true);
                        }
                    };
                    var doCopy = function doCopy(e, isCut) {
                        var data = host.getCopyText();
                        if (!data) return event.preventDefault(e);
                        if (handleClipboardData(e, data)) {
                            if (isIOS) {
                                resetSelection(data);
                                copied = data;
                                setTimeout(function() {
                                    copied = false;
                                }, 10);
                            }
                            isCut ? host.onCut() : host.onCopy();
                            event.preventDefault(e);
                        } else {
                            copied = true;
                            text.value = data;
                            text.select();
                            setTimeout(function() {
                                copied = false;
                                resetSelection();
                                isCut ? host.onCut() : host.onCopy();
                            });
                        }
                    };
                    var onCut = function onCut(e) {
                        doCopy(e, true);
                    };
                    var onCopy = function onCopy(e) {
                        doCopy(e, false);
                    };
                    var onPaste = function onPaste(e) {
                        var data = handleClipboardData(e);
                        if (clipboard.pasteCancelled()) return;
                        if (typeof data == "string") {
                            if (data) host.onPaste(data, e);
                            if (useragent.isIE) setTimeout(resetSelection);
                            event.preventDefault(e);
                        } else {
                            text.value = "";
                            pasted = true;
                        }
                    };
                    event.addCommandKeyListener(text, host.onCommandKey.bind(host), host);
                    event.addListener(text, "select", onSelect, host);
                    event.addListener(text, "input", onInput, host);
                    event.addListener(text, "cut", onCut, host);
                    event.addListener(text, "copy", onCopy, host);
                    event.addListener(text, "paste", onPaste, host);
                    // Opera has no clipboard events
                    if (!("oncut" in text) || !("oncopy" in text) || !("onpaste" in text)) {
                        event.addListener(parentNode, "keydown", function(e) {
                            if (useragent.isMac && !e.metaKey || !e.ctrlKey) return;
                            switch(e.keyCode){
                                case 67:
                                    onCopy(e);
                                    break;
                                case 86:
                                    onPaste(e);
                                    break;
                                case 88:
                                    onCut(e);
                                    break;
                            }
                        }, host);
                    }
                    // COMPOSITION
                    var onCompositionStart = function onCompositionStart(e) {
                        if (inComposition || !host.onCompositionStart || host.$readOnly) return;
                        inComposition = {};
                        if (commandMode) return;
                        if (e.data) inComposition.useTextareaForIME = false;
                        setTimeout(onCompositionUpdate, 0);
                        host._signal("compositionStart");
                        host.on("mousedown", cancelComposition);
                        var range = host.getSelectionRange();
                        range.end.row = range.start.row;
                        range.end.column = range.start.column;
                        inComposition.markerRange = range;
                        inComposition.selectionStart = lastSelectionStart;
                        host.onCompositionStart(inComposition);
                        if (inComposition.useTextareaForIME) {
                            lastValue = text.value = "";
                            lastSelectionStart = 0;
                            lastSelectionEnd = 0;
                        } else {
                            if (text.msGetInputContext) inComposition.context = text.msGetInputContext();
                            if (text.getInputContext) inComposition.context = text.getInputContext();
                        }
                    };
                    var onCompositionUpdate = function onCompositionUpdate() {
                        if (!inComposition || !host.onCompositionUpdate || host.$readOnly) return;
                        if (commandMode) return cancelComposition();
                        if (inComposition.useTextareaForIME) {
                            host.onCompositionUpdate(text.value);
                        } else {
                            var data = text.value;
                            sendText(data);
                            if (inComposition.markerRange) {
                                if (inComposition.context) {
                                    inComposition.markerRange.start.column = inComposition.selectionStart = inComposition.context.compositionStartOffset;
                                }
                                inComposition.markerRange.end.column = inComposition.markerRange.start.column + lastSelectionEnd - inComposition.selectionStart + lastRestoreEnd;
                            }
                        }
                    };
                    var onCompositionEnd = function onCompositionEnd(e) {
                        if (!host.onCompositionEnd || host.$readOnly) return;
                        inComposition = false;
                        host.onCompositionEnd();
                        host.off("mousedown", cancelComposition);
                        // note that resetting value of textarea at this point doesn't always work
                        // because textarea value can be silently restored
                        if (e) onInput();
                    };
                    var syncComposition = lang.delayedCall(onCompositionUpdate, 50).schedule.bind(null, null);
                    event.addListener(text, "compositionstart", onCompositionStart, host);
                    event.addListener(text, "compositionupdate", onCompositionUpdate, host);
                    event.addListener(text, "keyup", onKeyup, host);
                    event.addListener(text, "keydown", syncComposition, host);
                    event.addListener(text, "compositionend", onCompositionEnd, host);
                    this.getElement = function() {
                        return text;
                    };
                    // allows to ignore composition (used by vim keyboard handler in the normal mode)
                    // this is useful on mac, where with some keyboard layouts (e.g swedish) ^ starts composition
                    this.setCommandMode = function(value) {
                        commandMode = value;
                        text.readOnly = false;
                    };
                    this.setReadOnly = function(readOnly) {
                        if (!commandMode) text.readOnly = readOnly;
                    };
                    this.setCopyWithEmptySelection = function(value) {};
                    this.onContextMenu = function(e) {
                        afterContextMenu = true;
                        resetSelection();
                        host._emit("nativecontextmenu", {
                            target: host,
                            domEvent: e
                        });
                        this.moveToMouse(e, true);
                    };
                    this.moveToMouse = function(e, bringToFront) {
                        if (!tempStyle) tempStyle = text.style.cssText;
                        text.style.cssText = (bringToFront ? "z-index:100000;" : "") + (useragent.isIE ? "opacity:0.1;" : "") + "text-indent: -" + (lastSelectionStart + lastSelectionEnd) * host.renderer.characterWidth * 0.5 + "px;";
                        var rect = host.container.getBoundingClientRect();
                        var style = dom.computedStyle(host.container);
                        var top = rect.top + (parseInt(style.borderTopWidth) || 0);
                        var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
                        var maxTop = rect.bottom - top - text.clientHeight - 2;
                        var move = function move(e) {
                            dom.translate(text, e.clientX - left - 2, Math.min(e.clientY - top - 2, maxTop));
                        };
                        move(e);
                        if (e.type != "mousedown") return;
                        host.renderer.$isMousePressed = true;
                        clearTimeout(closeTimeout);
                        // on windows context menu is opened after mouseup
                        if (useragent.isWin) event.capture(host.container, move, onContextMenuClose);
                    };
                    this.onContextMenuClose = onContextMenuClose;
                    var closeTimeout;
                    var onContextMenu = function onContextMenu(e) {
                        host.textInput.onContextMenu(e);
                        onContextMenuClose();
                    };
                    event.addListener(text, "mouseup", onContextMenu, host);
                    event.addListener(text, "mousedown", function(e) {
                        e.preventDefault();
                        onContextMenuClose();
                    }, host);
                    event.addListener(host.renderer.scroller, "contextmenu", onContextMenu, host);
                    event.addListener(text, "contextmenu", onContextMenu, host);
                    if (isIOS) addIosSelectionHandler(parentNode, host, text);
                    this.destroy = function() {
                        if (text.parentElement) text.parentElement.removeChild(text);
                    };
                };
                exports1.o = TextInput;
                __webpack_unused_export__ = function __webpack_unused_export__(_isMobile, _isIOS) {
                    isMobile = _isMobile;
                    isIOS = _isIOS;
                };
            /***/ },
            /***/ 1361: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_624514__) {
                "use strict";
                var dom = __nested_webpack_require_624514__(5336);
                var Cursor = /*#__PURE__*/ function() {
                    function Cursor(parentEl) {
                        _class_call_check(this, Cursor);
                        this.element = dom.createElement("div");
                        this.element.className = "ace_layer ace_cursor-layer";
                        parentEl.appendChild(this.element);
                        this.isVisible = false;
                        this.isBlinking = true;
                        this.blinkInterval = 1000;
                        this.smoothBlinking = false;
                        this.cursors = [];
                        this.cursor = this.addCursor();
                        dom.addCssClass(this.element, "ace_hidden-cursors");
                        this.$updateCursors = this.$updateOpacity.bind(this);
                    }
                    _create_class(Cursor, [
                        {
                            key: "$updateOpacity",
                            value: function $updateOpacity(val) {
                                var cursors = this.cursors;
                                for(var i = cursors.length; i--;)dom.setStyle(cursors[i].style, "opacity", val ? "" : "0");
                            }
                        },
                        {
                            key: "$startCssAnimation",
                            value: function $startCssAnimation() {
                                var cursors = this.cursors;
                                for(var i = cursors.length; i--;)cursors[i].style.animationDuration = this.blinkInterval + "ms";
                                this.$isAnimating = true;
                                setTimeout((function() {
                                    if (this.$isAnimating) {
                                        dom.addCssClass(this.element, "ace_animate-blinking");
                                    }
                                }).bind(this));
                            }
                        },
                        {
                            key: "$stopCssAnimation",
                            value: function $stopCssAnimation() {
                                this.$isAnimating = false;
                                dom.removeCssClass(this.element, "ace_animate-blinking");
                            }
                        },
                        {
                            key: "setPadding",
                            value: function setPadding(padding) {
                                this.$padding = padding;
                            }
                        },
                        {
                            key: "setSession",
                            value: function setSession(session) {
                                this.session = session;
                            }
                        },
                        {
                            key: "setBlinking",
                            value: function setBlinking(blinking) {
                                if (blinking != this.isBlinking) {
                                    this.isBlinking = blinking;
                                    this.restartTimer();
                                }
                            }
                        },
                        {
                            key: "setBlinkInterval",
                            value: function setBlinkInterval(blinkInterval) {
                                if (blinkInterval != this.blinkInterval) {
                                    this.blinkInterval = blinkInterval;
                                    this.restartTimer();
                                }
                            }
                        },
                        {
                            key: "setSmoothBlinking",
                            value: function setSmoothBlinking(smoothBlinking) {
                                if (smoothBlinking != this.smoothBlinking) {
                                    this.smoothBlinking = smoothBlinking;
                                    dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
                                    this.$updateCursors(true);
                                    this.restartTimer();
                                }
                            }
                        },
                        {
                            key: "addCursor",
                            value: function addCursor() {
                                var el = dom.createElement("div");
                                el.className = "ace_cursor";
                                this.element.appendChild(el);
                                this.cursors.push(el);
                                return el;
                            }
                        },
                        {
                            key: "removeCursor",
                            value: function removeCursor() {
                                if (this.cursors.length > 1) {
                                    var el = this.cursors.pop();
                                    el.parentNode.removeChild(el);
                                    return el;
                                }
                            }
                        },
                        {
                            key: "hideCursor",
                            value: function hideCursor() {
                                this.isVisible = false;
                                dom.addCssClass(this.element, "ace_hidden-cursors");
                                this.restartTimer();
                            }
                        },
                        {
                            key: "showCursor",
                            value: function showCursor() {
                                this.isVisible = true;
                                dom.removeCssClass(this.element, "ace_hidden-cursors");
                                this.restartTimer();
                            }
                        },
                        {
                            key: "restartTimer",
                            value: function restartTimer() {
                                var update = this.$updateCursors;
                                clearInterval(this.intervalId);
                                clearTimeout(this.timeoutId);
                                this.$stopCssAnimation();
                                if (this.smoothBlinking) {
                                    this.$isSmoothBlinking = false;
                                    dom.removeCssClass(this.element, "ace_smooth-blinking");
                                }
                                update(true);
                                if (!this.isBlinking || !this.blinkInterval || !this.isVisible) {
                                    this.$stopCssAnimation();
                                    return;
                                }
                                if (this.smoothBlinking) {
                                    this.$isSmoothBlinking = true;
                                    setTimeout((function() {
                                        if (this.$isSmoothBlinking) {
                                            dom.addCssClass(this.element, "ace_smooth-blinking");
                                        }
                                    }).bind(this));
                                }
                                if (dom.HAS_CSS_ANIMATION) {
                                    this.$startCssAnimation();
                                } else {
                                    var blink = (function() {
                                        this.timeoutId = setTimeout(function() {
                                            update(false);
                                        }, 0.6 * this.blinkInterval);
                                    }).bind(this);
                                    this.intervalId = setInterval(function() {
                                        update(true);
                                        blink();
                                    }, this.blinkInterval);
                                    blink();
                                }
                            }
                        },
                        {
                            key: "getPixelPosition",
                            value: function getPixelPosition(position, onScreen) {
                                if (!this.config || !this.session) return {
                                    left: 0,
                                    top: 0
                                };
                                if (!position) position = this.session.selection.getCursor();
                                var pos = this.session.documentToScreenPosition(position);
                                var cursorLeft = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, position.row) ? this.session.$bidiHandler.getPosLeft(pos.column) : pos.column * this.config.characterWidth);
                                var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) * this.config.lineHeight;
                                return {
                                    left: cursorLeft,
                                    top: cursorTop
                                };
                            }
                        },
                        {
                            key: "isCursorInView",
                            value: function isCursorInView(pixelPos, config) {
                                return pixelPos.top >= 0 && pixelPos.top < config.maxHeight;
                            }
                        },
                        {
                            key: "update",
                            value: function update(config) {
                                this.config = config;
                                var selections = this.session.$selectionMarkers;
                                var i = 0, cursorIndex = 0;
                                if (selections === undefined || selections.length === 0) {
                                    selections = [
                                        {
                                            cursor: null
                                        }
                                    ];
                                }
                                for(var i = 0, n = selections.length; i < n; i++){
                                    var pixelPos = this.getPixelPosition(selections[i].cursor, true);
                                    if ((pixelPos.top > config.height + config.offset || pixelPos.top < 0) && i > 1) {
                                        continue;
                                    }
                                    var element = this.cursors[cursorIndex++] || this.addCursor();
                                    var style = element.style;
                                    if (!this.drawCursor) {
                                        if (!this.isCursorInView(pixelPos, config)) {
                                            dom.setStyle(style, "display", "none");
                                        } else {
                                            dom.setStyle(style, "display", "block");
                                            dom.translate(element, pixelPos.left, pixelPos.top);
                                            dom.setStyle(style, "width", Math.round(config.characterWidth) + "px");
                                            dom.setStyle(style, "height", config.lineHeight + "px");
                                        }
                                    } else {
                                        this.drawCursor(element, pixelPos, config, selections[i], this.session);
                                    }
                                }
                                while(this.cursors.length > cursorIndex)this.removeCursor();
                                var overwrite = this.session.getOverwrite();
                                this.$setOverwrite(overwrite);
                                // cache for textarea and gutter highlight
                                this.$pixelPos = pixelPos;
                                this.restartTimer();
                            }
                        },
                        {
                            key: "$setOverwrite",
                            value: function $setOverwrite(overwrite) {
                                if (overwrite != this.overwrite) {
                                    this.overwrite = overwrite;
                                    if (overwrite) dom.addCssClass(this.element, "ace_overwrite-cursors");
                                    else dom.removeCssClass(this.element, "ace_overwrite-cursors");
                                }
                            }
                        },
                        {
                            key: "destroy",
                            value: function destroy() {
                                clearInterval(this.intervalId);
                                clearTimeout(this.timeoutId);
                            }
                        }
                    ]);
                    return Cursor;
                }();
                Cursor.prototype.$padding = 0;
                Cursor.prototype.drawCursor = null;
                exports1.C = Cursor;
            /***/ },
            /***/ 9945: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_638280__) {
                "use strict";
                var dom = __nested_webpack_require_638280__(5336);
                var oop = __nested_webpack_require_638280__(2011);
                var EventEmitter = __nested_webpack_require_638280__(7858)/* .EventEmitter */ .v;
                var Decorator = /*#__PURE__*/ function() {
                    function Decorator(parent, renderer) {
                        _class_call_check(this, Decorator);
                        this.canvas = dom.createElement("canvas");
                        this.renderer = renderer;
                        this.pixelRatio = 1;
                        this.maxHeight = renderer.layerConfig.maxHeight;
                        this.lineHeight = renderer.layerConfig.lineHeight;
                        this.canvasHeight = parent.parent.scrollHeight;
                        this.heightRatio = this.canvasHeight / this.maxHeight;
                        this.canvasWidth = parent.width;
                        this.minDecorationHeight = 2 * this.pixelRatio | 0;
                        this.halfMinDecorationHeight = this.minDecorationHeight / 2 | 0;
                        this.canvas.width = this.canvasWidth;
                        this.canvas.height = this.canvasHeight;
                        this.canvas.style.top = 0 + "px";
                        this.canvas.style.right = 0 + "px";
                        this.canvas.style.zIndex = 7 + "px";
                        this.canvas.style.position = "absolute";
                        this.colors = {};
                        this.colors.dark = {
                            "error": "rgba(255, 18, 18, 1)",
                            "warning": "rgba(18, 136, 18, 1)",
                            "info": "rgba(18, 18, 136, 1)"
                        };
                        this.colors.light = {
                            "error": "rgb(255,51,51)",
                            "warning": "rgb(32,133,72)",
                            "info": "rgb(35,68,138)"
                        };
                        parent.element.appendChild(this.canvas);
                    }
                    _create_class(Decorator, [
                        {
                            key: "$updateDecorators",
                            value: function $updateDecorators(config) {
                                var compare = function compare(a, b) {
                                    if (a.priority < b.priority) return -1;
                                    if (a.priority > b.priority) return 1;
                                    return 0;
                                };
                                var colors = this.renderer.theme.isDark === true ? this.colors.dark : this.colors.light;
                                if (config) {
                                    this.maxHeight = config.maxHeight;
                                    this.lineHeight = config.lineHeight;
                                    this.canvasHeight = config.height;
                                    var allLineHeight = (config.lastRow + 1) * this.lineHeight;
                                    if (allLineHeight < this.canvasHeight) {
                                        this.heightRatio = 1;
                                    } else {
                                        this.heightRatio = this.canvasHeight / this.maxHeight;
                                    }
                                }
                                var ctx = this.canvas.getContext("2d");
                                var annotations = this.renderer.session.$annotations;
                                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                                if (annotations) {
                                    var priorities = {
                                        "info": 1,
                                        "warning": 2,
                                        "error": 3
                                    };
                                    annotations.forEach(function(item) {
                                        item.priority = priorities[item.type] || null;
                                    });
                                    annotations = annotations.sort(compare);
                                    var foldData = this.renderer.session.$foldData;
                                    for(var i = 0; i < annotations.length; i++){
                                        var row = annotations[i].row;
                                        var compensateFold = this.compensateFoldRows(row, foldData);
                                        var currentY = Math.round((row - compensateFold) * this.lineHeight * this.heightRatio);
                                        var y1 = Math.round((row - compensateFold) * this.lineHeight * this.heightRatio);
                                        var y2 = Math.round(((row - compensateFold) * this.lineHeight + this.lineHeight) * this.heightRatio);
                                        var height = y2 - y1;
                                        if (height < this.minDecorationHeight) {
                                            var yCenter = (y1 + y2) / 2 | 0;
                                            if (yCenter < this.halfMinDecorationHeight) {
                                                yCenter = this.halfMinDecorationHeight;
                                            } else if (yCenter + this.halfMinDecorationHeight > this.canvasHeight) {
                                                yCenter = this.canvasHeight - this.halfMinDecorationHeight;
                                            }
                                            y1 = Math.round(yCenter - this.halfMinDecorationHeight);
                                            y2 = Math.round(yCenter + this.halfMinDecorationHeight);
                                        }
                                        ctx.fillStyle = colors[annotations[i].type] || null;
                                        ctx.fillRect(0, currentY, this.canvasWidth, y2 - y1);
                                    }
                                }
                                var cursor = this.renderer.session.selection.getCursor();
                                if (cursor) {
                                    var compensateFold1 = this.compensateFoldRows(cursor.row, foldData);
                                    var currentY1 = Math.round((cursor.row - compensateFold1) * this.lineHeight * this.heightRatio);
                                    ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
                                    ctx.fillRect(0, currentY1, this.canvasWidth, 2);
                                }
                            }
                        },
                        {
                            key: "compensateFoldRows",
                            value: function compensateFoldRows(row, foldData) {
                                var compensateFold = 0;
                                if (foldData && foldData.length > 0) {
                                    for(var j = 0; j < foldData.length; j++){
                                        if (row > foldData[j].start.row && row < foldData[j].end.row) {
                                            compensateFold += row - foldData[j].start.row;
                                        } else if (row >= foldData[j].end.row) {
                                            compensateFold += foldData[j].end.row - foldData[j].start.row;
                                        }
                                    }
                                }
                                return compensateFold;
                            }
                        }
                    ]);
                    return Decorator;
                }();
                oop.implement(Decorator.prototype, EventEmitter);
                exports1.S = Decorator;
            /***/ },
            /***/ 342: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_646316__) {
                var oop = __nested_webpack_require_646316__(2011);
                var dom = __nested_webpack_require_646316__(5336);
                var lang = __nested_webpack_require_646316__(732);
                var event = __nested_webpack_require_646316__(8215);
                var useragent = __nested_webpack_require_646316__(8057);
                var EventEmitter = __nested_webpack_require_646316__(7858)/* .EventEmitter */ .v;
                var CHAR_COUNT = 512;
                var USE_OBSERVER = typeof ResizeObserver == "function";
                var L = 200;
                var FontMetrics = /*#__PURE__*/ function() {
                    "use strict";
                    function FontMetrics(parentEl) {
                        _class_call_check(this, FontMetrics);
                        this.el = dom.createElement("div");
                        this.$setMeasureNodeStyles(this.el.style, true);
                        this.$main = dom.createElement("div");
                        this.$setMeasureNodeStyles(this.$main.style);
                        this.$measureNode = dom.createElement("div");
                        this.$setMeasureNodeStyles(this.$measureNode.style);
                        this.el.appendChild(this.$main);
                        this.el.appendChild(this.$measureNode);
                        parentEl.appendChild(this.el);
                        this.$measureNode.textContent = lang.stringRepeat("X", CHAR_COUNT);
                        this.$characterSize = {
                            width: 0,
                            height: 0
                        };
                        if (USE_OBSERVER) this.$addObserver();
                        else this.checkForSizeChanges();
                    }
                    _create_class(FontMetrics, [
                        {
                            key: "$setMeasureNodeStyles",
                            value: function $setMeasureNodeStyles(style, isRoot) {
                                style.width = style.height = "auto";
                                style.left = style.top = "0px";
                                style.visibility = "hidden";
                                style.position = "absolute";
                                style.whiteSpace = "pre";
                                if (useragent.isIE < 8) {
                                    style["font-family"] = "inherit";
                                } else {
                                    style.font = "inherit";
                                }
                                style.overflow = isRoot ? "hidden" : "visible";
                            }
                        },
                        {
                            key: "checkForSizeChanges",
                            value: function checkForSizeChanges(size) {
                                if (size === undefined) size = this.$measureSizes();
                                if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
                                    this.$measureNode.style.fontWeight = "bold";
                                    var boldSize = this.$measureSizes();
                                    this.$measureNode.style.fontWeight = "";
                                    this.$characterSize = size;
                                    this.charSizes = Object.create(null);
                                    this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
                                    this._emit("changeCharacterSize", {
                                        data: size
                                    });
                                }
                            }
                        },
                        {
                            key: "$addObserver",
                            value: function $addObserver() {
                                var _$self = this;
                                this.$observer = new window.ResizeObserver(function(e) {
                                    // e[0].contentRect is broken on safari when zoomed;
                                    _$self.checkForSizeChanges();
                                });
                                this.$observer.observe(this.$measureNode);
                            }
                        },
                        {
                            key: "$pollSizeChanges",
                            value: function $pollSizeChanges() {
                                if (this.$pollSizeChangesTimer || this.$observer) return this.$pollSizeChangesTimer;
                                var _$self = this;
                                return this.$pollSizeChangesTimer = event.onIdle(function cb() {
                                    _$self.checkForSizeChanges();
                                    event.onIdle(cb, 500);
                                }, 500);
                            }
                        },
                        {
                            key: "setPolling",
                            value: function setPolling(val) {
                                if (val) {
                                    this.$pollSizeChanges();
                                } else if (this.$pollSizeChangesTimer) {
                                    clearInterval(this.$pollSizeChangesTimer);
                                    this.$pollSizeChangesTimer = 0;
                                }
                            }
                        },
                        {
                            key: "$measureSizes",
                            value: function $measureSizes(node) {
                                var size = {
                                    height: (node || this.$measureNode).clientHeight,
                                    width: (node || this.$measureNode).clientWidth / CHAR_COUNT
                                };
                                // Size and width can be null if the editor is not visible or
                                // detached from the document
                                if (size.width === 0 || size.height === 0) return null;
                                return size;
                            }
                        },
                        {
                            key: "$measureCharWidth",
                            value: function $measureCharWidth(ch) {
                                this.$main.textContent = lang.stringRepeat(ch, CHAR_COUNT);
                                var rect = this.$main.getBoundingClientRect();
                                return rect.width / CHAR_COUNT;
                            }
                        },
                        {
                            key: "getCharacterWidth",
                            value: function getCharacterWidth(ch) {
                                var w = this.charSizes[ch];
                                if (w === undefined) {
                                    w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
                                }
                                return w;
                            }
                        },
                        {
                            key: "destroy",
                            value: function destroy() {
                                clearInterval(this.$pollSizeChangesTimer);
                                if (this.$observer) this.$observer.disconnect();
                                if (this.el && this.el.parentNode) this.el.parentNode.removeChild(this.el);
                            }
                        },
                        {
                            key: "$getZoom",
                            value: function $getZoom(element) {
                                if (!element || !element.parentElement) return 1;
                                return (window.getComputedStyle(element).zoom || 1) * this.$getZoom(element.parentElement);
                            }
                        },
                        {
                            key: "$initTransformMeasureNodes",
                            value: function $initTransformMeasureNodes() {
                                var t = function t(t, l) {
                                    return [
                                        "div",
                                        {
                                            style: "position: absolute;top:" + t + "px;left:" + l + "px;"
                                        }
                                    ];
                                };
                                this.els = dom.buildDom([
                                    t(0, 0),
                                    t(L, 0),
                                    t(0, L),
                                    t(L, L)
                                ], this.el);
                            }
                        },
                        {
                            // general transforms from element coordinates x to screen coordinates u have the form
                            // | m1[0] m2[0] t[0] |   | x |       | u |
                            // | m1[1] m2[1] t[1] | . | y |  == k | v |
                            // | h[0]  h[1]  1    |   | 1 |       | 1 |
                            // this function finds the coeeficients of the matrix using positions of four points
                            //  
                            key: "transformCoordinates",
                            value: function transformCoordinates(clientPos, elPos) {
                                var solve = function solve(l1, l2, r) {
                                    var det = l1[1] * l2[0] - l1[0] * l2[1];
                                    return [
                                        (-l2[1] * r[0] + l2[0] * r[1]) / det,
                                        (+l1[1] * r[0] - l1[0] * r[1]) / det
                                    ];
                                };
                                var sub = function sub(a, b) {
                                    return [
                                        a[0] - b[0],
                                        a[1] - b[1]
                                    ];
                                };
                                var add = function add(a, b) {
                                    return [
                                        a[0] + b[0],
                                        a[1] + b[1]
                                    ];
                                };
                                var mul = function mul(a, b) {
                                    return [
                                        a * b[0],
                                        a * b[1]
                                    ];
                                };
                                var p = function p(el) {
                                    var r = el.getBoundingClientRect();
                                    return [
                                        r.left,
                                        r.top
                                    ];
                                };
                                if (clientPos) {
                                    var zoom = this.$getZoom(this.el);
                                    clientPos = mul(1 / zoom, clientPos);
                                }
                                if (!this.els) this.$initTransformMeasureNodes();
                                var a = p(this.els[0]);
                                var b = p(this.els[1]);
                                var c = p(this.els[2]);
                                var d = p(this.els[3]);
                                var h = solve(sub(d, b), sub(d, c), sub(add(b, c), add(d, a)));
                                var m1 = mul(1 + h[0], sub(b, a));
                                var m2 = mul(1 + h[1], sub(c, a));
                                if (elPos) {
                                    var x = elPos;
                                    var k = h[0] * x[0] / L + h[1] * x[1] / L + 1;
                                    var ut = add(mul(x[0], m1), mul(x[1], m2));
                                    return add(mul(1 / k / L, ut), a);
                                }
                                var u = sub(clientPos, a);
                                var f = solve(sub(m1, mul(h[0], u)), sub(m2, mul(h[1], u)), u);
                                return mul(L, f);
                            }
                        }
                    ]);
                    return FontMetrics;
                }();
                FontMetrics.prototype.$characterSize = {
                    width: 0,
                    height: 0
                };
                oop.implement(FontMetrics.prototype, EventEmitter);
                exports1.c = FontMetrics;
            /***/ },
            /***/ 9749: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_659409__) {
                "use strict";
                var onCreateCell = function onCreateCell(element) {
                    var textNode = document.createTextNode("");
                    element.appendChild(textNode);
                    var foldWidget = dom.createElement("span");
                    element.appendChild(foldWidget);
                    var annotationNode = dom.createElement("span");
                    element.appendChild(annotationNode);
                    return element;
                };
                /* provided dependency */ var console = __nested_webpack_require_659409__(3716);
                var dom = __nested_webpack_require_659409__(5336);
                var oop = __nested_webpack_require_659409__(2011);
                var lang = __nested_webpack_require_659409__(732);
                var EventEmitter = __nested_webpack_require_659409__(7858)/* .EventEmitter */ .v;
                var Lines = __nested_webpack_require_659409__(5130)/* .Lines */ .x;
                var Gutter = /*#__PURE__*/ function() {
                    function Gutter(parentEl) {
                        _class_call_check(this, Gutter);
                        this.element = dom.createElement("div");
                        this.element.className = "ace_layer ace_gutter-layer";
                        parentEl.appendChild(this.element);
                        this.setShowFoldWidgets(this.$showFoldWidgets);
                        this.gutterWidth = 0;
                        this.$annotations = [];
                        this.$updateAnnotations = this.$updateAnnotations.bind(this);
                        this.$lines = new Lines(this.element);
                        this.$lines.$offsetCoefficient = 1;
                    }
                    _create_class(Gutter, [
                        {
                            key: "setSession",
                            value: function setSession(session) {
                                if (this.session) this.session.off("change", this.$updateAnnotations);
                                this.session = session;
                                if (session) session.on("change", this.$updateAnnotations);
                            }
                        },
                        {
                            key: "addGutterDecoration",
                            value: function addGutterDecoration(row, className) {
                                if (window.console) console.warn && console.warn("deprecated use session.addGutterDecoration");
                                this.session.addGutterDecoration(row, className);
                            }
                        },
                        {
                            key: "removeGutterDecoration",
                            value: function removeGutterDecoration(row, className) {
                                if (window.console) console.warn && console.warn("deprecated use session.removeGutterDecoration");
                                this.session.removeGutterDecoration(row, className);
                            }
                        },
                        {
                            key: "setAnnotations",
                            value: function setAnnotations(annotations) {
                                // iterate over sparse array
                                this.$annotations = [];
                                for(var i = 0; i < annotations.length; i++){
                                    var annotation = annotations[i];
                                    var row = annotation.row;
                                    var rowInfo = this.$annotations[row];
                                    if (!rowInfo) rowInfo = this.$annotations[row] = {
                                        text: [],
                                        type: []
                                    };
                                    var annoText = annotation.text;
                                    var annoType = annotation.type;
                                    annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";
                                    if (rowInfo.text.indexOf(annoText) === -1) {
                                        rowInfo.text.push(annoText);
                                        rowInfo.type.push(annoType);
                                    }
                                    var className = annotation.className;
                                    if (className) rowInfo.className = className;
                                    else if (annoType == "error") rowInfo.className = " ace_error";
                                    else if (annoType == "warning" && rowInfo.className != " ace_error") rowInfo.className = " ace_warning";
                                    else if (annoType == "info" && !rowInfo.className) rowInfo.className = " ace_info";
                                }
                            }
                        },
                        {
                            key: "$updateAnnotations",
                            value: function $updateAnnotations(delta) {
                                if (!this.$annotations.length) return;
                                var firstRow = delta.start.row;
                                var len = delta.end.row - firstRow;
                                if (len === 0) {
                                // do nothing
                                } else if (delta.action == "remove") {
                                    this.$annotations.splice(firstRow, len + 1, null);
                                } else {
                                    var args = new Array(len + 1);
                                    args.unshift(firstRow, 1);
                                    this.$annotations.splice.apply(this.$annotations, args);
                                }
                            }
                        },
                        {
                            key: "update",
                            value: function update(config) {
                                this.config = config;
                                var session = this.session;
                                var firstRow = config.firstRow;
                                var lastRow = Math.min(config.lastRow + config.gutterOffset, session.getLength() - 1);
                                this.oldLastRow = lastRow;
                                this.config = config;
                                this.$lines.moveContainer(config);
                                this.$updateCursorRow();
                                var fold = session.getNextFoldLine(firstRow);
                                var foldStart = fold ? fold.start.row : Infinity;
                                var cell = null;
                                var index = -1;
                                var row = firstRow;
                                while(true){
                                    if (row > foldStart) {
                                        row = fold.end.row + 1;
                                        fold = session.getNextFoldLine(row, fold);
                                        foldStart = fold ? fold.start.row : Infinity;
                                    }
                                    if (row > lastRow) {
                                        while(this.$lines.getLength() > index + 1)this.$lines.pop();
                                        break;
                                    }
                                    cell = this.$lines.get(++index);
                                    if (cell) {
                                        cell.row = row;
                                    } else {
                                        cell = this.$lines.createCell(row, config, this.session, onCreateCell);
                                        this.$lines.push(cell);
                                    }
                                    this.$renderCell(cell, config, fold, row);
                                    row++;
                                }
                                this._signal("afterRender");
                                this.$updateGutterWidth(config);
                            }
                        },
                        {
                            key: "$updateGutterWidth",
                            value: function $updateGutterWidth(config) {
                                var session = this.session;
                                var gutterRenderer = session.gutterRenderer || this.$renderer;
                                var firstLineNumber = session.$firstLineNumber;
                                var lastLineText = this.$lines.last() ? this.$lines.last().text : "";
                                if (this.$fixedWidth || session.$useWrapMode) lastLineText = session.getLength() + firstLineNumber - 1;
                                var gutterWidth = gutterRenderer ? gutterRenderer.getWidth(session, lastLineText, config) : lastLineText.toString().length * config.characterWidth;
                                var padding = this.$padding || this.$computePadding();
                                gutterWidth += padding.left + padding.right;
                                if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
                                    this.gutterWidth = gutterWidth;
                                    this.element.parentNode.style.width = this.element.style.width = Math.ceil(this.gutterWidth) + "px";
                                    this._signal("changeGutterWidth", gutterWidth);
                                }
                            }
                        },
                        {
                            key: "$updateCursorRow",
                            value: function $updateCursorRow() {
                                if (!this.$highlightGutterLine) return;
                                var position = this.session.selection.getCursor();
                                if (this.$cursorRow === position.row) return;
                                this.$cursorRow = position.row;
                            }
                        },
                        {
                            key: "updateLineHighlight",
                            value: function updateLineHighlight() {
                                if (!this.$highlightGutterLine) return;
                                var row = this.session.selection.cursor.row;
                                this.$cursorRow = row;
                                if (this.$cursorCell && this.$cursorCell.row == row) return;
                                if (this.$cursorCell) this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
                                var cells = this.$lines.cells;
                                this.$cursorCell = null;
                                for(var i = 0; i < cells.length; i++){
                                    var cell = cells[i];
                                    if (cell.row >= this.$cursorRow) {
                                        if (cell.row > this.$cursorRow) {
                                            var fold = this.session.getFoldLine(this.$cursorRow);
                                            if (i > 0 && fold && fold.start.row == cells[i - 1].row) cell = cells[i - 1];
                                            else break;
                                        }
                                        cell.element.className = "ace_gutter-active-line " + cell.element.className;
                                        this.$cursorCell = cell;
                                        break;
                                    }
                                }
                            }
                        },
                        {
                            key: "scrollLines",
                            value: function scrollLines(config) {
                                var oldConfig = this.config;
                                this.config = config;
                                this.$updateCursorRow();
                                if (this.$lines.pageChanged(oldConfig, config)) return this.update(config);
                                this.$lines.moveContainer(config);
                                var lastRow = Math.min(config.lastRow + config.gutterOffset, this.session.getLength() - 1);
                                var oldLastRow = this.oldLastRow;
                                this.oldLastRow = lastRow;
                                if (!oldConfig || oldLastRow < config.firstRow) return this.update(config);
                                if (lastRow < oldConfig.firstRow) return this.update(config);
                                if (oldConfig.firstRow < config.firstRow) for(var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--)this.$lines.shift();
                                if (oldLastRow > lastRow) for(var row = this.session.getFoldedRowCount(lastRow + 1, oldLastRow); row > 0; row--)this.$lines.pop();
                                if (config.firstRow < oldConfig.firstRow) {
                                    this.$lines.unshift(this.$renderLines(config, config.firstRow, oldConfig.firstRow - 1));
                                }
                                if (lastRow > oldLastRow) {
                                    this.$lines.push(this.$renderLines(config, oldLastRow + 1, lastRow));
                                }
                                this.updateLineHighlight();
                                this._signal("afterRender");
                                this.$updateGutterWidth(config);
                            }
                        },
                        {
                            key: "$renderLines",
                            value: function $renderLines(config, firstRow, lastRow) {
                                var fragment = [];
                                var row = firstRow;
                                var foldLine = this.session.getNextFoldLine(row);
                                var foldStart = foldLine ? foldLine.start.row : Infinity;
                                while(true){
                                    if (row > foldStart) {
                                        row = foldLine.end.row + 1;
                                        foldLine = this.session.getNextFoldLine(row, foldLine);
                                        foldStart = foldLine ? foldLine.start.row : Infinity;
                                    }
                                    if (row > lastRow) break;
                                    var cell = this.$lines.createCell(row, config, this.session, onCreateCell);
                                    this.$renderCell(cell, config, foldLine, row);
                                    fragment.push(cell);
                                    row++;
                                }
                                return fragment;
                            }
                        },
                        {
                            key: "$renderCell",
                            value: function $renderCell(cell, config, fold, row) {
                                var element = cell.element;
                                var session = this.session;
                                var textNode = element.childNodes[0];
                                var foldWidget = element.childNodes[1];
                                var annotationNode = element.childNodes[2];
                                var firstLineNumber = session.$firstLineNumber;
                                var breakpoints = session.$breakpoints;
                                var decorations = session.$decorations;
                                var gutterRenderer = session.gutterRenderer || this.$renderer;
                                var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
                                var foldStart = fold ? fold.start.row : Number.MAX_VALUE;
                                var lineHeight = config.lineHeight + "px";
                                var className;
                                if (this.$useSvgGutterIcons) {
                                    className = "ace_gutter-cell_svg-icons ";
                                    if (this.$annotations[row]) {
                                        annotationNode.className = "ace_icon_svg" + this.$annotations[row].className;
                                        dom.setStyle(annotationNode.style, "height", lineHeight);
                                        dom.setStyle(annotationNode.style, "display", "block");
                                    } else {
                                        dom.setStyle(annotationNode.style, "display", "none");
                                    }
                                } else {
                                    className = "ace_gutter-cell ";
                                    dom.setStyle(annotationNode.style, "display", "none");
                                }
                                if (this.$highlightGutterLine) {
                                    if (row == this.$cursorRow || fold && row < this.$cursorRow && row >= foldStart && this.$cursorRow <= fold.end.row) {
                                        className += "ace_gutter-active-line ";
                                        if (this.$cursorCell != cell) {
                                            if (this.$cursorCell) this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
                                            this.$cursorCell = cell;
                                        }
                                    }
                                }
                                if (breakpoints[row]) className += breakpoints[row];
                                if (decorations[row]) className += decorations[row];
                                if (this.$annotations[row]) className += this.$annotations[row].className;
                                if (element.className != className) element.className = className;
                                if (foldWidgets) {
                                    var c = foldWidgets[row];
                                    // check if cached value is invalidated and we need to recompute
                                    if (c == null) c = foldWidgets[row] = session.getFoldWidget(row);
                                }
                                if (c) {
                                    var className = "ace_fold-widget ace_" + c;
                                    if (c == "start" && row == foldStart && row < fold.end.row) className += " ace_closed";
                                    else className += " ace_open";
                                    if (foldWidget.className != className) foldWidget.className = className;
                                    dom.setStyle(foldWidget.style, "height", lineHeight);
                                    dom.setStyle(foldWidget.style, "display", "inline-block");
                                } else {
                                    if (foldWidget) {
                                        dom.setStyle(foldWidget.style, "display", "none");
                                    }
                                }
                                var text = (gutterRenderer ? gutterRenderer.getText(session, row) : row + firstLineNumber).toString();
                                if (text !== textNode.data) {
                                    textNode.data = text;
                                }
                                dom.setStyle(cell.element.style, "height", this.$lines.computeLineHeight(row, config, session) + "px");
                                dom.setStyle(cell.element.style, "top", this.$lines.computeLineTop(row, config, session) + "px");
                                cell.text = text;
                                return cell;
                            }
                        },
                        {
                            key: "setHighlightGutterLine",
                            value: function setHighlightGutterLine(highlightGutterLine) {
                                this.$highlightGutterLine = highlightGutterLine;
                            }
                        },
                        {
                            key: "setShowLineNumbers",
                            value: function setShowLineNumbers(show) {
                                this.$renderer = !show && {
                                    getWidth: function getWidth() {
                                        return 0;
                                    },
                                    getText: function getText() {
                                        return "";
                                    }
                                };
                            }
                        },
                        {
                            key: "getShowLineNumbers",
                            value: function getShowLineNumbers() {
                                return this.$showLineNumbers;
                            }
                        },
                        {
                            key: "setShowFoldWidgets",
                            value: function setShowFoldWidgets(show) {
                                if (show) dom.addCssClass(this.element, "ace_folding-enabled");
                                else dom.removeCssClass(this.element, "ace_folding-enabled");
                                this.$showFoldWidgets = show;
                                this.$padding = null;
                            }
                        },
                        {
                            key: "getShowFoldWidgets",
                            value: function getShowFoldWidgets() {
                                return this.$showFoldWidgets;
                            }
                        },
                        {
                            key: "$computePadding",
                            value: function $computePadding() {
                                if (!this.element.firstChild) return {
                                    left: 0,
                                    right: 0
                                };
                                var style = dom.computedStyle(this.element.firstChild);
                                this.$padding = {};
                                this.$padding.left = (parseInt(style.borderLeftWidth) || 0) + (parseInt(style.paddingLeft) || 0) + 1;
                                this.$padding.right = (parseInt(style.borderRightWidth) || 0) + (parseInt(style.paddingRight) || 0);
                                return this.$padding;
                            }
                        },
                        {
                            key: "getRegion",
                            value: function getRegion(point) {
                                var padding = this.$padding || this.$computePadding();
                                var rect = this.element.getBoundingClientRect();
                                if (point.x < padding.left + rect.left) return "markers";
                                if (this.$showFoldWidgets && point.x > rect.right - padding.right) return "foldWidgets";
                            }
                        }
                    ]);
                    return Gutter;
                }();
                Gutter.prototype.$fixedWidth = false;
                Gutter.prototype.$highlightGutterLine = true;
                Gutter.prototype.$renderer = "";
                Gutter.prototype.$showLineNumbers = true;
                Gutter.prototype.$showFoldWidgets = true;
                oop.implement(Gutter.prototype, EventEmitter);
                exports1.T = Gutter;
            /***/ },
            /***/ 5130: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_683653__) {
                "use strict";
                var dom = __nested_webpack_require_683653__(5336);
                var Lines = /*#__PURE__*/ function() {
                    function Lines(element, canvasHeight) {
                        _class_call_check(this, Lines);
                        this.element = element;
                        this.canvasHeight = canvasHeight || 500000;
                        this.element.style.height = this.canvasHeight * 2 + "px";
                        this.cells = [];
                        this.cellCache = [];
                        this.$offsetCoefficient = 0;
                    }
                    _create_class(Lines, [
                        {
                            key: "moveContainer",
                            value: function moveContainer(config) {
                                dom.translate(this.element, 0, -(config.firstRowScreen * config.lineHeight % this.canvasHeight) - config.offset * this.$offsetCoefficient);
                            }
                        },
                        {
                            key: "pageChanged",
                            value: function pageChanged(oldConfig, newConfig) {
                                return Math.floor(oldConfig.firstRowScreen * oldConfig.lineHeight / this.canvasHeight) !== Math.floor(newConfig.firstRowScreen * newConfig.lineHeight / this.canvasHeight);
                            }
                        },
                        {
                            key: "computeLineTop",
                            value: function computeLineTop(row, config, session) {
                                var screenTop = config.firstRowScreen * config.lineHeight;
                                var screenPage = Math.floor(screenTop / this.canvasHeight);
                                var lineTop = session.documentToScreenRow(row, 0) * config.lineHeight;
                                return lineTop - screenPage * this.canvasHeight;
                            }
                        },
                        {
                            key: "computeLineHeight",
                            value: function computeLineHeight(row, config, session) {
                                return config.lineHeight * session.getRowLineCount(row);
                            }
                        },
                        {
                            key: "getLength",
                            value: function getLength() {
                                return this.cells.length;
                            }
                        },
                        {
                            key: "get",
                            value: function get(index) {
                                return this.cells[index];
                            }
                        },
                        {
                            key: "shift",
                            value: function shift() {
                                this.$cacheCell(this.cells.shift());
                            }
                        },
                        {
                            key: "pop",
                            value: function pop() {
                                this.$cacheCell(this.cells.pop());
                            }
                        },
                        {
                            key: "push",
                            value: function push(cell) {
                                if (Array.isArray(cell)) {
                                    this.cells.push.apply(this.cells, cell);
                                    var fragment = dom.createFragment(this.element);
                                    for(var i = 0; i < cell.length; i++){
                                        fragment.appendChild(cell[i].element);
                                    }
                                    this.element.appendChild(fragment);
                                } else {
                                    this.cells.push(cell);
                                    this.element.appendChild(cell.element);
                                }
                            }
                        },
                        {
                            key: "unshift",
                            value: function unshift(cell) {
                                if (Array.isArray(cell)) {
                                    this.cells.unshift.apply(this.cells, cell);
                                    var fragment = dom.createFragment(this.element);
                                    for(var i = 0; i < cell.length; i++){
                                        fragment.appendChild(cell[i].element);
                                    }
                                    if (this.element.firstChild) this.element.insertBefore(fragment, this.element.firstChild);
                                    else this.element.appendChild(fragment);
                                } else {
                                    this.cells.unshift(cell);
                                    this.element.insertAdjacentElement("afterbegin", cell.element);
                                }
                            }
                        },
                        {
                            key: "last",
                            value: function last() {
                                if (this.cells.length) return this.cells[this.cells.length - 1];
                                else return null;
                            }
                        },
                        {
                            key: "$cacheCell",
                            value: function $cacheCell(cell) {
                                if (!cell) return;
                                cell.element.remove();
                                this.cellCache.push(cell);
                            }
                        },
                        {
                            key: "createCell",
                            value: function createCell(row, config, session, initElement) {
                                var cell = this.cellCache.pop();
                                if (!cell) {
                                    var element = dom.createElement("div");
                                    if (initElement) initElement(element);
                                    this.element.appendChild(element);
                                    cell = {
                                        element: element,
                                        text: "",
                                        row: row
                                    };
                                }
                                cell.row = row;
                                return cell;
                            }
                        }
                    ]);
                    return Lines;
                }();
                exports1.x = Lines;
            /***/ },
            /***/ 8890: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_690720__) {
                "use strict";
                var getBorderClass = function getBorderClass(tl, tr, br, bl) {
                    return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
                };
                var Range = __nested_webpack_require_690720__(3069)/* .Range */ .e;
                var dom = __nested_webpack_require_690720__(5336);
                var Marker = /*#__PURE__*/ function() {
                    function Marker(parentEl) {
                        _class_call_check(this, Marker);
                        this.element = dom.createElement("div");
                        this.element.className = "ace_layer ace_marker-layer";
                        parentEl.appendChild(this.element);
                    }
                    _create_class(Marker, [
                        {
                            key: "setPadding",
                            value: function setPadding(padding) {
                                this.$padding = padding;
                            }
                        },
                        {
                            key: "setSession",
                            value: function setSession(session) {
                                this.session = session;
                            }
                        },
                        {
                            key: "setMarkers",
                            value: function setMarkers(markers) {
                                this.markers = markers;
                            }
                        },
                        {
                            key: "elt",
                            value: function elt(className, css) {
                                var x = this.i != -1 && this.element.childNodes[this.i];
                                if (!x) {
                                    x = document.createElement("div");
                                    this.element.appendChild(x);
                                    this.i = -1;
                                } else {
                                    this.i++;
                                }
                                x.style.cssText = css;
                                x.className = className;
                            }
                        },
                        {
                            key: "update",
                            value: function update(config) {
                                if (!config) return;
                                this.config = config;
                                this.i = 0;
                                var html;
                                for(var key in this.markers){
                                    var marker = this.markers[key];
                                    if (!marker.range) {
                                        marker.update(html, this, this.session, config);
                                        continue;
                                    }
                                    var range = marker.range.clipRows(config.firstRow, config.lastRow);
                                    if (range.isEmpty()) continue;
                                    range = range.toScreenRange(this.session);
                                    if (marker.renderer) {
                                        var top = this.$getTop(range.start.row, config);
                                        var left = this.$padding + range.start.column * config.characterWidth;
                                        marker.renderer(html, range, left, top, config);
                                    } else if (marker.type == "fullLine") {
                                        this.drawFullLineMarker(html, range, marker.clazz, config);
                                    } else if (marker.type == "screenLine") {
                                        this.drawScreenLineMarker(html, range, marker.clazz, config);
                                    } else if (range.isMultiLine()) {
                                        if (marker.type == "text") this.drawTextMarker(html, range, marker.clazz, config);
                                        else this.drawMultiLineMarker(html, range, marker.clazz, config);
                                    } else {
                                        this.drawSingleLineMarker(html, range, marker.clazz + " ace_start" + " ace_br15", config);
                                    }
                                }
                                if (this.i != -1) {
                                    while(this.i < this.element.childElementCount)this.element.removeChild(this.element.lastChild);
                                }
                            }
                        },
                        {
                            key: "$getTop",
                            value: function $getTop(row, layerConfig) {
                                return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
                            }
                        },
                        {
                            // Draws a marker, which spans a range of text on multiple lines 
                            key: "drawTextMarker",
                            value: function drawTextMarker(stringBuilder, range, clazz, layerConfig, extraStyle) {
                                var session = this.session;
                                var start = range.start.row;
                                var end = range.end.row;
                                var row = start;
                                var prev = 0;
                                var curr = 0;
                                var next = session.getScreenLastRowColumn(row);
                                var lineRange = new Range(row, range.start.column, row, curr);
                                for(; row <= end; row++){
                                    lineRange.start.row = lineRange.end.row = row;
                                    lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
                                    lineRange.end.column = next;
                                    prev = curr;
                                    curr = next;
                                    next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
                                    this.drawSingleLineMarker(stringBuilder, lineRange, clazz + (row == start ? " ace_start" : "") + " ace_br" + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end), layerConfig, row == end ? 0 : 1, extraStyle);
                                }
                            }
                        },
                        {
                            // Draws a multi line marker, where lines span the full width
                            key: "drawMultiLineMarker",
                            value: function drawMultiLineMarker(stringBuilder, range, clazz, config, extraStyle) {
                                // from selection start to the end of the line
                                var padding = this.$padding;
                                var height = config.lineHeight;
                                var top = this.$getTop(range.start.row, config);
                                var left = padding + range.start.column * config.characterWidth;
                                extraStyle = extraStyle || "";
                                if (this.session.$bidiHandler.isBidiRow(range.start.row)) {
                                    var range1 = range.clone();
                                    range1.end.row = range1.start.row;
                                    range1.end.column = this.session.getLine(range1.start.row).length;
                                    this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br1 ace_start", config, null, extraStyle);
                                } else {
                                    this.elt(clazz + " ace_br1 ace_start", "height:" + height + "px;" + "right:0;" + "top:" + top + "px;left:" + left + "px;" + (extraStyle || ""));
                                }
                                // from start of the last line to the selection end
                                if (this.session.$bidiHandler.isBidiRow(range.end.row)) {
                                    var range1 = range.clone();
                                    range1.start.row = range1.end.row;
                                    range1.start.column = 0;
                                    this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br12", config, null, extraStyle);
                                } else {
                                    top = this.$getTop(range.end.row, config);
                                    var width = range.end.column * config.characterWidth;
                                    this.elt(clazz + " ace_br12", "height:" + height + "px;" + "width:" + width + "px;" + "top:" + top + "px;" + "left:" + padding + "px;" + (extraStyle || ""));
                                }
                                // all the complete lines
                                height = (range.end.row - range.start.row - 1) * config.lineHeight;
                                if (height <= 0) return;
                                top = this.$getTop(range.start.row + 1, config);
                                var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);
                                this.elt(clazz + (radiusClass ? " ace_br" + radiusClass : ""), "height:" + height + "px;" + "right:0;" + "top:" + top + "px;" + "left:" + padding + "px;" + (extraStyle || ""));
                            }
                        },
                        {
                            // Draws a marker which covers part or whole width of a single screen line
                            key: "drawSingleLineMarker",
                            value: function drawSingleLineMarker(stringBuilder, range, clazz, config, extraLength, extraStyle) {
                                if (this.session.$bidiHandler.isBidiRow(range.start.row)) return this.drawBidiSingleLineMarker(stringBuilder, range, clazz, config, extraLength, extraStyle);
                                var height = config.lineHeight;
                                var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;
                                var top = this.$getTop(range.start.row, config);
                                var left = this.$padding + range.start.column * config.characterWidth;
                                this.elt(clazz, "height:" + height + "px;" + "width:" + width + "px;" + "top:" + top + "px;" + "left:" + left + "px;" + (extraStyle || ""));
                            }
                        },
                        {
                            // Draws Bidi marker which covers part or whole width of a single screen line
                            key: "drawBidiSingleLineMarker",
                            value: function drawBidiSingleLineMarker(stringBuilder, range, clazz, config, extraLength, extraStyle) {
                                var height = config.lineHeight, top = this.$getTop(range.start.row, config), padding = this.$padding;
                                var selections = this.session.$bidiHandler.getSelections(range.start.column, range.end.column);
                                selections.forEach(function(selection) {
                                    this.elt(clazz, "height:" + height + "px;" + "width:" + (selection.width + (extraLength || 0)) + "px;" + "top:" + top + "px;" + "left:" + (padding + selection.left) + "px;" + (extraStyle || ""));
                                }, this);
                            }
                        },
                        {
                            key: "drawFullLineMarker",
                            value: function drawFullLineMarker(stringBuilder, range, clazz, config, extraStyle) {
                                var top = this.$getTop(range.start.row, config);
                                var height = config.lineHeight;
                                if (range.start.row != range.end.row) height += this.$getTop(range.end.row, config) - top;
                                this.elt(clazz, "height:" + height + "px;" + "top:" + top + "px;" + "left:0;right:0;" + (extraStyle || ""));
                            }
                        },
                        {
                            key: "drawScreenLineMarker",
                            value: function drawScreenLineMarker(stringBuilder, range, clazz, config, extraStyle) {
                                var top = this.$getTop(range.start.row, config);
                                var height = config.lineHeight;
                                this.elt(clazz, "height:" + height + "px;" + "top:" + top + "px;" + "left:0;right:0;" + (extraStyle || ""));
                            }
                        }
                    ]);
                    return Marker;
                }();
                Marker.prototype.$padding = 0;
                exports1.J = Marker;
            /***/ },
            /***/ 8235: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_704154__) {
                "use strict";
                var oop = __nested_webpack_require_704154__(2011);
                var dom = __nested_webpack_require_704154__(5336);
                var lang = __nested_webpack_require_704154__(732);
                var Lines = __nested_webpack_require_704154__(5130)/* .Lines */ .x;
                var EventEmitter = __nested_webpack_require_704154__(7858)/* .EventEmitter */ .v;
                var Text = /*#__PURE__*/ function() {
                    function Text(parentEl) {
                        _class_call_check(this, Text);
                        this.dom = dom;
                        this.element = this.dom.createElement("div");
                        this.element.className = "ace_layer ace_text-layer";
                        parentEl.appendChild(this.element);
                        this.$updateEolChar = this.$updateEolChar.bind(this);
                        this.$lines = new Lines(this.element);
                    }
                    _create_class(Text, [
                        {
                            key: "$updateEolChar",
                            value: function $updateEolChar() {
                                var doc = this.session.doc;
                                var unixMode = doc.getNewLineCharacter() == "\n" && doc.getNewLineMode() != "windows";
                                var EOL_CHAR = unixMode ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;
                                if (this.EOL_CHAR != EOL_CHAR) {
                                    this.EOL_CHAR = EOL_CHAR;
                                    return true;
                                }
                            }
                        },
                        {
                            key: "setPadding",
                            value: function setPadding(padding) {
                                this.$padding = padding;
                                this.element.style.margin = "0 " + padding + "px";
                            }
                        },
                        {
                            key: "getLineHeight",
                            value: function getLineHeight() {
                                return this.$fontMetrics.$characterSize.height || 0;
                            }
                        },
                        {
                            key: "getCharacterWidth",
                            value: function getCharacterWidth() {
                                return this.$fontMetrics.$characterSize.width || 0;
                            }
                        },
                        {
                            key: "$setFontMetrics",
                            value: function $setFontMetrics(measure) {
                                this.$fontMetrics = measure;
                                this.$fontMetrics.on("changeCharacterSize", (function(e) {
                                    this._signal("changeCharacterSize", e);
                                }).bind(this));
                                this.$pollSizeChanges();
                            }
                        },
                        {
                            key: "checkForSizeChanges",
                            value: function checkForSizeChanges() {
                                this.$fontMetrics.checkForSizeChanges();
                            }
                        },
                        {
                            key: "$pollSizeChanges",
                            value: function $pollSizeChanges() {
                                return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
                            }
                        },
                        {
                            key: "setSession",
                            value: function setSession(session) {
                                this.session = session;
                                if (session) this.$computeTabString();
                            }
                        },
                        {
                            key: "setShowInvisibles",
                            value: function setShowInvisibles(showInvisibles) {
                                if (this.showInvisibles == showInvisibles) return false;
                                this.showInvisibles = showInvisibles;
                                if (typeof showInvisibles == "string") {
                                    this.showSpaces = /tab/i.test(showInvisibles);
                                    this.showTabs = /space/i.test(showInvisibles);
                                    this.showEOL = /eol/i.test(showInvisibles);
                                } else {
                                    this.showSpaces = this.showTabs = this.showEOL = showInvisibles;
                                }
                                this.$computeTabString();
                                return true;
                            }
                        },
                        {
                            key: "setDisplayIndentGuides",
                            value: function setDisplayIndentGuides(display) {
                                if (this.displayIndentGuides == display) return false;
                                this.displayIndentGuides = display;
                                this.$computeTabString();
                                return true;
                            }
                        },
                        {
                            key: "setHighlightIndentGuides",
                            value: function setHighlightIndentGuides(highlight) {
                                if (this.$highlightIndentGuides === highlight) return false;
                                this.$highlightIndentGuides = highlight;
                                return highlight;
                            }
                        },
                        {
                            key: "$computeTabString",
                            value: function $computeTabString() {
                                var tabSize = this.session.getTabSize();
                                this.tabSize = tabSize;
                                var tabStr = this.$tabStrings = [
                                    0
                                ];
                                for(var i = 1; i < tabSize + 1; i++){
                                    if (this.showTabs) {
                                        var span = this.dom.createElement("span");
                                        span.className = "ace_invisible ace_invisible_tab";
                                        span.textContent = lang.stringRepeat(this.TAB_CHAR, i);
                                        tabStr.push(span);
                                    } else {
                                        tabStr.push(this.dom.createTextNode(lang.stringRepeat(" ", i), this.element));
                                    }
                                }
                                if (this.displayIndentGuides) {
                                    this.$indentGuideRe = /\s\S| \t|\t |\s$/;
                                    var className = "ace_indent-guide";
                                    var spaceClass = this.showSpaces ? " ace_invisible ace_invisible_space" : "";
                                    var spaceContent = this.showSpaces ? lang.stringRepeat(this.SPACE_CHAR, this.tabSize) : lang.stringRepeat(" ", this.tabSize);
                                    var tabClass = this.showTabs ? " ace_invisible ace_invisible_tab" : "";
                                    var tabContent = this.showTabs ? lang.stringRepeat(this.TAB_CHAR, this.tabSize) : spaceContent;
                                    var span = this.dom.createElement("span");
                                    span.className = className + spaceClass;
                                    span.textContent = spaceContent;
                                    this.$tabStrings[" "] = span;
                                    var span = this.dom.createElement("span");
                                    span.className = className + tabClass;
                                    span.textContent = tabContent;
                                    this.$tabStrings["	"] = span;
                                }
                            }
                        },
                        {
                            key: "updateLines",
                            value: function updateLines(config, firstRow, lastRow) {
                                // Due to wrap line changes there can be new lines if e.g.
                                // the line to updated wrapped in the meantime.
                                if (this.config.lastRow != config.lastRow || this.config.firstRow != config.firstRow) {
                                    return this.update(config);
                                }
                                this.config = config;
                                var first = Math.max(firstRow, config.firstRow);
                                var last = Math.min(lastRow, config.lastRow);
                                var lineElements = this.element.childNodes;
                                var lineElementsIdx = 0;
                                for(var row = config.firstRow; row < first; row++){
                                    var foldLine = this.session.getFoldLine(row);
                                    if (foldLine) {
                                        if (foldLine.containsRow(first)) {
                                            first = foldLine.start.row;
                                            break;
                                        } else {
                                            row = foldLine.end.row;
                                        }
                                    }
                                    lineElementsIdx++;
                                }
                                var heightChanged = false;
                                var row = first;
                                var foldLine = this.session.getNextFoldLine(row);
                                var foldStart = foldLine ? foldLine.start.row : Infinity;
                                while(true){
                                    if (row > foldStart) {
                                        row = foldLine.end.row + 1;
                                        foldLine = this.session.getNextFoldLine(row, foldLine);
                                        foldStart = foldLine ? foldLine.start.row : Infinity;
                                    }
                                    if (row > last) break;
                                    var lineElement = lineElements[lineElementsIdx++];
                                    if (lineElement) {
                                        this.dom.removeChildren(lineElement);
                                        this.$renderLine(lineElement, row, row == foldStart ? foldLine : false);
                                        if (heightChanged) lineElement.style.top = this.$lines.computeLineTop(row, config, this.session) + "px";
                                        var height = config.lineHeight * this.session.getRowLength(row) + "px";
                                        if (lineElement.style.height != height) {
                                            heightChanged = true;
                                            lineElement.style.height = height;
                                        }
                                    }
                                    row++;
                                }
                                if (heightChanged) {
                                    while(lineElementsIdx < this.$lines.cells.length){
                                        var cell = this.$lines.cells[lineElementsIdx++];
                                        cell.element.style.top = this.$lines.computeLineTop(cell.row, config, this.session) + "px";
                                    }
                                }
                            }
                        },
                        {
                            key: "scrollLines",
                            value: function scrollLines(config) {
                                var oldConfig = this.config;
                                this.config = config;
                                if (this.$lines.pageChanged(oldConfig, config)) return this.update(config);
                                this.$lines.moveContainer(config);
                                var lastRow = config.lastRow;
                                var oldLastRow = oldConfig ? oldConfig.lastRow : -1;
                                if (!oldConfig || oldLastRow < config.firstRow) return this.update(config);
                                if (lastRow < oldConfig.firstRow) return this.update(config);
                                if (!oldConfig || oldConfig.lastRow < config.firstRow) return this.update(config);
                                if (config.lastRow < oldConfig.firstRow) return this.update(config);
                                if (oldConfig.firstRow < config.firstRow) for(var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--)this.$lines.shift();
                                if (oldConfig.lastRow > config.lastRow) for(var row = this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row > 0; row--)this.$lines.pop();
                                if (config.firstRow < oldConfig.firstRow) {
                                    this.$lines.unshift(this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1));
                                }
                                if (config.lastRow > oldConfig.lastRow) {
                                    this.$lines.push(this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow));
                                }
                                this.$highlightIndentGuide();
                            }
                        },
                        {
                            key: "$renderLinesFragment",
                            value: function $renderLinesFragment(config, firstRow, lastRow) {
                                var fragment = [];
                                var row = firstRow;
                                var foldLine = this.session.getNextFoldLine(row);
                                var foldStart = foldLine ? foldLine.start.row : Infinity;
                                while(true){
                                    if (row > foldStart) {
                                        row = foldLine.end.row + 1;
                                        foldLine = this.session.getNextFoldLine(row, foldLine);
                                        foldStart = foldLine ? foldLine.start.row : Infinity;
                                    }
                                    if (row > lastRow) break;
                                    var line = this.$lines.createCell(row, config, this.session);
                                    var lineEl = line.element;
                                    this.dom.removeChildren(lineEl);
                                    dom.setStyle(lineEl.style, "height", this.$lines.computeLineHeight(row, config, this.session) + "px");
                                    dom.setStyle(lineEl.style, "top", this.$lines.computeLineTop(row, config, this.session) + "px");
                                    // Get the tokens per line as there might be some lines in between
                                    // beeing folded.
                                    this.$renderLine(lineEl, row, row == foldStart ? foldLine : false);
                                    if (this.$useLineGroups()) {
                                        lineEl.className = "ace_line_group";
                                    } else {
                                        lineEl.className = "ace_line";
                                    }
                                    fragment.push(line);
                                    row++;
                                }
                                return fragment;
                            }
                        },
                        {
                            key: "update",
                            value: function update(config) {
                                this.$lines.moveContainer(config);
                                this.config = config;
                                var firstRow = config.firstRow;
                                var lastRow = config.lastRow;
                                var lines = this.$lines;
                                while(lines.getLength())lines.pop();
                                lines.push(this.$renderLinesFragment(config, firstRow, lastRow));
                            }
                        },
                        {
                            key: "$renderToken",
                            value: function $renderToken(parent, screenColumn, token, value) {
                                var _$self = this;
                                var re = /(\t)|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\uFEFF\uFFF9-\uFFFC\u2066\u2067\u2068\u202A\u202B\u202D\u202E\u202C\u2069]+)|(\u3000)|([\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]|[\uD800-\uDBFF][\uDC00-\uDFFF])/g;
                                var valueFragment = this.dom.createFragment(this.element);
                                var m;
                                var i = 0;
                                while(m = re.exec(value)){
                                    var tab = m[1];
                                    var simpleSpace = m[2];
                                    var controlCharacter = m[3];
                                    var cjkSpace = m[4];
                                    var cjk = m[5];
                                    if (!_$self.showSpaces && simpleSpace) continue;
                                    var before = i != m.index ? value.slice(i, m.index) : "";
                                    i = m.index + m[0].length;
                                    if (before) {
                                        valueFragment.appendChild(this.dom.createTextNode(before, this.element));
                                    }
                                    if (tab) {
                                        var tabSize = _$self.session.getScreenTabSize(screenColumn + m.index);
                                        valueFragment.appendChild(_$self.$tabStrings[tabSize].cloneNode(true));
                                        screenColumn += tabSize - 1;
                                    } else if (simpleSpace) {
                                        if (_$self.showSpaces) {
                                            var span = this.dom.createElement("span");
                                            span.className = "ace_invisible ace_invisible_space";
                                            span.textContent = lang.stringRepeat(_$self.SPACE_CHAR, simpleSpace.length);
                                            valueFragment.appendChild(span);
                                        } else {
                                            valueFragment.appendChild(this.com.createTextNode(simpleSpace, this.element));
                                        }
                                    } else if (controlCharacter) {
                                        var span = this.dom.createElement("span");
                                        span.className = "ace_invisible ace_invisible_space ace_invalid";
                                        span.textContent = lang.stringRepeat(_$self.SPACE_CHAR, controlCharacter.length);
                                        valueFragment.appendChild(span);
                                    } else if (cjkSpace) {
                                        // U+3000 is both invisible AND full-width, so must be handled uniquely
                                        screenColumn += 1;
                                        var span = this.dom.createElement("span");
                                        span.style.width = _$self.config.characterWidth * 2 + "px";
                                        span.className = _$self.showSpaces ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
                                        span.textContent = _$self.showSpaces ? _$self.SPACE_CHAR : cjkSpace;
                                        valueFragment.appendChild(span);
                                    } else if (cjk) {
                                        screenColumn += 1;
                                        var span = this.dom.createElement("span");
                                        span.style.width = _$self.config.characterWidth * 2 + "px";
                                        span.className = "ace_cjk";
                                        span.textContent = cjk;
                                        valueFragment.appendChild(span);
                                    }
                                }
                                valueFragment.appendChild(this.dom.createTextNode(i ? value.slice(i) : value, this.element));
                                if (!this.$textToken[token.type]) {
                                    var classes = "ace_" + token.type.replace(/\./g, " ace_");
                                    var span = this.dom.createElement("span");
                                    if (token.type == "fold") span.style.width = token.value.length * this.config.characterWidth + "px";
                                    span.className = classes;
                                    span.appendChild(valueFragment);
                                    parent.appendChild(span);
                                } else {
                                    parent.appendChild(valueFragment);
                                }
                                return screenColumn + value.length;
                            }
                        },
                        {
                            key: "renderIndentGuide",
                            value: function renderIndentGuide(parent, value, max) {
                                var cols = value.search(this.$indentGuideRe);
                                if (cols <= 0 || cols >= max) return value;
                                if (value[0] == " ") {
                                    cols -= cols % this.tabSize;
                                    var count = cols / this.tabSize;
                                    for(var i = 0; i < count; i++){
                                        parent.appendChild(this.$tabStrings[" "].cloneNode(true));
                                    }
                                    this.$highlightIndentGuide();
                                    return value.substr(cols);
                                } else if (value[0] == "	") {
                                    for(var i = 0; i < cols; i++){
                                        parent.appendChild(this.$tabStrings["	"].cloneNode(true));
                                    }
                                    this.$highlightIndentGuide();
                                    return value.substr(cols);
                                }
                                this.$highlightIndentGuide();
                                return value;
                            }
                        },
                        {
                            key: "$highlightIndentGuide",
                            value: function $highlightIndentGuide() {
                                if (!this.$highlightIndentGuides || !this.displayIndentGuides) return;
                                this.$highlightIndentGuideMarker = {
                                    indentLevel: undefined,
                                    start: undefined,
                                    end: undefined,
                                    dir: undefined
                                };
                                var lines = this.session.doc.$lines;
                                if (!lines) return;
                                var cursor = this.session.selection.getCursor();
                                var initialIndent = /^\s*/.exec(this.session.doc.getLine(cursor.row))[0].length;
                                var elementIndentLevel = Math.floor(initialIndent / this.tabSize);
                                this.$highlightIndentGuideMarker = {
                                    indentLevel: elementIndentLevel,
                                    start: cursor.row
                                };
                                var bracketHighlight = this.session.$bracketHighlight;
                                if (bracketHighlight) {
                                    var ranges = this.session.$bracketHighlight.ranges;
                                    for(var i = 0; i < ranges.length; i++){
                                        if (cursor.row !== ranges[i].start.row) {
                                            this.$highlightIndentGuideMarker.end = ranges[i].start.row;
                                            if (cursor.row > ranges[i].start.row) {
                                                this.$highlightIndentGuideMarker.dir = -1;
                                            } else {
                                                this.$highlightIndentGuideMarker.dir = 1;
                                            }
                                            break;
                                        }
                                    }
                                }
                                if (!this.$highlightIndentGuideMarker.end) {
                                    if (lines[cursor.row] !== "" && cursor.column === lines[cursor.row].length) {
                                        this.$highlightIndentGuideMarker.dir = 1;
                                        for(var i = cursor.row + 1; i < lines.length; i++){
                                            var line = lines[i];
                                            var currentIndent = /^\s*/.exec(line)[0].length;
                                            if (line !== "") {
                                                this.$highlightIndentGuideMarker.end = i;
                                                if (currentIndent <= initialIndent) break;
                                            }
                                        }
                                    }
                                }
                                this.$renderHighlightIndentGuide();
                            }
                        },
                        {
                            key: "$clearActiveIndentGuide",
                            value: function $clearActiveIndentGuide() {
                                var cells = this.$lines.cells;
                                for(var i = 0; i < cells.length; i++){
                                    var cell = cells[i];
                                    var childNodes = cell.element.childNodes;
                                    if (childNodes.length > 0) {
                                        for(var j = 0; j < childNodes.length; j++){
                                            if (childNodes[j].classList && childNodes[j].classList.contains("ace_indent-guide-active")) {
                                                childNodes[j].classList.remove("ace_indent-guide-active");
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        {
                            key: "$setIndentGuideActive",
                            value: function $setIndentGuideActive(cell, indentLevel) {
                                var line = this.session.doc.getLine(cell.row);
                                if (line !== "") {
                                    var childNodes = cell.element.childNodes;
                                    if (childNodes) {
                                        var node = childNodes[indentLevel - 1];
                                        if (node && node.classList && node.classList.contains("ace_indent-guide")) node.classList.add("ace_indent-guide-active");
                                    }
                                }
                            }
                        },
                        {
                            key: "$renderHighlightIndentGuide",
                            value: function $renderHighlightIndentGuide() {
                                if (!this.$lines) return;
                                var cells = this.$lines.cells;
                                this.$clearActiveIndentGuide();
                                var indentLevel = this.$highlightIndentGuideMarker.indentLevel;
                                if (indentLevel !== 0) {
                                    if (this.$highlightIndentGuideMarker.dir === 1) {
                                        for(var i = 0; i < cells.length; i++){
                                            var cell = cells[i];
                                            if (this.$highlightIndentGuideMarker.end && cell.row >= this.$highlightIndentGuideMarker.start + 1) {
                                                if (cell.row >= this.$highlightIndentGuideMarker.end) break;
                                                this.$setIndentGuideActive(cell, indentLevel);
                                            }
                                        }
                                    } else {
                                        for(var i = cells.length - 1; i >= 0; i--){
                                            var cell = cells[i];
                                            if (this.$highlightIndentGuideMarker.end && cell.row < this.$highlightIndentGuideMarker.start) {
                                                if (cell.row <= this.$highlightIndentGuideMarker.end) break;
                                                this.$setIndentGuideActive(cell, indentLevel);
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        {
                            key: "$createLineElement",
                            value: function $createLineElement(parent) {
                                var lineEl = this.dom.createElement("div");
                                lineEl.className = "ace_line";
                                lineEl.style.height = this.config.lineHeight + "px";
                                return lineEl;
                            }
                        },
                        {
                            key: "$renderWrappedLine",
                            value: function $renderWrappedLine(parent, tokens, splits) {
                                var chars = 0;
                                var split = 0;
                                var splitChars = splits[0];
                                var screenColumn = 0;
                                var lineEl = this.$createLineElement();
                                parent.appendChild(lineEl);
                                for(var i = 0; i < tokens.length; i++){
                                    var token = tokens[i];
                                    var value = token.value;
                                    if (i == 0 && this.displayIndentGuides) {
                                        chars = value.length;
                                        value = this.renderIndentGuide(lineEl, value, splitChars);
                                        if (!value) continue;
                                        chars -= value.length;
                                    }
                                    if (chars + value.length < splitChars) {
                                        screenColumn = this.$renderToken(lineEl, screenColumn, token, value);
                                        chars += value.length;
                                    } else {
                                        while(chars + value.length >= splitChars){
                                            screenColumn = this.$renderToken(lineEl, screenColumn, token, value.substring(0, splitChars - chars));
                                            value = value.substring(splitChars - chars);
                                            chars = splitChars;
                                            lineEl = this.$createLineElement();
                                            parent.appendChild(lineEl);
                                            lineEl.appendChild(this.dom.createTextNode(lang.stringRepeat("\xa0", splits.indent), this.element));
                                            split++;
                                            screenColumn = 0;
                                            splitChars = splits[split] || Number.MAX_VALUE;
                                        }
                                        if (value.length != 0) {
                                            chars += value.length;
                                            screenColumn = this.$renderToken(lineEl, screenColumn, token, value);
                                        }
                                    }
                                }
                                if (splits[splits.length - 1] > this.MAX_LINE_LENGTH) this.$renderOverflowMessage(lineEl, screenColumn, null, "", true);
                            }
                        },
                        {
                            key: "$renderSimpleLine",
                            value: function $renderSimpleLine(parent, tokens) {
                                var screenColumn = 0;
                                for(var i = 0; i < tokens.length; i++){
                                    var token = tokens[i];
                                    var value = token.value;
                                    if (i == 0 && this.displayIndentGuides) {
                                        value = this.renderIndentGuide(parent, value);
                                        if (!value) continue;
                                    }
                                    if (screenColumn + value.length > this.MAX_LINE_LENGTH) return this.$renderOverflowMessage(parent, screenColumn, token, value);
                                    screenColumn = this.$renderToken(parent, screenColumn, token, value);
                                }
                            }
                        },
                        {
                            key: "$renderOverflowMessage",
                            value: function $renderOverflowMessage(parent, screenColumn, token, value, hide) {
                                token && this.$renderToken(parent, screenColumn, token, value.slice(0, this.MAX_LINE_LENGTH - screenColumn));
                                var overflowEl = this.dom.createElement("span");
                                overflowEl.className = "ace_inline_button ace_keyword ace_toggle_wrap";
                                overflowEl.textContent = hide ? "<hide>" : "<click to see more...>";
                                parent.appendChild(overflowEl);
                            }
                        },
                        {
                            // row is either first row of foldline or not in fold
                            key: "$renderLine",
                            value: function $renderLine(parent, row, foldLine) {
                                if (!foldLine && foldLine != false) foldLine = this.session.getFoldLine(row);
                                if (foldLine) var tokens = this.$getFoldLineTokens(row, foldLine);
                                else var tokens = this.session.getTokens(row);
                                var lastLineEl = parent;
                                if (tokens.length) {
                                    var splits = this.session.getRowSplitData(row);
                                    if (splits && splits.length) {
                                        this.$renderWrappedLine(parent, tokens, splits);
                                        var lastLineEl = parent.lastChild;
                                    } else {
                                        var lastLineEl = parent;
                                        if (this.$useLineGroups()) {
                                            lastLineEl = this.$createLineElement();
                                            parent.appendChild(lastLineEl);
                                        }
                                        this.$renderSimpleLine(lastLineEl, tokens);
                                    }
                                } else if (this.$useLineGroups()) {
                                    lastLineEl = this.$createLineElement();
                                    parent.appendChild(lastLineEl);
                                }
                                if (this.showEOL && lastLineEl) {
                                    if (foldLine) row = foldLine.end.row;
                                    var invisibleEl = this.dom.createElement("span");
                                    invisibleEl.className = "ace_invisible ace_invisible_eol";
                                    invisibleEl.textContent = row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR;
                                    lastLineEl.appendChild(invisibleEl);
                                }
                            }
                        },
                        {
                            key: "$getFoldLineTokens",
                            value: function $getFoldLineTokens(row, foldLine) {
                                var addTokens = function addTokens(tokens, from, to) {
                                    var idx = 0, col = 0;
                                    while(col + tokens[idx].value.length < from){
                                        col += tokens[idx].value.length;
                                        idx++;
                                        if (idx == tokens.length) return;
                                    }
                                    if (col != from) {
                                        var value = tokens[idx].value.substring(from - col);
                                        // Check if the token value is longer then the from...to spacing.
                                        if (value.length > to - from) value = value.substring(0, to - from);
                                        renderTokens.push({
                                            type: tokens[idx].type,
                                            value: value
                                        });
                                        col = from + value.length;
                                        idx += 1;
                                    }
                                    while(col < to && idx < tokens.length){
                                        var value = tokens[idx].value;
                                        if (value.length + col > to) {
                                            renderTokens.push({
                                                type: tokens[idx].type,
                                                value: value.substring(0, to - col)
                                            });
                                        } else renderTokens.push(tokens[idx]);
                                        col += value.length;
                                        idx += 1;
                                    }
                                };
                                var session = this.session;
                                var renderTokens = [];
                                var tokens = session.getTokens(row);
                                foldLine.walk(function(placeholder, row, column, lastColumn, isNewRow) {
                                    if (placeholder != null) {
                                        renderTokens.push({
                                            type: "fold",
                                            value: placeholder
                                        });
                                    } else {
                                        if (isNewRow) tokens = session.getTokens(row);
                                        if (tokens.length) addTokens(tokens, lastColumn, column);
                                    }
                                }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);
                                return renderTokens;
                            }
                        },
                        {
                            key: "$useLineGroups",
                            value: function $useLineGroups() {
                                // For the updateLines function to work correctly, it's important that the
                                // child nodes of this.element correspond on a 1-to-1 basis to rows in the
                                // document (as distinct from lines on the screen). For sessions that are
                                // wrapped, this means we need to add a layer to the node hierarchy (tagged
                                // with the class name ace_line_group).
                                return this.session.getUseWrapMode();
                            }
                        }
                    ]);
                    return Text;
                }();
                Text.prototype.$textToken = {
                    "text": true,
                    "rparen": true,
                    "lparen": true
                };
                Text.prototype.EOF_CHAR = "\xb6";
                Text.prototype.EOL_CHAR_LF = "\xac";
                Text.prototype.EOL_CHAR_CRLF = "\xa4";
                Text.prototype.EOL_CHAR = Text.prototype.EOL_CHAR_LF;
                Text.prototype.TAB_CHAR = "—"; //"\u21E5";
                Text.prototype.SPACE_CHAR = "\xb7";
                Text.prototype.$padding = 0;
                Text.prototype.MAX_LINE_LENGTH = 10000;
                Text.prototype.showInvisibles = false;
                Text.prototype.showSpaces = false;
                Text.prototype.showTabs = false;
                Text.prototype.showEOL = false;
                Text.prototype.displayIndentGuides = true;
                Text.prototype.$highlightIndentGuides = true;
                Text.prototype.$tabStrings = [];
                Text.prototype.destroy = {};
                Text.prototype.onChangeTabSize = Text.prototype.$computeTabString;
                oop.implement(Text.prototype, EventEmitter);
                exports1.x = Text;
            /***/ },
            /***/ 5704: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_748190__) {
                "no use strict";
                var warn = function warn(message) {
                    if (typeof console != "undefined" && console.warn) console.warn.apply(console, arguments);
                };
                var reportError = function reportError(msg, data) {
                    var e = new Error(msg);
                    e.data = data;
                    if (typeof console == "object" && console.error) console.error(e);
                    setTimeout(function() {
                        throw e;
                    });
                };
                /* provided dependency */ var console = __nested_webpack_require_748190__(3716);
                var oop = __nested_webpack_require_748190__(2011);
                var EventEmitter = __nested_webpack_require_748190__(7858)/* .EventEmitter */ .v;
                var optionsProvider = {
                    setOptions: function setOptions(optList) {
                        Object.keys(optList).forEach(function(key) {
                            this.setOption(key, optList[key]);
                        }, this);
                    },
                    getOptions: function getOptions(optionNames) {
                        var result = {};
                        if (!optionNames) {
                            var options = this.$options;
                            optionNames = Object.keys(options).filter(function(key) {
                                return !options[key].hidden;
                            });
                        } else if (!Array.isArray(optionNames)) {
                            result = optionNames;
                            optionNames = Object.keys(result);
                        }
                        optionNames.forEach(function(key) {
                            result[key] = this.getOption(key);
                        }, this);
                        return result;
                    },
                    setOption: function setOption(name, value) {
                        if (this["$" + name] === value) return;
                        var opt = this.$options[name];
                        if (!opt) {
                            return warn('misspelled option "' + name + '"');
                        }
                        if (opt.forwardTo) return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);
                        if (!opt.handlesSet) this["$" + name] = value;
                        if (opt && opt.set) opt.set.call(this, value);
                    },
                    getOption: function getOption(name) {
                        var opt = this.$options[name];
                        if (!opt) {
                            return warn('misspelled option "' + name + '"');
                        }
                        if (opt.forwardTo) return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
                        return opt && opt.get ? opt.get.call(this) : this["$" + name];
                    }
                };
                var AppConfig = /*#__PURE__*/ function() {
                    "use strict";
                    function AppConfig() {
                        _class_call_check(this, AppConfig);
                        this.$defaultOptions = {};
                    }
                    _create_class(AppConfig, [
                        {
                            /*
     * option {name, value, initialValue, setterName, set, get }
     */ key: "defineOptions",
                            value: function defineOptions(obj, path, options) {
                                if (!obj.$options) this.$defaultOptions[path] = obj.$options = {};
                                Object.keys(options).forEach(function(key) {
                                    var opt = options[key];
                                    if (typeof opt == "string") opt = {
                                        forwardTo: opt
                                    };
                                    opt.name || (opt.name = key);
                                    obj.$options[opt.name] = opt;
                                    if ("initialValue" in opt) obj["$" + opt.name] = opt.initialValue;
                                });
                                // implement option provider interface
                                oop.implement(obj, optionsProvider);
                                return this;
                            }
                        },
                        {
                            key: "resetOptions",
                            value: function resetOptions(obj) {
                                Object.keys(obj.$options).forEach(function(key) {
                                    var opt = obj.$options[key];
                                    if ("value" in opt) obj.setOption(key, opt.value);
                                });
                            }
                        },
                        {
                            key: "setDefaultValue",
                            value: function setDefaultValue(path, name, value) {
                                if (!path) {
                                    for(path in this.$defaultOptions)if (this.$defaultOptions[path][name]) break;
                                    if (!this.$defaultOptions[path][name]) return false;
                                }
                                var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
                                if (opts[name]) {
                                    if (opts.forwardTo) this.setDefaultValue(opts.forwardTo, name, value);
                                    else opts[name].value = value;
                                }
                            }
                        },
                        {
                            key: "setDefaultValues",
                            value: function setDefaultValues(path, optionHash) {
                                Object.keys(optionHash).forEach(function(key) {
                                    this.setDefaultValue(path, key, optionHash[key]);
                                }, this);
                            }
                        }
                    ]);
                    return AppConfig;
                }();
                AppConfig.prototype.warn = warn;
                AppConfig.prototype.reportError = reportError;
                // module loading
                oop.implement(AppConfig.prototype, EventEmitter);
                exports1.X = AppConfig;
            /***/ },
            /***/ 7199: /***/ function(__unused_webpack_module, exports1) {
                "use strict";
                var _computeLevels = function _computeLevels(chars, levels, len, charTypes) {
                    var impTab = dir ? impTab_RTL : impTab_LTR, prevState = null, newClass = null, newLevel = null, newState = 0, action = null, cond = null, condPos = -1, i = null, ix = null, classes = [];
                    if (!charTypes) {
                        for(i = 0, charTypes = []; i < len; i++){
                            charTypes[i] = _getCharacterType(chars[i]);
                        }
                    }
                    hiLevel = dir;
                    lastArabic = false;
                    hasUBAT_AL = false;
                    hasUBAT_B = false;
                    hasUBAT_S = false;
                    for(ix = 0; ix < len; ix++){
                        prevState = newState;
                        classes[ix] = newClass = _getCharClass(chars, charTypes, classes, ix);
                        newState = impTab[prevState][newClass];
                        action = newState & 0xF0;
                        newState &= 0x0F;
                        levels[ix] = newLevel = impTab[newState][5];
                        if (action > 0) {
                            if (action == 0x10) {
                                for(i = condPos; i < ix; i++){
                                    levels[i] = 1;
                                }
                                condPos = -1;
                            } else {
                                condPos = -1;
                            }
                        }
                        cond = impTab[newState][6];
                        if (cond) {
                            if (condPos == -1) {
                                condPos = ix;
                            }
                        } else {
                            if (condPos > -1) {
                                for(i = condPos; i < ix; i++){
                                    levels[i] = newLevel;
                                }
                                condPos = -1;
                            }
                        }
                        if (charTypes[ix] == B) {
                            levels[ix] = 0;
                        }
                        hiLevel |= newLevel;
                    }
                    if (hasUBAT_S) {
                        for(i = 0; i < len; i++){
                            if (charTypes[i] == S) {
                                levels[i] = dir;
                                for(var j = i - 1; j >= 0; j--){
                                    if (charTypes[j] == WS) {
                                        levels[j] = dir;
                                    } else {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                };
                var _invertLevel = function _invertLevel(lev, levels, _array) {
                    if (hiLevel < lev) {
                        return;
                    }
                    if (lev == 1 && dir == RTL && !hasUBAT_B) {
                        _array.reverse();
                        return;
                    }
                    var len = _array.length, start = 0, end, lo, hi, tmp;
                    while(start < len){
                        if (levels[start] >= lev) {
                            end = start + 1;
                            while(end < len && levels[end] >= lev){
                                end++;
                            }
                            for(lo = start, hi = end - 1; lo < hi; lo++, hi--){
                                tmp = _array[lo];
                                _array[lo] = _array[hi];
                                _array[hi] = tmp;
                            }
                            start = end;
                        }
                        start++;
                    }
                };
                var _getCharClass = function _getCharClass(chars, types, classes, ix) {
                    var cType = types[ix], wType, nType, len, i;
                    switch(cType){
                        case L:
                        case R:
                            lastArabic = false;
                        case ON:
                        case AN:
                            return cType;
                        case EN:
                            return lastArabic ? AN : EN;
                        case AL:
                            lastArabic = true;
                            hasUBAT_AL = true;
                            return R;
                        case WS:
                            return ON;
                        case CS:
                            if (ix < 1 || ix + 1 >= types.length || (wType = classes[ix - 1]) != EN && wType != AN || (nType = types[ix + 1]) != EN && nType != AN) {
                                return ON;
                            }
                            if (lastArabic) {
                                nType = AN;
                            }
                            return nType == wType ? nType : ON;
                        case ES:
                            wType = ix > 0 ? classes[ix - 1] : B;
                            if (wType == EN && ix + 1 < types.length && types[ix + 1] == EN) {
                                return EN;
                            }
                            return ON;
                        case ET:
                            if (ix > 0 && classes[ix - 1] == EN) {
                                return EN;
                            }
                            if (lastArabic) {
                                return ON;
                            }
                            i = ix + 1;
                            len = types.length;
                            while(i < len && types[i] == ET){
                                i++;
                            }
                            if (i < len && types[i] == EN) {
                                return EN;
                            }
                            return ON;
                        case NSM:
                            len = types.length;
                            i = ix + 1;
                            while(i < len && types[i] == NSM){
                                i++;
                            }
                            if (i < len) {
                                var c = chars[ix], rtlCandidate = c >= 0x0591 && c <= 0x08FF || c == 0xFB1E;
                                wType = types[i];
                                if (rtlCandidate && (wType == R || wType == AL)) {
                                    return R;
                                }
                            }
                            if (ix < 1 || (wType = types[ix - 1]) == B) {
                                return ON;
                            }
                            return classes[ix - 1];
                        case B:
                            lastArabic = false;
                            hasUBAT_B = true;
                            return dir;
                        case S:
                            hasUBAT_S = true;
                            return ON;
                        case LRE:
                        case RLE:
                        case LRO:
                        case RLO:
                        case PDF:
                            lastArabic = false;
                        case BN:
                            return ON;
                    }
                };
                var _getCharacterType = function _getCharacterType(ch) {
                    var uc = ch.charCodeAt(0), hi = uc >> 8;
                    if (hi == 0) {
                        return uc > 0x00BF ? L : UnicodeTBL00[uc];
                    } else if (hi == 5) {
                        return /[\u0591-\u05f4]/.test(ch) ? R : L;
                    } else if (hi == 6) {
                        if (/[\u0610-\u061a\u064b-\u065f\u06d6-\u06e4\u06e7-\u06ed]/.test(ch)) return NSM;
                        else if (/[\u0660-\u0669\u066b-\u066c]/.test(ch)) return AN;
                        else if (uc == 0x066A) return ET;
                        else if (/[\u06f0-\u06f9]/.test(ch)) return EN;
                        else return AL;
                    } else if (hi == 0x20 && uc <= 0x205F) {
                        return UnicodeTBL20[uc & 0xFF];
                    } else if (hi == 0xFE) {
                        return uc >= 0xFE70 ? AL : ON;
                    }
                    return ON;
                };
                var _isArabicDiacritics = function _isArabicDiacritics(ch) {
                    return ch >= "ً" && ch <= "ٕ";
                };
                var ArabicAlefBetIntervalsBegine = /* unused pure expression or super */ null && 0;
                var ArabicAlefBetIntervalsEnd = /* unused pure expression or super */ null && 0;
                var dir = 0, hiLevel = 0;
                var lastArabic = false, hasUBAT_AL = false, hasUBAT_B = false, hasUBAT_S = false, hasBlockSep = false, hasSegSep = false;
                var impTab_LTR = [
                    /*		L,		R,		EN,		AN,		N,		IL,		Cond */ /* 0 LTR text	*/ [
                        0,
                        3,
                        0,
                        1,
                        0,
                        0,
                        0
                    ],
                    /* 1 LTR+AN		*/ [
                        0,
                        3,
                        0,
                        1,
                        2,
                        2,
                        0
                    ],
                    /* 2 LTR+AN+N	*/ [
                        0,
                        3,
                        0,
                        0x11,
                        2,
                        0,
                        1
                    ],
                    /* 3 RTL text	*/ [
                        0,
                        3,
                        5,
                        5,
                        4,
                        1,
                        0
                    ],
                    /* 4 RTL cont	*/ [
                        0,
                        3,
                        0x15,
                        0x15,
                        4,
                        0,
                        1
                    ],
                    /* 5 RTL+EN/AN	*/ [
                        0,
                        3,
                        5,
                        5,
                        4,
                        2,
                        0
                    ]
                ];
                var impTab_RTL = [
                    /*		L,		R,		EN,		AN,		N,		IL,		Cond */ /* 0 RTL text	*/ [
                        2,
                        0,
                        1,
                        1,
                        0,
                        1,
                        0
                    ],
                    /* 1 RTL+EN/AN	*/ [
                        2,
                        0,
                        1,
                        1,
                        0,
                        2,
                        0
                    ],
                    /* 2 LTR text	*/ [
                        2,
                        0,
                        2,
                        1,
                        3,
                        2,
                        0
                    ],
                    /* 3 LTR+cont	*/ [
                        2,
                        0,
                        2,
                        0x21,
                        3,
                        1,
                        1
                    ]
                ];
                var LTR = 0, RTL = 1;
                var L = 0; /* left to right */ 
                var R = 1; /* right to left */ 
                var EN = 2; /* European digit */ 
                var AN = 3; /* Arabic-Indic digit */ 
                var ON = 4; /* neutral */ 
                var B = 5; /* block separator */ 
                var S = 6; /* segment separator */ 
                var AL = 7; /* Arabic Letter */ 
                var WS = 8; /* white space */ 
                var CS = 9; /* common digit separator */ 
                var ES = 10; /* European digit separator */ 
                var ET = 11; /* European digit terminator */ 
                var NSM = 12; /* Non Spacing Mark */ 
                var LRE = 13; /* LRE */ 
                var RLE = 14; /* RLE */ 
                var PDF = 15; /* PDF */ 
                var LRO = 16; /* LRO */ 
                var RLO = 17; /* RLO */ 
                var BN = 18; /* Boundary Neutral */ 
                var UnicodeTBL00 = [
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    S,
                    B,
                    S,
                    WS,
                    B,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    B,
                    B,
                    B,
                    S,
                    WS,
                    ON,
                    ON,
                    ET,
                    ET,
                    ET,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ES,
                    CS,
                    ES,
                    CS,
                    CS,
                    EN,
                    EN,
                    EN,
                    EN,
                    EN,
                    EN,
                    EN,
                    EN,
                    EN,
                    EN,
                    CS,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    L,
                    ON,
                    ON,
                    ON,
                    ON,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    B,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    BN,
                    CS,
                    ON,
                    ET,
                    ET,
                    ET,
                    ET,
                    ON,
                    ON,
                    ON,
                    ON,
                    L,
                    ON,
                    ON,
                    BN,
                    ON,
                    ON,
                    ET,
                    ET,
                    EN,
                    EN,
                    ON,
                    L,
                    ON,
                    ON,
                    ON,
                    EN,
                    L,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON
                ];
                var UnicodeTBL20 = [
                    WS,
                    WS,
                    WS,
                    WS,
                    WS,
                    WS,
                    WS,
                    WS,
                    WS,
                    WS,
                    WS,
                    BN,
                    BN,
                    BN,
                    L,
                    R,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    WS,
                    B,
                    LRE,
                    RLE,
                    PDF,
                    LRO,
                    RLO,
                    CS,
                    ET,
                    ET,
                    ET,
                    ET,
                    ET,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    CS,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    ON,
                    WS
                ];
                /* Strong LTR character (0 - even), regular width */ exports1.L = L;
                /* Strong RTL character (1 - odd), Bidi width */ exports1.R = R;
                /* European digit (2 - even), regular width */ exports1.EN = EN;
                /* Neutral RTL-by-context character (3 - odd), regular width */ exports1.ON_R = 3;
                /* Hindi (Arabic) digit (4 - even), Bidi width */ exports1.AN = 4;
                /* Arabic LamAlef (5 - odd), Half Bidi width */ exports1.R_H = 5;
                /* invisible EOL (6 - even), zero width */ exports1.B = 6;
                /* invisible RLE (7 - odd), zero width */ exports1.RLE = 7;
                exports1.DOT = "\xb7";
                /**
 * Performs text reordering by implementing Unicode Bidi algorithm
 * with aim to produce logical<->visual map and Bidi levels
 * @param {String} text string to be reordered
 * @param {Array} unicode character types produced by call to 'hasBidiCharacters'
 * @param {Boolean} 'true' for right-to-left text direction, otherwise 'false'
 *
 * @return {Object} An object containing logicalFromVisual map and Bidi levels
 **/ exports1.doBidiReorder = function(text, textCharTypes, isRtl) {
                    if (text.length < 2) return {};
                    var chars = text.split(""), logicalFromVisual = new Array(chars.length), bidiLevels = new Array(chars.length), levels = [];
                    dir = isRtl ? RTL : LTR;
                    _computeLevels(chars, levels, chars.length, textCharTypes);
                    for(var i = 0; i < logicalFromVisual.length; logicalFromVisual[i] = i, i++);
                    _invertLevel(2, levels, logicalFromVisual);
                    _invertLevel(1, levels, logicalFromVisual);
                    for(var i = 0; i < logicalFromVisual.length - 1; i++){
                        if (textCharTypes[i] === AN) {
                            levels[i] = exports1.AN;
                        } else if (levels[i] === R && (textCharTypes[i] > AL && textCharTypes[i] < LRE || textCharTypes[i] === ON || textCharTypes[i] === BN)) {
                            levels[i] = exports1.ON_R;
                        } else if (i > 0 && chars[i - 1] === "ل" && /\u0622|\u0623|\u0625|\u0627/.test(chars[i])) {
                            levels[i - 1] = levels[i] = exports1.R_H;
                            i++;
                        }
                    }
                    /* fix level to mark zero length EOL */ if (chars[chars.length - 1] === exports1.DOT) levels[chars.length - 1] = exports1.B;
                    if (chars[0] === "‫") levels[0] = exports1.RLE;
                    for(var i = 0; i < logicalFromVisual.length; i++){
                        bidiLevels[i] = levels[logicalFromVisual[i]];
                    }
                    return {
                        "logicalFromVisual": logicalFromVisual,
                        "bidiLevels": bidiLevels
                    };
                };
                /**
 * Performs character classification, to be used in Unicode Bidi algorithm.
 * @param {String} text string to be reordered
 * @param {Array} unicode character types (to be filled by this method)
 *
 * @return {Boolean} 'true' if text contains Bidi characters, otherwise 'false' 
 **/ exports1.hasBidiCharacters = function(text, textCharTypes) {
                    var ret = false;
                    for(var i = 0; i < text.length; i++){
                        textCharTypes[i] = _getCharacterType(text.charAt(i));
                        if (!ret && (textCharTypes[i] == R || textCharTypes[i] == AL || textCharTypes[i] == AN)) ret = true;
                    }
                    return ret;
                };
                /**
 * Returns visual index corresponding to logical index basing on logicalFromvisual 
 * map provided by Unicode Bidi algorithm.
 * @param {Number} logIdx logical index of character in text buffer
 * @param {Object} rowMap object containing logicalFromVisual map
 *
 * @return {Number} visual index (on display) corresponding to logical index
 **/ exports1.getVisualFromLogicalIdx = function(logIdx, rowMap) {
                    for(var i = 0; i < rowMap.logicalFromVisual.length; i++){
                        if (rowMap.logicalFromVisual[i] == logIdx) return i;
                    }
                    return 0;
                };
            /***/ },
            /***/ 5336: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_779329__) {
                "use strict";
                var insertPendingStyles = function insertPendingStyles() {
                    var cache = cssCache;
                    cssCache = null;
                    cache && cache.forEach(function(item) {
                        importCssString(item[0], item[1]);
                    });
                };
                var importCssString = function importCssString(cssText, id, target) {
                    if (typeof document == "undefined") return;
                    if (cssCache) {
                        if (target) {
                            insertPendingStyles();
                        } else if (target === false) {
                            return cssCache.push([
                                cssText,
                                id
                            ]);
                        }
                    }
                    if (strictCSP) return;
                    var container = target;
                    if (!target || !target.getRootNode) {
                        container = document;
                    } else {
                        container = target.getRootNode();
                        if (!container || container == target) container = document;
                    }
                    var doc = container.ownerDocument || container;
                    // If style is already imported return immediately.
                    if (id && exports1.hasCssString(id, container)) return null;
                    if (id) cssText += "\n/*# sourceURL=ace/css/" + id + " */";
                    var style = exports1.createElement("style");
                    style.appendChild(doc.createTextNode(cssText));
                    if (id) style.id = id;
                    if (container == doc) container = exports1.getDocumentHead(doc);
                    container.insertBefore(style, container.firstChild);
                };
                var useragent = __nested_webpack_require_779329__(8057);
                var XHTML_NS = "http://www.w3.org/1999/xhtml";
                exports1.buildDom = function buildDom(arr, parent, refs) {
                    if (typeof arr == "string" && arr) {
                        var txt = document.createTextNode(arr);
                        if (parent) parent.appendChild(txt);
                        return txt;
                    }
                    if (!Array.isArray(arr)) {
                        if (arr && arr.appendChild && parent) parent.appendChild(arr);
                        return arr;
                    }
                    if (typeof arr[0] != "string" || !arr[0]) {
                        var els = [];
                        for(var i = 0; i < arr.length; i++){
                            var ch = buildDom(arr[i], parent, refs);
                            ch && els.push(ch);
                        }
                        return els;
                    }
                    var el = document.createElement(arr[0]);
                    var options = arr[1];
                    var childIndex = 1;
                    if (options && typeof options == "object" && !Array.isArray(options)) childIndex = 2;
                    for(var i = childIndex; i < arr.length; i++)buildDom(arr[i], el, refs);
                    if (childIndex == 2) {
                        Object.keys(options).forEach(function(n) {
                            var val = options[n];
                            if (n === "class") {
                                el.className = Array.isArray(val) ? val.join(" ") : val;
                            } else if (typeof val == "function" || n == "value" || n[0] == "$") {
                                el[n] = val;
                            } else if (n === "ref") {
                                if (refs) refs[val] = el;
                            } else if (n === "style") {
                                if (typeof val == "string") el.style.cssText = val;
                            } else if (val != null) {
                                el.setAttribute(n, val);
                            }
                        });
                    }
                    if (parent) parent.appendChild(el);
                    return el;
                };
                exports1.getDocumentHead = function(doc) {
                    if (!doc) doc = document;
                    return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
                };
                exports1.createElement = function(tag, ns) {
                    return document.createElementNS ? document.createElementNS(ns || XHTML_NS, tag) : document.createElement(tag);
                };
                exports1.removeChildren = function(element) {
                    element.innerHTML = "";
                };
                exports1.createTextNode = function(textContent, element) {
                    var doc = element ? element.ownerDocument : document;
                    return doc.createTextNode(textContent);
                };
                exports1.createFragment = function(element) {
                    var doc = element ? element.ownerDocument : document;
                    return doc.createDocumentFragment();
                };
                exports1.hasCssClass = function(el, name) {
                    var classes = (el.className + "").split(/\s+/g);
                    return classes.indexOf(name) !== -1;
                };
                /*
* Add a CSS class to the list of classes on the given node
*/ exports1.addCssClass = function(el, name) {
                    if (!exports1.hasCssClass(el, name)) {
                        el.className += " " + name;
                    }
                };
                /*
* Remove a CSS class from the list of classes on the given node
*/ exports1.removeCssClass = function(el, name) {
                    var classes = el.className.split(/\s+/g);
                    while(true){
                        var index = classes.indexOf(name);
                        if (index == -1) {
                            break;
                        }
                        classes.splice(index, 1);
                    }
                    el.className = classes.join(" ");
                };
                exports1.toggleCssClass = function(el, name) {
                    var classes = el.className.split(/\s+/g), add = true;
                    while(true){
                        var index = classes.indexOf(name);
                        if (index == -1) {
                            break;
                        }
                        add = false;
                        classes.splice(index, 1);
                    }
                    if (add) classes.push(name);
                    el.className = classes.join(" ");
                    return add;
                };
                /*
    * Add or remove a CSS class from the list of classes on the given node
    * depending on the value of <tt>include</tt>
    */ exports1.setCssClass = function(node, className, include) {
                    if (include) {
                        exports1.addCssClass(node, className);
                    } else {
                        exports1.removeCssClass(node, className);
                    }
                };
                exports1.hasCssString = function(id, doc) {
                    var index = 0, sheets;
                    doc = doc || document;
                    if (sheets = doc.querySelectorAll("style")) {
                        while(index < sheets.length){
                            if (sheets[index++].id === id) {
                                return true;
                            }
                        }
                    }
                };
                exports1.removeElementById = function(id, doc) {
                    doc = doc || document;
                    if (doc.getElementById(id)) {
                        doc.getElementById(id).remove();
                    }
                };
                var strictCSP;
                var cssCache = [];
                exports1.useStrictCSP = function(value) {
                    strictCSP = value;
                    if (value == false) insertPendingStyles();
                    else if (!cssCache) cssCache = [];
                };
                exports1.importCssString = importCssString;
                exports1.importCssStylsheet = function(uri, doc) {
                    exports1.buildDom([
                        "link",
                        {
                            rel: "stylesheet",
                            href: uri
                        }
                    ], exports1.getDocumentHead(doc));
                };
                exports1.scrollbarWidth = function(doc) {
                    var inner = exports1.createElement("ace_inner");
                    inner.style.width = "100%";
                    inner.style.minWidth = "0px";
                    inner.style.height = "200px";
                    inner.style.display = "block";
                    var outer = exports1.createElement("ace_outer");
                    var style = outer.style;
                    style.position = "absolute";
                    style.left = "-10000px";
                    style.overflow = "hidden";
                    style.width = "200px";
                    style.minWidth = "0px";
                    style.height = "150px";
                    style.display = "block";
                    outer.appendChild(inner);
                    var body = doc && doc.documentElement || document && document.documentElement;
                    if (!body) return 0;
                    body.appendChild(outer);
                    var noScrollbar = inner.offsetWidth;
                    style.overflow = "scroll";
                    var withScrollbar = inner.offsetWidth;
                    if (noScrollbar === withScrollbar) {
                        withScrollbar = outer.clientWidth;
                    }
                    body.removeChild(outer);
                    return noScrollbar - withScrollbar;
                };
                exports1.computedStyle = function(element, style) {
                    return window.getComputedStyle(element, "") || {};
                };
                exports1.setStyle = function(styles, property, value) {
                    if (styles[property] !== value) {
                        //console.log("set style", property, styles[property], value);
                        styles[property] = value;
                    }
                };
                exports1.HAS_CSS_ANIMATION = false;
                exports1.HAS_CSS_TRANSFORMS = false;
                exports1.HI_DPI = useragent.isWin ? typeof window !== "undefined" && window.devicePixelRatio >= 1.5 : true;
                if (useragent.isChromeOS) exports1.HI_DPI = false;
                if (typeof document !== "undefined") {
                    // detect CSS transformation support
                    var div = document.createElement("div");
                    if (exports1.HI_DPI && div.style.transform !== undefined) exports1.HAS_CSS_TRANSFORMS = true;
                    if (!useragent.isEdge && typeof div.style.animationName !== "undefined") exports1.HAS_CSS_ANIMATION = true;
                    div = null;
                }
                if (exports1.HAS_CSS_TRANSFORMS) {
                    exports1.translate = function(element, tx, ty) {
                        element.style.transform = "translate(" + Math.round(tx) + "px, " + Math.round(ty) + "px)";
                    };
                } else {
                    exports1.translate = function(element, tx, ty) {
                        element.style.top = Math.round(ty) + "px";
                        element.style.left = Math.round(tx) + "px";
                    };
                }
            /***/ },
            /***/ 8215: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_791345__) {
                "use strict";
                var detectListenerOptionsSupport = function detectListenerOptionsSupport() {
                    activeListenerOptions = false;
                    try {
                        document.createComment("").addEventListener("test", function() {}, {
                            get passive () {
                                activeListenerOptions = {
                                    passive: false
                                };
                            }
                        });
                    } catch (e) {}
                };
                var getListenerOptions = function getListenerOptions() {
                    if (activeListenerOptions == undefined) detectListenerOptionsSupport();
                    return activeListenerOptions;
                };
                var EventListener = function EventListener(elem, type, callback) {
                    this.elem = elem;
                    this.type = type;
                    this.callback = callback;
                };
                var normalizeCommandKeys = function normalizeCommandKeys(callback, e, keyCode) {
                    var hashId = getModifierHash(e);
                    if (!useragent.isMac && pressedKeys) {
                        if (e.getModifierState && (e.getModifierState("OS") || e.getModifierState("Win"))) hashId |= 8;
                        if (pressedKeys.altGr) {
                            if ((3 & hashId) != 3) pressedKeys.altGr = 0;
                            else return;
                        }
                        if (keyCode === 18 || keyCode === 17) {
                            var location = "location" in e ? e.location : e.keyLocation;
                            if (keyCode === 17 && location === 1) {
                                if (pressedKeys[keyCode] == 1) ts = e.timeStamp;
                            } else if (keyCode === 18 && hashId === 3 && location === 2) {
                                var dt = e.timeStamp - ts;
                                if (dt < 50) pressedKeys.altGr = true;
                            }
                        }
                    }
                    if (keyCode in keys.MODIFIER_KEYS) {
                        keyCode = -1;
                    }
                    if (!hashId && keyCode === 13) {
                        var location = "location" in e ? e.location : e.keyLocation;
                        if (location === 3) {
                            callback(e, hashId, -keyCode);
                            if (e.defaultPrevented) return;
                        }
                    }
                    if (useragent.isChromeOS && hashId & 8) {
                        callback(e, hashId, keyCode);
                        if (e.defaultPrevented) return;
                        else hashId &= ~8;
                    }
                    // If there is no hashId and the keyCode is not a function key, then
                    // we don't call the callback as we don't handle a command key here
                    // (it's a normal key/character input).
                    if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
                        return false;
                    }
                    return callback(e, hashId, keyCode);
                };
                var resetPressedKeys = function resetPressedKeys() {
                    pressedKeys = Object.create(null);
                };
                var keys = __nested_webpack_require_791345__(1492);
                var useragent = __nested_webpack_require_791345__(8057);
                var pressedKeys = null;
                var ts = 0;
                var activeListenerOptions;
                EventListener.prototype.destroy = function() {
                    removeListener(this.elem, this.type, this.callback);
                    this.elem = this.type = this.callback = undefined;
                };
                var addListener = exports1.addListener = function addListener(elem, type, callback, destroyer) {
                    elem.addEventListener(type, callback, getListenerOptions());
                    if (destroyer) destroyer.$toDestroy.push(new EventListener(elem, type, callback));
                };
                var removeListener = exports1.removeListener = function removeListener(elem, type, callback) {
                    elem.removeEventListener(type, callback, getListenerOptions());
                };
                /*
* Prevents propagation and clobbers the default action of the passed event
*/ exports1.stopEvent = function(e) {
                    exports1.stopPropagation(e);
                    exports1.preventDefault(e);
                    return false;
                };
                exports1.stopPropagation = function(e) {
                    if (e.stopPropagation) e.stopPropagation();
                };
                exports1.preventDefault = function(e) {
                    if (e.preventDefault) e.preventDefault();
                };
                /*
 * @return {Number} 0 for left button, 1 for middle button, 2 for right button
 */ exports1.getButton = function(e) {
                    if (e.type == "dblclick") return 0;
                    if (e.type == "contextmenu" || useragent.isMac && e.ctrlKey && !e.altKey && !e.shiftKey) return 2;
                    // DOM Event
                    return e.button;
                };
                exports1.capture = function(el, eventHandler, releaseCaptureHandler) {
                    var ownerDocument = el && el.ownerDocument || document;
                    function onMouseUp(e) {
                        eventHandler && eventHandler(e);
                        releaseCaptureHandler && releaseCaptureHandler(e);
                        removeListener(ownerDocument, "mousemove", eventHandler);
                        removeListener(ownerDocument, "mouseup", onMouseUp);
                        removeListener(ownerDocument, "dragstart", onMouseUp);
                    }
                    addListener(ownerDocument, "mousemove", eventHandler);
                    addListener(ownerDocument, "mouseup", onMouseUp);
                    addListener(ownerDocument, "dragstart", onMouseUp);
                    return onMouseUp;
                };
                exports1.addMouseWheelListener = function(el, callback, destroyer) {
                    addListener(el, "wheel", function(e) {
                        var factor = 0.15;
                        // workaround for firefox changing deltaMode based on which property is accessed first
                        var deltaX = e.deltaX || 0;
                        var deltaY = e.deltaY || 0;
                        switch(e.deltaMode){
                            case e.DOM_DELTA_PIXEL:
                                e.wheelX = deltaX * factor;
                                e.wheelY = deltaY * factor;
                                break;
                            case e.DOM_DELTA_LINE:
                                var linePixels = 15;
                                e.wheelX = deltaX * linePixels;
                                e.wheelY = deltaY * linePixels;
                                break;
                            case e.DOM_DELTA_PAGE:
                                var pagePixels = 150;
                                e.wheelX = deltaX * pagePixels;
                                e.wheelY = deltaY * pagePixels;
                                break;
                        }
                        callback(e);
                    }, destroyer);
                };
                exports1.addMultiMouseDownListener = function(elements, timeouts, eventHandler, callbackName, destroyer) {
                    var onMousedown = function onMousedown(e) {
                        if (exports1.getButton(e) !== 0) {
                            clicks = 0;
                        } else if (e.detail > 1) {
                            clicks++;
                            if (clicks > 4) clicks = 1;
                        } else {
                            clicks = 1;
                        }
                        if (useragent.isIE) {
                            var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
                            if (!timer || isNewClick) clicks = 1;
                            if (timer) clearTimeout(timer);
                            timer = setTimeout(function() {
                                timer = null;
                            }, timeouts[clicks - 1] || 600);
                            if (clicks == 1) {
                                startX = e.clientX;
                                startY = e.clientY;
                            }
                        }
                        e._clicks = clicks;
                        eventHandler[callbackName]("mousedown", e);
                        if (clicks > 4) clicks = 0;
                        else if (clicks > 1) return eventHandler[callbackName](eventNames[clicks], e);
                    };
                    var clicks = 0;
                    var startX, startY, timer;
                    var eventNames = {
                        2: "dblclick",
                        3: "tripleclick",
                        4: "quadclick"
                    };
                    if (!Array.isArray(elements)) elements = [
                        elements
                    ];
                    elements.forEach(function(el) {
                        addListener(el, "mousedown", onMousedown, destroyer);
                    });
                };
                var getModifierHash = function getModifierHash(e) {
                    return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
                };
                exports1.getModifierString = function(e) {
                    return keys.KEY_MODS[getModifierHash(e)];
                };
                exports1.addCommandKeyListener = function(el, callback, destroyer) {
                    if (useragent.isOldGecko || useragent.isOpera && !("KeyboardEvent" in window)) {
                        // Old versions of Gecko aka. Firefox < 4.0 didn't repeat the keydown
                        // event if the user pressed the key for a longer time. Instead, the
                        // keydown event was fired once and later on only the keypress event.
                        // To emulate the 'right' keydown behavior, the keyCode of the initial
                        // keyDown event is stored and in the following keypress events the
                        // stores keyCode is used to emulate a keyDown event.
                        var lastKeyDownKeyCode = null;
                        addListener(el, "keydown", function(e) {
                            lastKeyDownKeyCode = e.keyCode;
                        }, destroyer);
                        addListener(el, "keypress", function(e) {
                            return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
                        }, destroyer);
                    } else {
                        var lastDefaultPrevented = null;
                        addListener(el, "keydown", function(e) {
                            pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;
                            var result = normalizeCommandKeys(callback, e, e.keyCode);
                            lastDefaultPrevented = e.defaultPrevented;
                            return result;
                        }, destroyer);
                        addListener(el, "keypress", function(e) {
                            if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
                                exports1.stopEvent(e);
                                lastDefaultPrevented = null;
                            }
                        }, destroyer);
                        addListener(el, "keyup", function(e) {
                            pressedKeys[e.keyCode] = null;
                        }, destroyer);
                        if (!pressedKeys) {
                            resetPressedKeys();
                            addListener(window, "focus", resetPressedKeys);
                        }
                    }
                };
                if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
                    var postMessageId = 1;
                    exports1.nextTick = function(callback, win) {
                        win = win || window;
                        var messageName = "zero-timeout-message-" + postMessageId++;
                        var listener = function listener1(e) {
                            if (e.data == messageName) {
                                exports1.stopPropagation(e);
                                removeListener(win, "message", listener);
                                callback();
                            }
                        };
                        addListener(win, "message", listener);
                        win.postMessage(messageName, "*");
                    };
                }
                exports1.$idleBlocked = false;
                exports1.onIdle = function(cb, timeout) {
                    return setTimeout(function handler() {
                        if (!exports1.$idleBlocked) {
                            cb();
                        } else {
                            setTimeout(handler, 100);
                        }
                    }, timeout);
                };
                exports1.$idleBlockId = null;
                exports1.blockIdle = function(delay) {
                    if (exports1.$idleBlockId) clearTimeout(exports1.$idleBlockId);
                    exports1.$idleBlocked = true;
                    exports1.$idleBlockId = setTimeout(function() {
                        exports1.$idleBlocked = false;
                    }, delay || 100);
                };
                exports1.nextFrame = typeof window == "object" && (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame);
                if (exports1.nextFrame) exports1.nextFrame = exports1.nextFrame.bind(window);
                else exports1.nextFrame = function(callback) {
                    setTimeout(callback, 17);
                };
            /***/ },
            /***/ 7858: /***/ function(__unused_webpack_module, exports1) {
                "use strict";
                var EventEmitter = {};
                var stopPropagation = function stopPropagation() {
                    this.propagationStopped = true;
                };
                var preventDefault = function preventDefault() {
                    this.defaultPrevented = true;
                };
                EventEmitter._emit = EventEmitter._dispatchEvent = function(eventName, e) {
                    this._eventRegistry || (this._eventRegistry = {});
                    this._defaultHandlers || (this._defaultHandlers = {});
                    var listeners = this._eventRegistry[eventName] || [];
                    var defaultHandler = this._defaultHandlers[eventName];
                    if (!listeners.length && !defaultHandler) return;
                    if (typeof e != "object" || !e) e = {};
                    if (!e.type) e.type = eventName;
                    if (!e.stopPropagation) e.stopPropagation = stopPropagation;
                    if (!e.preventDefault) e.preventDefault = preventDefault;
                    listeners = listeners.slice();
                    for(var i = 0; i < listeners.length; i++){
                        listeners[i](e, this);
                        if (e.propagationStopped) break;
                    }
                    if (defaultHandler && !e.defaultPrevented) return defaultHandler(e, this);
                };
                EventEmitter._signal = function(eventName, e) {
                    var listeners = (this._eventRegistry || {})[eventName];
                    if (!listeners) return;
                    listeners = listeners.slice();
                    for(var i = 0; i < listeners.length; i++)listeners[i](e, this);
                };
                EventEmitter.once = function(eventName, callback) {
                    var _self = this;
                    this.on(eventName, function newCallback() {
                        _self.off(eventName, newCallback);
                        callback.apply(null, arguments);
                    });
                    if (!callback) {
                        /*global Promise*/ return new Promise(function(resolve) {
                            callback = resolve;
                        });
                    }
                };
                EventEmitter.setDefaultHandler = function(eventName, callback) {
                    var handlers = this._defaultHandlers;
                    if (!handlers) handlers = this._defaultHandlers = {
                        _disabled_: {}
                    };
                    if (handlers[eventName]) {
                        var old = handlers[eventName];
                        var disabled = handlers._disabled_[eventName];
                        if (!disabled) handlers._disabled_[eventName] = disabled = [];
                        disabled.push(old);
                        var i = disabled.indexOf(callback);
                        if (i != -1) disabled.splice(i, 1);
                    }
                    handlers[eventName] = callback;
                };
                EventEmitter.removeDefaultHandler = function(eventName, callback) {
                    var handlers = this._defaultHandlers;
                    if (!handlers) return;
                    var disabled = handlers._disabled_[eventName];
                    if (handlers[eventName] == callback) {
                        if (disabled) this.setDefaultHandler(eventName, disabled.pop());
                    } else if (disabled) {
                        var i = disabled.indexOf(callback);
                        if (i != -1) disabled.splice(i, 1);
                    }
                };
                EventEmitter.on = EventEmitter.addEventListener = function(eventName, callback, capturing) {
                    this._eventRegistry = this._eventRegistry || {};
                    var listeners = this._eventRegistry[eventName];
                    if (!listeners) listeners = this._eventRegistry[eventName] = [];
                    if (listeners.indexOf(callback) == -1) listeners[capturing ? "unshift" : "push"](callback);
                    return callback;
                };
                EventEmitter.off = EventEmitter.removeListener = EventEmitter.removeEventListener = function(eventName, callback) {
                    this._eventRegistry = this._eventRegistry || {};
                    var listeners = this._eventRegistry[eventName];
                    if (!listeners) return;
                    var index = listeners.indexOf(callback);
                    if (index !== -1) listeners.splice(index, 1);
                };
                EventEmitter.removeAllListeners = function(eventName) {
                    if (!eventName) this._eventRegistry = this._defaultHandlers = undefined;
                    if (this._eventRegistry) this._eventRegistry[eventName] = undefined;
                    if (this._defaultHandlers) this._defaultHandlers[eventName] = undefined;
                };
                exports1.v = EventEmitter;
            /***/ },
            /***/ 1492: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_811169__) {
                "use strict";
                /*! @license
==========================================================================
SproutCore -- JavaScript Application Framework
copyright 2006-2009, Sprout Systems Inc., Apple Inc. and contributors.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

SproutCore and the SproutCore logo are trademarks of Sprout Systems, Inc.

For more information about SproutCore, visit http://www.sproutcore.com


==========================================================================
@license */ // Most of the following code is taken from SproutCore with a few changes.
                var oop = __nested_webpack_require_811169__(2011);
                /*
 * Helper functions and hashes for key handling.
 */ var Keys = function() {
                    var ret = {
                        MODIFIER_KEYS: {
                            16: "Shift",
                            17: "Ctrl",
                            18: "Alt",
                            224: "Meta",
                            91: "MetaLeft",
                            92: "MetaRight",
                            93: "ContextMenu"
                        },
                        KEY_MODS: {
                            "ctrl": 1,
                            "alt": 2,
                            "option": 2,
                            "shift": 4,
                            "super": 8,
                            "meta": 8,
                            "command": 8,
                            "cmd": 8,
                            "control": 1
                        },
                        FUNCTION_KEYS: {
                            8: "Backspace",
                            9: "Tab",
                            13: "Return",
                            19: "Pause",
                            27: "Esc",
                            32: "Space",
                            33: "PageUp",
                            34: "PageDown",
                            35: "End",
                            36: "Home",
                            37: "Left",
                            38: "Up",
                            39: "Right",
                            40: "Down",
                            44: "Print",
                            45: "Insert",
                            46: "Delete",
                            96: "Numpad0",
                            97: "Numpad1",
                            98: "Numpad2",
                            99: "Numpad3",
                            100: "Numpad4",
                            101: "Numpad5",
                            102: "Numpad6",
                            103: "Numpad7",
                            104: "Numpad8",
                            105: "Numpad9",
                            "-13": "NumpadEnter",
                            112: "F1",
                            113: "F2",
                            114: "F3",
                            115: "F4",
                            116: "F5",
                            117: "F6",
                            118: "F7",
                            119: "F8",
                            120: "F9",
                            121: "F10",
                            122: "F11",
                            123: "F12",
                            144: "Numlock",
                            145: "Scrolllock"
                        },
                        PRINTABLE_KEYS: {
                            32: " ",
                            48: "0",
                            49: "1",
                            50: "2",
                            51: "3",
                            52: "4",
                            53: "5",
                            54: "6",
                            55: "7",
                            56: "8",
                            57: "9",
                            59: ";",
                            61: "=",
                            65: "a",
                            66: "b",
                            67: "c",
                            68: "d",
                            69: "e",
                            70: "f",
                            71: "g",
                            72: "h",
                            73: "i",
                            74: "j",
                            75: "k",
                            76: "l",
                            77: "m",
                            78: "n",
                            79: "o",
                            80: "p",
                            81: "q",
                            82: "r",
                            83: "s",
                            84: "t",
                            85: "u",
                            86: "v",
                            87: "w",
                            88: "x",
                            89: "y",
                            90: "z",
                            107: "+",
                            109: "-",
                            110: ".",
                            186: ";",
                            187: "=",
                            188: ",",
                            189: "-",
                            190: ".",
                            191: "/",
                            192: "`",
                            219: "[",
                            220: "\\",
                            221: "]",
                            222: "'",
                            111: "/",
                            106: "*"
                        }
                    };
                    // workaround for firefox bug
                    ret.PRINTABLE_KEYS[173] = "-";
                    // A reverse map of FUNCTION_KEYS
                    var name, i;
                    for(i in ret.FUNCTION_KEYS){
                        name = ret.FUNCTION_KEYS[i].toLowerCase();
                        ret[name] = parseInt(i, 10);
                    }
                    // A reverse map of PRINTABLE_KEYS
                    for(i in ret.PRINTABLE_KEYS){
                        name = ret.PRINTABLE_KEYS[i].toLowerCase();
                        ret[name] = parseInt(i, 10);
                    }
                    // Add the MODIFIER_KEYS, FUNCTION_KEYS and PRINTABLE_KEYS to the KEY
                    // variables as well.
                    oop.mixin(ret, ret.MODIFIER_KEYS);
                    oop.mixin(ret, ret.PRINTABLE_KEYS);
                    oop.mixin(ret, ret.FUNCTION_KEYS);
                    // aliases
                    ret.enter = ret["return"];
                    ret.escape = ret.esc;
                    ret.del = ret["delete"];
                    (function() {
                        var mods = [
                            "cmd",
                            "ctrl",
                            "alt",
                            "shift"
                        ];
                        for(var i = Math.pow(2, mods.length); i--;){
                            ret.KEY_MODS[i] = mods.filter(function(x) {
                                return i & ret.KEY_MODS[x];
                            }).join("-") + "-";
                        }
                    })();
                    ret.KEY_MODS[0] = "";
                    ret.KEY_MODS[-1] = "input-";
                    return ret;
                }();
                oop.mixin(exports1, Keys);
                exports1.keyCodeToString = function(keyCode) {
                    // Language-switching keystroke in Chrome/Linux emits keyCode 0.
                    var keyString = Keys[keyCode];
                    if (typeof keyString != "string") keyString = String.fromCharCode(keyCode);
                    return keyString.toLowerCase();
                };
            /***/ },
            /***/ 732: /***/ function(__unused_webpack_module, exports1) {
                "use strict";
                exports1.last = function(a) {
                    return a[a.length - 1];
                };
                exports1.stringReverse = function(string) {
                    return string.split("").reverse().join("");
                };
                exports1.stringRepeat = function(string, count) {
                    var result = "";
                    while(count > 0){
                        if (count & 1) result += string;
                        if (count >>= 1) string += string;
                    }
                    return result;
                };
                var trimBeginRegexp = /^\s\s*/;
                var trimEndRegexp = /\s\s*$/;
                exports1.stringTrimLeft = function(string) {
                    return string.replace(trimBeginRegexp, "");
                };
                exports1.stringTrimRight = function(string) {
                    return string.replace(trimEndRegexp, "");
                };
                exports1.copyObject = function(obj) {
                    var copy = {};
                    for(var key in obj){
                        copy[key] = obj[key];
                    }
                    return copy;
                };
                exports1.copyArray = function(array) {
                    var copy = [];
                    for(var i = 0, l = array.length; i < l; i++){
                        if (array[i] && typeof array[i] == "object") copy[i] = this.copyObject(array[i]);
                        else copy[i] = array[i];
                    }
                    return copy;
                };
                exports1.deepCopy = function deepCopy(obj) {
                    if (typeof obj !== "object" || !obj) return obj;
                    var copy;
                    if (Array.isArray(obj)) {
                        copy = [];
                        for(var key = 0; key < obj.length; key++){
                            copy[key] = deepCopy(obj[key]);
                        }
                        return copy;
                    }
                    if (Object.prototype.toString.call(obj) !== "[object Object]") return obj;
                    copy = {};
                    for(var key in obj)copy[key] = deepCopy(obj[key]);
                    return copy;
                };
                exports1.arrayToMap = function(arr) {
                    var map = {};
                    for(var i = 0; i < arr.length; i++){
                        map[arr[i]] = 1;
                    }
                    return map;
                };
                exports1.createMap = function(props) {
                    var map = Object.create(null);
                    for(var i in props){
                        map[i] = props[i];
                    }
                    return map;
                };
                /*
 * splice out of 'array' anything that === 'value'
 */ exports1.arrayRemove = function(array, value) {
                    for(var i = 0; i <= array.length; i++){
                        if (value === array[i]) {
                            array.splice(i, 1);
                        }
                    }
                };
                exports1.escapeRegExp = function(str) {
                    return str.replace(/([.*+?^${}()|[\]\/\\])/g, "\\$1");
                };
                exports1.escapeHTML = function(str) {
                    return ("" + str).replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
                };
                exports1.getMatchOffsets = function(string, regExp) {
                    var matches = [];
                    string.replace(regExp, function(str) {
                        matches.push({
                            offset: arguments[arguments.length - 2],
                            length: str.length
                        });
                    });
                    return matches;
                };
                /* deprecated */ exports1.deferredCall = function(fcn) {
                    var timer = null;
                    var callback = function callback() {
                        timer = null;
                        fcn();
                    };
                    var deferred = function deferred1(timeout) {
                        deferred.cancel();
                        timer = setTimeout(callback, timeout || 0);
                        return deferred;
                    };
                    deferred.schedule = deferred;
                    deferred.call = function() {
                        this.cancel();
                        fcn();
                        return deferred;
                    };
                    deferred.cancel = function() {
                        clearTimeout(timer);
                        timer = null;
                        return deferred;
                    };
                    deferred.isPending = function() {
                        return timer;
                    };
                    return deferred;
                };
                exports1.delayedCall = function(fcn, defaultTimeout) {
                    var timer = null;
                    var callback = function callback() {
                        timer = null;
                        fcn();
                    };
                    var _self = function _self(timeout) {
                        if (timer == null) timer = setTimeout(callback, timeout || defaultTimeout);
                    };
                    _self.delay = function(timeout) {
                        timer && clearTimeout(timer);
                        timer = setTimeout(callback, timeout || defaultTimeout);
                    };
                    _self.schedule = _self;
                    _self.call = function() {
                        this.cancel();
                        fcn();
                    };
                    _self.cancel = function() {
                        timer && clearTimeout(timer);
                        timer = null;
                    };
                    _self.isPending = function() {
                        return timer;
                    };
                    return _self;
                };
            /***/ },
            /***/ 8999: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_826320__) {
                "use strict";
                /*
 * based on code from:
 *
 * @license RequireJS text 0.25.0 Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/requirejs for details
 */ var dom = __nested_webpack_require_826320__(5336);
                exports1.get = function(url, callback) {
                    var xhr = new XMLHttpRequest();
                    xhr.open("GET", url, true);
                    xhr.onreadystatechange = function() {
                        //Do not explicitly handle errors, those should be
                        //visible via console output in the browser.
                        if (xhr.readyState === 4) {
                            callback(xhr.responseText);
                        }
                    };
                    xhr.send(null);
                };
                exports1.loadScript = function(path, callback) {
                    var head = dom.getDocumentHead();
                    var s = document.createElement("script");
                    s.src = path;
                    head.appendChild(s);
                    s.onload = s.onreadystatechange = function(_, isAbort) {
                        if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
                            s = s.onload = s.onreadystatechange = null;
                            if (!isAbort) callback();
                        }
                    };
                };
                /*
 * Convert a url into a fully qualified absolute URL
 * This function does not work in IE6
 */ exports1.qualifyURL = function(url) {
                    var a = document.createElement("a");
                    a.href = url;
                    return a.href;
                };
            /***/ },
            /***/ 2011: /***/ function(__unused_webpack_module, exports1) {
                "use strict";
                exports1.inherits = function(ctor, superCtor) {
                    ctor.super_ = superCtor;
                    ctor.prototype = Object.create(superCtor.prototype, {
                        constructor: {
                            value: ctor,
                            enumerable: false,
                            writable: true,
                            configurable: true
                        }
                    });
                };
                exports1.mixin = function(obj, mixin) {
                    for(var key in mixin){
                        obj[key] = mixin[key];
                    }
                    return obj;
                };
                exports1.implement = function(proto, mixin) {
                    exports1.mixin(proto, mixin);
                };
            /***/ },
            /***/ 8057: /***/ function(__unused_webpack_module, exports1) {
                "use strict";
                /*
 * I hate doing this, but we need some way to determine if the user is on a Mac
 * The reason is that users have different expectations of their key combinations.
 *
 * Take copy as an example, Mac people expect to use CMD or APPLE + C
 * Windows folks expect to use CTRL + C
 */ exports1.OS = {
                    LINUX: "LINUX",
                    MAC: "MAC",
                    WINDOWS: "WINDOWS"
                };
                /*
 * Return an exports.OS constant
 */ exports1.getOS = function() {
                    if (exports1.isMac) {
                        return exports1.OS.MAC;
                    } else if (exports1.isLinux) {
                        return exports1.OS.LINUX;
                    } else {
                        return exports1.OS.WINDOWS;
                    }
                };
                // this can be called in non browser environments (e.g. from ace/requirejs/text)
                var _navigator = typeof navigator == "object" ? navigator : {};
                var os = (/mac|win|linux/i.exec(_navigator.platform) || [
                    "other"
                ])[0].toLowerCase();
                var ua = _navigator.userAgent || "";
                var appName = _navigator.appName || "";
                // Is the user using a browser that identifies itself as Windows
                exports1.isWin = os == "win";
                // Is the user using a browser that identifies itself as Mac OS
                exports1.isMac = os == "mac";
                // Is the user using a browser that identifies itself as Linux
                exports1.isLinux = os == "linux";
                // Windows Store JavaScript apps (aka Metro apps written in HTML5 and JavaScript) do not use the "Microsoft Internet Explorer" string in their user agent, but "MSAppHost" instead.
                exports1.isIE = appName == "Microsoft Internet Explorer" || appName.indexOf("MSAppHost") >= 0 ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]) : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]); // for ie
                exports1.isOldIE = exports1.isIE && exports1.isIE < 9;
                // Is this Firefox or related?
                exports1.isGecko = exports1.isMozilla = ua.match(/ Gecko\/\d+/);
                // Is this Opera 
                exports1.isOpera = typeof opera == "object" && Object.prototype.toString.call(window.opera) == "[object Opera]";
                // Is the user using a browser that identifies itself as WebKit 
                exports1.isWebKit = parseFloat(ua.split("WebKit/")[1]) || undefined;
                exports1.isChrome = parseFloat(ua.split(" Chrome/")[1]) || undefined;
                exports1.isEdge = parseFloat(ua.split(" Edge/")[1]) || undefined;
                exports1.isAIR = ua.indexOf("AdobeAIR") >= 0;
                exports1.isAndroid = ua.indexOf("Android") >= 0;
                exports1.isChromeOS = ua.indexOf(" CrOS ") >= 0;
                exports1.isIOS = /iPad|iPhone|iPod/.test(ua) && !window.MSStream;
                if (exports1.isIOS) exports1.isMac = true;
                exports1.isMobile = exports1.isIOS || exports1.isAndroid;
            /***/ },
            /***/ 1252: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_832585__) {
                "use strict";
                var dom = __nested_webpack_require_832585__(5336);
                var LineWidgets = /*#__PURE__*/ function() {
                    function LineWidgets(session) {
                        _class_call_check(this, LineWidgets);
                        this.session = session;
                        this.session.widgetManager = this;
                        this.session.getRowLength = this.getRowLength;
                        this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
                        this.updateOnChange = this.updateOnChange.bind(this);
                        this.renderWidgets = this.renderWidgets.bind(this);
                        this.measureWidgets = this.measureWidgets.bind(this);
                        this.session._changedWidgets = [];
                        this.$onChangeEditor = this.$onChangeEditor.bind(this);
                        this.session.on("change", this.updateOnChange);
                        this.session.on("changeFold", this.updateOnFold);
                        this.session.on("changeEditor", this.$onChangeEditor);
                    }
                    _create_class(LineWidgets, [
                        {
                            key: "getRowLength",
                            value: function getRowLength(row) {
                                var h;
                                if (this.lineWidgets) h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
                                else h = 0;
                                if (!this.$useWrapMode || !this.$wrapData[row]) {
                                    return 1 + h;
                                } else {
                                    return this.$wrapData[row].length + 1 + h;
                                }
                            }
                        },
                        {
                            key: "$getWidgetScreenLength",
                            value: function $getWidgetScreenLength() {
                                var screenRows = 0;
                                this.lineWidgets.forEach(function(w) {
                                    if (w && w.rowCount && !w.hidden) screenRows += w.rowCount;
                                });
                                return screenRows;
                            }
                        },
                        {
                            key: "$onChangeEditor",
                            value: function $onChangeEditor(e) {
                                this.attach(e.editor);
                            }
                        },
                        {
                            key: "attach",
                            value: function attach(editor) {
                                if (editor && editor.widgetManager && editor.widgetManager != this) editor.widgetManager.detach();
                                if (this.editor == editor) return;
                                this.detach();
                                this.editor = editor;
                                if (editor) {
                                    editor.widgetManager = this;
                                    editor.renderer.on("beforeRender", this.measureWidgets);
                                    editor.renderer.on("afterRender", this.renderWidgets);
                                }
                            }
                        },
                        {
                            key: "detach",
                            value: function detach(e) {
                                var editor = this.editor;
                                if (!editor) return;
                                this.editor = null;
                                editor.widgetManager = null;
                                editor.renderer.off("beforeRender", this.measureWidgets);
                                editor.renderer.off("afterRender", this.renderWidgets);
                                var lineWidgets = this.session.lineWidgets;
                                lineWidgets && lineWidgets.forEach(function(w) {
                                    if (w && w.el && w.el.parentNode) {
                                        w._inDocument = false;
                                        w.el.parentNode.removeChild(w.el);
                                    }
                                });
                            }
                        },
                        {
                            key: "updateOnFold",
                            value: function updateOnFold(e, session) {
                                var lineWidgets = session.lineWidgets;
                                if (!lineWidgets || !e.action) return;
                                var fold = e.data;
                                var start = fold.start.row;
                                var end = fold.end.row;
                                var hide = e.action == "add";
                                for(var i = start + 1; i < end; i++){
                                    if (lineWidgets[i]) lineWidgets[i].hidden = hide;
                                }
                                if (lineWidgets[end]) {
                                    if (hide) {
                                        if (!lineWidgets[start]) lineWidgets[start] = lineWidgets[end];
                                        else lineWidgets[end].hidden = hide;
                                    } else {
                                        if (lineWidgets[start] == lineWidgets[end]) lineWidgets[start] = undefined;
                                        lineWidgets[end].hidden = hide;
                                    }
                                }
                            }
                        },
                        {
                            key: "updateOnChange",
                            value: function updateOnChange(delta) {
                                var lineWidgets = this.session.lineWidgets;
                                if (!lineWidgets) return;
                                var startRow = delta.start.row;
                                var len = delta.end.row - startRow;
                                if (len === 0) {
                                // return
                                } else if (delta.action == "remove") {
                                    var removed = lineWidgets.splice(startRow + 1, len);
                                    if (!lineWidgets[startRow] && removed[removed.length - 1]) {
                                        lineWidgets[startRow] = removed.pop();
                                    }
                                    removed.forEach(function(w) {
                                        w && this.removeLineWidget(w);
                                    }, this);
                                    this.$updateRows();
                                } else {
                                    var args = new Array(len);
                                    if (lineWidgets[startRow] && lineWidgets[startRow].column != null) {
                                        if (delta.start.column > lineWidgets[startRow].column) startRow++;
                                    }
                                    args.unshift(startRow, 0);
                                    lineWidgets.splice.apply(lineWidgets, args);
                                    this.$updateRows();
                                }
                            }
                        },
                        {
                            key: "$updateRows",
                            value: function $updateRows() {
                                var lineWidgets = this.session.lineWidgets;
                                if (!lineWidgets) return;
                                var noWidgets = true;
                                lineWidgets.forEach(function(w, i) {
                                    if (w) {
                                        noWidgets = false;
                                        w.row = i;
                                        while(w.$oldWidget){
                                            w.$oldWidget.row = i;
                                            w = w.$oldWidget;
                                        }
                                    }
                                });
                                if (noWidgets) this.session.lineWidgets = null;
                            }
                        },
                        {
                            key: "$registerLineWidget",
                            value: function $registerLineWidget(w) {
                                if (!this.session.lineWidgets) this.session.lineWidgets = new Array(this.session.getLength());
                                var old = this.session.lineWidgets[w.row];
                                if (old) {
                                    w.$oldWidget = old;
                                    if (old.el && old.el.parentNode) {
                                        old.el.parentNode.removeChild(old.el);
                                        old._inDocument = false;
                                    }
                                }
                                this.session.lineWidgets[w.row] = w;
                                return w;
                            }
                        },
                        {
                            key: "addLineWidget",
                            value: function addLineWidget(w) {
                                this.$registerLineWidget(w);
                                w.session = this.session;
                                if (!this.editor) return w;
                                var renderer = this.editor.renderer;
                                if (w.html && !w.el) {
                                    w.el = dom.createElement("div");
                                    w.el.innerHTML = w.html;
                                }
                                if (w.text && !w.el) {
                                    w.el = dom.createElement("div");
                                    w.el.textContent = w.text;
                                }
                                if (w.el) {
                                    dom.addCssClass(w.el, "ace_lineWidgetContainer");
                                    if (w.className) {
                                        dom.addCssClass(w.el, w.className);
                                    }
                                    w.el.style.position = "absolute";
                                    w.el.style.zIndex = 5;
                                    renderer.container.appendChild(w.el);
                                    w._inDocument = true;
                                    if (!w.coverGutter) {
                                        w.el.style.zIndex = 3;
                                    }
                                    if (w.pixelHeight == null) {
                                        w.pixelHeight = w.el.offsetHeight;
                                    }
                                }
                                if (w.rowCount == null) {
                                    w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
                                }
                                var fold = this.session.getFoldAt(w.row, 0);
                                w.$fold = fold;
                                if (fold) {
                                    var lineWidgets = this.session.lineWidgets;
                                    if (w.row == fold.end.row && !lineWidgets[fold.start.row]) lineWidgets[fold.start.row] = w;
                                    else w.hidden = true;
                                }
                                this.session._emit("changeFold", {
                                    data: {
                                        start: {
                                            row: w.row
                                        }
                                    }
                                });
                                this.$updateRows();
                                this.renderWidgets(null, renderer);
                                this.onWidgetChanged(w);
                                return w;
                            }
                        },
                        {
                            key: "removeLineWidget",
                            value: function removeLineWidget(w) {
                                w._inDocument = false;
                                w.session = null;
                                if (w.el && w.el.parentNode) w.el.parentNode.removeChild(w.el);
                                if (w.editor && w.editor.destroy) try {
                                    w.editor.destroy();
                                } catch (e) {}
                                if (this.session.lineWidgets) {
                                    var w1 = this.session.lineWidgets[w.row];
                                    if (w1 == w) {
                                        this.session.lineWidgets[w.row] = w.$oldWidget;
                                        if (w.$oldWidget) this.onWidgetChanged(w.$oldWidget);
                                    } else {
                                        while(w1){
                                            if (w1.$oldWidget == w) {
                                                w1.$oldWidget = w.$oldWidget;
                                                break;
                                            }
                                            w1 = w1.$oldWidget;
                                        }
                                    }
                                }
                                this.session._emit("changeFold", {
                                    data: {
                                        start: {
                                            row: w.row
                                        }
                                    }
                                });
                                this.$updateRows();
                            }
                        },
                        {
                            key: "getWidgetsAtRow",
                            value: function getWidgetsAtRow(row) {
                                var lineWidgets = this.session.lineWidgets;
                                var w = lineWidgets && lineWidgets[row];
                                var list = [];
                                while(w){
                                    list.push(w);
                                    w = w.$oldWidget;
                                }
                                return list;
                            }
                        },
                        {
                            key: "onWidgetChanged",
                            value: function onWidgetChanged(w) {
                                this.session._changedWidgets.push(w);
                                this.editor && this.editor.renderer.updateFull();
                            }
                        },
                        {
                            key: "measureWidgets",
                            value: function measureWidgets(e, renderer) {
                                var changedWidgets = this.session._changedWidgets;
                                var config = renderer.layerConfig;
                                if (!changedWidgets || !changedWidgets.length) return;
                                var min = Infinity;
                                for(var i = 0; i < changedWidgets.length; i++){
                                    var w = changedWidgets[i];
                                    if (!w || !w.el) continue;
                                    if (w.session != this.session) continue;
                                    if (!w._inDocument) {
                                        if (this.session.lineWidgets[w.row] != w) continue;
                                        w._inDocument = true;
                                        renderer.container.appendChild(w.el);
                                    }
                                    w.h = w.el.offsetHeight;
                                    if (!w.fixedWidth) {
                                        w.w = w.el.offsetWidth;
                                        w.screenWidth = Math.ceil(w.w / config.characterWidth);
                                    }
                                    var rowCount = w.h / config.lineHeight;
                                    if (w.coverLine) {
                                        rowCount -= this.session.getRowLineCount(w.row);
                                        if (rowCount < 0) rowCount = 0;
                                    }
                                    if (w.rowCount != rowCount) {
                                        w.rowCount = rowCount;
                                        if (w.row < min) min = w.row;
                                    }
                                }
                                if (min != Infinity) {
                                    this.session._emit("changeFold", {
                                        data: {
                                            start: {
                                                row: min
                                            }
                                        }
                                    });
                                    this.session.lineWidgetWidth = null;
                                }
                                this.session._changedWidgets = [];
                            }
                        },
                        {
                            key: "renderWidgets",
                            value: function renderWidgets(e, renderer) {
                                var config = renderer.layerConfig;
                                var lineWidgets = this.session.lineWidgets;
                                if (!lineWidgets) return;
                                var first = Math.min(this.firstRow, config.firstRow);
                                var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);
                                while(first > 0 && !lineWidgets[first])first--;
                                this.firstRow = config.firstRow;
                                this.lastRow = config.lastRow;
                                renderer.$cursorLayer.config = config;
                                for(var i = first; i <= last; i++){
                                    var w = lineWidgets[i];
                                    if (!w || !w.el) continue;
                                    if (w.hidden) {
                                        w.el.style.top = -100 - (w.pixelHeight || 0) + "px";
                                        continue;
                                    }
                                    if (!w._inDocument) {
                                        w._inDocument = true;
                                        renderer.container.appendChild(w.el);
                                    }
                                    var top = renderer.$cursorLayer.getPixelPosition({
                                        row: i,
                                        column: 0
                                    }, true).top;
                                    if (!w.coverLine) top += config.lineHeight * this.session.getRowLineCount(w.row);
                                    w.el.style.top = top - config.offset + "px";
                                    var left = w.coverGutter ? 0 : renderer.gutterWidth;
                                    if (!w.fixedWidth) left -= renderer.scrollLeft;
                                    w.el.style.left = left + "px";
                                    if (w.fullWidth && w.screenWidth) {
                                        w.el.style.minWidth = config.width + 2 * config.padding + "px";
                                    }
                                    if (w.fixedWidth) {
                                        w.el.style.right = renderer.scrollBar.getWidth() + "px";
                                    } else {
                                        w.el.style.right = "";
                                    }
                                }
                            }
                        }
                    ]);
                    return LineWidgets;
                }();
                exports1.H = LineWidgets;
            /***/ },
            /***/ 2463: /***/ function(__unused_webpack_module, exports1) {
                "use strict";
                var Behaviour = function Behaviour() {
                    this.$behaviours = {};
                };
                (function() {
                    this.add = function(name, action, callback) {
                        switch(undefined){
                            case this.$behaviours:
                                this.$behaviours = {};
                            case this.$behaviours[name]:
                                this.$behaviours[name] = {};
                        }
                        this.$behaviours[name][action] = callback;
                    };
                    this.addBehaviours = function(behaviours) {
                        for(var key in behaviours){
                            for(var action in behaviours[key]){
                                this.add(key, action, behaviours[key][action]);
                            }
                        }
                    };
                    this.remove = function(name) {
                        if (this.$behaviours && this.$behaviours[name]) {
                            delete this.$behaviours[name];
                        }
                    };
                    this.inherit = function(mode, filter) {
                        if (typeof mode === "function") {
                            var behaviours = new mode().getBehaviours(filter);
                        } else {
                            var behaviours = mode.getBehaviours(filter);
                        }
                        this.addBehaviours(behaviours);
                    };
                    this.getBehaviours = function(filter) {
                        if (!filter) {
                            return this.$behaviours;
                        } else {
                            var ret = {};
                            for(var i = 0; i < filter.length; i++){
                                if (this.$behaviours[filter[i]]) {
                                    ret[filter[i]] = this.$behaviours[filter[i]];
                                }
                            }
                            return ret;
                        }
                    };
                }).call(Behaviour.prototype);
                exports1.T = Behaviour;
            /***/ },
            /***/ 5478: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_855942__) {
                "use strict";
                var oop = __nested_webpack_require_855942__(2011);
                var Behaviour = __nested_webpack_require_855942__(2463)/* .Behaviour */ .T;
                var TokenIterator = __nested_webpack_require_855942__(7726)/* .TokenIterator */ .N;
                var lang = __nested_webpack_require_855942__(732);
                var SAFE_INSERT_IN_TOKENS = [
                    "text",
                    "paren.rparen",
                    "rparen",
                    "paren",
                    "punctuation.operator"
                ];
                var SAFE_INSERT_BEFORE_TOKENS = [
                    "text",
                    "paren.rparen",
                    "rparen",
                    "paren",
                    "punctuation.operator",
                    "comment"
                ];
                var context;
                var contextCache = {};
                var defaultQuotes = {
                    '"': '"',
                    "'": "'"
                };
                var initContext = function initContext(editor) {
                    var id = -1;
                    if (editor.multiSelect) {
                        id = editor.selection.index;
                        if (contextCache.rangeCount != editor.multiSelect.rangeCount) contextCache = {
                            rangeCount: editor.multiSelect.rangeCount
                        };
                    }
                    if (contextCache[id]) return context = contextCache[id];
                    context = contextCache[id] = {
                        autoInsertedBrackets: 0,
                        autoInsertedRow: -1,
                        autoInsertedLineEnd: "",
                        maybeInsertedBrackets: 0,
                        maybeInsertedRow: -1,
                        maybeInsertedLineStart: "",
                        maybeInsertedLineEnd: ""
                    };
                };
                var getWrapped = function getWrapped(selection, selected, opening, closing) {
                    var rowDiff = selection.end.row - selection.start.row;
                    return {
                        text: opening + selected + closing,
                        selection: [
                            0,
                            selection.start.column + 1,
                            rowDiff,
                            selection.end.column + (rowDiff ? 0 : 1)
                        ]
                    };
                };
                /**
 * Creates a new Cstyle behaviour object with the specified options.
 * @constructor
 * @param {Object} [options] - The options for the Cstyle behaviour object.
 * @param {boolean} [options.braces] - Whether to force braces auto-pairing.
 */ var CstyleBehaviour = function CstyleBehaviour1(options) {
                    this.add("braces", "insertion", function(state, action, editor, session, text) {
                        var cursor = editor.getCursorPosition();
                        var line = session.doc.getLine(cursor.row);
                        if (text == "{") {
                            initContext(editor);
                            var selection = editor.getSelectionRange();
                            var selected = session.doc.getTextRange(selection);
                            if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
                                return getWrapped(selection, selected, "{", "}");
                            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                                if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode || options && options.braces) {
                                    CstyleBehaviour.recordAutoInsert(editor, session, "}");
                                    return {
                                        text: "{}",
                                        selection: [
                                            1,
                                            1
                                        ]
                                    };
                                } else {
                                    CstyleBehaviour.recordMaybeInsert(editor, session, "{");
                                    return {
                                        text: "{",
                                        selection: [
                                            1,
                                            1
                                        ]
                                    };
                                }
                            }
                        } else if (text == "}") {
                            initContext(editor);
                            var rightChar = line.substring(cursor.column, cursor.column + 1);
                            if (rightChar == "}") {
                                var matching = session.$findOpeningBracket("}", {
                                    column: cursor.column + 1,
                                    row: cursor.row
                                });
                                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                                    CstyleBehaviour.popAutoInsertedClosing();
                                    return {
                                        text: "",
                                        selection: [
                                            1,
                                            1
                                        ]
                                    };
                                }
                            }
                        } else if (text == "\n" || text == "\r\n") {
                            initContext(editor);
                            var closing = "";
                            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
                                closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
                                CstyleBehaviour.clearMaybeInsertedClosing();
                            }
                            var rightChar = line.substring(cursor.column, cursor.column + 1);
                            if (rightChar === "}") {
                                var openBracePos = session.findMatchingBracket({
                                    row: cursor.row,
                                    column: cursor.column + 1
                                }, "}");
                                if (!openBracePos) return null;
                                var next_indent = this.$getIndent(session.getLine(openBracePos.row));
                            } else if (closing) {
                                var next_indent = this.$getIndent(line);
                            } else {
                                CstyleBehaviour.clearMaybeInsertedClosing();
                                return;
                            }
                            var indent = next_indent + session.getTabString();
                            return {
                                text: "\n" + indent + "\n" + next_indent + closing,
                                selection: [
                                    1,
                                    indent.length,
                                    1,
                                    indent.length
                                ]
                            };
                        } else {
                            CstyleBehaviour.clearMaybeInsertedClosing();
                        }
                    });
                    this.add("braces", "deletion", function(state, action, editor, session, range) {
                        var selected = session.doc.getTextRange(range);
                        if (!range.isMultiLine() && selected == "{") {
                            initContext(editor);
                            var line = session.doc.getLine(range.start.row);
                            var rightChar = line.substring(range.end.column, range.end.column + 1);
                            if (rightChar == "}") {
                                range.end.column++;
                                return range;
                            } else {
                                context.maybeInsertedBrackets--;
                            }
                        }
                    });
                    this.add("parens", "insertion", function(state, action, editor, session, text) {
                        if (text == "(") {
                            initContext(editor);
                            var selection = editor.getSelectionRange();
                            var selected = session.doc.getTextRange(selection);
                            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                                return getWrapped(selection, selected, "(", ")");
                            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                                CstyleBehaviour.recordAutoInsert(editor, session, ")");
                                return {
                                    text: "()",
                                    selection: [
                                        1,
                                        1
                                    ]
                                };
                            }
                        } else if (text == ")") {
                            initContext(editor);
                            var cursor = editor.getCursorPosition();
                            var line = session.doc.getLine(cursor.row);
                            var rightChar = line.substring(cursor.column, cursor.column + 1);
                            if (rightChar == ")") {
                                var matching = session.$findOpeningBracket(")", {
                                    column: cursor.column + 1,
                                    row: cursor.row
                                });
                                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                                    CstyleBehaviour.popAutoInsertedClosing();
                                    return {
                                        text: "",
                                        selection: [
                                            1,
                                            1
                                        ]
                                    };
                                }
                            }
                        }
                    });
                    this.add("parens", "deletion", function(state, action, editor, session, range) {
                        var selected = session.doc.getTextRange(range);
                        if (!range.isMultiLine() && selected == "(") {
                            initContext(editor);
                            var line = session.doc.getLine(range.start.row);
                            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
                            if (rightChar == ")") {
                                range.end.column++;
                                return range;
                            }
                        }
                    });
                    this.add("brackets", "insertion", function(state, action, editor, session, text) {
                        if (text == "[") {
                            initContext(editor);
                            var selection = editor.getSelectionRange();
                            var selected = session.doc.getTextRange(selection);
                            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                                return getWrapped(selection, selected, "[", "]");
                            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                                CstyleBehaviour.recordAutoInsert(editor, session, "]");
                                return {
                                    text: "[]",
                                    selection: [
                                        1,
                                        1
                                    ]
                                };
                            }
                        } else if (text == "]") {
                            initContext(editor);
                            var cursor = editor.getCursorPosition();
                            var line = session.doc.getLine(cursor.row);
                            var rightChar = line.substring(cursor.column, cursor.column + 1);
                            if (rightChar == "]") {
                                var matching = session.$findOpeningBracket("]", {
                                    column: cursor.column + 1,
                                    row: cursor.row
                                });
                                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                                    CstyleBehaviour.popAutoInsertedClosing();
                                    return {
                                        text: "",
                                        selection: [
                                            1,
                                            1
                                        ]
                                    };
                                }
                            }
                        }
                    });
                    this.add("brackets", "deletion", function(state, action, editor, session, range) {
                        var selected = session.doc.getTextRange(range);
                        if (!range.isMultiLine() && selected == "[") {
                            initContext(editor);
                            var line = session.doc.getLine(range.start.row);
                            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
                            if (rightChar == "]") {
                                range.end.column++;
                                return range;
                            }
                        }
                    });
                    this.add("string_dquotes", "insertion", function(state, action, editor, session, text) {
                        var quotes = session.$mode.$quotes || defaultQuotes;
                        if (text.length == 1 && quotes[text]) {
                            if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1) return;
                            initContext(editor);
                            var quote = text;
                            var selection = editor.getSelectionRange();
                            var selected = session.doc.getTextRange(selection);
                            if (selected !== "" && (selected.length != 1 || !quotes[selected]) && editor.getWrapBehavioursEnabled()) {
                                return getWrapped(selection, selected, quote, quote);
                            } else if (!selected) {
                                var cursor = editor.getCursorPosition();
                                var line = session.doc.getLine(cursor.row);
                                var leftChar = line.substring(cursor.column - 1, cursor.column);
                                var rightChar = line.substring(cursor.column, cursor.column + 1);
                                var token = session.getTokenAt(cursor.row, cursor.column);
                                var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
                                // We're escaped.
                                if (leftChar == "\\" && token && /escape/.test(token.type)) return null;
                                var stringBefore = token && /string|escape/.test(token.type);
                                var stringAfter = !rightToken || /string|escape/.test(rightToken.type);
                                var pair;
                                if (rightChar == quote) {
                                    pair = stringBefore !== stringAfter;
                                    if (pair && /string\.end/.test(rightToken.type)) pair = false;
                                } else {
                                    if (stringBefore && !stringAfter) return null; // wrap string with different quote
                                    if (stringBefore && stringAfter) return null; // do not pair quotes inside strings
                                    var wordRe = session.$mode.tokenRe;
                                    wordRe.lastIndex = 0;
                                    var isWordBefore = wordRe.test(leftChar);
                                    wordRe.lastIndex = 0;
                                    var isWordAfter = wordRe.test(rightChar);
                                    var pairQuotesAfter = session.$mode.$pairQuotesAfter;
                                    var shouldPairQuotes = pairQuotesAfter && pairQuotesAfter[quote] && pairQuotesAfter[quote].test(leftChar);
                                    if (!shouldPairQuotes && isWordBefore || isWordAfter) return null; // before or after alphanumeric
                                    if (rightChar && !/[\s;,.})\]\\]/.test(rightChar)) return null; // there is rightChar and it isn't closing
                                    var charBefore = line[cursor.column - 2];
                                    if (leftChar == quote && (charBefore == quote || wordRe.test(charBefore))) return null;
                                    pair = true;
                                }
                                return {
                                    text: pair ? quote + quote : "",
                                    selection: [
                                        1,
                                        1
                                    ]
                                };
                            }
                        }
                    });
                    this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
                        var quotes = session.$mode.$quotes || defaultQuotes;
                        var selected = session.doc.getTextRange(range);
                        if (!range.isMultiLine() && quotes.hasOwnProperty(selected)) {
                            initContext(editor);
                            var line = session.doc.getLine(range.start.row);
                            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
                            if (rightChar == selected) {
                                range.end.column++;
                                return range;
                            }
                        }
                    });
                };
                CstyleBehaviour.isSaneInsertion = function(editor, session) {
                    var cursor = editor.getCursorPosition();
                    var iterator = new TokenIterator(session, cursor.row, cursor.column);
                    // Don't insert in the middle of a keyword/identifier/lexical
                    if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
                        if (/[)}\]]/.test(editor.session.getLine(cursor.row)[cursor.column])) return true;
                        // Look ahead in case we're at the end of a token
                        var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
                        if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) return false;
                    }
                    // Only insert in front of whitespace/comments
                    iterator.stepForward();
                    return iterator.getCurrentTokenRow() !== cursor.row || this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
                };
                CstyleBehaviour.$matchTokenType = function(token, types) {
                    return types.indexOf(token.type || token) > -1;
                };
                CstyleBehaviour.recordAutoInsert = function(editor, session, bracket) {
                    var cursor = editor.getCursorPosition();
                    var line = session.doc.getLine(cursor.row);
                    // Reset previous state if text or context changed too much
                    if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0])) context.autoInsertedBrackets = 0;
                    context.autoInsertedRow = cursor.row;
                    context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
                    context.autoInsertedBrackets++;
                };
                CstyleBehaviour.recordMaybeInsert = function(editor, session, bracket) {
                    var cursor = editor.getCursorPosition();
                    var line = session.doc.getLine(cursor.row);
                    if (!this.isMaybeInsertedClosing(cursor, line)) context.maybeInsertedBrackets = 0;
                    context.maybeInsertedRow = cursor.row;
                    context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
                    context.maybeInsertedLineEnd = line.substr(cursor.column);
                    context.maybeInsertedBrackets++;
                };
                CstyleBehaviour.isAutoInsertedClosing = function(cursor, line, bracket) {
                    return context.autoInsertedBrackets > 0 && cursor.row === context.autoInsertedRow && bracket === context.autoInsertedLineEnd[0] && line.substr(cursor.column) === context.autoInsertedLineEnd;
                };
                CstyleBehaviour.isMaybeInsertedClosing = function(cursor, line) {
                    return context.maybeInsertedBrackets > 0 && cursor.row === context.maybeInsertedRow && line.substr(cursor.column) === context.maybeInsertedLineEnd && line.substr(0, cursor.column) == context.maybeInsertedLineStart;
                };
                CstyleBehaviour.popAutoInsertedClosing = function() {
                    context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
                    context.autoInsertedBrackets--;
                };
                CstyleBehaviour.clearMaybeInsertedClosing = function() {
                    if (context) {
                        context.maybeInsertedBrackets = 0;
                        context.maybeInsertedRow = -1;
                    }
                };
                oop.inherits(CstyleBehaviour, Behaviour);
                exports1.B = CstyleBehaviour;
            /***/ },
            /***/ 9372: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_878966__) {
                "use strict";
                var Range = __nested_webpack_require_878966__(3069)/* .Range */ .e;
                var FoldMode = exports1.FoldMode = function FoldMode() {};
                (function() {
                    this.foldingStartMarker = null;
                    this.foldingStopMarker = null;
                    // must return "" if there's no fold, to enable caching
                    this.getFoldWidget = function(session, foldStyle, row) {
                        var line = session.getLine(row);
                        if (this.foldingStartMarker.test(line)) return "start";
                        if (foldStyle == "markbeginend" && this.foldingStopMarker && this.foldingStopMarker.test(line)) return "end";
                        return "";
                    };
                    this.getFoldWidgetRange = function(session, foldStyle, row) {
                        return null;
                    };
                    this.indentationBlock = function(session, row, column) {
                        var re = /\S/;
                        var line = session.getLine(row);
                        var startLevel = line.search(re);
                        if (startLevel == -1) return;
                        var startColumn = column || line.length;
                        var maxRow = session.getLength();
                        var startRow = row;
                        var endRow = row;
                        while(++row < maxRow){
                            var level = session.getLine(row).search(re);
                            if (level == -1) continue;
                            if (level <= startLevel) {
                                var token = session.getTokenAt(row, 0);
                                if (!token || token.type !== "string") break;
                            }
                            endRow = row;
                        }
                        if (endRow > startRow) {
                            var endColumn = session.getLine(endRow).length;
                            return new Range(startRow, startColumn, endRow, endColumn);
                        }
                    };
                    this.openingBracketBlock = function(session, bracket, row, column, typeRe) {
                        var start = {
                            row: row,
                            column: column + 1
                        };
                        var end = session.$findClosingBracket(bracket, start, typeRe);
                        if (!end) return;
                        var fw = session.foldWidgets[end.row];
                        if (fw == null) fw = session.getFoldWidget(end.row);
                        if (fw == "start" && end.row > start.row) {
                            end.row--;
                            end.column = session.getLine(end.row).length;
                        }
                        return Range.fromPoints(start, end);
                    };
                    this.closingBracketBlock = function(session, bracket, row, column, typeRe) {
                        var end = {
                            row: row,
                            column: column
                        };
                        var start = session.$findOpeningBracket(bracket, end);
                        if (!start) return;
                        start.column++;
                        end.column--;
                        return Range.fromPoints(start, end);
                    };
                }).call(FoldMode.prototype);
            /***/ },
            /***/ 2113: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_882628__) {
                "use strict";
                var config = __nested_webpack_require_882628__(3294);
                var Tokenizer = __nested_webpack_require_882628__(9754)/* .Tokenizer */ .d;
                var TextHighlightRules = __nested_webpack_require_882628__(9697)/* .TextHighlightRules */ .K;
                var CstyleBehaviour = __nested_webpack_require_882628__(5478)/* .CstyleBehaviour */ .B;
                var unicode = __nested_webpack_require_882628__(7913);
                var lang = __nested_webpack_require_882628__(732);
                var TokenIterator = __nested_webpack_require_882628__(7726)/* .TokenIterator */ .N;
                var Range = __nested_webpack_require_882628__(3069)/* .Range */ .e;
                /**
 *
 * @constructor
 * @alias TextMode
 * @property {{[quote: string]: string}} [$quotes] - quotes used by language mode
 * @property {string} lineCommentStart - characters that indicate the start of a line comment
 * @property {{start: string, end: string}} [blockComment] - characters that indicate the start and end of a block comment
 * @property {TextHighlightRules} HighlightRules - language specific highlighters
 * @property {FoldMode} foldingRules - language specific folding rules
 * @property {MatchingBraceOutdent} $outdent
 * @property {RegExp} tokenRe
 * @property {RegExp} nonTokenRe
 * @property {{[quote: string]: RegExp}} [$pairQuotesAfter] - An object containing conditions to determine whether to apply matching quote or not.
 */ var Mode = function Mode() {
                    this.HighlightRules = TextHighlightRules;
                };
                (function() {
                    this.$defaultBehaviour = new CstyleBehaviour();
                    this.tokenRe = new RegExp("^[" + unicode.wordChars + "\\$_]+", "g");
                    this.nonTokenRe = new RegExp("^(?:[^" + unicode.wordChars + "\\$_]|\\s])+", "g");
                    this.getTokenizer = function() {
                        if (!this.$tokenizer) {
                            this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);
                            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
                        }
                        return this.$tokenizer;
                    };
                    this.lineCommentStart = "";
                    this.blockComment = "";
                    this.toggleCommentLines = function(state, session, startRow, endRow) {
                        var iter = function iter(fun) {
                            for(var i = startRow; i <= endRow; i++)fun(doc.getLine(i), i);
                        };
                        var doc = session.doc;
                        var ignoreBlankLines = true;
                        var shouldRemove = true;
                        var minIndent = Infinity;
                        var tabSize = session.getTabSize();
                        var insertAtTabStop = false;
                        if (!this.lineCommentStart) {
                            if (!this.blockComment) return false;
                            var lineCommentStart = this.blockComment.start;
                            var lineCommentEnd = this.blockComment.end;
                            var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
                            var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");
                            var comment = function comment(line, i) {
                                if (testRemove(line, i)) return;
                                if (!ignoreBlankLines || /\S/.test(line)) {
                                    doc.insertInLine({
                                        row: i,
                                        column: line.length
                                    }, lineCommentEnd);
                                    doc.insertInLine({
                                        row: i,
                                        column: minIndent
                                    }, lineCommentStart);
                                }
                            };
                            var uncomment = function uncomment(line, i) {
                                var m;
                                if (m = line.match(regexpEnd)) doc.removeInLine(i, line.length - m[0].length, line.length);
                                if (m = line.match(regexpStart)) doc.removeInLine(i, m[1].length, m[0].length);
                            };
                            var testRemove = function testRemove(line, row) {
                                if (regexpStart.test(line)) return true;
                                var tokens = session.getTokens(row);
                                for(var i = 0; i < tokens.length; i++){
                                    if (tokens[i].type === "comment") return true;
                                }
                            };
                        } else {
                            if (Array.isArray(this.lineCommentStart)) {
                                var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
                                var lineCommentStart = this.lineCommentStart[0];
                            } else {
                                var regexpStart = lang.escapeRegExp(this.lineCommentStart);
                                var lineCommentStart = this.lineCommentStart;
                            }
                            regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");
                            insertAtTabStop = session.getUseSoftTabs();
                            var uncomment = function uncomment(line, i) {
                                var m = line.match(regexpStart);
                                if (!m) return;
                                var start = m[1].length, end = m[0].length;
                                if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ") end--;
                                doc.removeInLine(i, start, end);
                            };
                            var commentWithSpace = lineCommentStart + " ";
                            var comment = function comment(line, i) {
                                if (!ignoreBlankLines || /\S/.test(line)) {
                                    if (shouldInsertSpace(line, minIndent, minIndent)) doc.insertInLine({
                                        row: i,
                                        column: minIndent
                                    }, commentWithSpace);
                                    else doc.insertInLine({
                                        row: i,
                                        column: minIndent
                                    }, lineCommentStart);
                                }
                            };
                            var testRemove = function testRemove(line, i) {
                                return regexpStart.test(line);
                            };
                            var shouldInsertSpace = function shouldInsertSpace(line, before, after) {
                                var spaces = 0;
                                while(before-- && line.charAt(before) == " ")spaces++;
                                if (spaces % tabSize != 0) return false;
                                var spaces = 0;
                                while(line.charAt(after++) == " ")spaces++;
                                if (tabSize > 2) return spaces % tabSize != tabSize - 1;
                                else return spaces % tabSize == 0;
                            };
                        }
                        var minEmptyLength = Infinity;
                        iter(function(line, i) {
                            var indent = line.search(/\S/);
                            if (indent !== -1) {
                                if (indent < minIndent) minIndent = indent;
                                if (shouldRemove && !testRemove(line, i)) shouldRemove = false;
                            } else if (minEmptyLength > line.length) {
                                minEmptyLength = line.length;
                            }
                        });
                        if (minIndent == Infinity) {
                            minIndent = minEmptyLength;
                            ignoreBlankLines = false;
                            shouldRemove = false;
                        }
                        if (insertAtTabStop && minIndent % tabSize != 0) minIndent = Math.floor(minIndent / tabSize) * tabSize;
                        iter(shouldRemove ? uncomment : comment);
                    };
                    this.toggleBlockComment = function(state, session, range, cursor) {
                        var comment = this.blockComment;
                        if (!comment) return;
                        if (!comment.start && comment[0]) comment = comment[0];
                        var iterator = new TokenIterator(session, cursor.row, cursor.column);
                        var token = iterator.getCurrentToken();
                        var sel = session.selection;
                        var initialRange = session.selection.toOrientedRange();
                        var startRow, colDiff;
                        if (token && /comment/.test(token.type)) {
                            var startRange, endRange;
                            while(token && /comment/.test(token.type)){
                                var i = token.value.indexOf(comment.start);
                                if (i != -1) {
                                    var row = iterator.getCurrentTokenRow();
                                    var column = iterator.getCurrentTokenColumn() + i;
                                    startRange = new Range(row, column, row, column + comment.start.length);
                                    break;
                                }
                                token = iterator.stepBackward();
                            }
                            var iterator = new TokenIterator(session, cursor.row, cursor.column);
                            var token = iterator.getCurrentToken();
                            while(token && /comment/.test(token.type)){
                                var i = token.value.indexOf(comment.end);
                                if (i != -1) {
                                    var row = iterator.getCurrentTokenRow();
                                    var column = iterator.getCurrentTokenColumn() + i;
                                    endRange = new Range(row, column, row, column + comment.end.length);
                                    break;
                                }
                                token = iterator.stepForward();
                            }
                            if (endRange) session.remove(endRange);
                            if (startRange) {
                                session.remove(startRange);
                                startRow = startRange.start.row;
                                colDiff = -comment.start.length;
                            }
                        } else {
                            colDiff = comment.start.length;
                            startRow = range.start.row;
                            session.insert(range.end, comment.end);
                            session.insert(range.start, comment.start);
                        }
                        // todo: selection should have ended up in the right place automatically!
                        if (initialRange.start.row == startRow) initialRange.start.column += colDiff;
                        if (initialRange.end.row == startRow) initialRange.end.column += colDiff;
                        session.selection.fromOrientedRange(initialRange);
                    };
                    this.getNextLineIndent = function(state, line, tab) {
                        return this.$getIndent(line);
                    };
                    this.checkOutdent = function(state, line, input) {
                        return false;
                    };
                    this.autoOutdent = function(state, doc, row) {};
                    this.$getIndent = function(line) {
                        return line.match(/^\s*/)[0];
                    };
                    this.createWorker = function(session) {
                        return null;
                    };
                    this.createModeDelegates = function(mapping) {
                        this.$embeds = [];
                        this.$modes = {};
                        for(var i in mapping){
                            if (mapping[i]) {
                                var Mode = mapping[i];
                                var id = Mode.prototype.$id;
                                var mode = config.$modes[id];
                                if (!mode) config.$modes[id] = mode = new Mode();
                                if (!config.$modes[i]) config.$modes[i] = mode;
                                this.$embeds.push(i);
                                this.$modes[i] = mode;
                            }
                        }
                        var delegations = [
                            "toggleBlockComment",
                            "toggleCommentLines",
                            "getNextLineIndent",
                            "checkOutdent",
                            "autoOutdent",
                            "transformAction",
                            "getCompletions"
                        ];
                        for(var i = 0; i < delegations.length; i++){
                            (function(scope) {
                                var functionName = delegations[i];
                                var defaultHandler = scope[functionName];
                                scope[delegations[i]] = function() {
                                    return this.$delegator(functionName, arguments, defaultHandler);
                                };
                            })(this);
                        }
                    };
                    this.$delegator = function(method, args, defaultHandler) {
                        var state = args[0] || "start";
                        if (typeof state != "string") {
                            if (Array.isArray(state[2])) {
                                var language = state[2][state[2].length - 1];
                                var mode = this.$modes[language];
                                if (mode) return mode[method].apply(mode, [
                                    state[1]
                                ].concat([].slice.call(args, 1)));
                            }
                            state = state[0] || "start";
                        }
                        for(var i = 0; i < this.$embeds.length; i++){
                            if (!this.$modes[this.$embeds[i]]) continue;
                            var split = state.split(this.$embeds[i]);
                            if (!split[0] && split[1]) {
                                args[0] = split[1];
                                var mode = this.$modes[this.$embeds[i]];
                                return mode[method].apply(mode, args);
                            }
                        }
                        var ret = defaultHandler.apply(this, args);
                        return defaultHandler ? ret : undefined;
                    };
                    this.transformAction = function(state, action, editor, session, param) {
                        if (this.$behaviour) {
                            var behaviours = this.$behaviour.getBehaviours();
                            for(var key in behaviours){
                                if (behaviours[key][action]) {
                                    var ret = behaviours[key][action].apply(this, arguments);
                                    if (ret) {
                                        return ret;
                                    }
                                }
                            }
                        }
                    };
                    this.getKeywords = function(append) {
                        // this is for autocompletion to pick up regexp'ed keywords
                        if (!this.completionKeywords) {
                            var rules = this.$tokenizer.rules;
                            var completionKeywords = [];
                            for(var rule in rules){
                                var ruleItr = rules[rule];
                                for(var r = 0, l = ruleItr.length; r < l; r++){
                                    if (typeof ruleItr[r].token === "string") {
                                        if (/keyword|support|storage/.test(ruleItr[r].token)) completionKeywords.push(ruleItr[r].regex);
                                    } else if (typeof ruleItr[r].token === "object") {
                                        for(var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++){
                                            if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                                                // drop surrounding parens
                                                var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                                                completionKeywords.push(rule.substr(1, rule.length - 2));
                                            }
                                        }
                                    }
                                }
                            }
                            this.completionKeywords = completionKeywords;
                        }
                        // this is for highlighting embed rules, like HAML/Ruby or Obj-C/C
                        if (!append) return this.$keywordList;
                        return completionKeywords.concat(this.$keywordList || []);
                    };
                    this.$createKeywordList = function() {
                        if (!this.$highlightRules) this.getTokenizer();
                        return this.$keywordList = this.$highlightRules.$keywordList || [];
                    };
                    this.getCompletions = function(state, session, pos, prefix) {
                        var keywords = this.$keywordList || this.$createKeywordList();
                        return keywords.map(function(word) {
                            return {
                                name: word,
                                value: word,
                                score: 0,
                                meta: "keyword"
                            };
                        });
                    };
                    this.$id = "ace/mode/text";
                }).call(Mode.prototype);
                exports1.A = Mode;
            /***/ },
            /***/ 9697: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_901752__) {
                "use strict";
                var lang = __nested_webpack_require_901752__(732);
                var TextHighlightRules = function TextHighlightRules() {
                    // regexp must not have capturing parentheses
                    // regexps are ordered -> the first match is used
                    this.$rules = {
                        "start": [
                            {
                                token: "empty_line",
                                regex: "^$"
                            },
                            {
                                defaultToken: "text"
                            }
                        ]
                    };
                };
                (function() {
                    this.addRules = function(rules, prefix) {
                        if (!prefix) {
                            for(var key in rules)this.$rules[key] = rules[key];
                            return;
                        }
                        for(var key in rules){
                            var state = rules[key];
                            for(var i = 0; i < state.length; i++){
                                var rule = state[i];
                                if (rule.next || rule.onMatch) {
                                    if (typeof rule.next == "string") {
                                        if (rule.next.indexOf(prefix) !== 0) rule.next = prefix + rule.next;
                                    }
                                    if (rule.nextState && rule.nextState.indexOf(prefix) !== 0) rule.nextState = prefix + rule.nextState;
                                }
                            }
                            this.$rules[prefix + key] = state;
                        }
                    };
                    this.getRules = function() {
                        return this.$rules;
                    };
                    this.embedRules = function(HighlightRules, prefix, escapeRules, states, append) {
                        var embedRules = typeof HighlightRules == "function" ? new HighlightRules().getRules() : HighlightRules;
                        if (states) {
                            for(var i = 0; i < states.length; i++)states[i] = prefix + states[i];
                        } else {
                            states = [];
                            for(var key in embedRules)states.push(prefix + key);
                        }
                        this.addRules(embedRules, prefix);
                        if (escapeRules) {
                            var addRules = Array.prototype[append ? "push" : "unshift"];
                            for(var i = 0; i < states.length; i++)addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));
                        }
                        if (!this.$embeds) this.$embeds = [];
                        this.$embeds.push(prefix);
                    };
                    this.getEmbeds = function() {
                        return this.$embeds;
                    };
                    var pushState = function pushState(currentState, stack) {
                        if (currentState != "start" || stack.length) stack.unshift(this.nextState, currentState);
                        return this.nextState;
                    };
                    var popState = function popState(currentState, stack) {
                        // if (stack[0] === currentState)
                        stack.shift();
                        return stack.shift() || "start";
                    };
                    this.normalizeRules = function() {
                        var id = 0;
                        var rules = this.$rules;
                        function processState(key) {
                            var state = rules[key];
                            state.processed = true;
                            for(var i = 0; i < state.length; i++){
                                var rule = state[i];
                                var toInsert = null;
                                if (Array.isArray(rule)) {
                                    toInsert = rule;
                                    rule = {};
                                }
                                if (!rule.regex && rule.start) {
                                    rule.regex = rule.start;
                                    if (!rule.next) rule.next = [];
                                    rule.next.push({
                                        defaultToken: rule.token
                                    }, {
                                        token: rule.token + ".end",
                                        regex: rule.end || rule.start,
                                        next: "pop"
                                    });
                                    rule.token = rule.token + ".start";
                                    rule.push = true;
                                }
                                var next = rule.next || rule.push;
                                if (next && Array.isArray(next)) {
                                    var stateName = rule.stateName;
                                    if (!stateName) {
                                        stateName = rule.token;
                                        if (typeof stateName != "string") stateName = stateName[0] || "";
                                        if (rules[stateName]) stateName += id++;
                                    }
                                    rules[stateName] = next;
                                    rule.next = stateName;
                                    processState(stateName);
                                } else if (next == "pop") {
                                    rule.next = popState;
                                }
                                if (rule.push) {
                                    rule.nextState = rule.next || rule.push;
                                    rule.next = pushState;
                                    delete rule.push;
                                }
                                if (rule.rules) {
                                    for(var r in rule.rules){
                                        if (rules[r]) {
                                            if (rules[r].push) rules[r].push.apply(rules[r], rule.rules[r]);
                                        } else {
                                            rules[r] = rule.rules[r];
                                        }
                                    }
                                }
                                var includeName = typeof rule == "string" ? rule : rule.include;
                                if (includeName) {
                                    if (includeName === "$self") includeName = "start";
                                    if (Array.isArray(includeName)) toInsert = includeName.map(function(x) {
                                        return rules[x];
                                    });
                                    else toInsert = rules[includeName];
                                }
                                if (toInsert) {
                                    var args = [
                                        i,
                                        1
                                    ].concat(toInsert);
                                    if (rule.noEscape) args = args.filter(function(x) {
                                        return !x.next;
                                    });
                                    state.splice.apply(state, args);
                                    // skip included rules since they are already processed
                                    //i += args.length - 3;
                                    i--;
                                }
                                if (rule.keywordMap) {
                                    rule.token = this.createKeywordMapper(rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive);
                                    delete rule.defaultToken;
                                }
                            }
                        }
                        Object.keys(rules).forEach(processState, this);
                    };
                    this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {
                        var keywords = Object.create(null);
                        this.$keywordList = [];
                        Object.keys(map).forEach(function(className) {
                            var a = map[className];
                            var list = a.split(splitChar || "|");
                            for(var i = list.length; i--;){
                                var word = list[i];
                                this.$keywordList.push(word);
                                if (ignoreCase) word = word.toLowerCase();
                                keywords[word] = className;
                            }
                        }, this);
                        map = null;
                        return ignoreCase ? function(value) {
                            return keywords[value.toLowerCase()] || defaultToken;
                        } : function(value) {
                            return keywords[value] || defaultToken;
                        };
                    };
                    this.getKeywords = function() {
                        return this.$keywords;
                    };
                }).call(TextHighlightRules.prototype);
                exports1.K = TextHighlightRules;
            /***/ },
            /***/ 4334: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_911565__) {
                "use strict";
                var GutterHandler = function GutterHandler(mouseHandler) {
                    var editor = mouseHandler.editor;
                    var gutter = editor.renderer.$gutterLayer;
                    var tooltip = new GutterTooltip(editor.container);
                    mouseHandler.editor.setDefaultHandler("guttermousedown", function(e) {
                        if (!editor.isFocused() || e.getButton() != 0) return;
                        var gutterRegion = gutter.getRegion(e);
                        if (gutterRegion == "foldWidgets") return;
                        var row = e.getDocumentPosition().row;
                        var selection = editor.session.selection;
                        if (e.getShiftKey()) selection.selectTo(row, 0);
                        else {
                            if (e.domEvent.detail == 2) {
                                editor.selectAll();
                                return e.preventDefault();
                            }
                            mouseHandler.$clickSelection = editor.selection.getLineRange(row);
                        }
                        mouseHandler.setState("selectByLines");
                        mouseHandler.captureMouse(e);
                        return e.preventDefault();
                    });
                    var tooltipTimeout, mouseEvent, tooltipAnnotation;
                    function showTooltip() {
                        var row = mouseEvent.getDocumentPosition().row;
                        var annotation = gutter.$annotations[row];
                        if (!annotation) return hideTooltip();
                        var maxRow = editor.session.getLength();
                        if (row == maxRow) {
                            var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
                            var pos = mouseEvent.$pos;
                            if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column)) return hideTooltip();
                        }
                        var annotationMessages = {
                            error: [],
                            warning: [],
                            info: []
                        };
                        var annotationLabels = {
                            error: {
                                singular: "error",
                                plural: "errors"
                            },
                            warning: {
                                singular: "warning",
                                plural: "warnings"
                            },
                            info: {
                                singular: "information message",
                                plural: "information messages"
                            }
                        };
                        var iconClassName = gutter.$useSvgGutterIcons ? "ace_icon_svg" : "ace_icon";
                        // Construct the body of the tooltip.
                        for(var i = 0; i < annotation.text.length; i++){
                            var line = "<span class='ace_".concat(annotation.type[i], " ").concat(iconClassName, "' aria-label='").concat(annotationLabels[annotation.type[i]].singular, "' role=img> </span> ").concat(annotation.text[i]);
                            annotationMessages[annotation.type[i]].push(line);
                        }
                        var tooltipBody = "<div class='ace_gutter-tooltip_body'>";
                        tooltipBody += [].concat(annotationMessages.error, annotationMessages.warning, annotationMessages.info).join("<br>");
                        tooltipBody += "</div>";
                        // Construct the header of the tooltip.
                        var isMoreThanOneAnnotationType = false;
                        var tooltipHeader = "<div class='ace_gutter-tooltip_header'>";
                        for(var i = 0; i < 3; i++){
                            var annotationType = [
                                "error",
                                "warning",
                                "info"
                            ][i];
                            if (annotationMessages[annotationType].length > 0) {
                                var label = annotationMessages[annotationType].length === 1 ? annotationLabels[annotationType].singular : annotationLabels[annotationType].plural;
                                tooltipHeader += "".concat(isMoreThanOneAnnotationType ? ", " : "").concat(annotationMessages[annotationType].length, " ").concat(label);
                                isMoreThanOneAnnotationType = true;
                            }
                        }
                        tooltipHeader += "</div>";
                        tooltipAnnotation = tooltipHeader + tooltipBody;
                        tooltip.setHtml(tooltipAnnotation);
                        tooltip.setClassName("ace_gutter-tooltip");
                        tooltip.$element.setAttribute("aria-live", "polite");
                        tooltip.show();
                        editor._signal("showGutterTooltip", tooltip);
                        editor.on("mousewheel", hideTooltip);
                        if (mouseHandler.$tooltipFollowsMouse) {
                            moveTooltip(mouseEvent);
                        } else {
                            var gutterElement = mouseEvent.domEvent.target;
                            var rect = gutterElement.getBoundingClientRect();
                            var style = tooltip.getElement().style;
                            style.left = rect.right + "px";
                            style.top = rect.bottom + "px";
                        }
                    }
                    function hideTooltip() {
                        if (tooltipTimeout) tooltipTimeout = clearTimeout(tooltipTimeout);
                        if (tooltipAnnotation) {
                            tooltip.hide();
                            tooltipAnnotation = null;
                            editor._signal("hideGutterTooltip", tooltip);
                            editor.off("mousewheel", hideTooltip);
                        }
                    }
                    function moveTooltip(e) {
                        tooltip.setPosition(e.x, e.y);
                    }
                    mouseHandler.editor.setDefaultHandler("guttermousemove", function(e) {
                        var target = e.domEvent.target || e.domEvent.srcElement;
                        if (dom.hasCssClass(target, "ace_fold-widget")) return hideTooltip();
                        if (tooltipAnnotation && mouseHandler.$tooltipFollowsMouse) moveTooltip(e);
                        mouseEvent = e;
                        if (tooltipTimeout) return;
                        tooltipTimeout = setTimeout(function() {
                            tooltipTimeout = null;
                            if (mouseEvent && !mouseHandler.isMousePressed) showTooltip();
                            else hideTooltip();
                        }, 50);
                    });
                    event.addListener(editor.renderer.$gutter, "mouseout", function(e) {
                        mouseEvent = null;
                        if (!tooltipAnnotation || tooltipTimeout) return;
                        tooltipTimeout = setTimeout(function() {
                            tooltipTimeout = null;
                            hideTooltip();
                        }, 50);
                    }, editor);
                    editor.on("changeSession", hideTooltip);
                };
                var dom = __nested_webpack_require_911565__(5336);
                var event = __nested_webpack_require_911565__(8215);
                var Tooltip = __nested_webpack_require_911565__(1692)/* .Tooltip */ .u;
                var GutterTooltip = /*#__PURE__*/ function(Tooltip1) {
                    _inherits(GutterTooltip, Tooltip1);
                    var _super = _create_super(GutterTooltip);
                    function GutterTooltip() {
                        _class_call_check(this, GutterTooltip);
                        return _super.apply(this, arguments);
                    }
                    _create_class(GutterTooltip, [
                        {
                            key: "setPosition",
                            value: function setPosition(x, y) {
                                var windowWidth = window.innerWidth || document.documentElement.clientWidth;
                                var windowHeight = window.innerHeight || document.documentElement.clientHeight;
                                var width = this.getWidth();
                                var height = this.getHeight();
                                x += 15;
                                y += 15;
                                if (x + width > windowWidth) {
                                    x -= x + width - windowWidth;
                                }
                                if (y + height > windowHeight) {
                                    y -= 20 + height;
                                }
                                Tooltip.prototype.setPosition.call(this, x, y);
                            }
                        }
                    ]);
                    return GutterTooltip;
                }(Tooltip);
                exports1.d = GutterHandler;
            /***/ },
            /***/ 6763: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_921140__) {
                "use strict";
                var calcDistance = function calcDistance(ax, ay, bx, by) {
                    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
                };
                var calcRangeOrientation = function calcRangeOrientation(range, cursor) {
                    if (range.start.row == range.end.row) var cmp = 2 * cursor.column - range.start.column - range.end.column;
                    else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column) var cmp = cursor.column - 4;
                    else var cmp = 2 * cursor.row - range.start.row - range.end.row;
                    if (cmp < 0) return {
                        cursor: range.start,
                        anchor: range.end
                    };
                    else return {
                        cursor: range.end,
                        anchor: range.start
                    };
                };
                var useragent = __nested_webpack_require_921140__(8057);
                var DRAG_OFFSET = 0; // pixels
                var SCROLL_COOLDOWN_T = 550; // milliseconds
                var DefaultHandlers = /*#__PURE__*/ function() {
                    function DefaultHandlers(mouseHandler) {
                        _class_call_check(this, DefaultHandlers);
                        mouseHandler.$clickSelection = null;
                        var editor = mouseHandler.editor;
                        editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
                        editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
                        editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
                        editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
                        editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));
                        var _$exports = [
                            "select",
                            "startSelect",
                            "selectEnd",
                            "selectAllEnd",
                            "selectByWordsEnd",
                            "selectByLinesEnd",
                            "dragWait",
                            "dragWaitEnd",
                            "focusWait"
                        ];
                        _$exports.forEach(function(x) {
                            mouseHandler[x] = this[x];
                        }, this);
                        mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
                        mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
                    }
                    _create_class(DefaultHandlers, [
                        {
                            key: "onMouseDown",
                            value: function onMouseDown(ev) {
                                var inSelection = ev.inSelection();
                                var pos = ev.getDocumentPosition();
                                this.mousedownEvent = ev;
                                var editor = this.editor;
                                var button = ev.getButton();
                                if (button !== 0) {
                                    var selectionRange = editor.getSelectionRange();
                                    var selectionEmpty = selectionRange.isEmpty();
                                    if (selectionEmpty || button == 1) editor.selection.moveToPosition(pos);
                                    // 2: contextmenu, 1: linux paste
                                    if (button == 2) {
                                        editor.textInput.onContextMenu(ev.domEvent);
                                        if (!useragent.isMozilla) ev.preventDefault();
                                    }
                                    // stopping event here breaks contextmenu on ff mac
                                    // not stoping breaks it on chrome mac
                                    return;
                                }
                                this.mousedownEvent.time = Date.now();
                                // if this click caused the editor to be focused should not clear the
                                // selection
                                if (inSelection && !editor.isFocused()) {
                                    editor.focus();
                                    if (this.$focusTimeout && !this.$clickSelection && !editor.inMultiSelectMode) {
                                        this.setState("focusWait");
                                        this.captureMouse(ev);
                                        return;
                                    }
                                }
                                this.captureMouse(ev);
                                this.startSelect(pos, ev.domEvent._clicks > 1);
                                return ev.preventDefault();
                            }
                        },
                        {
                            key: "startSelect",
                            value: function startSelect(pos, waitForClickSelection) {
                                pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
                                var editor = this.editor;
                                if (!this.mousedownEvent) return;
                                // allow double/triple click handlers to change selection
                                if (this.mousedownEvent.getShiftKey()) editor.selection.selectToPosition(pos);
                                else if (!waitForClickSelection) editor.selection.moveToPosition(pos);
                                if (!waitForClickSelection) this.select();
                                editor.setStyle("ace_selecting");
                                this.setState("select");
                            }
                        },
                        {
                            key: "select",
                            value: function select() {
                                var anchor, editor = this.editor;
                                var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
                                if (this.$clickSelection) {
                                    var cmp = this.$clickSelection.comparePoint(cursor);
                                    if (cmp == -1) {
                                        anchor = this.$clickSelection.end;
                                    } else if (cmp == 1) {
                                        anchor = this.$clickSelection.start;
                                    } else {
                                        var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                                        cursor = orientedRange.cursor;
                                        anchor = orientedRange.anchor;
                                    }
                                    editor.selection.setSelectionAnchor(anchor.row, anchor.column);
                                }
                                editor.selection.selectToPosition(cursor);
                                editor.renderer.scrollCursorIntoView();
                            }
                        },
                        {
                            key: "extendSelectionBy",
                            value: function extendSelectionBy(unitName) {
                                var anchor, editor = this.editor;
                                var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
                                var range = editor.selection[unitName](cursor.row, cursor.column);
                                if (this.$clickSelection) {
                                    var cmpStart = this.$clickSelection.comparePoint(range.start);
                                    var cmpEnd = this.$clickSelection.comparePoint(range.end);
                                    if (cmpStart == -1 && cmpEnd <= 0) {
                                        anchor = this.$clickSelection.end;
                                        if (range.end.row != cursor.row || range.end.column != cursor.column) cursor = range.start;
                                    } else if (cmpEnd == 1 && cmpStart >= 0) {
                                        anchor = this.$clickSelection.start;
                                        if (range.start.row != cursor.row || range.start.column != cursor.column) cursor = range.end;
                                    } else if (cmpStart == -1 && cmpEnd == 1) {
                                        cursor = range.end;
                                        anchor = range.start;
                                    } else {
                                        var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                                        cursor = orientedRange.cursor;
                                        anchor = orientedRange.anchor;
                                    }
                                    editor.selection.setSelectionAnchor(anchor.row, anchor.column);
                                }
                                editor.selection.selectToPosition(cursor);
                                editor.renderer.scrollCursorIntoView();
                            }
                        },
                        {
                            key: "selectByLinesEnd",
                            value: function selectByLinesEnd() {
                                this.$clickSelection = null;
                                this.editor.unsetStyle("ace_selecting");
                            }
                        },
                        {
                            key: "focusWait",
                            value: function focusWait() {
                                var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
                                var time = Date.now();
                                if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimeout) this.startSelect(this.mousedownEvent.getDocumentPosition());
                            }
                        },
                        {
                            key: "onDoubleClick",
                            value: function onDoubleClick(ev) {
                                var pos = ev.getDocumentPosition();
                                var editor = this.editor;
                                var session = editor.session;
                                var range = session.getBracketRange(pos);
                                if (range) {
                                    if (range.isEmpty()) {
                                        range.start.column--;
                                        range.end.column++;
                                    }
                                    this.setState("select");
                                } else {
                                    range = editor.selection.getWordRange(pos.row, pos.column);
                                    this.setState("selectByWords");
                                }
                                this.$clickSelection = range;
                                this.select();
                            }
                        },
                        {
                            key: "onTripleClick",
                            value: function onTripleClick(ev) {
                                var pos = ev.getDocumentPosition();
                                var editor = this.editor;
                                this.setState("selectByLines");
                                var range = editor.getSelectionRange();
                                if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
                                    this.$clickSelection = editor.selection.getLineRange(range.start.row);
                                    this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
                                } else {
                                    this.$clickSelection = editor.selection.getLineRange(pos.row);
                                }
                                this.select();
                            }
                        },
                        {
                            key: "onQuadClick",
                            value: function onQuadClick(ev) {
                                var editor = this.editor;
                                editor.selectAll();
                                this.$clickSelection = editor.getSelectionRange();
                                this.setState("selectAll");
                            }
                        },
                        {
                            key: "onMouseWheel",
                            value: function onMouseWheel(ev) {
                                if (ev.getAccelKey()) return;
                                // shift wheel to horizontal scroll
                                if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
                                    ev.wheelX = ev.wheelY;
                                    ev.wheelY = 0;
                                }
                                var editor = this.editor;
                                if (!this.$lastScroll) this.$lastScroll = {
                                    t: 0,
                                    vx: 0,
                                    vy: 0,
                                    allowed: 0
                                };
                                var prevScroll = this.$lastScroll;
                                var t = ev.domEvent.timeStamp;
                                var dt = t - prevScroll.t;
                                var vx = dt ? ev.wheelX / dt : prevScroll.vx;
                                var vy = dt ? ev.wheelY / dt : prevScroll.vy;
                                // touchbar keeps sending scroll events after touchend, if we do not stop these events,
                                // users can't scrol editor without scrolling the parent node
                                if (dt < SCROLL_COOLDOWN_T) {
                                    vx = (vx + prevScroll.vx) / 2;
                                    vy = (vy + prevScroll.vy) / 2;
                                }
                                var direction = Math.abs(vx / vy);
                                var canScroll = false;
                                if (direction >= 1 && editor.renderer.isScrollableBy(ev.wheelX * ev.speed, 0)) canScroll = true;
                                if (direction <= 1 && editor.renderer.isScrollableBy(0, ev.wheelY * ev.speed)) canScroll = true;
                                if (canScroll) {
                                    prevScroll.allowed = t;
                                } else if (t - prevScroll.allowed < SCROLL_COOLDOWN_T) {
                                    var isSlower = Math.abs(vx) <= 1.5 * Math.abs(prevScroll.vx) && Math.abs(vy) <= 1.5 * Math.abs(prevScroll.vy);
                                    if (isSlower) {
                                        canScroll = true;
                                        prevScroll.allowed = t;
                                    } else {
                                        prevScroll.allowed = 0;
                                    }
                                }
                                prevScroll.t = t;
                                prevScroll.vx = vx;
                                prevScroll.vy = vy;
                                if (canScroll) {
                                    editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
                                    return ev.stop();
                                }
                            }
                        }
                    ]);
                    return DefaultHandlers;
                }();
                DefaultHandlers.prototype.selectEnd = DefaultHandlers.prototype.selectByLinesEnd;
                DefaultHandlers.prototype.selectAllEnd = DefaultHandlers.prototype.selectByLinesEnd;
                DefaultHandlers.prototype.selectByWordsEnd = DefaultHandlers.prototype.selectByLinesEnd;
                exports1.z = DefaultHandlers;
            /***/ },
            /***/ 2482: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_937927__) {
                "use strict";
                var DragdropHandler = function DragdropHandler(mouseHandler) {
                    var editor = mouseHandler.editor;
                    var dragImage = dom.createElement("div");
                    dragImage.style.cssText = "top:-100px;position:absolute;z-index:2147483647;opacity:0.5";
                    dragImage.textContent = "\xa0";
                    var _$exports = [
                        "dragWait",
                        "dragWaitEnd",
                        "startDrag",
                        "dragReadyEnd",
                        "onMouseDrag"
                    ];
                    _$exports.forEach(function(x) {
                        mouseHandler[x] = this[x];
                    }, this);
                    editor.on("mousedown", this.onMouseDown.bind(mouseHandler));
                    var mouseTarget = editor.container;
                    var dragSelectionMarker, x, y;
                    var timerId, range;
                    var dragCursor, counter = 0;
                    var dragOperation;
                    var isInternal;
                    var autoScrollStartTime;
                    var cursorMovedTime;
                    var cursorPointOnCaretMoved;
                    this.onDragStart = function(e) {
                        // webkit workaround, see this.onMouseDown
                        if (this.cancelDrag || !mouseTarget.draggable) {
                            var _$self = this;
                            setTimeout(function() {
                                _$self.startSelect();
                                _$self.captureMouse(e);
                            }, 0);
                            return e.preventDefault();
                        }
                        range = editor.getSelectionRange();
                        var dataTransfer = e.dataTransfer;
                        dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
                        editor.container.appendChild(dragImage);
                        dataTransfer.setDragImage && dataTransfer.setDragImage(dragImage, 0, 0);
                        setTimeout(function() {
                            editor.container.removeChild(dragImage);
                        });
                        // clear Opera garbage
                        dataTransfer.clearData();
                        dataTransfer.setData("Text", editor.session.getTextRange());
                        isInternal = true;
                        this.setState("drag");
                    };
                    this.onDragEnd = function(e) {
                        mouseTarget.draggable = false;
                        isInternal = false;
                        this.setState(null);
                        if (!editor.getReadOnly()) {
                            var dropEffect = e.dataTransfer.dropEffect;
                            if (!dragOperation && dropEffect == "move") // text was dragged outside the editor
                            editor.session.remove(editor.getSelectionRange());
                            editor.$resetCursorStyle();
                        }
                        this.editor.unsetStyle("ace_dragging");
                        this.editor.renderer.setCursorStyle("");
                    };
                    this.onDragEnter = function(e) {
                        if (editor.getReadOnly() || !canAccept(e.dataTransfer)) return;
                        x = e.clientX;
                        y = e.clientY;
                        if (!dragSelectionMarker) addDragMarker();
                        counter++;
                        // dataTransfer object does not save dropEffect across events on IE, so we store it in dragOperation
                        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
                        return event.preventDefault(e);
                    };
                    this.onDragOver = function(e) {
                        if (editor.getReadOnly() || !canAccept(e.dataTransfer)) return;
                        x = e.clientX;
                        y = e.clientY;
                        // Opera doesn't trigger dragenter event on drag start
                        if (!dragSelectionMarker) {
                            addDragMarker();
                            counter++;
                        }
                        if (onMouseMoveTimer !== null) onMouseMoveTimer = null;
                        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
                        return event.preventDefault(e);
                    };
                    this.onDragLeave = function(e) {
                        counter--;
                        if (counter <= 0 && dragSelectionMarker) {
                            clearDragMarker();
                            dragOperation = null;
                            return event.preventDefault(e);
                        }
                    };
                    this.onDrop = function(e) {
                        if (!dragCursor) return;
                        var dataTransfer = e.dataTransfer;
                        if (isInternal) {
                            switch(dragOperation){
                                case "move":
                                    if (range.contains(dragCursor.row, dragCursor.column)) {
                                        // clear selection
                                        range = {
                                            start: dragCursor,
                                            end: dragCursor
                                        };
                                    } else {
                                        // move text
                                        range = editor.moveText(range, dragCursor);
                                    }
                                    break;
                                case "copy":
                                    // copy text
                                    range = editor.moveText(range, dragCursor, true);
                                    break;
                            }
                        } else {
                            var dropData = dataTransfer.getData("Text");
                            range = {
                                start: dragCursor,
                                end: editor.session.insert(dragCursor, dropData)
                            };
                            editor.focus();
                            dragOperation = null;
                        }
                        clearDragMarker();
                        return event.preventDefault(e);
                    };
                    event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler), editor);
                    event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler), editor);
                    event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler), editor);
                    event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler), editor);
                    event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler), editor);
                    event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler), editor);
                    function scrollCursorIntoView(cursor, prevCursor) {
                        var now = Date.now();
                        var vMovement = !prevCursor || cursor.row != prevCursor.row;
                        var hMovement = !prevCursor || cursor.column != prevCursor.column;
                        if (!cursorMovedTime || vMovement || hMovement) {
                            editor.moveCursorToPosition(cursor);
                            cursorMovedTime = now;
                            cursorPointOnCaretMoved = {
                                x: x,
                                y: y
                            };
                        } else {
                            var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
                            if (distance > SCROLL_CURSOR_HYSTERESIS) {
                                cursorMovedTime = null;
                            } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
                                editor.renderer.scrollCursorIntoView();
                                cursorMovedTime = null;
                            }
                        }
                    }
                    function autoScroll(cursor, prevCursor) {
                        var now = Date.now();
                        var lineHeight = editor.renderer.layerConfig.lineHeight;
                        var characterWidth = editor.renderer.layerConfig.characterWidth;
                        var editorRect = editor.renderer.scroller.getBoundingClientRect();
                        var offsets = {
                            x: {
                                left: x - editorRect.left,
                                right: editorRect.right - x
                            },
                            y: {
                                top: y - editorRect.top,
                                bottom: editorRect.bottom - y
                            }
                        };
                        var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
                        var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
                        var scrollCursor = {
                            row: cursor.row,
                            column: cursor.column
                        };
                        if (nearestXOffset / characterWidth <= 2) {
                            scrollCursor.column += offsets.x.left < offsets.x.right ? -3 : +2;
                        }
                        if (nearestYOffset / lineHeight <= 1) {
                            scrollCursor.row += offsets.y.top < offsets.y.bottom ? -1 : +1;
                        }
                        var vScroll = cursor.row != scrollCursor.row;
                        var hScroll = cursor.column != scrollCursor.column;
                        var vMovement = !prevCursor || cursor.row != prevCursor.row;
                        if (vScroll || hScroll && !vMovement) {
                            if (!autoScrollStartTime) autoScrollStartTime = now;
                            else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY) editor.renderer.scrollCursorIntoView(scrollCursor);
                        } else {
                            autoScrollStartTime = null;
                        }
                    }
                    function onDragInterval() {
                        var prevCursor = dragCursor;
                        dragCursor = editor.renderer.screenToTextCoordinates(x, y);
                        scrollCursorIntoView(dragCursor, prevCursor);
                        autoScroll(dragCursor, prevCursor);
                    }
                    function addDragMarker() {
                        range = editor.selection.toOrientedRange();
                        dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
                        editor.clearSelection();
                        if (editor.isFocused()) editor.renderer.$cursorLayer.setBlinking(false);
                        clearInterval(timerId);
                        onDragInterval();
                        timerId = setInterval(onDragInterval, 20);
                        counter = 0;
                        event.addListener(document, "mousemove", onMouseMove);
                    }
                    function clearDragMarker() {
                        clearInterval(timerId);
                        editor.session.removeMarker(dragSelectionMarker);
                        dragSelectionMarker = null;
                        editor.selection.fromOrientedRange(range);
                        if (editor.isFocused() && !isInternal) editor.$resetCursorStyle();
                        range = null;
                        dragCursor = null;
                        counter = 0;
                        autoScrollStartTime = null;
                        cursorMovedTime = null;
                        event.removeListener(document, "mousemove", onMouseMove);
                    }
                    // sometimes other code on the page can stop dragleave event leaving editor stuck in the drag state
                    var onMouseMoveTimer = null;
                    function onMouseMove() {
                        if (onMouseMoveTimer == null) {
                            onMouseMoveTimer = setTimeout(function() {
                                if (onMouseMoveTimer != null && dragSelectionMarker) clearDragMarker();
                            }, 20);
                        }
                    }
                    function canAccept(dataTransfer) {
                        var types = dataTransfer.types;
                        return !types || Array.prototype.some.call(types, function(type) {
                            return type == "text/plain" || type == "Text";
                        });
                    }
                    function getDropEffect(e) {
                        var copyAllowed = [
                            "copy",
                            "copymove",
                            "all",
                            "uninitialized"
                        ];
                        var moveAllowed = [
                            "move",
                            "copymove",
                            "linkmove",
                            "all",
                            "uninitialized"
                        ];
                        var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;
                        // IE throws error while dragging from another app
                        var effectAllowed = "uninitialized";
                        try {
                            effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
                        } catch (e) {}
                        var dropEffect = "none";
                        if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0) dropEffect = "copy";
                        else if (moveAllowed.indexOf(effectAllowed) >= 0) dropEffect = "move";
                        else if (copyAllowed.indexOf(effectAllowed) >= 0) dropEffect = "copy";
                        return dropEffect;
                    }
                };
                var calcDistance = function calcDistance(ax, ay, bx, by) {
                    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
                };
                var dom = __nested_webpack_require_937927__(5336);
                var event = __nested_webpack_require_937927__(8215);
                var useragent = __nested_webpack_require_937927__(8057);
                var AUTOSCROLL_DELAY = 200;
                var SCROLL_CURSOR_DELAY = 200;
                var SCROLL_CURSOR_HYSTERESIS = 5;
                (function() {
                    this.dragWait = function() {
                        var interval = Date.now() - this.mousedownEvent.time;
                        if (interval > this.editor.getDragDelay()) this.startDrag();
                    };
                    this.dragWaitEnd = function() {
                        var target = this.editor.container;
                        target.draggable = false;
                        this.startSelect(this.mousedownEvent.getDocumentPosition());
                        this.selectEnd();
                    };
                    this.dragReadyEnd = function(e) {
                        this.editor.$resetCursorStyle();
                        this.editor.unsetStyle("ace_dragging");
                        this.editor.renderer.setCursorStyle("");
                        this.dragWaitEnd();
                    };
                    this.startDrag = function() {
                        this.cancelDrag = false;
                        var editor = this.editor;
                        var target = editor.container;
                        target.draggable = true;
                        editor.renderer.$cursorLayer.setBlinking(false);
                        editor.setStyle("ace_dragging");
                        var cursorStyle = useragent.isWin ? "default" : "move";
                        editor.renderer.setCursorStyle(cursorStyle);
                        this.setState("dragReady");
                    };
                    this.onMouseDrag = function(e) {
                        var target = this.editor.container;
                        if (useragent.isIE && this.state == "dragReady") {
                            // IE does not handle [draggable] attribute set after mousedown
                            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
                            if (distance > 3) target.dragDrop();
                        }
                        if (this.state === "dragWait") {
                            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
                            if (distance > 0) {
                                target.draggable = false;
                                this.startSelect(this.mousedownEvent.getDocumentPosition());
                            }
                        }
                    };
                    this.onMouseDown = function(e) {
                        if (!this.$dragEnabled) return;
                        this.mousedownEvent = e;
                        var editor = this.editor;
                        var inSelection = e.inSelection();
                        var button = e.getButton();
                        var clickCount = e.domEvent.detail || 1;
                        if (clickCount === 1 && button === 0 && inSelection) {
                            if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey())) return;
                            this.mousedownEvent.time = Date.now();
                            var eventTarget = e.domEvent.target || e.domEvent.srcElement;
                            if ("unselectable" in eventTarget) eventTarget.unselectable = "on";
                            if (editor.getDragDelay()) {
                                // https://code.google.com/p/chromium/issues/detail?id=286700
                                if (useragent.isWebKit) {
                                    this.cancelDrag = true;
                                    var mouseTarget = editor.container;
                                    mouseTarget.draggable = true;
                                }
                                this.setState("dragWait");
                            } else {
                                this.startDrag();
                            }
                            this.captureMouse(e, this.onMouseDrag.bind(this));
                            // TODO: a better way to prevent default handler without preventing browser default action
                            e.defaultPrevented = true;
                        }
                    };
                }).call(DragdropHandler.prototype);
                exports1.q = DragdropHandler;
            /***/ },
            /***/ 6049: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_957501__) {
                "use strict";
                var dom = __nested_webpack_require_957501__(5336);
                var FoldHandler = function FoldHandler(editor) {
                    _class_call_check(this, FoldHandler);
                    editor.on("click", function(e) {
                        var position = e.getDocumentPosition();
                        var session = editor.session;
                        // If the user clicked on a fold, then expand it.
                        var fold = session.getFoldAt(position.row, position.column, 1);
                        if (fold) {
                            if (e.getAccelKey()) session.removeFold(fold);
                            else session.expandFold(fold);
                            e.stop();
                        }
                        var target = e.domEvent && e.domEvent.target;
                        if (target && dom.hasCssClass(target, "ace_inline_button")) {
                            if (dom.hasCssClass(target, "ace_toggle_wrap")) {
                                session.setOption("wrap", !session.getUseWrapMode());
                                editor.renderer.scrollCursorIntoView();
                            }
                        }
                    });
                    editor.on("gutterclick", function(e) {
                        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
                        if (gutterRegion == "foldWidgets") {
                            var row = e.getDocumentPosition().row;
                            var session = editor.session;
                            if (session.foldWidgets && session.foldWidgets[row]) editor.session.onFoldWidgetClick(row, e);
                            if (!editor.isFocused()) editor.focus();
                            e.stop();
                        }
                    });
                    editor.on("gutterdblclick", function(e) {
                        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
                        if (gutterRegion == "foldWidgets") {
                            var row = e.getDocumentPosition().row;
                            var session = editor.session;
                            var data = session.getParentFoldRangeData(row, true);
                            var range = data.range || data.firstRange;
                            if (range) {
                                row = range.start.row;
                                var fold = session.getFoldAt(row, session.getLine(row).length, 1);
                                if (fold) {
                                    session.removeFold(fold);
                                } else {
                                    session.addFold("...", range);
                                    editor.renderer.scrollCursorIntoView({
                                        row: range.start.row,
                                        column: 0
                                    });
                                }
                            }
                            e.stop();
                        }
                    });
                };
                exports1.z = FoldHandler;
            /***/ },
            /***/ 7224: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_960811__) {
                "use strict";
                var event = __nested_webpack_require_960811__(8215);
                var useragent = __nested_webpack_require_960811__(8057);
                /*
 * Custom Ace mouse event
 */ var MouseEvent = /*#__PURE__*/ function() {
                    function MouseEvent(domEvent, editor) {
                        _class_call_check(this, MouseEvent);
                        this.domEvent = domEvent;
                        this.editor = editor;
                        this.x = this.clientX = domEvent.clientX;
                        this.y = this.clientY = domEvent.clientY;
                        this.$pos = null;
                        this.$inSelection = null;
                        this.propagationStopped = false;
                        this.defaultPrevented = false;
                        this.getAccelKey = useragent.isMac ? function() {
                            return this.domEvent.metaKey;
                        } : function() {
                            return this.domEvent.ctrlKey;
                        };
                    }
                    _create_class(MouseEvent, [
                        {
                            key: "stopPropagation",
                            value: function stopPropagation() {
                                event.stopPropagation(this.domEvent);
                                this.propagationStopped = true;
                            }
                        },
                        {
                            key: "preventDefault",
                            value: function preventDefault() {
                                event.preventDefault(this.domEvent);
                                this.defaultPrevented = true;
                            }
                        },
                        {
                            key: "stop",
                            value: function stop() {
                                this.stopPropagation();
                                this.preventDefault();
                            }
                        },
                        {
                            /**
     * Get the document position below the mouse cursor
     * 
     * @return {Object} 'row' and 'column' of the document position
     */ key: "getDocumentPosition",
                            value: function getDocumentPosition() {
                                if (this.$pos) return this.$pos;
                                this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
                                return this.$pos;
                            }
                        },
                        {
                            /**
     * Check if the mouse cursor is inside of the text selection
     * 
     * @return {Boolean} whether the mouse cursor is inside of the selection
     */ key: "inSelection",
                            value: function inSelection() {
                                if (this.$inSelection !== null) return this.$inSelection;
                                var editor = this.editor;
                                var selectionRange = editor.getSelectionRange();
                                if (selectionRange.isEmpty()) this.$inSelection = false;
                                else {
                                    var pos = this.getDocumentPosition();
                                    this.$inSelection = selectionRange.contains(pos.row, pos.column);
                                }
                                return this.$inSelection;
                            }
                        },
                        {
                            /**
     * Get the clicked mouse button
     * 
     * @return {Number} 0 for left button, 1 for middle button, 2 for right button
     */ key: "getButton",
                            value: function getButton() {
                                return event.getButton(this.domEvent);
                            }
                        },
                        {
                            /**
     * @return {Boolean} whether the shift key was pressed when the event was emitted
     */ key: "getShiftKey",
                            value: function getShiftKey() {
                                return this.domEvent.shiftKey;
                            }
                        }
                    ]);
                    return MouseEvent;
                }();
                exports1.T = MouseEvent;
            /***/ },
            /***/ 6581: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_965431__) {
                "use strict";
                var event = __nested_webpack_require_965431__(8215);
                var useragent = __nested_webpack_require_965431__(8057);
                var DefaultHandlers = __nested_webpack_require_965431__(6763)/* .DefaultHandlers */ .z;
                var DefaultGutterHandler = __nested_webpack_require_965431__(4334)/* .GutterHandler */ .d;
                var MouseEvent = __nested_webpack_require_965431__(7224)/* .MouseEvent */ .T;
                var DragdropHandler = __nested_webpack_require_965431__(2482)/* .DragdropHandler */ .q;
                var addTouchListeners = __nested_webpack_require_965431__(461)/* .addTouchListeners */ .W;
                var config = __nested_webpack_require_965431__(3294);
                var MouseHandler = /*#__PURE__*/ function() {
                    function MouseHandler(editor) {
                        _class_call_check(this, MouseHandler);
                        var _self = this;
                        this.editor = editor;
                        new DefaultHandlers(this);
                        new DefaultGutterHandler(this);
                        new DragdropHandler(this);
                        var focusEditor = function focusEditor(e) {
                            // because we have to call event.preventDefault() any window on ie and iframes
                            // on other browsers do not get focus, so we have to call window.focus() here
                            var windowBlurred = !document.hasFocus || !document.hasFocus() || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement());
                            if (windowBlurred) window.focus();
                            editor.focus();
                            // Without this editor is blurred after double click
                            setTimeout(function() {
                                if (!editor.isFocused()) editor.focus();
                            });
                        };
                        var mouseTarget = editor.renderer.getMouseEventTarget();
                        event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"), editor);
                        event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"), editor);
                        event.addMultiMouseDownListener([
                            mouseTarget,
                            editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner,
                            editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner,
                            editor.textInput && editor.textInput.getElement()
                        ].filter(Boolean), [
                            400,
                            300,
                            250
                        ], this, "onMouseEvent", editor);
                        event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"), editor);
                        addTouchListeners(editor.container, editor);
                        var gutterEl = editor.renderer.$gutter;
                        event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"), editor);
                        event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"), editor);
                        event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"), editor);
                        event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"), editor);
                        event.addListener(mouseTarget, "mousedown", focusEditor, editor);
                        event.addListener(gutterEl, "mousedown", focusEditor, editor);
                        if (useragent.isIE && editor.renderer.scrollBarV) {
                            event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor, editor);
                            event.addListener(editor.renderer.scrollBarH.element, "mousedown", focusEditor, editor);
                        }
                        editor.on("mousemove", function(e) {
                            if (_self.state || _self.$dragDelay || !_self.$dragEnabled) return;
                            var character = editor.renderer.screenToTextCoordinates(e.x, e.y);
                            var range = editor.session.selection.getRange();
                            var renderer = editor.renderer;
                            if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
                                renderer.setCursorStyle("default");
                            } else {
                                renderer.setCursorStyle("");
                            }
                        }, editor);
                    }
                    _create_class(MouseHandler, [
                        {
                            key: "onMouseEvent",
                            value: function onMouseEvent(name, e) {
                                if (!this.editor.session) return;
                                this.editor._emit(name, new MouseEvent(e, this.editor));
                            }
                        },
                        {
                            key: "onMouseMove",
                            value: function onMouseMove(name, e) {
                                // optimization, because mousemove doesn't have a default handler.
                                var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
                                if (!listeners || !listeners.length) return;
                                this.editor._emit(name, new MouseEvent(e, this.editor));
                            }
                        },
                        {
                            key: "onMouseWheel",
                            value: function onMouseWheel(name, e) {
                                var mouseEvent = new MouseEvent(e, this.editor);
                                mouseEvent.speed = this.$scrollSpeed * 2;
                                mouseEvent.wheelX = e.wheelX;
                                mouseEvent.wheelY = e.wheelY;
                                this.editor._emit(name, mouseEvent);
                            }
                        },
                        {
                            key: "setState",
                            value: function setState(state) {
                                this.state = state;
                            }
                        },
                        {
                            key: "captureMouse",
                            value: function captureMouse(ev, mouseMoveHandler) {
                                this.x = ev.x;
                                this.y = ev.y;
                                this.isMousePressed = true;
                                // do not move textarea during selection
                                var editor = this.editor;
                                var renderer = this.editor.renderer;
                                renderer.$isMousePressed = true;
                                var _$self = this;
                                var onMouseMove = function onMouseMove(e) {
                                    if (!e) return;
                                    // if editor is loaded inside iframe, and mouseup event is outside
                                    // we won't recieve it, so we cancel on first mousemove without button
                                    if (useragent.isWebKit && !e.which && _$self.releaseMouse) return _$self.releaseMouse();
                                    _$self.x = e.clientX;
                                    _$self.y = e.clientY;
                                    mouseMoveHandler && mouseMoveHandler(e);
                                    _$self.mouseEvent = new MouseEvent(e, _$self.editor);
                                    _$self.$mouseMoved = true;
                                };
                                var onCaptureEnd = function onCaptureEnd(e) {
                                    editor.off("beforeEndOperation", onOperationEnd);
                                    clearInterval(timerId);
                                    if (editor.session) onCaptureInterval();
                                    _$self[_$self.state + "End"] && _$self[_$self.state + "End"](e);
                                    _$self.state = "";
                                    _$self.isMousePressed = renderer.$isMousePressed = false;
                                    if (renderer.$keepTextAreaAtCursor) renderer.$moveTextAreaToCursor();
                                    _$self.$onCaptureMouseMove = _$self.releaseMouse = null;
                                    e && _$self.onMouseEvent("mouseup", e);
                                    editor.endOperation();
                                };
                                var onCaptureInterval = function onCaptureInterval() {
                                    _$self[_$self.state] && _$self[_$self.state]();
                                    _$self.$mouseMoved = false;
                                };
                                if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
                                    return setTimeout(function() {
                                        onCaptureEnd(ev);
                                    });
                                }
                                var onOperationEnd = function onOperationEnd(e) {
                                    if (!_$self.releaseMouse) return;
                                    // some touchpads fire mouseup event after a slight delay, 
                                    // which can cause problems if user presses a keyboard shortcut quickly
                                    if (editor.curOp.command.name && editor.curOp.selectionChanged) {
                                        _$self[_$self.state + "End"] && _$self[_$self.state + "End"]();
                                        _$self.state = "";
                                        _$self.releaseMouse();
                                    }
                                };
                                editor.on("beforeEndOperation", onOperationEnd);
                                editor.startOperation({
                                    command: {
                                        name: "mouse"
                                    }
                                });
                                _$self.$onCaptureMouseMove = onMouseMove;
                                _$self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
                                var timerId = setInterval(onCaptureInterval, 20);
                            }
                        },
                        {
                            key: "cancelContextMenu",
                            value: function cancelContextMenu() {
                                var stop = (function(e) {
                                    if (e && e.domEvent && e.domEvent.type != "contextmenu") return;
                                    this.editor.off("nativecontextmenu", stop);
                                    if (e && e.domEvent) event.stopEvent(e.domEvent);
                                }).bind(this);
                                setTimeout(stop, 10);
                                this.editor.on("nativecontextmenu", stop);
                            }
                        },
                        {
                            key: "destroy",
                            value: function destroy() {
                                if (this.releaseMouse) this.releaseMouse();
                            }
                        }
                    ]);
                    return MouseHandler;
                }();
                MouseHandler.prototype.releaseMouse = null;
                config.defineOptions(MouseHandler.prototype, "mouseHandler", {
                    scrollSpeed: {
                        initialValue: 2
                    },
                    dragDelay: {
                        initialValue: useragent.isMac ? 150 : 0
                    },
                    dragEnabled: {
                        initialValue: true
                    },
                    focusTimeout: {
                        initialValue: 0
                    },
                    tooltipFollowsMouse: {
                        initialValue: true
                    }
                });
                exports1.S = MouseHandler;
            /***/ },
            /***/ 4486: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_978242__) {
                var isSamePoint = // mouse
                function isSamePoint(p1, p2) {
                    return p1.row == p2.row && p1.column == p2.column;
                };
                var onMouseDown = function onMouseDown(e) {
                    var ev = e.domEvent;
                    var alt = ev.altKey;
                    var shift = ev.shiftKey;
                    var ctrl = ev.ctrlKey;
                    var accel = e.getAccelKey();
                    var button = e.getButton();
                    if (ctrl && useragent.isMac) button = ev.button;
                    if (e.editor.inMultiSelectMode && button == 2) {
                        e.editor.textInput.onContextMenu(e.domEvent);
                        return;
                    }
                    if (!ctrl && !alt && !accel) {
                        if (button === 0 && e.editor.inMultiSelectMode) e.editor.exitMultiSelectMode();
                        return;
                    }
                    if (button !== 0) return;
                    var editor = e.editor;
                    var selection = editor.selection;
                    var isMultiSelect = editor.inMultiSelectMode;
                    var pos = e.getDocumentPosition();
                    var cursor = selection.getCursor();
                    var inSelection = e.inSelection() || selection.isEmpty() && isSamePoint(pos, cursor);
                    var mouseX = e.x, mouseY = e.y;
                    var onMouseSelection = function onMouseSelection(e) {
                        mouseX = e.clientX;
                        mouseY = e.clientY;
                    };
                    var session = editor.session;
                    var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
                    var screenCursor = screenAnchor;
                    var selectionMode;
                    if (editor.$mouseHandler.$enableJumpToDef) {
                        if (ctrl && alt || accel && alt) selectionMode = shift ? "block" : "add";
                        else if (alt && editor.$blockSelectEnabled) selectionMode = "block";
                    } else {
                        if (accel && !alt) {
                            selectionMode = "add";
                            if (!isMultiSelect && shift) return;
                        } else if (alt && editor.$blockSelectEnabled) {
                            selectionMode = "block";
                        }
                    }
                    if (selectionMode && useragent.isMac && ev.ctrlKey) {
                        editor.$mouseHandler.cancelContextMenu();
                    }
                    if (selectionMode == "add") {
                        if (!isMultiSelect && inSelection) return; // dragging
                        if (!isMultiSelect) {
                            var range = selection.toOrientedRange();
                            editor.addSelectionMarker(range);
                        }
                        var oldRange = selection.rangeList.rangeAtPoint(pos);
                        editor.inVirtualSelectionMode = true;
                        if (shift) {
                            oldRange = null;
                            range = selection.ranges[0] || range;
                            editor.removeSelectionMarker(range);
                        }
                        editor.once("mouseup", function() {
                            var tmpSel = selection.toOrientedRange();
                            if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor)) selection.substractPoint(tmpSel.cursor);
                            else {
                                if (shift) {
                                    selection.substractPoint(range.cursor);
                                } else if (range) {
                                    editor.removeSelectionMarker(range);
                                    selection.addRange(range);
                                }
                                selection.addRange(tmpSel);
                            }
                            editor.inVirtualSelectionMode = false;
                        });
                    } else if (selectionMode == "block") {
                        e.stop();
                        editor.inVirtualSelectionMode = true;
                        var initialRange;
                        var rectSel = [];
                        var blockSelect = function blockSelect() {
                            var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
                            var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column, newCursor.offsetX);
                            if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead)) return;
                            screenCursor = newCursor;
                            editor.selection.moveToPosition(cursor);
                            editor.renderer.scrollCursorIntoView();
                            editor.removeSelectionMarkers(rectSel);
                            rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
                            if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty()) rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
                            rectSel.forEach(editor.addSelectionMarker, editor);
                            editor.updateSelectionMarkers();
                        };
                        if (isMultiSelect && !accel) {
                            selection.toSingleRange();
                        } else if (!isMultiSelect && accel) {
                            initialRange = selection.toOrientedRange();
                            editor.addSelectionMarker(initialRange);
                        }
                        if (shift) screenAnchor = session.documentToScreenPosition(selection.lead);
                        else selection.moveToPosition(pos);
                        screenCursor = {
                            row: -1,
                            column: -1
                        };
                        var onMouseSelectionEnd = function onMouseSelectionEnd(e) {
                            blockSelect();
                            clearInterval(timerId);
                            editor.removeSelectionMarkers(rectSel);
                            if (!rectSel.length) rectSel = [
                                selection.toOrientedRange()
                            ];
                            if (initialRange) {
                                editor.removeSelectionMarker(initialRange);
                                selection.toSingleRange(initialRange);
                            }
                            for(var i = 0; i < rectSel.length; i++)selection.addRange(rectSel[i]);
                            editor.inVirtualSelectionMode = false;
                            editor.$mouseHandler.$clickSelection = null;
                        };
                        var onSelectionInterval = blockSelect;
                        event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
                        var timerId = setInterval(function() {
                            onSelectionInterval();
                        }, 20);
                        return e.preventDefault();
                    }
                };
                var event = __nested_webpack_require_978242__(8215);
                var useragent = __nested_webpack_require_978242__(8057);
                exports1.P = onMouseDown;
            /***/ },
            /***/ 461: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_986014__) {
                "use strict";
                var MouseEvent = __nested_webpack_require_986014__(7224)/* .MouseEvent */ .T;
                var event = __nested_webpack_require_986014__(8215);
                var dom = __nested_webpack_require_986014__(5336);
                exports1.W = function(el, editor) {
                    var createContextMenu = function createContextMenu() {
                        var clipboard = window.navigator && window.navigator.clipboard;
                        var isOpen = false;
                        var updateMenu = function updateMenu() {
                            var selected = editor.getCopyText();
                            var hasUndo = editor.session.getUndoManager().hasUndo();
                            contextMenu.replaceChild(dom.buildDom(isOpen ? [
                                "span",
                                !selected && [
                                    "span",
                                    {
                                        class: "ace_mobile-button",
                                        action: "selectall"
                                    },
                                    "Select All"
                                ],
                                selected && [
                                    "span",
                                    {
                                        class: "ace_mobile-button",
                                        action: "copy"
                                    },
                                    "Copy"
                                ],
                                selected && [
                                    "span",
                                    {
                                        class: "ace_mobile-button",
                                        action: "cut"
                                    },
                                    "Cut"
                                ],
                                clipboard && [
                                    "span",
                                    {
                                        class: "ace_mobile-button",
                                        action: "paste"
                                    },
                                    "Paste"
                                ],
                                hasUndo && [
                                    "span",
                                    {
                                        class: "ace_mobile-button",
                                        action: "undo"
                                    },
                                    "Undo"
                                ],
                                [
                                    "span",
                                    {
                                        class: "ace_mobile-button",
                                        action: "find"
                                    },
                                    "Find"
                                ],
                                [
                                    "span",
                                    {
                                        class: "ace_mobile-button",
                                        action: "openCommandPallete"
                                    },
                                    "Palette"
                                ]
                            ] : [
                                "span"
                            ]), contextMenu.firstChild);
                        };
                        var handleClick = function handleClick(e) {
                            var action = e.target.getAttribute("action");
                            if (action == "more" || !isOpen) {
                                isOpen = !isOpen;
                                return updateMenu();
                            }
                            if (action == "paste") {
                                clipboard.readText().then(function(text) {
                                    editor.execCommand(action, text);
                                });
                            } else if (action) {
                                if (action == "cut" || action == "copy") {
                                    if (clipboard) clipboard.writeText(editor.getCopyText());
                                    else document.execCommand("copy");
                                }
                                editor.execCommand(action);
                            }
                            contextMenu.firstChild.style.display = "none";
                            isOpen = false;
                            if (action != "openCommandPallete") editor.focus();
                        };
                        contextMenu = dom.buildDom([
                            "div",
                            {
                                class: "ace_mobile-menu",
                                ontouchstart: function ontouchstart(e) {
                                    mode = "menu";
                                    e.stopPropagation();
                                    e.preventDefault();
                                    editor.textInput.focus();
                                },
                                ontouchend: function ontouchend(e) {
                                    e.stopPropagation();
                                    e.preventDefault();
                                    handleClick(e);
                                },
                                onclick: handleClick
                            },
                            [
                                "span"
                            ],
                            [
                                "span",
                                {
                                    class: "ace_mobile-button",
                                    action: "more"
                                },
                                "..."
                            ]
                        ], editor.container);
                    };
                    var showContextMenu = function showContextMenu() {
                        if (!contextMenu) createContextMenu();
                        var cursor = editor.selection.cursor;
                        var pagePos = editor.renderer.textToScreenCoordinates(cursor.row, cursor.column);
                        var leftOffset = editor.renderer.textToScreenCoordinates(0, 0).pageX;
                        var scrollLeft = editor.renderer.scrollLeft;
                        var rect = editor.container.getBoundingClientRect();
                        contextMenu.style.top = pagePos.pageY - rect.top - 3 + "px";
                        if (pagePos.pageX - rect.left < rect.width - 70) {
                            contextMenu.style.left = "";
                            contextMenu.style.right = "10px";
                        } else {
                            contextMenu.style.right = "";
                            contextMenu.style.left = leftOffset + scrollLeft - rect.left + "px";
                        }
                        contextMenu.style.display = "";
                        contextMenu.firstChild.style.display = "none";
                        editor.on("input", hideContextMenu);
                    };
                    var handleLongTap = function handleLongTap() {
                        longTouchTimer = null;
                        clearTimeout(longTouchTimer);
                        var range = editor.selection.getRange();
                        var inSelection = range.contains(pos.row, pos.column);
                        if (range.isEmpty() || !inSelection) {
                            editor.selection.moveToPosition(pos);
                            editor.selection.selectWord();
                        }
                        mode = "wait";
                        showContextMenu();
                    };
                    var switchToSelectionMode = function switchToSelectionMode() {
                        longTouchTimer = null;
                        clearTimeout(longTouchTimer);
                        editor.selection.moveToPosition(pos);
                        var range = clickCount >= 2 ? editor.selection.getLineRange(pos.row) : editor.session.getBracketRange(pos);
                        if (range && !range.isEmpty()) {
                            editor.selection.setRange(range);
                        } else {
                            editor.selection.selectWord();
                        }
                        mode = "wait";
                    };
                    var animate = function animate() {
                        animationSteps += 60;
                        animationTimer = setInterval(function() {
                            if (animationSteps-- <= 0) {
                                clearInterval(animationTimer);
                                animationTimer = null;
                            }
                            if (Math.abs(vX) < 0.01) vX = 0;
                            if (Math.abs(vY) < 0.01) vY = 0;
                            if (animationSteps < 20) vX = 0.9 * vX;
                            if (animationSteps < 20) vY = 0.9 * vY;
                            var oldScrollTop = editor.session.getScrollTop();
                            editor.renderer.scrollBy(10 * vX, 10 * vY);
                            if (oldScrollTop == editor.session.getScrollTop()) animationSteps = 0;
                        }, 10);
                    };
                    var mode = "scroll";
                    var startX;
                    var startY;
                    var touchStartT;
                    var lastT;
                    var longTouchTimer;
                    var animationTimer;
                    var animationSteps = 0;
                    var pos;
                    var clickCount = 0;
                    var vX = 0;
                    var vY = 0;
                    var pressed;
                    var contextMenu;
                    function hideContextMenu(e) {
                        if (contextMenu) contextMenu.style.display = "none";
                        editor.off("input", hideContextMenu);
                    }
                    event.addListener(el, "contextmenu", function(e) {
                        if (!pressed) return;
                        var textarea = editor.textInput.getElement();
                        textarea.focus();
                    }, editor);
                    event.addListener(el, "touchstart", function(e) {
                        var touches = e.touches;
                        if (longTouchTimer || touches.length > 1) {
                            clearTimeout(longTouchTimer);
                            longTouchTimer = null;
                            touchStartT = -1;
                            mode = "zoom";
                            return;
                        }
                        pressed = editor.$mouseHandler.isMousePressed = true;
                        var h = editor.renderer.layerConfig.lineHeight;
                        var w = editor.renderer.layerConfig.lineHeight;
                        var t = e.timeStamp;
                        lastT = t;
                        var touchObj = touches[0];
                        var x = touchObj.clientX;
                        var y = touchObj.clientY;
                        // reset clickCount if the new touch is far from the old one
                        if (Math.abs(startX - x) + Math.abs(startY - y) > h) touchStartT = -1;
                        startX = e.clientX = x;
                        startY = e.clientY = y;
                        vX = vY = 0;
                        var ev = new MouseEvent(e, editor);
                        pos = ev.getDocumentPosition();
                        if (t - touchStartT < 500 && touches.length == 1 && !animationSteps) {
                            clickCount++;
                            e.preventDefault();
                            e.button = 0;
                            switchToSelectionMode();
                        } else {
                            clickCount = 0;
                            var cursor = editor.selection.cursor;
                            var anchor = editor.selection.isEmpty() ? cursor : editor.selection.anchor;
                            var cursorPos = editor.renderer.$cursorLayer.getPixelPosition(cursor, true);
                            var anchorPos = editor.renderer.$cursorLayer.getPixelPosition(anchor, true);
                            var rect = editor.renderer.scroller.getBoundingClientRect();
                            var offsetTop = editor.renderer.layerConfig.offset;
                            var offsetLeft = editor.renderer.scrollLeft;
                            var weightedDistance = function weightedDistance(x, y) {
                                x = x / w;
                                y = y / h - 0.75;
                                return x * x + y * y;
                            };
                            if (e.clientX < rect.left) {
                                mode = "zoom";
                                return;
                            }
                            var diff1 = weightedDistance(e.clientX - rect.left - cursorPos.left + offsetLeft, e.clientY - rect.top - cursorPos.top + offsetTop);
                            var diff2 = weightedDistance(e.clientX - rect.left - anchorPos.left + offsetLeft, e.clientY - rect.top - anchorPos.top + offsetTop);
                            if (diff1 < 3.5 && diff2 < 3.5) mode = diff1 > diff2 ? "cursor" : "anchor";
                            if (diff2 < 3.5) mode = "anchor";
                            else if (diff1 < 3.5) mode = "cursor";
                            else mode = "scroll";
                            longTouchTimer = setTimeout(handleLongTap, 450);
                        }
                        touchStartT = t;
                    }, editor);
                    event.addListener(el, "touchend", function(e) {
                        pressed = editor.$mouseHandler.isMousePressed = false;
                        if (animationTimer) clearInterval(animationTimer);
                        if (mode == "zoom") {
                            mode = "";
                            animationSteps = 0;
                        } else if (longTouchTimer) {
                            editor.selection.moveToPosition(pos);
                            animationSteps = 0;
                            showContextMenu();
                        } else if (mode == "scroll") {
                            animate();
                            hideContextMenu();
                        } else {
                            showContextMenu();
                        }
                        clearTimeout(longTouchTimer);
                        longTouchTimer = null;
                    }, editor);
                    event.addListener(el, "touchmove", function(e) {
                        if (longTouchTimer) {
                            clearTimeout(longTouchTimer);
                            longTouchTimer = null;
                        }
                        var touches = e.touches;
                        if (touches.length > 1 || mode == "zoom") return;
                        var touchObj = touches[0];
                        var wheelX = startX - touchObj.clientX;
                        var wheelY = startY - touchObj.clientY;
                        if (mode == "wait") {
                            if (wheelX * wheelX + wheelY * wheelY > 4) mode = "cursor";
                            else return e.preventDefault();
                        }
                        startX = touchObj.clientX;
                        startY = touchObj.clientY;
                        e.clientX = touchObj.clientX;
                        e.clientY = touchObj.clientY;
                        var t = e.timeStamp;
                        var dt = t - lastT;
                        lastT = t;
                        if (mode == "scroll") {
                            var mouseEvent = new MouseEvent(e, editor);
                            mouseEvent.speed = 1;
                            mouseEvent.wheelX = wheelX;
                            mouseEvent.wheelY = wheelY;
                            if (10 * Math.abs(wheelX) < Math.abs(wheelY)) wheelX = 0;
                            if (10 * Math.abs(wheelY) < Math.abs(wheelX)) wheelY = 0;
                            if (dt != 0) {
                                vX = wheelX / dt;
                                vY = wheelY / dt;
                            }
                            editor._emit("mousewheel", mouseEvent);
                            if (!mouseEvent.propagationStopped) {
                                vX = vY = 0;
                            }
                        } else {
                            var ev = new MouseEvent(e, editor);
                            var pos = ev.getDocumentPosition();
                            if (mode == "cursor") editor.selection.moveCursorToPosition(pos);
                            else if (mode == "anchor") editor.selection.setSelectionAnchor(pos.row, pos.column);
                            editor.renderer.scrollCursorIntoView(pos);
                            e.preventDefault();
                        }
                    }, editor);
                };
            /***/ },
            /***/ 5403: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1003684__) {
                var find = function find(session, needle, dir) {
                    search.$options.wrap = true;
                    search.$options.needle = needle;
                    search.$options.backwards = dir == -1;
                    return search.find(session);
                };
                var isSamePoint = function isSamePoint(p1, p2) {
                    return p1.row == p2.row && p1.column == p2.column;
                };
                var MultiSelect = // MultiSelect(editor)
                // adds multiple selection support to the editor
                // (note: should be called only once for each editor instance)
                function MultiSelect(editor) {
                    if (editor.$multiselectOnSessionChange) return;
                    editor.$onAddRange = editor.$onAddRange.bind(editor);
                    editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
                    editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
                    editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
                    editor.$multiselectOnSessionChange = exports1.onSessionChange.bind(editor);
                    editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);
                    editor.$multiselectOnSessionChange(editor);
                    editor.on("changeSession", editor.$multiselectOnSessionChange);
                    editor.on("mousedown", onMouseDown);
                    editor.commands.addCommands(commands.defaultCommands);
                    addAltCursorListeners(editor);
                };
                var addAltCursorListeners = function addAltCursorListeners(editor) {
                    if (!editor.textInput) return;
                    var el = editor.textInput.getElement();
                    var altCursor = false;
                    event.addListener(el, "keydown", function(e) {
                        var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);
                        if (editor.$blockSelectEnabled && altDown) {
                            if (!altCursor) {
                                editor.renderer.setMouseCursor("crosshair");
                                altCursor = true;
                            }
                        } else if (altCursor) {
                            reset();
                        }
                    }, editor);
                    event.addListener(el, "keyup", reset, editor);
                    event.addListener(el, "blur", reset, editor);
                    function reset(e) {
                        if (altCursor) {
                            editor.renderer.setMouseCursor("");
                            altCursor = false;
                        // TODO disable menu popping up
                        // e && e.preventDefault()
                        }
                    }
                };
                var RangeList1 = __nested_webpack_require_1003684__(9204)/* .RangeList */ .$;
                var Range = __nested_webpack_require_1003684__(3069)/* .Range */ .e;
                var Selection = __nested_webpack_require_1003684__(4720)/* .Selection */ .Y;
                var onMouseDown = __nested_webpack_require_1003684__(4486)/* .onMouseDown */ .P;
                var event = __nested_webpack_require_1003684__(8215);
                var lang = __nested_webpack_require_1003684__(732);
                var commands = __nested_webpack_require_1003684__(2051);
                exports1.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
                // Todo: session.find or editor.findVolatile that returns range
                var Search = __nested_webpack_require_1003684__(3002)/* .Search */ .o;
                var search = new Search();
                // extend EditSession
                var EditSession = __nested_webpack_require_1003684__(8827)/* .EditSession */ .m;
                (function() {
                    this.getSelectionMarkers = function() {
                        return this.$selectionMarkers;
                    };
                }).call(EditSession.prototype);
                // extend Selection
                (function() {
                    // list of ranges in reverse addition order
                    this.ranges = null;
                    // automatically sorted list of ranges
                    this.rangeList = null;
                    /** 
     * Adds a range to a selection by entering multiselect mode, if necessary.
     * @param {Range} range The new range to add
     * @param {Boolean} $blockChangeEvents Whether or not to block changing events
     * @method Selection.addRange
     **/ this.addRange = function(range, $blockChangeEvents) {
                        if (!range) return;
                        if (!this.inMultiSelectMode && this.rangeCount === 0) {
                            var oldRange = this.toOrientedRange();
                            this.rangeList.add(oldRange);
                            this.rangeList.add(range);
                            if (this.rangeList.ranges.length != 2) {
                                this.rangeList.removeAll();
                                return $blockChangeEvents || this.fromOrientedRange(range);
                            }
                            this.rangeList.removeAll();
                            this.rangeList.add(oldRange);
                            this.$onAddRange(oldRange);
                        }
                        if (!range.cursor) range.cursor = range.end;
                        var removed = this.rangeList.add(range);
                        this.$onAddRange(range);
                        if (removed.length) this.$onRemoveRange(removed);
                        if (this.rangeCount > 1 && !this.inMultiSelectMode) {
                            this._signal("multiSelect");
                            this.inMultiSelectMode = true;
                            this.session.$undoSelect = false;
                            this.rangeList.attach(this.session);
                        }
                        return $blockChangeEvents || this.fromOrientedRange(range);
                    };
                    /**
     * @method Selection.toSingleRange
     **/ this.toSingleRange = function(range) {
                        range = range || this.ranges[0];
                        var removed = this.rangeList.removeAll();
                        if (removed.length) this.$onRemoveRange(removed);
                        range && this.fromOrientedRange(range);
                    };
                    /**
     * Removes a Range containing pos (if it exists).
     * @param {Range} pos The position to remove, as a `{row, column}` object
     * @method Selection.substractPoint
     **/ this.substractPoint = function(pos) {
                        var removed = this.rangeList.substractPoint(pos);
                        if (removed) {
                            this.$onRemoveRange(removed);
                            return removed[0];
                        }
                    };
                    /**
     * Merges overlapping ranges ensuring consistency after changes
     * @method Selection.mergeOverlappingRanges
     **/ this.mergeOverlappingRanges = function() {
                        var removed = this.rangeList.merge();
                        if (removed.length) this.$onRemoveRange(removed);
                    };
                    this.$onAddRange = function(range) {
                        this.rangeCount = this.rangeList.ranges.length;
                        this.ranges.unshift(range);
                        this._signal("addRange", {
                            range: range
                        });
                    };
                    this.$onRemoveRange = function(removed) {
                        this.rangeCount = this.rangeList.ranges.length;
                        if (this.rangeCount == 1 && this.inMultiSelectMode) {
                            var lastRange = this.rangeList.ranges.pop();
                            removed.push(lastRange);
                            this.rangeCount = 0;
                        }
                        for(var i = removed.length; i--;){
                            var index = this.ranges.indexOf(removed[i]);
                            this.ranges.splice(index, 1);
                        }
                        this._signal("removeRange", {
                            ranges: removed
                        });
                        if (this.rangeCount === 0 && this.inMultiSelectMode) {
                            this.inMultiSelectMode = false;
                            this._signal("singleSelect");
                            this.session.$undoSelect = true;
                            this.rangeList.detach(this.session);
                        }
                        lastRange = lastRange || this.ranges[0];
                        if (lastRange && !lastRange.isEqual(this.getRange())) this.fromOrientedRange(lastRange);
                    };
                    // adds multicursor support to selection
                    this.$initRangeList = function() {
                        if (this.rangeList) return;
                        this.rangeList = new RangeList1();
                        this.ranges = [];
                        this.rangeCount = 0;
                    };
                    /**
     * Returns a concatenation of all the ranges.
     * @returns {Range[]}
     * @method Selection.getAllRanges
     **/ this.getAllRanges = function() {
                        return this.rangeCount ? this.rangeList.ranges.concat() : [
                            this.getRange()
                        ];
                    };
                    /**
     * Splits all the ranges into lines.
     * @method Selection.splitIntoLines
     **/ this.splitIntoLines = function() {
                        var ranges = this.ranges.length ? this.ranges : [
                            this.getRange()
                        ];
                        var newRanges = [];
                        for(var i = 0; i < ranges.length; i++){
                            var range = ranges[i];
                            var row = range.start.row;
                            var endRow = range.end.row;
                            if (row === endRow) {
                                newRanges.push(range.clone());
                            } else {
                                newRanges.push(new Range(row, range.start.column, row, this.session.getLine(row).length));
                                while(++row < endRow)newRanges.push(this.getLineRange(row, true));
                                newRanges.push(new Range(endRow, 0, endRow, range.end.column));
                            }
                            if (i == 0 && !this.isBackwards()) newRanges = newRanges.reverse();
                        }
                        this.toSingleRange();
                        for(var i = newRanges.length; i--;)this.addRange(newRanges[i]);
                    };
                    this.joinSelections = function() {
                        var ranges = this.rangeList.ranges;
                        var lastRange = ranges[ranges.length - 1];
                        var range = Range.fromPoints(ranges[0].start, lastRange.end);
                        this.toSingleRange();
                        this.setSelectionRange(range, lastRange.cursor == lastRange.start);
                    };
                    /**
     * @method Selection.toggleBlockSelection
     **/ this.toggleBlockSelection = function() {
                        if (this.rangeCount > 1) {
                            var ranges = this.rangeList.ranges;
                            var lastRange = ranges[ranges.length - 1];
                            var range = Range.fromPoints(ranges[0].start, lastRange.end);
                            this.toSingleRange();
                            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
                        } else {
                            var cursor = this.session.documentToScreenPosition(this.cursor);
                            var anchor = this.session.documentToScreenPosition(this.anchor);
                            var rectSel = this.rectangularRangeBlock(cursor, anchor);
                            rectSel.forEach(this.addRange, this);
                        }
                    };
                    /**
     * 
     * Gets list of ranges composing rectangular block on the screen
     * 
     * @param {Position} screenCursor The cursor to use
     * @param {Position} screenAnchor The anchor to use
     * @param {Boolean} includeEmptyLines If true, this includes ranges inside the block which are empty due to clipping
     * @returns {Range}
     * @method Selection.rectangularRangeBlock
     **/ this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {
                        var rectSel = [];
                        var xBackwards = screenCursor.column < screenAnchor.column;
                        if (xBackwards) {
                            var startColumn = screenCursor.column;
                            var endColumn = screenAnchor.column;
                            var startOffsetX = screenCursor.offsetX;
                            var endOffsetX = screenAnchor.offsetX;
                        } else {
                            var startColumn = screenAnchor.column;
                            var endColumn = screenCursor.column;
                            var startOffsetX = screenAnchor.offsetX;
                            var endOffsetX = screenCursor.offsetX;
                        }
                        var yBackwards = screenCursor.row < screenAnchor.row;
                        if (yBackwards) {
                            var startRow = screenCursor.row;
                            var endRow = screenAnchor.row;
                        } else {
                            var startRow = screenAnchor.row;
                            var endRow = screenCursor.row;
                        }
                        if (startColumn < 0) startColumn = 0;
                        if (startRow < 0) startRow = 0;
                        if (startRow == endRow) includeEmptyLines = true;
                        var docEnd;
                        for(var row = startRow; row <= endRow; row++){
                            var range = Range.fromPoints(this.session.screenToDocumentPosition(row, startColumn, startOffsetX), this.session.screenToDocumentPosition(row, endColumn, endOffsetX));
                            if (range.isEmpty()) {
                                if (docEnd && isSamePoint(range.end, docEnd)) break;
                                docEnd = range.end;
                            }
                            range.cursor = xBackwards ? range.start : range.end;
                            rectSel.push(range);
                        }
                        if (yBackwards) rectSel.reverse();
                        if (!includeEmptyLines) {
                            var end = rectSel.length - 1;
                            while(rectSel[end].isEmpty() && end > 0)end--;
                            if (end > 0) {
                                var start = 0;
                                while(rectSel[start].isEmpty())start++;
                            }
                            for(var i = end; i >= start; i--){
                                if (rectSel[i].isEmpty()) rectSel.splice(i, 1);
                            }
                        }
                        return rectSel;
                    };
                }).call(Selection.prototype);
                // extend Editor
                var Editor = __nested_webpack_require_1003684__(7180)/* .Editor */ .M;
                (function() {
                    /** 
     * 
     * Updates the cursor and marker layers.
     * @method Editor.updateSelectionMarkers
     *
     **/ this.updateSelectionMarkers = function() {
                        this.renderer.updateCursor();
                        this.renderer.updateBackMarkers();
                    };
                    /** 
     * Adds the selection and cursor.
     * @param {Range} orientedRange A range containing a cursor
     * @returns {Range}
     * @method Editor.addSelectionMarker
     **/ this.addSelectionMarker = function(orientedRange) {
                        if (!orientedRange.cursor) orientedRange.cursor = orientedRange.end;
                        var style = this.getSelectionStyle();
                        orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);
                        this.session.$selectionMarkers.push(orientedRange);
                        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
                        return orientedRange;
                    };
                    /** 
     * Removes the selection marker.
     * @param {Range} range The selection range added with [[Editor.addSelectionMarker `addSelectionMarker()`]].
     * @method Editor.removeSelectionMarker
     **/ this.removeSelectionMarker = function(range) {
                        if (!range.marker) return;
                        this.session.removeMarker(range.marker);
                        var index = this.session.$selectionMarkers.indexOf(range);
                        if (index != -1) this.session.$selectionMarkers.splice(index, 1);
                        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
                    };
                    this.removeSelectionMarkers = function(ranges) {
                        var markerList = this.session.$selectionMarkers;
                        for(var i = ranges.length; i--;){
                            var range = ranges[i];
                            if (!range.marker) continue;
                            this.session.removeMarker(range.marker);
                            var index = markerList.indexOf(range);
                            if (index != -1) markerList.splice(index, 1);
                        }
                        this.session.selectionMarkerCount = markerList.length;
                    };
                    this.$onAddRange = function(e) {
                        this.addSelectionMarker(e.range);
                        this.renderer.updateCursor();
                        this.renderer.updateBackMarkers();
                    };
                    this.$onRemoveRange = function(e) {
                        this.removeSelectionMarkers(e.ranges);
                        this.renderer.updateCursor();
                        this.renderer.updateBackMarkers();
                    };
                    this.$onMultiSelect = function(e) {
                        if (this.inMultiSelectMode) return;
                        this.inMultiSelectMode = true;
                        this.setStyle("ace_multiselect");
                        this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
                        this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);
                        this.renderer.updateCursor();
                        this.renderer.updateBackMarkers();
                    };
                    this.$onSingleSelect = function(e) {
                        if (this.session.multiSelect.inVirtualMode) return;
                        this.inMultiSelectMode = false;
                        this.unsetStyle("ace_multiselect");
                        this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);
                        this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
                        this.renderer.updateCursor();
                        this.renderer.updateBackMarkers();
                        this._emit("changeSelection");
                    };
                    this.$onMultiSelectExec = function(e) {
                        var command = e.command;
                        var editor = e.editor;
                        if (!editor.multiSelect) return;
                        if (!command.multiSelectAction) {
                            var result = command.exec(editor, e.args || {});
                            editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
                            editor.multiSelect.mergeOverlappingRanges();
                        } else if (command.multiSelectAction == "forEach") {
                            result = editor.forEachSelection(command, e.args);
                        } else if (command.multiSelectAction == "forEachLine") {
                            result = editor.forEachSelection(command, e.args, true);
                        } else if (command.multiSelectAction == "single") {
                            editor.exitMultiSelectMode();
                            result = command.exec(editor, e.args || {});
                        } else {
                            result = command.multiSelectAction(editor, e.args || {});
                        }
                        return result;
                    };
                    /** 
     * Executes a command for each selection range.
     * @param {Object} cmd The command to execute
     * @param {String} args Any arguments for the command
     * @method Editor.forEachSelection
     **/ this.forEachSelection = function(cmd, args, options) {
                        if (this.inVirtualSelectionMode) return;
                        var keepOrder = options && options.keepOrder;
                        var $byLines = options == true || options && options.$byLines;
                        var session = this.session;
                        var selection = this.selection;
                        var rangeList = selection.rangeList;
                        var ranges = (keepOrder ? selection : rangeList).ranges;
                        var result;
                        if (!ranges.length) return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
                        var reg = selection._eventRegistry;
                        selection._eventRegistry = {};
                        var tmpSel = new Selection(session);
                        this.inVirtualSelectionMode = true;
                        for(var i = ranges.length; i--;){
                            if ($byLines) {
                                while(i > 0 && ranges[i].start.row == ranges[i - 1].end.row)i--;
                            }
                            tmpSel.fromOrientedRange(ranges[i]);
                            tmpSel.index = i;
                            this.selection = session.selection = tmpSel;
                            var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
                            if (!result && cmdResult !== undefined) result = cmdResult;
                            tmpSel.toOrientedRange(ranges[i]);
                        }
                        tmpSel.detach();
                        this.selection = session.selection = selection;
                        this.inVirtualSelectionMode = false;
                        selection._eventRegistry = reg;
                        selection.mergeOverlappingRanges();
                        if (selection.ranges[0]) selection.fromOrientedRange(selection.ranges[0]);
                        var anim = this.renderer.$scrollAnimation;
                        this.onCursorChange();
                        this.onSelectionChange();
                        if (anim && anim.from == anim.to) this.renderer.animateScrolling(anim.from);
                        return result;
                    };
                    /** 
    * Removes all the selections except the last added one.
    * @method Editor.exitMultiSelectMode
    **/ this.exitMultiSelectMode = function() {
                        if (!this.inMultiSelectMode || this.inVirtualSelectionMode) return;
                        this.multiSelect.toSingleRange();
                    };
                    this.getSelectedText = function() {
                        var text = "";
                        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
                            var ranges = this.multiSelect.rangeList.ranges;
                            var buf = [];
                            for(var i = 0; i < ranges.length; i++){
                                buf.push(this.session.getTextRange(ranges[i]));
                            }
                            var nl = this.session.getDocument().getNewLineCharacter();
                            text = buf.join(nl);
                            if (text.length == (buf.length - 1) * nl.length) text = "";
                        } else if (!this.selection.isEmpty()) {
                            text = this.session.getTextRange(this.getSelectionRange());
                        }
                        return text;
                    };
                    this.$checkMultiselectChange = function(e, anchor) {
                        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
                            var range = this.multiSelect.ranges[0];
                            if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor) return;
                            var pos = anchor == this.multiSelect.anchor ? range.cursor == range.start ? range.end : range.start : range.cursor;
                            if (pos.row != anchor.row || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column) this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
                            else this.multiSelect.mergeOverlappingRanges();
                        }
                    };
                    /**
     * Finds and selects all the occurrences of `needle`.
     * @param {String} The text to find
     * @param {Object} The search options
     * @param {Boolean} keeps
     *
     * @returns {Number} The cumulative count of all found matches 
     * @method Editor.findAll
     **/ this.findAll = function(needle, options, additive) {
                        options = options || {};
                        options.needle = needle || options.needle;
                        if (options.needle == undefined) {
                            var range = this.selection.isEmpty() ? this.selection.getWordRange() : this.selection.getRange();
                            options.needle = this.session.getTextRange(range);
                        }
                        this.$search.set(options);
                        var ranges = this.$search.findAll(this.session);
                        if (!ranges.length) return 0;
                        var selection = this.multiSelect;
                        if (!additive) selection.toSingleRange(ranges[0]);
                        for(var i = ranges.length; i--;)selection.addRange(ranges[i], true);
                        // keep old selection as primary if possible
                        if (range && selection.rangeList.rangeAtPoint(range.start)) selection.addRange(range, true);
                        return ranges.length;
                    };
                    /**
     * Adds a cursor above or below the active cursor.
     * 
     * @param {Number} dir The direction of lines to select: -1 for up, 1 for down
     * @param {Boolean} skip If `true`, removes the active selection range
     *
     * @method Editor.selectMoreLines 
     */ this.selectMoreLines = function(dir, skip) {
                        var range = this.selection.toOrientedRange();
                        var isBackwards = range.cursor == range.end;
                        var screenLead = this.session.documentToScreenPosition(range.cursor);
                        if (this.selection.$desiredColumn) screenLead.column = this.selection.$desiredColumn;
                        var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);
                        if (!range.isEmpty()) {
                            var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
                            var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
                        } else {
                            var anchor = lead;
                        }
                        if (isBackwards) {
                            var newRange = Range.fromPoints(lead, anchor);
                            newRange.cursor = newRange.start;
                        } else {
                            var newRange = Range.fromPoints(anchor, lead);
                            newRange.cursor = newRange.end;
                        }
                        newRange.desiredColumn = screenLead.column;
                        if (!this.selection.inMultiSelectMode) {
                            this.selection.addRange(range);
                        } else {
                            if (skip) var toRemove = range.cursor;
                        }
                        this.selection.addRange(newRange);
                        if (toRemove) this.selection.substractPoint(toRemove);
                    };
                    /** 
     * Transposes the selected ranges.
     * @param {Number} dir The direction to rotate selections
     * @method Editor.transposeSelections
     **/ this.transposeSelections = function(dir) {
                        var session = this.session;
                        var sel = session.multiSelect;
                        var all = sel.ranges;
                        for(var i = all.length; i--;){
                            var range = all[i];
                            if (range.isEmpty()) {
                                var tmp = session.getWordRange(range.start.row, range.start.column);
                                range.start.row = tmp.start.row;
                                range.start.column = tmp.start.column;
                                range.end.row = tmp.end.row;
                                range.end.column = tmp.end.column;
                            }
                        }
                        sel.mergeOverlappingRanges();
                        var words = [];
                        for(var i = all.length; i--;){
                            var range = all[i];
                            words.unshift(session.getTextRange(range));
                        }
                        if (dir < 0) words.unshift(words.pop());
                        else words.push(words.shift());
                        for(var i = all.length; i--;){
                            var range = all[i];
                            var tmp = range.clone();
                            session.replace(range, words[i]);
                            range.start.row = tmp.start.row;
                            range.start.column = tmp.start.column;
                        }
                        sel.fromOrientedRange(sel.ranges[0]);
                    };
                    /** 
     * Finds the next occurrence of text in an active selection and adds it to the selections.
     * @param {Number} dir The direction of lines to select: -1 for up, 1 for down
     * @param {Boolean} skip If `true`, removes the active selection range
     * @method Editor.selectMore
     **/ this.selectMore = function(dir, skip, stopAtFirst) {
                        var session = this.session;
                        var sel = session.multiSelect;
                        var range = sel.toOrientedRange();
                        if (range.isEmpty()) {
                            range = session.getWordRange(range.start.row, range.start.column);
                            range.cursor = dir == -1 ? range.start : range.end;
                            this.multiSelect.addRange(range);
                            if (stopAtFirst) return;
                        }
                        var needle = session.getTextRange(range);
                        var newRange = find(session, needle, dir);
                        if (newRange) {
                            newRange.cursor = dir == -1 ? newRange.start : newRange.end;
                            this.session.unfold(newRange);
                            this.multiSelect.addRange(newRange);
                            this.renderer.scrollCursorIntoView(null, 0.5);
                        }
                        if (skip) this.multiSelect.substractPoint(range.cursor);
                    };
                    /** 
     * Aligns the cursors or selected text.
     * @method Editor.alignCursors
     **/ this.alignCursors = function() {
                        var session = this.session;
                        var sel = session.multiSelect;
                        var ranges = sel.ranges;
                        // filter out ranges on same row
                        var row = -1;
                        var sameRowRanges = ranges.filter(function(r) {
                            if (r.cursor.row == row) return true;
                            row = r.cursor.row;
                        });
                        if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
                            var range = this.selection.getRange();
                            var fr = range.start.row, lr = range.end.row;
                            var guessRange = fr == lr;
                            if (guessRange) {
                                var max = this.session.getLength();
                                var line;
                                do {
                                    line = this.session.getLine(lr);
                                }while (/[=:]/.test(line) && ++lr < max);
                                do {
                                    line = this.session.getLine(fr);
                                }while (/[=:]/.test(line) && --fr > 0);
                                if (fr < 0) fr = 0;
                                if (lr >= max) lr = max - 1;
                            }
                            var lines = this.session.removeFullLines(fr, lr);
                            lines = this.$reAlignText(lines, guessRange);
                            this.session.insert({
                                row: fr,
                                column: 0
                            }, lines.join("\n") + "\n");
                            if (!guessRange) {
                                range.start.column = 0;
                                range.end.column = lines[lines.length - 1].length;
                            }
                            this.selection.setRange(range);
                        } else {
                            sameRowRanges.forEach(function(r) {
                                sel.substractPoint(r.cursor);
                            });
                            var maxCol = 0;
                            var minSpace = Infinity;
                            var spaceOffsets = ranges.map(function(r) {
                                var p = r.cursor;
                                var line = session.getLine(p.row);
                                var spaceOffset = line.substr(p.column).search(/\S/g);
                                if (spaceOffset == -1) spaceOffset = 0;
                                if (p.column > maxCol) maxCol = p.column;
                                if (spaceOffset < minSpace) minSpace = spaceOffset;
                                return spaceOffset;
                            });
                            ranges.forEach(function(r, i) {
                                var p = r.cursor;
                                var l = maxCol - p.column;
                                var d = spaceOffsets[i] - minSpace;
                                if (l > d) session.insert(p, lang.stringRepeat(" ", l - d));
                                else session.remove(new Range(p.row, p.column, p.row, p.column - l + d));
                                r.start.column = r.end.column = maxCol;
                                r.start.row = r.end.row = p.row;
                                r.cursor = r.end;
                            });
                            sel.fromOrientedRange(ranges[0]);
                            this.renderer.updateCursor();
                            this.renderer.updateBackMarkers();
                        }
                    };
                    this.$reAlignText = function(lines, forceLeft) {
                        var spaces = function spaces(n) {
                            return lang.stringRepeat(" ", n);
                        };
                        var alignLeft = function alignLeft(m) {
                            return !m[2] ? m[0] : spaces(startW) + m[2] + spaces(textW - m[2].length + endW) + m[4].replace(/^([=:])\s+/, "$1 ");
                        };
                        var alignRight = function alignRight(m) {
                            return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2] + spaces(endW) + m[4].replace(/^([=:])\s+/, "$1 ");
                        };
                        var unAlign = function unAlign(m) {
                            return !m[2] ? m[0] : spaces(startW) + m[2] + spaces(endW) + m[4].replace(/^([=:])\s+/, "$1 ");
                        };
                        var isLeftAligned = true, isRightAligned = true;
                        var startW, textW, endW;
                        return lines.map(function(line) {
                            var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
                            if (!m) return [
                                line
                            ];
                            if (startW == null) {
                                startW = m[1].length;
                                textW = m[2].length;
                                endW = m[3].length;
                                return m;
                            }
                            if (startW + textW + endW != m[1].length + m[2].length + m[3].length) isRightAligned = false;
                            if (startW != m[1].length) isLeftAligned = false;
                            if (startW > m[1].length) startW = m[1].length;
                            if (textW < m[2].length) textW = m[2].length;
                            if (endW > m[3].length) endW = m[3].length;
                            return m;
                        }).map(forceLeft ? alignLeft : isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);
                    };
                }).call(Editor.prototype);
                // patch
                // adds multicursor support to a session
                exports1.onSessionChange = function(e) {
                    var session = e.session;
                    if (session && !session.multiSelect) {
                        session.$selectionMarkers = [];
                        session.selection.$initRangeList();
                        session.multiSelect = session.selection;
                    }
                    this.multiSelect = session && session.multiSelect;
                    var oldSession = e.oldSession;
                    if (oldSession) {
                        oldSession.multiSelect.off("addRange", this.$onAddRange);
                        oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
                        oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
                        oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
                        oldSession.multiSelect.lead.off("change", this.$checkMultiselectChange);
                        oldSession.multiSelect.anchor.off("change", this.$checkMultiselectChange);
                    }
                    if (session) {
                        session.multiSelect.on("addRange", this.$onAddRange);
                        session.multiSelect.on("removeRange", this.$onRemoveRange);
                        session.multiSelect.on("multiSelect", this.$onMultiSelect);
                        session.multiSelect.on("singleSelect", this.$onSingleSelect);
                        session.multiSelect.lead.on("change", this.$checkMultiselectChange);
                        session.multiSelect.anchor.on("change", this.$checkMultiselectChange);
                    }
                    if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
                        if (session.selection.inMultiSelectMode) this.$onMultiSelect();
                        else this.$onSingleSelect();
                    }
                };
                exports1.MultiSelect = MultiSelect;
                __nested_webpack_require_1003684__(3294).defineOptions(Editor.prototype, "editor", {
                    enableMultiselect: {
                        set: function set(val) {
                            MultiSelect(this);
                            if (val) {
                                this.on("changeSession", this.$multiselectOnSessionChange);
                                this.on("mousedown", onMouseDown);
                            } else {
                                this.off("changeSession", this.$multiselectOnSessionChange);
                                this.off("mousedown", onMouseDown);
                            }
                        },
                        value: true
                    },
                    enableBlockSelect: {
                        set: function set(val) {
                            this.$blockSelectEnabled = val;
                        },
                        value: true
                    }
                });
            /***/ },
            /***/ 8916: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1045661__) {
                "use strict";
                var Range = __nested_webpack_require_1045661__(3069)/* .Range */ .e;
                var EventEmitter = __nested_webpack_require_1045661__(7858)/* .EventEmitter */ .v;
                var oop = __nested_webpack_require_1045661__(2011);
                var PlaceHolder = /*#__PURE__*/ function() {
                    function PlaceHolder(session, length, pos, others, mainClass, othersClass) {
                        _class_call_check(this, PlaceHolder);
                        var _self = this;
                        this.length = length;
                        this.session = session;
                        this.doc = session.getDocument();
                        this.mainClass = mainClass;
                        this.othersClass = othersClass;
                        this.$onUpdate = this.onUpdate.bind(this);
                        this.doc.on("change", this.$onUpdate, true);
                        this.$others = others;
                        this.$onCursorChange = function() {
                            setTimeout(function() {
                                _self.onCursorChange();
                            });
                        };
                        this.$pos = pos;
                        // Used for reset
                        var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || {
                            length: -1
                        };
                        this.$undoStackDepth = undoStack.length;
                        this.setup();
                        session.selection.on("changeCursor", this.$onCursorChange);
                    }
                    _create_class(PlaceHolder, [
                        {
                            /**
     * PlaceHolder.setup()
     *
     * TODO
     *
     **/ key: "setup",
                            value: function setup() {
                                var _self = this;
                                var doc = this.doc;
                                var session = this.session;
                                this.selectionBefore = session.selection.toJSON();
                                if (session.selection.inMultiSelectMode) session.selection.toSingleRange();
                                this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);
                                var pos = this.pos;
                                pos.$insertRight = true;
                                pos.detach();
                                pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
                                this.others = [];
                                this.$others.forEach(function(other) {
                                    var anchor = doc.createAnchor(other.row, other.column);
                                    anchor.$insertRight = true;
                                    anchor.detach();
                                    _self.others.push(anchor);
                                });
                                session.setUndoSelect(false);
                            }
                        },
                        {
                            /**
     * PlaceHolder.showOtherMarkers()
     *
     * TODO
     *
     **/ key: "showOtherMarkers",
                            value: function showOtherMarkers() {
                                if (this.othersActive) return;
                                var session = this.session;
                                var _self = this;
                                this.othersActive = true;
                                this.others.forEach(function(anchor) {
                                    anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column + _self.length), _self.othersClass, null, false);
                                });
                            }
                        },
                        {
                            /**
     * PlaceHolder.hideOtherMarkers()
     *
     * Hides all over markers in the [[EditSession `EditSession`]] that are not the currently selected one.
     *
     **/ key: "hideOtherMarkers",
                            value: function hideOtherMarkers() {
                                if (!this.othersActive) return;
                                this.othersActive = false;
                                for(var i = 0; i < this.others.length; i++){
                                    this.session.removeMarker(this.others[i].markerId);
                                }
                            }
                        },
                        {
                            /**
     * PlaceHolder@onUpdate(e)
     * 
     * Emitted when the place holder updates.
     *
     **/ key: "onUpdate",
                            value: function onUpdate(delta) {
                                if (this.$updating) return this.updateAnchors(delta);
                                var range = delta;
                                if (range.start.row !== range.end.row) return;
                                if (range.start.row !== this.pos.row) return;
                                this.$updating = true;
                                var lengthDiff = delta.action === "insert" ? range.end.column - range.start.column : range.start.column - range.end.column;
                                var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;
                                var distanceFromStart = range.start.column - this.pos.column;
                                this.updateAnchors(delta);
                                if (inMainRange) this.length += lengthDiff;
                                if (inMainRange && !this.session.$fromUndo) {
                                    if (delta.action === "insert") {
                                        for(var i = this.others.length - 1; i >= 0; i--){
                                            var otherPos = this.others[i];
                                            var newPos = {
                                                row: otherPos.row,
                                                column: otherPos.column + distanceFromStart
                                            };
                                            this.doc.insertMergedLines(newPos, delta.lines);
                                        }
                                    } else if (delta.action === "remove") {
                                        for(var i = this.others.length - 1; i >= 0; i--){
                                            var otherPos = this.others[i];
                                            var newPos = {
                                                row: otherPos.row,
                                                column: otherPos.column + distanceFromStart
                                            };
                                            this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
                                        }
                                    }
                                }
                                this.$updating = false;
                                this.updateMarkers();
                            }
                        },
                        {
                            key: "updateAnchors",
                            value: function updateAnchors(delta) {
                                this.pos.onChange(delta);
                                for(var i = this.others.length; i--;)this.others[i].onChange(delta);
                                this.updateMarkers();
                            }
                        },
                        {
                            key: "updateMarkers",
                            value: function updateMarkers() {
                                if (this.$updating) return;
                                var _self = this;
                                var session = this.session;
                                var updateMarker = function updateMarker(pos, className) {
                                    session.removeMarker(pos.markerId);
                                    pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + _self.length), className, null, false);
                                };
                                updateMarker(this.pos, this.mainClass);
                                for(var i = this.others.length; i--;)updateMarker(this.others[i], this.othersClass);
                            }
                        },
                        {
                            /**
     * PlaceHolder@onCursorChange(e)
     * 
     * Emitted when the cursor changes.
     *
     **/ key: "onCursorChange",
                            value: function onCursorChange(event) {
                                if (this.$updating || !this.session) return;
                                var pos = this.session.selection.getCursor();
                                if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
                                    this.showOtherMarkers();
                                    this._emit("cursorEnter", event);
                                } else {
                                    this.hideOtherMarkers();
                                    this._emit("cursorLeave", event);
                                }
                            }
                        },
                        {
                            /**
     * PlaceHolder.detach()
     * 
     * TODO
     *
     **/ key: "detach",
                            value: function detach() {
                                this.session.removeMarker(this.pos && this.pos.markerId);
                                this.hideOtherMarkers();
                                this.doc.off("change", this.$onUpdate);
                                this.session.selection.off("changeCursor", this.$onCursorChange);
                                this.session.setUndoSelect(true);
                                this.session = null;
                            }
                        },
                        {
                            /**
     * PlaceHolder.cancel()
     * 
     * TODO
     *
     **/ key: "cancel",
                            value: function cancel() {
                                if (this.$undoStackDepth === -1) return;
                                var undoManager = this.session.getUndoManager();
                                var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;
                                for(var i = 0; i < undosRequired; i++){
                                    undoManager.undo(this.session, true);
                                }
                                if (this.selectionBefore) this.session.selection.fromJSON(this.selectionBefore);
                            }
                        }
                    ]);
                    return PlaceHolder;
                }();
                oop.implement(PlaceHolder.prototype, EventEmitter);
                exports1.PlaceHolder = PlaceHolder;
            /***/ },
            /***/ 3069: /***/ function(__unused_webpack_module, exports1) {
                "use strict";
                var comparePoints = function comparePoints(p1, p2) {
                    return p1.row - p2.row || p1.column - p2.column;
                };
                /**
 * This object is used in various places to indicate a region within the editor. To better visualize how this works, imagine a rectangle. Each quadrant of the rectangle is analogous to a range, as ranges contain a starting row and starting column, and an ending row, and ending column.
 * @class Range
 **/ var Range = /*#__PURE__*/ function() {
                    function Range(startRow, startColumn, endRow, endColumn) {
                        _class_call_check(this, Range);
                        this.start = {
                            row: startRow,
                            column: startColumn
                        };
                        this.end = {
                            row: endRow,
                            column: endColumn
                        };
                    }
                    _create_class(Range, [
                        {
                            /**
     * Returns `true` if and only if the starting row and column, and ending row and column, are equivalent to those given by `range`.
     * @param {Range} range A range to check against
     * @return {Boolean}
     **/ key: "isEqual",
                            value: function isEqual(range) {
                                return this.start.row === range.start.row && this.end.row === range.end.row && this.start.column === range.start.column && this.end.column === range.end.column;
                            }
                        },
                        {
                            /**
     * Returns a string containing the range's row and column information, given like this:
     * ```
     *    [start.row/start.column] -> [end.row/end.column]
     * ```
     * @return {String}
     **/ key: "toString",
                            value: function toString() {
                                return "Range: [" + this.start.row + "/" + this.start.column + "] -> [" + this.end.row + "/" + this.end.column + "]";
                            }
                        },
                        {
                            /**
     * Returns `true` if the `row` and `column` provided are within the given range. This can better be expressed as returning `true` if:
     * ```javascript
     *    this.start.row <= row <= this.end.row &&
     *    this.start.column <= column <= this.end.column
     * ```
     * @param {Number} row A row to check for
     * @param {Number} column A column to check for
     * @returns {Boolean}
     * @related [[Range.compare]]
     **/ key: "contains",
                            value: function contains(row, column) {
                                return this.compare(row, column) == 0;
                            }
                        },
                        {
                            /**
     * Compares `this` range (A) with another range (B).
     * @param {Range} range A range to compare with
     * @related [[Range.compare]]
     * @returns {Number} This method returns one of the following numbers:
     * * `-2`: (B) is in front of (A), and doesn't intersect with (A)
     * * `-1`: (B) begins before (A) but ends inside of (A)
     * * `0`: (B) is completely inside of (A) OR (A) is completely inside of (B)
     * * `+1`: (B) begins inside of (A) but ends outside of (A)
     * * `+2`: (B) is after (A) and doesn't intersect with (A)
     * * `42`: FTW state: (B) ends in (A) but starts outside of (A)
     **/ key: "compareRange",
                            value: function compareRange(range) {
                                var cmp, end = range.end, start = range.start;
                                cmp = this.compare(end.row, end.column);
                                if (cmp == 1) {
                                    cmp = this.compare(start.row, start.column);
                                    if (cmp == 1) {
                                        return 2;
                                    } else if (cmp == 0) {
                                        return 1;
                                    } else {
                                        return 0;
                                    }
                                } else if (cmp == -1) {
                                    return -2;
                                } else {
                                    cmp = this.compare(start.row, start.column);
                                    if (cmp == -1) {
                                        return -1;
                                    } else if (cmp == 1) {
                                        return 42;
                                    } else {
                                        return 0;
                                    }
                                }
                            }
                        },
                        {
                            /**
     * Compares the row and column of `p` with the starting and ending [[Point]]'s of the calling range (by calling [[Range.compare]]).
     * @param {Ace.Point} p A point to compare with
     * @related [[Range.compare]]
     * @returns {Number}
     **/ key: "comparePoint",
                            value: function comparePoint(p) {
                                return this.compare(p.row, p.column);
                            }
                        },
                        {
                            /**
     * Checks the start and end [[Point]]'s of `range` and compares them to the calling range. Returns `true` if the `range` is contained within the caller's range.
     * @param {Range} range A range to compare with
     * @returns {Boolean}
     * @related [[Range.comparePoint]]
     **/ key: "containsRange",
                            value: function containsRange(range) {
                                return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
                            }
                        },
                        {
                            /**
     * Returns `true` if passed in `range` intersects with the one calling this method.
     * @param {Range} range A range to compare with
     * @returns {Boolean}
     **/ key: "intersects",
                            value: function intersects(range) {
                                var cmp = this.compareRange(range);
                                return cmp == -1 || cmp == 0 || cmp == 1;
                            }
                        },
                        {
                            /**
     * Returns `true` if the caller's ending row is the same as `row`, and if the caller's ending column is the same as `column`.
     * @param {Number} row A row to compare with
     * @param {Number} column A column to compare with
     * @returns {Boolean}
     **/ key: "isEnd",
                            value: function isEnd(row, column) {
                                return this.end.row == row && this.end.column == column;
                            }
                        },
                        {
                            /**
     * Returns `true` if the caller's starting row is the same as `row`, and if the caller's starting column is the same as `column`.
     * @param {Number} row A row to compare with
     * @param {Number} column A column to compare with
     * @returns {Boolean}
     **/ key: "isStart",
                            value: function isStart(row, column) {
                                return this.start.row == row && this.start.column == column;
                            }
                        },
                        {
                            /**
     * Sets the starting row and column for the range.
     * @param {Number|Ace.Point} row A row to set
     * @param {Number} column A column to set
     *
     **/ key: "setStart",
                            value: function setStart(row, column) {
                                if (typeof row == "object") {
                                    this.start.column = row.column;
                                    this.start.row = row.row;
                                } else {
                                    this.start.row = row;
                                    this.start.column = column;
                                }
                            }
                        },
                        {
                            /**
     * Sets the starting row and column for the range.
     * @param {Number|Ace.Point} row A row to set
     * @param {Number} column A column to set
     *
     **/ key: "setEnd",
                            value: function setEnd(row, column) {
                                if (typeof row == "object") {
                                    this.end.column = row.column;
                                    this.end.row = row.row;
                                } else {
                                    this.end.row = row;
                                    this.end.column = column;
                                }
                            }
                        },
                        {
                            /**
     * Returns `true` if the `row` and `column` are within the given range.
     * @param {Number} row A row to compare with
     * @param {Number} column A column to compare with
     * @returns {Boolean}
     * @related [[Range.compare]]
     **/ key: "inside",
                            value: function inside(row, column) {
                                if (this.compare(row, column) == 0) {
                                    if (this.isEnd(row, column) || this.isStart(row, column)) {
                                        return false;
                                    } else {
                                        return true;
                                    }
                                }
                                return false;
                            }
                        },
                        {
                            /**
     * Returns `true` if the `row` and `column` are within the given range's starting [[Point]].
     * @param {Number} row A row to compare with
     * @param {Number} column A column to compare with
     * @returns {Boolean}
     * @related [[Range.compare]]
     **/ key: "insideStart",
                            value: function insideStart(row, column) {
                                if (this.compare(row, column) == 0) {
                                    if (this.isEnd(row, column)) {
                                        return false;
                                    } else {
                                        return true;
                                    }
                                }
                                return false;
                            }
                        },
                        {
                            /**
     * Returns `true` if the `row` and `column` are within the given range's ending [[Point]].
     * @param {Number} row A row to compare with
     * @param {Number} column A column to compare with
     * @returns {Boolean}
     * @related [[Range.compare]]
     *
     **/ key: "insideEnd",
                            value: function insideEnd(row, column) {
                                if (this.compare(row, column) == 0) {
                                    if (this.isStart(row, column)) {
                                        return false;
                                    } else {
                                        return true;
                                    }
                                }
                                return false;
                            }
                        },
                        {
                            /**
     * Compares the `row` and `column` with the starting and ending [[Point]]'s of the calling range.
     * @param {Number} row A row to compare with
     * @param {Number} column A column to compare with
     * @returns {Number} This method returns one of the following numbers:
     * * `1` if `row` is greater than the calling range
     * * `-1` if `row` is less then the calling range
     * * `0` otherwise
     *
     * If the starting row of the calling range is equal to `row`, and:
     * * `column` is greater than or equal to the calling range's starting column, this returns `0`
     * * Otherwise, it returns -1
     *
     * If the ending row of the calling range is equal to `row`, and:
     * * `column` is less than or equal to the calling range's ending column, this returns `0`
     * * Otherwise, it returns 1
     **/ key: "compare",
                            value: function compare(row, column) {
                                if (!this.isMultiLine()) {
                                    if (row === this.start.row) {
                                        return column < this.start.column ? -1 : column > this.end.column ? 1 : 0;
                                    }
                                }
                                if (row < this.start.row) return -1;
                                if (row > this.end.row) return 1;
                                if (this.start.row === row) return column >= this.start.column ? 0 : -1;
                                if (this.end.row === row) return column <= this.end.column ? 0 : 1;
                                return 0;
                            }
                        },
                        {
                            /**
     * Compares the `row` and `column` with the starting and ending [[Point]]'s of the calling range.
     * @param {Number} row A row to compare with
     * @param {Number} column A column to compare with
     * @returns {Number} This method returns one of the following numbers:
     * * `-1` if calling range's starting column and calling range's starting row are equal `row` and `column`
     * * Otherwise, it returns the value after calling [[Range.compare `compare()`]].
     **/ key: "compareStart",
                            value: function compareStart(row, column) {
                                if (this.start.row == row && this.start.column == column) {
                                    return -1;
                                } else {
                                    return this.compare(row, column);
                                }
                            }
                        },
                        {
                            /**
     * Compares the `row` and `column` with the starting and ending [[Point]]'s of the calling range.
     * @param {Number} row A row to compare with
     * @param {Number} column A column to compare with
     * @returns {Number} This method returns one of the following numbers:
     * * `1` if calling range's ending column and calling range's ending row are equal `row` and `column`.
     * * Otherwise, it returns the value after calling [[Range.compare `compare()`]].
     */ key: "compareEnd",
                            value: function compareEnd(row, column) {
                                if (this.end.row == row && this.end.column == column) {
                                    return 1;
                                } else {
                                    return this.compare(row, column);
                                }
                            }
                        },
                        {
                            /**
     * Compares the `row` and `column` with the start and end [[Point]]'s of the calling range.
     * @param {Number} row A row to compare with
     * @param {Number} column A column to compare with
     * @returns {Number} This method returns one of the following numbers:
     * * `1` if the ending row of the calling range is equal to `row`, and the ending column of the calling range is equal to `column`
     * * `-1` if the starting row of the calling range is equal to `row`, and the starting column of the calling range is equal to `column`
     * * Otherwise, it returns the value after calling [[Range.compare `compare()`]].
     **/ key: "compareInside",
                            value: function compareInside(row, column) {
                                if (this.end.row == row && this.end.column == column) {
                                    return 1;
                                } else if (this.start.row == row && this.start.column == column) {
                                    return -1;
                                } else {
                                    return this.compare(row, column);
                                }
                            }
                        },
                        {
                            /**
     * Returns the part of the current `Range` that occurs within the boundaries of `firstRow` and `lastRow` as a new `Range` object.
     * @param {Number} firstRow The starting row
     * @param {Number} lastRow The ending row
     * @returns {Range}
    **/ key: "clipRows",
                            value: function clipRows(firstRow, lastRow) {
                                if (this.end.row > lastRow) var end = {
                                    row: lastRow + 1,
                                    column: 0
                                };
                                else if (this.end.row < firstRow) var end = {
                                    row: firstRow,
                                    column: 0
                                };
                                if (this.start.row > lastRow) var start = {
                                    row: lastRow + 1,
                                    column: 0
                                };
                                else if (this.start.row < firstRow) var start = {
                                    row: firstRow,
                                    column: 0
                                };
                                return Range.fromPoints(start || this.start, end || this.end);
                            }
                        },
                        {
                            /**
     * Changes the `row` and `column` for the calling range for both the starting and ending [[Point]]'s.
     * @param {Number} row A new row to extend to
     * @param {Number} column A new column to extend to
     * @returns {Range} The original range with the new row
    **/ key: "extend",
                            value: function extend(row, column) {
                                var cmp = this.compare(row, column);
                                if (cmp == 0) return this;
                                else if (cmp == -1) var start = {
                                    row: row,
                                    column: column
                                };
                                else var end = {
                                    row: row,
                                    column: column
                                };
                                return Range.fromPoints(start || this.start, end || this.end);
                            }
                        },
                        {
                            /**
     * Returns `true` if the calling range is empty (starting [[Point]] == ending [[Point]]).
     * @returns {Boolean}
     **/ key: "isEmpty",
                            value: function isEmpty() {
                                return this.start.row === this.end.row && this.start.column === this.end.column;
                            }
                        },
                        {
                            /**
     * Returns `true` if the range spans across multiple lines.
     * @returns {Boolean}
    **/ key: "isMultiLine",
                            value: function isMultiLine() {
                                return this.start.row !== this.end.row;
                            }
                        },
                        {
                            /**
     * Returns a duplicate of the calling range.
     * @returns {Range}
    **/ key: "clone",
                            value: function clone() {
                                return Range.fromPoints(this.start, this.end);
                            }
                        },
                        {
                            /**
     * Returns a range containing the starting and ending rows of the original range, but with a column value of `0`.
     * @returns {Range}
    **/ key: "collapseRows",
                            value: function collapseRows() {
                                if (this.end.column == 0) return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);
                                else return new Range(this.start.row, 0, this.end.row, 0);
                            }
                        },
                        {
                            /**
     * Given the current `Range`, this function converts those starting and ending [[Point]]'s into screen positions, and then returns a new `Range` object.
     * @param {EditSession} session The `EditSession` to retrieve coordinates from
     * @returns {Range}
    **/ key: "toScreenRange",
                            value: function toScreenRange(session) {
                                var screenPosStart = session.documentToScreenPosition(this.start);
                                var screenPosEnd = session.documentToScreenPosition(this.end);
                                return new Range(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);
                            }
                        },
                        {
                            /**
     * Shift the calling range by `row` and `column` values.
     * @param {Number} row
     * @param {Number} column
     * @experimental
     */ key: "moveBy",
                            value: function moveBy(row, column) {
                                this.start.row += row;
                                this.start.column += column;
                                this.end.row += row;
                                this.end.column += column;
                            }
                        }
                    ]);
                    return Range;
                }();
                /**
 * Creates and returns a new `Range` based on the `start` [[Point]] and `end` [[Point]] of the given parameters.
 * @param {Point} start A starting point to use
 * @param {Point} end An ending point to use
 * @returns {Range}
**/ Range.fromPoints = function(start, end) {
                    return new Range(start.row, start.column, end.row, end.column);
                };
                Range.comparePoints = comparePoints;
                /**
 * Compares `p1` and `p2` [[Point]]'s, useful for sorting
 * @param {Ace.Point} p1
 * @param {Ace.Point} p2
 * @returns {Number}
 */ Range.comparePoints = function(p1, p2) {
                    return p1.row - p2.row || p1.column - p2.column;
                };
                exports1.e = Range;
            /***/ },
            /***/ 9204: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1080599__) {
                "use strict";
                var Range = __nested_webpack_require_1080599__(3069)/* .Range */ .e;
                var comparePoints = Range.comparePoints;
                var RangeList1 = /*#__PURE__*/ function() {
                    function RangeList1() {
                        _class_call_check(this, RangeList1);
                        this.ranges = [];
                        this.$bias = 1;
                    }
                    _create_class(RangeList1, [
                        {
                            key: "pointIndex",
                            value: function pointIndex(pos, excludeEdges, startIndex) {
                                var list = this.ranges;
                                for(var i = startIndex || 0; i < list.length; i++){
                                    var range = list[i];
                                    var cmpEnd = comparePoints(pos, range.end);
                                    if (cmpEnd > 0) continue;
                                    var cmpStart = comparePoints(pos, range.start);
                                    if (cmpEnd === 0) return excludeEdges && cmpStart !== 0 ? -i - 2 : i;
                                    if (cmpStart > 0 || cmpStart === 0 && !excludeEdges) return i;
                                    return -i - 1;
                                }
                                return -i - 1;
                            }
                        },
                        {
                            key: "add",
                            value: function add(range) {
                                var excludeEdges = !range.isEmpty();
                                var startIndex = this.pointIndex(range.start, excludeEdges);
                                if (startIndex < 0) startIndex = -startIndex - 1;
                                var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);
                                if (endIndex < 0) endIndex = -endIndex - 1;
                                else endIndex++;
                                return this.ranges.splice(startIndex, endIndex - startIndex, range);
                            }
                        },
                        {
                            key: "addList",
                            value: function addList(list) {
                                var removed = [];
                                for(var i = list.length; i--;){
                                    removed.push.apply(removed, this.add(list[i]));
                                }
                                return removed;
                            }
                        },
                        {
                            key: "substractPoint",
                            value: function substractPoint(pos) {
                                var i = this.pointIndex(pos);
                                if (i >= 0) return this.ranges.splice(i, 1);
                            }
                        },
                        {
                            // merge overlapping ranges
                            key: "merge",
                            value: function merge() {
                                var removed = [];
                                var list = this.ranges;
                                list = list.sort(function(a, b) {
                                    return comparePoints(a.start, b.start);
                                });
                                var next = list[0], range;
                                for(var i = 1; i < list.length; i++){
                                    range = next;
                                    next = list[i];
                                    var cmp = comparePoints(range.end, next.start);
                                    if (cmp < 0) continue;
                                    if (cmp == 0 && !range.isEmpty() && !next.isEmpty()) continue;
                                    if (comparePoints(range.end, next.end) < 0) {
                                        range.end.row = next.end.row;
                                        range.end.column = next.end.column;
                                    }
                                    list.splice(i, 1);
                                    removed.push(next);
                                    next = range;
                                    i--;
                                }
                                this.ranges = list;
                                return removed;
                            }
                        },
                        {
                            key: "contains",
                            value: function contains(row, column) {
                                return this.pointIndex({
                                    row: row,
                                    column: column
                                }) >= 0;
                            }
                        },
                        {
                            key: "containsPoint",
                            value: function containsPoint(pos) {
                                return this.pointIndex(pos) >= 0;
                            }
                        },
                        {
                            key: "rangeAtPoint",
                            value: function rangeAtPoint(pos) {
                                var i = this.pointIndex(pos);
                                if (i >= 0) return this.ranges[i];
                            }
                        },
                        {
                            key: "clipRows",
                            value: function clipRows(startRow, endRow) {
                                var list = this.ranges;
                                if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow) return [];
                                var startIndex = this.pointIndex({
                                    row: startRow,
                                    column: 0
                                });
                                if (startIndex < 0) startIndex = -startIndex - 1;
                                var endIndex = this.pointIndex({
                                    row: endRow,
                                    column: 0
                                }, startIndex);
                                if (endIndex < 0) endIndex = -endIndex - 1;
                                var clipped = [];
                                for(var i = startIndex; i < endIndex; i++){
                                    clipped.push(list[i]);
                                }
                                return clipped;
                            }
                        },
                        {
                            key: "removeAll",
                            value: function removeAll() {
                                return this.ranges.splice(0, this.ranges.length);
                            }
                        },
                        {
                            key: "attach",
                            value: function attach(session) {
                                if (this.session) this.detach();
                                this.session = session;
                                this.onChange = this.$onChange.bind(this);
                                this.session.on("change", this.onChange);
                            }
                        },
                        {
                            key: "detach",
                            value: function detach() {
                                if (!this.session) return;
                                this.session.removeListener("change", this.onChange);
                                this.session = null;
                            }
                        },
                        {
                            key: "$onChange",
                            value: function $onChange(delta) {
                                var start = delta.start;
                                var end = delta.end;
                                var startRow = start.row;
                                var endRow = end.row;
                                var ranges = this.ranges;
                                for(var i = 0, n = ranges.length; i < n; i++){
                                    var r = ranges[i];
                                    if (r.end.row >= startRow) break;
                                }
                                if (delta.action == "insert") {
                                    var lineDif = endRow - startRow;
                                    var colDiff = -start.column + end.column;
                                    for(; i < n; i++){
                                        var r = ranges[i];
                                        if (r.start.row > startRow) break;
                                        if (r.start.row == startRow && r.start.column >= start.column) {
                                            if (r.start.column == start.column && this.$bias <= 0) {
                                            // do nothing
                                            } else {
                                                r.start.column += colDiff;
                                                r.start.row += lineDif;
                                            }
                                        }
                                        if (r.end.row == startRow && r.end.column >= start.column) {
                                            if (r.end.column == start.column && this.$bias < 0) {
                                                continue;
                                            }
                                            // special handling for the case when two ranges share an edge
                                            if (r.end.column == start.column && colDiff > 0 && i < n - 1) {
                                                if (r.end.column > r.start.column && r.end.column == ranges[i + 1].start.column) r.end.column -= colDiff;
                                            }
                                            r.end.column += colDiff;
                                            r.end.row += lineDif;
                                        }
                                    }
                                } else {
                                    var lineDif = startRow - endRow;
                                    var colDiff = start.column - end.column;
                                    for(; i < n; i++){
                                        var r = ranges[i];
                                        if (r.start.row > endRow) break;
                                        if (r.end.row < endRow && (startRow < r.end.row || startRow == r.end.row && start.column < r.end.column)) {
                                            r.end.row = startRow;
                                            r.end.column = start.column;
                                        } else if (r.end.row == endRow) {
                                            if (r.end.column <= end.column) {
                                                if (lineDif || r.end.column > start.column) {
                                                    r.end.column = start.column;
                                                    r.end.row = start.row;
                                                }
                                            } else {
                                                r.end.column += colDiff;
                                                r.end.row += lineDif;
                                            }
                                        } else if (r.end.row > endRow) {
                                            r.end.row += lineDif;
                                        }
                                        if (r.start.row < endRow && (startRow < r.start.row || startRow == r.start.row && start.column < r.start.column)) {
                                            r.start.row = startRow;
                                            r.start.column = start.column;
                                        } else if (r.start.row == endRow) {
                                            if (r.start.column <= end.column) {
                                                if (lineDif || r.start.column > start.column) {
                                                    r.start.column = start.column;
                                                    r.start.row = start.row;
                                                }
                                            } else {
                                                r.start.column += colDiff;
                                                r.start.row += lineDif;
                                            }
                                        } else if (r.start.row > endRow) {
                                            r.start.row += lineDif;
                                        }
                                    }
                                }
                                if (lineDif != 0 && i < n) {
                                    for(; i < n; i++){
                                        var r = ranges[i];
                                        r.start.row += lineDif;
                                        r.end.row += lineDif;
                                    }
                                }
                            }
                        }
                    ]);
                    return RangeList1;
                }();
                RangeList1.prototype.comparePoints = comparePoints;
                exports1.$ = RangeList1;
            /***/ },
            /***/ 9224: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1094577__) {
                "use strict";
                var event = __nested_webpack_require_1094577__(8215);
                /**
 * Batches changes (that force something to be redrawn) in the background.
 **/ var RenderLoop = /*#__PURE__*/ function() {
                    function RenderLoop(onRender, win) {
                        _class_call_check(this, RenderLoop);
                        this.onRender = onRender;
                        this.pending = false;
                        this.changes = 0;
                        this.$recursionLimit = 2;
                        this.window = win || window;
                        var _self = this;
                        this._flush = function(ts) {
                            _self.pending = false;
                            var changes = _self.changes;
                            if (changes) {
                                event.blockIdle(100);
                                _self.changes = 0;
                                _self.onRender(changes);
                            }
                            if (_self.changes) {
                                if (_self.$recursionLimit-- < 0) return;
                                _self.schedule();
                            } else {
                                _self.$recursionLimit = 2;
                            }
                        };
                    }
                    _create_class(RenderLoop, [
                        {
                            key: "schedule",
                            value: function schedule(change) {
                                this.changes = this.changes | change;
                                if (this.changes && !this.pending) {
                                    event.nextFrame(this._flush);
                                    this.pending = true;
                                }
                            }
                        },
                        {
                            key: "clear",
                            value: function clear(change) {
                                var changes = this.changes;
                                this.changes = 0;
                                return changes;
                            }
                        }
                    ]);
                    return RenderLoop;
                }();
                exports1.d = RenderLoop;
            /***/ },
            /***/ 6038: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1097070__) {
                "use strict";
                var __webpack_unused_export__;
                var oop = __nested_webpack_require_1097070__(2011);
                var dom = __nested_webpack_require_1097070__(5336);
                var event = __nested_webpack_require_1097070__(8215);
                var EventEmitter = __nested_webpack_require_1097070__(7858)/* .EventEmitter */ .v;
                // on ie maximal element height is smaller than what we get from 4-5K line document
                // so scrollbar doesn't work, as a workaround we do not set height higher than MAX_SCROLL_H
                // and rescale scrolltop
                var MAX_SCROLL_H = 0x8000;
                /**
 * An abstract class representing a native scrollbar control.
 **/ var Scrollbar = /*#__PURE__*/ function() {
                    function Scrollbar(parent, classSuffix) {
                        _class_call_check(this, Scrollbar);
                        this.element = dom.createElement("div");
                        this.element.className = "ace_scrollbar ace_scrollbar" + classSuffix;
                        this.inner = dom.createElement("div");
                        this.inner.className = "ace_scrollbar-inner";
                        // on safari scrollbar is not shown for empty elements
                        this.inner.textContent = "\xa0";
                        this.element.appendChild(this.inner);
                        parent.appendChild(this.element);
                        this.setVisible(false);
                        this.skipEvent = false;
                        event.addListener(this.element, "scroll", this.onScroll.bind(this));
                        event.addListener(this.element, "mousedown", event.preventDefault);
                    }
                    _create_class(Scrollbar, [
                        {
                            key: "setVisible",
                            value: function setVisible(isVisible) {
                                this.element.style.display = isVisible ? "" : "none";
                                this.isVisible = isVisible;
                                this.coeff = 1;
                            }
                        }
                    ]);
                    return Scrollbar;
                }();
                oop.implement(Scrollbar.prototype, EventEmitter);
                /**
 * Represents a vertical scroll bar.
 **/ var VScrollBar = /*#__PURE__*/ function(Scrollbar) {
                    _inherits(VScrollBar, Scrollbar);
                    var _super = _create_super(VScrollBar);
                    function VScrollBar(parent, renderer) {
                        _class_call_check(this, VScrollBar);
                        var _this;
                        _this = _super.call(this, parent, "-v");
                        _this.scrollTop = 0;
                        _this.scrollHeight = 0;
                        // in OSX lion the scrollbars appear to have no width. In this case resize the
                        // element to show the scrollbar but still pretend that the scrollbar has a width
                        // of 0px
                        // in Firefox 6+ scrollbar is hidden if element has the same width as scrollbar
                        // make element a little bit wider to retain scrollbar when page is zoomed 
                        renderer.$scrollbarWidth = _this.width = dom.scrollbarWidth(parent.ownerDocument);
                        _this.inner.style.width = _this.element.style.width = (_this.width || 15) + 5 + "px";
                        _this.$minWidth = 0;
                        return _this;
                    }
                    _create_class(VScrollBar, [
                        {
                            /**
     * Emitted when the scroll bar, well, scrolls.
     * @event scroll
     * @param {Object} e Contains one property, `"data"`, which indicates the current scroll top position
     **/ key: "onScroll",
                            value: function onScroll() {
                                if (!this.skipEvent) {
                                    this.scrollTop = this.element.scrollTop;
                                    if (this.coeff != 1) {
                                        var h = this.element.clientHeight / this.scrollHeight;
                                        this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);
                                    }
                                    this._emit("scroll", {
                                        data: this.scrollTop
                                    });
                                }
                                this.skipEvent = false;
                            }
                        },
                        {
                            /**
     * Returns the width of the scroll bar.
     * @returns {Number}
     **/ key: "getWidth",
                            value: function getWidth() {
                                return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
                            }
                        },
                        {
                            /**
     * Sets the height of the scroll bar, in pixels.
     * @param {Number} height The new height
     **/ key: "setHeight",
                            value: function setHeight(height) {
                                this.element.style.height = height + "px";
                            }
                        },
                        {
                            /**
     * Sets the scroll height of the scroll bar, in pixels.
     * @param {Number} height The new scroll height
     **/ key: "setScrollHeight",
                            value: function setScrollHeight(height) {
                                this.scrollHeight = height;
                                if (height > MAX_SCROLL_H) {
                                    this.coeff = MAX_SCROLL_H / height;
                                    height = MAX_SCROLL_H;
                                } else if (this.coeff != 1) {
                                    this.coeff = 1;
                                }
                                this.inner.style.height = height + "px";
                            }
                        },
                        {
                            /**
     * Sets the scroll top of the scroll bar.
     * @param {Number} scrollTop The new scroll top
     **/ key: "setScrollTop",
                            value: function setScrollTop(scrollTop) {
                                // on chrome 17+ for small zoom levels after calling this function
                                // this.element.scrollTop != scrollTop which makes page to scroll up.
                                if (this.scrollTop != scrollTop) {
                                    this.skipEvent = true;
                                    this.scrollTop = scrollTop;
                                    this.element.scrollTop = scrollTop * this.coeff;
                                }
                            }
                        }
                    ]);
                    return VScrollBar;
                }(Scrollbar);
                /**
 * Sets the inner height of the scroll bar, in pixels.
 * @param {Number} height The new inner height
 * @deprecated Use setScrollHeight instead
 **/ VScrollBar.prototype.setInnerHeight = VScrollBar.prototype.setScrollHeight;
                /**
 * Represents a horisontal scroll bar.
 **/ var HScrollBar = /*#__PURE__*/ function(Scrollbar) {
                    _inherits(HScrollBar, Scrollbar);
                    var _super = _create_super(HScrollBar);
                    function HScrollBar(parent, renderer) {
                        _class_call_check(this, HScrollBar);
                        var _this;
                        _this = _super.call(this, parent, "-h");
                        _this.scrollLeft = 0;
                        // in OSX lion the scrollbars appear to have no width. In this case resize the
                        // element to show the scrollbar but still pretend that the scrollbar has a width
                        // of 0px
                        // in Firefox 6+ scrollbar is hidden if element has the same width as scrollbar
                        // make element a little bit wider to retain scrollbar when page is zoomed 
                        _this.height = renderer.$scrollbarWidth;
                        _this.inner.style.height = _this.element.style.height = (_this.height || 15) + 5 + "px";
                        return _this;
                    }
                    _create_class(HScrollBar, [
                        {
                            /**
     * Emitted when the scroll bar, well, scrolls.
     * @event scroll
     * @param {Object} e Contains one property, `"data"`, which indicates the current scroll left position
     **/ key: "onScroll",
                            value: function onScroll() {
                                if (!this.skipEvent) {
                                    this.scrollLeft = this.element.scrollLeft;
                                    this._emit("scroll", {
                                        data: this.scrollLeft
                                    });
                                }
                                this.skipEvent = false;
                            }
                        },
                        {
                            /**
     * Returns the height of the scroll bar.
     * @returns {Number}
     **/ key: "getHeight",
                            value: function getHeight() {
                                return this.isVisible ? this.height : 0;
                            }
                        },
                        {
                            /**
     * Sets the width of the scroll bar, in pixels.
     * @param {Number} width The new width
     **/ key: "setWidth",
                            value: function setWidth(width) {
                                this.element.style.width = width + "px";
                            }
                        },
                        {
                            /**
     * Sets the inner width of the scroll bar, in pixels.
     * @param {Number} width The new inner width
     * @deprecated Use setScrollWidth instead
     **/ key: "setInnerWidth",
                            value: function setInnerWidth(width) {
                                this.inner.style.width = width + "px";
                            }
                        },
                        {
                            /**
     * Sets the scroll width of the scroll bar, in pixels.
     * @param {Number} width The new scroll width
     **/ key: "setScrollWidth",
                            value: function setScrollWidth(width) {
                                this.inner.style.width = width + "px";
                            }
                        },
                        {
                            /**
     * Sets the scroll left of the scroll bar.
     * @param {Number} scrollLeft The new scroll left
     **/ key: "setScrollLeft",
                            value: function setScrollLeft(scrollLeft) {
                                // on chrome 17+ for small zoom levels after calling this function
                                // this.element.scrollTop != scrollTop which makes page to scroll up.
                                if (this.scrollLeft != scrollLeft) {
                                    this.skipEvent = true;
                                    this.scrollLeft = this.element.scrollLeft = scrollLeft;
                                }
                            }
                        }
                    ]);
                    return HScrollBar;
                }(Scrollbar);
                __webpack_unused_export__ = VScrollBar; // backward compatibility
                __webpack_unused_export__ = VScrollBar; // backward compatibility
                __webpack_unused_export__ = HScrollBar; // backward compatibility
                exports1.oX = VScrollBar;
                exports1.ii = HScrollBar;
            /***/ },
            /***/ 9975: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1109352__) {
                "use strict";
                var __webpack_unused_export__;
                var oop = __nested_webpack_require_1109352__(2011);
                var dom = __nested_webpack_require_1109352__(5336);
                var event = __nested_webpack_require_1109352__(8215);
                var EventEmitter = __nested_webpack_require_1109352__(7858)/* .EventEmitter */ .v;
                dom.importCssString(".ace_editor>.ace_sb-v div, .ace_editor>.ace_sb-h div{\n  position: absolute;\n  background: rgba(128, 128, 128, 0.6);\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  border: 1px solid #bbb;\n  border-radius: 2px;\n  z-index: 8;\n}\n.ace_editor>.ace_sb-v, .ace_editor>.ace_sb-h {\n  position: absolute;\n  z-index: 6;\n  background: none;\n  overflow: hidden!important;\n}\n.ace_editor>.ace_sb-v {\n  z-index: 6;\n  right: 0;\n  top: 0;\n  width: 12px;\n}\n.ace_editor>.ace_sb-v div {\n  z-index: 8;\n  right: 0;\n  width: 100%;\n}\n.ace_editor>.ace_sb-h {\n  bottom: 0;\n  left: 0;\n  height: 12px;\n}\n.ace_editor>.ace_sb-h div {\n  bottom: 0;\n  height: 100%;\n}\n.ace_editor>.ace_sb_grabbed {\n  z-index: 8;\n  background: #000;\n}", "ace_scrollbar.css", false);
                /**
 * An abstract class representing a native scrollbar control.
 **/ var ScrollBar = /*#__PURE__*/ function() {
                    function ScrollBar(parent, classSuffix) {
                        _class_call_check(this, ScrollBar);
                        this.element = dom.createElement("div");
                        this.element.className = "ace_sb" + classSuffix;
                        this.inner = dom.createElement("div");
                        this.inner.className = "";
                        this.element.appendChild(this.inner);
                        this.VScrollWidth = 12;
                        this.HScrollHeight = 12;
                        parent.appendChild(this.element);
                        this.setVisible(false);
                        this.skipEvent = false;
                        event.addMultiMouseDownListener(this.element, [
                            500,
                            300,
                            300
                        ], this, "onMouseDown");
                    }
                    _create_class(ScrollBar, [
                        {
                            key: "setVisible",
                            value: function setVisible(isVisible) {
                                this.element.style.display = isVisible ? "" : "none";
                                this.isVisible = isVisible;
                                this.coeff = 1;
                            }
                        }
                    ]);
                    return ScrollBar;
                }();
                oop.implement(ScrollBar.prototype, EventEmitter);
                /**
 * Represents a vertical scroll bar.
 * @class VScrollBar
 **/ /**
 * Creates a new `VScrollBar`. `parent` is the owner of the scroll bar.
 * @param {Element} parent A DOM element
 * @param {Object} renderer An editor renderer
 *
 * @constructor
 **/ var VScrollBar = /*#__PURE__*/ function(ScrollBar) {
                    _inherits(VScrollBar, ScrollBar);
                    var _super = _create_super(VScrollBar);
                    function VScrollBar(parent, renderer) {
                        _class_call_check(this, VScrollBar);
                        var _this;
                        _this = _super.call(this, parent, "-v");
                        _this.scrollTop = 0;
                        _this.scrollHeight = 0;
                        _this.parent = parent;
                        _this.width = _this.VScrollWidth;
                        _this.renderer = renderer;
                        _this.inner.style.width = _this.element.style.width = (_this.width || 15) + "px";
                        _this.$minWidth = 0;
                        return _this;
                    }
                    _create_class(VScrollBar, [
                        {
                            /**
     * Emitted when the scroll thumb dragged or scrollbar canvas clicked.
     **/ key: "onMouseDown",
                            value: function onMouseDown(eType, e) {
                                if (eType !== "mousedown") return;
                                if (event.getButton(e) !== 0 || e.detail === 2) {
                                    return;
                                }
                                if (e.target === this.inner) {
                                    var _$self = this;
                                    var mousePageY = e.clientY;
                                    var onMouseMove = function onMouseMove(e) {
                                        mousePageY = e.clientY;
                                    };
                                    var onMouseUp = function onMouseUp() {
                                        clearInterval(timerId);
                                    };
                                    var startY = e.clientY;
                                    var startTop = this.thumbTop;
                                    var onScrollInterval = function onScrollInterval() {
                                        if (mousePageY === undefined) return;
                                        var scrollTop = _$self.scrollTopFromThumbTop(startTop + mousePageY - startY);
                                        if (scrollTop === _$self.scrollTop) return;
                                        _$self._emit("scroll", {
                                            data: scrollTop
                                        });
                                    };
                                    event.capture(this.inner, onMouseMove, onMouseUp);
                                    var timerId = setInterval(onScrollInterval, 20);
                                    return event.preventDefault(e);
                                }
                                var top = e.clientY - this.element.getBoundingClientRect().top - this.thumbHeight / 2;
                                this._emit("scroll", {
                                    data: this.scrollTopFromThumbTop(top)
                                });
                                return event.preventDefault(e);
                            }
                        },
                        {
                            key: "getHeight",
                            value: function getHeight() {
                                return this.height;
                            }
                        },
                        {
                            /**
     * Returns new top for scroll thumb
     * @param {Number}thumbTop
     * @returns {Number}
     **/ key: "scrollTopFromThumbTop",
                            value: function scrollTopFromThumbTop(thumbTop) {
                                var scrollTop = thumbTop * (this.pageHeight - this.viewHeight) / (this.slideHeight - this.thumbHeight);
                                scrollTop = scrollTop >> 0;
                                if (scrollTop < 0) {
                                    scrollTop = 0;
                                } else if (scrollTop > this.pageHeight - this.viewHeight) {
                                    scrollTop = this.pageHeight - this.viewHeight;
                                }
                                return scrollTop;
                            }
                        },
                        {
                            /**
     * Returns the width of the scroll bar.
     * @returns {Number}
     **/ key: "getWidth",
                            value: function getWidth() {
                                return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
                            }
                        },
                        {
                            /**
     * Sets the height of the scroll bar, in pixels.
     * @param {Number} height The new height
     **/ key: "setHeight",
                            value: function setHeight(height) {
                                this.height = Math.max(0, height);
                                this.slideHeight = this.height;
                                this.viewHeight = this.height;
                                this.setScrollHeight(this.pageHeight, true);
                            }
                        },
                        {
                            /**
     * Sets the inner and scroll height of the scroll bar, in pixels.
     * @param {Number} height The new inner height
     *
     * @param {boolean} force Forcely update height
     **/ key: "setScrollHeight",
                            value: function setScrollHeight(height, force) {
                                if (this.pageHeight === height && !force) return;
                                this.pageHeight = height;
                                this.thumbHeight = this.slideHeight * this.viewHeight / this.pageHeight;
                                if (this.thumbHeight > this.slideHeight) this.thumbHeight = this.slideHeight;
                                if (this.thumbHeight < 15) this.thumbHeight = 15;
                                this.inner.style.height = this.thumbHeight + "px";
                                if (this.scrollTop > this.pageHeight - this.viewHeight) {
                                    this.scrollTop = this.pageHeight - this.viewHeight;
                                    if (this.scrollTop < 0) this.scrollTop = 0;
                                    this._emit("scroll", {
                                        data: this.scrollTop
                                    });
                                }
                            }
                        },
                        {
                            /**
     * Sets the scroll top of the scroll bar.
     * @param {Number} scrollTop The new scroll top
     **/ key: "setScrollTop",
                            value: function setScrollTop(scrollTop) {
                                this.scrollTop = scrollTop;
                                if (scrollTop < 0) scrollTop = 0;
                                this.thumbTop = scrollTop * (this.slideHeight - this.thumbHeight) / (this.pageHeight - this.viewHeight);
                                this.inner.style.top = this.thumbTop + "px";
                            }
                        }
                    ]);
                    return VScrollBar;
                }(ScrollBar);
                VScrollBar.prototype.setInnerHeight = VScrollBar.prototype.setScrollHeight;
                /**
 * Represents a horizontal scroll bar.
 **/ var HScrollBar = /*#__PURE__*/ function(ScrollBar) {
                    _inherits(HScrollBar, ScrollBar);
                    var _super = _create_super(HScrollBar);
                    function HScrollBar(parent, renderer) {
                        _class_call_check(this, HScrollBar);
                        var _this;
                        _this = _super.call(this, parent, "-h");
                        _this.scrollLeft = 0;
                        _this.scrollWidth = 0;
                        _this.height = _this.HScrollHeight;
                        _this.inner.style.height = _this.element.style.height = (_this.height || 12) + "px";
                        _this.renderer = renderer;
                        return _this;
                    }
                    _create_class(HScrollBar, [
                        {
                            /**
     * Emitted when the scroll thumb dragged or scrollbar canvas clicked.
     **/ key: "onMouseDown",
                            value: function onMouseDown(eType, e) {
                                if (eType !== "mousedown") return;
                                if (event.getButton(e) !== 0 || e.detail === 2) {
                                    return;
                                }
                                if (e.target === this.inner) {
                                    var _$self = this;
                                    var mousePageX = e.clientX;
                                    var onMouseMove = function onMouseMove(e) {
                                        mousePageX = e.clientX;
                                    };
                                    var onMouseUp = function onMouseUp() {
                                        clearInterval(timerId);
                                    };
                                    var startX = e.clientX;
                                    var startLeft = this.thumbLeft;
                                    var onScrollInterval = function onScrollInterval() {
                                        if (mousePageX === undefined) return;
                                        var scrollLeft = _$self.scrollLeftFromThumbLeft(startLeft + mousePageX - startX);
                                        if (scrollLeft === _$self.scrollLeft) return;
                                        _$self._emit("scroll", {
                                            data: scrollLeft
                                        });
                                    };
                                    event.capture(this.inner, onMouseMove, onMouseUp);
                                    var timerId = setInterval(onScrollInterval, 20);
                                    return event.preventDefault(e);
                                }
                                var left = e.clientX - this.element.getBoundingClientRect().left - this.thumbWidth / 2;
                                this._emit("scroll", {
                                    data: this.scrollLeftFromThumbLeft(left)
                                });
                                return event.preventDefault(e);
                            }
                        },
                        {
                            /**
     * Returns the height of the scroll bar.
     * @returns {Number}
     **/ key: "getHeight",
                            value: function getHeight() {
                                return this.isVisible ? this.height : 0;
                            }
                        },
                        {
                            /**
     * Returns new left for scroll thumb
     * @param {Number} thumbLeft
     * @returns {Number}
     **/ key: "scrollLeftFromThumbLeft",
                            value: function scrollLeftFromThumbLeft(thumbLeft) {
                                var scrollLeft = thumbLeft * (this.pageWidth - this.viewWidth) / (this.slideWidth - this.thumbWidth);
                                scrollLeft = scrollLeft >> 0;
                                if (scrollLeft < 0) {
                                    scrollLeft = 0;
                                } else if (scrollLeft > this.pageWidth - this.viewWidth) {
                                    scrollLeft = this.pageWidth - this.viewWidth;
                                }
                                return scrollLeft;
                            }
                        },
                        {
                            /**
     * Sets the width of the scroll bar, in pixels.
     * @param {Number} width The new width
     **/ key: "setWidth",
                            value: function setWidth(width) {
                                this.width = Math.max(0, width);
                                this.element.style.width = this.width + "px";
                                this.slideWidth = this.width;
                                this.viewWidth = this.width;
                                this.setScrollWidth(this.pageWidth, true);
                            }
                        },
                        {
                            /**
     * Sets the inner and scroll width of the scroll bar, in pixels.
     * @param {Number} width The new inner width
     * @param {boolean} force Forcely update width
     **/ key: "setScrollWidth",
                            value: function setScrollWidth(width, force) {
                                if (this.pageWidth === width && !force) return;
                                this.pageWidth = width;
                                this.thumbWidth = this.slideWidth * this.viewWidth / this.pageWidth;
                                if (this.thumbWidth > this.slideWidth) this.thumbWidth = this.slideWidth;
                                if (this.thumbWidth < 15) this.thumbWidth = 15;
                                this.inner.style.width = this.thumbWidth + "px";
                                if (this.scrollLeft > this.pageWidth - this.viewWidth) {
                                    this.scrollLeft = this.pageWidth - this.viewWidth;
                                    if (this.scrollLeft < 0) this.scrollLeft = 0;
                                    this._emit("scroll", {
                                        data: this.scrollLeft
                                    });
                                }
                            }
                        },
                        {
                            /**
     * Sets the scroll left of the scroll bar.
     * @param {Number} scrollLeft The new scroll left
     **/ key: "setScrollLeft",
                            value: function setScrollLeft(scrollLeft) {
                                this.scrollLeft = scrollLeft;
                                if (scrollLeft < 0) scrollLeft = 0;
                                this.thumbLeft = scrollLeft * (this.slideWidth - this.thumbWidth) / (this.pageWidth - this.viewWidth);
                                this.inner.style.left = this.thumbLeft + "px";
                            }
                        }
                    ]);
                    return HScrollBar;
                }(ScrollBar);
                HScrollBar.prototype.setInnerWidth = HScrollBar.prototype.setScrollWidth;
                __webpack_unused_export__ = VScrollBar; // backward compatibility
                __webpack_unused_export__ = VScrollBar; // backward compatibility
                __webpack_unused_export__ = HScrollBar; // backward compatibility
                exports1.oX = VScrollBar;
                exports1.ii = HScrollBar;
            /***/ },
            /***/ 3002: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1127755__) {
                "use strict";
                var addWordBoundary = function addWordBoundary(needle, options) {
                    function wordBoundary(c) {
                        if (/\w/.test(c) || options.regExp) return "\\b";
                        return "";
                    }
                    return wordBoundary(needle[0]) + needle + wordBoundary(needle[needle.length - 1]);
                };
                var lang = __nested_webpack_require_1127755__(732);
                var oop = __nested_webpack_require_1127755__(2011);
                var Range = __nested_webpack_require_1127755__(3069)/* .Range */ .e;
                /**
 * A class designed to handle all sorts of text searches within a [[Document `Document`]].
 **/ var Search = /*#__PURE__*/ function() {
                    function Search() {
                        _class_call_check(this, Search);
                        this.$options = {};
                    }
                    _create_class(Search, [
                        {
                            /**
     * Sets the search options via the `options` parameter.
     * @param {Object} options An object containing all the new search properties
     *
     * 
     * @returns {Search}
     * @chainable
    **/ key: "set",
                            value: function set(options) {
                                oop.mixin(this.$options, options);
                                return this;
                            }
                        },
                        {
                            /**
     * [Returns an object containing all the search options.]{: #Search.getOptions}
     * @returns {Object}
    **/ key: "getOptions",
                            value: function getOptions() {
                                return lang.copyObject(this.$options);
                            }
                        },
                        {
                            /**
     * Sets the search options via the `options` parameter.
     * @param {Object} options object containing all the search propertie
     * @related Search.set
    **/ key: "setOptions",
                            value: function setOptions(options) {
                                this.$options = options;
                            }
                        },
                        {
                            /**
     * Searches for `options.needle`. If found, this method returns the [[Range `Range`]] where the text first occurs. If `options.backwards` is `true`, the search goes backwards in the session.
     * @param {EditSession} session The session to search with
     *
     * 
     * @returns {Range}
    **/ key: "find",
                            value: function find(session) {
                                var options = this.$options;
                                var iterator = this.$matchIterator(session, options);
                                if (!iterator) return false;
                                var firstRange = null;
                                iterator.forEach(function(sr, sc, er, ec) {
                                    firstRange = new Range(sr, sc, er, ec);
                                    if (sc == ec && options.start && options.start.start && options.skipCurrent != false && firstRange.isEqual(options.start)) {
                                        firstRange = null;
                                        return false;
                                    }
                                    return true;
                                });
                                return firstRange;
                            }
                        },
                        {
                            /**
     * Searches for all occurrances `options.needle`. If found, this method returns an array of [[Range `Range`s]] where the text first occurs. If `options.backwards` is `true`, the search goes backwards in the session.
     * @param {EditSession} session The session to search with
     *
     * 
     * @returns {[Range]}
    **/ key: "findAll",
                            value: function findAll(session) {
                                var options = this.$options;
                                if (!options.needle) return [];
                                this.$assembleRegExp(options);
                                var range = options.range;
                                var lines = range ? session.getLines(range.start.row, range.end.row) : session.doc.getAllLines();
                                var ranges = [];
                                var re = options.re;
                                if (options.$isMultiLine) {
                                    var len = re.length;
                                    var maxRow = lines.length - len;
                                    var prevRange;
                                    outer: for(var row = re.offset || 0; row <= maxRow; row++){
                                        for(var j = 0; j < len; j++)if (lines[row + j].search(re[j]) == -1) continue outer;
                                        var startLine = lines[row];
                                        var line = lines[row + len - 1];
                                        var startIndex = startLine.length - startLine.match(re[0])[0].length;
                                        var endIndex = line.match(re[len - 1])[0].length;
                                        if (prevRange && prevRange.end.row === row && prevRange.end.column > startIndex) {
                                            continue;
                                        }
                                        ranges.push(prevRange = new Range(row, startIndex, row + len - 1, endIndex));
                                        if (len > 2) row = row + len - 2;
                                    }
                                } else {
                                    for(var i = 0; i < lines.length; i++){
                                        var matches = lang.getMatchOffsets(lines[i], re);
                                        for(var j = 0; j < matches.length; j++){
                                            var match = matches[j];
                                            ranges.push(new Range(i, match.offset, i, match.offset + match.length));
                                        }
                                    }
                                }
                                if (range) {
                                    var startColumn = range.start.column;
                                    var endColumn = range.end.column;
                                    var i = 0, j = ranges.length - 1;
                                    while(i < j && ranges[i].start.column < startColumn && ranges[i].start.row == 0)i++;
                                    var endRow = range.end.row - range.start.row;
                                    while(i < j && ranges[j].end.column > endColumn && ranges[j].end.row == endRow)j--;
                                    ranges = ranges.slice(i, j + 1);
                                    for(i = 0, j = ranges.length; i < j; i++){
                                        ranges[i].start.row += range.start.row;
                                        ranges[i].end.row += range.start.row;
                                    }
                                }
                                return ranges;
                            }
                        },
                        {
                            /**
     * Searches for `options.needle` in `input`, and, if found, replaces it with `replacement`.
     * @param {String} input The text to search in
     * @param {String} replacement The replacing text
     * + (String): If `options.regExp` is `true`, this function returns `input` with the replacement already made. Otherwise, this function just returns `replacement`.<br/>
     * If `options.needle` was not found, this function returns `null`.
     *
     * 
     * @returns {String}
    **/ key: "replace",
                            value: function replace(input, replacement) {
                                var options = this.$options;
                                var re = this.$assembleRegExp(options);
                                if (options.$isMultiLine) return replacement;
                                if (!re) return;
                                var match = re.exec(input);
                                if (!match || match[0].length != input.length) return null;
                                replacement = input.replace(re, replacement);
                                if (options.preserveCase) {
                                    replacement = replacement.split("");
                                    for(var i = Math.min(input.length, input.length); i--;){
                                        var ch = input[i];
                                        if (ch && ch.toLowerCase() != ch) replacement[i] = replacement[i].toUpperCase();
                                        else replacement[i] = replacement[i].toLowerCase();
                                    }
                                    replacement = replacement.join("");
                                }
                                return replacement;
                            }
                        },
                        {
                            key: "$assembleRegExp",
                            value: function $assembleRegExp(options, $disableFakeMultiline) {
                                if (_instanceof(options.needle, RegExp)) return options.re = options.needle;
                                var needle = options.needle;
                                if (!options.needle) return options.re = false;
                                if (!options.regExp) needle = lang.escapeRegExp(needle);
                                if (options.wholeWord) needle = addWordBoundary(needle, options);
                                var modifier = options.caseSensitive ? "gm" : "gmi";
                                options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
                                if (options.$isMultiLine) return options.re = this.$assembleMultilineRegExp(needle, modifier);
                                try {
                                    var re = new RegExp(needle, modifier);
                                } catch (e) {
                                    re = false;
                                }
                                return options.re = re;
                            }
                        },
                        {
                            key: "$assembleMultilineRegExp",
                            value: function $assembleMultilineRegExp(needle, modifier) {
                                var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
                                var re = [];
                                for(var i = 0; i < parts.length; i++)try {
                                    re.push(new RegExp(parts[i], modifier));
                                } catch (e) {
                                    return false;
                                }
                                return re;
                            }
                        },
                        {
                            key: "$matchIterator",
                            value: function $matchIterator(session, options) {
                                var re = this.$assembleRegExp(options);
                                if (!re) return false;
                                var backwards = options.backwards == true;
                                var skipCurrent = options.skipCurrent != false;
                                var range = options.range;
                                var start = options.start;
                                if (!start) start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();
                                if (start.start) start = start[skipCurrent != backwards ? "end" : "start"];
                                var firstRow = range ? range.start.row : 0;
                                var lastRow = range ? range.end.row : session.getLength() - 1;
                                if (backwards) {
                                    var forEach = function forEach(callback) {
                                        var row = start.row;
                                        if (forEachInLine(row, start.column, callback)) return;
                                        for(row--; row >= firstRow; row--)if (forEachInLine(row, Number.MAX_VALUE, callback)) return;
                                        if (options.wrap == false) return;
                                        for(row = lastRow, firstRow = start.row; row >= firstRow; row--)if (forEachInLine(row, Number.MAX_VALUE, callback)) return;
                                    };
                                } else {
                                    var forEach = function forEach(callback) {
                                        var row = start.row;
                                        if (forEachInLine(row, start.column, callback)) return;
                                        for(row = row + 1; row <= lastRow; row++)if (forEachInLine(row, 0, callback)) return;
                                        if (options.wrap == false) return;
                                        for(row = firstRow, lastRow = start.row; row <= lastRow; row++)if (forEachInLine(row, 0, callback)) return;
                                    };
                                }
                                if (options.$isMultiLine) {
                                    var len = re.length;
                                    var forEachInLine = function forEachInLine(row, offset, callback) {
                                        var startRow = backwards ? row - len + 1 : row;
                                        if (startRow < 0 || startRow + len > session.getLength()) return;
                                        var line = session.getLine(startRow);
                                        var startIndex = line.search(re[0]);
                                        if (!backwards && startIndex < offset || startIndex === -1) return;
                                        for(var i = 1; i < len; i++){
                                            line = session.getLine(startRow + i);
                                            if (line.search(re[i]) == -1) return;
                                        }
                                        var endIndex = line.match(re[len - 1])[0].length;
                                        if (backwards && endIndex > offset) return;
                                        if (callback(startRow, startIndex, startRow + len - 1, endIndex)) return true;
                                    };
                                } else if (backwards) {
                                    var forEachInLine = function forEachInLine(row, endIndex, callback) {
                                        var line = session.getLine(row);
                                        var matches = [];
                                        var m, last = 0;
                                        re.lastIndex = 0;
                                        while(m = re.exec(line)){
                                            var length = m[0].length;
                                            last = m.index;
                                            if (!length) {
                                                if (last >= line.length) break;
                                                re.lastIndex = last += 1;
                                            }
                                            if (m.index + length > endIndex) break;
                                            matches.push(m.index, length);
                                        }
                                        for(var i = matches.length - 1; i >= 0; i -= 2){
                                            var column = matches[i - 1];
                                            var length = matches[i];
                                            if (callback(row, column, row, column + length)) return true;
                                        }
                                    };
                                } else {
                                    var forEachInLine = function forEachInLine(row, startIndex, callback) {
                                        var line = session.getLine(row);
                                        var last;
                                        var m;
                                        re.lastIndex = startIndex;
                                        while(m = re.exec(line)){
                                            var length = m[0].length;
                                            last = m.index;
                                            if (callback(row, last, row, last + length)) return true;
                                            if (!length) {
                                                re.lastIndex = last += 1;
                                                if (last >= line.length) return false;
                                            }
                                        }
                                    };
                                }
                                return {
                                    forEach: forEach
                                };
                            }
                        }
                    ]);
                    return Search;
                }();
                exports1.o = Search;
            /***/ },
            /***/ 349: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1145690__) {
                "use strict";
                var lang = __nested_webpack_require_1145690__(732);
                var Range = __nested_webpack_require_1145690__(3069)/* .Range */ .e;
                var SearchHighlight = /*#__PURE__*/ function() {
                    function SearchHighlight(regExp, clazz) {
                        var type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "text";
                        _class_call_check(this, SearchHighlight);
                        this.setRegexp(regExp);
                        this.clazz = clazz;
                        this.type = type;
                    }
                    _create_class(SearchHighlight, [
                        {
                            key: "setRegexp",
                            value: function setRegexp(regExp) {
                                if (this.regExp + "" == regExp + "") return;
                                this.regExp = regExp;
                                this.cache = [];
                            }
                        },
                        {
                            key: "update",
                            value: function update(html, markerLayer, session, config) {
                                if (!this.regExp) return;
                                var start = config.firstRow, end = config.lastRow;
                                var renderedMarkerRanges = {};
                                for(var i = start; i <= end; i++){
                                    var ranges = this.cache[i];
                                    if (ranges == null) {
                                        ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
                                        if (ranges.length > this.MAX_RANGES) ranges = ranges.slice(0, this.MAX_RANGES);
                                        ranges = ranges.map(function(match) {
                                            return new Range(i, match.offset, i, match.offset + match.length);
                                        });
                                        this.cache[i] = ranges.length ? ranges : "";
                                    }
                                    for(var j = ranges.length; j--;){
                                        var rangeToAddMarkerTo = ranges[j].toScreenRange(session);
                                        var rangeAsString = rangeToAddMarkerTo.toString();
                                        if (renderedMarkerRanges[rangeAsString]) continue;
                                        renderedMarkerRanges[rangeAsString] = true;
                                        markerLayer.drawSingleLineMarker(html, rangeToAddMarkerTo, this.clazz, config);
                                    }
                                }
                            }
                        }
                    ]);
                    return SearchHighlight;
                }();
                // needed to prevent long lines from freezing the browser
                SearchHighlight.prototype.MAX_RANGES = 500;
                exports1.t = SearchHighlight;
            /***/ },
            /***/ 4720: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1148927__) {
                "use strict";
                var oop = __nested_webpack_require_1148927__(2011);
                var lang = __nested_webpack_require_1148927__(732);
                var EventEmitter = __nested_webpack_require_1148927__(7858)/* .EventEmitter */ .v;
                var Range = __nested_webpack_require_1148927__(3069)/* .Range */ .e;
                /**
 * Contains the cursor position and the text selection of an edit session.
 *
 * The row/columns used in the selection are in document coordinates representing the coordinates as they appear in the document before applying soft wrap and folding.
 * @class Selection
 **/ /**
 * Emitted when the cursor position changes.
 * @event changeCursor
 *
 **/ /**
 * Emitted when the cursor selection changes.
 *
 *  @event changeSelection
 **/ /**
 * Creates a new `Selection` object.
 * @param {EditSession} session The session to use
 *
 * @constructor
 **/ var Selection = function Selection(session) {
                    this.session = session;
                    this.doc = session.getDocument();
                    this.clearSelection();
                    this.cursor = this.lead = this.doc.createAnchor(0, 0);
                    this.anchor = this.doc.createAnchor(0, 0);
                    this.$silent = false;
                    var _$self = this;
                    this.cursor.on("change", function(e) {
                        _$self.$cursorChanged = true;
                        if (!_$self.$silent) _$self._emit("changeCursor");
                        if (!_$self.$isEmpty && !_$self.$silent) _$self._emit("changeSelection");
                        if (!_$self.$keepDesiredColumnOnChange && e.old.column != e.value.column) _$self.$desiredColumn = null;
                    });
                    this.anchor.on("change", function() {
                        _$self.$anchorChanged = true;
                        if (!_$self.$isEmpty && !_$self.$silent) _$self._emit("changeSelection");
                    });
                };
                (function() {
                    oop.implement(this, EventEmitter);
                    /**
     * Returns `true` if the selection is empty.
     * @returns {Boolean}
     **/ this.isEmpty = function() {
                        return this.$isEmpty || this.anchor.row == this.lead.row && this.anchor.column == this.lead.column;
                    };
                    /**
     * Returns `true` if the selection is a multi-line.
     * @returns {Boolean}
     **/ this.isMultiLine = function() {
                        return !this.$isEmpty && this.anchor.row != this.cursor.row;
                    };
                    /**
     * Returns an object containing the `row` and `column` current position of the cursor.
     * @returns {Object}
     **/ this.getCursor = function() {
                        return this.lead.getPosition();
                    };
                    /**
     * Sets the row and column position of the anchor. This function also emits the `'changeSelection'` event.
     * @param {Number} row The new row
     * @param {Number} column The new column
     *
     **/ this.setAnchor = function(row, column) {
                        this.$isEmpty = false;
                        this.anchor.setPosition(row, column);
                    };
                    /**
     * Left for backward compatibility
     * @deprecated
     */ this.setSelectionAnchor = this.setAnchor;
                    /**
     * Returns an object containing the `row` and `column` of the calling selection anchor.
     *
     * @returns {Object}
     * @related Anchor.getPosition
     **/ this.getAnchor = function() {
                        if (this.$isEmpty) return this.getSelectionLead();
                        return this.anchor.getPosition();
                    };
                    /**
     * Left for backward compatibility
     * @deprecated
     */ this.getSelectionAnchor = this.getAnchor;
                    /**
     * Returns an object containing the `row` and `column` of the calling selection lead.
     * @returns {Object}
     **/ this.getSelectionLead = function() {
                        return this.lead.getPosition();
                    };
                    /**
     * Returns `true` if the selection is going backwards in the document.
     * @returns {Boolean}
     **/ this.isBackwards = function() {
                        var anchor = this.anchor;
                        var lead = this.lead;
                        return anchor.row > lead.row || anchor.row == lead.row && anchor.column > lead.column;
                    };
                    /**
     * [Returns the [[Range]] for the selected text.]{: #Selection.getRange}
     * @returns {Range}
     **/ this.getRange = function() {
                        var anchor = this.anchor;
                        var lead = this.lead;
                        if (this.$isEmpty) return Range.fromPoints(lead, lead);
                        return this.isBackwards() ? Range.fromPoints(lead, anchor) : Range.fromPoints(anchor, lead);
                    };
                    /**
     * [Empties the selection (by de-selecting it). This function also emits the `'changeSelection'` event.]{: #Selection.clearSelection}
     **/ this.clearSelection = function() {
                        if (!this.$isEmpty) {
                            this.$isEmpty = true;
                            this._emit("changeSelection");
                        }
                    };
                    /**
     * Selects all the text in the document.
     **/ this.selectAll = function() {
                        this.$setSelection(0, 0, Number.MAX_VALUE, Number.MAX_VALUE);
                    };
                    /**
     * Sets the selection to the provided range.
     * @param {Range} range The range of text to select
     * @param {Boolean} reverse Indicates if the range should go backwards (`true`) or not
     *
     * @method setSelectionRange
     * @alias setRange
     **/ this.setRange = this.setSelectionRange = function(range, reverse) {
                        var start = reverse ? range.end : range.start;
                        var end = reverse ? range.start : range.end;
                        this.$setSelection(start.row, start.column, end.row, end.column);
                    };
                    this.$setSelection = function(anchorRow, anchorColumn, cursorRow, cursorColumn) {
                        if (this.$silent) return;
                        var wasEmpty = this.$isEmpty;
                        var wasMultiselect = this.inMultiSelectMode;
                        this.$silent = true;
                        this.$cursorChanged = this.$anchorChanged = false;
                        this.anchor.setPosition(anchorRow, anchorColumn);
                        this.cursor.setPosition(cursorRow, cursorColumn);
                        this.$isEmpty = !Range.comparePoints(this.anchor, this.cursor);
                        this.$silent = false;
                        if (this.$cursorChanged) this._emit("changeCursor");
                        if (this.$cursorChanged || this.$anchorChanged || wasEmpty != this.$isEmpty || wasMultiselect) this._emit("changeSelection");
                    };
                    this.$moveSelection = function(mover) {
                        var lead = this.lead;
                        if (this.$isEmpty) this.setSelectionAnchor(lead.row, lead.column);
                        mover.call(this);
                    };
                    /**
     * Moves the selection cursor to the indicated row and column.
     * @param {Number} row The row to select to
     * @param {Number} column The column to select to
     **/ this.selectTo = function(row, column) {
                        this.$moveSelection(function() {
                            this.moveCursorTo(row, column);
                        });
                    };
                    /**
     * Moves the selection cursor to the row and column indicated by `pos`.
     * @param {Object} pos An object containing the row and column
     **/ this.selectToPosition = function(pos) {
                        this.$moveSelection(function() {
                            this.moveCursorToPosition(pos);
                        });
                    };
                    /**
     * Moves the selection cursor to the indicated row and column.
     * @param {Number} row The row to select to
     * @param {Number} column The column to select to
     *
     **/ this.moveTo = function(row, column) {
                        this.clearSelection();
                        this.moveCursorTo(row, column);
                    };
                    /**
     * Moves the selection cursor to the row and column indicated by `pos`.
     * @param {Object} pos An object containing the row and column
     **/ this.moveToPosition = function(pos) {
                        this.clearSelection();
                        this.moveCursorToPosition(pos);
                    };
                    /**
     * Moves the selection up one row.
     **/ this.selectUp = function() {
                        this.$moveSelection(this.moveCursorUp);
                    };
                    /**
     * Moves the selection down one row.
     **/ this.selectDown = function() {
                        this.$moveSelection(this.moveCursorDown);
                    };
                    /**
     * Moves the selection right one column.
     **/ this.selectRight = function() {
                        this.$moveSelection(this.moveCursorRight);
                    };
                    /**
     * Moves the selection left one column.
     **/ this.selectLeft = function() {
                        this.$moveSelection(this.moveCursorLeft);
                    };
                    /**
     * Moves the selection to the beginning of the current line.
     **/ this.selectLineStart = function() {
                        this.$moveSelection(this.moveCursorLineStart);
                    };
                    /**
     * Moves the selection to the end of the current line.
     **/ this.selectLineEnd = function() {
                        this.$moveSelection(this.moveCursorLineEnd);
                    };
                    /**
     * Moves the selection to the end of the file.
     **/ this.selectFileEnd = function() {
                        this.$moveSelection(this.moveCursorFileEnd);
                    };
                    /**
     * Moves the selection to the start of the file.
     **/ this.selectFileStart = function() {
                        this.$moveSelection(this.moveCursorFileStart);
                    };
                    /**
     * Moves the selection to the first word on the right.
     **/ this.selectWordRight = function() {
                        this.$moveSelection(this.moveCursorWordRight);
                    };
                    /**
     * Moves the selection to the first word on the left.
     **/ this.selectWordLeft = function() {
                        this.$moveSelection(this.moveCursorWordLeft);
                    };
                    /**
     * Moves the selection to highlight the entire word.
     * @related EditSession.getWordRange
     **/ this.getWordRange = function(row, column) {
                        if (typeof column == "undefined") {
                            var cursor = row || this.lead;
                            row = cursor.row;
                            column = cursor.column;
                        }
                        return this.session.getWordRange(row, column);
                    };
                    /**
     * Selects an entire word boundary.
     **/ this.selectWord = function() {
                        this.setSelectionRange(this.getWordRange());
                    };
                    /**
     * Selects a word, including its right whitespace.
     * @related EditSession.getAWordRange
     **/ this.selectAWord = function() {
                        var cursor = this.getCursor();
                        var range = this.session.getAWordRange(cursor.row, cursor.column);
                        this.setSelectionRange(range);
                    };
                    this.getLineRange = function(row, excludeLastChar) {
                        var rowStart = typeof row == "number" ? row : this.lead.row;
                        var rowEnd;
                        var foldLine = this.session.getFoldLine(rowStart);
                        if (foldLine) {
                            rowStart = foldLine.start.row;
                            rowEnd = foldLine.end.row;
                        } else {
                            rowEnd = rowStart;
                        }
                        if (excludeLastChar === true) return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
                        else return new Range(rowStart, 0, rowEnd + 1, 0);
                    };
                    /**
     * Selects the entire line.
     **/ this.selectLine = function() {
                        this.setSelectionRange(this.getLineRange());
                    };
                    /**
     * Moves the cursor up one row.
     **/ this.moveCursorUp = function() {
                        this.moveCursorBy(-1, 0);
                    };
                    /**
     * Moves the cursor down one row.
     **/ this.moveCursorDown = function() {
                        this.moveCursorBy(1, 0);
                    };
                    /**
     *
     * Returns `true` if moving the character next to the cursor in the specified direction is a soft tab.
     * @param {Object} cursor the current cursor position
     * @param {Number} tabSize the tab size
     * @param {Number} direction 1 for right, -1 for left
     */ this.wouldMoveIntoSoftTab = function(cursor, tabSize, direction) {
                        var start = cursor.column;
                        var end = cursor.column + tabSize;
                        if (direction < 0) {
                            start = cursor.column - tabSize;
                            end = cursor.column;
                        }
                        return this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(start, end).split(" ").length - 1 == tabSize;
                    };
                    /**
     * Moves the cursor left one column.
     **/ this.moveCursorLeft = function() {
                        var cursor = this.lead.getPosition(), fold;
                        if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
                            this.moveCursorTo(fold.start.row, fold.start.column);
                        } else if (cursor.column === 0) {
                            // cursor is a line (start
                            if (cursor.row > 0) {
                                this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
                            }
                        } else {
                            var tabSize = this.session.getTabSize();
                            if (this.wouldMoveIntoSoftTab(cursor, tabSize, -1) && !this.session.getNavigateWithinSoftTabs()) {
                                this.moveCursorBy(0, -tabSize);
                            } else {
                                this.moveCursorBy(0, -1);
                            }
                        }
                    };
                    /**
     * Moves the cursor right one column.
     **/ this.moveCursorRight = function() {
                        var cursor = this.lead.getPosition(), fold;
                        if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
                            this.moveCursorTo(fold.end.row, fold.end.column);
                        } else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
                            if (this.lead.row < this.doc.getLength() - 1) {
                                this.moveCursorTo(this.lead.row + 1, 0);
                            }
                        } else {
                            var tabSize = this.session.getTabSize();
                            var cursor = this.lead;
                            if (this.wouldMoveIntoSoftTab(cursor, tabSize, 1) && !this.session.getNavigateWithinSoftTabs()) {
                                this.moveCursorBy(0, tabSize);
                            } else {
                                this.moveCursorBy(0, 1);
                            }
                        }
                    };
                    /**
     * Moves the cursor to the start of the line.
     **/ this.moveCursorLineStart = function() {
                        var row = this.lead.row;
                        var column = this.lead.column;
                        var screenRow = this.session.documentToScreenRow(row, column);
                        // Determ the doc-position of the first character at the screen line.
                        var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
                        // Determ the line
                        var beforeCursor = this.session.getDisplayLine(row, null, firstColumnPosition.row, firstColumnPosition.column);
                        var leadingSpace = beforeCursor.match(/^\s*/);
                        // TODO find better way for emacs mode to override selection behaviors
                        if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart) firstColumnPosition.column += leadingSpace[0].length;
                        this.moveCursorToPosition(firstColumnPosition);
                    };
                    /**
     * Moves the cursor to the end of the line.
     **/ this.moveCursorLineEnd = function() {
                        var lead = this.lead;
                        var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
                        if (this.lead.column == lineEnd.column) {
                            var line = this.session.getLine(lineEnd.row);
                            if (lineEnd.column == line.length) {
                                var textEnd = line.search(/\s+$/);
                                if (textEnd > 0) lineEnd.column = textEnd;
                            }
                        }
                        this.moveCursorTo(lineEnd.row, lineEnd.column);
                    };
                    /**
     * Moves the cursor to the end of the file.
     **/ this.moveCursorFileEnd = function() {
                        var row = this.doc.getLength() - 1;
                        var column = this.doc.getLine(row).length;
                        this.moveCursorTo(row, column);
                    };
                    /**
     * Moves the cursor to the start of the file.
     **/ this.moveCursorFileStart = function() {
                        this.moveCursorTo(0, 0);
                    };
                    /**
     * Moves the cursor to the word on the right.
     **/ this.moveCursorLongWordRight = function() {
                        var row = this.lead.row;
                        var column = this.lead.column;
                        var line = this.doc.getLine(row);
                        var rightOfCursor = line.substring(column);
                        this.session.nonTokenRe.lastIndex = 0;
                        this.session.tokenRe.lastIndex = 0;
                        // skip folds
                        var fold = this.session.getFoldAt(row, column, 1);
                        if (fold) {
                            this.moveCursorTo(fold.end.row, fold.end.column);
                            return;
                        }
                        // first skip space
                        if (this.session.nonTokenRe.exec(rightOfCursor)) {
                            column += this.session.nonTokenRe.lastIndex;
                            this.session.nonTokenRe.lastIndex = 0;
                            rightOfCursor = line.substring(column);
                        }
                        // if at line end proceed with next line
                        if (column >= line.length) {
                            this.moveCursorTo(row, line.length);
                            this.moveCursorRight();
                            if (row < this.doc.getLength() - 1) this.moveCursorWordRight();
                            return;
                        }
                        // advance to the end of the next token
                        if (this.session.tokenRe.exec(rightOfCursor)) {
                            column += this.session.tokenRe.lastIndex;
                            this.session.tokenRe.lastIndex = 0;
                        }
                        this.moveCursorTo(row, column);
                    };
                    /**
    *
    * Moves the cursor to the word on the left.
    **/ this.moveCursorLongWordLeft = function() {
                        var row = this.lead.row;
                        var column = this.lead.column;
                        // skip folds
                        var fold;
                        if (fold = this.session.getFoldAt(row, column, -1)) {
                            this.moveCursorTo(fold.start.row, fold.start.column);
                            return;
                        }
                        var str = this.session.getFoldStringAt(row, column, -1);
                        if (str == null) {
                            str = this.doc.getLine(row).substring(0, column);
                        }
                        var leftOfCursor = lang.stringReverse(str);
                        this.session.nonTokenRe.lastIndex = 0;
                        this.session.tokenRe.lastIndex = 0;
                        // skip whitespace
                        if (this.session.nonTokenRe.exec(leftOfCursor)) {
                            column -= this.session.nonTokenRe.lastIndex;
                            leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
                            this.session.nonTokenRe.lastIndex = 0;
                        }
                        // if at begin of the line proceed in line above
                        if (column <= 0) {
                            this.moveCursorTo(row, 0);
                            this.moveCursorLeft();
                            if (row > 0) this.moveCursorWordLeft();
                            return;
                        }
                        // move to the begin of the word
                        if (this.session.tokenRe.exec(leftOfCursor)) {
                            column -= this.session.tokenRe.lastIndex;
                            this.session.tokenRe.lastIndex = 0;
                        }
                        this.moveCursorTo(row, column);
                    };
                    this.$shortWordEndIndex = function(rightOfCursor) {
                        var index = 0, ch;
                        var whitespaceRe = /\s/;
                        var tokenRe = this.session.tokenRe;
                        tokenRe.lastIndex = 0;
                        if (this.session.tokenRe.exec(rightOfCursor)) {
                            index = this.session.tokenRe.lastIndex;
                        } else {
                            while((ch = rightOfCursor[index]) && whitespaceRe.test(ch))index++;
                            if (index < 1) {
                                tokenRe.lastIndex = 0;
                                while((ch = rightOfCursor[index]) && !tokenRe.test(ch)){
                                    tokenRe.lastIndex = 0;
                                    index++;
                                    if (whitespaceRe.test(ch)) {
                                        if (index > 2) {
                                            index--;
                                            break;
                                        } else {
                                            while((ch = rightOfCursor[index]) && whitespaceRe.test(ch))index++;
                                            if (index > 2) break;
                                        }
                                    }
                                }
                            }
                        }
                        tokenRe.lastIndex = 0;
                        return index;
                    };
                    this.moveCursorShortWordRight = function() {
                        var row = this.lead.row;
                        var column = this.lead.column;
                        var line = this.doc.getLine(row);
                        var rightOfCursor = line.substring(column);
                        var fold = this.session.getFoldAt(row, column, 1);
                        if (fold) return this.moveCursorTo(fold.end.row, fold.end.column);
                        if (column == line.length) {
                            var l = this.doc.getLength();
                            do {
                                row++;
                                rightOfCursor = this.doc.getLine(row);
                            }while (row < l && /^\s*$/.test(rightOfCursor));
                            if (!/^\s+/.test(rightOfCursor)) rightOfCursor = "";
                            column = 0;
                        }
                        var index = this.$shortWordEndIndex(rightOfCursor);
                        this.moveCursorTo(row, column + index);
                    };
                    this.moveCursorShortWordLeft = function() {
                        var row = this.lead.row;
                        var column = this.lead.column;
                        var fold;
                        if (fold = this.session.getFoldAt(row, column, -1)) return this.moveCursorTo(fold.start.row, fold.start.column);
                        var line = this.session.getLine(row).substring(0, column);
                        if (column === 0) {
                            do {
                                row--;
                                line = this.doc.getLine(row);
                            }while (row > 0 && /^\s*$/.test(line));
                            column = line.length;
                            if (!/\s+$/.test(line)) line = "";
                        }
                        var leftOfCursor = lang.stringReverse(line);
                        var index = this.$shortWordEndIndex(leftOfCursor);
                        return this.moveCursorTo(row, column - index);
                    };
                    this.moveCursorWordRight = function() {
                        if (this.session.$selectLongWords) this.moveCursorLongWordRight();
                        else this.moveCursorShortWordRight();
                    };
                    this.moveCursorWordLeft = function() {
                        if (this.session.$selectLongWords) this.moveCursorLongWordLeft();
                        else this.moveCursorShortWordLeft();
                    };
                    /**
     * Moves the cursor to position indicated by the parameters. Negative numbers move the cursor backwards in the document.
     * @param {Number} rows The number of rows to move by
     * @param {Number} chars The number of characters to move by
     *
     * @related EditSession.documentToScreenPosition
     **/ this.moveCursorBy = function(rows, chars) {
                        var screenPos = this.session.documentToScreenPosition(this.lead.row, this.lead.column);
                        var offsetX;
                        if (chars === 0) {
                            if (rows !== 0) {
                                if (this.session.$bidiHandler.isBidiRow(screenPos.row, this.lead.row)) {
                                    offsetX = this.session.$bidiHandler.getPosLeft(screenPos.column);
                                    screenPos.column = Math.round(offsetX / this.session.$bidiHandler.charWidths[0]);
                                } else {
                                    offsetX = screenPos.column * this.session.$bidiHandler.charWidths[0];
                                }
                            }
                            if (this.$desiredColumn) screenPos.column = this.$desiredColumn;
                            else this.$desiredColumn = screenPos.column;
                        }
                        if (rows != 0 && this.session.lineWidgets && this.session.lineWidgets[this.lead.row]) {
                            var widget = this.session.lineWidgets[this.lead.row];
                            if (rows < 0) rows -= widget.rowsAbove || 0;
                            else if (rows > 0) rows += widget.rowCount - (widget.rowsAbove || 0);
                        }
                        var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column, offsetX);
                        if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {}
                        // move the cursor and update the desired column
                        this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
                    };
                    /**
     * Moves the selection to the position indicated by its `row` and `column`.
     * @param {Object} position The position to move to
     **/ this.moveCursorToPosition = function(position) {
                        this.moveCursorTo(position.row, position.column);
                    };
                    /**
     * Moves the cursor to the row and column provided. [If `preventUpdateDesiredColumn` is `true`, then the cursor stays in the same column position as its original point.]{: #preventUpdateBoolDesc}
     * @param {Number} row The row to move to
     * @param {Number} column The column to move to
     * @param {Boolean} keepDesiredColumn [If `true`, the cursor move does not respect the previous column]{: #preventUpdateBool}
     *
     **/ this.moveCursorTo = function(row, column, keepDesiredColumn) {
                        // Ensure the row/column is not inside of a fold.
                        var fold = this.session.getFoldAt(row, column, 1);
                        if (fold) {
                            row = fold.start.row;
                            column = fold.start.column;
                        }
                        this.$keepDesiredColumnOnChange = true;
                        var line = this.session.getLine(row);
                        // do not allow putting cursor in the middle of surrogate pairs
                        if (/[\uDC00-\uDFFF]/.test(line.charAt(column)) && line.charAt(column - 1)) {
                            if (this.lead.row == row && this.lead.column == column + 1) column = column - 1;
                            else column = column + 1;
                        }
                        this.lead.setPosition(row, column);
                        this.$keepDesiredColumnOnChange = false;
                        if (!keepDesiredColumn) this.$desiredColumn = null;
                    };
                    /**
     * Moves the cursor to the screen position indicated by row and column. {:preventUpdateBoolDesc}
     * @param {Number} row The row to move to
     * @param {Number} column The column to move to
     * @param {Boolean} keepDesiredColumn {:preventUpdateBool}
     *
     **/ this.moveCursorToScreen = function(row, column, keepDesiredColumn) {
                        var pos = this.session.screenToDocumentPosition(row, column);
                        this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
                    };
                    // remove listeners from document
                    this.detach = function() {
                        this.lead.detach();
                        this.anchor.detach();
                    };
                    this.fromOrientedRange = function(range) {
                        this.setSelectionRange(range, range.cursor == range.start);
                        this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
                    };
                    this.toOrientedRange = function(range) {
                        var r = this.getRange();
                        if (range) {
                            range.start.column = r.start.column;
                            range.start.row = r.start.row;
                            range.end.column = r.end.column;
                            range.end.row = r.end.row;
                        } else {
                            range = r;
                        }
                        range.cursor = this.isBackwards() ? range.start : range.end;
                        range.desiredColumn = this.$desiredColumn;
                        return range;
                    };
                    /**
     * Saves the current cursor position and calls `func` that can change the cursor
     * postion. The result is the range of the starting and eventual cursor position.
     * Will reset the cursor position.
     * @param {Function} The callback that should change the cursor position
     * @returns {Range}
     *
     **/ this.getRangeOfMovements = function(func) {
                        var start = this.getCursor();
                        try {
                            func(this);
                            var end = this.getCursor();
                            return Range.fromPoints(start, end);
                        } catch (e) {
                            return Range.fromPoints(start, start);
                        } finally{
                            this.moveCursorToPosition(start);
                        }
                    };
                    this.toJSON = function() {
                        if (this.rangeCount) {
                            var data = this.ranges.map(function(r) {
                                var r1 = r.clone();
                                r1.isBackwards = r.cursor == r.start;
                                return r1;
                            });
                        } else {
                            var data = this.getRange();
                            data.isBackwards = this.isBackwards();
                        }
                        return data;
                    };
                    this.fromJSON = function(data) {
                        if (data.start == undefined) {
                            if (this.rangeList && data.length > 1) {
                                this.toSingleRange(data[0]);
                                for(var i = data.length; i--;){
                                    var r = Range.fromPoints(data[i].start, data[i].end);
                                    if (data[i].isBackwards) r.cursor = r.start;
                                    this.addRange(r, true);
                                }
                                return;
                            } else {
                                data = data[0];
                            }
                        }
                        if (this.rangeList) this.toSingleRange(data);
                        this.setSelectionRange(data, data.isBackwards);
                    };
                    this.isEqual = function(data) {
                        if ((data.length || this.rangeCount) && data.length != this.rangeCount) return false;
                        if (!data.length || !this.ranges) return this.getRange().isEqual(data);
                        for(var i = this.ranges.length; i--;){
                            if (!this.ranges[i].isEqual(data[i])) return false;
                        }
                        return true;
                    };
                }).call(Selection.prototype);
                exports1.Y = Selection;
            /***/ },
            /***/ 7804: /***/ function(module1) {
                module1.exports = '.ace-tm .ace_gutter {\n  background: #f0f0f0;\n  color: #333;\n}\n\n.ace-tm .ace_print-margin {\n  width: 1px;\n  background: #e8e8e8;\n}\n\n.ace-tm .ace_fold {\n    background-color: #6B72E6;\n}\n\n.ace-tm {\n  background-color: #FFFFFF;\n  color: black;\n}\n\n.ace-tm .ace_cursor {\n  color: black;\n}\n        \n.ace-tm .ace_invisible {\n  color: rgb(191, 191, 191);\n}\n\n.ace-tm .ace_storage,\n.ace-tm .ace_keyword {\n  color: blue;\n}\n\n.ace-tm .ace_constant {\n  color: rgb(197, 6, 11);\n}\n\n.ace-tm .ace_constant.ace_buildin {\n  color: rgb(88, 72, 246);\n}\n\n.ace-tm .ace_constant.ace_language {\n  color: rgb(88, 92, 246);\n}\n\n.ace-tm .ace_constant.ace_library {\n  color: rgb(6, 150, 14);\n}\n\n.ace-tm .ace_invalid {\n  background-color: rgba(255, 0, 0, 0.1);\n  color: red;\n}\n\n.ace-tm .ace_support.ace_function {\n  color: rgb(60, 76, 114);\n}\n\n.ace-tm .ace_support.ace_constant {\n  color: rgb(6, 150, 14);\n}\n\n.ace-tm .ace_support.ace_type,\n.ace-tm .ace_support.ace_class {\n  color: rgb(109, 121, 222);\n}\n\n.ace-tm .ace_keyword.ace_operator {\n  color: rgb(104, 118, 135);\n}\n\n.ace-tm .ace_string {\n  color: rgb(3, 106, 7);\n}\n\n.ace-tm .ace_comment {\n  color: rgb(76, 136, 107);\n}\n\n.ace-tm .ace_comment.ace_doc {\n  color: rgb(0, 102, 255);\n}\n\n.ace-tm .ace_comment.ace_doc.ace_tag {\n  color: rgb(128, 159, 191);\n}\n\n.ace-tm .ace_constant.ace_numeric {\n  color: rgb(0, 0, 205);\n}\n\n.ace-tm .ace_variable {\n  color: rgb(49, 132, 149);\n}\n\n.ace-tm .ace_xml-pe {\n  color: rgb(104, 104, 91);\n}\n\n.ace-tm .ace_entity.ace_name.ace_function {\n  color: #0000A2;\n}\n\n\n.ace-tm .ace_heading {\n  color: rgb(12, 7, 255);\n}\n\n.ace-tm .ace_list {\n  color:rgb(185, 6, 144);\n}\n\n.ace-tm .ace_meta.ace_tag {\n  color:rgb(0, 22, 142);\n}\n\n.ace-tm .ace_string.ace_regex {\n  color: rgb(255, 0, 0)\n}\n\n.ace-tm .ace_marker-layer .ace_selection {\n  background: rgb(181, 213, 255);\n}\n.ace-tm.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px white;\n}\n.ace-tm .ace_marker-layer .ace_step {\n  background: rgb(252, 255, 0);\n}\n\n.ace-tm .ace_marker-layer .ace_stack {\n  background: rgb(164, 229, 101);\n}\n\n.ace-tm .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgb(192, 192, 192);\n}\n\n.ace-tm .ace_marker-layer .ace_active-line {\n  background: rgba(0, 0, 0, 0.07);\n}\n\n.ace-tm .ace_gutter-active-line {\n    background-color : #dcdcdc;\n}\n\n.ace-tm .ace_marker-layer .ace_selected-word {\n  background: rgb(250, 250, 255);\n  border: 1px solid rgb(200, 200, 250);\n}\n\n.ace-tm .ace_indent-guide {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;\n}\n\n.ace-tm .ace_indent-guide-active {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;\n}\n';
            /***/ },
            /***/ 9609: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1188069__) {
                "use strict";
                exports1.isDark = false;
                exports1.cssClass = "ace-tm";
                exports1.cssText = __nested_webpack_require_1188069__(7804);
                exports1.$id = "ace/theme/textmate";
                var dom = __nested_webpack_require_1188069__(5336);
                dom.importCssString(exports1.cssText, exports1.cssClass, false);
            /***/ },
            /***/ 7726: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1188553__) {
                "use strict";
                var Range = __nested_webpack_require_1188553__(3069)/* .Range */ .e;
                /**
 * This class provides an essay way to treat the document as a stream of tokens, and provides methods to iterate over these tokens.
 **/ var TokenIterator = /*#__PURE__*/ function() {
                    function TokenIterator(session, initialRow, initialColumn) {
                        _class_call_check(this, TokenIterator);
                        this.$session = session;
                        this.$row = initialRow;
                        this.$rowTokens = session.getTokens(initialRow);
                        var token = session.getTokenAt(initialRow, initialColumn);
                        this.$tokenIndex = token ? token.index : -1;
                    }
                    _create_class(TokenIterator, [
                        {
                            /**
     * Moves iterator position to the start of previous token.
     * @returns {Token|null}
     **/ key: "stepBackward",
                            value: function stepBackward() {
                                this.$tokenIndex -= 1;
                                while(this.$tokenIndex < 0){
                                    this.$row -= 1;
                                    if (this.$row < 0) {
                                        this.$row = 0;
                                        return null;
                                    }
                                    this.$rowTokens = this.$session.getTokens(this.$row);
                                    this.$tokenIndex = this.$rowTokens.length - 1;
                                }
                                return this.$rowTokens[this.$tokenIndex];
                            }
                        },
                        {
                            /**
     * Moves iterator position to the start of next token.
     * @returns {Token|null}
     **/ key: "stepForward",
                            value: function stepForward() {
                                this.$tokenIndex += 1;
                                var rowCount;
                                while(this.$tokenIndex >= this.$rowTokens.length){
                                    this.$row += 1;
                                    if (!rowCount) rowCount = this.$session.getLength();
                                    if (this.$row >= rowCount) {
                                        this.$row = rowCount - 1;
                                        return null;
                                    }
                                    this.$rowTokens = this.$session.getTokens(this.$row);
                                    this.$tokenIndex = 0;
                                }
                                return this.$rowTokens[this.$tokenIndex];
                            }
                        },
                        {
                            /**
     * 
     * Returns current token.
     * @returns {Token}
     **/ key: "getCurrentToken",
                            value: function getCurrentToken() {
                                return this.$rowTokens[this.$tokenIndex];
                            }
                        },
                        {
                            /**
     * 
     * Returns the current row.
     * @returns {Number}
     **/ key: "getCurrentTokenRow",
                            value: function getCurrentTokenRow() {
                                return this.$row;
                            }
                        },
                        {
                            /**
     * 
     * Returns the current column.
     * @returns {Number}
     **/ key: "getCurrentTokenColumn",
                            value: function getCurrentTokenColumn() {
                                var rowTokens = this.$rowTokens;
                                var tokenIndex = this.$tokenIndex;
                                // If a column was cached by EditSession.getTokenAt, then use it
                                var column = rowTokens[tokenIndex].start;
                                if (column !== undefined) return column;
                                column = 0;
                                while(tokenIndex > 0){
                                    tokenIndex -= 1;
                                    column += rowTokens[tokenIndex].value.length;
                                }
                                return column;
                            }
                        },
                        {
                            /**
     * Return the current token position.
     * @returns {Position}
     */ key: "getCurrentTokenPosition",
                            value: function getCurrentTokenPosition() {
                                return {
                                    row: this.$row,
                                    column: this.getCurrentTokenColumn()
                                };
                            }
                        },
                        {
                            /**
     * Return the current token range.
     * @returns {Range}
     */ key: "getCurrentTokenRange",
                            value: function getCurrentTokenRange() {
                                var token = this.$rowTokens[this.$tokenIndex];
                                var column = this.getCurrentTokenColumn();
                                return new Range(this.$row, column, this.$row, column + token.value.length);
                            }
                        }
                    ]);
                    return TokenIterator;
                }();
                exports1.N = TokenIterator;
            /***/ },
            /***/ 9754: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1194398__) {
                "use strict";
                var config = __nested_webpack_require_1194398__(3294);
                // tokenizing lines longer than this makes editor very slow
                var MAX_TOKEN_COUNT = 2000;
                /**
 * This class takes a set of highlighting rules, and creates a tokenizer out of them. For more information, see [the wiki on extending highlighters](https://github.com/ajaxorg/ace/wiki/Creating-or-Extending-an-Edit-Mode#wiki-extendingTheHighlighter).
 **/ var Tokenizer = /*#__PURE__*/ function() {
                    function Tokenizer(rules) {
                        _class_call_check(this, Tokenizer);
                        this.states = rules;
                        this.regExps = {};
                        this.matchMappings = {};
                        for(var key in this.states){
                            var state = this.states[key];
                            var ruleRegExps = [];
                            var matchTotal = 0;
                            var mapping = this.matchMappings[key] = {
                                defaultToken: "text"
                            };
                            var flag = "g";
                            var splitterRurles = [];
                            for(var i = 0; i < state.length; i++){
                                var rule = state[i];
                                if (rule.defaultToken) mapping.defaultToken = rule.defaultToken;
                                if (rule.caseInsensitive && flag.indexOf("i") === -1) flag += "i";
                                if (rule.unicode && flag.indexOf("u") === -1) flag += "u";
                                if (rule.regex == null) continue;
                                if (_instanceof(rule.regex, RegExp)) rule.regex = rule.regex.toString().slice(1, -1);
                                // Count number of matching groups. 2 extra groups from the full match
                                // And the catch-all on the end (used to force a match);
                                var adjustedregex = rule.regex;
                                var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
                                if (Array.isArray(rule.token)) {
                                    if (rule.token.length == 1 || matchcount == 1) {
                                        rule.token = rule.token[0];
                                    } else if (matchcount - 1 != rule.token.length) {
                                        this.reportError("number of classes and regexp groups doesn't match", {
                                            rule: rule,
                                            groupCount: matchcount - 1
                                        });
                                        rule.token = rule.token[0];
                                    } else {
                                        rule.tokenArray = rule.token;
                                        rule.token = null;
                                        rule.onMatch = this.$arrayTokens;
                                    }
                                } else if (typeof rule.token == "function" && !rule.onMatch) {
                                    if (matchcount > 1) rule.onMatch = this.$applyToken;
                                    else rule.onMatch = rule.token;
                                }
                                if (matchcount > 1) {
                                    if (/\\\d/.test(rule.regex)) {
                                        // Replace any backreferences and offset appropriately.
                                        adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function(match, digit) {
                                            return "\\" + (parseInt(digit, 10) + matchTotal + 1);
                                        });
                                    } else {
                                        matchcount = 1;
                                        adjustedregex = this.removeCapturingGroups(rule.regex);
                                    }
                                    if (!rule.splitRegex && typeof rule.token != "string") splitterRurles.push(rule); // flag will be known only at the very end
                                }
                                mapping[matchTotal] = i;
                                matchTotal += matchcount;
                                ruleRegExps.push(adjustedregex);
                                // makes property access faster
                                if (!rule.onMatch) rule.onMatch = null;
                            }
                            if (!ruleRegExps.length) {
                                mapping[0] = 0;
                                ruleRegExps.push("$");
                            }
                            splitterRurles.forEach(function(rule) {
                                rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);
                            }, this);
                            this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
                        }
                    }
                    _create_class(Tokenizer, [
                        {
                            key: "$setMaxTokenCount",
                            value: function $setMaxTokenCount(m) {
                                MAX_TOKEN_COUNT = m | 0;
                            }
                        },
                        {
                            key: "$applyToken",
                            value: function $applyToken(str) {
                                var values = this.splitRegex.exec(str).slice(1);
                                var types = this.token.apply(this, values);
                                // required for compatibility with old modes
                                if (typeof types === "string") return [
                                    {
                                        type: types,
                                        value: str
                                    }
                                ];
                                var tokens = [];
                                for(var i = 0, l = types.length; i < l; i++){
                                    if (values[i]) tokens[tokens.length] = {
                                        type: types[i],
                                        value: values[i]
                                    };
                                }
                                return tokens;
                            }
                        },
                        {
                            key: "$arrayTokens",
                            value: function $arrayTokens(str) {
                                if (!str) return [];
                                var values = this.splitRegex.exec(str);
                                if (!values) return "text";
                                var tokens = [];
                                var types = this.tokenArray;
                                for(var i = 0, l = types.length; i < l; i++){
                                    if (values[i + 1]) tokens[tokens.length] = {
                                        type: types[i],
                                        value: values[i + 1]
                                    };
                                }
                                return tokens;
                            }
                        },
                        {
                            key: "removeCapturingGroups",
                            value: function removeCapturingGroups(src) {
                                var r = src.replace(/\\.|\[(?:\\.|[^\\\]])*|\(\?[:=!<]|(\()/g, function(x, y) {
                                    return y ? "(?:" : x;
                                });
                                return r;
                            }
                        },
                        {
                            key: "createSplitterRegexp",
                            value: function createSplitterRegexp(src, flag) {
                                if (src.indexOf("(?=") != -1) {
                                    var stack = 0;
                                    var inChClass = false;
                                    var lastCapture = {};
                                    src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(m, esc, parenOpen, parenClose, square, index) {
                                        if (inChClass) {
                                            inChClass = square != "]";
                                        } else if (square) {
                                            inChClass = true;
                                        } else if (parenClose) {
                                            if (stack == lastCapture.stack) {
                                                lastCapture.end = index + 1;
                                                lastCapture.stack = -1;
                                            }
                                            stack--;
                                        } else if (parenOpen) {
                                            stack++;
                                            if (parenOpen.length != 1) {
                                                lastCapture.stack = stack;
                                                lastCapture.start = index;
                                            }
                                        }
                                        return m;
                                    });
                                    if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end))) src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
                                }
                                // this is needed for regexps that can match in multiple ways
                                if (src.charAt(0) != "^") src = "^" + src;
                                if (src.charAt(src.length - 1) != "$") src += "$";
                                return new RegExp(src, (flag || "").replace("g", ""));
                            }
                        },
                        {
                            /**
     * Returns an object containing two properties: `tokens`, which contains all the tokens; and `state`, the current state.
     * @returns {Object}
     **/ key: "getLineTokens",
                            value: function getLineTokens(line, startState) {
                                if (startState && typeof startState != "string") {
                                    var stack = startState.slice(0);
                                    startState = stack[0];
                                    if (startState === "#tmp") {
                                        stack.shift();
                                        startState = stack.shift();
                                    }
                                } else var stack = [];
                                var currentState = startState || "start";
                                var state = this.states[currentState];
                                if (!state) {
                                    currentState = "start";
                                    state = this.states[currentState];
                                }
                                var mapping = this.matchMappings[currentState];
                                var re = this.regExps[currentState];
                                re.lastIndex = 0;
                                var match, tokens = [];
                                var lastIndex = 0;
                                var matchAttempts = 0;
                                var token = {
                                    type: null,
                                    value: ""
                                };
                                while(match = re.exec(line)){
                                    var type = mapping.defaultToken;
                                    var rule = null;
                                    var value = match[0];
                                    var index = re.lastIndex;
                                    if (index - value.length > lastIndex) {
                                        var skipped = line.substring(lastIndex, index - value.length);
                                        if (token.type == type) {
                                            token.value += skipped;
                                        } else {
                                            if (token.type) tokens.push(token);
                                            token = {
                                                type: type,
                                                value: skipped
                                            };
                                        }
                                    }
                                    for(var i = 0; i < match.length - 2; i++){
                                        if (match[i + 1] === undefined) continue;
                                        rule = state[mapping[i]];
                                        if (rule.onMatch) type = rule.onMatch(value, currentState, stack, line);
                                        else type = rule.token;
                                        if (rule.next) {
                                            if (typeof rule.next == "string") {
                                                currentState = rule.next;
                                            } else {
                                                currentState = rule.next(currentState, stack);
                                            }
                                            state = this.states[currentState];
                                            if (!state) {
                                                this.reportError("state doesn't exist", currentState);
                                                currentState = "start";
                                                state = this.states[currentState];
                                            }
                                            mapping = this.matchMappings[currentState];
                                            lastIndex = index;
                                            re = this.regExps[currentState];
                                            re.lastIndex = index;
                                        }
                                        if (rule.consumeLineEnd) lastIndex = index;
                                        break;
                                    }
                                    if (value) {
                                        if (typeof type === "string") {
                                            if ((!rule || rule.merge !== false) && token.type === type) {
                                                token.value += value;
                                            } else {
                                                if (token.type) tokens.push(token);
                                                token = {
                                                    type: type,
                                                    value: value
                                                };
                                            }
                                        } else if (type) {
                                            if (token.type) tokens.push(token);
                                            token = {
                                                type: null,
                                                value: ""
                                            };
                                            for(var i = 0; i < type.length; i++)tokens.push(type[i]);
                                        }
                                    }
                                    if (lastIndex == line.length) break;
                                    lastIndex = index;
                                    if (matchAttempts++ > MAX_TOKEN_COUNT) {
                                        if (matchAttempts > 2 * line.length) {
                                            this.reportError("infinite loop with in ace tokenizer", {
                                                startState: startState,
                                                line: line
                                            });
                                        }
                                        // chrome doens't show contents of text nodes with very long text
                                        while(lastIndex < line.length){
                                            if (token.type) tokens.push(token);
                                            token = {
                                                value: line.substring(lastIndex, lastIndex += 500),
                                                type: "overflow"
                                            };
                                        }
                                        currentState = "start";
                                        stack = [];
                                        break;
                                    }
                                }
                                if (token.type) tokens.push(token);
                                if (stack.length > 1) {
                                    if (stack[0] !== currentState) stack.unshift("#tmp", currentState);
                                }
                                return {
                                    tokens: tokens,
                                    state: stack.length ? stack : currentState
                                };
                            }
                        }
                    ]);
                    return Tokenizer;
                }();
                Tokenizer.prototype.reportError = config.reportError;
                exports1.d = Tokenizer;
            /***/ },
            /***/ 1692: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1212741__) {
                "use strict";
                var dom = __nested_webpack_require_1212741__(5336);
                var CLASSNAME = "ace_tooltip";
                var Tooltip = /*#__PURE__*/ function() {
                    function Tooltip(parentNode) {
                        _class_call_check(this, Tooltip);
                        this.isOpen = false;
                        this.$element = null;
                        this.$parentNode = parentNode;
                    }
                    _create_class(Tooltip, [
                        {
                            key: "$init",
                            value: function $init() {
                                this.$element = dom.createElement("div");
                                this.$element.className = CLASSNAME;
                                this.$element.style.display = "none";
                                this.$parentNode.appendChild(this.$element);
                                return this.$element;
                            }
                        },
                        {
                            /**
     * @returns {Element}
     **/ key: "getElement",
                            value: function getElement() {
                                return this.$element || this.$init();
                            }
                        },
                        {
                            /**
     * @param {String} text
     **/ key: "setText",
                            value: function setText(text) {
                                this.getElement().textContent = text;
                            }
                        },
                        {
                            /**
     * @param {String} html
     **/ key: "setHtml",
                            value: function setHtml(html) {
                                this.getElement().innerHTML = html;
                            }
                        },
                        {
                            /**
     * @param {Number} x
     * @param {Number} y
     **/ key: "setPosition",
                            value: function setPosition(x, y) {
                                this.getElement().style.left = x + "px";
                                this.getElement().style.top = y + "px";
                            }
                        },
                        {
                            /**
     * @param {String} className
     **/ key: "setClassName",
                            value: function setClassName(className) {
                                dom.addCssClass(this.getElement(), className);
                            }
                        },
                        {
                            /**
     * @param {String} text
     * @param {Number} x
     * @param {Number} y
     **/ key: "show",
                            value: function show(text, x, y) {
                                if (text != null) this.setText(text);
                                if (x != null && y != null) this.setPosition(x, y);
                                if (!this.isOpen) {
                                    this.getElement().style.display = "block";
                                    this.isOpen = true;
                                }
                            }
                        },
                        {
                            key: "hide",
                            value: function hide() {
                                if (this.isOpen) {
                                    this.getElement().style.display = "none";
                                    this.getElement().className = CLASSNAME;
                                    this.isOpen = false;
                                }
                            }
                        },
                        {
                            /**
     * @returns {Number}
     **/ key: "getHeight",
                            value: function getHeight() {
                                return this.getElement().offsetHeight;
                            }
                        },
                        {
                            /**
     * @returns {Number}
     **/ key: "getWidth",
                            value: function getWidth() {
                                return this.getElement().offsetWidth;
                            }
                        },
                        {
                            key: "destroy",
                            value: function destroy() {
                                this.isOpen = false;
                                if (this.$element && this.$element.parentNode) {
                                    this.$element.parentNode.removeChild(this.$element);
                                }
                            }
                        }
                    ]);
                    return Tooltip;
                }();
                exports1.u = Tooltip;
            /***/ },
            /***/ 1966: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1217787__) {
                "use strict";
                var rearrangeUndoStack = function rearrangeUndoStack(stack, pos) {
                    for(var i = pos; i--;){
                        var deltaSet = stack[i];
                        if (deltaSet && !deltaSet[0].ignore) {
                            while(i < pos - 1){
                                var swapped = swapGroups(stack[i], stack[i + 1]);
                                stack[i] = swapped[0];
                                stack[i + 1] = swapped[1];
                                i++;
                            }
                            return true;
                        }
                    }
                };
                var $updateMarkers = function $updateMarkers(delta) {
                    var isInsert = delta.action == "insert";
                    var start = delta.start;
                    var end = delta.end;
                    var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);
                    var colShift = (end.column - start.column) * (isInsert ? 1 : -1);
                    if (isInsert) end = start;
                    for(var i in this.marks){
                        var point = this.marks[i];
                        var cmp = comparePoints(point, start);
                        if (cmp < 0) {
                            continue; // delta starts after the range
                        }
                        if (cmp === 0) {
                            if (isInsert) {
                                if (point.bias == 1) {
                                    cmp = 1;
                                } else {
                                    point.bias == -1;
                                    continue;
                                }
                            }
                        }
                        var cmp2 = isInsert ? cmp : comparePoints(point, end);
                        if (cmp2 > 0) {
                            point.row += rowShift;
                            point.column += point.row == end.row ? colShift : 0;
                            continue;
                        }
                        if (!isInsert && cmp2 <= 0) {
                            point.row = start.row;
                            point.column = start.column;
                            if (cmp2 === 0) point.bias = 1;
                        }
                    }
                };
                var clonePos = function clonePos(pos) {
                    return {
                        row: pos.row,
                        column: pos.column
                    };
                };
                var cloneDelta = function cloneDelta(d) {
                    return {
                        start: clonePos(d.start),
                        end: clonePos(d.end),
                        action: d.action,
                        lines: d.lines.slice()
                    };
                };
                var stringifyRange = function stringifyRange(r) {
                    return r.start.row + ":" + r.start.column + "=>" + r.end.row + ":" + r.end.column;
                };
                var swap = /*
 * i i  d1  d2
 *      |/  |/  d2.s >= d1.e shift(d2, d1, -1)
 *              d2.s <= d1.s shift(d1, d2, +1)
 *       d1.s < d2.s < d1.e // can split
 * 
 * i r  d1  d2
 *      |/  |\  d2.s >= d1.e shift(d2, d1, -1)
 *              d2.e <= d1.s shift(d1, d2, -1)
 *       else // can't swap
 * 
 * r i  d1  d2
 *      |\  |/  d2.s >= d1.s shift(d2, d1, +1)
 *              d2.s <= d1.s shift(d1, d2, +1)
 *       // no else
 * 
 * r r  d1  d2
 *      |\  |\  d2.s >= d1.s shift(d2, d1, +1)
 *              d2.e <= d1.s shift(d1, d2, -1)
 *       d2.s < d1.s < d2.e // can split
 */ function swap(d1, d2) {
                    var i1 = d1.action == "insert";
                    var i2 = d2.action == "insert";
                    if (i1 && i2) {
                        if (cmp(d2.start, d1.end) >= 0) {
                            shift(d2, d1, -1);
                        } else if (cmp(d2.start, d1.start) <= 0) {
                            shift(d1, d2, +1);
                        } else {
                            return null;
                        }
                    } else if (i1 && !i2) {
                        if (cmp(d2.start, d1.end) >= 0) {
                            shift(d2, d1, -1);
                        } else if (cmp(d2.end, d1.start) <= 0) {
                            shift(d1, d2, -1);
                        } else {
                            return null;
                        }
                    } else if (!i1 && i2) {
                        if (cmp(d2.start, d1.start) >= 0) {
                            shift(d2, d1, +1);
                        } else if (cmp(d2.start, d1.start) <= 0) {
                            shift(d1, d2, +1);
                        } else {
                            return null;
                        }
                    } else if (!i1 && !i2) {
                        if (cmp(d2.start, d1.start) >= 0) {
                            shift(d2, d1, +1);
                        } else if (cmp(d2.end, d1.start) <= 0) {
                            shift(d1, d2, -1);
                        } else {
                            return null;
                        }
                    }
                    return [
                        d2,
                        d1
                    ];
                };
                var swapGroups = function swapGroups(ds1, ds2) {
                    for(var i = ds1.length; i--;){
                        for(var j = 0; j < ds2.length; j++){
                            if (!swap(ds1[i], ds2[j])) {
                                // rollback, we have to undo ds2 first
                                while(i < ds1.length){
                                    while(j--){
                                        swap(ds2[j], ds1[i]);
                                    }
                                    j = ds2.length;
                                    i++;
                                }
                                return [
                                    ds1,
                                    ds2
                                ];
                            }
                        }
                    }
                    ds1.selectionBefore = ds2.selectionBefore = ds1.selectionAfter = ds2.selectionAfter = null;
                    return [
                        ds2,
                        ds1
                    ];
                };
                var xform = /*
      d2          xform(d1, c1) = [d2, c2]
    o<---o        xform(c1, d1) = [c2, d2]
 c2 |    | d1     
    o<---o
      c1
*/ function xform(d1, c1) {
                    var i1 = d1.action == "insert";
                    var i2 = c1.action == "insert";
                    if (i1 && i2) {
                        if (cmp(d1.start, c1.start) < 0) {
                            shift(c1, d1, 1);
                        } else {
                            shift(d1, c1, 1);
                        }
                    } else if (i1 && !i2) {
                        if (cmp(d1.start, c1.end) >= 0) {
                            shift(d1, c1, -1);
                        } else if (cmp(d1.start, c1.start) <= 0) {
                            shift(c1, d1, +1);
                        } else {
                            shift(d1, Range.fromPoints(c1.start, d1.start), -1);
                            shift(c1, d1, +1);
                        }
                    } else if (!i1 && i2) {
                        if (cmp(c1.start, d1.end) >= 0) {
                            shift(c1, d1, -1);
                        } else if (cmp(c1.start, d1.start) <= 0) {
                            shift(d1, c1, +1);
                        } else {
                            shift(c1, Range.fromPoints(d1.start, c1.start), -1);
                            shift(d1, c1, +1);
                        }
                    } else if (!i1 && !i2) {
                        if (cmp(c1.start, d1.end) >= 0) {
                            shift(c1, d1, -1);
                        } else if (cmp(c1.end, d1.start) <= 0) {
                            shift(d1, c1, -1);
                        } else {
                            var before, after;
                            if (cmp(d1.start, c1.start) < 0) {
                                before = d1;
                                d1 = splitDelta(d1, c1.start);
                            }
                            if (cmp(d1.end, c1.end) > 0) {
                                after = splitDelta(d1, c1.end);
                            }
                            shiftPos(c1.end, d1.start, d1.end, -1);
                            if (after && !before) {
                                d1.lines = after.lines;
                                d1.start = after.start;
                                d1.end = after.end;
                                after = d1;
                            }
                            return [
                                c1,
                                before,
                                after
                            ].filter(Boolean);
                        }
                    }
                    return [
                        c1,
                        d1
                    ];
                };
                var shift = function shift(d1, d2, dir) {
                    shiftPos(d1.start, d2.start, d2.end, dir);
                    shiftPos(d1.end, d2.start, d2.end, dir);
                };
                var shiftPos = function shiftPos(pos, start, end, dir) {
                    if (pos.row == (dir == 1 ? start : end).row) {
                        pos.column += dir * (end.column - start.column);
                    }
                    pos.row += dir * (end.row - start.row);
                };
                var splitDelta = function splitDelta(c, pos) {
                    var lines = c.lines;
                    var end = c.end;
                    c.end = clonePos(pos);
                    var rowsBefore = c.end.row - c.start.row;
                    var otherLines = lines.splice(rowsBefore, lines.length);
                    var col = rowsBefore ? pos.column : pos.column - c.start.column;
                    lines.push(otherLines[0].substring(0, col));
                    otherLines[0] = otherLines[0].substr(col);
                    var rest = {
                        start: clonePos(pos),
                        end: end,
                        lines: otherLines,
                        action: c.action
                    };
                    return rest;
                };
                var moveDeltasByOne = function moveDeltasByOne(redoStack, d) {
                    d = cloneDelta(d);
                    for(var j = redoStack.length; j--;){
                        var deltaSet = redoStack[j];
                        for(var i = 0; i < deltaSet.length; i++){
                            var x = deltaSet[i];
                            var xformed = xform(x, d);
                            d = xformed[0];
                            if (xformed.length != 2) {
                                if (xformed[2]) {
                                    deltaSet.splice(i + 1, 1, xformed[1], xformed[2]);
                                    i++;
                                } else if (!xformed[1]) {
                                    deltaSet.splice(i, 1);
                                    i--;
                                }
                            }
                        }
                        if (!deltaSet.length) {
                            redoStack.splice(j, 1);
                        }
                    }
                    return redoStack;
                };
                var rebaseRedoStack = function rebaseRedoStack(redoStack, deltaSets) {
                    for(var i = 0; i < deltaSets.length; i++){
                        var deltas = deltaSets[i];
                        for(var j = 0; j < deltas.length; j++){
                            moveDeltasByOne(redoStack, deltas[j]);
                        }
                    }
                };
                /**
 * This object maintains the undo stack for an [[EditSession `EditSession`]].
 **/ var UndoManager = /*#__PURE__*/ function() {
                    function UndoManager() {
                        _class_call_check(this, UndoManager);
                        this.$maxRev = 0;
                        this.$fromUndo = false;
                        this.$undoDepth = Infinity;
                        this.reset();
                    }
                    _create_class(UndoManager, [
                        {
                            key: "addSession",
                            value: function addSession(session) {
                                this.$session = session;
                            }
                        },
                        {
                            /**
     * Provides a means for implementing your own undo manager. `options` has one property, `args`, an [[Array `Array`]], with two elements:
     *
     * - `args[0]` is an array of deltas
     * - `args[1]` is the document to associate with
     *
     * @param {Object} options Contains additional properties
     *
     **/ key: "add",
                            value: function add(delta, allowMerge, session) {
                                if (this.$fromUndo) return;
                                if (delta == this.$lastDelta) return;
                                if (!this.$keepRedoStack) this.$redoStack.length = 0;
                                if (allowMerge === false || !this.lastDeltas) {
                                    this.lastDeltas = [];
                                    var undoStackLength = this.$undoStack.length;
                                    if (undoStackLength > this.$undoDepth - 1) {
                                        this.$undoStack.splice(0, undoStackLength - this.$undoDepth + 1);
                                    }
                                    this.$undoStack.push(this.lastDeltas);
                                    delta.id = this.$rev = ++this.$maxRev;
                                }
                                if (delta.action == "remove" || delta.action == "insert") this.$lastDelta = delta;
                                this.lastDeltas.push(delta);
                            }
                        },
                        {
                            key: "addSelection",
                            value: function addSelection(selection, rev) {
                                this.selections.push({
                                    value: selection,
                                    rev: rev || this.$rev
                                });
                            }
                        },
                        {
                            key: "startNewGroup",
                            value: function startNewGroup() {
                                this.lastDeltas = null;
                                return this.$rev;
                            }
                        },
                        {
                            key: "markIgnored",
                            value: function markIgnored(from, to) {
                                if (to == null) to = this.$rev + 1;
                                var stack = this.$undoStack;
                                for(var i = stack.length; i--;){
                                    var delta = stack[i][0];
                                    if (delta.id <= from) break;
                                    if (delta.id < to) delta.ignore = true;
                                }
                                this.lastDeltas = null;
                            }
                        },
                        {
                            key: "getSelection",
                            value: function getSelection(rev, after) {
                                var stack = this.selections;
                                for(var i = stack.length; i--;){
                                    var selection = stack[i];
                                    if (selection.rev < rev) {
                                        if (after) selection = stack[i + 1];
                                        return selection;
                                    }
                                }
                            }
                        },
                        {
                            key: "getRevision",
                            value: function getRevision() {
                                return this.$rev;
                            }
                        },
                        {
                            key: "getDeltas",
                            value: function getDeltas(from, to) {
                                if (to == null) to = this.$rev + 1;
                                var stack = this.$undoStack;
                                var end = null, start = 0;
                                for(var i = stack.length; i--;){
                                    var delta = stack[i][0];
                                    if (delta.id < to && !end) end = i + 1;
                                    if (delta.id <= from) {
                                        start = i + 1;
                                        break;
                                    }
                                }
                                return stack.slice(start, end);
                            }
                        },
                        {
                            key: "getChangedRanges",
                            value: function getChangedRanges(from, to) {
                                if (to == null) to = this.$rev + 1;
                            }
                        },
                        {
                            key: "getChangedLines",
                            value: function getChangedLines(from, to) {
                                if (to == null) to = this.$rev + 1;
                            }
                        },
                        {
                            /**
     * [Perform an undo operation on the document, reverting the last change.]{: #UndoManager.undo}
     * @param {EditSession} session
     * @param {Boolean} dontSelect {:dontSelect}
     *
     * @returns {Range} The range of the undo.
     **/ key: "undo",
                            value: function undo(session, dontSelect) {
                                this.lastDeltas = null;
                                var stack = this.$undoStack;
                                if (!rearrangeUndoStack(stack, stack.length)) return;
                                if (!session) session = this.$session;
                                if (this.$redoStackBaseRev !== this.$rev && this.$redoStack.length) this.$redoStack = [];
                                this.$fromUndo = true;
                                var deltaSet = stack.pop();
                                var undoSelectionRange = null;
                                if (deltaSet) {
                                    undoSelectionRange = session.undoChanges(deltaSet, dontSelect);
                                    this.$redoStack.push(deltaSet);
                                    this.$syncRev();
                                }
                                this.$fromUndo = false;
                                return undoSelectionRange;
                            }
                        },
                        {
                            /**
     * [Perform a redo operation on the document, reimplementing the last change.]{: #UndoManager.redo}
     * @param {Boolean} dontSelect {:dontSelect}
     *
     **/ key: "redo",
                            value: function redo(session, dontSelect) {
                                this.lastDeltas = null;
                                if (!session) session = this.$session;
                                this.$fromUndo = true;
                                if (this.$redoStackBaseRev != this.$rev) {
                                    var diff = this.getDeltas(this.$redoStackBaseRev, this.$rev + 1);
                                    rebaseRedoStack(this.$redoStack, diff);
                                    this.$redoStackBaseRev = this.$rev;
                                    this.$redoStack.forEach(function(x) {
                                        x[0].id = ++this.$maxRev;
                                    }, this);
                                }
                                var deltaSet = this.$redoStack.pop();
                                var redoSelectionRange = null;
                                if (deltaSet) {
                                    redoSelectionRange = session.redoChanges(deltaSet, dontSelect);
                                    this.$undoStack.push(deltaSet);
                                    this.$syncRev();
                                }
                                this.$fromUndo = false;
                                return redoSelectionRange;
                            }
                        },
                        {
                            key: "$syncRev",
                            value: function $syncRev() {
                                var stack = this.$undoStack;
                                var nextDelta = stack[stack.length - 1];
                                var id = nextDelta && nextDelta[0].id || 0;
                                this.$redoStackBaseRev = id;
                                this.$rev = id;
                            }
                        },
                        {
                            /**
     * Destroys the stack of undo and redo redo operations.
     **/ key: "reset",
                            value: function reset() {
                                this.lastDeltas = null;
                                this.$lastDelta = null;
                                this.$undoStack = [];
                                this.$redoStack = [];
                                this.$rev = 0;
                                this.mark = 0;
                                this.$redoStackBaseRev = this.$rev;
                                this.selections = [];
                            }
                        },
                        {
                            /**
     * Returns `true` if there are undo operations left to perform.
     * @returns {Boolean}
     **/ key: "canUndo",
                            value: function canUndo() {
                                return this.$undoStack.length > 0;
                            }
                        },
                        {
                            /**
     * Returns `true` if there are redo operations left to perform.
     * @returns {Boolean}
     **/ key: "canRedo",
                            value: function canRedo() {
                                return this.$redoStack.length > 0;
                            }
                        },
                        {
                            /**
     * Marks the current status clean
     **/ key: "bookmark",
                            value: function bookmark(rev) {
                                if (rev == undefined) rev = this.$rev;
                                this.mark = rev;
                            }
                        },
                        {
                            /**
     * Returns if the current status is clean
     * @returns {Boolean}
     **/ key: "isAtBookmark",
                            value: function isAtBookmark() {
                                return this.$rev === this.mark;
                            }
                        },
                        {
                            key: "toJSON",
                            value: function toJSON() {}
                        },
                        {
                            key: "fromJSON",
                            value: function fromJSON() {}
                        },
                        {
                            key: "$prettyPrint",
                            value: function $prettyPrint(delta) {
                                if (delta) return stringifyDelta(delta);
                                return stringifyDelta(this.$undoStack) + "\n---\n" + stringifyDelta(this.$redoStack);
                            }
                        }
                    ]);
                    return UndoManager;
                }();
                UndoManager.prototype.hasUndo = UndoManager.prototype.canUndo;
                UndoManager.prototype.hasRedo = UndoManager.prototype.canRedo;
                UndoManager.prototype.isClean = UndoManager.prototype.isAtBookmark;
                UndoManager.prototype.markClean = UndoManager.prototype.bookmark;
                var Range = __nested_webpack_require_1217787__(3069)/* .Range */ .e;
                var cmp = Range.comparePoints;
                var comparePoints = Range.comparePoints;
                function stringifyDelta(d) {
                    d = d || this;
                    if (Array.isArray(d)) {
                        return d.map(stringifyDelta).join("\n");
                    }
                    var type = "";
                    if (d.action) {
                        type = d.action == "insert" ? "+" : "-";
                        type += "[" + d.lines + "]";
                    } else if (d.value) {
                        if (Array.isArray(d.value)) {
                            type = d.value.map(stringifyRange).join("\n");
                        } else {
                            type = stringifyRange(d.value);
                        }
                    }
                    if (d.start) {
                        type += stringifyRange(d);
                    }
                    if (d.id || d.rev) {
                        type += "	(" + (d.id || d.rev) + ")";
                    }
                    return type;
                }
                exports1.H = UndoManager;
            /***/ },
            /***/ 7913: /***/ function(__unused_webpack_module, exports1) {
                "use strict";
                // generated by tool/unicode.js
                var wordChars = [
                    48,
                    9,
                    8,
                    25,
                    5,
                    0,
                    2,
                    25,
                    48,
                    0,
                    11,
                    0,
                    5,
                    0,
                    6,
                    22,
                    2,
                    30,
                    2,
                    457,
                    5,
                    11,
                    15,
                    4,
                    8,
                    0,
                    2,
                    0,
                    18,
                    116,
                    2,
                    1,
                    3,
                    3,
                    9,
                    0,
                    2,
                    2,
                    2,
                    0,
                    2,
                    19,
                    2,
                    82,
                    2,
                    138,
                    2,
                    4,
                    3,
                    155,
                    12,
                    37,
                    3,
                    0,
                    8,
                    38,
                    10,
                    44,
                    2,
                    0,
                    2,
                    1,
                    2,
                    1,
                    2,
                    0,
                    9,
                    26,
                    6,
                    2,
                    30,
                    10,
                    7,
                    61,
                    2,
                    9,
                    5,
                    101,
                    2,
                    7,
                    3,
                    9,
                    2,
                    18,
                    3,
                    0,
                    17,
                    58,
                    3,
                    100,
                    15,
                    53,
                    5,
                    0,
                    6,
                    45,
                    211,
                    57,
                    3,
                    18,
                    2,
                    5,
                    3,
                    11,
                    3,
                    9,
                    2,
                    1,
                    7,
                    6,
                    2,
                    2,
                    2,
                    7,
                    3,
                    1,
                    3,
                    21,
                    2,
                    6,
                    2,
                    0,
                    4,
                    3,
                    3,
                    8,
                    3,
                    1,
                    3,
                    3,
                    9,
                    0,
                    5,
                    1,
                    2,
                    4,
                    3,
                    11,
                    16,
                    2,
                    2,
                    5,
                    5,
                    1,
                    3,
                    21,
                    2,
                    6,
                    2,
                    1,
                    2,
                    1,
                    2,
                    1,
                    3,
                    0,
                    2,
                    4,
                    5,
                    1,
                    3,
                    2,
                    4,
                    0,
                    8,
                    3,
                    2,
                    0,
                    8,
                    15,
                    12,
                    2,
                    2,
                    8,
                    2,
                    2,
                    2,
                    21,
                    2,
                    6,
                    2,
                    1,
                    2,
                    4,
                    3,
                    9,
                    2,
                    2,
                    2,
                    2,
                    3,
                    0,
                    16,
                    3,
                    3,
                    9,
                    18,
                    2,
                    2,
                    7,
                    3,
                    1,
                    3,
                    21,
                    2,
                    6,
                    2,
                    1,
                    2,
                    4,
                    3,
                    8,
                    3,
                    1,
                    3,
                    2,
                    9,
                    1,
                    5,
                    1,
                    2,
                    4,
                    3,
                    9,
                    2,
                    0,
                    17,
                    1,
                    2,
                    5,
                    4,
                    2,
                    2,
                    3,
                    4,
                    1,
                    2,
                    0,
                    2,
                    1,
                    4,
                    1,
                    4,
                    2,
                    4,
                    11,
                    5,
                    4,
                    4,
                    2,
                    2,
                    3,
                    3,
                    0,
                    7,
                    0,
                    15,
                    9,
                    18,
                    2,
                    2,
                    7,
                    2,
                    2,
                    2,
                    22,
                    2,
                    9,
                    2,
                    4,
                    4,
                    7,
                    2,
                    2,
                    2,
                    3,
                    8,
                    1,
                    2,
                    1,
                    7,
                    3,
                    3,
                    9,
                    19,
                    1,
                    2,
                    7,
                    2,
                    2,
                    2,
                    22,
                    2,
                    9,
                    2,
                    4,
                    3,
                    8,
                    2,
                    2,
                    2,
                    3,
                    8,
                    1,
                    8,
                    0,
                    2,
                    3,
                    3,
                    9,
                    19,
                    1,
                    2,
                    7,
                    2,
                    2,
                    2,
                    22,
                    2,
                    15,
                    4,
                    7,
                    2,
                    2,
                    2,
                    3,
                    10,
                    0,
                    9,
                    3,
                    3,
                    9,
                    11,
                    5,
                    3,
                    1,
                    2,
                    17,
                    4,
                    23,
                    2,
                    8,
                    2,
                    0,
                    3,
                    6,
                    4,
                    0,
                    5,
                    5,
                    2,
                    0,
                    2,
                    7,
                    19,
                    1,
                    14,
                    57,
                    6,
                    14,
                    2,
                    9,
                    40,
                    1,
                    2,
                    0,
                    3,
                    1,
                    2,
                    0,
                    3,
                    0,
                    7,
                    3,
                    2,
                    6,
                    2,
                    2,
                    2,
                    0,
                    2,
                    0,
                    3,
                    1,
                    2,
                    12,
                    2,
                    2,
                    3,
                    4,
                    2,
                    0,
                    2,
                    5,
                    3,
                    9,
                    3,
                    1,
                    35,
                    0,
                    24,
                    1,
                    7,
                    9,
                    12,
                    0,
                    2,
                    0,
                    2,
                    0,
                    5,
                    9,
                    2,
                    35,
                    5,
                    19,
                    2,
                    5,
                    5,
                    7,
                    2,
                    35,
                    10,
                    0,
                    58,
                    73,
                    7,
                    77,
                    3,
                    37,
                    11,
                    42,
                    2,
                    0,
                    4,
                    328,
                    2,
                    3,
                    3,
                    6,
                    2,
                    0,
                    2,
                    3,
                    3,
                    40,
                    2,
                    3,
                    3,
                    32,
                    2,
                    3,
                    3,
                    6,
                    2,
                    0,
                    2,
                    3,
                    3,
                    14,
                    2,
                    56,
                    2,
                    3,
                    3,
                    66,
                    5,
                    0,
                    33,
                    15,
                    17,
                    84,
                    13,
                    619,
                    3,
                    16,
                    2,
                    25,
                    6,
                    74,
                    22,
                    12,
                    2,
                    6,
                    12,
                    20,
                    12,
                    19,
                    13,
                    12,
                    2,
                    2,
                    2,
                    1,
                    13,
                    51,
                    3,
                    29,
                    4,
                    0,
                    5,
                    1,
                    3,
                    9,
                    34,
                    2,
                    3,
                    9,
                    7,
                    87,
                    9,
                    42,
                    6,
                    69,
                    11,
                    28,
                    4,
                    11,
                    5,
                    11,
                    11,
                    39,
                    3,
                    4,
                    12,
                    43,
                    5,
                    25,
                    7,
                    10,
                    38,
                    27,
                    5,
                    62,
                    2,
                    28,
                    3,
                    10,
                    7,
                    9,
                    14,
                    0,
                    89,
                    75,
                    5,
                    9,
                    18,
                    8,
                    13,
                    42,
                    4,
                    11,
                    71,
                    55,
                    9,
                    9,
                    4,
                    48,
                    83,
                    2,
                    2,
                    30,
                    14,
                    230,
                    23,
                    280,
                    3,
                    5,
                    3,
                    37,
                    3,
                    5,
                    3,
                    7,
                    2,
                    0,
                    2,
                    0,
                    2,
                    0,
                    2,
                    30,
                    3,
                    52,
                    2,
                    6,
                    2,
                    0,
                    4,
                    2,
                    2,
                    6,
                    4,
                    3,
                    3,
                    5,
                    5,
                    12,
                    6,
                    2,
                    2,
                    6,
                    67,
                    1,
                    20,
                    0,
                    29,
                    0,
                    14,
                    0,
                    17,
                    4,
                    60,
                    12,
                    5,
                    0,
                    4,
                    11,
                    18,
                    0,
                    5,
                    0,
                    3,
                    9,
                    2,
                    0,
                    4,
                    4,
                    7,
                    0,
                    2,
                    0,
                    2,
                    0,
                    2,
                    3,
                    2,
                    10,
                    3,
                    3,
                    6,
                    4,
                    5,
                    0,
                    53,
                    1,
                    2684,
                    46,
                    2,
                    46,
                    2,
                    132,
                    7,
                    6,
                    15,
                    37,
                    11,
                    53,
                    10,
                    0,
                    17,
                    22,
                    10,
                    6,
                    2,
                    6,
                    2,
                    6,
                    2,
                    6,
                    2,
                    6,
                    2,
                    6,
                    2,
                    6,
                    2,
                    6,
                    2,
                    31,
                    48,
                    0,
                    470,
                    1,
                    36,
                    5,
                    2,
                    4,
                    6,
                    1,
                    5,
                    85,
                    3,
                    1,
                    3,
                    2,
                    2,
                    89,
                    2,
                    3,
                    6,
                    40,
                    4,
                    93,
                    18,
                    23,
                    57,
                    15,
                    513,
                    6581,
                    75,
                    20939,
                    53,
                    1164,
                    68,
                    45,
                    3,
                    268,
                    4,
                    27,
                    21,
                    31,
                    3,
                    13,
                    13,
                    1,
                    2,
                    24,
                    9,
                    69,
                    11,
                    1,
                    38,
                    8,
                    3,
                    102,
                    3,
                    1,
                    111,
                    44,
                    25,
                    51,
                    13,
                    68,
                    12,
                    9,
                    7,
                    23,
                    4,
                    0,
                    5,
                    45,
                    3,
                    35,
                    13,
                    28,
                    4,
                    64,
                    15,
                    10,
                    39,
                    54,
                    10,
                    13,
                    3,
                    9,
                    7,
                    22,
                    4,
                    1,
                    5,
                    66,
                    25,
                    2,
                    227,
                    42,
                    2,
                    1,
                    3,
                    9,
                    7,
                    11171,
                    13,
                    22,
                    5,
                    48,
                    8453,
                    301,
                    3,
                    61,
                    3,
                    105,
                    39,
                    6,
                    13,
                    4,
                    6,
                    11,
                    2,
                    12,
                    2,
                    4,
                    2,
                    0,
                    2,
                    1,
                    2,
                    1,
                    2,
                    107,
                    34,
                    362,
                    19,
                    63,
                    3,
                    53,
                    41,
                    11,
                    5,
                    15,
                    17,
                    6,
                    13,
                    1,
                    25,
                    2,
                    33,
                    4,
                    2,
                    134,
                    20,
                    9,
                    8,
                    25,
                    5,
                    0,
                    2,
                    25,
                    12,
                    88,
                    4,
                    5,
                    3,
                    5,
                    3,
                    5,
                    3,
                    2
                ];
                var code = 0;
                var str = [];
                for(var i = 0; i < wordChars.length; i += 2){
                    str.push(code += wordChars[i]);
                    if (wordChars[i + 1]) str.push(45, code += wordChars[i + 1]);
                }
                exports1.wordChars = String.fromCharCode.apply(null, str);
            /***/ },
            /***/ 8390: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1264628__) {
                "use strict";
                var oop = __nested_webpack_require_1264628__(2011);
                var dom = __nested_webpack_require_1264628__(5336);
                var lang = __nested_webpack_require_1264628__(732);
                var config = __nested_webpack_require_1264628__(3294);
                var GutterLayer = __nested_webpack_require_1264628__(9749)/* .Gutter */ .T;
                var MarkerLayer = __nested_webpack_require_1264628__(8890)/* .Marker */ .J;
                var TextLayer = __nested_webpack_require_1264628__(8235)/* .Text */ .x;
                var CursorLayer = __nested_webpack_require_1264628__(1361)/* .Cursor */ .C;
                var HScrollBar = __nested_webpack_require_1264628__(6038)/* .HScrollBar */ .ii;
                var VScrollBar = __nested_webpack_require_1264628__(6038)/* .VScrollBar */ .oX;
                var HScrollBarCustom = __nested_webpack_require_1264628__(9975)/* .HScrollBar */ .ii;
                var VScrollBarCustom = __nested_webpack_require_1264628__(9975)/* .VScrollBar */ .oX;
                var RenderLoop = __nested_webpack_require_1264628__(9224)/* .RenderLoop */ .d;
                var FontMetrics = __nested_webpack_require_1264628__(342)/* .FontMetrics */ .c;
                var EventEmitter = __nested_webpack_require_1264628__(7858)/* .EventEmitter */ .v;
                var editorCss = __nested_webpack_require_1264628__(5043);
                var Decorator = __nested_webpack_require_1264628__(9945)/* .Decorator */ .S;
                var useragent = __nested_webpack_require_1264628__(8057);
                dom.importCssString(editorCss, "ace_editor.css", false);
                /**
 * The class that is responsible for drawing everything you see on the screen!
 * @related editor.renderer 
 **/ var VirtualRenderer = /*#__PURE__*/ function() {
                    function VirtualRenderer(container, theme) {
                        _class_call_check(this, VirtualRenderer);
                        var _self = this;
                        this.container = container || dom.createElement("div");
                        dom.addCssClass(this.container, "ace_editor");
                        if (dom.HI_DPI) dom.addCssClass(this.container, "ace_hidpi");
                        this.setTheme(theme);
                        if (config.get("useStrictCSP") == null) config.set("useStrictCSP", false);
                        this.$gutter = dom.createElement("div");
                        this.$gutter.className = "ace_gutter";
                        this.container.appendChild(this.$gutter);
                        this.$gutter.setAttribute("aria-hidden", true);
                        this.scroller = dom.createElement("div");
                        this.scroller.className = "ace_scroller";
                        this.container.appendChild(this.scroller);
                        this.content = dom.createElement("div");
                        this.content.className = "ace_content";
                        this.scroller.appendChild(this.content);
                        this.$gutterLayer = new GutterLayer(this.$gutter);
                        this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));
                        this.$markerBack = new MarkerLayer(this.content);
                        var textLayer = this.$textLayer = new TextLayer(this.content);
                        this.canvas = textLayer.element;
                        this.$markerFront = new MarkerLayer(this.content);
                        this.$cursorLayer = new CursorLayer(this.content);
                        // Indicates whether the horizontal scrollbar is visible
                        this.$horizScroll = false;
                        this.$vScroll = false;
                        this.scrollBar = this.scrollBarV = new VScrollBar(this.container, this);
                        this.scrollBarH = new HScrollBar(this.container, this);
                        this.scrollBarV.on("scroll", function(e) {
                            if (!_self.$scrollAnimation) _self.session.setScrollTop(e.data - _self.scrollMargin.top);
                        });
                        this.scrollBarH.on("scroll", function(e) {
                            if (!_self.$scrollAnimation) _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
                        });
                        this.scrollTop = 0;
                        this.scrollLeft = 0;
                        this.cursorPos = {
                            row: 0,
                            column: 0
                        };
                        this.$fontMetrics = new FontMetrics(this.container);
                        this.$textLayer.$setFontMetrics(this.$fontMetrics);
                        this.$textLayer.on("changeCharacterSize", function(e) {
                            _self.updateCharacterSize();
                            _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
                            _self._signal("changeCharacterSize", e);
                        });
                        this.$size = {
                            width: 0,
                            height: 0,
                            scrollerHeight: 0,
                            scrollerWidth: 0,
                            $dirty: true
                        };
                        this.layerConfig = {
                            width: 1,
                            padding: 0,
                            firstRow: 0,
                            firstRowScreen: 0,
                            lastRow: 0,
                            lineHeight: 0,
                            characterWidth: 0,
                            minHeight: 1,
                            maxHeight: 1,
                            offset: 0,
                            height: 1,
                            gutterOffset: 1
                        };
                        this.scrollMargin = {
                            left: 0,
                            right: 0,
                            top: 0,
                            bottom: 0,
                            v: 0,
                            h: 0
                        };
                        this.margin = {
                            left: 0,
                            right: 0,
                            top: 0,
                            bottom: 0,
                            v: 0,
                            h: 0
                        };
                        this.$keepTextAreaAtCursor = !useragent.isIOS;
                        this.$loop = new RenderLoop(this.$renderChanges.bind(this), this.container.ownerDocument.defaultView);
                        this.$loop.schedule(this.CHANGE_FULL);
                        this.updateCharacterSize();
                        this.setPadding(4);
                        this.$addResizeObserver();
                        config.resetOptions(this);
                        config._signal("renderer", this);
                    }
                    _create_class(VirtualRenderer, [
                        {
                            // this.$logChanges = function(changes) {
                            //     var a = ""
                            //     if (changes & this.CHANGE_CURSOR) a += " cursor";
                            //     if (changes & this.CHANGE_MARKER) a += " marker";
                            //     if (changes & this.CHANGE_GUTTER) a += " gutter";
                            //     if (changes & this.CHANGE_SCROLL) a += " scroll";
                            //     if (changes & this.CHANGE_LINES) a += " lines";
                            //     if (changes & this.CHANGE_TEXT) a += " text";
                            //     if (changes & this.CHANGE_SIZE) a += " size";
                            //     if (changes & this.CHANGE_MARKER_BACK) a += " marker_back";
                            //     if (changes & this.CHANGE_MARKER_FRONT) a += " marker_front";
                            //     if (changes & this.CHANGE_FULL) a += " full";
                            //     if (changes & this.CHANGE_H_SCROLL) a += " h_scroll";
                            //     console.log(a.trim())
                            // };
                            key: "updateCharacterSize",
                            value: function updateCharacterSize() {
                                if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
                                    this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
                                    this.setStyle("ace_nobold", !this.$allowBoldFonts);
                                }
                                this.layerConfig.characterWidth = this.characterWidth = this.$textLayer.getCharacterWidth();
                                this.layerConfig.lineHeight = this.lineHeight = this.$textLayer.getLineHeight();
                                this.$updatePrintMargin();
                                // set explicit line height to avoid normal resolving to different values based on text
                                dom.setStyle(this.scroller.style, "line-height", this.lineHeight + "px");
                            }
                        },
                        {
                            /**
     *
     * Associates the renderer with an [[EditSession `EditSession`]].
     **/ key: "setSession",
                            value: function setSession(session) {
                                if (this.session) this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);
                                this.session = session;
                                if (session && this.scrollMargin.top && session.getScrollTop() <= 0) session.setScrollTop(-this.scrollMargin.top);
                                this.$cursorLayer.setSession(session);
                                this.$markerBack.setSession(session);
                                this.$markerFront.setSession(session);
                                this.$gutterLayer.setSession(session);
                                this.$textLayer.setSession(session);
                                if (!session) return;
                                this.$loop.schedule(this.CHANGE_FULL);
                                this.session.$setFontMetrics(this.$fontMetrics);
                                this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
                                this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
                                this.onChangeNewLineMode();
                                this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
                            }
                        },
                        {
                            /**
     * Triggers a partial update of the text, from the range given by the two parameters.
     * @param {Number} firstRow The first row to update
     * @param {Number} lastRow The last row to update
     *
     **/ key: "updateLines",
                            value: function updateLines(firstRow, lastRow, force) {
                                if (lastRow === undefined) lastRow = Infinity;
                                if (!this.$changedLines) {
                                    this.$changedLines = {
                                        firstRow: firstRow,
                                        lastRow: lastRow
                                    };
                                } else {
                                    if (this.$changedLines.firstRow > firstRow) this.$changedLines.firstRow = firstRow;
                                    if (this.$changedLines.lastRow < lastRow) this.$changedLines.lastRow = lastRow;
                                }
                                // If the change happened offscreen above us then it's possible
                                // that a new line wrap will affect the position of the lines on our
                                // screen so they need redrawn.
                                // TODO: better solution is to not change scroll position when text is changed outside of visible area
                                if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
                                    if (force) this.$changedLines.lastRow = this.layerConfig.lastRow;
                                    else return;
                                }
                                if (this.$changedLines.firstRow > this.layerConfig.lastRow) return;
                                this.$loop.schedule(this.CHANGE_LINES);
                            }
                        },
                        {
                            key: "onChangeNewLineMode",
                            value: function onChangeNewLineMode() {
                                this.$loop.schedule(this.CHANGE_TEXT);
                                this.$textLayer.$updateEolChar();
                                this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);
                            }
                        },
                        {
                            key: "onChangeTabSize",
                            value: function onChangeTabSize() {
                                this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
                                this.$textLayer.onChangeTabSize();
                            }
                        },
                        {
                            /**
     * Triggers a full update of the text, for all the rows.
     **/ key: "updateText",
                            value: function updateText() {
                                this.$loop.schedule(this.CHANGE_TEXT);
                            }
                        },
                        {
                            /**
     * Triggers a full update of all the layers, for all the rows.
     * @param {Boolean} force If `true`, forces the changes through
     **/ key: "updateFull",
                            value: function updateFull(force) {
                                if (force) this.$renderChanges(this.CHANGE_FULL, true);
                                else this.$loop.schedule(this.CHANGE_FULL);
                            }
                        },
                        {
                            /**
     * Updates the font size.
     **/ key: "updateFontSize",
                            value: function updateFontSize() {
                                this.$textLayer.checkForSizeChanges();
                            }
                        },
                        {
                            key: "$updateSizeAsync",
                            value: function $updateSizeAsync() {
                                if (this.$loop.pending) this.$size.$dirty = true;
                                else this.onResize();
                            }
                        },
                        {
                            /**
     * [Triggers a resize of the editor.]{: #VirtualRenderer.onResize}
     * @param {Boolean} force If `true`, recomputes the size, even if the height and width haven't changed
     * @param {Number} gutterWidth The width of the gutter in pixels
     * @param {Number} width The width of the editor in pixels
     * @param {Number} height The hiehgt of the editor, in pixels
     *
     **/ key: "onResize",
                            value: function onResize(force, gutterWidth, width, height) {
                                if (this.resizing > 2) return;
                                else if (this.resizing > 0) this.resizing++;
                                else this.resizing = force ? 1 : 0;
                                // `|| el.scrollHeight` is required for outosizing editors on ie
                                // where elements with clientHeight = 0 alsoe have clientWidth = 0
                                var el = this.container;
                                if (!height) height = el.clientHeight || el.scrollHeight;
                                if (!width) width = el.clientWidth || el.scrollWidth;
                                var changes = this.$updateCachedSize(force, gutterWidth, width, height);
                                if (this.$resizeTimer) this.$resizeTimer.cancel();
                                if (!this.$size.scrollerHeight || !width && !height) return this.resizing = 0;
                                if (force) this.$gutterLayer.$padding = null;
                                if (force) this.$renderChanges(changes | this.$changes, true);
                                else this.$loop.schedule(changes | this.$changes);
                                if (this.resizing) this.resizing = 0;
                                // reset cached values on scrollbars, needs to be removed when switching to non-native scrollbars
                                // see https://github.com/ajaxorg/ace/issues/2195
                                this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
                                if (this.$customScrollbar) {
                                    this.$updateCustomScrollbar(true);
                                }
                            }
                        },
                        {
                            key: "$updateCachedSize",
                            value: function $updateCachedSize(force, gutterWidth, width, height) {
                                height -= this.$extraHeight || 0;
                                var changes = 0;
                                var size = this.$size;
                                var oldSize = {
                                    width: size.width,
                                    height: size.height,
                                    scrollerHeight: size.scrollerHeight,
                                    scrollerWidth: size.scrollerWidth
                                };
                                if (height && (force || size.height != height)) {
                                    size.height = height;
                                    changes |= this.CHANGE_SIZE;
                                    size.scrollerHeight = size.height;
                                    if (this.$horizScroll) size.scrollerHeight -= this.scrollBarH.getHeight();
                                    this.scrollBarV.setHeight(size.scrollerHeight);
                                    this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";
                                    changes = changes | this.CHANGE_SCROLL;
                                }
                                if (width && (force || size.width != width)) {
                                    changes |= this.CHANGE_SIZE;
                                    size.width = width;
                                    if (gutterWidth == null) gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
                                    this.gutterWidth = gutterWidth;
                                    dom.setStyle(this.scrollBarH.element.style, "left", gutterWidth + "px");
                                    dom.setStyle(this.scroller.style, "left", gutterWidth + this.margin.left + "px");
                                    size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth() - this.margin.h);
                                    dom.setStyle(this.$gutter.style, "left", this.margin.left + "px");
                                    var right = this.scrollBarV.getWidth() + "px";
                                    dom.setStyle(this.scrollBarH.element.style, "right", right);
                                    dom.setStyle(this.scroller.style, "right", right);
                                    dom.setStyle(this.scroller.style, "bottom", this.scrollBarH.getHeight());
                                    this.scrollBarH.setWidth(size.scrollerWidth);
                                    if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force) {
                                        changes |= this.CHANGE_FULL;
                                    }
                                }
                                size.$dirty = !width || !height;
                                if (changes) this._signal("resize", oldSize);
                                return changes;
                            }
                        },
                        {
                            key: "onGutterResize",
                            value: function onGutterResize(width) {
                                var gutterWidth = this.$showGutter ? width : 0;
                                if (gutterWidth != this.gutterWidth) this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);
                                if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
                                    this.$loop.schedule(this.CHANGE_FULL);
                                } else if (this.$size.$dirty) {
                                    this.$loop.schedule(this.CHANGE_FULL);
                                } else {
                                    this.$computeLayerConfig();
                                }
                            }
                        },
                        {
                            /**
     * Adjusts the wrap limit, which is the number of characters that can fit within the width of the edit area on screen.
     **/ key: "adjustWrapLimit",
                            value: function adjustWrapLimit() {
                                var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
                                var limit = Math.floor(availableWidth / this.characterWidth);
                                return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
                            }
                        },
                        {
                            /**
     * Identifies whether you want to have an animated scroll or not.
     * @param {Boolean} shouldAnimate Set to `true` to show animated scrolls
     *
     **/ key: "setAnimatedScroll",
                            value: function setAnimatedScroll(shouldAnimate) {
                                this.setOption("animatedScroll", shouldAnimate);
                            }
                        },
                        {
                            /**
     * Returns whether an animated scroll happens or not.
     * @returns {Boolean}
     **/ key: "getAnimatedScroll",
                            value: function getAnimatedScroll() {
                                return this.$animatedScroll;
                            }
                        },
                        {
                            /**
     * Identifies whether you want to show invisible characters or not.
     * @param {Boolean} showInvisibles Set to `true` to show invisibles
     *
     **/ key: "setShowInvisibles",
                            value: function setShowInvisibles(showInvisibles) {
                                this.setOption("showInvisibles", showInvisibles);
                                this.session.$bidiHandler.setShowInvisibles(showInvisibles);
                            }
                        },
                        {
                            /**
     * Returns whether invisible characters are being shown or not.
     * @returns {Boolean}
     **/ key: "getShowInvisibles",
                            value: function getShowInvisibles() {
                                return this.getOption("showInvisibles");
                            }
                        },
                        {
                            key: "getDisplayIndentGuide",
                            value: function getDisplayIndentGuide() {
                                return this.getOption("displayIndentGuides");
                            }
                        },
                        {
                            key: "setDisplayIndentGuides",
                            value: function setDisplayIndentGuides(display) {
                                this.setOption("displayIndentGuides", display);
                            }
                        },
                        {
                            key: "getHighlightIndentGuides",
                            value: function getHighlightIndentGuides() {
                                return this.getOption("highlightIndentGuides");
                            }
                        },
                        {
                            key: "setHighlightIndentGuides",
                            value: function setHighlightIndentGuides(highlight) {
                                this.setOption("highlightIndentGuides", highlight);
                            }
                        },
                        {
                            /**
     * Identifies whether you want to show the print margin or not.
     * @param {Boolean} showPrintMargin Set to `true` to show the print margin
     *
     **/ key: "setShowPrintMargin",
                            value: function setShowPrintMargin(showPrintMargin) {
                                this.setOption("showPrintMargin", showPrintMargin);
                            }
                        },
                        {
                            /**
     * Returns whether the print margin is being shown or not.
     * @returns {Boolean}
     **/ key: "getShowPrintMargin",
                            value: function getShowPrintMargin() {
                                return this.getOption("showPrintMargin");
                            }
                        },
                        {
                            /**
     * Identifies whether you want to show the print margin column or not.
     * @param {Boolean} showPrintMargin Set to `true` to show the print margin column
     *
     **/ key: "setPrintMarginColumn",
                            value: function setPrintMarginColumn(showPrintMargin) {
                                this.setOption("printMarginColumn", showPrintMargin);
                            }
                        },
                        {
                            /**
     * Returns whether the print margin column is being shown or not.
     * @returns {Boolean}
     **/ key: "getPrintMarginColumn",
                            value: function getPrintMarginColumn() {
                                return this.getOption("printMarginColumn");
                            }
                        },
                        {
                            /**
     * Returns `true` if the gutter is being shown.
     * @returns {Boolean}
     **/ key: "getShowGutter",
                            value: function getShowGutter() {
                                return this.getOption("showGutter");
                            }
                        },
                        {
                            /**
     * Identifies whether you want to show the gutter or not.
     * @param {Boolean} show Set to `true` to show the gutter
     *
     **/ key: "setShowGutter",
                            value: function setShowGutter(show) {
                                return this.setOption("showGutter", show);
                            }
                        },
                        {
                            key: "getFadeFoldWidgets",
                            value: function getFadeFoldWidgets() {
                                return this.getOption("fadeFoldWidgets");
                            }
                        },
                        {
                            key: "setFadeFoldWidgets",
                            value: function setFadeFoldWidgets(show) {
                                this.setOption("fadeFoldWidgets", show);
                            }
                        },
                        {
                            key: "setHighlightGutterLine",
                            value: function setHighlightGutterLine(shouldHighlight) {
                                this.setOption("highlightGutterLine", shouldHighlight);
                            }
                        },
                        {
                            key: "getHighlightGutterLine",
                            value: function getHighlightGutterLine() {
                                return this.getOption("highlightGutterLine");
                            }
                        },
                        {
                            key: "$updatePrintMargin",
                            value: function $updatePrintMargin() {
                                if (!this.$showPrintMargin && !this.$printMarginEl) return;
                                if (!this.$printMarginEl) {
                                    var containerEl = dom.createElement("div");
                                    containerEl.className = "ace_layer ace_print-margin-layer";
                                    this.$printMarginEl = dom.createElement("div");
                                    this.$printMarginEl.className = "ace_print-margin";
                                    containerEl.appendChild(this.$printMarginEl);
                                    this.content.insertBefore(containerEl, this.content.firstChild);
                                }
                                var style = this.$printMarginEl.style;
                                style.left = Math.round(this.characterWidth * this.$printMarginColumn + this.$padding) + "px";
                                style.visibility = this.$showPrintMargin ? "visible" : "hidden";
                                if (this.session && this.session.$wrap == -1) this.adjustWrapLimit();
                            }
                        },
                        {
                            /**
     *
     * Returns the root element containing this renderer.
     * @returns {Element}
     **/ key: "getContainerElement",
                            value: function getContainerElement() {
                                return this.container;
                            }
                        },
                        {
                            /**
     *
     * Returns the element that the mouse events are attached to
     * @returns {Element}
     **/ key: "getMouseEventTarget",
                            value: function getMouseEventTarget() {
                                return this.scroller;
                            }
                        },
                        {
                            /**
     *
     * Returns the element to which the hidden text area is added.
     * @returns {Element}
     **/ key: "getTextAreaContainer",
                            value: function getTextAreaContainer() {
                                return this.container;
                            }
                        },
                        {
                            // move text input over the cursor
                            // this is required for IME
                            key: "$moveTextAreaToCursor",
                            value: function $moveTextAreaToCursor() {
                                if (this.$isMousePressed) return;
                                var style = this.textarea.style;
                                var composition = this.$composition;
                                if (!this.$keepTextAreaAtCursor && !composition) {
                                    dom.translate(this.textarea, -100, 0);
                                    return;
                                }
                                var pixelPos = this.$cursorLayer.$pixelPos;
                                if (!pixelPos) return;
                                if (composition && composition.markerRange) pixelPos = this.$cursorLayer.getPixelPosition(composition.markerRange.start, true);
                                var config = this.layerConfig;
                                var posTop = pixelPos.top;
                                var posLeft = pixelPos.left;
                                posTop -= config.offset;
                                var h = composition && composition.useTextareaForIME || useragent.isMobile ? this.lineHeight : 1;
                                if (posTop < 0 || posTop > config.height - h) {
                                    dom.translate(this.textarea, 0, 0);
                                    return;
                                }
                                var w = 1;
                                var maxTop = this.$size.height - h;
                                if (!composition) {
                                    posTop += this.lineHeight;
                                } else {
                                    if (composition.useTextareaForIME) {
                                        var val = this.textarea.value;
                                        w = this.characterWidth * this.session.$getStringScreenWidth(val)[0];
                                    } else {
                                        posTop += this.lineHeight + 2;
                                    }
                                }
                                posLeft -= this.scrollLeft;
                                if (posLeft > this.$size.scrollerWidth - w) posLeft = this.$size.scrollerWidth - w;
                                posLeft += this.gutterWidth + this.margin.left;
                                dom.setStyle(style, "height", h + "px");
                                dom.setStyle(style, "width", w + "px");
                                dom.translate(this.textarea, Math.min(posLeft, this.$size.scrollerWidth - w), Math.min(posTop, maxTop));
                            }
                        },
                        {
                            /**
     * [Returns the index of the first visible row.]{: #VirtualRenderer.getFirstVisibleRow}
     * @returns {Number}
     **/ key: "getFirstVisibleRow",
                            value: function getFirstVisibleRow() {
                                return this.layerConfig.firstRow;
                            }
                        },
                        {
                            /**
     *
     * Returns the index of the first fully visible row. "Fully" here means that the characters in the row are not truncated; that the top and the bottom of the row are on the screen.
     * @returns {Number}
     **/ key: "getFirstFullyVisibleRow",
                            value: function getFirstFullyVisibleRow() {
                                return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
                            }
                        },
                        {
                            /**
     *
     * Returns the index of the last fully visible row. "Fully" here means that the characters in the row are not truncated; that the top and the bottom of the row are on the screen.
     * @returns {Number}
     **/ key: "getLastFullyVisibleRow",
                            value: function getLastFullyVisibleRow() {
                                var config = this.layerConfig;
                                var lastRow = config.lastRow;
                                var top = this.session.documentToScreenRow(lastRow, 0) * config.lineHeight;
                                if (top - this.session.getScrollTop() > config.height - config.lineHeight) return lastRow - 1;
                                return lastRow;
                            }
                        },
                        {
                            /**
     *
     * [Returns the index of the last visible row.]{: #VirtualRenderer.getLastVisibleRow}
     * @returns {Number}
     **/ key: "getLastVisibleRow",
                            value: function getLastVisibleRow() {
                                return this.layerConfig.lastRow;
                            }
                        },
                        {
                            /**
     * Sets the padding for all the layers.
     * @param {Number} padding A new padding value (in pixels)
     *
     **/ key: "setPadding",
                            value: function setPadding(padding) {
                                this.$padding = padding;
                                this.$textLayer.setPadding(padding);
                                this.$cursorLayer.setPadding(padding);
                                this.$markerFront.setPadding(padding);
                                this.$markerBack.setPadding(padding);
                                this.$loop.schedule(this.CHANGE_FULL);
                                this.$updatePrintMargin();
                            }
                        },
                        {
                            key: "setScrollMargin",
                            value: function setScrollMargin(top, bottom, left, right) {
                                var sm = this.scrollMargin;
                                sm.top = top | 0;
                                sm.bottom = bottom | 0;
                                sm.right = right | 0;
                                sm.left = left | 0;
                                sm.v = sm.top + sm.bottom;
                                sm.h = sm.left + sm.right;
                                if (sm.top && this.scrollTop <= 0 && this.session) this.session.setScrollTop(-sm.top);
                                this.updateFull();
                            }
                        },
                        {
                            key: "setMargin",
                            value: function setMargin(top, bottom, left, right) {
                                var sm = this.margin;
                                sm.top = top | 0;
                                sm.bottom = bottom | 0;
                                sm.right = right | 0;
                                sm.left = left | 0;
                                sm.v = sm.top + sm.bottom;
                                sm.h = sm.left + sm.right;
                                this.$updateCachedSize(true, this.gutterWidth, this.$size.width, this.$size.height);
                                this.updateFull();
                            }
                        },
                        {
                            /**
     * Returns whether the horizontal scrollbar is set to be always visible.
     * @returns {Boolean}
     **/ key: "getHScrollBarAlwaysVisible",
                            value: function getHScrollBarAlwaysVisible() {
                                return this.$hScrollBarAlwaysVisible;
                            }
                        },
                        {
                            /**
     * Identifies whether you want to show the horizontal scrollbar or not.
     * @param {Boolean} alwaysVisible Set to `true` to make the horizontal scroll bar visible
     **/ key: "setHScrollBarAlwaysVisible",
                            value: function setHScrollBarAlwaysVisible(alwaysVisible) {
                                this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
                            }
                        },
                        {
                            /**
     * Returns whether the horizontal scrollbar is set to be always visible.
     * @returns {Boolean}
     **/ key: "getVScrollBarAlwaysVisible",
                            value: function getVScrollBarAlwaysVisible() {
                                return this.$vScrollBarAlwaysVisible;
                            }
                        },
                        {
                            /**
     * Identifies whether you want to show the horizontal scrollbar or not.
     * @param {Boolean} alwaysVisible Set to `true` to make the horizontal scroll bar visible
     **/ key: "setVScrollBarAlwaysVisible",
                            value: function setVScrollBarAlwaysVisible(alwaysVisible) {
                                this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
                            }
                        },
                        {
                            key: "$updateScrollBarV",
                            value: function $updateScrollBarV() {
                                var scrollHeight = this.layerConfig.maxHeight;
                                var scrollerHeight = this.$size.scrollerHeight;
                                if (!this.$maxLines && this.$scrollPastEnd) {
                                    scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
                                    if (this.scrollTop > scrollHeight - scrollerHeight) {
                                        scrollHeight = this.scrollTop + scrollerHeight;
                                        this.scrollBarV.scrollTop = null;
                                    }
                                }
                                this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
                                this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
                            }
                        },
                        {
                            key: "$updateScrollBarH",
                            value: function $updateScrollBarH() {
                                this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
                                this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
                            }
                        },
                        {
                            key: "freeze",
                            value: function freeze() {
                                this.$frozen = true;
                            }
                        },
                        {
                            key: "unfreeze",
                            value: function unfreeze() {
                                this.$frozen = false;
                            }
                        },
                        {
                            key: "$renderChanges",
                            value: function $renderChanges(changes, force) {
                                if (this.$changes) {
                                    changes |= this.$changes;
                                    this.$changes = 0;
                                }
                                if (!this.session || !this.container.offsetWidth || this.$frozen || !changes && !force) {
                                    this.$changes |= changes;
                                    return;
                                }
                                if (this.$size.$dirty) {
                                    this.$changes |= changes;
                                    return this.onResize(true);
                                }
                                if (!this.lineHeight) {
                                    this.$textLayer.checkForSizeChanges();
                                }
                                // this.$logChanges(changes);
                                this._signal("beforeRender", changes);
                                if (this.session && this.session.$bidiHandler) this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);
                                var config = this.layerConfig;
                                // text, scrolling and resize changes can cause the view port size to change
                                if (changes & this.CHANGE_FULL || changes & this.CHANGE_SIZE || changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES || changes & this.CHANGE_SCROLL || changes & this.CHANGE_H_SCROLL) {
                                    changes |= this.$computeLayerConfig() | this.$loop.clear();
                                    // If a change is made offscreen and wrapMode is on, then the onscreen
                                    // lines may have been pushed down. If so, the first screen row will not
                                    // have changed, but the first actual row will. In that case, adjust 
                                    // scrollTop so that the cursor and onscreen content stays in the same place.
                                    // TODO: find a better way to handle this, that works non wrapped case and doesn't compute layerConfig twice
                                    if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {
                                        var st = this.scrollTop + (config.firstRow - Math.max(this.layerConfig.firstRow, 0)) * this.lineHeight;
                                        if (st > 0) {
                                            // this check is needed as a workaround for the documentToScreenRow returning -1 if document.length == 0
                                            this.scrollTop = st;
                                            changes = changes | this.CHANGE_SCROLL;
                                            changes |= this.$computeLayerConfig() | this.$loop.clear();
                                        }
                                    }
                                    config = this.layerConfig;
                                    // update scrollbar first to not lose scroll position when gutter calls resize
                                    this.$updateScrollBarV();
                                    if (changes & this.CHANGE_H_SCROLL) this.$updateScrollBarH();
                                    dom.translate(this.content, -this.scrollLeft, -config.offset);
                                    var width = config.width + 2 * this.$padding + "px";
                                    var height = config.minHeight + "px";
                                    dom.setStyle(this.content.style, "width", width);
                                    dom.setStyle(this.content.style, "height", height);
                                }
                                // horizontal scrolling
                                if (changes & this.CHANGE_H_SCROLL) {
                                    dom.translate(this.content, -this.scrollLeft, -config.offset);
                                    this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller" : "ace_scroller ace_scroll-left";
                                }
                                // full
                                if (changes & this.CHANGE_FULL) {
                                    this.$changedLines = null;
                                    this.$textLayer.update(config);
                                    if (this.$showGutter) this.$gutterLayer.update(config);
                                    if (this.$customScrollbar) {
                                        this.$scrollDecorator.$updateDecorators(config);
                                    }
                                    this.$markerBack.update(config);
                                    this.$markerFront.update(config);
                                    this.$cursorLayer.update(config);
                                    this.$moveTextAreaToCursor();
                                    this._signal("afterRender", changes);
                                    return;
                                }
                                // scrolling
                                if (changes & this.CHANGE_SCROLL) {
                                    this.$changedLines = null;
                                    if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES) this.$textLayer.update(config);
                                    else this.$textLayer.scrollLines(config);
                                    if (this.$showGutter) {
                                        if (changes & this.CHANGE_GUTTER || changes & this.CHANGE_LINES) this.$gutterLayer.update(config);
                                        else this.$gutterLayer.scrollLines(config);
                                    }
                                    if (this.$customScrollbar) {
                                        this.$scrollDecorator.$updateDecorators(config);
                                    }
                                    this.$markerBack.update(config);
                                    this.$markerFront.update(config);
                                    this.$cursorLayer.update(config);
                                    this.$moveTextAreaToCursor();
                                    this._signal("afterRender", changes);
                                    return;
                                }
                                if (changes & this.CHANGE_TEXT) {
                                    this.$changedLines = null;
                                    this.$textLayer.update(config);
                                    if (this.$showGutter) this.$gutterLayer.update(config);
                                    if (this.$customScrollbar) {
                                        this.$scrollDecorator.$updateDecorators(config);
                                    }
                                } else if (changes & this.CHANGE_LINES) {
                                    if (this.$updateLines() || changes & this.CHANGE_GUTTER && this.$showGutter) this.$gutterLayer.update(config);
                                    if (this.$customScrollbar) {
                                        this.$scrollDecorator.$updateDecorators(config);
                                    }
                                } else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
                                    if (this.$showGutter) this.$gutterLayer.update(config);
                                    if (this.$customScrollbar) {
                                        this.$scrollDecorator.$updateDecorators(config);
                                    }
                                } else if (changes & this.CHANGE_CURSOR) {
                                    if (this.$highlightGutterLine) this.$gutterLayer.updateLineHighlight(config);
                                    if (this.$customScrollbar) {
                                        this.$scrollDecorator.$updateDecorators(config);
                                    }
                                }
                                if (changes & this.CHANGE_CURSOR) {
                                    this.$cursorLayer.update(config);
                                    this.$moveTextAreaToCursor();
                                }
                                if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
                                    this.$markerFront.update(config);
                                }
                                if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
                                    this.$markerBack.update(config);
                                }
                                this._signal("afterRender", changes);
                            }
                        },
                        {
                            key: "$autosize",
                            value: function $autosize() {
                                var height = this.session.getScreenLength() * this.lineHeight;
                                var maxHeight = this.$maxLines * this.lineHeight;
                                var desiredHeight = Math.min(maxHeight, Math.max((this.$minLines || 1) * this.lineHeight, height)) + this.scrollMargin.v + (this.$extraHeight || 0);
                                if (this.$horizScroll) desiredHeight += this.scrollBarH.getHeight();
                                if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight) desiredHeight = this.$maxPixelHeight;
                                var hideScrollbars = desiredHeight <= 2 * this.lineHeight;
                                var vScroll = !hideScrollbars && height > maxHeight;
                                if (desiredHeight != this.desiredHeight || this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
                                    if (vScroll != this.$vScroll) {
                                        this.$vScroll = vScroll;
                                        this.scrollBarV.setVisible(vScroll);
                                    }
                                    var w = this.container.clientWidth;
                                    this.container.style.height = desiredHeight + "px";
                                    this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
                                    // this.$loop.changes = 0;
                                    this.desiredHeight = desiredHeight;
                                    this._signal("autosize");
                                }
                            }
                        },
                        {
                            key: "$computeLayerConfig",
                            value: function $computeLayerConfig() {
                                var session = this.session;
                                var size = this.$size;
                                var hideScrollbars = size.height <= 2 * this.lineHeight;
                                var screenLines = this.session.getScreenLength();
                                var maxHeight = screenLines * this.lineHeight;
                                var longestLine = this.$getLongestLine();
                                var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible || size.scrollerWidth - longestLine - 2 * this.$padding < 0);
                                var hScrollChanged = this.$horizScroll !== horizScroll;
                                if (hScrollChanged) {
                                    this.$horizScroll = horizScroll;
                                    this.scrollBarH.setVisible(horizScroll);
                                }
                                var vScrollBefore = this.$vScroll; // autosize can change vscroll value in which case we need to update longestLine
                                // autoresize only after updating hscroll to include scrollbar height in desired height
                                if (this.$maxLines && this.lineHeight > 1) this.$autosize();
                                var minHeight = size.scrollerHeight + this.lineHeight;
                                var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd : 0;
                                maxHeight += scrollPastEnd;
                                var sm = this.scrollMargin;
                                this.session.setScrollTop(Math.max(-sm.top, Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));
                                this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));
                                var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible || size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);
                                var vScrollChanged = vScrollBefore !== vScroll;
                                if (vScrollChanged) {
                                    this.$vScroll = vScroll;
                                    this.scrollBarV.setVisible(vScroll);
                                }
                                var offset = this.scrollTop % this.lineHeight;
                                var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
                                var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
                                var lastRow = firstRow + lineCount;
                                // Map lines on the screen to lines in the document.
                                var firstRowScreen, firstRowHeight;
                                var lineHeight = this.lineHeight;
                                firstRow = session.screenToDocumentRow(firstRow, 0);
                                // Check if firstRow is inside of a foldLine. If true, then use the first
                                // row of the foldLine.
                                var foldLine = session.getFoldLine(firstRow);
                                if (foldLine) {
                                    firstRow = foldLine.start.row;
                                }
                                firstRowScreen = session.documentToScreenRow(firstRow, 0);
                                firstRowHeight = session.getRowLength(firstRow) * lineHeight;
                                lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
                                minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight + firstRowHeight;
                                offset = this.scrollTop - firstRowScreen * lineHeight;
                                var changes = 0;
                                if (this.layerConfig.width != longestLine || hScrollChanged) changes = this.CHANGE_H_SCROLL;
                                // Horizontal scrollbar visibility may have changed, which changes
                                // the client height of the scroller
                                if (hScrollChanged || vScrollChanged) {
                                    changes |= this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
                                    this._signal("scrollbarVisibilityChanged");
                                    if (vScrollChanged) longestLine = this.$getLongestLine();
                                }
                                this.layerConfig = {
                                    width: longestLine,
                                    padding: this.$padding,
                                    firstRow: firstRow,
                                    firstRowScreen: firstRowScreen,
                                    lastRow: lastRow,
                                    lineHeight: lineHeight,
                                    characterWidth: this.characterWidth,
                                    minHeight: minHeight,
                                    maxHeight: maxHeight,
                                    offset: offset,
                                    gutterOffset: lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,
                                    height: this.$size.scrollerHeight
                                };
                                if (this.session.$bidiHandler) this.session.$bidiHandler.setContentWidth(longestLine - this.$padding);
                                // For debugging.
                                // console.log(JSON.stringify(this.layerConfig));
                                return changes;
                            }
                        },
                        {
                            key: "$updateLines",
                            value: function $updateLines() {
                                if (!this.$changedLines) return;
                                var firstRow = this.$changedLines.firstRow;
                                var lastRow = this.$changedLines.lastRow;
                                this.$changedLines = null;
                                var layerConfig = this.layerConfig;
                                if (firstRow > layerConfig.lastRow + 1) {
                                    return;
                                }
                                if (lastRow < layerConfig.firstRow) {
                                    return;
                                }
                                // if the last row is unknown -> redraw everything
                                if (lastRow === Infinity) {
                                    if (this.$showGutter) this.$gutterLayer.update(layerConfig);
                                    this.$textLayer.update(layerConfig);
                                    return;
                                }
                                // else update only the changed rows
                                this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
                                return true;
                            }
                        },
                        {
                            key: "$getLongestLine",
                            value: function $getLongestLine() {
                                var charCount = this.session.getScreenWidth();
                                if (this.showInvisibles && !this.session.$useWrapMode) charCount += 1;
                                if (this.$textLayer && charCount > this.$textLayer.MAX_LINE_LENGTH) charCount = this.$textLayer.MAX_LINE_LENGTH + 30;
                                return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
                            }
                        },
                        {
                            /**
     * Schedules an update to all the front markers in the document.
     **/ key: "updateFrontMarkers",
                            value: function updateFrontMarkers() {
                                this.$markerFront.setMarkers(this.session.getMarkers(true));
                                this.$loop.schedule(this.CHANGE_MARKER_FRONT);
                            }
                        },
                        {
                            /**
     *
     * Schedules an update to all the back markers in the document.
     **/ key: "updateBackMarkers",
                            value: function updateBackMarkers() {
                                this.$markerBack.setMarkers(this.session.getMarkers());
                                this.$loop.schedule(this.CHANGE_MARKER_BACK);
                            }
                        },
                        {
                            /**
     *
     * Deprecated; (moved to [[EditSession]])
     * @deprecated
     **/ key: "addGutterDecoration",
                            value: function addGutterDecoration(row, className) {
                                this.$gutterLayer.addGutterDecoration(row, className);
                            }
                        },
                        {
                            /**
     * Deprecated; (moved to [[EditSession]])
     * @deprecated
     **/ key: "removeGutterDecoration",
                            value: function removeGutterDecoration(row, className) {
                                this.$gutterLayer.removeGutterDecoration(row, className);
                            }
                        },
                        {
                            /**
     *
     * Redraw breakpoints.
     **/ key: "updateBreakpoints",
                            value: function updateBreakpoints(rows) {
                                this.$loop.schedule(this.CHANGE_GUTTER);
                            }
                        },
                        {
                            /**
     * Sets annotations for the gutter.
     * @param {Annotation[]} annotations An array containing annotations
     *
     **/ key: "setAnnotations",
                            value: function setAnnotations(annotations) {
                                this.$gutterLayer.setAnnotations(annotations);
                                this.$loop.schedule(this.CHANGE_GUTTER);
                            }
                        },
                        {
                            /**
     *
     * Updates the cursor icon.
     **/ key: "updateCursor",
                            value: function updateCursor() {
                                this.$loop.schedule(this.CHANGE_CURSOR);
                            }
                        },
                        {
                            /**
     *
     * Hides the cursor icon.
     **/ key: "hideCursor",
                            value: function hideCursor() {
                                this.$cursorLayer.hideCursor();
                            }
                        },
                        {
                            /**
     *
     * Shows the cursor icon.
     **/ key: "showCursor",
                            value: function showCursor() {
                                this.$cursorLayer.showCursor();
                            }
                        },
                        {
                            key: "scrollSelectionIntoView",
                            value: function scrollSelectionIntoView(anchor, lead, offset) {
                                // first scroll anchor into view then scroll lead into view
                                this.scrollCursorIntoView(anchor, offset);
                                this.scrollCursorIntoView(lead, offset);
                            }
                        },
                        {
                            /**
     *
     * Scrolls the cursor into the first visibile area of the editor
     **/ key: "scrollCursorIntoView",
                            value: function scrollCursorIntoView(cursor, offset, $viewMargin) {
                                // the editor is not visible
                                if (this.$size.scrollerHeight === 0) return;
                                var pos = this.$cursorLayer.getPixelPosition(cursor);
                                var newLeft = pos.left;
                                var newTop = pos.top;
                                var topMargin = $viewMargin && $viewMargin.top || 0;
                                var bottomMargin = $viewMargin && $viewMargin.bottom || 0;
                                if (this.$scrollAnimation) {
                                    this.$stopAnimation = true;
                                }
                                var currentTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
                                if (currentTop + topMargin > newTop) {
                                    if (offset && currentTop + topMargin > newTop + this.lineHeight) newTop -= offset * this.$size.scrollerHeight;
                                    if (newTop === 0) newTop = -this.scrollMargin.top;
                                    this.session.setScrollTop(newTop);
                                } else if (currentTop + this.$size.scrollerHeight - bottomMargin < newTop + this.lineHeight) {
                                    if (offset && currentTop + this.$size.scrollerHeight - bottomMargin < newTop - this.lineHeight) newTop += offset * this.$size.scrollerHeight;
                                    this.session.setScrollTop(newTop + this.lineHeight + bottomMargin - this.$size.scrollerHeight);
                                }
                                var currentLeft = this.scrollLeft;
                                // Show 2 context characters of the line when moving to it
                                var twoCharsWidth = 2 * this.layerConfig.characterWidth;
                                if (newLeft - twoCharsWidth < currentLeft) {
                                    newLeft -= twoCharsWidth;
                                    if (newLeft < this.$padding + twoCharsWidth) {
                                        newLeft = -this.scrollMargin.left;
                                    }
                                    this.session.setScrollLeft(newLeft);
                                } else {
                                    newLeft += twoCharsWidth;
                                    if (currentLeft + this.$size.scrollerWidth < newLeft + this.characterWidth) {
                                        this.session.setScrollLeft(Math.round(newLeft + this.characterWidth - this.$size.scrollerWidth));
                                    } else if (currentLeft <= this.$padding && newLeft - currentLeft < this.characterWidth) {
                                        this.session.setScrollLeft(0);
                                    }
                                }
                            }
                        },
                        {
                            /**
     * {:EditSession.getScrollTop}
     * @related EditSession.getScrollTop
     * @returns {Number}
     **/ key: "getScrollTop",
                            value: function getScrollTop() {
                                return this.session.getScrollTop();
                            }
                        },
                        {
                            /**
     * {:EditSession.getScrollLeft}
     * @related EditSession.getScrollLeft
     * @returns {Number}
     **/ key: "getScrollLeft",
                            value: function getScrollLeft() {
                                return this.session.getScrollLeft();
                            }
                        },
                        {
                            /**
     * Returns the first visible row, regardless of whether it's fully visible or not.
     * @returns {Number}
     **/ key: "getScrollTopRow",
                            value: function getScrollTopRow() {
                                return this.scrollTop / this.lineHeight;
                            }
                        },
                        {
                            /**
     * Returns the last visible row, regardless of whether it's fully visible or not.
     * @returns {Number}
     **/ key: "getScrollBottomRow",
                            value: function getScrollBottomRow() {
                                return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
                            }
                        },
                        {
                            /**
     * Gracefully scrolls from the top of the editor to the row indicated.
     * @param {Number} row A row id
     *
     * @related EditSession.setScrollTop
     **/ key: "scrollToRow",
                            value: function scrollToRow(row) {
                                this.session.setScrollTop(row * this.lineHeight);
                            }
                        },
                        {
                            key: "alignCursor",
                            value: function alignCursor(cursor, alignment) {
                                if (typeof cursor == "number") cursor = {
                                    row: cursor,
                                    column: 0
                                };
                                var pos = this.$cursorLayer.getPixelPosition(cursor);
                                var h = this.$size.scrollerHeight - this.lineHeight;
                                var offset = pos.top - h * (alignment || 0);
                                this.session.setScrollTop(offset);
                                return offset;
                            }
                        },
                        {
                            key: "$calcSteps",
                            value: function $calcSteps(fromValue, toValue) {
                                var i = 0;
                                var l = this.STEPS;
                                var steps = [];
                                var func = function func(t, x_min, dx) {
                                    return dx * (Math.pow(t - 1, 3) + 1) + x_min;
                                };
                                for(i = 0; i < l; ++i)steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));
                                return steps;
                            }
                        },
                        {
                            /**
     * Gracefully scrolls the editor to the row indicated.
     * @param {Number} line A line number
     * @param {Boolean} center If `true`, centers the editor the to indicated line
     * @param {Boolean} animate If `true` animates scrolling
     * @param {Function} callback Function to be called after the animation has finished
     *
     **/ key: "scrollToLine",
                            value: function scrollToLine(line, center, animate, callback) {
                                var pos = this.$cursorLayer.getPixelPosition({
                                    row: line,
                                    column: 0
                                });
                                var offset = pos.top;
                                if (center) offset -= this.$size.scrollerHeight / 2;
                                var initialScroll = this.scrollTop;
                                this.session.setScrollTop(offset);
                                if (animate !== false) this.animateScrolling(initialScroll, callback);
                            }
                        },
                        {
                            key: "animateScrolling",
                            value: function animateScrolling(fromValue, callback) {
                                var endAnimation = function endAnimation() {
                                    _self.$timer = clearInterval(_self.$timer);
                                    _self.$scrollAnimation = null;
                                    _self.$stopAnimation = false;
                                    callback && callback();
                                };
                                var toValue = this.scrollTop;
                                if (!this.$animatedScroll) return;
                                var _self = this;
                                if (fromValue == toValue) return;
                                if (this.$scrollAnimation) {
                                    var oldSteps = this.$scrollAnimation.steps;
                                    if (oldSteps.length) {
                                        fromValue = oldSteps[0];
                                        if (fromValue == toValue) return;
                                    }
                                }
                                var steps = _self.$calcSteps(fromValue, toValue);
                                this.$scrollAnimation = {
                                    from: fromValue,
                                    to: toValue,
                                    steps: steps
                                };
                                clearInterval(this.$timer);
                                _self.session.setScrollTop(steps.shift());
                                // trick session to think it's already scrolled to not loose toValue
                                _self.session.$scrollTop = toValue;
                                this.$timer = setInterval(function() {
                                    if (_self.$stopAnimation) {
                                        endAnimation();
                                        return;
                                    }
                                    if (!_self.session) return clearInterval(_self.$timer);
                                    if (steps.length) {
                                        _self.session.setScrollTop(steps.shift());
                                        _self.session.$scrollTop = toValue;
                                    } else if (toValue != null) {
                                        _self.session.$scrollTop = -1;
                                        _self.session.setScrollTop(toValue);
                                        toValue = null;
                                    } else {
                                        // do this on separate step to not get spurious scroll event from scrollbar
                                        endAnimation();
                                    }
                                }, 10);
                            }
                        },
                        {
                            /**
     * Scrolls the editor to the y pixel indicated.
     * @param {Number} scrollTop The position to scroll to
     *
     * @returns {Number}
     **/ key: "scrollToY",
                            value: function scrollToY(scrollTop) {
                                // after calling scrollBar.setScrollTop
                                // scrollbar sends us event with same scrollTop. ignore it
                                if (this.scrollTop !== scrollTop) {
                                    this.$loop.schedule(this.CHANGE_SCROLL);
                                    this.scrollTop = scrollTop;
                                }
                            }
                        },
                        {
                            /**
     * Scrolls the editor across the x-axis to the pixel indicated.
     * @param {Number} scrollLeft The position to scroll to
     *
     * @returns {Number}
     **/ key: "scrollToX",
                            value: function scrollToX(scrollLeft) {
                                if (this.scrollLeft !== scrollLeft) this.scrollLeft = scrollLeft;
                                this.$loop.schedule(this.CHANGE_H_SCROLL);
                            }
                        },
                        {
                            /**
     * Scrolls the editor across both x- and y-axes.
     * @param {Number} x The x value to scroll to
     * @param {Number} y The y value to scroll to
     **/ key: "scrollTo",
                            value: function scrollTo(x, y) {
                                this.session.setScrollTop(y);
                                this.session.setScrollLeft(x);
                            }
                        },
                        {
                            /**
     * Scrolls the editor across both x- and y-axes.
     * @param {Number} deltaX The x value to scroll by
     * @param {Number} deltaY The y value to scroll by
     **/ key: "scrollBy",
                            value: function scrollBy(deltaX, deltaY) {
                                deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
                                deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
                            }
                        },
                        {
                            /**
     * Returns `true` if you can still scroll by either parameter; in other words, you haven't reached the end of the file or line.
     * @param {Number} deltaX The x value to scroll by
     * @param {Number} deltaY The y value to scroll by
     *
     * @returns {Boolean}
     **/ key: "isScrollableBy",
                            value: function isScrollableBy(deltaX, deltaY) {
                                if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top) return true;
                                if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom) return true;
                                if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left) return true;
                                if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth - this.layerConfig.width < -1 + this.scrollMargin.right) return true;
                            }
                        },
                        {
                            key: "pixelToScreenCoordinates",
                            value: function pixelToScreenCoordinates(x, y) {
                                var canvasPos;
                                if (this.$hasCssTransforms) {
                                    canvasPos = {
                                        top: 0,
                                        left: 0
                                    };
                                    var p = this.$fontMetrics.transformCoordinates([
                                        x,
                                        y
                                    ]);
                                    x = p[1] - this.gutterWidth - this.margin.left;
                                    y = p[0];
                                } else {
                                    canvasPos = this.scroller.getBoundingClientRect();
                                }
                                var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
                                var offset = offsetX / this.characterWidth;
                                var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
                                var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);
                                return {
                                    row: row,
                                    column: col,
                                    side: offset - col > 0 ? 1 : -1,
                                    offsetX: offsetX
                                };
                            }
                        },
                        {
                            key: "screenToTextCoordinates",
                            value: function screenToTextCoordinates(x, y) {
                                var canvasPos;
                                if (this.$hasCssTransforms) {
                                    canvasPos = {
                                        top: 0,
                                        left: 0
                                    };
                                    var p = this.$fontMetrics.transformCoordinates([
                                        x,
                                        y
                                    ]);
                                    x = p[1] - this.gutterWidth - this.margin.left;
                                    y = p[0];
                                } else {
                                    canvasPos = this.scroller.getBoundingClientRect();
                                }
                                var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
                                var offset = offsetX / this.characterWidth;
                                var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);
                                var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
                                return this.session.screenToDocumentPosition(row, Math.max(col, 0), offsetX);
                            }
                        },
                        {
                            /**
     * Returns an object containing the `pageX` and `pageY` coordinates of the document position.
     * @param {Number} row The document row position
     * @param {Number} column The document column position
     *
     * @returns {Object}
     **/ key: "textToScreenCoordinates",
                            value: function textToScreenCoordinates(row, column) {
                                var canvasPos = this.scroller.getBoundingClientRect();
                                var pos = this.session.documentToScreenPosition(row, column);
                                var x = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, row) ? this.session.$bidiHandler.getPosLeft(pos.column) : Math.round(pos.column * this.characterWidth));
                                var y = pos.row * this.lineHeight;
                                return {
                                    pageX: canvasPos.left + x - this.scrollLeft,
                                    pageY: canvasPos.top + y - this.scrollTop
                                };
                            }
                        },
                        {
                            /**
     *
     * Focuses the current container.
     **/ key: "visualizeFocus",
                            value: function visualizeFocus() {
                                dom.addCssClass(this.container, "ace_focus");
                            }
                        },
                        {
                            /**
     *
     * Blurs the current container.
     **/ key: "visualizeBlur",
                            value: function visualizeBlur() {
                                dom.removeCssClass(this.container, "ace_focus");
                            }
                        },
                        {
                            /**
     * @param {Object} composition
     *
     * @private
     **/ key: "showComposition",
                            value: function showComposition(composition) {
                                this.$composition = composition;
                                if (!composition.cssText) {
                                    composition.cssText = this.textarea.style.cssText;
                                }
                                if (composition.useTextareaForIME == undefined) composition.useTextareaForIME = this.$useTextareaForIME;
                                if (this.$useTextareaForIME) {
                                    dom.addCssClass(this.textarea, "ace_composition");
                                    this.textarea.style.cssText = "";
                                    this.$moveTextAreaToCursor();
                                    this.$cursorLayer.element.style.display = "none";
                                } else {
                                    composition.markerId = this.session.addMarker(composition.markerRange, "ace_composition_marker", "text");
                                }
                            }
                        },
                        {
                            /**
     * @param {String} text A string of text to use
     *
     * Sets the inner text of the current composition to `text`.
     **/ key: "setCompositionText",
                            value: function setCompositionText(text) {
                                var cursor = this.session.selection.cursor;
                                this.addToken(text, "composition_placeholder", cursor.row, cursor.column);
                                this.$moveTextAreaToCursor();
                            }
                        },
                        {
                            /**
     *
     * Hides the current composition.
     **/ key: "hideComposition",
                            value: function hideComposition() {
                                if (!this.$composition) return;
                                if (this.$composition.markerId) this.session.removeMarker(this.$composition.markerId);
                                dom.removeCssClass(this.textarea, "ace_composition");
                                this.textarea.style.cssText = this.$composition.cssText;
                                var cursor = this.session.selection.cursor;
                                this.removeExtraToken(cursor.row, cursor.column);
                                this.$composition = null;
                                this.$cursorLayer.element.style.display = "";
                            }
                        },
                        {
                            key: "setGhostText",
                            value: function setGhostText(text, position) {
                                var cursor = this.session.selection.cursor;
                                var insertPosition = position || {
                                    row: cursor.row,
                                    column: cursor.column
                                };
                                this.removeGhostText();
                                var textLines = text.split("\n");
                                this.addToken(textLines[0], "ghost_text", insertPosition.row, insertPosition.column);
                                this.$ghostText = {
                                    text: text,
                                    position: {
                                        row: insertPosition.row,
                                        column: insertPosition.column
                                    }
                                };
                                if (textLines.length > 1) {
                                    this.$ghostTextWidget = {
                                        text: textLines.slice(1).join("\n"),
                                        row: insertPosition.row,
                                        column: insertPosition.column,
                                        className: "ace_ghost_text"
                                    };
                                    this.session.widgetManager.addLineWidget(this.$ghostTextWidget);
                                }
                            }
                        },
                        {
                            key: "removeGhostText",
                            value: function removeGhostText() {
                                if (!this.$ghostText) return;
                                var position = this.$ghostText.position;
                                this.removeExtraToken(position.row, position.column);
                                if (this.$ghostTextWidget) {
                                    this.session.widgetManager.removeLineWidget(this.$ghostTextWidget);
                                    this.$ghostTextWidget = null;
                                }
                                this.$ghostText = null;
                            }
                        },
                        {
                            key: "addToken",
                            value: function addToken(text, type, row, column) {
                                var session = this.session;
                                session.bgTokenizer.lines[row] = null;
                                var newToken = {
                                    type: type,
                                    value: text
                                };
                                var tokens = session.getTokens(row);
                                if (column == null || !tokens.length) {
                                    tokens.push(newToken);
                                } else {
                                    var l = 0;
                                    for(var i = 0; i < tokens.length; i++){
                                        var token = tokens[i];
                                        l += token.value.length;
                                        if (column <= l) {
                                            var diff = token.value.length - (l - column);
                                            var before = token.value.slice(0, diff);
                                            var after = token.value.slice(diff);
                                            tokens.splice(i, 1, {
                                                type: token.type,
                                                value: before
                                            }, newToken, {
                                                type: token.type,
                                                value: after
                                            });
                                            break;
                                        }
                                    }
                                }
                                this.updateLines(row, row);
                            }
                        },
                        {
                            key: "removeExtraToken",
                            value: function removeExtraToken(row, column) {
                                this.session.bgTokenizer.lines[row] = null;
                                this.updateLines(row, row);
                            }
                        },
                        {
                            /**
     * [Sets a new theme for the editor. `theme` should exist, and be a directory path, like `ace/theme/textmate`.]{: #VirtualRenderer.setTheme}
     * @param {String} [theme] The path to a theme
     * @param {Function} [cb] optional callback
     *
     **/ key: "setTheme",
                            value: function setTheme(theme, cb) {
                                var afterLoad = function afterLoad(module1) {
                                    if (_self.$themeId != theme) return cb && cb();
                                    if (!module1 || !module1.cssClass) throw new Error("couldn't load module " + theme + " or it didn't call define");
                                    if (module1.$id) _self.$themeId = module1.$id;
                                    dom.importCssString(module1.cssText, module1.cssClass, _self.container);
                                    if (_self.theme) dom.removeCssClass(_self.container, _self.theme.cssClass);
                                    var padding = "padding" in module1 ? module1.padding : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
                                    if (_self.$padding && padding != _self.$padding) _self.setPadding(padding);
                                    // this is kept only for backwards compatibility
                                    _self.$theme = module1.cssClass;
                                    _self.theme = module1;
                                    dom.addCssClass(_self.container, module1.cssClass);
                                    dom.setCssClass(_self.container, "ace_dark", module1.isDark);
                                    // force re-measure of the gutter width
                                    if (_self.$size) {
                                        _self.$size.width = 0;
                                        _self.$updateSizeAsync();
                                    }
                                    _self._dispatchEvent("themeLoaded", {
                                        theme: module1
                                    });
                                    cb && cb();
                                };
                                var _self = this;
                                this.$themeId = theme;
                                _self._dispatchEvent("themeChange", {
                                    theme: theme
                                });
                                if (!theme || typeof theme == "string") {
                                    var moduleName = theme || this.$options.theme.initialValue;
                                    config.loadModule([
                                        "theme",
                                        moduleName
                                    ], afterLoad);
                                } else {
                                    afterLoad(theme);
                                }
                            }
                        },
                        {
                            /**
     * [Returns the path of the current theme.]{: #VirtualRenderer.getTheme}
     * @returns {String}
     **/ key: "getTheme",
                            value: function getTheme() {
                                return this.$themeId;
                            }
                        },
                        {
                            // Methods allows to add / remove CSS classnames to the editor element.
                            // This feature can be used by plug-ins to provide a visual indication of
                            // a certain mode that editor is in.
                            /**
     * [Adds a new class, `style`, to the editor.]{: #VirtualRenderer.setStyle}
     * @param {String} style A class name
     *
     **/ key: "setStyle",
                            value: function setStyle(style, include) {
                                dom.setCssClass(this.container, style, include !== false);
                            }
                        },
                        {
                            /**
     * [Removes the class `style` from the editor.]{: #VirtualRenderer.unsetStyle}
     * @param {String} style A class name
     *
     **/ key: "unsetStyle",
                            value: function unsetStyle(style) {
                                dom.removeCssClass(this.container, style);
                            }
                        },
                        {
                            key: "setCursorStyle",
                            value: function setCursorStyle(style) {
                                dom.setStyle(this.scroller.style, "cursor", style);
                            }
                        },
                        {
                            /**
     * @param {String} cursorStyle A css cursor style
     *
     **/ key: "setMouseCursor",
                            value: function setMouseCursor(cursorStyle) {
                                dom.setStyle(this.scroller.style, "cursor", cursorStyle);
                            }
                        },
                        {
                            key: "attachToShadowRoot",
                            value: function attachToShadowRoot() {
                                dom.importCssString(editorCss, "ace_editor.css", this.container);
                            }
                        },
                        {
                            /**
     * Destroys the text and cursor layers for this renderer.
     **/ key: "destroy",
                            value: function destroy() {
                                this.freeze();
                                this.$fontMetrics.destroy();
                                this.$cursorLayer.destroy();
                                this.removeAllListeners();
                                this.container.textContent = "";
                                this.setOption("useResizeObserver", false);
                            }
                        },
                        {
                            key: "$updateCustomScrollbar",
                            value: function $updateCustomScrollbar(val) {
                                var _self = this;
                                this.$horizScroll = this.$vScroll = null;
                                this.scrollBarV.element.remove();
                                this.scrollBarH.element.remove();
                                if (this.$scrollDecorator) {
                                    delete this.$scrollDecorator;
                                }
                                if (val === true) {
                                    this.scrollBarV = new VScrollBarCustom(this.container, this);
                                    this.scrollBarH = new HScrollBarCustom(this.container, this);
                                    this.scrollBarV.setHeight(this.$size.scrollerHeight);
                                    this.scrollBarH.setWidth(this.$size.scrollerWidth);
                                    this.scrollBarV.addEventListener("scroll", function(e) {
                                        if (!_self.$scrollAnimation) _self.session.setScrollTop(e.data - _self.scrollMargin.top);
                                    });
                                    this.scrollBarH.addEventListener("scroll", function(e) {
                                        if (!_self.$scrollAnimation) _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
                                    });
                                    this.$scrollDecorator = new Decorator(this.scrollBarV, this);
                                    this.$scrollDecorator.$updateDecorators();
                                } else {
                                    this.scrollBarV = new VScrollBar(this.container, this);
                                    this.scrollBarH = new HScrollBar(this.container, this);
                                    this.scrollBarV.addEventListener("scroll", function(e) {
                                        if (!_self.$scrollAnimation) _self.session.setScrollTop(e.data - _self.scrollMargin.top);
                                    });
                                    this.scrollBarH.addEventListener("scroll", function(e) {
                                        if (!_self.$scrollAnimation) _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
                                    });
                                }
                            }
                        },
                        {
                            key: "$addResizeObserver",
                            value: function $addResizeObserver() {
                                if (!window.ResizeObserver || this.$resizeObserver) return;
                                var _$self = this;
                                this.$resizeTimer = lang.delayedCall(function() {
                                    if (!_$self.destroyed) _$self.onResize();
                                }, 50);
                                this.$resizeObserver = new window.ResizeObserver(function(e) {
                                    var w = e[0].contentRect.width;
                                    var h = e[0].contentRect.height;
                                    if (Math.abs(_$self.$size.width - w) > 1 || Math.abs(_$self.$size.height - h) > 1) {
                                        _$self.$resizeTimer.delay();
                                    } else {
                                        _$self.$resizeTimer.cancel();
                                    }
                                });
                                this.$resizeObserver.observe(this.container);
                            }
                        }
                    ]);
                    return VirtualRenderer;
                }();
                VirtualRenderer.prototype.CHANGE_CURSOR = 1;
                VirtualRenderer.prototype.CHANGE_MARKER = 2;
                VirtualRenderer.prototype.CHANGE_GUTTER = 4;
                VirtualRenderer.prototype.CHANGE_SCROLL = 8;
                VirtualRenderer.prototype.CHANGE_LINES = 16;
                VirtualRenderer.prototype.CHANGE_TEXT = 32;
                VirtualRenderer.prototype.CHANGE_SIZE = 64;
                VirtualRenderer.prototype.CHANGE_MARKER_BACK = 128;
                VirtualRenderer.prototype.CHANGE_MARKER_FRONT = 256;
                VirtualRenderer.prototype.CHANGE_FULL = 512;
                VirtualRenderer.prototype.CHANGE_H_SCROLL = 1024;
                VirtualRenderer.prototype.$changes = 0;
                VirtualRenderer.prototype.$padding = null;
                VirtualRenderer.prototype.$frozen = false;
                VirtualRenderer.prototype.STEPS = 8;
                oop.implement(VirtualRenderer.prototype, EventEmitter);
                config.defineOptions(VirtualRenderer.prototype, "renderer", {
                    useResizeObserver: {
                        set: function set(value) {
                            if (!value && this.$resizeObserver) {
                                this.$resizeObserver.disconnect();
                                this.$resizeTimer.cancel();
                                this.$resizeTimer = this.$resizeObserver = null;
                            } else if (value && !this.$resizeObserver) {
                                this.$addResizeObserver();
                            }
                        }
                    },
                    animatedScroll: {
                        initialValue: false
                    },
                    showInvisibles: {
                        set: function set(value) {
                            if (this.$textLayer.setShowInvisibles(value)) this.$loop.schedule(this.CHANGE_TEXT);
                        },
                        initialValue: false
                    },
                    showPrintMargin: {
                        set: function set() {
                            this.$updatePrintMargin();
                        },
                        initialValue: true
                    },
                    printMarginColumn: {
                        set: function set() {
                            this.$updatePrintMargin();
                        },
                        initialValue: 80
                    },
                    printMargin: {
                        set: function set(val) {
                            if (typeof val == "number") this.$printMarginColumn = val;
                            this.$showPrintMargin = !!val;
                            this.$updatePrintMargin();
                        },
                        get: function get() {
                            return this.$showPrintMargin && this.$printMarginColumn;
                        }
                    },
                    showGutter: {
                        set: function set(show) {
                            this.$gutter.style.display = show ? "block" : "none";
                            this.$loop.schedule(this.CHANGE_FULL);
                            this.onGutterResize();
                        },
                        initialValue: true
                    },
                    useSvgGutterIcons: {
                        set: function set(value) {
                            this.$gutterLayer.$useSvgGutterIcons = value;
                        },
                        initialValue: false
                    },
                    fadeFoldWidgets: {
                        set: function set(show) {
                            dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
                        },
                        initialValue: false
                    },
                    showFoldWidgets: {
                        set: function set(show) {
                            this.$gutterLayer.setShowFoldWidgets(show);
                            this.$loop.schedule(this.CHANGE_GUTTER);
                        },
                        initialValue: true
                    },
                    displayIndentGuides: {
                        set: function set(show) {
                            if (this.$textLayer.setDisplayIndentGuides(show)) this.$loop.schedule(this.CHANGE_TEXT);
                        },
                        initialValue: true
                    },
                    highlightIndentGuides: {
                        set: function set(show) {
                            if (this.$textLayer.setHighlightIndentGuides(show) == true) {
                                this.$textLayer.$highlightIndentGuide();
                            } else {
                                this.$textLayer.$clearActiveIndentGuide(this.$textLayer.$lines.cells);
                            }
                        },
                        initialValue: true
                    },
                    highlightGutterLine: {
                        set: function set(shouldHighlight) {
                            this.$gutterLayer.setHighlightGutterLine(shouldHighlight);
                            this.$loop.schedule(this.CHANGE_GUTTER);
                        },
                        initialValue: true
                    },
                    hScrollBarAlwaysVisible: {
                        set: function set(val) {
                            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll) this.$loop.schedule(this.CHANGE_SCROLL);
                        },
                        initialValue: false
                    },
                    vScrollBarAlwaysVisible: {
                        set: function set(val) {
                            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll) this.$loop.schedule(this.CHANGE_SCROLL);
                        },
                        initialValue: false
                    },
                    fontSize: {
                        set: function set(size) {
                            if (typeof size == "number") size = size + "px";
                            this.container.style.fontSize = size;
                            this.updateFontSize();
                        },
                        initialValue: 12
                    },
                    fontFamily: {
                        set: function set(name) {
                            this.container.style.fontFamily = name;
                            this.updateFontSize();
                        }
                    },
                    maxLines: {
                        set: function set(val) {
                            this.updateFull();
                        }
                    },
                    minLines: {
                        set: function set(val) {
                            if (!(this.$minLines < 0x1ffffffffffff)) this.$minLines = 0;
                            this.updateFull();
                        }
                    },
                    maxPixelHeight: {
                        set: function set(val) {
                            this.updateFull();
                        },
                        initialValue: 0
                    },
                    scrollPastEnd: {
                        set: function set(val) {
                            val = +val || 0;
                            if (this.$scrollPastEnd == val) return;
                            this.$scrollPastEnd = val;
                            this.$loop.schedule(this.CHANGE_SCROLL);
                        },
                        initialValue: 0,
                        handlesSet: true
                    },
                    fixedWidthGutter: {
                        set: function set(val) {
                            this.$gutterLayer.$fixedWidth = !!val;
                            this.$loop.schedule(this.CHANGE_GUTTER);
                        }
                    },
                    customScrollbar: {
                        set: function set(val) {
                            this.$updateCustomScrollbar(val);
                        },
                        initialValue: false
                    },
                    theme: {
                        set: function set(val) {
                            this.setTheme(val);
                        },
                        get: function get() {
                            return this.$themeId || this.theme;
                        },
                        initialValue: "./theme/textmate",
                        handlesSet: true
                    },
                    hasCssTransforms: {},
                    useTextareaForIME: {
                        initialValue: !useragent.isMobile && !useragent.isIE
                    }
                });
                exports1._ = VirtualRenderer;
            /***/ },
            /***/ 1583: /***/ function(__unused_webpack_module, exports1) {
                // not implemented
                exports1.WorkerClient = function() {
                    this.attachToDocument = function() {};
                    this.on = function() {};
                    this.terminate = function() {};
                };
            /***/ },
            /***/ 5267: /***/ function(module1) {
                var webpackEmptyContext = function webpackEmptyContext(req) {
                    var e = new Error("Cannot find module '" + req + "'");
                    e.code = "MODULE_NOT_FOUND";
                    throw e;
                };
                webpackEmptyContext.keys = function() {
                    return [];
                };
                webpackEmptyContext.resolve = webpackEmptyContext;
                webpackEmptyContext.id = 5267;
                module1.exports = webpackEmptyContext;
            /***/ },
            /***/ 1696: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_1377063__) {
                "use strict";
                var _classCallCheck = function _classCallCheck(instance, Constructor) {
                    if (!_instanceof(instance, Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                };
                var lazyLoadComparison = function lazyLoadComparison() {
                    var comparison = __nested_webpack_require_1377063__(6796);
                    isDeepEqual = comparison.isDeepEqual;
                    isDeepStrictEqual = comparison.isDeepStrictEqual;
                } // Escape control characters but not \n and \t to keep the line breaks and
                ;
                var innerFail = // when a corresponding condition is not met, with a message that
                // may be undefined if not provided. All assertion methods provide
                // both the actual and expected values to the assertion error for
                // display purposes.
                function innerFail(obj) {
                    if (_instanceof(obj.message, Error)) throw obj.message;
                    throw new AssertionError(obj);
                };
                var innerOk = function innerOk(fn, argLen, value, message) {
                    if (!value) {
                        var generatedMessage = false;
                        if (argLen === 0) {
                            generatedMessage = true;
                            message = "No value argument passed to `assert.ok()`";
                        } else if (_instanceof(message, Error)) {
                            throw message;
                        }
                        var err = new AssertionError({
                            actual: value,
                            expected: true,
                            message: message,
                            operator: "==",
                            stackStartFn: fn
                        });
                        err.generatedMessage = generatedMessage;
                        throw err;
                    }
                } // Pure assertion tests whether a value is truthy, as determined
                ;
                var compareExceptionKey = function compareExceptionKey(actual, expected, key, message, keys, fn) {
                    if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
                        if (!message) {
                            // Create placeholder objects to create a nice output.
                            var a = new Comparison(actual, keys);
                            var b = new Comparison(expected, keys, actual);
                            var err = new AssertionError({
                                actual: a,
                                expected: b,
                                operator: "deepStrictEqual",
                                stackStartFn: fn
                            });
                            err.actual = actual;
                            err.expected = expected;
                            err.operator = fn.name;
                            throw err;
                        }
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: fn.name,
                            stackStartFn: fn
                        });
                    }
                };
                var expectedException = function expectedException(actual, expected, msg, fn) {
                    if (typeof expected !== "function") {
                        if (isRegExp(expected)) return expected.test(actual); // assert.doesNotThrow does not accept objects.
                        if (arguments.length === 2) {
                            throw new ERR_INVALID_ARG_TYPE("expected", [
                                "Function",
                                "RegExp"
                            ], expected);
                        } // Handle primitives properly.
                        if (_typeof(actual) !== "object" || actual === null) {
                            var err = new AssertionError({
                                actual: actual,
                                expected: expected,
                                message: msg,
                                operator: "deepStrictEqual",
                                stackStartFn: fn
                            });
                            err.operator = fn.name;
                            throw err;
                        }
                        var keys = Object.keys(expected); // Special handle errors to make sure the name and the message are compared
                        // as well.
                        if (_instanceof(expected, Error)) {
                            keys.push("name", "message");
                        } else if (keys.length === 0) {
                            throw new ERR_INVALID_ARG_VALUE("error", expected, "may not be an empty object");
                        }
                        if (isDeepEqual === undefined) lazyLoadComparison();
                        keys.forEach(function(key) {
                            if (typeof actual[key] === "string" && isRegExp(expected[key]) && expected[key].test(actual[key])) {
                                return;
                            }
                            compareExceptionKey(actual, expected, key, msg, keys, fn);
                        });
                        return true;
                    } // Guard instanceof against arrow functions as they don't have a prototype.
                    if (expected.prototype !== undefined && _instanceof(actual, expected)) {
                        return true;
                    }
                    if (Error.isPrototypeOf(expected)) {
                        return false;
                    }
                    return expected.call({}, actual) === true;
                };
                var getActual = function getActual(fn) {
                    if (typeof fn !== "function") {
                        throw new ERR_INVALID_ARG_TYPE("fn", "Function", fn);
                    }
                    try {
                        fn();
                    } catch (e) {
                        return e;
                    }
                    return NO_EXCEPTION_SENTINEL;
                };
                var checkIsPromise = function checkIsPromise(obj) {
                    // Accept native ES6 promises and promises that are implemented in a similar
                    // way. Do not accept thenables that use a function as `obj` and that have no
                    // `catch` handler.
                    // TODO: thenables are checked up until they have the correct methods,
                    // but according to documentation, the `then` method should receive
                    // the `fulfill` and `reject` arguments as well or it may be never resolved.
                    return isPromise(obj) || obj !== null && _typeof(obj) === "object" && typeof obj.then === "function" && typeof obj.catch === "function";
                };
                var waitForActual = function waitForActual(promiseFn) {
                    return Promise.resolve().then(function() {
                        var resultPromise;
                        if (typeof promiseFn === "function") {
                            // Return a rejected promise if `promiseFn` throws synchronously.
                            resultPromise = promiseFn(); // Fail in case no promise is returned.
                            if (!checkIsPromise(resultPromise)) {
                                throw new ERR_INVALID_RETURN_VALUE("instance of Promise", "promiseFn", resultPromise);
                            }
                        } else if (checkIsPromise(promiseFn)) {
                            resultPromise = promiseFn;
                        } else {
                            throw new ERR_INVALID_ARG_TYPE("promiseFn", [
                                "Function",
                                "Promise"
                            ], promiseFn);
                        }
                        return Promise.resolve().then(function() {
                            return resultPromise;
                        }).then(function() {
                            return NO_EXCEPTION_SENTINEL;
                        }).catch(function(e) {
                            return e;
                        });
                    });
                };
                var expectsError = function expectsError(stackStartFn, actual, error, message) {
                    if (typeof error === "string") {
                        if (arguments.length === 4) {
                            throw new ERR_INVALID_ARG_TYPE("error", [
                                "Object",
                                "Error",
                                "Function",
                                "RegExp"
                            ], error);
                        }
                        if (_typeof(actual) === "object" && actual !== null) {
                            if (actual.message === error) {
                                throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error message "'.concat(actual.message, '" is identical to the message.'));
                            }
                        } else if (actual === error) {
                            throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error "'.concat(actual, '" is identical to the message.'));
                        }
                        message = error;
                        error = undefined;
                    } else if (error != null && _typeof(error) !== "object" && typeof error !== "function") {
                        throw new ERR_INVALID_ARG_TYPE("error", [
                            "Object",
                            "Error",
                            "Function",
                            "RegExp"
                        ], error);
                    }
                    if (actual === NO_EXCEPTION_SENTINEL) {
                        var details = "";
                        if (error && error.name) {
                            details += " (".concat(error.name, ")");
                        }
                        details += message ? ": ".concat(message) : ".";
                        var fnType = stackStartFn.name === "rejects" ? "rejection" : "exception";
                        innerFail({
                            actual: undefined,
                            expected: error,
                            operator: stackStartFn.name,
                            message: "Missing expected ".concat(fnType).concat(details),
                            stackStartFn: stackStartFn
                        });
                    }
                    if (error && !expectedException(actual, error, message, stackStartFn)) {
                        throw actual;
                    }
                };
                var expectsNoError = function expectsNoError(stackStartFn, actual, error, message) {
                    if (actual === NO_EXCEPTION_SENTINEL) return;
                    if (typeof error === "string") {
                        message = error;
                        error = undefined;
                    }
                    if (!error || expectedException(actual, error)) {
                        var details = message ? ": ".concat(message) : ".";
                        var fnType = stackStartFn.name === "doesNotReject" ? "rejection" : "exception";
                        innerFail({
                            actual: actual,
                            expected: error,
                            operator: stackStartFn.name,
                            message: "Got unwanted ".concat(fnType).concat(details, "\n") + 'Actual message: "'.concat(actual && actual.message, '"'),
                            stackStartFn: stackStartFn
                        });
                    }
                    throw actual;
                };
                /* provided dependency */ var process = __nested_webpack_require_1377063__(4406);
                /* provided dependency */ var console = __nested_webpack_require_1377063__(3716);
                // Currently in sync with Node.js lib/assert.js
                // https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b
                // Originally from narwhal.js (http://narwhaljs.org)
                // Copyright (c) 2009 Thomas Robinson <280north.com>
                //
                // Permission is hereby granted, free of charge, to any person obtaining a copy
                // of this software and associated documentation files (the 'Software'), to
                // deal in the Software without restriction, including without limitation the
                // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
                // sell copies of the Software, and to permit persons to whom the Software is
                // furnished to do so, subject to the following conditions:
                //
                // The above copyright notice and this permission notice shall be included in
                // all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                // AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
                // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                function _typeof(obj) {
                    if (typeof Symbol === "function" && _type_of(Symbol.iterator) === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj === "undefined" ? "undefined" : _type_of(obj);
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _type_of(obj);
                        };
                    }
                    return _typeof(obj);
                }
                var _require = __nested_webpack_require_1377063__(7515), _require$codes = _require.codes, ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE, ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
                var AssertionError = __nested_webpack_require_1377063__(4082);
                var _require2 = __nested_webpack_require_1377063__(3335), inspect = _require2.inspect;
                var _require$types = __nested_webpack_require_1377063__(3335).types, isPromise = _require$types.isPromise, isRegExp = _require$types.isRegExp;
                var objectAssign = Object.assign ? Object.assign : __nested_webpack_require_1377063__(4956).assign;
                var objectIs = Object.is ? Object.is : __nested_webpack_require_1377063__(4679);
                var errorCache = new Map();
                var isDeepEqual;
                var isDeepStrictEqual;
                var parseExpressionAt;
                var findNodeAround;
                var decoder;
                // indentation intact.
                // eslint-disable-next-line no-control-regex
                var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
                var meta = /* unused pure expression or super */ null && 0;
                var escapeFn = function escapeFn(str) {
                    return meta[str.charCodeAt(0)];
                };
                var warned = false; // The assert module provides functions that throw
                // AssertionError's when particular conditions are not met. The
                // assert module must conform to the following interface.
                var assert = module1.exports = ok;
                var NO_EXCEPTION_SENTINEL = {}; // All of the following functions must throw an AssertionError
                function fail(actual, expected, message, operator, stackStartFn) {
                    var argsLen = arguments.length;
                    var internalMessage;
                    if (argsLen === 0) {
                        internalMessage = "Failed";
                    } else if (argsLen === 1) {
                        message = actual;
                        actual = undefined;
                    } else {
                        if (warned === false) {
                            warned = true;
                            var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
                            warn("assert.fail() with more than one argument is deprecated. " + "Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
                        }
                        if (argsLen === 2) operator = "!=";
                    }
                    if (_instanceof(message, Error)) throw message;
                    var errArgs = {
                        actual: actual,
                        expected: expected,
                        operator: operator === undefined ? "fail" : operator,
                        stackStartFn: stackStartFn || fail
                    };
                    if (message !== undefined) {
                        errArgs.message = message;
                    }
                    var err = new AssertionError(errArgs);
                    if (internalMessage) {
                        err.message = internalMessage;
                        err.generatedMessage = true;
                    }
                    throw err;
                }
                assert.fail = fail; // The AssertionError is defined in internal/error.
                assert.AssertionError = AssertionError;
                // by !!value.
                function ok() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    innerOk.apply(void 0, [
                        ok,
                        args.length
                    ].concat(args));
                }
                assert.ok = ok; // The equality assertion tests shallow, coercive equality with ==.
                /* eslint-disable no-restricted-properties */ assert.equal = function equal(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS("actual", "expected");
                    } // eslint-disable-next-line eqeqeq
                    if (actual != expected) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: "==",
                            stackStartFn: equal
                        });
                    }
                }; // The non-equality assertion tests for whether two objects are not
                // equal with !=.
                assert.notEqual = function notEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS("actual", "expected");
                    } // eslint-disable-next-line eqeqeq
                    if (actual == expected) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: "!=",
                            stackStartFn: notEqual
                        });
                    }
                }; // The equivalence assertion tests a deep equality relation.
                assert.deepEqual = function deepEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS("actual", "expected");
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (!isDeepEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: "deepEqual",
                            stackStartFn: deepEqual
                        });
                    }
                }; // The non-equivalence assertion tests for any deep inequality.
                assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS("actual", "expected");
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (isDeepEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: "notDeepEqual",
                            stackStartFn: notDeepEqual
                        });
                    }
                };
                /* eslint-enable */ assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS("actual", "expected");
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (!isDeepStrictEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: "deepStrictEqual",
                            stackStartFn: deepStrictEqual
                        });
                    }
                };
                assert.notDeepStrictEqual = notDeepStrictEqual;
                function notDeepStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS("actual", "expected");
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (isDeepStrictEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: "notDeepStrictEqual",
                            stackStartFn: notDeepStrictEqual
                        });
                    }
                }
                assert.strictEqual = function strictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS("actual", "expected");
                    }
                    if (!objectIs(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: "strictEqual",
                            stackStartFn: strictEqual
                        });
                    }
                };
                assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS("actual", "expected");
                    }
                    if (objectIs(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: "notStrictEqual",
                            stackStartFn: notStrictEqual
                        });
                    }
                };
                var Comparison = function Comparison(obj, keys, actual) {
                    var _this = this;
                    _classCallCheck(this, Comparison);
                    keys.forEach(function(key) {
                        if (key in obj) {
                            if (actual !== undefined && typeof actual[key] === "string" && isRegExp(obj[key]) && obj[key].test(actual[key])) {
                                _this[key] = actual[key];
                            } else {
                                _this[key] = obj[key];
                            }
                        }
                    });
                };
                assert.throws = function throws(promiseFn) {
                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                        args[_key2 - 1] = arguments[_key2];
                    }
                    expectsError.apply(void 0, [
                        throws,
                        getActual(promiseFn)
                    ].concat(args));
                };
                assert.rejects = function rejects(promiseFn) {
                    for(var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++){
                        args[_key3 - 1] = arguments[_key3];
                    }
                    return waitForActual(promiseFn).then(function(result) {
                        return expectsError.apply(void 0, [
                            rejects,
                            result
                        ].concat(args));
                    });
                };
                assert.doesNotThrow = function doesNotThrow(fn) {
                    for(var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++){
                        args[_key4 - 1] = arguments[_key4];
                    }
                    expectsNoError.apply(void 0, [
                        doesNotThrow,
                        getActual(fn)
                    ].concat(args));
                };
                assert.doesNotReject = function doesNotReject(fn) {
                    for(var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++){
                        args[_key5 - 1] = arguments[_key5];
                    }
                    return waitForActual(fn).then(function(result) {
                        return expectsNoError.apply(void 0, [
                            doesNotReject,
                            result
                        ].concat(args));
                    });
                };
                assert.ifError = function ifError(err) {
                    if (err !== null && err !== undefined) {
                        var message = "ifError got unwanted exception: ";
                        if (_typeof(err) === "object" && typeof err.message === "string") {
                            if (err.message.length === 0 && err.constructor) {
                                message += err.constructor.name;
                            } else {
                                message += err.message;
                            }
                        } else {
                            message += inspect(err);
                        }
                        var newErr = new AssertionError({
                            actual: err,
                            expected: null,
                            operator: "ifError",
                            message: message,
                            stackStartFn: ifError
                        }); // Make sure we actually have a stack trace!
                        var origStack = err.stack;
                        if (typeof origStack === "string") {
                            // This will remove any duplicated frames from the error frames taken
                            // from within `ifError` and add the original error frames to the newly
                            // created ones.
                            var tmp2 = origStack.split("\n");
                            tmp2.shift(); // Filter all frames existing in err.stack.
                            var tmp1 = newErr.stack.split("\n");
                            for(var i = 0; i < tmp2.length; i++){
                                // Find the first occurrence of the frame.
                                var pos = tmp1.indexOf(tmp2[i]);
                                if (pos !== -1) {
                                    // Only keep new frames.
                                    tmp1 = tmp1.slice(0, pos);
                                    break;
                                }
                            }
                            newErr.stack = "".concat(tmp1.join("\n"), "\n").concat(tmp2.join("\n"));
                        }
                        throw newErr;
                    }
                }; // Expose a strict only variant of assert
                function strict() {
                    for(var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++){
                        args[_key6] = arguments[_key6];
                    }
                    innerOk.apply(void 0, [
                        strict,
                        args.length
                    ].concat(args));
                }
                assert.strict = objectAssign(strict, assert, {
                    equal: assert.strictEqual,
                    deepEqual: assert.deepStrictEqual,
                    notEqual: assert.notStrictEqual,
                    notDeepEqual: assert.notDeepStrictEqual
                });
                assert.strict.strict = assert.strict;
            /***/ },
            /***/ 4082: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_1408662__) {
                "use strict";
                var _objectSpread = // Currently in sync with Node.js lib/internal/assert/assertion_error.js
                // https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c
                function _objectSpread(target) {
                    for(var i = 1; i < arguments.length; i++){
                        var source = arguments[i] != null ? arguments[i] : {};
                        var ownKeys = Object.keys(source);
                        if (typeof Object.getOwnPropertySymbols === "function") {
                            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                            }));
                        }
                        ownKeys.forEach(function(key) {
                            _defineProperty(target, key, source[key]);
                        });
                    }
                    return target;
                };
                var _defineProperty = function _defineProperty(obj, key, value) {
                    if (key in obj) {
                        Object.defineProperty(obj, key, {
                            value: value,
                            enumerable: true,
                            configurable: true,
                            writable: true
                        });
                    } else {
                        obj[key] = value;
                    }
                    return obj;
                };
                var _classCallCheck = function _classCallCheck(instance, Constructor) {
                    if (!_instanceof(instance, Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                };
                var _defineProperties = function _defineProperties(target, props) {
                    for(var i = 0; i < props.length; i++){
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                };
                var _createClass = function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    return Constructor;
                };
                var _possibleConstructorReturn = function _possibleConstructorReturn(self1, call) {
                    if (call && (_typeof(call) === "object" || typeof call === "function")) {
                        return call;
                    }
                    return _assertThisInitialized(self1);
                };
                var _assertThisInitialized = function _assertThisInitialized(self1) {
                    if (self1 === void 0) {
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    }
                    return self1;
                };
                var _inherits = function _inherits(subClass, superClass) {
                    if (typeof superClass !== "function" && superClass !== null) {
                        throw new TypeError("Super expression must either be null or a function");
                    }
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            writable: true,
                            configurable: true
                        }
                    });
                    if (superClass) _setPrototypeOf(subClass, superClass);
                };
                var isNativeReflectConstruct = function isNativeReflectConstruct() {
                    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if (typeof Proxy === "function") return true;
                    try {
                        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
                        return true;
                    } catch (e) {
                        return false;
                    }
                };
                var _isNativeFunction = function _isNativeFunction(fn) {
                    return Function.toString.call(fn).indexOf("[native code]") !== -1;
                };
                var endsWith = function endsWith(str, search, this_len) {
                    if (this_len === undefined || this_len > str.length) {
                        this_len = str.length;
                    }
                    return str.substring(this_len - search.length, this_len) === search;
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
                ;
                var repeat = function repeat(str, count) {
                    count = Math.floor(count);
                    if (str.length == 0 || count == 0) return "";
                    var maxCount = str.length * count;
                    count = Math.floor(Math.log(count) / Math.log(2));
                    while(count){
                        str += str;
                        count--;
                    }
                    str += str.substring(0, maxCount - str.length);
                    return str;
                };
                var copyError = function copyError(source) {
                    var keys = Object.keys(source);
                    var target = Object.create(Object.getPrototypeOf(source));
                    keys.forEach(function(key) {
                        target[key] = source[key];
                    });
                    Object.defineProperty(target, "message", {
                        value: source.message
                    });
                    return target;
                };
                var inspectValue = function inspectValue(val) {
                    // The util.inspect default values could be changed. This makes sure the
                    // error messages contain the necessary information nevertheless.
                    return inspect(val, {
                        compact: false,
                        customInspect: false,
                        depth: 1000,
                        maxArrayLength: Infinity,
                        // Assert compares only enumerable properties (with a few exceptions).
                        showHidden: false,
                        // Having a long line as error is better than wrapping the line for
                        // comparison for now.
                        // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
                        // have meta information about the inspected properties (i.e., know where
                        // in what line the property starts and ends).
                        breakLength: Infinity,
                        // Assert does not detect proxies currently.
                        showProxy: false,
                        sorted: true,
                        // Inspect getters as we also check them when comparing entries.
                        getters: true
                    });
                };
                var createErrDiff = function createErrDiff(actual, expected, operator) {
                    var other = "";
                    var res = "";
                    var lastPos = 0;
                    var end = "";
                    var skipped = false;
                    var actualInspected = inspectValue(actual);
                    var actualLines = actualInspected.split("\n");
                    var expectedLines = inspectValue(expected).split("\n");
                    var i = 0;
                    var indicator = ""; // In case both values are objects explicitly mark them as not reference equal
                    // for the `strictEqual` operator.
                    if (operator === "strictEqual" && _typeof(actual) === "object" && _typeof(expected) === "object" && actual !== null && expected !== null) {
                        operator = "strictEqualObject";
                    } // If "actual" and "expected" fit on a single line and they are not strictly
                    // equal, check further special handling.
                    if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
                        var inputLength = actualLines[0].length + expectedLines[0].length; // If the character length of "actual" and "expected" together is less than
                        // kMaxShortLength and if neither is an object and at least one of them is
                        // not `zero`, use the strict equal comparison to visualize the output.
                        if (inputLength <= kMaxShortLength) {
                            if ((_typeof(actual) !== "object" || actual === null) && (_typeof(expected) !== "object" || expected === null) && (actual !== 0 || expected !== 0)) {
                                // -0 === +0
                                return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
                            }
                        } else if (operator !== "strictEqualObject") {
                            // If the stderr is a tty and the input length is lower than the current
                            // columns per line, add a mismatch indicator below the output. If it is
                            // not a tty, use a default value of 80 characters.
                            var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
                            if (inputLength < maxLength) {
                                while(actualLines[0][i] === expectedLines[0][i]){
                                    i++;
                                } // Ignore the first characters.
                                if (i > 2) {
                                    // Add position indicator for the first mismatch in case it is a
                                    // single line and the input length is less than the column length.
                                    indicator = "\n  ".concat(repeat(" ", i), "^");
                                    i = 0;
                                }
                            }
                        }
                    } // Remove all ending lines that match (this optimizes the output for
                    // readability by reducing the number of total changed lines).
                    var a = actualLines[actualLines.length - 1];
                    var b = expectedLines[expectedLines.length - 1];
                    while(a === b){
                        if (i++ < 2) {
                            end = "\n  ".concat(a).concat(end);
                        } else {
                            other = a;
                        }
                        actualLines.pop();
                        expectedLines.pop();
                        if (actualLines.length === 0 || expectedLines.length === 0) break;
                        a = actualLines[actualLines.length - 1];
                        b = expectedLines[expectedLines.length - 1];
                    }
                    var maxLines = Math.max(actualLines.length, expectedLines.length); // Strict equal with identical objects that are not identical by reference.
                    // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })
                    if (maxLines === 0) {
                        // We have to get the result again. The lines were all removed before.
                        var _actualLines = actualInspected.split("\n"); // Only remove lines in case it makes sense to collapse those.
                        // TODO: Accept env to always show the full error.
                        if (_actualLines.length > 30) {
                            _actualLines[26] = "".concat(blue, "...").concat(white);
                            while(_actualLines.length > 27){
                                _actualLines.pop();
                            }
                        }
                        return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join("\n"), "\n");
                    }
                    if (i > 3) {
                        end = "\n".concat(blue, "...").concat(white).concat(end);
                        skipped = true;
                    }
                    if (other !== "") {
                        end = "\n  ".concat(other).concat(end);
                        other = "";
                    }
                    var printedLines = 0;
                    var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
                    var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
                    for(i = 0; i < maxLines; i++){
                        // Only extra expected lines exist
                        var cur = i - lastPos;
                        if (actualLines.length < i + 1) {
                            // If the last diverging line is more than one line above and the
                            // current line is at least line three, add some of the former lines and
                            // also add dots to indicate skipped entries.
                            if (cur > 1 && i > 2) {
                                if (cur > 4) {
                                    res += "\n".concat(blue, "...").concat(white);
                                    skipped = true;
                                } else if (cur > 3) {
                                    res += "\n  ".concat(expectedLines[i - 2]);
                                    printedLines++;
                                }
                                res += "\n  ".concat(expectedLines[i - 1]);
                                printedLines++;
                            } // Mark the current line as the last diverging one.
                            lastPos = i; // Add the expected line to the cache.
                            other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
                            printedLines++; // Only extra actual lines exist
                        } else if (expectedLines.length < i + 1) {
                            // If the last diverging line is more than one line above and the
                            // current line is at least line three, add some of the former lines and
                            // also add dots to indicate skipped entries.
                            if (cur > 1 && i > 2) {
                                if (cur > 4) {
                                    res += "\n".concat(blue, "...").concat(white);
                                    skipped = true;
                                } else if (cur > 3) {
                                    res += "\n  ".concat(actualLines[i - 2]);
                                    printedLines++;
                                }
                                res += "\n  ".concat(actualLines[i - 1]);
                                printedLines++;
                            } // Mark the current line as the last diverging one.
                            lastPos = i; // Add the actual line to the result.
                            res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
                            printedLines++; // Lines diverge
                        } else {
                            var expectedLine = expectedLines[i];
                            var actualLine = actualLines[i]; // If the lines diverge, specifically check for lines that only diverge by
                            // a trailing comma. In that case it is actually identical and we should
                            // mark it as such.
                            var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ",") || actualLine.slice(0, -1) !== expectedLine); // If the expected line has a trailing comma but is otherwise identical,
                            // add a comma at the end of the actual line. Otherwise the output could
                            // look weird as in:
                            //
                            //   [
                            //     1         // No comma at the end!
                            // +   2
                            //   ]
                            //
                            if (divergingLines && endsWith(expectedLine, ",") && expectedLine.slice(0, -1) === actualLine) {
                                divergingLines = false;
                                actualLine += ",";
                            }
                            if (divergingLines) {
                                // If the last diverging line is more than one line above and the
                                // current line is at least line three, add some of the former lines and
                                // also add dots to indicate skipped entries.
                                if (cur > 1 && i > 2) {
                                    if (cur > 4) {
                                        res += "\n".concat(blue, "...").concat(white);
                                        skipped = true;
                                    } else if (cur > 3) {
                                        res += "\n  ".concat(actualLines[i - 2]);
                                        printedLines++;
                                    }
                                    res += "\n  ".concat(actualLines[i - 1]);
                                    printedLines++;
                                } // Mark the current line as the last diverging one.
                                lastPos = i; // Add the actual line to the result and cache the expected diverging
                                // line so consecutive diverging lines show up as +++--- and not +-+-+-.
                                res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
                                other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
                                printedLines += 2; // Lines are identical
                            } else {
                                // Add all cached information to the result before adding other things
                                // and reset the cache.
                                res += other;
                                other = ""; // If the last diverging line is exactly one line above or if it is the
                                // very first line, add the line to the result.
                                if (cur === 1 || i === 0) {
                                    res += "\n  ".concat(actualLine);
                                    printedLines++;
                                }
                            }
                        } // Inspected object to big (Show ~20 rows max)
                        if (printedLines > 20 && i < maxLines - 2) {
                            return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
                        }
                    }
                    return "".concat(msg).concat(skipped ? skippedMsg : "", "\n").concat(res).concat(other).concat(end).concat(indicator);
                };
                /* provided dependency */ var process = __nested_webpack_require_1408662__(4406);
                function _wrapNativeSuper(Class) {
                    var _cache = typeof Map === "function" ? new Map() : undefined;
                    _wrapNativeSuper = function _wrapNativeSuper(Class) {
                        if (Class === null || !_isNativeFunction(Class)) return Class;
                        if (typeof Class !== "function") {
                            throw new TypeError("Super expression must either be null or a function");
                        }
                        if (typeof _cache !== "undefined") {
                            if (_cache.has(Class)) return _cache.get(Class);
                            _cache.set(Class, Wrapper);
                        }
                        function Wrapper() {
                            return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                        }
                        Wrapper.prototype = Object.create(Class.prototype, {
                            constructor: {
                                value: Wrapper,
                                enumerable: false,
                                writable: true,
                                configurable: true
                            }
                        });
                        return _setPrototypeOf(Wrapper, Class);
                    };
                    return _wrapNativeSuper(Class);
                }
                function _construct(Parent, args, Class) {
                    if (isNativeReflectConstruct()) {
                        _construct = Reflect.construct;
                    } else {
                        _construct = function _construct(Parent, args, Class) {
                            var a = [
                                null
                            ];
                            a.push.apply(a, args);
                            var Constructor = Function.bind.apply(Parent, a);
                            var instance = new Constructor();
                            if (Class) _setPrototypeOf(instance, Class.prototype);
                            return instance;
                        };
                    }
                    return _construct.apply(null, arguments);
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                        o.__proto__ = p;
                        return o;
                    };
                    return _setPrototypeOf(o, p);
                }
                function _getPrototypeOf(o) {
                    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                        return o.__proto__ || Object.getPrototypeOf(o);
                    };
                    return _getPrototypeOf(o);
                }
                function _typeof(obj) {
                    if (typeof Symbol === "function" && _type_of(Symbol.iterator) === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj === "undefined" ? "undefined" : _type_of(obj);
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _type_of(obj);
                        };
                    }
                    return _typeof(obj);
                }
                var _require = __nested_webpack_require_1408662__(3335), inspect = _require.inspect;
                var _require2 = __nested_webpack_require_1408662__(7515), ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
                var blue = "";
                var green = "";
                var red = "";
                var white = "";
                var kReadableOperator = {
                    deepStrictEqual: "Expected values to be strictly deep-equal:",
                    strictEqual: "Expected values to be strictly equal:",
                    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
                    deepEqual: "Expected values to be loosely deep-equal:",
                    equal: "Expected values to be loosely equal:",
                    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
                    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
                    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
                    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
                    notEqual: 'Expected "actual" to be loosely unequal to:',
                    notIdentical: "Values identical but not reference-equal:"
                }; // Comparing short primitives should just show === / !== instead of using the
                // diff.
                var kMaxShortLength = 10;
                var AssertionError = /*#__PURE__*/ function(_Error) {
                    _inherits(AssertionError, _Error);
                    function AssertionError(options) {
                        var _this;
                        _classCallCheck(this, AssertionError);
                        if (_typeof(options) !== "object" || options === null) {
                            throw new ERR_INVALID_ARG_TYPE("options", "Object", options);
                        }
                        var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
                        var actual = options.actual, expected = options.expected;
                        var limit = Error.stackTraceLimit;
                        Error.stackTraceLimit = 0;
                        if (message != null) {
                            _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, String(message)));
                        } else {
                            if (process.stderr && process.stderr.isTTY) {
                                // Reset on each call to make sure we handle dynamically set environment
                                // variables correct.
                                if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
                                    blue = "\x1b[34m";
                                    green = "\x1b[32m";
                                    white = "\x1b[39m";
                                    red = "\x1b[31m";
                                } else {
                                    blue = "";
                                    green = "";
                                    white = "";
                                    red = "";
                                }
                            } // Prevent the error stack from being visible by duplicating the error
                            // in a very close way to the original in case both sides are actually
                            // instances of Error.
                            if (_typeof(actual) === "object" && actual !== null && _typeof(expected) === "object" && expected !== null && "stack" in actual && _instanceof(actual, Error) && "stack" in expected && _instanceof(expected, Error)) {
                                actual = copyError(actual);
                                expected = copyError(expected);
                            }
                            if (operator === "deepStrictEqual" || operator === "strictEqual") {
                                _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, createErrDiff(actual, expected, operator)));
                            } else if (operator === "notDeepStrictEqual" || operator === "notStrictEqual") {
                                // In case the objects are equal but the operator requires unequal, show
                                // the first object and say A equals B
                                var base = kReadableOperator[operator];
                                var res = inspectValue(actual).split("\n"); // In case "actual" is an object, it should not be reference equal.
                                if (operator === "notStrictEqual" && _typeof(actual) === "object" && actual !== null) {
                                    base = kReadableOperator.notStrictEqualObject;
                                } // Only remove lines in case it makes sense to collapse those.
                                // TODO: Accept env to always show the full error.
                                if (res.length > 30) {
                                    res[26] = "".concat(blue, "...").concat(white);
                                    while(res.length > 27){
                                        res.pop();
                                    }
                                } // Only print a single input.
                                if (res.length === 1) {
                                    _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, " ").concat(res[0])));
                                } else {
                                    _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, "\n\n").concat(res.join("\n"), "\n")));
                                }
                            } else {
                                var _res = inspectValue(actual);
                                var other = "";
                                var knownOperators = kReadableOperator[operator];
                                if (operator === "notDeepEqual" || operator === "notEqual") {
                                    _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
                                    if (_res.length > 1024) {
                                        _res = "".concat(_res.slice(0, 1021), "...");
                                    }
                                } else {
                                    other = "".concat(inspectValue(expected));
                                    if (_res.length > 512) {
                                        _res = "".concat(_res.slice(0, 509), "...");
                                    }
                                    if (other.length > 512) {
                                        other = "".concat(other.slice(0, 509), "...");
                                    }
                                    if (operator === "deepEqual" || operator === "equal") {
                                        _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
                                    } else {
                                        other = " ".concat(operator, " ").concat(other);
                                    }
                                }
                                _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(_res).concat(other)));
                            }
                        }
                        Error.stackTraceLimit = limit;
                        _this.generatedMessage = !message;
                        Object.defineProperty(_assertThisInitialized(_this), "name", {
                            value: "AssertionError [ERR_ASSERTION]",
                            enumerable: false,
                            writable: true,
                            configurable: true
                        });
                        _this.code = "ERR_ASSERTION";
                        _this.actual = actual;
                        _this.expected = expected;
                        _this.operator = operator;
                        if (Error.captureStackTrace) {
                            // eslint-disable-next-line no-restricted-syntax
                            Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
                        } // Create error message including the error code in the name.
                        _this.stack; // Reset the name.
                        _this.name = "AssertionError";
                        return _possibleConstructorReturn(_this);
                    }
                    _createClass(AssertionError, [
                        {
                            key: "toString",
                            value: function toString() {
                                return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
                            }
                        },
                        {
                            key: inspect.custom,
                            value: function value(recurseTimes, ctx) {
                                // This limits the `actual` and `expected` property default inspection to
                                // the minimum depth. Otherwise those values would be too verbose compared
                                // to the actual error message which contains a combined view of these two
                                // input values.
                                return inspect(this, _objectSpread({}, ctx, {
                                    customInspect: false,
                                    depth: 0
                                }));
                            }
                        }
                    ]);
                    return AssertionError;
                }(_wrapNativeSuper(Error));
                module1.exports = AssertionError;
            /***/ },
            /***/ 7515: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_1442720__) {
                "use strict";
                var _classCallCheck = function _classCallCheck(instance, Constructor) {
                    if (!_instanceof(instance, Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                };
                var _possibleConstructorReturn = function _possibleConstructorReturn(self1, call) {
                    if (call && (_typeof(call) === "object" || typeof call === "function")) {
                        return call;
                    }
                    return _assertThisInitialized(self1);
                };
                var _assertThisInitialized = function _assertThisInitialized(self1) {
                    if (self1 === void 0) {
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    }
                    return self1;
                };
                var _inherits = function _inherits(subClass, superClass) {
                    if (typeof superClass !== "function" && superClass !== null) {
                        throw new TypeError("Super expression must either be null or a function");
                    }
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            writable: true,
                            configurable: true
                        }
                    });
                    if (superClass) _setPrototypeOf(subClass, superClass);
                };
                var createErrorType = function createErrorType(code, message, Base) {
                    if (!Base) {
                        Base = Error;
                    }
                    function getMessage(arg1, arg2, arg3) {
                        if (typeof message === "string") {
                            return message;
                        } else {
                            return message(arg1, arg2, arg3);
                        }
                    }
                    var NodeError = /*#__PURE__*/ function(_Base) {
                        _inherits(NodeError, _Base);
                        function NodeError(arg1, arg2, arg3) {
                            var _this;
                            _classCallCheck(this, NodeError);
                            _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError).call(this, getMessage(arg1, arg2, arg3)));
                            _this.code = code;
                            return _this;
                        }
                        return NodeError;
                    }(Base);
                    codes[code] = NodeError;
                } // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
                ;
                var oneOf = function oneOf(expected, thing) {
                    if (Array.isArray(expected)) {
                        var len = expected.length;
                        expected = expected.map(function(i) {
                            return String(i);
                        });
                        if (len > 2) {
                            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
                        } else if (len === 2) {
                            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
                        } else {
                            return "of ".concat(thing, " ").concat(expected[0]);
                        }
                    } else {
                        return "of ".concat(thing, " ").concat(String(expected));
                    }
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
                ;
                var startsWith = function startsWith(str, search, pos) {
                    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
                ;
                var endsWith = function endsWith(str, search, this_len) {
                    if (this_len === undefined || this_len > str.length) {
                        this_len = str.length;
                    }
                    return str.substring(this_len - search.length, this_len) === search;
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
                ;
                var includes = function includes(str, search, start) {
                    if (typeof start !== "number") {
                        start = 0;
                    }
                    if (start + search.length > str.length) {
                        return false;
                    } else {
                        return str.indexOf(search, start) !== -1;
                    }
                };
                // Currently in sync with Node.js lib/internal/errors.js
                // https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f
                /* eslint node-core/documented-errors: "error" */ /* eslint node-core/alphabetize-errors: "error" */ /* eslint node-core/prefer-util-format-errors: "error" */ // The whole point behind this internal module is to allow Node.js to no
                // longer be forced to treat every error message change as a semver-major
                // change. The NodeError classes here all expose a `code` property whose
                // value statically and permanently identifies the error. While the error
                // message may change, the code should not.
                function _typeof(obj) {
                    if (typeof Symbol === "function" && _type_of(Symbol.iterator) === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj === "undefined" ? "undefined" : _type_of(obj);
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _type_of(obj);
                        };
                    }
                    return _typeof(obj);
                }
                function _getPrototypeOf(o) {
                    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                        return o.__proto__ || Object.getPrototypeOf(o);
                    };
                    return _getPrototypeOf(o);
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                        o.__proto__ = p;
                        return o;
                    };
                    return _setPrototypeOf(o, p);
                }
                var codes = {}; // Lazy loaded
                var assert;
                var util;
                createErrorType("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError);
                createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
                    if (assert === undefined) assert = __nested_webpack_require_1442720__(1696);
                    assert(typeof name === "string", "'name' must be a string"); // determiner: 'must be' or 'must not be'
                    var determiner;
                    if (typeof expected === "string" && startsWith(expected, "not ")) {
                        determiner = "must not be";
                        expected = expected.replace(/^not /, "");
                    } else {
                        determiner = "must be";
                    }
                    var msg;
                    if (endsWith(name, " argument")) {
                        // For cases like 'first argument'
                        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
                    } else {
                        var type = includes(name, ".") ? "property" : "argument";
                        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
                    } // TODO(BridgeAR): Improve the output by showing `null` and similar.
                    msg += ". Received type ".concat(_typeof(actual));
                    return msg;
                }, TypeError);
                createErrorType("ERR_INVALID_ARG_VALUE", function(name, value) {
                    var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "is invalid";
                    if (util === undefined) util = __nested_webpack_require_1442720__(3335);
                    var inspected = util.inspect(value);
                    if (inspected.length > 128) {
                        inspected = "".concat(inspected.slice(0, 128), "...");
                    }
                    return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
                }, TypeError, RangeError);
                createErrorType("ERR_INVALID_RETURN_VALUE", function(input, name, value) {
                    var type;
                    if (value && value.constructor && value.constructor.name) {
                        type = "instance of ".concat(value.constructor.name);
                    } else {
                        type = "type ".concat(_typeof(value));
                    }
                    return "Expected ".concat(input, ' to be returned from the "').concat(name, '"') + " function but got ".concat(type, ".");
                }, TypeError);
                createErrorType("ERR_MISSING_ARGS", function() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    if (assert === undefined) assert = __nested_webpack_require_1442720__(1696);
                    assert(args.length > 0, "At least one arg needs to be specified");
                    var msg = "The ";
                    var len = args.length;
                    args = args.map(function(a) {
                        return '"'.concat(a, '"');
                    });
                    switch(len){
                        case 1:
                            msg += "".concat(args[0], " argument");
                            break;
                        case 2:
                            msg += "".concat(args[0], " and ").concat(args[1], " arguments");
                            break;
                        default:
                            msg += args.slice(0, len - 1).join(", ");
                            msg += ", and ".concat(args[len - 1], " arguments");
                            break;
                    }
                    return "".concat(msg, " must be specified");
                }, TypeError);
                module1.exports.codes = codes;
            /***/ },
            /***/ 6796: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_1454141__) {
                "use strict";
                var _slicedToArray = // Currently in sync with Node.js lib/internal/util/comparisons.js
                // https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
                function _slicedToArray(arr, i) {
                    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
                };
                var _nonIterableRest = function _nonIterableRest() {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                };
                var _iterableToArrayLimit = function _iterableToArrayLimit(arr, i) {
                    var _arr = [];
                    var _n = true;
                    var _d = false;
                    var _e = undefined;
                    try {
                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){
                            _arr.push(_s.value);
                            if (i && _arr.length === i) break;
                        }
                    } catch (err) {
                        _d = true;
                        _e = err;
                    } finally{
                        try {
                            if (!_n && _i["return"] != null) _i["return"]();
                        } finally{
                            if (_d) throw _e;
                        }
                    }
                    return _arr;
                };
                var _arrayWithHoles = function _arrayWithHoles(arr) {
                    if (Array.isArray(arr)) return arr;
                };
                var uncurryThis = function uncurryThis(f) {
                    return f.call.bind(f);
                };
                var isNonIndex = function isNonIndex(key) {
                    if (key.length === 0 || key.length > 10) return true;
                    for(var i = 0; i < key.length; i++){
                        var code = key.charCodeAt(i);
                        if (code < 48 || code > 57) return true;
                    } // The maximum size for an array is 2 ** 32 -1.
                    return key.length === 10 && key >= Math.pow(2, 32);
                };
                var getOwnNonIndexProperties = function getOwnNonIndexProperties(value) {
                    return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
                } // Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
                ;
                var compare = // original notice:
                /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */ function compare(a, b) {
                    if (a === b) {
                        return 0;
                    }
                    var x = a.length;
                    var y = b.length;
                    for(var i = 0, len = Math.min(x, y); i < len; ++i){
                        if (a[i] !== b[i]) {
                            x = a[i];
                            y = b[i];
                            break;
                        }
                    }
                    if (x < y) {
                        return -1;
                    }
                    if (y < x) {
                        return 1;
                    }
                    return 0;
                };
                var areSimilarRegExps = function areSimilarRegExps(a, b) {
                    return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
                };
                var areSimilarFloatArrays = function areSimilarFloatArrays(a, b) {
                    if (a.byteLength !== b.byteLength) {
                        return false;
                    }
                    for(var offset = 0; offset < a.byteLength; offset++){
                        if (a[offset] !== b[offset]) {
                            return false;
                        }
                    }
                    return true;
                };
                var areSimilarTypedArrays = function areSimilarTypedArrays(a, b) {
                    if (a.byteLength !== b.byteLength) {
                        return false;
                    }
                    return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
                };
                var areEqualArrayBuffers = function areEqualArrayBuffers(buf1, buf2) {
                    return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
                };
                var isEqualBoxedPrimitive = function isEqualBoxedPrimitive(val1, val2) {
                    if (isNumberObject(val1)) {
                        return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
                    }
                    if (isStringObject(val1)) {
                        return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
                    }
                    if (isBooleanObject(val1)) {
                        return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
                    }
                    if (isBigIntObject(val1)) {
                        return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
                    }
                    return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
                } // Notes: Type tags are historical [[Class]] properties that can be set by
                ;
                var innerDeepEqual = // FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
                // and retrieved using Object.prototype.toString.call(obj) in JS
                // See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
                // for a list of tags pre-defined in the spec.
                // There are some unspecified tags in the wild too (e.g. typed array tags).
                // Since tags can be altered, they only serve fast failures
                //
                // Typed arrays and buffers are checked by comparing the content in their
                // underlying ArrayBuffer. This optimization requires that it's
                // reasonable to interpret their underlying memory in the same way,
                // which is checked by comparing their type tags.
                // (e.g. a Uint8Array and a Uint16Array with the same memory content
                // could still be different because they will be interpreted differently).
                //
                // For strict comparison, objects should have
                // a) The same built-in type tags
                // b) The same prototypes.
                function innerDeepEqual(val1, val2, strict, memos) {
                    // All identical values are equivalent, as determined by ===.
                    if (val1 === val2) {
                        if (val1 !== 0) return true;
                        return strict ? objectIs(val1, val2) : true;
                    } // Check more closely if val1 and val2 are equal.
                    if (strict) {
                        if (_typeof(val1) !== "object") {
                            return typeof val1 === "number" && numberIsNaN(val1) && numberIsNaN(val2);
                        }
                        if (_typeof(val2) !== "object" || val1 === null || val2 === null) {
                            return false;
                        }
                        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
                            return false;
                        }
                    } else {
                        if (val1 === null || _typeof(val1) !== "object") {
                            if (val2 === null || _typeof(val2) !== "object") {
                                // eslint-disable-next-line eqeqeq
                                return val1 == val2;
                            }
                            return false;
                        }
                        if (val2 === null || _typeof(val2) !== "object") {
                            return false;
                        }
                    }
                    var val1Tag = objectToString(val1);
                    var val2Tag = objectToString(val2);
                    if (val1Tag !== val2Tag) {
                        return false;
                    }
                    if (Array.isArray(val1)) {
                        // Check for sparse arrays and general fast path
                        if (val1.length !== val2.length) {
                            return false;
                        }
                        var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
                        var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
                        if (keys1.length !== keys2.length) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
                    } // [browserify] This triggers on certain types in IE (Map/Set) so we don't
                    // wan't to early return out of the rest of the checks. However we can check
                    // if the second value is one of these values and the first isn't.
                    if (val1Tag === "[object Object]") {
                        // return keyCheck(val1, val2, strict, memos, kNoIterator);
                        if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
                            return false;
                        }
                    }
                    if (isDate(val1)) {
                        if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
                            return false;
                        }
                    } else if (isRegExp(val1)) {
                        if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
                            return false;
                        }
                    } else if (isNativeError(val1) || _instanceof(val1, Error)) {
                        // Do not compare the stack as it might differ even though the error itself
                        // is otherwise identical.
                        if (val1.message !== val2.message || val1.name !== val2.name) {
                            return false;
                        }
                    } else if (isArrayBufferView(val1)) {
                        if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
                            if (!areSimilarFloatArrays(val1, val2)) {
                                return false;
                            }
                        } else if (!areSimilarTypedArrays(val1, val2)) {
                            return false;
                        } // Buffer.compare returns true, so val1.length === val2.length. If they both
                        // only contain numeric keys, we don't need to exam further than checking
                        // the symbols.
                        var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
                        var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
                        if (_keys.length !== _keys2.length) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
                    } else if (isSet(val1)) {
                        if (!isSet(val2) || val1.size !== val2.size) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kIsSet);
                    } else if (isMap(val1)) {
                        if (!isMap(val2) || val1.size !== val2.size) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kIsMap);
                    } else if (isAnyArrayBuffer(val1)) {
                        if (!areEqualArrayBuffers(val1, val2)) {
                            return false;
                        }
                    } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
                        return false;
                    }
                    return keyCheck(val1, val2, strict, memos, kNoIterator);
                };
                var getEnumerables = function getEnumerables(val, keys) {
                    return keys.filter(function(k) {
                        return propertyIsEnumerable(val, k);
                    });
                };
                var keyCheck = function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
                    // For all remaining Object pairs, including Array, objects and Maps,
                    // equivalence is determined by having:
                    // a) The same number of owned enumerable properties
                    // b) The same set of keys/indexes (although not necessarily the same order)
                    // c) Equivalent values for every corresponding key/index
                    // d) For Sets and Maps, equal contents
                    // Note: this accounts for both named and indexed properties on Arrays.
                    if (arguments.length === 5) {
                        aKeys = Object.keys(val1);
                        var bKeys = Object.keys(val2); // The pair must have the same number of owned properties.
                        if (aKeys.length !== bKeys.length) {
                            return false;
                        }
                    } // Cheap key test
                    var i = 0;
                    for(; i < aKeys.length; i++){
                        if (!hasOwnProperty(val2, aKeys[i])) {
                            return false;
                        }
                    }
                    if (strict && arguments.length === 5) {
                        var symbolKeysA = objectGetOwnPropertySymbols(val1);
                        if (symbolKeysA.length !== 0) {
                            var count = 0;
                            for(i = 0; i < symbolKeysA.length; i++){
                                var key = symbolKeysA[i];
                                if (propertyIsEnumerable(val1, key)) {
                                    if (!propertyIsEnumerable(val2, key)) {
                                        return false;
                                    }
                                    aKeys.push(key);
                                    count++;
                                } else if (propertyIsEnumerable(val2, key)) {
                                    return false;
                                }
                            }
                            var symbolKeysB = objectGetOwnPropertySymbols(val2);
                            if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
                                return false;
                            }
                        } else {
                            var _symbolKeysB = objectGetOwnPropertySymbols(val2);
                            if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
                                return false;
                            }
                        }
                    }
                    if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
                        return true;
                    } // Use memos to handle cycles.
                    if (memos === undefined) {
                        memos = {
                            val1: new Map(),
                            val2: new Map(),
                            position: 0
                        };
                    } else {
                        // We prevent up to two map.has(x) calls by directly retrieving the value
                        // and checking for undefined. The map can only contain numbers, so it is
                        // safe to check for undefined only.
                        var val2MemoA = memos.val1.get(val1);
                        if (val2MemoA !== undefined) {
                            var val2MemoB = memos.val2.get(val2);
                            if (val2MemoB !== undefined) {
                                return val2MemoA === val2MemoB;
                            }
                        }
                        memos.position++;
                    }
                    memos.val1.set(val1, memos.position);
                    memos.val2.set(val2, memos.position);
                    var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
                    memos.val1.delete(val1);
                    memos.val2.delete(val2);
                    return areEq;
                };
                var setHasEqualElement = function setHasEqualElement(set, val1, strict, memo) {
                    // Go looking.
                    var setValues = arrayFromSet(set);
                    for(var i = 0; i < setValues.length; i++){
                        var val2 = setValues[i];
                        if (innerDeepEqual(val1, val2, strict, memo)) {
                            // Remove the matching element to make sure we do not check that again.
                            set.delete(val2);
                            return true;
                        }
                    }
                    return false;
                } // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
                ;
                var findLooseMatchingPrimitives = // Sadly it is not possible to detect corresponding values properly in case the
                // type is a string, number, bigint or boolean. The reason is that those values
                // can match lots of different string values (e.g., 1n == '+00001').
                function findLooseMatchingPrimitives(prim) {
                    switch(_typeof(prim)){
                        case "undefined":
                            return null;
                        case "object":
                            // Only pass in null as object!
                            return undefined;
                        case "symbol":
                            return false;
                        case "string":
                            prim = +prim;
                        // Loose equal entries exist only if the string is possible to convert to
                        // a regular number and not NaN.
                        // Fall through
                        case "number":
                            if (numberIsNaN(prim)) {
                                return false;
                            }
                    }
                    return true;
                };
                var setMightHaveLoosePrim = function setMightHaveLoosePrim(a, b, prim) {
                    var altValue = findLooseMatchingPrimitives(prim);
                    if (altValue != null) return altValue;
                    return b.has(altValue) && !a.has(altValue);
                };
                var mapMightHaveLoosePrim = function mapMightHaveLoosePrim(a, b, prim, item, memo) {
                    var altValue = findLooseMatchingPrimitives(prim);
                    if (altValue != null) {
                        return altValue;
                    }
                    var curB = b.get(altValue);
                    if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
                        return false;
                    }
                    return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
                };
                var setEquiv = function setEquiv(a, b, strict, memo) {
                    // This is a lazily initiated Set of entries which have to be compared
                    // pairwise.
                    var set = null;
                    var aValues = arrayFromSet(a);
                    for(var i = 0; i < aValues.length; i++){
                        var val = aValues[i]; // Note: Checking for the objects first improves the performance for object
                        // heavy sets but it is a minor slow down for primitives. As they are fast
                        // to check this improves the worst case scenario instead.
                        if (_typeof(val) === "object" && val !== null) {
                            if (set === null) {
                                set = new Set();
                            } // If the specified value doesn't exist in the second set its an not null
                            // object (or non strict only: a not matching primitive) we'll need to go
                            // hunting for something thats deep-(strict-)equal to it. To make this
                            // O(n log n) complexity we have to copy these values in a new set first.
                            set.add(val);
                        } else if (!b.has(val)) {
                            if (strict) return false; // Fast path to detect missing string, symbol, undefined and null values.
                            if (!setMightHaveLoosePrim(a, b, val)) {
                                return false;
                            }
                            if (set === null) {
                                set = new Set();
                            }
                            set.add(val);
                        }
                    }
                    if (set !== null) {
                        var bValues = arrayFromSet(b);
                        for(var _i = 0; _i < bValues.length; _i++){
                            var _val = bValues[_i]; // We have to check if a primitive value is already
                            // matching and only if it's not, go hunting for it.
                            if (_typeof(_val) === "object" && _val !== null) {
                                if (!setHasEqualElement(set, _val, strict, memo)) return false;
                            } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
                                return false;
                            }
                        }
                        return set.size === 0;
                    }
                    return true;
                };
                var mapHasEqualEntry = function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
                    // To be able to handle cases like:
                    //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
                    // ... we need to consider *all* matching keys, not just the first we find.
                    var setValues = arrayFromSet(set);
                    for(var i = 0; i < setValues.length; i++){
                        var key2 = setValues[i];
                        if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
                            set.delete(key2);
                            return true;
                        }
                    }
                    return false;
                };
                var mapEquiv = function mapEquiv(a, b, strict, memo) {
                    var set = null;
                    var aEntries = arrayFromMap(a);
                    for(var i = 0; i < aEntries.length; i++){
                        var _aEntries$i = _slicedToArray(aEntries[i], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
                        if (_typeof(key) === "object" && key !== null) {
                            if (set === null) {
                                set = new Set();
                            }
                            set.add(key);
                        } else {
                            // By directly retrieving the value we prevent another b.has(key) check in
                            // almost all possible cases.
                            var item2 = b.get(key);
                            if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
                                if (strict) return false; // Fast path to detect missing string, symbol, undefined and null
                                // keys.
                                if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;
                                if (set === null) {
                                    set = new Set();
                                }
                                set.add(key);
                            }
                        }
                    }
                    if (set !== null) {
                        var bEntries = arrayFromMap(b);
                        for(var _i2 = 0; _i2 < bEntries.length; _i2++){
                            var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), key = _bEntries$_i[0], item = _bEntries$_i[1];
                            if (_typeof(key) === "object" && key !== null) {
                                if (!mapHasEqualEntry(set, a, key, item, strict, memo)) return false;
                            } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) {
                                return false;
                            }
                        }
                        return set.size === 0;
                    }
                    return true;
                };
                var objEquiv = function objEquiv(a, b, strict, keys, memos, iterationType) {
                    // Sets and maps don't have their entries accessible via normal object
                    // properties.
                    var i = 0;
                    if (iterationType === kIsSet) {
                        if (!setEquiv(a, b, strict, memos)) {
                            return false;
                        }
                    } else if (iterationType === kIsMap) {
                        if (!mapEquiv(a, b, strict, memos)) {
                            return false;
                        }
                    } else if (iterationType === kIsArray) {
                        for(; i < a.length; i++){
                            if (hasOwnProperty(a, i)) {
                                if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
                                    return false;
                                }
                            } else if (hasOwnProperty(b, i)) {
                                return false;
                            } else {
                                // Array is sparse.
                                var keysA = Object.keys(a);
                                for(; i < keysA.length; i++){
                                    var key = keysA[i];
                                    if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
                                        return false;
                                    }
                                }
                                if (keysA.length !== Object.keys(b).length) {
                                    return false;
                                }
                                return true;
                            }
                        }
                    } // The pair must have equivalent values for every corresponding key.
                    // Possibly expensive deep test:
                    for(i = 0; i < keys.length; i++){
                        var _key = keys[i];
                        if (!innerDeepEqual(a[_key], b[_key], strict, memos)) {
                            return false;
                        }
                    }
                    return true;
                };
                var isDeepEqual = function isDeepEqual(val1, val2) {
                    return innerDeepEqual(val1, val2, kLoose);
                };
                var isDeepStrictEqual = function isDeepStrictEqual(val1, val2) {
                    return innerDeepEqual(val1, val2, kStrict);
                };
                function _typeof(obj) {
                    if (typeof Symbol === "function" && _type_of(Symbol.iterator) === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj === "undefined" ? "undefined" : _type_of(obj);
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _type_of(obj);
                        };
                    }
                    return _typeof(obj);
                }
                var regexFlagsSupported = /a/g.flags !== undefined;
                var arrayFromSet = function arrayFromSet(set) {
                    var array = [];
                    set.forEach(function(value) {
                        return array.push(value);
                    });
                    return array;
                };
                var arrayFromMap = function arrayFromMap(map) {
                    var array = [];
                    map.forEach(function(value, key) {
                        return array.push([
                            key,
                            value
                        ]);
                    });
                    return array;
                };
                var objectIs = Object.is ? Object.is : __nested_webpack_require_1454141__(4679);
                var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function objectGetOwnPropertySymbols() {
                    return [];
                };
                var numberIsNaN = Number.isNaN ? Number.isNaN : __nested_webpack_require_1454141__(4782);
                var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
                var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
                var objectToString = uncurryThis(Object.prototype.toString);
                var _require$types = __nested_webpack_require_1454141__(3335).types, isAnyArrayBuffer = _require$types.isAnyArrayBuffer, isArrayBufferView = _require$types.isArrayBufferView, isDate = _require$types.isDate, isMap = _require$types.isMap, isRegExp = _require$types.isRegExp, isSet = _require$types.isSet, isNativeError = _require$types.isNativeError, isBoxedPrimitive = _require$types.isBoxedPrimitive, isNumberObject = _require$types.isNumberObject, isStringObject = _require$types.isStringObject, isBooleanObject = _require$types.isBooleanObject, isBigIntObject = _require$types.isBigIntObject, isSymbolObject = _require$types.isSymbolObject, isFloat32Array = _require$types.isFloat32Array, isFloat64Array = _require$types.isFloat64Array;
                var ONLY_ENUMERABLE = undefined;
                var kStrict = true;
                var kLoose = false;
                var kNoIterator = 0;
                var kIsArray = 1;
                var kIsSet = 2;
                var kIsMap = 3; // Check if they have the same source and flags
                module1.exports = {
                    isDeepEqual: isDeepEqual,
                    isDeepStrictEqual: isDeepStrictEqual
                };
            /***/ },
            /***/ 2680: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_1486496__) {
                "use strict";
                var GetIntrinsic = __nested_webpack_require_1486496__(7286);
                var callBind = __nested_webpack_require_1486496__(9429);
                var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
                module1.exports = function callBoundIntrinsic(name, allowMissing) {
                    var intrinsic = GetIntrinsic(name, !!allowMissing);
                    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
                        return callBind(intrinsic);
                    }
                    return intrinsic;
                };
            /***/ },
            /***/ 9429: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_1487231__) {
                "use strict";
                var bind = __nested_webpack_require_1487231__(4090);
                var GetIntrinsic = __nested_webpack_require_1487231__(7286);
                var $apply = GetIntrinsic("%Function.prototype.apply%");
                var $call = GetIntrinsic("%Function.prototype.call%");
                var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
                var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
                var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
                var $max = GetIntrinsic("%Math.max%");
                if ($defineProperty) {
                    try {
                        $defineProperty({}, "a", {
                            value: 1
                        });
                    } catch (e) {
                        // IE 8 has a broken defineProperty
                        $defineProperty = null;
                    }
                }
                module1.exports = function callBind(originalFunction) {
                    var func = $reflectApply(bind, $call, arguments);
                    if ($gOPD && $defineProperty) {
                        var desc = $gOPD(func, "length");
                        if (desc.configurable) {
                            // original length, plus the receiver, minus any additional arguments (after the receiver)
                            $defineProperty(func, "length", {
                                value: 1 + $max(0, originalFunction.length - (arguments.length - 1))
                            });
                        }
                    }
                    return func;
                };
                var applyBind = function applyBind() {
                    return $reflectApply(bind, $apply, arguments);
                };
                if ($defineProperty) {
                    $defineProperty(module1.exports, "apply", {
                        value: applyBind
                    });
                } else {
                    module1.exports.apply = applyBind;
                }
            /***/ },
            /***/ 3716: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_1489452__) {
                var now = function now() {
                    return new Date().getTime();
                };
                var log = function log() {};
                var info = function info() {
                    console.log.apply(console, arguments);
                };
                var warn = function warn() {
                    console.log.apply(console, arguments);
                };
                var error = function error() {
                    console.warn.apply(console, arguments);
                };
                var time = function time(label) {
                    times[label] = now();
                };
                var timeEnd = function timeEnd(label) {
                    var time = times[label];
                    if (!time) {
                        throw new Error("No such label: " + label);
                    }
                    delete times[label];
                    var duration = now() - time;
                    console.log(label + ": " + duration + "ms");
                };
                var trace = function trace() {
                    var err = new Error();
                    err.name = "Trace";
                    err.message = util.format.apply(null, arguments);
                    console.error(err.stack);
                };
                var dir = function dir(object) {
                    console.log(util.inspect(object) + "\n");
                };
                var consoleAssert = function consoleAssert(expression) {
                    if (!expression) {
                        var arr = slice.call(arguments, 1);
                        assert.ok(false, util.format.apply(null, arr));
                    }
                };
                /*global window, global*/ var util = __nested_webpack_require_1489452__(3335);
                var assert = __nested_webpack_require_1489452__(1696);
                var slice = Array.prototype.slice;
                var console;
                var times = {};
                if (typeof __nested_webpack_require_1489452__.g !== "undefined" && __nested_webpack_require_1489452__.g.console) {
                    console = __nested_webpack_require_1489452__.g.console;
                } else if (typeof window !== "undefined" && window.console) {
                    console = window.console;
                } else {
                    console = {};
                }
                var functions = [
                    [
                        log,
                        "log"
                    ],
                    [
                        info,
                        "info"
                    ],
                    [
                        warn,
                        "warn"
                    ],
                    [
                        error,
                        "error"
                    ],
                    [
                        time,
                        "time"
                    ],
                    [
                        timeEnd,
                        "timeEnd"
                    ],
                    [
                        trace,
                        "trace"
                    ],
                    [
                        dir,
                        "dir"
                    ],
                    [
                        consoleAssert,
                        "assert"
                    ]
                ];
                for(var i = 0; i < functions.length; i++){
                    var tuple = functions[i];
                    var f = tuple[0];
                    var name = tuple[1];
                    if (!console[name]) {
                        console[name] = f;
                    }
                }
                module1.exports = console;
            /***/ },
            /***/ 4926: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_1493273__) {
                "use strict";
                var keys = __nested_webpack_require_1493273__(3464);
                var hasSymbols = typeof Symbol === "function" && _type_of(Symbol("foo")) === "symbol";
                var toStr = Object.prototype.toString;
                var concat = Array.prototype.concat;
                var origDefineProperty = Object.defineProperty;
                var isFunction = function isFunction(fn) {
                    return typeof fn === "function" && toStr.call(fn) === "[object Function]";
                };
                var hasPropertyDescriptors = __nested_webpack_require_1493273__(1181)();
                var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;
                var defineProperty = function defineProperty(object, name, value, predicate) {
                    if (name in object) {
                        if (predicate === true) {
                            if (object[name] === value) {
                                return;
                            }
                        } else if (!isFunction(predicate) || !predicate()) {
                            return;
                        }
                    }
                    if (supportsDescriptors) {
                        origDefineProperty(object, name, {
                            configurable: true,
                            enumerable: false,
                            value: value,
                            writable: true
                        });
                    } else {
                        object[name] = value; // eslint-disable-line no-param-reassign
                    }
                };
                var defineProperties = function defineProperties(object, map) {
                    var predicates = arguments.length > 2 ? arguments[2] : {};
                    var props = keys(map);
                    if (hasSymbols) {
                        props = concat.call(props, Object.getOwnPropertySymbols(map));
                    }
                    for(var i = 0; i < props.length; i += 1){
                        defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
                    }
                };
                defineProperties.supportsDescriptors = !!supportsDescriptors;
                module1.exports = defineProperties;
            /***/ },
            /***/ 4956: /***/ function(module1) {
                "use strict";
                var assign = /**
 * Code refactored from Mozilla Developer Network:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 */ function assign(target, firstSource) {
                    if (target === undefined || target === null) {
                        throw new TypeError("Cannot convert first argument to object");
                    }
                    var to = Object(target);
                    for(var i = 1; i < arguments.length; i++){
                        var nextSource = arguments[i];
                        if (nextSource === undefined || nextSource === null) {
                            continue;
                        }
                        var keysArray = Object.keys(Object(nextSource));
                        for(var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++){
                            var nextKey = keysArray[nextIndex];
                            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                            if (desc !== undefined && desc.enumerable) {
                                to[nextKey] = nextSource[nextKey];
                            }
                        }
                    }
                    return to;
                };
                var polyfill = function polyfill() {
                    if (!Object.assign) {
                        Object.defineProperty(Object, "assign", {
                            enumerable: false,
                            configurable: true,
                            writable: true,
                            value: assign
                        });
                    }
                };
                module1.exports = {
                    assign: assign,
                    polyfill: polyfill
                };
            /***/ },
            /***/ 3243: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_1497659__) {
                "use strict";
                var isCallable = __nested_webpack_require_1497659__(9680);
                var toStr = Object.prototype.toString;
                var hasOwnProperty = Object.prototype.hasOwnProperty;
                var forEachArray = function forEachArray(array, iterator, receiver) {
                    for(var i = 0, len = array.length; i < len; i++){
                        if (hasOwnProperty.call(array, i)) {
                            if (receiver == null) {
                                iterator(array[i], i, array);
                            } else {
                                iterator.call(receiver, array[i], i, array);
                            }
                        }
                    }
                };
                var forEachString = function forEachString(string, iterator, receiver) {
                    for(var i = 0, len = string.length; i < len; i++){
                        // no such thing as a sparse string.
                        if (receiver == null) {
                            iterator(string.charAt(i), i, string);
                        } else {
                            iterator.call(receiver, string.charAt(i), i, string);
                        }
                    }
                };
                var forEachObject = function forEachObject(object, iterator, receiver) {
                    for(var k in object){
                        if (hasOwnProperty.call(object, k)) {
                            if (receiver == null) {
                                iterator(object[k], k, object);
                            } else {
                                iterator.call(receiver, object[k], k, object);
                            }
                        }
                    }
                };
                var forEach = function forEach(list, iterator, thisArg) {
                    if (!isCallable(iterator)) {
                        throw new TypeError("iterator must be a function");
                    }
                    var receiver;
                    if (arguments.length >= 3) {
                        receiver = thisArg;
                    }
                    if (toStr.call(list) === "[object Array]") {
                        forEachArray(list, iterator, receiver);
                    } else if (typeof list === "string") {
                        forEachString(list, iterator, receiver);
                    } else {
                        forEachObject(list, iterator, receiver);
                    }
                };
                module1.exports = forEach;
            /***/ },
            /***/ 7795: /***/ function(module1) {
                "use strict";
                /* eslint no-invalid-this: 1 */ var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
                var slice = Array.prototype.slice;
                var toStr = Object.prototype.toString;
                var funcType = "[object Function]";
                module1.exports = function bind(that) {
                    var target = this;
                    if (typeof target !== "function" || toStr.call(target) !== funcType) {
                        throw new TypeError(ERROR_MESSAGE + target);
                    }
                    var args = slice.call(arguments, 1);
                    var bound;
                    var binder = function binder() {
                        if (_instanceof(this, bound)) {
                            var result = target.apply(this, args.concat(slice.call(arguments)));
                            if (Object(result) === result) {
                                return result;
                            }
                            return this;
                        } else {
                            return target.apply(that, args.concat(slice.call(arguments)));
                        }
                    };
                    var boundLength = Math.max(0, target.length - args.length);
                    var boundArgs = [];
                    for(var i = 0; i < boundLength; i++){
                        boundArgs.push("$" + i);
                    }
                    bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
                    if (target.prototype) {
                        var Empty = function Empty() {};
                        Empty.prototype = target.prototype;
                        bound.prototype = new Empty();
                        Empty.prototype = null;
                    }
                    return bound;
                };
            /***/ },
            /***/ 4090: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_1502409__) {
                "use strict";
                var implementation = __nested_webpack_require_1502409__(7795);
                module1.exports = Function.prototype.bind || implementation;
            /***/ },
            /***/ 7286: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_1502698__) {
                "use strict";
                var undefined1;
                var $SyntaxError = SyntaxError;
                var $Function = Function;
                var $TypeError = TypeError;
                // eslint-disable-next-line consistent-return
                var getEvalledConstructor = function getEvalledConstructor(expressionSyntax) {
                    try {
                        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
                    } catch (e) {}
                };
                var $gOPD = Object.getOwnPropertyDescriptor;
                if ($gOPD) {
                    try {
                        $gOPD({}, "");
                    } catch (e) {
                        $gOPD = null; // this is IE 8, which has a broken gOPD
                    }
                }
                var throwTypeError = function throwTypeError() {
                    throw new $TypeError();
                };
                var ThrowTypeError = $gOPD ? function() {
                    try {
                        // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
                        arguments.callee; // IE 8 does not throw here
                        return throwTypeError;
                    } catch (calleeThrows) {
                        try {
                            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
                            return $gOPD(arguments, "callee").get;
                        } catch (gOPDthrows) {
                            return throwTypeError;
                        }
                    }
                }() : throwTypeError;
                var hasSymbols = __nested_webpack_require_1502698__(2636)();
                var getProto = Object.getPrototypeOf || function(x) {
                    return x.__proto__;
                }; // eslint-disable-line no-proto
                var needsEval = {};
                var TypedArray = typeof Uint8Array === "undefined" ? undefined1 : getProto(Uint8Array);
                var INTRINSICS = {
                    "%AggregateError%": typeof AggregateError === "undefined" ? undefined1 : AggregateError,
                    "%Array%": Array,
                    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined1 : ArrayBuffer,
                    "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined1,
                    "%AsyncFromSyncIteratorPrototype%": undefined1,
                    "%AsyncFunction%": needsEval,
                    "%AsyncGenerator%": needsEval,
                    "%AsyncGeneratorFunction%": needsEval,
                    "%AsyncIteratorPrototype%": needsEval,
                    "%Atomics%": typeof Atomics === "undefined" ? undefined1 : Atomics,
                    "%BigInt%": typeof BigInt === "undefined" ? undefined1 : BigInt,
                    "%Boolean%": Boolean,
                    "%DataView%": typeof DataView === "undefined" ? undefined1 : DataView,
                    "%Date%": Date,
                    "%decodeURI%": decodeURI,
                    "%decodeURIComponent%": decodeURIComponent,
                    "%encodeURI%": encodeURI,
                    "%encodeURIComponent%": encodeURIComponent,
                    "%Error%": Error,
                    "%eval%": eval,
                    "%EvalError%": EvalError,
                    "%Float32Array%": typeof Float32Array === "undefined" ? undefined1 : Float32Array,
                    "%Float64Array%": typeof Float64Array === "undefined" ? undefined1 : Float64Array,
                    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined1 : FinalizationRegistry,
                    "%Function%": $Function,
                    "%GeneratorFunction%": needsEval,
                    "%Int8Array%": typeof Int8Array === "undefined" ? undefined1 : Int8Array,
                    "%Int16Array%": typeof Int16Array === "undefined" ? undefined1 : Int16Array,
                    "%Int32Array%": typeof Int32Array === "undefined" ? undefined1 : Int32Array,
                    "%isFinite%": isFinite,
                    "%isNaN%": isNaN,
                    "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined1,
                    "%JSON%": typeof JSON === "object" ? JSON : undefined1,
                    "%Map%": typeof Map === "undefined" ? undefined1 : Map,
                    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined1 : getProto(new Map()[Symbol.iterator]()),
                    "%Math%": Math,
                    "%Number%": Number,
                    "%Object%": Object,
                    "%parseFloat%": parseFloat,
                    "%parseInt%": parseInt,
                    "%Promise%": typeof Promise === "undefined" ? undefined1 : Promise,
                    "%Proxy%": typeof Proxy === "undefined" ? undefined1 : Proxy,
                    "%RangeError%": RangeError,
                    "%ReferenceError%": ReferenceError,
                    "%Reflect%": typeof Reflect === "undefined" ? undefined1 : Reflect,
                    "%RegExp%": RegExp,
                    "%Set%": typeof Set === "undefined" ? undefined1 : Set,
                    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined1 : getProto(new Set()[Symbol.iterator]()),
                    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined1 : SharedArrayBuffer,
                    "%String%": String,
                    "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined1,
                    "%Symbol%": hasSymbols ? Symbol : undefined1,
                    "%SyntaxError%": $SyntaxError,
                    "%ThrowTypeError%": ThrowTypeError,
                    "%TypedArray%": TypedArray,
                    "%TypeError%": $TypeError,
                    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined1 : Uint8Array,
                    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined1 : Uint8ClampedArray,
                    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined1 : Uint16Array,
                    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined1 : Uint32Array,
                    "%URIError%": URIError,
                    "%WeakMap%": typeof WeakMap === "undefined" ? undefined1 : WeakMap,
                    "%WeakRef%": typeof WeakRef === "undefined" ? undefined1 : WeakRef,
                    "%WeakSet%": typeof WeakSet === "undefined" ? undefined1 : WeakSet
                };
                var doEval = function doEval(name) {
                    var value;
                    if (name === "%AsyncFunction%") {
                        value = getEvalledConstructor("async function () {}");
                    } else if (name === "%GeneratorFunction%") {
                        value = getEvalledConstructor("function* () {}");
                    } else if (name === "%AsyncGeneratorFunction%") {
                        value = getEvalledConstructor("async function* () {}");
                    } else if (name === "%AsyncGenerator%") {
                        var fn = doEval("%AsyncGeneratorFunction%");
                        if (fn) {
                            value = fn.prototype;
                        }
                    } else if (name === "%AsyncIteratorPrototype%") {
                        var gen = doEval("%AsyncGenerator%");
                        if (gen) {
                            value = getProto(gen.prototype);
                        }
                    }
                    INTRINSICS[name] = value;
                    return value;
                };
                var LEGACY_ALIASES = {
                    "%ArrayBufferPrototype%": [
                        "ArrayBuffer",
                        "prototype"
                    ],
                    "%ArrayPrototype%": [
                        "Array",
                        "prototype"
                    ],
                    "%ArrayProto_entries%": [
                        "Array",
                        "prototype",
                        "entries"
                    ],
                    "%ArrayProto_forEach%": [
                        "Array",
                        "prototype",
                        "forEach"
                    ],
                    "%ArrayProto_keys%": [
                        "Array",
                        "prototype",
                        "keys"
                    ],
                    "%ArrayProto_values%": [
                        "Array",
                        "prototype",
                        "values"
                    ],
                    "%AsyncFunctionPrototype%": [
                        "AsyncFunction",
                        "prototype"
                    ],
                    "%AsyncGenerator%": [
                        "AsyncGeneratorFunction",
                        "prototype"
                    ],
                    "%AsyncGeneratorPrototype%": [
                        "AsyncGeneratorFunction",
                        "prototype",
                        "prototype"
                    ],
                    "%BooleanPrototype%": [
                        "Boolean",
                        "prototype"
                    ],
                    "%DataViewPrototype%": [
                        "DataView",
                        "prototype"
                    ],
                    "%DatePrototype%": [
                        "Date",
                        "prototype"
                    ],
                    "%ErrorPrototype%": [
                        "Error",
                        "prototype"
                    ],
                    "%EvalErrorPrototype%": [
                        "EvalError",
                        "prototype"
                    ],
                    "%Float32ArrayPrototype%": [
                        "Float32Array",
                        "prototype"
                    ],
                    "%Float64ArrayPrototype%": [
                        "Float64Array",
                        "prototype"
                    ],
                    "%FunctionPrototype%": [
                        "Function",
                        "prototype"
                    ],
                    "%Generator%": [
                        "GeneratorFunction",
                        "prototype"
                    ],
                    "%GeneratorPrototype%": [
                        "GeneratorFunction",
                        "prototype",
                        "prototype"
                    ],
                    "%Int8ArrayPrototype%": [
                        "Int8Array",
                        "prototype"
                    ],
                    "%Int16ArrayPrototype%": [
                        "Int16Array",
                        "prototype"
                    ],
                    "%Int32ArrayPrototype%": [
                        "Int32Array",
                        "prototype"
                    ],
                    "%JSONParse%": [
                        "JSON",
                        "parse"
                    ],
                    "%JSONStringify%": [
                        "JSON",
                        "stringify"
                    ],
                    "%MapPrototype%": [
                        "Map",
                        "prototype"
                    ],
                    "%NumberPrototype%": [
                        "Number",
                        "prototype"
                    ],
                    "%ObjectPrototype%": [
                        "Object",
                        "prototype"
                    ],
                    "%ObjProto_toString%": [
                        "Object",
                        "prototype",
                        "toString"
                    ],
                    "%ObjProto_valueOf%": [
                        "Object",
                        "prototype",
                        "valueOf"
                    ],
                    "%PromisePrototype%": [
                        "Promise",
                        "prototype"
                    ],
                    "%PromiseProto_then%": [
                        "Promise",
                        "prototype",
                        "then"
                    ],
                    "%Promise_all%": [
                        "Promise",
                        "all"
                    ],
                    "%Promise_reject%": [
                        "Promise",
                        "reject"
                    ],
                    "%Promise_resolve%": [
                        "Promise",
                        "resolve"
                    ],
                    "%RangeErrorPrototype%": [
                        "RangeError",
                        "prototype"
                    ],
                    "%ReferenceErrorPrototype%": [
                        "ReferenceError",
                        "prototype"
                    ],
                    "%RegExpPrototype%": [
                        "RegExp",
                        "prototype"
                    ],
                    "%SetPrototype%": [
                        "Set",
                        "prototype"
                    ],
                    "%SharedArrayBufferPrototype%": [
                        "SharedArrayBuffer",
                        "prototype"
                    ],
                    "%StringPrototype%": [
                        "String",
                        "prototype"
                    ],
                    "%SymbolPrototype%": [
                        "Symbol",
                        "prototype"
                    ],
                    "%SyntaxErrorPrototype%": [
                        "SyntaxError",
                        "prototype"
                    ],
                    "%TypedArrayPrototype%": [
                        "TypedArray",
                        "prototype"
                    ],
                    "%TypeErrorPrototype%": [
                        "TypeError",
                        "prototype"
                    ],
                    "%Uint8ArrayPrototype%": [
                        "Uint8Array",
                        "prototype"
                    ],
                    "%Uint8ClampedArrayPrototype%": [
                        "Uint8ClampedArray",
                        "prototype"
                    ],
                    "%Uint16ArrayPrototype%": [
                        "Uint16Array",
                        "prototype"
                    ],
                    "%Uint32ArrayPrototype%": [
                        "Uint32Array",
                        "prototype"
                    ],
                    "%URIErrorPrototype%": [
                        "URIError",
                        "prototype"
                    ],
                    "%WeakMapPrototype%": [
                        "WeakMap",
                        "prototype"
                    ],
                    "%WeakSetPrototype%": [
                        "WeakSet",
                        "prototype"
                    ]
                };
                var bind = __nested_webpack_require_1502698__(4090);
                var hasOwn = __nested_webpack_require_1502698__(3198);
                var $concat = bind.call(Function.call, Array.prototype.concat);
                var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
                var $replace = bind.call(Function.call, String.prototype.replace);
                var $strSlice = bind.call(Function.call, String.prototype.slice);
                var $exec = bind.call(Function.call, RegExp.prototype.exec);
                /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */ var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
                var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */ 
                var stringToPath = function stringToPath(string) {
                    var first = $strSlice(string, 0, 1);
                    var last = $strSlice(string, -1);
                    if (first === "%" && last !== "%") {
                        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
                    } else if (last === "%" && first !== "%") {
                        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
                    }
                    var result = [];
                    $replace(string, rePropName, function(match, number, quote, subString) {
                        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
                    });
                    return result;
                };
                /* end adaptation */ var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
                    var intrinsicName = name;
                    var alias;
                    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
                        alias = LEGACY_ALIASES[intrinsicName];
                        intrinsicName = "%" + alias[0] + "%";
                    }
                    if (hasOwn(INTRINSICS, intrinsicName)) {
                        var value = INTRINSICS[intrinsicName];
                        if (value === needsEval) {
                            value = doEval(intrinsicName);
                        }
                        if (typeof value === "undefined" && !allowMissing) {
                            throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
                        }
                        return {
                            alias: alias,
                            name: intrinsicName,
                            value: value
                        };
                    }
                    throw new $SyntaxError("intrinsic " + name + " does not exist!");
                };
                module1.exports = function GetIntrinsic(name, allowMissing) {
                    if (typeof name !== "string" || name.length === 0) {
                        throw new $TypeError("intrinsic name must be a non-empty string");
                    }
                    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
                        throw new $TypeError('"allowMissing" argument must be a boolean');
                    }
                    if ($exec(/^%?[^%]*%?$/, name) === null) {
                        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
                    }
                    var parts = stringToPath(name);
                    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
                    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
                    var intrinsicRealName = intrinsic.name;
                    var value = intrinsic.value;
                    var skipFurtherCaching = false;
                    var alias = intrinsic.alias;
                    if (alias) {
                        intrinsicBaseName = alias[0];
                        $spliceApply(parts, $concat([
                            0,
                            1
                        ], alias));
                    }
                    for(var i = 1, isOwn = true; i < parts.length; i += 1){
                        var part = parts[i];
                        var first = $strSlice(part, 0, 1);
                        var last = $strSlice(part, -1);
                        if ((first === '"' || first === "'" || first === "`" || last === '"' || last === "'" || last === "`") && first !== last) {
                            throw new $SyntaxError("property names with quotes must have matching quotes");
                        }
                        if (part === "constructor" || !isOwn) {
                            skipFurtherCaching = true;
                        }
                        intrinsicBaseName += "." + part;
                        intrinsicRealName = "%" + intrinsicBaseName + "%";
                        if (hasOwn(INTRINSICS, intrinsicRealName)) {
                            value = INTRINSICS[intrinsicRealName];
                        } else if (value != null) {
                            if (!(part in value)) {
                                if (!allowMissing) {
                                    throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
                                }
                                return void undefined1;
                            }
                            if ($gOPD && i + 1 >= parts.length) {
                                var desc = $gOPD(value, part);
                                isOwn = !!desc;
                                // By convention, when a data property is converted to an accessor
                                // property to emulate a data property that does not suffer from
                                // the override mistake, that accessor's getter is marked with
                                // an `originalValue` property. Here, when we detect this, we
                                // uphold the illusion by pretending to see that original data
                                // property, i.e., returning the value rather than the getter
                                // itself.
                                if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                                    value = desc.get;
                                } else {
                                    value = value[part];
                                }
                            } else {
                                isOwn = hasOwn(value, part);
                                value = value[part];
                            }
                            if (isOwn && !skipFurtherCaching) {
                                INTRINSICS[intrinsicRealName] = value;
                            }
                        }
                    }
                    return value;
                };
            /***/ },
            /***/ 326: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_1525358__) {
                "use strict";
                var GetIntrinsic = __nested_webpack_require_1525358__(7286);
                var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
                if ($gOPD) {
                    try {
                        $gOPD([], "length");
                    } catch (e) {
                        // IE 8 has a broken gOPD
                        $gOPD = null;
                    }
                }
                module1.exports = $gOPD;
            /***/ },
            /***/ 1181: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_1525956__) {
                "use strict";
                var GetIntrinsic = __nested_webpack_require_1525956__(7286);
                var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
                var hasPropertyDescriptors = function hasPropertyDescriptors() {
                    if ($defineProperty) {
                        try {
                            $defineProperty({}, "a", {
                                value: 1
                            });
                            return true;
                        } catch (e) {
                            // IE 8 has a broken defineProperty
                            return false;
                        }
                    }
                    return false;
                };
                hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
                    // node v0.6 has a bug where array lengths can be Set but not Defined
                    if (!hasPropertyDescriptors()) {
                        return null;
                    }
                    try {
                        return $defineProperty([], "length", {
                            value: 1
                        }).length !== 1;
                    } catch (e) {
                        // In Firefox 4-22, defining length on an array throws an exception.
                        return true;
                    }
                };
                module1.exports = hasPropertyDescriptors;
            /***/ },
            /***/ 2636: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_1527553__) {
                "use strict";
                var origSymbol = typeof Symbol !== "undefined" && Symbol;
                var hasSymbolSham = __nested_webpack_require_1527553__(6679);
                module1.exports = function hasNativeSymbols() {
                    if (typeof origSymbol !== "function") {
                        return false;
                    }
                    if (typeof Symbol !== "function") {
                        return false;
                    }
                    if (_type_of(origSymbol("foo")) !== "symbol") {
                        return false;
                    }
                    if (_type_of(Symbol("bar")) !== "symbol") {
                        return false;
                    }
                    return hasSymbolSham();
                };
            /***/ },
            /***/ 6679: /***/ function(module1) {
                "use strict";
                /* eslint complexity: [2, 18], max-statements: [2, 33] */ module1.exports = function hasSymbols() {
                    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
                        return false;
                    }
                    if (_type_of(Symbol.iterator) === "symbol") {
                        return true;
                    }
                    var obj = {};
                    var sym = Symbol("test");
                    var symObj = Object(sym);
                    if (typeof sym === "string") {
                        return false;
                    }
                    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
                        return false;
                    }
                    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
                        return false;
                    }
                    // temp disabled per https://github.com/ljharb/object.assign/issues/17
                    // if (sym instanceof Symbol) { return false; }
                    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
                    // if (!(symObj instanceof Symbol)) { return false; }
                    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
                    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
                    var symVal = 42;
                    obj[sym] = symVal;
                    for(sym in obj){
                        return false;
                    } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
                    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
                        return false;
                    }
                    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
                        return false;
                    }
                    var syms = Object.getOwnPropertySymbols(obj);
                    if (syms.length !== 1 || syms[0] !== sym) {
                        return false;
                    }
                    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
                        return false;
                    }
                    if (typeof Object.getOwnPropertyDescriptor === "function") {
                        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
                        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
                            return false;
                        }
                    }
                    return true;
                };
            /***/ },
            /***/ 7226: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_1531335__) {
                "use strict";
                var hasSymbols = __nested_webpack_require_1531335__(6679);
                module1.exports = function hasToStringTagShams() {
                    return hasSymbols() && !!Symbol.toStringTag;
                };
            /***/ },
            /***/ 3198: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_1531694__) {
                "use strict";
                var bind = __nested_webpack_require_1531694__(4090);
                module1.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
            /***/ },
            /***/ 1285: /***/ function(module1) {
                if (typeof Object.create === "function") {
                    // implementation from standard node.js 'util' module
                    module1.exports = function inherits(ctor, superCtor) {
                        if (superCtor) {
                            ctor.super_ = superCtor;
                            ctor.prototype = Object.create(superCtor.prototype, {
                                constructor: {
                                    value: ctor,
                                    enumerable: false,
                                    writable: true,
                                    configurable: true
                                }
                            });
                        }
                    };
                } else {
                    // old school shim for old browsers
                    module1.exports = function inherits(ctor, superCtor) {
                        if (superCtor) {
                            ctor.super_ = superCtor;
                            var TempCtor = function TempCtor() {};
                            TempCtor.prototype = superCtor.prototype;
                            ctor.prototype = new TempCtor();
                            ctor.prototype.constructor = ctor;
                        }
                    };
                }
            /***/ },
            /***/ 2635: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_1533395__) {
                "use strict";
                var hasToStringTag = __nested_webpack_require_1533395__(7226)();
                var callBound = __nested_webpack_require_1533395__(2680);
                var $toString = callBound("Object.prototype.toString");
                var isStandardArguments = function isArguments(value) {
                    if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
                        return false;
                    }
                    return $toString(value) === "[object Arguments]";
                };
                var isLegacyArguments = function isArguments(value) {
                    if (isStandardArguments(value)) {
                        return true;
                    }
                    return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
                };
                var supportsStandardArguments = function() {
                    return isStandardArguments(arguments);
                }();
                isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests
                module1.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
            /***/ },
            /***/ 9680: /***/ function(module1) {
                "use strict";
                var fnToStr = Function.prototype.toString;
                var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
                var badArrayLike;
                var isCallableMarker;
                if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
                    try {
                        badArrayLike = Object.defineProperty({}, "length", {
                            get: function get() {
                                throw isCallableMarker;
                            }
                        });
                        isCallableMarker = {};
                        // eslint-disable-next-line no-throw-literal
                        reflectApply(function() {
                            throw 42;
                        }, null, badArrayLike);
                    } catch (_) {
                        if (_ !== isCallableMarker) {
                            reflectApply = null;
                        }
                    }
                } else {
                    reflectApply = null;
                }
                var constructorRegex = /^\s*class\b/;
                var isES6ClassFn = function isES6ClassFunction(value) {
                    try {
                        var fnStr = fnToStr.call(value);
                        return constructorRegex.test(fnStr);
                    } catch (e) {
                        return false; // not a function
                    }
                };
                var tryFunctionObject = function tryFunctionToStr(value) {
                    try {
                        if (isES6ClassFn(value)) {
                            return false;
                        }
                        fnToStr.call(value);
                        return true;
                    } catch (e) {
                        return false;
                    }
                };
                var toStr = Object.prototype.toString;
                var objectClass = "[object Object]";
                var fnClass = "[object Function]";
                var genClass = "[object GeneratorFunction]";
                var ddaClass = "[object HTMLAllCollection]"; // IE 11
                var ddaClass2 = "[object HTML document.all class]";
                var ddaClass3 = "[object HTMLCollection]"; // IE 9-10
                var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag; // better: use `has-tostringtag`
                var isIE68 = !(0 in [
                    , 
                ]); // eslint-disable-line no-sparse-arrays, comma-spacing
                var isDDA = function isDocumentDotAll() {
                    return false;
                };
                if (typeof document === "object") {
                    // Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
                    var all = document.all;
                    if (toStr.call(all) === toStr.call(document.all)) {
                        isDDA = function isDocumentDotAll(value) {
                            /* globals document: false */ // in IE 6-8, typeof document.all is "object" and it's truthy
                            if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
                                try {
                                    var str = toStr.call(value);
                                    return (str === ddaClass || str === ddaClass2 || str === ddaClass3 // opera 12.16
                                     || str === objectClass // IE 6-8
                                    ) && value("") == null; // eslint-disable-line eqeqeq
                                } catch (e) {}
                            }
                            return false;
                        };
                    }
                }
                module1.exports = reflectApply ? function isCallable(value) {
                    if (isDDA(value)) {
                        return true;
                    }
                    if (!value) {
                        return false;
                    }
                    if (typeof value !== "function" && typeof value !== "object") {
                        return false;
                    }
                    try {
                        reflectApply(value, null, badArrayLike);
                    } catch (e) {
                        if (e !== isCallableMarker) {
                            return false;
                        }
                    }
                    return !isES6ClassFn(value) && tryFunctionObject(value);
                } : function isCallable(value) {
                    if (isDDA(value)) {
                        return true;
                    }
                    if (!value) {
                        return false;
                    }
                    if (typeof value !== "function" && typeof value !== "object") {
                        return false;
                    }
                    if (hasToStringTag) {
                        return tryFunctionObject(value);
                    }
                    if (isES6ClassFn(value)) {
                        return false;
                    }
                    var strClass = toStr.call(value);
                    if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
                        return false;
                    }
                    return tryFunctionObject(value);
                };
            /***/ },
            /***/ 3138: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_1540473__) {
                "use strict";
                var toStr = Object.prototype.toString;
                var fnToStr = Function.prototype.toString;
                var isFnRegex = /^\s*(?:function)?\*/;
                var hasToStringTag = __nested_webpack_require_1540473__(7226)();
                var getProto = Object.getPrototypeOf;
                var getGeneratorFunc = function getGeneratorFunc() {
                    if (!hasToStringTag) {
                        return false;
                    }
                    try {
                        return Function("return function*() {}")();
                    } catch (e) {}
                };
                var GeneratorFunction;
                module1.exports = function isGeneratorFunction(fn) {
                    if (typeof fn !== "function") {
                        return false;
                    }
                    if (isFnRegex.test(fnToStr.call(fn))) {
                        return true;
                    }
                    if (!hasToStringTag) {
                        var str = toStr.call(fn);
                        return str === "[object GeneratorFunction]";
                    }
                    if (!getProto) {
                        return false;
                    }
                    if (typeof GeneratorFunction === "undefined") {
                        var generatorFunc = getGeneratorFunc();
                        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
                    }
                    return getProto(fn) === GeneratorFunction;
                };
            /***/ },
            /***/ 7053: /***/ function(module1) {
                "use strict";
                /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ module1.exports = function isNaN1(value) {
                    return value !== value;
                };
            /***/ },
            /***/ 4782: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_1542473__) {
                "use strict";
                var callBind = __nested_webpack_require_1542473__(9429);
                var define1 = __nested_webpack_require_1542473__(4926);
                var implementation = __nested_webpack_require_1542473__(7053);
                var getPolyfill = __nested_webpack_require_1542473__(755);
                var shim = __nested_webpack_require_1542473__(5346);
                var polyfill = callBind(getPolyfill(), Number);
                /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ define1(polyfill, {
                    getPolyfill: getPolyfill,
                    implementation: implementation,
                    shim: shim
                });
                module1.exports = polyfill;
            /***/ },
            /***/ 755: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_1543277__) {
                "use strict";
                var implementation = __nested_webpack_require_1543277__(7053);
                module1.exports = function getPolyfill() {
                    if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a")) {
                        return Number.isNaN;
                    }
                    return implementation;
                };
            /***/ },
            /***/ 5346: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_1543760__) {
                "use strict";
                var define1 = __nested_webpack_require_1543760__(4926);
                var getPolyfill = __nested_webpack_require_1543760__(755);
                /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ module1.exports = function shimNumberIsNaN() {
                    var polyfill = getPolyfill();
                    define1(Number, {
                        isNaN: polyfill
                    }, {
                        isNaN: function testIsNaN() {
                            return Number.isNaN !== polyfill;
                        }
                    });
                    return polyfill;
                };
            /***/ },
            /***/ 198: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_1544533__) {
                "use strict";
                var forEach = __nested_webpack_require_1544533__(3243);
                var availableTypedArrays = __nested_webpack_require_1544533__(2191);
                var callBound = __nested_webpack_require_1544533__(2680);
                var $toString = callBound("Object.prototype.toString");
                var hasToStringTag = __nested_webpack_require_1544533__(7226)();
                var gOPD = __nested_webpack_require_1544533__(326);
                var g = typeof globalThis === "undefined" ? __nested_webpack_require_1544533__.g : globalThis;
                var typedArrays = availableTypedArrays();
                var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
                    for(var i = 0; i < array.length; i += 1){
                        if (array[i] === value) {
                            return i;
                        }
                    }
                    return -1;
                };
                var $slice = callBound("String.prototype.slice");
                var toStrTags = {};
                var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
                if (hasToStringTag && gOPD && getPrototypeOf) {
                    forEach(typedArrays, function(typedArray) {
                        var arr = new g[typedArray]();
                        if (Symbol.toStringTag in arr) {
                            var proto = getPrototypeOf(arr);
                            var descriptor = gOPD(proto, Symbol.toStringTag);
                            if (!descriptor) {
                                var superProto = getPrototypeOf(proto);
                                descriptor = gOPD(superProto, Symbol.toStringTag);
                            }
                            toStrTags[typedArray] = descriptor.get;
                        }
                    });
                }
                var tryTypedArrays = function tryAllTypedArrays(value) {
                    var anyTrue = false;
                    forEach(toStrTags, function(getter, typedArray) {
                        if (!anyTrue) {
                            try {
                                anyTrue = getter.call(value) === typedArray;
                            } catch (e) {}
                        }
                    });
                    return anyTrue;
                };
                module1.exports = function isTypedArray(value) {
                    if (!value || typeof value !== "object") {
                        return false;
                    }
                    if (!hasToStringTag || !(Symbol.toStringTag in value)) {
                        var tag = $slice($toString(value), 8, -1);
                        return $indexOf(typedArrays, tag) > -1;
                    }
                    if (!gOPD) {
                        return false;
                    }
                    return tryTypedArrays(value);
                };
            /***/ },
            /***/ 7438: /***/ function(module1, exports1, __nested_webpack_require_1547556__) {
                /* module decorator */ module1 = __nested_webpack_require_1547556__.nmd(module1);
                var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; /* global exports:true, module:true, require:true, define:true, global:true */ 
                (function(root, name, factory) {
                    "use strict";
                    // Used to determine if values are of the language type `Object`
                    var objectTypes = {
                        "function": true,
                        "object": true
                    }, freeExports = objectTypes[typeof exports1 === "undefined" ? "undefined" : _type_of(exports1)] && exports1 && !exports1.nodeType && exports1, freeModule = objectTypes["object"] && module1 && !module1.nodeType && module1, freeGlobal = freeExports && freeModule && typeof __nested_webpack_require_1547556__.g === "object" && __nested_webpack_require_1547556__.g, moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
                    /* istanbul ignore else */ if (freeGlobal && (freeGlobal.global === freeGlobal || /* istanbul ignore next */ freeGlobal.window === freeGlobal || /* istanbul ignore next */ freeGlobal.self === freeGlobal)) {
                        root = freeGlobal;
                    }
                    // Some AMD build optimizers, like r.js, check for specific condition
                    // patterns like the following:
                    /* istanbul ignore if */ if (true) {
                        // defined as an anonymous module.
                        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
                            exports1
                        ], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports1, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module1.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                        // In case the source has been processed and wrapped in a define module use
                        // the supplied `exports` object.
                        if (freeExports && moduleExports) factory(freeModule.exports);
                    } else /* istanbul ignore else */ {}
                })(this, "luaparse", function(exports1) {
                    "use strict";
                    var encodeUTF8 = function encodeUTF8(codepoint, highMask) {
                        highMask = highMask || 0;
                        if (codepoint < 0x80) {
                            return String.fromCharCode(codepoint);
                        } else if (codepoint < 0x800) {
                            return String.fromCharCode(highMask | 0xc0 | codepoint >> 6, highMask | 0x80 | codepoint & 0x3f);
                        } else if (codepoint < 0x10000) {
                            return String.fromCharCode(highMask | 0xe0 | codepoint >> 12, highMask | 0x80 | codepoint >> 6 & 0x3f, highMask | 0x80 | codepoint & 0x3f);
                        } else /* istanbul ignore else */ if (codepoint < 0x110000) {
                            return String.fromCharCode(highMask | 0xf0 | codepoint >> 18, highMask | 0x80 | codepoint >> 12 & 0x3f, highMask | 0x80 | codepoint >> 6 & 0x3f, highMask | 0x80 | codepoint & 0x3f);
                        } else {
                            // TODO: Lua 5.4 allows up to six-byte sequences, as in UTF-8:1993
                            return null;
                        }
                    };
                    var toHex = function toHex(num, digits) {
                        var result = num.toString(16);
                        while(result.length < digits)result = "0" + result;
                        return result;
                    };
                    var checkChars = function checkChars(rx) {
                        return function(s) {
                            var m = rx.exec(s);
                            if (!m) return s;
                            raise(null, errors.invalidCodeUnit, toHex(m[0].charCodeAt(0), 4).toUpperCase());
                        };
                    };
                    var finishNode = // Wrap up the node object.
                    function finishNode(node) {
                        // Pop a `Marker` off the location-array and attach its location data.
                        if (trackLocations) {
                            var location = locations.pop();
                            location.complete();
                            location.bless(node);
                        }
                        if (options.onCreateNode) options.onCreateNode(node);
                        return node;
                    };
                    var indexOfObject = // Iterate through an array of objects and return the index of an object
                    // with a matching property.
                    function indexOfObject(array, property, element) {
                        for(var i = 0, length = array.length; i < length; ++i){
                            if (array[i][property] === element) return i;
                        }
                        return -1;
                    };
                    var sprintf = // A sprintf implementation using %index (beginning at 1) to input
                    // arguments in the format string.
                    //
                    // Example:
                    //
                    //     // Unexpected function in token
                    //     sprintf('Unexpected %2 in %1.', 'token', 'function');
                    function sprintf(format) {
                        var args = slice.call(arguments, 1);
                        format = format.replace(/%(\d)/g, function(match, index) {
                            return "" + args[index - 1] || /* istanbul ignore next */ "";
                        });
                        return format;
                    };
                    var fixupError = // XXX: Eliminate this function and change the error type to be different from SyntaxError.
                    // This will unfortunately be a breaking change, because some downstream users depend
                    // on the error thrown being an instance of SyntaxError. For example, the Ace editor:
                    // <https://github.com/ajaxorg/ace/blob/4c7e5eb3f5d5ca9434847be51834a4e41661b852/lib/ace/mode/lua_worker.js#L55>
                    function fixupError(e) {
                        /* istanbul ignore if */ if (!Object.create) return e;
                        return Object.create(e, {
                            "line": {
                                "writable": true,
                                value: e.line
                            },
                            "index": {
                                "writable": true,
                                value: e.index
                            },
                            "column": {
                                "writable": true,
                                value: e.column
                            }
                        });
                    };
                    var raise = // #### Raise an exception.
                    //
                    // Raise an exception by passing a token, a string format and its paramters.
                    //
                    // The passed tokens location will automatically be added to the error
                    // message if it exists, if not it will default to the lexers current
                    // position.
                    //
                    // Example:
                    //
                    //     // [1:0] expected [ near (
                    //     raise(token, "expected %1 near %2", '[', token.value);
                    function raise(token) {
                        var message = sprintf.apply(null, slice.call(arguments, 1)), error, col;
                        if (token === null || typeof token.line === "undefined") {
                            col = index - lineStart + 1;
                            error = fixupError(new SyntaxError(sprintf("[%1:%2] %3", line, col, message)));
                            error.index = index;
                            error.line = line;
                            error.column = col;
                        } else {
                            col = token.range[0] - token.lineStart;
                            error = fixupError(new SyntaxError(sprintf("[%1:%2] %3", token.line, col, message)));
                            error.line = token.line;
                            error.index = token.range[0];
                            error.column = col;
                        }
                        throw error;
                    };
                    var tokenValue = function tokenValue(token) {
                        var raw = input.slice(token.range[0], token.range[1]);
                        if (raw) return raw;
                        return token.value;
                    };
                    var raiseUnexpectedToken = // #### Raise an unexpected token error.
                    //
                    // Example:
                    //
                    //     // expected <name> near '0'
                    //     raiseUnexpectedToken('<name>', token);
                    function raiseUnexpectedToken(type, token) {
                        raise(token, errors.expectedToken, type, tokenValue(token));
                    };
                    var unexpected = // #### Raise a general unexpected error
                    //
                    // Usage should pass either a token object or a symbol string which was
                    // expected. We can also specify a nearby token such as <eof>, this will
                    // default to the currently active token.
                    //
                    // Example:
                    //
                    //     // Unexpected symbol 'end' near '<eof>'
                    //     unexpected(token);
                    //
                    // If there's no token in the buffer it means we have reached <eof>.
                    function unexpected(found) {
                        var near = tokenValue(lookahead);
                        if ("undefined" !== typeof found.type) {
                            var type;
                            switch(found.type){
                                case StringLiteral:
                                    type = "string";
                                    break;
                                case Keyword:
                                    type = "keyword";
                                    break;
                                case Identifier:
                                    type = "identifier";
                                    break;
                                case NumericLiteral:
                                    type = "number";
                                    break;
                                case Punctuator:
                                    type = "symbol";
                                    break;
                                case BooleanLiteral:
                                    type = "boolean";
                                    break;
                                case NilLiteral:
                                    return raise(found, errors.unexpected, "symbol", "nil", near);
                                case EOF:
                                    return raise(found, errors.unexpectedEOF);
                            }
                            return raise(found, errors.unexpected, type, tokenValue(found), near);
                        }
                        return raise(found, errors.unexpected, "symbol", found, near);
                    };
                    var lex = function lex() {
                        skipWhiteSpace();
                        // Skip comments beginning with --
                        while(45 === input.charCodeAt(index) && 45 === input.charCodeAt(index + 1)){
                            scanComment();
                            skipWhiteSpace();
                        }
                        if (index >= length) return {
                            type: EOF,
                            value: "<eof>",
                            line: line,
                            lineStart: lineStart,
                            range: [
                                index,
                                index
                            ]
                        };
                        var charCode = input.charCodeAt(index), next = input.charCodeAt(index + 1);
                        // Memorize the range index where the token begins.
                        tokenStart = index;
                        if (isIdentifierStart(charCode)) return scanIdentifierOrKeyword();
                        switch(charCode){
                            case 39:
                            case 34:
                                return scanStringLiteral();
                            case 48:
                            case 49:
                            case 50:
                            case 51:
                            case 52:
                            case 53:
                            case 54:
                            case 55:
                            case 56:
                            case 57:
                                return scanNumericLiteral();
                            case 46:
                                // If the dot is followed by a digit it's a float.
                                if (isDecDigit(next)) return scanNumericLiteral();
                                if (46 === next) {
                                    if (46 === input.charCodeAt(index + 2)) return scanVarargLiteral();
                                    return scanPunctuator("..");
                                }
                                return scanPunctuator(".");
                            case 61:
                                if (61 === next) return scanPunctuator("==");
                                return scanPunctuator("=");
                            case 62:
                                if (features.bitwiseOperators) {
                                    if (62 === next) return scanPunctuator(">>");
                                }
                                if (61 === next) return scanPunctuator(">=");
                                return scanPunctuator(">");
                            case 60:
                                if (features.bitwiseOperators) {
                                    if (60 === next) return scanPunctuator("<<");
                                }
                                if (61 === next) return scanPunctuator("<=");
                                return scanPunctuator("<");
                            case 126:
                                if (61 === next) return scanPunctuator("~=");
                                if (!features.bitwiseOperators) break;
                                return scanPunctuator("~");
                            case 58:
                                if (features.labels) {
                                    if (58 === next) return scanPunctuator("::");
                                }
                                return scanPunctuator(":");
                            case 91:
                                // Check for a multiline string, they begin with [= or [[
                                if (91 === next || 61 === next) return scanLongStringLiteral();
                                return scanPunctuator("[");
                            case 47:
                                // Check for integer division op (//)
                                if (features.integerDivision) {
                                    if (47 === next) return scanPunctuator("//");
                                }
                                return scanPunctuator("/");
                            case 38:
                            case 124:
                                if (!features.bitwiseOperators) break;
                            /* fall through */ case 42:
                            case 94:
                            case 37:
                            case 44:
                            case 123:
                            case 125:
                            case 93:
                            case 40:
                            case 41:
                            case 59:
                            case 35:
                            case 45:
                            case 43:
                                return scanPunctuator(input.charAt(index));
                        }
                        return unexpected(input.charAt(index));
                    };
                    var consumeEOL = // Whitespace has no semantic meaning in lua so simply skip ahead while
                    // tracking the encounted newlines. Any kind of eol sequence is counted as a
                    // single line.
                    function consumeEOL() {
                        var charCode = input.charCodeAt(index), peekCharCode = input.charCodeAt(index + 1);
                        if (isLineTerminator(charCode)) {
                            // Count \n\r and \r\n as one newline.
                            if (10 === charCode && 13 === peekCharCode) ++index;
                            if (13 === charCode && 10 === peekCharCode) ++index;
                            ++line;
                            lineStart = ++index;
                            return true;
                        }
                        return false;
                    };
                    var skipWhiteSpace = function skipWhiteSpace() {
                        while(index < length){
                            var charCode = input.charCodeAt(index);
                            if (isWhiteSpace(charCode)) {
                                ++index;
                            } else if (!consumeEOL()) {
                                break;
                            }
                        }
                    };
                    var scanIdentifierOrKeyword = // Identifiers, keywords, booleans and nil all look the same syntax wise. We
                    // simply go through them one by one and defaulting to an identifier if no
                    // previous case matched.
                    function scanIdentifierOrKeyword() {
                        var value, type;
                        // Slicing the input string is prefered before string concatenation in a
                        // loop for performance reasons.
                        while(isIdentifierPart(input.charCodeAt(++index)));
                        value = encodingMode.fixup(input.slice(tokenStart, index));
                        // Decide on the token type and possibly cast the value.
                        if (isKeyword(value)) {
                            type = Keyword;
                        } else if ("true" === value || "false" === value) {
                            type = BooleanLiteral;
                            value = "true" === value;
                        } else if ("nil" === value) {
                            type = NilLiteral;
                            value = null;
                        } else {
                            type = Identifier;
                        }
                        return {
                            type: type,
                            value: value,
                            line: line,
                            lineStart: lineStart,
                            range: [
                                tokenStart,
                                index
                            ]
                        };
                    };
                    var scanPunctuator = // Once a punctuator reaches this function it should already have been
                    // validated so we simply return it as a token.
                    function scanPunctuator(value) {
                        index += value.length;
                        return {
                            type: Punctuator,
                            value: value,
                            line: line,
                            lineStart: lineStart,
                            range: [
                                tokenStart,
                                index
                            ]
                        };
                    };
                    var scanVarargLiteral = // A vararg literal consists of three dots.
                    function scanVarargLiteral() {
                        index += 3;
                        return {
                            type: VarargLiteral,
                            value: "...",
                            line: line,
                            lineStart: lineStart,
                            range: [
                                tokenStart,
                                index
                            ]
                        };
                    };
                    var scanStringLiteral = // Find the string literal by matching the delimiter marks used.
                    function scanStringLiteral() {
                        var delimiter = input.charCodeAt(index++), beginLine = line, beginLineStart = lineStart, stringStart = index, string = encodingMode.discardStrings ? null : "", charCode;
                        for(;;){
                            charCode = input.charCodeAt(index++);
                            if (delimiter === charCode) break;
                            // EOF or `\n` terminates a string literal. If we haven't found the
                            // ending delimiter by now, raise an exception.
                            if (index > length || isLineTerminator(charCode)) {
                                string += input.slice(stringStart, index - 1);
                                raise(null, errors.unfinishedString, input.slice(tokenStart, index - 1));
                            }
                            if (92 === charCode) {
                                if (!encodingMode.discardStrings) {
                                    var beforeEscape = input.slice(stringStart, index - 1);
                                    string += encodingMode.fixup(beforeEscape);
                                }
                                var escapeValue = readEscapeSequence();
                                if (!encodingMode.discardStrings) string += escapeValue;
                                stringStart = index;
                            }
                        }
                        if (!encodingMode.discardStrings) {
                            string += encodingMode.encodeByte(null);
                            string += encodingMode.fixup(input.slice(stringStart, index - 1));
                        }
                        return {
                            type: StringLiteral,
                            value: string,
                            line: beginLine,
                            lineStart: beginLineStart,
                            lastLine: line,
                            lastLineStart: lineStart,
                            range: [
                                tokenStart,
                                index
                            ]
                        };
                    };
                    var scanLongStringLiteral = // Expect a multiline string literal and return it as a regular string
                    // literal, if it doesn't validate into a valid multiline string, throw an
                    // exception.
                    function scanLongStringLiteral() {
                        var beginLine = line, beginLineStart = lineStart, string = readLongString(false);
                        // Fail if it's not a multiline literal.
                        if (false === string) raise(token, errors.expected, "[", tokenValue(token));
                        return {
                            type: StringLiteral,
                            value: encodingMode.discardStrings ? null : encodingMode.fixup(string),
                            line: beginLine,
                            lineStart: beginLineStart,
                            lastLine: line,
                            lastLineStart: lineStart,
                            range: [
                                tokenStart,
                                index
                            ]
                        };
                    };
                    var scanNumericLiteral = // Numeric literals will be returned as floating-point numbers instead of
                    // strings. The raw value should be retrieved from slicing the input string
                    // later on in the process.
                    //
                    // If a hexadecimal number is encountered, it will be converted.
                    function scanNumericLiteral() {
                        var character = input.charAt(index), next = input.charAt(index + 1);
                        var literal = "0" === character && "xX".indexOf(next || null) >= 0 ? readHexLiteral() : readDecLiteral();
                        var foundImaginaryUnit = readImaginaryUnitSuffix(), foundInt64Suffix = readInt64Suffix();
                        if (foundInt64Suffix && (foundImaginaryUnit || literal.hasFractionPart)) {
                            raise(null, errors.malformedNumber, input.slice(tokenStart, index));
                        }
                        return {
                            type: NumericLiteral,
                            value: literal.value,
                            line: line,
                            lineStart: lineStart,
                            range: [
                                tokenStart,
                                index
                            ]
                        };
                    };
                    var readImaginaryUnitSuffix = function readImaginaryUnitSuffix() {
                        if (!features.imaginaryNumbers) return;
                        // Imaginary unit number suffix is optional.
                        // See http://luajit.org/ext_ffi_api.html#literals
                        if ("iI".indexOf(input.charAt(index) || null) >= 0) {
                            ++index;
                            return true;
                        } else {
                            return false;
                        }
                    };
                    var readInt64Suffix = function readInt64Suffix() {
                        if (!features.integerSuffixes) return;
                        // Int64/uint64 number suffix is optional.
                        // See http://luajit.org/ext_ffi_api.html#literals
                        if ("uU".indexOf(input.charAt(index) || null) >= 0) {
                            ++index;
                            if ("lL".indexOf(input.charAt(index) || null) >= 0) {
                                ++index;
                                if ("lL".indexOf(input.charAt(index) || null) >= 0) {
                                    ++index;
                                    return "ULL";
                                } else {
                                    // UL but no L
                                    raise(null, errors.malformedNumber, input.slice(tokenStart, index));
                                }
                            } else {
                                // U but no L
                                raise(null, errors.malformedNumber, input.slice(tokenStart, index));
                            }
                        } else if ("lL".indexOf(input.charAt(index) || null) >= 0) {
                            ++index;
                            if ("lL".indexOf(input.charAt(index) || null) >= 0) {
                                ++index;
                                return "LL";
                            } else {
                                // First L but no second L
                                raise(null, errors.malformedNumber, input.slice(tokenStart, index));
                            }
                        }
                    };
                    var readHexLiteral = // Lua hexadecimals have an optional fraction part and an optional binary
                    // exoponent part. These are not included in JavaScript so we will compute
                    // all three parts separately and then sum them up at the end of the function
                    // with the following algorithm.
                    //
                    //     Digit := toDec(digit)
                    //     Fraction := toDec(fraction) / 16 ^ fractionCount
                    //     BinaryExp := 2 ^ binaryExp
                    //     Number := ( Digit + Fraction ) * BinaryExp
                    function readHexLiteral() {
                        var fraction = 0 // defaults to 0 as it gets summed
                        , binaryExponent = 1 // defaults to 1 as it gets multiplied
                        , binarySign = 1 // positive
                        , digit, fractionStart, exponentStart, digitStart;
                        digitStart = index += 2; // Skip 0x part
                        // A minimum of one hex digit is required.
                        if (!isHexDigit(input.charCodeAt(index))) raise(null, errors.malformedNumber, input.slice(tokenStart, index));
                        while(isHexDigit(input.charCodeAt(index)))++index;
                        // Convert the hexadecimal digit to base 10.
                        digit = parseInt(input.slice(digitStart, index), 16);
                        // Fraction part is optional.
                        var foundFraction = false;
                        if ("." === input.charAt(index)) {
                            foundFraction = true;
                            fractionStart = ++index;
                            while(isHexDigit(input.charCodeAt(index)))++index;
                            fraction = input.slice(fractionStart, index);
                            // Empty fraction parts should default to 0, others should be converted
                            // 0.x form so we can use summation at the end.
                            fraction = fractionStart === index ? 0 : parseInt(fraction, 16) / Math.pow(16, index - fractionStart);
                        }
                        // Binary exponents are optional
                        var foundBinaryExponent = false;
                        if ("pP".indexOf(input.charAt(index) || null) >= 0) {
                            foundBinaryExponent = true;
                            ++index;
                            // Sign part is optional and defaults to 1 (positive).
                            if ("+-".indexOf(input.charAt(index) || null) >= 0) binarySign = "+" === input.charAt(index++) ? 1 : -1;
                            exponentStart = index;
                            // The binary exponent sign requires a decimal digit.
                            if (!isDecDigit(input.charCodeAt(index))) raise(null, errors.malformedNumber, input.slice(tokenStart, index));
                            while(isDecDigit(input.charCodeAt(index)))++index;
                            binaryExponent = input.slice(exponentStart, index);
                            // Calculate the binary exponent of the number.
                            binaryExponent = Math.pow(2, binaryExponent * binarySign);
                        }
                        return {
                            value: (digit + fraction) * binaryExponent,
                            hasFractionPart: foundFraction || foundBinaryExponent
                        };
                    };
                    var readDecLiteral = // Decimal numbers are exactly the same in Lua and in JavaScript, because of
                    // this we check where the token ends and then parse it with native
                    // functions.
                    function readDecLiteral() {
                        while(isDecDigit(input.charCodeAt(index)))++index;
                        // Fraction part is optional
                        var foundFraction = false;
                        if ("." === input.charAt(index)) {
                            foundFraction = true;
                            ++index;
                            // Fraction part defaults to 0
                            while(isDecDigit(input.charCodeAt(index)))++index;
                        }
                        // Exponent part is optional.
                        var foundExponent = false;
                        if ("eE".indexOf(input.charAt(index) || null) >= 0) {
                            foundExponent = true;
                            ++index;
                            // Sign part is optional.
                            if ("+-".indexOf(input.charAt(index) || null) >= 0) ++index;
                            // An exponent is required to contain at least one decimal digit.
                            if (!isDecDigit(input.charCodeAt(index))) raise(null, errors.malformedNumber, input.slice(tokenStart, index));
                            while(isDecDigit(input.charCodeAt(index)))++index;
                        }
                        return {
                            value: parseFloat(input.slice(tokenStart, index)),
                            hasFractionPart: foundFraction || foundExponent
                        };
                    };
                    var readUnicodeEscapeSequence = function readUnicodeEscapeSequence() {
                        var sequenceStart = index++;
                        if (input.charAt(index++) !== "{") raise(null, errors.braceExpected, "{", "\\" + input.slice(sequenceStart, index));
                        if (!isHexDigit(input.charCodeAt(index))) raise(null, errors.hexadecimalDigitExpected, "\\" + input.slice(sequenceStart, index));
                        while(input.charCodeAt(index) === 0x30)++index;
                        var escStart = index;
                        while(isHexDigit(input.charCodeAt(index))){
                            ++index;
                            if (index - escStart > 6) raise(null, errors.tooLargeCodepoint, "\\" + input.slice(sequenceStart, index));
                        }
                        var b = input.charAt(index++);
                        if (b !== "}") {
                            if (b === '"' || b === "'") raise(null, errors.braceExpected, "}", "\\" + input.slice(sequenceStart, index--));
                            else raise(null, errors.hexadecimalDigitExpected, "\\" + input.slice(sequenceStart, index));
                        }
                        var codepoint = parseInt(input.slice(escStart, index - 1) || "0", 16);
                        var frag = "\\" + input.slice(sequenceStart, index);
                        if (codepoint > 0x10ffff) {
                            raise(null, errors.tooLargeCodepoint, frag);
                        }
                        return encodingMode.encodeUTF8(codepoint, frag);
                    };
                    var readEscapeSequence = // Translate escape sequences to the actual characters.
                    function readEscapeSequence() {
                        var sequenceStart = index;
                        switch(input.charAt(index)){
                            // Lua allow the following escape sequences.
                            case "a":
                                ++index;
                                return "\x07";
                            case "n":
                                ++index;
                                return "\n";
                            case "r":
                                ++index;
                                return "\r";
                            case "t":
                                ++index;
                                return "	";
                            case "v":
                                ++index;
                                return "\v";
                            case "b":
                                ++index;
                                return "\b";
                            case "f":
                                ++index;
                                return "\f";
                            // Backslash at the end of the line. We treat all line endings as equivalent,
                            // and as representing the [LF] character (code 10). Lua 5.1 through 5.3
                            // have been verified to behave the same way.
                            case "\r":
                            case "\n":
                                consumeEOL();
                                return "\n";
                            case "0":
                            case "1":
                            case "2":
                            case "3":
                            case "4":
                            case "5":
                            case "6":
                            case "7":
                            case "8":
                            case "9":
                                // \ddd, where ddd is a sequence of up to three decimal digits.
                                while(isDecDigit(input.charCodeAt(index)) && index - sequenceStart < 3)++index;
                                var frag = input.slice(sequenceStart, index);
                                var ddd = parseInt(frag, 10);
                                if (ddd > 255) {
                                    raise(null, errors.decimalEscapeTooLarge, "\\" + ddd);
                                }
                                return encodingMode.encodeByte(ddd, "\\" + frag);
                            case "z":
                                if (features.skipWhitespaceEscape) {
                                    ++index;
                                    skipWhiteSpace();
                                    return "";
                                }
                                break;
                            case "x":
                                if (features.hexEscapes) {
                                    // \xXX, where XX is a sequence of exactly two hexadecimal digits
                                    if (isHexDigit(input.charCodeAt(index + 1)) && isHexDigit(input.charCodeAt(index + 2))) {
                                        index += 3;
                                        return encodingMode.encodeByte(parseInt(input.slice(sequenceStart + 1, index), 16), "\\" + input.slice(sequenceStart, index));
                                    }
                                    raise(null, errors.hexadecimalDigitExpected, "\\" + input.slice(sequenceStart, index + 2));
                                }
                                break;
                            case "u":
                                if (features.unicodeEscapes) return readUnicodeEscapeSequence();
                                break;
                            case "\\":
                            case '"':
                            case "'":
                                return input.charAt(index++);
                        }
                        if (features.strictEscapes) raise(null, errors.invalidEscape, "\\" + input.slice(sequenceStart, index + 1));
                        return input.charAt(index++);
                    };
                    var scanComment = // Comments begin with -- after which it will be decided if they are
                    // multiline comments or not.
                    //
                    // The multiline functionality works the exact same way as with string
                    // literals so we reuse the functionality.
                    function scanComment() {
                        tokenStart = index;
                        index += 2; // --
                        var character = input.charAt(index), content = "", isLong = false, commentStart = index, lineStartComment = lineStart, lineComment = line;
                        if ("[" === character) {
                            content = readLongString(true);
                            // This wasn't a multiline comment after all.
                            if (false === content) content = character;
                            else isLong = true;
                        }
                        // Scan until next line as long as it's not a multiline comment.
                        if (!isLong) {
                            while(index < length){
                                if (isLineTerminator(input.charCodeAt(index))) break;
                                ++index;
                            }
                            if (options.comments) content = input.slice(commentStart, index);
                        }
                        if (options.comments) {
                            var node = ast.comment(content, input.slice(tokenStart, index));
                            // `Marker`s depend on tokens available in the parser and as comments are
                            // intercepted in the lexer all location data is set manually.
                            if (options.locations) {
                                node.loc = {
                                    start: {
                                        line: lineComment,
                                        column: tokenStart - lineStartComment
                                    },
                                    end: {
                                        line: line,
                                        column: index - lineStart
                                    }
                                };
                            }
                            if (options.ranges) {
                                node.range = [
                                    tokenStart,
                                    index
                                ];
                            }
                            if (options.onCreateNode) options.onCreateNode(node);
                            comments.push(node);
                        }
                    };
                    var readLongString = // Read a multiline string by calculating the depth of `=` characters and
                    // then appending until an equal depth is found.
                    function readLongString(isComment) {
                        var level = 0, content = "", terminator = false, character, stringStart, firstLine = line;
                        ++index; // [
                        // Calculate the depth of the comment.
                        while("=" === input.charAt(index + level))++level;
                        // Exit, this is not a long string afterall.
                        if ("[" !== input.charAt(index + level)) return false;
                        index += level + 1;
                        // If the first character is a newline, ignore it and begin on next line.
                        if (isLineTerminator(input.charCodeAt(index))) consumeEOL();
                        stringStart = index;
                        while(index < length){
                            // To keep track of line numbers run the `consumeEOL()` which increments
                            // its counter.
                            while(isLineTerminator(input.charCodeAt(index)))consumeEOL();
                            character = input.charAt(index++);
                            // Once the delimiter is found, iterate through the depth count and see
                            // if it matches.
                            if ("]" === character) {
                                terminator = true;
                                for(var i = 0; i < level; ++i){
                                    if ("=" !== input.charAt(index + i)) terminator = false;
                                }
                                if ("]" !== input.charAt(index + level)) terminator = false;
                            }
                            // We reached the end of the multiline string. Get out now.
                            if (terminator) {
                                content += input.slice(stringStart, index - 1);
                                index += level + 1;
                                return content;
                            }
                        }
                        raise(null, isComment ? errors.unfinishedLongComment : errors.unfinishedLongString, firstLine, "<eof>");
                    };
                    var next = // ## Lex functions and helpers.
                    // Read the next token.
                    //
                    // This is actually done by setting the current token to the lookahead and
                    // reading in the new lookahead token.
                    function next() {
                        previousToken = token;
                        token = lookahead;
                        lookahead = lex();
                    };
                    var consume = // Consume a token if its value matches. Once consumed or not, return the
                    // success of the operation.
                    function consume(value) {
                        if (value === token.value) {
                            next();
                            return true;
                        }
                        return false;
                    };
                    var expect = // Expect the next token value to match. If not, throw an exception.
                    function expect(value) {
                        if (value === token.value) next();
                        else raise(token, errors.expected, value, tokenValue(token));
                    };
                    var isWhiteSpace = // ### Validation functions
                    function isWhiteSpace(charCode) {
                        return 9 === charCode || 32 === charCode || 0xB === charCode || 0xC === charCode;
                    };
                    var isLineTerminator = function isLineTerminator(charCode) {
                        return 10 === charCode || 13 === charCode;
                    };
                    var isDecDigit = function isDecDigit(charCode) {
                        return charCode >= 48 && charCode <= 57;
                    };
                    var isHexDigit = function isHexDigit(charCode) {
                        return charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70;
                    };
                    var isIdentifierStart = // From [Lua 5.2](http://www.lua.org/manual/5.2/manual.html#8.1) onwards
                    // identifiers cannot use 'locale-dependent' letters (i.e. dependent on the C locale).
                    // On the other hand, LuaJIT allows arbitrary octets ≥ 128 in identifiers.
                    function isIdentifierStart(charCode) {
                        if (charCode >= 65 && charCode <= 90 || charCode >= 97 && charCode <= 122 || 95 === charCode) return true;
                        if (features.extendedIdentifiers && charCode >= 128) return true;
                        return false;
                    };
                    var isIdentifierPart = function isIdentifierPart(charCode) {
                        if (charCode >= 65 && charCode <= 90 || charCode >= 97 && charCode <= 122 || 95 === charCode || charCode >= 48 && charCode <= 57) return true;
                        if (features.extendedIdentifiers && charCode >= 128) return true;
                        return false;
                    };
                    var isKeyword = // [3.1 Lexical Conventions](http://www.lua.org/manual/5.2/manual.html#3.1)
                    //
                    // `true`, `false` and `nil` will not be considered keywords, but literals.
                    function isKeyword(id) {
                        switch(id.length){
                            case 2:
                                return "do" === id || "if" === id || "in" === id || "or" === id;
                            case 3:
                                return "and" === id || "end" === id || "for" === id || "not" === id;
                            case 4:
                                if ("else" === id || "then" === id) return true;
                                if (features.labels && !features.contextualGoto) return "goto" === id;
                                return false;
                            case 5:
                                return "break" === id || "local" === id || "until" === id || "while" === id;
                            case 6:
                                return "elseif" === id || "repeat" === id || "return" === id;
                            case 8:
                                return "function" === id;
                        }
                        return false;
                    };
                    var isUnary = function isUnary(token) {
                        if (Punctuator === token.type) return "#-~".indexOf(token.value) >= 0;
                        if (Keyword === token.type) return "not" === token.value;
                        return false;
                    };
                    var isBlockFollow = // Check if the token syntactically closes a block.
                    function isBlockFollow(token) {
                        if (EOF === token.type) return true;
                        if (Keyword !== token.type) return false;
                        switch(token.value){
                            case "else":
                            case "elseif":
                            case "end":
                            case "until":
                                return true;
                            default:
                                return false;
                        }
                    };
                    var createScope = // Create a new scope inheriting all declarations from the previous scope.
                    function createScope() {
                        var scope = scopes[scopeDepth++].slice();
                        scopes.push(scope);
                        if (options.onCreateScope) options.onCreateScope();
                    };
                    var destroyScope = // Exit and remove the current scope.
                    function destroyScope() {
                        var scope = scopes.pop();
                        --scopeDepth;
                        if (options.onDestroyScope) options.onDestroyScope();
                    };
                    var scopeIdentifierName = // Add identifier name to the current scope if it doesnt already exist.
                    function scopeIdentifierName(name) {
                        if (options.onLocalDeclaration) options.onLocalDeclaration(name);
                        if (-1 !== indexOf(scopes[scopeDepth], name)) return;
                        scopes[scopeDepth].push(name);
                    };
                    var scopeIdentifier = // Add identifier to the current scope
                    function scopeIdentifier(node) {
                        scopeIdentifierName(node.name);
                        attachScope(node, true);
                    };
                    var attachScope = // Attach scope information to node. If the node is global, store it in the
                    // globals array so we can return the information to the user.
                    function attachScope(node, isLocal) {
                        if (!isLocal && -1 === indexOfObject(globals, "name", node.name)) globals.push(node);
                        node.isLocal = isLocal;
                    };
                    var scopeHasName = // Is the identifier name available in this scope.
                    function scopeHasName(name) {
                        return -1 !== indexOf(scopes[scopeDepth], name);
                    };
                    var createLocationMarker = function createLocationMarker() {
                        return new Marker(token);
                    };
                    var Marker = function Marker(token) {
                        if (options.locations) {
                            this.loc = {
                                start: {
                                    line: token.line,
                                    column: token.range[0] - token.lineStart
                                },
                                end: {
                                    line: 0,
                                    column: 0
                                }
                            };
                        }
                        if (options.ranges) this.range = [
                            token.range[0],
                            0
                        ];
                    };
                    var markLocation = // Create a new `Marker` and add it to the FILO-array.
                    function markLocation() {
                        if (trackLocations) locations.push(createLocationMarker());
                    };
                    var pushLocation = // Push an arbitrary `Marker` object onto the FILO-array.
                    function pushLocation(marker) {
                        if (trackLocations) locations.push(marker);
                    };
                    var FullFlowContext = // Control flow tracking
                    // ---------------------
                    // A context object that validates loop breaks and `goto`-based control flow.
                    function FullFlowContext() {
                        this.scopes = [];
                        this.pendingGotos = [];
                    };
                    var LoopFlowContext = // Simplified context that only checks the validity of loop breaks.
                    function LoopFlowContext() {
                        this.level = 0;
                        this.loopLevels = [];
                    };
                    var makeFlowContext = function makeFlowContext() {
                        return features.labels ? new FullFlowContext() : new LoopFlowContext();
                    };
                    var parseChunk = // Parse functions
                    // ---------------
                    // Chunk is the main program object. Syntactically it's the same as a block.
                    //
                    //     chunk ::= block
                    function parseChunk() {
                        next();
                        markLocation();
                        if (options.scope) createScope();
                        var flowContext = makeFlowContext();
                        flowContext.allowVararg = true;
                        flowContext.pushScope();
                        var body = parseBlock(flowContext);
                        flowContext.popScope();
                        if (options.scope) destroyScope();
                        if (EOF !== token.type) unexpected(token);
                        // If the body is empty no previousToken exists when finishNode runs.
                        if (trackLocations && !body.length) previousToken = token;
                        return finishNode(ast.chunk(body));
                    };
                    var parseBlock = // A block contains a list of statements with an optional return statement
                    // as its last statement.
                    //
                    //     block ::= {stat} [retstat]
                    function parseBlock(flowContext) {
                        var block = [], statement;
                        while(!isBlockFollow(token)){
                            // Return has to be the last statement in a block.
                            // Likewise 'break' in Lua older than 5.2
                            if ("return" === token.value || !features.relaxedBreak && "break" === token.value) {
                                block.push(parseStatement(flowContext));
                                break;
                            }
                            statement = parseStatement(flowContext);
                            consume(";");
                            // Statements are only added if they are returned, this allows us to
                            // ignore some statements, such as EmptyStatement.
                            if (statement) block.push(statement);
                        }
                        // Doesn't really need an ast node
                        return block;
                    };
                    var parseStatement = // There are two types of statements, simple and compound.
                    //
                    //     statement ::= break | goto | do | while | repeat | return
                    //          | if | for | function | local | label | assignment
                    //          | functioncall | ';'
                    function parseStatement(flowContext) {
                        markLocation();
                        if (Punctuator === token.type) {
                            if (consume("::")) return parseLabelStatement(flowContext);
                        }
                        // When a `;` is encounted, simply eat it without storing it.
                        if (features.emptyStatement) {
                            if (consume(";")) {
                                if (trackLocations) locations.pop();
                                return;
                            }
                        }
                        flowContext.raiseDeferredErrors();
                        if (Keyword === token.type) {
                            switch(token.value){
                                case "local":
                                    next();
                                    return parseLocalStatement(flowContext);
                                case "if":
                                    next();
                                    return parseIfStatement(flowContext);
                                case "return":
                                    next();
                                    return parseReturnStatement(flowContext);
                                case "function":
                                    next();
                                    var name = parseFunctionName();
                                    return parseFunctionDeclaration(name);
                                case "while":
                                    next();
                                    return parseWhileStatement(flowContext);
                                case "for":
                                    next();
                                    return parseForStatement(flowContext);
                                case "repeat":
                                    next();
                                    return parseRepeatStatement(flowContext);
                                case "break":
                                    next();
                                    if (!flowContext.isInLoop()) raise(token, errors.noLoopToBreak, token.value);
                                    return parseBreakStatement();
                                case "do":
                                    next();
                                    return parseDoStatement(flowContext);
                                case "goto":
                                    next();
                                    return parseGotoStatement(flowContext);
                            }
                        }
                        if (features.contextualGoto && token.type === Identifier && token.value === "goto" && lookahead.type === Identifier && lookahead.value !== "goto") {
                            next();
                            return parseGotoStatement(flowContext);
                        }
                        // Assignments memorizes the location and pushes it manually for wrapper nodes.
                        if (trackLocations) locations.pop();
                        return parseAssignmentOrCallStatement(flowContext);
                    };
                    var parseLabelStatement = // ## Statements
                    //     label ::= '::' Name '::'
                    function parseLabelStatement(flowContext) {
                        var nameToken = token, label = parseIdentifier();
                        if (options.scope) {
                            scopeIdentifierName("::" + nameToken.value + "::");
                            attachScope(label, true);
                        }
                        expect("::");
                        flowContext.addLabel(nameToken.value, nameToken);
                        return finishNode(ast.labelStatement(label));
                    };
                    var parseBreakStatement = //     break ::= 'break'
                    function parseBreakStatement() {
                        return finishNode(ast.breakStatement());
                    };
                    var parseGotoStatement = //     goto ::= 'goto' Name
                    function parseGotoStatement(flowContext) {
                        var name = token.value, gotoToken = previousToken, label = parseIdentifier();
                        flowContext.addGoto(name, gotoToken);
                        return finishNode(ast.gotoStatement(label));
                    };
                    var parseDoStatement = //     do ::= 'do' block 'end'
                    function parseDoStatement(flowContext) {
                        if (options.scope) createScope();
                        flowContext.pushScope();
                        var body = parseBlock(flowContext);
                        flowContext.popScope();
                        if (options.scope) destroyScope();
                        expect("end");
                        return finishNode(ast.doStatement(body));
                    };
                    var parseWhileStatement = //     while ::= 'while' exp 'do' block 'end'
                    function parseWhileStatement(flowContext) {
                        var condition = parseExpectedExpression(flowContext);
                        expect("do");
                        if (options.scope) createScope();
                        flowContext.pushScope(true);
                        var body = parseBlock(flowContext);
                        flowContext.popScope();
                        if (options.scope) destroyScope();
                        expect("end");
                        return finishNode(ast.whileStatement(condition, body));
                    };
                    var parseRepeatStatement = //     repeat ::= 'repeat' block 'until' exp
                    function parseRepeatStatement(flowContext) {
                        if (options.scope) createScope();
                        flowContext.pushScope(true);
                        var body = parseBlock(flowContext);
                        expect("until");
                        flowContext.raiseDeferredErrors();
                        var condition = parseExpectedExpression(flowContext);
                        flowContext.popScope();
                        if (options.scope) destroyScope();
                        return finishNode(ast.repeatStatement(condition, body));
                    };
                    var parseReturnStatement = //     retstat ::= 'return' [exp {',' exp}] [';']
                    function parseReturnStatement(flowContext) {
                        var expressions = [];
                        if ("end" !== token.value) {
                            var expression = parseExpression(flowContext);
                            if (null != expression) expressions.push(expression);
                            while(consume(",")){
                                expression = parseExpectedExpression(flowContext);
                                expressions.push(expression);
                            }
                            consume(";"); // grammar tells us ; is optional here.
                        }
                        return finishNode(ast.returnStatement(expressions));
                    };
                    var parseIfStatement = //     if ::= 'if' exp 'then' block {elif} ['else' block] 'end'
                    //     elif ::= 'elseif' exp 'then' block
                    function parseIfStatement(flowContext) {
                        var clauses = [], condition, body, marker;
                        // IfClauses begin at the same location as the parent IfStatement.
                        // It ends at the start of `end`, `else`, or `elseif`.
                        if (trackLocations) {
                            marker = locations[locations.length - 1];
                            locations.push(marker);
                        }
                        condition = parseExpectedExpression(flowContext);
                        expect("then");
                        if (options.scope) createScope();
                        flowContext.pushScope();
                        body = parseBlock(flowContext);
                        flowContext.popScope();
                        if (options.scope) destroyScope();
                        clauses.push(finishNode(ast.ifClause(condition, body)));
                        if (trackLocations) marker = createLocationMarker();
                        while(consume("elseif")){
                            pushLocation(marker);
                            condition = parseExpectedExpression(flowContext);
                            expect("then");
                            if (options.scope) createScope();
                            flowContext.pushScope();
                            body = parseBlock(flowContext);
                            flowContext.popScope();
                            if (options.scope) destroyScope();
                            clauses.push(finishNode(ast.elseifClause(condition, body)));
                            if (trackLocations) marker = createLocationMarker();
                        }
                        if (consume("else")) {
                            // Include the `else` in the location of ElseClause.
                            if (trackLocations) {
                                marker = new Marker(previousToken);
                                locations.push(marker);
                            }
                            if (options.scope) createScope();
                            flowContext.pushScope();
                            body = parseBlock(flowContext);
                            flowContext.popScope();
                            if (options.scope) destroyScope();
                            clauses.push(finishNode(ast.elseClause(body)));
                        }
                        expect("end");
                        return finishNode(ast.ifStatement(clauses));
                    };
                    var parseForStatement = // There are two types of for statements, generic and numeric.
                    //
                    //     for ::= Name '=' exp ',' exp [',' exp] 'do' block 'end'
                    //     for ::= namelist 'in' explist 'do' block 'end'
                    //     namelist ::= Name {',' Name}
                    //     explist ::= exp {',' exp}
                    function parseForStatement(flowContext) {
                        var variable = parseIdentifier(), body;
                        // The start-identifier is local.
                        if (options.scope) {
                            createScope();
                            scopeIdentifier(variable);
                        }
                        // If the first expression is followed by a `=` punctuator, this is a
                        // Numeric For Statement.
                        if (consume("=")) {
                            // Start expression
                            var start = parseExpectedExpression(flowContext);
                            expect(",");
                            // End expression
                            var end = parseExpectedExpression(flowContext);
                            // Optional step expression
                            var step = consume(",") ? parseExpectedExpression(flowContext) : null;
                            expect("do");
                            flowContext.pushScope(true);
                            body = parseBlock(flowContext);
                            flowContext.popScope();
                            expect("end");
                            if (options.scope) destroyScope();
                            return finishNode(ast.forNumericStatement(variable, start, end, step, body));
                        } else {
                            // The namelist can contain one or more identifiers.
                            var variables = [
                                variable
                            ];
                            while(consume(",")){
                                variable = parseIdentifier();
                                // Each variable in the namelist is locally scoped.
                                if (options.scope) scopeIdentifier(variable);
                                variables.push(variable);
                            }
                            expect("in");
                            var iterators = [];
                            // One or more expressions in the explist.
                            do {
                                var expression = parseExpectedExpression(flowContext);
                                iterators.push(expression);
                            }while (consume(","));
                            expect("do");
                            flowContext.pushScope(true);
                            body = parseBlock(flowContext);
                            flowContext.popScope();
                            expect("end");
                            if (options.scope) destroyScope();
                            return finishNode(ast.forGenericStatement(variables, iterators, body));
                        }
                    };
                    var parseLocalStatement = // Local statements can either be variable assignments or function
                    // definitions. If a function definition is found, it will be delegated to
                    // `parseFunctionDeclaration()` with the isLocal flag.
                    //
                    // This AST structure might change into a local assignment with a function
                    // child.
                    //
                    //     local ::= 'local' 'function' Name funcdecl
                    //        | 'local' Name {',' Name} ['=' exp {',' exp}]
                    function parseLocalStatement(flowContext) {
                        var name, declToken = previousToken;
                        if (Identifier === token.type) {
                            var variables = [], init = [];
                            do {
                                name = parseIdentifier();
                                variables.push(name);
                                flowContext.addLocal(name.name, declToken);
                            }while (consume(","));
                            if (consume("=")) {
                                do {
                                    var expression = parseExpectedExpression(flowContext);
                                    init.push(expression);
                                }while (consume(","));
                            }
                            // Declarations doesn't exist before the statement has been evaluated.
                            // Therefore assignments can't use their declarator. And the identifiers
                            // shouldn't be added to the scope until the statement is complete.
                            if (options.scope) {
                                for(var i = 0, l = variables.length; i < l; ++i){
                                    scopeIdentifier(variables[i]);
                                }
                            }
                            return finishNode(ast.localStatement(variables, init));
                        }
                        if (consume("function")) {
                            name = parseIdentifier();
                            flowContext.addLocal(name.name, declToken);
                            if (options.scope) {
                                scopeIdentifier(name);
                                createScope();
                            }
                            // MemberExpressions are not allowed in local function statements.
                            return parseFunctionDeclaration(name, true);
                        } else {
                            raiseUnexpectedToken("<name>", token);
                        }
                    };
                    var parseAssignmentOrCallStatement = //     assignment ::= varlist '=' explist
                    //     var ::= Name | prefixexp '[' exp ']' | prefixexp '.' Name
                    //     varlist ::= var {',' var}
                    //     explist ::= exp {',' exp}
                    //
                    //     call ::= callexp
                    //     callexp ::= prefixexp args | prefixexp ':' Name args
                    function parseAssignmentOrCallStatement(flowContext) {
                        // Keep a reference to the previous token for better error messages in case
                        // of invalid statement
                        var previous = token, marker, startMarker;
                        var lvalue, base, name;
                        var targets = [];
                        if (trackLocations) startMarker = createLocationMarker();
                        do {
                            if (trackLocations) marker = createLocationMarker();
                            if (Identifier === token.type) {
                                name = token.value;
                                base = parseIdentifier();
                                // Set the parent scope.
                                if (options.scope) attachScope(base, scopeHasName(name));
                                lvalue = true;
                            } else if ("(" === token.value) {
                                next();
                                base = parseExpectedExpression(flowContext);
                                expect(")");
                                lvalue = false;
                            } else {
                                return unexpected(token);
                            }
                            both: for(;;){
                                var newBase;
                                switch(StringLiteral === token.type ? '"' : token.value){
                                    case ".":
                                    case "[":
                                        lvalue = true;
                                        break;
                                    case ":":
                                    case "(":
                                    case "{":
                                    case '"':
                                        lvalue = null;
                                        break;
                                    default:
                                        break both;
                                }
                                base = parsePrefixExpressionPart(base, marker, flowContext);
                            }
                            targets.push(base);
                            if ("," !== token.value) break;
                            if (!lvalue) {
                                return unexpected(token);
                            }
                            next();
                        }while (true);
                        if (targets.length === 1 && lvalue === null) {
                            pushLocation(marker);
                            return finishNode(ast.callStatement(targets[0]));
                        } else if (!lvalue) {
                            return unexpected(token);
                        }
                        expect("=");
                        var values = [];
                        do {
                            values.push(parseExpectedExpression(flowContext));
                        }while (consume(","));
                        pushLocation(startMarker);
                        return finishNode(ast.assignmentStatement(targets, values));
                    };
                    var parseIdentifier = // ### Non-statements
                    //     Identifier ::= Name
                    function parseIdentifier() {
                        markLocation();
                        var identifier = token.value;
                        if (Identifier !== token.type) raiseUnexpectedToken("<name>", token);
                        next();
                        return finishNode(ast.identifier(identifier));
                    };
                    var parseFunctionDeclaration = // Parse the functions parameters and body block. The name should already
                    // have been parsed and passed to this declaration function. By separating
                    // this we allow for anonymous functions in expressions.
                    //
                    // For local functions there's a boolean parameter which needs to be set
                    // when parsing the declaration.
                    //
                    //     funcdecl ::= '(' [parlist] ')' block 'end'
                    //     parlist ::= Name {',' Name} | [',' '...'] | '...'
                    function parseFunctionDeclaration(name, isLocal) {
                        var flowContext = makeFlowContext();
                        flowContext.pushScope();
                        var parameters = [];
                        expect("(");
                        // The declaration has arguments
                        if (!consume(")")) {
                            // Arguments are a comma separated list of identifiers, optionally ending
                            // with a vararg.
                            while(true){
                                if (Identifier === token.type) {
                                    var parameter = parseIdentifier();
                                    // Function parameters are local.
                                    if (options.scope) scopeIdentifier(parameter);
                                    parameters.push(parameter);
                                    if (consume(",")) continue;
                                } else if (VarargLiteral === token.type) {
                                    flowContext.allowVararg = true;
                                    parameters.push(parsePrimaryExpression(flowContext));
                                } else {
                                    raiseUnexpectedToken("<name> or '...'", token);
                                }
                                expect(")");
                                break;
                            }
                        }
                        var body = parseBlock(flowContext);
                        flowContext.popScope();
                        expect("end");
                        if (options.scope) destroyScope();
                        isLocal = isLocal || false;
                        return finishNode(ast.functionStatement(name, parameters, isLocal, body));
                    };
                    var parseFunctionName = // Parse the function name as identifiers and member expressions.
                    //
                    //     Name {'.' Name} [':' Name]
                    function parseFunctionName() {
                        var base, name, marker;
                        if (trackLocations) marker = createLocationMarker();
                        base = parseIdentifier();
                        if (options.scope) {
                            attachScope(base, scopeHasName(base.name));
                            createScope();
                        }
                        while(consume(".")){
                            pushLocation(marker);
                            name = parseIdentifier();
                            base = finishNode(ast.memberExpression(base, ".", name));
                        }
                        if (consume(":")) {
                            pushLocation(marker);
                            name = parseIdentifier();
                            base = finishNode(ast.memberExpression(base, ":", name));
                            if (options.scope) scopeIdentifierName("self");
                        }
                        return base;
                    };
                    var parseTableConstructor = //     tableconstructor ::= '{' [fieldlist] '}'
                    //     fieldlist ::= field {fieldsep field} fieldsep
                    //     field ::= '[' exp ']' '=' exp | Name = 'exp' | exp
                    //
                    //     fieldsep ::= ',' | ';'
                    function parseTableConstructor(flowContext) {
                        var fields = [], key, value;
                        while(true){
                            markLocation();
                            if (Punctuator === token.type && consume("[")) {
                                key = parseExpectedExpression(flowContext);
                                expect("]");
                                expect("=");
                                value = parseExpectedExpression(flowContext);
                                fields.push(finishNode(ast.tableKey(key, value)));
                            } else if (Identifier === token.type) {
                                if ("=" === lookahead.value) {
                                    key = parseIdentifier();
                                    next();
                                    value = parseExpectedExpression(flowContext);
                                    fields.push(finishNode(ast.tableKeyString(key, value)));
                                } else {
                                    value = parseExpectedExpression(flowContext);
                                    fields.push(finishNode(ast.tableValue(value)));
                                }
                            } else {
                                if (null == (value = parseExpression(flowContext))) {
                                    locations.pop();
                                    break;
                                }
                                fields.push(finishNode(ast.tableValue(value)));
                            }
                            if (",;".indexOf(token.value) >= 0) {
                                next();
                                continue;
                            }
                            break;
                        }
                        expect("}");
                        return finishNode(ast.tableConstructorExpression(fields));
                    };
                    var parseExpression = // Expression parser
                    // -----------------
                    //
                    // Expressions are evaluated and always return a value. If nothing is
                    // matched null will be returned.
                    //
                    //     exp ::= (unop exp | primary | prefixexp ) { binop exp }
                    //
                    //     primary ::= nil | false | true | Number | String | '...'
                    //          | functiondef | tableconstructor
                    //
                    //     prefixexp ::= (Name | '(' exp ')' ) { '[' exp ']'
                    //          | '.' Name | ':' Name args | args }
                    //
                    function parseExpression(flowContext) {
                        var expression = parseSubExpression(0, flowContext);
                        return expression;
                    };
                    var parseExpectedExpression = // Parse an expression expecting it to be valid.
                    function parseExpectedExpression(flowContext) {
                        var expression = parseExpression(flowContext);
                        if (null == expression) raiseUnexpectedToken("<expression>", token);
                        else return expression;
                    };
                    var binaryPrecedence = // Return the precedence priority of the operator.
                    //
                    // As unary `-` can't be distinguished from binary `-`, unary precedence
                    // isn't described in this table but in `parseSubExpression()` itself.
                    //
                    // As this function gets hit on every expression it's been optimized due to
                    // the expensive CompareICStub which took ~8% of the parse time.
                    function binaryPrecedence(operator) {
                        var charCode = operator.charCodeAt(0), length = operator.length;
                        if (1 === length) {
                            switch(charCode){
                                case 94:
                                    return 12; // ^
                                case 42:
                                case 47:
                                case 37:
                                    return 10; // * / %
                                case 43:
                                case 45:
                                    return 9; // + -
                                case 38:
                                    return 6; // &
                                case 126:
                                    return 5; // ~
                                case 124:
                                    return 4; // |
                                case 60:
                                case 62:
                                    return 3; // < >
                            }
                        } else if (2 === length) {
                            switch(charCode){
                                case 47:
                                    return 10; // //
                                case 46:
                                    return 8; // ..
                                case 60:
                                case 62:
                                    if ("<<" === operator || ">>" === operator) return 7; // << >>
                                    return 3; // <= >=
                                case 61:
                                case 126:
                                    return 3; // == ~=
                                case 111:
                                    return 1; // or
                            }
                        } else if (97 === charCode && "and" === operator) return 2;
                        return 0;
                    };
                    var parsePrefixExpressionPart = //     prefixexp ::= prefix {suffix}
                    //     prefix ::= Name | '(' exp ')'
                    //     suffix ::= '[' exp ']' | '.' Name | ':' Name args | args
                    //
                    //     args ::= '(' [explist] ')' | tableconstructor | String
                    function parsePrefixExpressionPart(base, marker, flowContext) {
                        var expression, identifier;
                        if (Punctuator === token.type) {
                            switch(token.value){
                                case "[":
                                    pushLocation(marker);
                                    next();
                                    expression = parseExpectedExpression(flowContext);
                                    expect("]");
                                    return finishNode(ast.indexExpression(base, expression));
                                case ".":
                                    pushLocation(marker);
                                    next();
                                    identifier = parseIdentifier();
                                    return finishNode(ast.memberExpression(base, ".", identifier));
                                case ":":
                                    pushLocation(marker);
                                    next();
                                    identifier = parseIdentifier();
                                    base = finishNode(ast.memberExpression(base, ":", identifier));
                                    // Once a : is found, this has to be a CallExpression, otherwise
                                    // throw an error.
                                    pushLocation(marker);
                                    return parseCallExpression(base, flowContext);
                                case "(":
                                case "{":
                                    pushLocation(marker);
                                    return parseCallExpression(base, flowContext);
                            }
                        } else if (StringLiteral === token.type) {
                            pushLocation(marker);
                            return parseCallExpression(base, flowContext);
                        }
                        return null;
                    };
                    var parsePrefixExpression = function parsePrefixExpression(flowContext) {
                        var base, name, marker;
                        if (trackLocations) marker = createLocationMarker();
                        // The prefix
                        if (Identifier === token.type) {
                            name = token.value;
                            base = parseIdentifier();
                            // Set the parent scope.
                            if (options.scope) attachScope(base, scopeHasName(name));
                        } else if (consume("(")) {
                            base = parseExpectedExpression(flowContext);
                            expect(")");
                        } else {
                            return null;
                        }
                        // The suffix
                        for(;;){
                            var newBase = parsePrefixExpressionPart(base, marker, flowContext);
                            if (newBase === null) break;
                            base = newBase;
                        }
                        return base;
                    };
                    var parseCallExpression = //     args ::= '(' [explist] ')' | tableconstructor | String
                    function parseCallExpression(base, flowContext) {
                        if (Punctuator === token.type) {
                            switch(token.value){
                                case "(":
                                    if (!features.emptyStatement) {
                                        if (token.line !== previousToken.line) raise(null, errors.ambiguousSyntax, token.value);
                                    }
                                    next();
                                    // List of expressions
                                    var expressions = [];
                                    var expression = parseExpression(flowContext);
                                    if (null != expression) expressions.push(expression);
                                    while(consume(",")){
                                        expression = parseExpectedExpression(flowContext);
                                        expressions.push(expression);
                                    }
                                    expect(")");
                                    return finishNode(ast.callExpression(base, expressions));
                                case "{":
                                    markLocation();
                                    next();
                                    var table = parseTableConstructor(flowContext);
                                    return finishNode(ast.tableCallExpression(base, table));
                            }
                        } else if (StringLiteral === token.type) {
                            return finishNode(ast.stringCallExpression(base, parsePrimaryExpression(flowContext)));
                        }
                        raiseUnexpectedToken("function arguments", token);
                    };
                    var parsePrimaryExpression = //     primary ::= String | Numeric | nil | true | false
                    //          | functiondef | tableconstructor | '...'
                    function parsePrimaryExpression(flowContext) {
                        var literals = StringLiteral | NumericLiteral | BooleanLiteral | NilLiteral | VarargLiteral, value = token.value, type = token.type, marker;
                        if (trackLocations) marker = createLocationMarker();
                        if (type === VarargLiteral && !flowContext.allowVararg) {
                            raise(token, errors.cannotUseVararg, token.value);
                        }
                        if (type & literals) {
                            pushLocation(marker);
                            var raw = input.slice(token.range[0], token.range[1]);
                            next();
                            return finishNode(ast.literal(type, value, raw));
                        } else if (Keyword === type && "function" === value) {
                            pushLocation(marker);
                            next();
                            if (options.scope) createScope();
                            return parseFunctionDeclaration(null);
                        } else if (consume("{")) {
                            pushLocation(marker);
                            return parseTableConstructor(flowContext);
                        }
                    };
                    var parse = function parse(_input, _options) {
                        if ("undefined" === typeof _options && "object" === typeof _input) {
                            _options = _input;
                            _input = undefined;
                        }
                        if (!_options) _options = {};
                        input = _input || "";
                        options = assign({}, defaultOptions, _options);
                        // Rewind the lexer
                        index = 0;
                        line = 1;
                        lineStart = 0;
                        length = input.length;
                        // When tracking identifier scope, initialize with an empty scope.
                        scopes = [
                            []
                        ];
                        scopeDepth = 0;
                        globals = [];
                        locations = [];
                        if (!Object.prototype.hasOwnProperty.call(versionFeatures, options.luaVersion)) {
                            throw new Error(sprintf("Lua version '%1' not supported", options.luaVersion));
                        }
                        features = assign({}, versionFeatures[options.luaVersion]);
                        if (options.extendedIdentifiers !== void 0) features.extendedIdentifiers = !!options.extendedIdentifiers;
                        if (!Object.prototype.hasOwnProperty.call(encodingModes, options.encodingMode)) {
                            throw new Error(sprintf("Encoding mode '%1' not supported", options.encodingMode));
                        }
                        encodingMode = encodingModes[options.encodingMode];
                        if (options.comments) comments = [];
                        if (!options.wait) return end();
                        return exports1;
                    };
                    var write = function write(_input) {
                        input += String(_input);
                        length = input.length;
                        return exports1;
                    };
                    var end = function end(_input) {
                        if ("undefined" !== typeof _input) write(_input);
                        // Ignore shebangs.
                        if (input && input.substr(0, 2) === "#!") input = input.replace(/^.*/, function(line) {
                            return line.replace(/./g, " ");
                        });
                        length = input.length;
                        trackLocations = options.locations || options.ranges;
                        // Initialize with a lookahead token.
                        lookahead = lex();
                        var chunk = parseChunk();
                        if (options.comments) chunk.comments = comments;
                        if (options.scope) chunk.globals = globals;
                        /* istanbul ignore if */ if (locations.length > 0) throw new Error("Location tracking failed. This is most likely a bug in luaparse");
                        return chunk;
                    };
                    exports1.version = "0.3.1";
                    var input, options, length, features, encodingMode;
                    // Options can be set either globally on the parser object through
                    // defaultOptions, or during the parse call.
                    var defaultOptions = exports1.defaultOptions = {
                        // Explicitly tell the parser when the input ends.
                        wait: false,
                        comments: true,
                        scope: false,
                        locations: false,
                        ranges: false,
                        onCreateNode: null,
                        onCreateScope: null,
                        onDestroyScope: null,
                        onLocalDeclaration: null,
                        luaVersion: "5.1",
                        encodingMode: "none"
                    };
                    var encodingModes = {
                        // `pseudo-latin1` encoding mode: assume the input was decoded with the latin1 encoding
                        // WARNING: latin1 does **NOT** mean cp1252 here like in the bone-headed WHATWG standard;
                        // it means true ISO/IEC 8859-1 identity-mapped to Basic Latin and Latin-1 Supplement blocks
                        "pseudo-latin1": {
                            fixup: checkChars(/[^\x00-\xff]/),
                            encodeByte: function encodeByte(value) {
                                if (value === null) return "";
                                return String.fromCharCode(value);
                            },
                            encodeUTF8: function encodeUTF81(codepoint) {
                                return encodeUTF8(codepoint);
                            }
                        },
                        // `x-user-defined` encoding mode: assume the input was decoded with the WHATWG `x-user-defined` encoding
                        "x-user-defined": {
                            fixup: checkChars(/[^\x00-\x7f\uf780-\uf7ff]/),
                            encodeByte: function encodeByte(value) {
                                if (value === null) return "";
                                if (value >= 0x80) return String.fromCharCode(value | 0xf700);
                                return String.fromCharCode(value);
                            },
                            encodeUTF8: function encodeUTF81(codepoint) {
                                return encodeUTF8(codepoint, 0xf700);
                            }
                        },
                        // `none` encoding mode: disregard intrepretation of string literals, leave identifiers as-is
                        "none": {
                            discardStrings: true,
                            fixup: function fixup(s) {
                                return s;
                            },
                            encodeByte: function encodeByte(value) {
                                return "";
                            },
                            encodeUTF8: function encodeUTF8(codepoint) {
                                return "";
                            }
                        }
                    };
                    // The available tokens expressed as enum flags so they can be checked with
                    // bitwise operations.
                    var EOF = 1, StringLiteral = 2, Keyword = 4, Identifier = 8, NumericLiteral = 16, Punctuator = 32, BooleanLiteral = 64, NilLiteral = 128, VarargLiteral = 256;
                    exports1.tokenTypes = {
                        EOF: EOF,
                        StringLiteral: StringLiteral,
                        Keyword: Keyword,
                        Identifier: Identifier,
                        NumericLiteral: NumericLiteral,
                        Punctuator: Punctuator,
                        BooleanLiteral: BooleanLiteral,
                        NilLiteral: NilLiteral,
                        VarargLiteral: VarargLiteral
                    };
                    // As this parser is a bit different from luas own, the error messages
                    // will be different in some situations.
                    var errors = exports1.errors = {
                        unexpected: "unexpected %1 '%2' near '%3'",
                        unexpectedEOF: "unexpected symbol near '<eof>'",
                        expected: "'%1' expected near '%2'",
                        expectedToken: "%1 expected near '%2'",
                        unfinishedString: "unfinished string near '%1'",
                        malformedNumber: "malformed number near '%1'",
                        decimalEscapeTooLarge: "decimal escape too large near '%1'",
                        invalidEscape: "invalid escape sequence near '%1'",
                        hexadecimalDigitExpected: "hexadecimal digit expected near '%1'",
                        braceExpected: "missing '%1' near '%2'",
                        tooLargeCodepoint: "UTF-8 value too large near '%1'",
                        unfinishedLongString: "unfinished long string (starting at line %1) near '%2'",
                        unfinishedLongComment: "unfinished long comment (starting at line %1) near '%2'",
                        ambiguousSyntax: "ambiguous syntax (function call x new statement) near '%1'",
                        noLoopToBreak: "no loop to break near '%1'",
                        labelAlreadyDefined: "label '%1' already defined on line %2",
                        labelNotVisible: "no visible label '%1' for <goto>",
                        gotoJumpInLocalScope: "<goto %1> jumps into the scope of local '%2'",
                        cannotUseVararg: "cannot use '...' outside a vararg function near '%1'",
                        invalidCodeUnit: "code unit U+%1 is not allowed in the current encoding mode"
                    };
                    // ### Abstract Syntax Tree
                    //
                    // The default AST structure is inspired by the Mozilla Parser API but can
                    // easily be customized by overriding these functions.
                    var ast = exports1.ast = {
                        labelStatement: function labelStatement(label) {
                            return {
                                type: "LabelStatement",
                                label: label
                            };
                        },
                        breakStatement: function breakStatement() {
                            return {
                                type: "BreakStatement"
                            };
                        },
                        gotoStatement: function gotoStatement(label) {
                            return {
                                type: "GotoStatement",
                                label: label
                            };
                        },
                        returnStatement: function returnStatement(args) {
                            return {
                                type: "ReturnStatement",
                                "arguments": args
                            };
                        },
                        ifStatement: function ifStatement(clauses) {
                            return {
                                type: "IfStatement",
                                clauses: clauses
                            };
                        },
                        ifClause: function ifClause(condition, body) {
                            return {
                                type: "IfClause",
                                condition: condition,
                                body: body
                            };
                        },
                        elseifClause: function elseifClause(condition, body) {
                            return {
                                type: "ElseifClause",
                                condition: condition,
                                body: body
                            };
                        },
                        elseClause: function elseClause(body) {
                            return {
                                type: "ElseClause",
                                body: body
                            };
                        },
                        whileStatement: function whileStatement(condition, body) {
                            return {
                                type: "WhileStatement",
                                condition: condition,
                                body: body
                            };
                        },
                        doStatement: function doStatement(body) {
                            return {
                                type: "DoStatement",
                                body: body
                            };
                        },
                        repeatStatement: function repeatStatement(condition, body) {
                            return {
                                type: "RepeatStatement",
                                condition: condition,
                                body: body
                            };
                        },
                        localStatement: function localStatement(variables, init) {
                            return {
                                type: "LocalStatement",
                                variables: variables,
                                init: init
                            };
                        },
                        assignmentStatement: function assignmentStatement(variables, init) {
                            return {
                                type: "AssignmentStatement",
                                variables: variables,
                                init: init
                            };
                        },
                        callStatement: function callStatement(expression) {
                            return {
                                type: "CallStatement",
                                expression: expression
                            };
                        },
                        functionStatement: function functionStatement(identifier, parameters, isLocal, body) {
                            return {
                                type: "FunctionDeclaration",
                                identifier: identifier,
                                isLocal: isLocal,
                                parameters: parameters,
                                body: body
                            };
                        },
                        forNumericStatement: function forNumericStatement(variable, start, end, step, body) {
                            return {
                                type: "ForNumericStatement",
                                variable: variable,
                                start: start,
                                end: end,
                                step: step,
                                body: body
                            };
                        },
                        forGenericStatement: function forGenericStatement(variables, iterators, body) {
                            return {
                                type: "ForGenericStatement",
                                variables: variables,
                                iterators: iterators,
                                body: body
                            };
                        },
                        chunk: function chunk(body) {
                            return {
                                type: "Chunk",
                                body: body
                            };
                        },
                        identifier: function identifier(name) {
                            return {
                                type: "Identifier",
                                name: name
                            };
                        },
                        literal: function literal(type, value, raw) {
                            type = type === StringLiteral ? "StringLiteral" : type === NumericLiteral ? "NumericLiteral" : type === BooleanLiteral ? "BooleanLiteral" : type === NilLiteral ? "NilLiteral" : "VarargLiteral";
                            return {
                                type: type,
                                value: value,
                                raw: raw
                            };
                        },
                        tableKey: function tableKey(key, value) {
                            return {
                                type: "TableKey",
                                key: key,
                                value: value
                            };
                        },
                        tableKeyString: function tableKeyString(key, value) {
                            return {
                                type: "TableKeyString",
                                key: key,
                                value: value
                            };
                        },
                        tableValue: function tableValue(value) {
                            return {
                                type: "TableValue",
                                value: value
                            };
                        },
                        tableConstructorExpression: function tableConstructorExpression(fields) {
                            return {
                                type: "TableConstructorExpression",
                                fields: fields
                            };
                        },
                        binaryExpression: function binaryExpression(operator, left, right) {
                            var type = "and" === operator || "or" === operator ? "LogicalExpression" : "BinaryExpression";
                            return {
                                type: type,
                                operator: operator,
                                left: left,
                                right: right
                            };
                        },
                        unaryExpression: function unaryExpression(operator, argument) {
                            return {
                                type: "UnaryExpression",
                                operator: operator,
                                argument: argument
                            };
                        },
                        memberExpression: function memberExpression(base, indexer, identifier) {
                            return {
                                type: "MemberExpression",
                                indexer: indexer,
                                identifier: identifier,
                                base: base
                            };
                        },
                        indexExpression: function indexExpression(base, index) {
                            return {
                                type: "IndexExpression",
                                base: base,
                                index: index
                            };
                        },
                        callExpression: function callExpression(base, args) {
                            return {
                                type: "CallExpression",
                                base: base,
                                "arguments": args
                            };
                        },
                        tableCallExpression: function tableCallExpression(base, args) {
                            return {
                                type: "TableCallExpression",
                                base: base,
                                "arguments": args
                            };
                        },
                        stringCallExpression: function stringCallExpression(base, argument) {
                            return {
                                type: "StringCallExpression",
                                base: base,
                                argument: argument
                            };
                        },
                        comment: function comment(value, raw) {
                            return {
                                type: "Comment",
                                value: value,
                                raw: raw
                            };
                        }
                    };
                    // Helpers
                    // -------
                    var slice = Array.prototype.slice, toString = Object.prototype.toString;
                    var indexOf = /* istanbul ignore next */ function indexOf(array, element) {
                        for(var i = 0, length = array.length; i < length; ++i){
                            if (array[i] === element) return i;
                        }
                        return -1;
                    };
                    /* istanbul ignore else */ if (Array.prototype.indexOf) indexOf = function indexOf(array, element) {
                        return array.indexOf(element);
                    };
                    // Polyfill for `Object.assign`.
                    var assign = /* istanbul ignore next */ function assign(dest) {
                        var args = slice.call(arguments, 1), src, prop;
                        for(var i = 0, length = args.length; i < length; ++i){
                            src = args[i];
                            for(prop in src)/* istanbul ignore else */ if (Object.prototype.hasOwnProperty.call(src, prop)) {
                                dest[prop] = src[prop];
                            }
                        }
                        return dest;
                    };
                    /* istanbul ignore else */ if (Object.assign) assign = Object.assign;
                    // ### Error functions
                    exports1.SyntaxError = SyntaxError;
                    // Lexer
                    // -----
                    //
                    // The lexer, or the tokenizer reads the input string character by character
                    // and derives a token left-right. To be as efficient as possible the lexer
                    // prioritizes the common cases such as identifiers. It also works with
                    // character codes instead of characters as string comparisons was the
                    // biggest bottleneck of the parser.
                    //
                    // If `options.comments` is enabled, all comments encountered will be stored
                    // in an array which later will be appended to the chunk object. If disabled,
                    // they will simply be disregarded.
                    //
                    // When the lexer has derived a valid token, it will be returned as an object
                    // containing its value and as well as its position in the input string (this
                    // is always enabled to provide proper debug messages).
                    //
                    // `lex()` starts lexing and returns the following token in the stream.
                    var index, token, previousToken, lookahead, comments, tokenStart, line, lineStart;
                    exports1.lex = lex;
                    // Scope
                    // -----
                    // Store each block scope as a an array of identifier names. Each scope is
                    // stored in an FILO-array.
                    var scopes, scopeDepth, globals;
                    // Location tracking
                    // -----------------
                    //
                    // Locations are stored in FILO-array as a `Marker` object consisting of both
                    // `loc` and `range` data. Once a `Marker` is popped off the list an end
                    // location is added and the data is attached to a syntax node.
                    var locations = [], trackLocations;
                    // Complete the location data stored in the `Marker` by adding the location
                    // of the *previous token* as an end location.
                    Marker.prototype.complete = function() {
                        if (options.locations) {
                            this.loc.end.line = previousToken.lastLine || previousToken.line;
                            this.loc.end.column = previousToken.range[1] - (previousToken.lastLineStart || previousToken.lineStart);
                        }
                        if (options.ranges) {
                            this.range[1] = previousToken.range[1];
                        }
                    };
                    Marker.prototype.bless = function(node) {
                        if (this.loc) {
                            var loc = this.loc;
                            node.loc = {
                                start: {
                                    line: loc.start.line,
                                    column: loc.start.column
                                },
                                end: {
                                    line: loc.end.line,
                                    column: loc.end.column
                                }
                            };
                        }
                        if (this.range) {
                            node.range = [
                                this.range[0],
                                this.range[1]
                            ];
                        }
                    };
                    FullFlowContext.prototype.isInLoop = function() {
                        var i = this.scopes.length;
                        while(i-- > 0){
                            if (this.scopes[i].isLoop) return true;
                        }
                        return false;
                    };
                    FullFlowContext.prototype.pushScope = function(isLoop) {
                        var scope = {
                            labels: {},
                            locals: [],
                            deferredGotos: [],
                            isLoop: !!isLoop
                        };
                        this.scopes.push(scope);
                    };
                    FullFlowContext.prototype.popScope = function() {
                        for(var i = 0; i < this.pendingGotos.length; ++i){
                            var theGoto = this.pendingGotos[i];
                            if (theGoto.maxDepth >= this.scopes.length) {
                                if (--theGoto.maxDepth <= 0) raise(theGoto.token, errors.labelNotVisible, theGoto.target);
                            }
                        }
                        this.scopes.pop();
                    };
                    FullFlowContext.prototype.addGoto = function(target, token) {
                        var localCounts = [];
                        for(var i = 0; i < this.scopes.length; ++i){
                            var scope = this.scopes[i];
                            localCounts.push(scope.locals.length);
                            if (Object.prototype.hasOwnProperty.call(scope.labels, target)) return;
                        }
                        this.pendingGotos.push({
                            maxDepth: this.scopes.length,
                            target: target,
                            token: token,
                            localCounts: localCounts
                        });
                    };
                    FullFlowContext.prototype.addLabel = function(name, token) {
                        var scope = this.currentScope();
                        if (Object.prototype.hasOwnProperty.call(scope.labels, name)) {
                            raise(token, errors.labelAlreadyDefined, name, scope.labels[name].line);
                        } else {
                            var newGotos = [];
                            for(var i = 0; i < this.pendingGotos.length; ++i){
                                var theGoto = this.pendingGotos[i];
                                if (theGoto.maxDepth >= this.scopes.length && theGoto.target === name) {
                                    if (theGoto.localCounts[this.scopes.length - 1] < scope.locals.length) {
                                        scope.deferredGotos.push(theGoto);
                                    }
                                    continue;
                                }
                                newGotos.push(theGoto);
                            }
                            this.pendingGotos = newGotos;
                        }
                        scope.labels[name] = {
                            localCount: scope.locals.length,
                            line: token.line
                        };
                    };
                    FullFlowContext.prototype.addLocal = function(name, token) {
                        this.currentScope().locals.push({
                            name: name,
                            token: token
                        });
                    };
                    FullFlowContext.prototype.currentScope = function() {
                        return this.scopes[this.scopes.length - 1];
                    };
                    FullFlowContext.prototype.raiseDeferredErrors = function() {
                        var scope = this.currentScope();
                        var bads = scope.deferredGotos;
                        for(var i = 0; i < bads.length; ++i){
                            var theGoto = bads[i];
                            raise(theGoto.token, errors.gotoJumpInLocalScope, theGoto.target, scope.locals[theGoto.localCounts[this.scopes.length - 1]].name);
                        }
                    // Would be dead code currently, but may be useful later
                    // if (bads.length)
                    //   scope.deferredGotos = [];
                    };
                    LoopFlowContext.prototype.isInLoop = function() {
                        return !!this.loopLevels.length;
                    };
                    LoopFlowContext.prototype.pushScope = function(isLoop) {
                        ++this.level;
                        if (isLoop) this.loopLevels.push(this.level);
                    };
                    LoopFlowContext.prototype.popScope = function() {
                        var levels = this.loopLevels;
                        var levlen = levels.length;
                        if (levlen) {
                            if (levels[levlen - 1] === this.level) levels.pop();
                        }
                        --this.level;
                    };
                    LoopFlowContext.prototype.addGoto = LoopFlowContext.prototype.addLabel = /* istanbul ignore next */ function() {
                        throw new Error("This should never happen");
                    };
                    LoopFlowContext.prototype.addLocal = LoopFlowContext.prototype.raiseDeferredErrors = function() {};
                    // Implement an operator-precedence parser to handle binary operator
                    // precedence.
                    //
                    // We use this algorithm because it's compact, it's fast and Lua core uses
                    // the same so we can be sure our expressions are parsed in the same manner
                    // without excessive amounts of tests.
                    //
                    //     exp ::= (unop exp | primary | prefixexp ) { binop exp }
                    function parseSubExpression(minPrecedence, flowContext) {
                        var operator = token.value, expression, marker;
                        if (trackLocations) marker = createLocationMarker();
                        // UnaryExpression
                        if (isUnary(token)) {
                            markLocation();
                            next();
                            var argument = parseSubExpression(10, flowContext);
                            if (argument == null) raiseUnexpectedToken("<expression>", token);
                            expression = finishNode(ast.unaryExpression(operator, argument));
                        }
                        if (null == expression) {
                            // PrimaryExpression
                            expression = parsePrimaryExpression(flowContext);
                            // PrefixExpression
                            if (null == expression) {
                                expression = parsePrefixExpression(flowContext);
                            }
                        }
                        // This is not a valid left hand expression.
                        if (null == expression) return null;
                        var precedence;
                        while(true){
                            operator = token.value;
                            precedence = Punctuator === token.type || Keyword === token.type ? binaryPrecedence(operator) : 0;
                            if (precedence === 0 || precedence <= minPrecedence) break;
                            // Right-hand precedence operators
                            if ("^" === operator || ".." === operator) --precedence;
                            next();
                            var right = parseSubExpression(precedence, flowContext);
                            if (null == right) raiseUnexpectedToken("<expression>", token);
                            // Push in the marker created before the loop to wrap its entirety.
                            if (trackLocations) locations.push(marker);
                            expression = finishNode(ast.binaryExpression(operator, expression, right));
                        }
                        return expression;
                    }
                    // Parser
                    // ------
                    // Export the main parser.
                    //
                    //   - `wait` Hold parsing until end() is called. Defaults to false
                    //   - `comments` Store comments. Defaults to true.
                    //   - `scope` Track identifier scope. Defaults to false.
                    //   - `locations` Store location information. Defaults to false.
                    //   - `ranges` Store the start and end character locations. Defaults to
                    //     false.
                    //   - `onCreateNode` Callback which will be invoked when a syntax node is
                    //     created.
                    //   - `onCreateScope` Callback which will be invoked when a new scope is
                    //     created.
                    //   - `onDestroyScope` Callback which will be invoked when the current scope
                    //     is destroyed.
                    //
                    // Example:
                    //
                    //     var parser = require('luaparser');
                    //     parser.parse('i = 0');
                    exports1.parse = parse;
                    var versionFeatures = {
                        "5.1": {},
                        "5.2": {
                            labels: true,
                            emptyStatement: true,
                            hexEscapes: true,
                            skipWhitespaceEscape: true,
                            strictEscapes: true,
                            relaxedBreak: true
                        },
                        "5.3": {
                            labels: true,
                            emptyStatement: true,
                            hexEscapes: true,
                            skipWhitespaceEscape: true,
                            strictEscapes: true,
                            unicodeEscapes: true,
                            bitwiseOperators: true,
                            integerDivision: true,
                            relaxedBreak: true
                        },
                        "LuaJIT": {
                            // XXX: LuaJIT language features may depend on compilation options; may need to
                            // rethink how to handle this. Specifically, there is a LUAJIT_ENABLE_LUA52COMPAT
                            // that removes contextual goto. Maybe add 'LuaJIT-5.2compat' as well?
                            labels: true,
                            contextualGoto: true,
                            hexEscapes: true,
                            skipWhitespaceEscape: true,
                            strictEscapes: true,
                            unicodeEscapes: true,
                            imaginaryNumbers: true,
                            integerSuffixes: true
                        }
                    };
                    // Write to the source code buffer without beginning the parse.
                    exports1.write = write;
                    // Send an EOF and begin parsing.
                    exports1.end = end;
                });
            /* vim: set sw=2 ts=2 et tw=79 : */ /***/ },
            /***/ 8169: /***/ function(module1) {
                "use strict";
                var numberIsNaN = function numberIsNaN(value) {
                    return value !== value;
                };
                module1.exports = function is(a, b) {
                    if (a === 0 && b === 0) {
                        return 1 / a === 1 / b;
                    }
                    if (a === b) {
                        return true;
                    }
                    if (numberIsNaN(a) && numberIsNaN(b)) {
                        return true;
                    }
                    return false;
                };
            /***/ },
            /***/ 4679: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_1679339__) {
                "use strict";
                var define1 = __nested_webpack_require_1679339__(4926);
                var callBind = __nested_webpack_require_1679339__(9429);
                var implementation = __nested_webpack_require_1679339__(8169);
                var getPolyfill = __nested_webpack_require_1679339__(8070);
                var shim = __nested_webpack_require_1679339__(191);
                var polyfill = callBind(getPolyfill(), Object);
                define1(polyfill, {
                    getPolyfill: getPolyfill,
                    implementation: implementation,
                    shim: shim
                });
                module1.exports = polyfill;
            /***/ },
            /***/ 8070: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_1680073__) {
                "use strict";
                var implementation = __nested_webpack_require_1680073__(8169);
                module1.exports = function getPolyfill() {
                    return typeof Object.is === "function" ? Object.is : implementation;
                };
            /***/ },
            /***/ 191: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_1680451__) {
                "use strict";
                var getPolyfill = __nested_webpack_require_1680451__(8070);
                var define1 = __nested_webpack_require_1680451__(4926);
                module1.exports = function shimObjectIs() {
                    var polyfill = getPolyfill();
                    define1(Object, {
                        is: polyfill
                    }, {
                        is: function testObjectIs() {
                            return Object.is !== polyfill;
                        }
                    });
                    return polyfill;
                };
            /***/ },
            /***/ 5691: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_1681146__) {
                "use strict";
                var keysShim;
                if (!Object.keys) {
                    // modified from https://github.com/es-shims/es5-shim
                    var has = Object.prototype.hasOwnProperty;
                    var toStr = Object.prototype.toString;
                    var isArgs = __nested_webpack_require_1681146__(801); // eslint-disable-line global-require
                    var isEnumerable = Object.prototype.propertyIsEnumerable;
                    var hasDontEnumBug = !isEnumerable.call({
                        toString: null
                    }, "toString");
                    var hasProtoEnumBug = isEnumerable.call(function() {}, "prototype");
                    var dontEnums = [
                        "toString",
                        "toLocaleString",
                        "valueOf",
                        "hasOwnProperty",
                        "isPrototypeOf",
                        "propertyIsEnumerable",
                        "constructor"
                    ];
                    var equalsConstructorPrototype = function equalsConstructorPrototype(o) {
                        var ctor = o.constructor;
                        return ctor && ctor.prototype === o;
                    };
                    var excludedKeys = {
                        $applicationCache: true,
                        $console: true,
                        $external: true,
                        $frame: true,
                        $frameElement: true,
                        $frames: true,
                        $innerHeight: true,
                        $innerWidth: true,
                        $onmozfullscreenchange: true,
                        $onmozfullscreenerror: true,
                        $outerHeight: true,
                        $outerWidth: true,
                        $pageXOffset: true,
                        $pageYOffset: true,
                        $parent: true,
                        $scrollLeft: true,
                        $scrollTop: true,
                        $scrollX: true,
                        $scrollY: true,
                        $self: true,
                        $webkitIndexedDB: true,
                        $webkitStorageInfo: true,
                        $window: true
                    };
                    var hasAutomationEqualityBug = function() {
                        /* global window */ if (typeof window === "undefined") {
                            return false;
                        }
                        for(var k in window){
                            try {
                                if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
                                    try {
                                        equalsConstructorPrototype(window[k]);
                                    } catch (e) {
                                        return true;
                                    }
                                }
                            } catch (e) {
                                return true;
                            }
                        }
                        return false;
                    }();
                    var equalsConstructorPrototypeIfNotBuggy = function equalsConstructorPrototypeIfNotBuggy(o) {
                        /* global window */ if (typeof window === "undefined" || !hasAutomationEqualityBug) {
                            return equalsConstructorPrototype(o);
                        }
                        try {
                            return equalsConstructorPrototype(o);
                        } catch (e) {
                            return false;
                        }
                    };
                    keysShim = function keys(object) {
                        var isObject = object !== null && typeof object === "object";
                        var isFunction = toStr.call(object) === "[object Function]";
                        var isArguments = isArgs(object);
                        var isString = isObject && toStr.call(object) === "[object String]";
                        var theKeys = [];
                        if (!isObject && !isFunction && !isArguments) {
                            throw new TypeError("Object.keys called on a non-object");
                        }
                        var skipProto = hasProtoEnumBug && isFunction;
                        if (isString && object.length > 0 && !has.call(object, 0)) {
                            for(var i = 0; i < object.length; ++i){
                                theKeys.push(String(i));
                            }
                        }
                        if (isArguments && object.length > 0) {
                            for(var j = 0; j < object.length; ++j){
                                theKeys.push(String(j));
                            }
                        } else {
                            for(var name in object){
                                if (!(skipProto && name === "prototype") && has.call(object, name)) {
                                    theKeys.push(String(name));
                                }
                            }
                        }
                        if (hasDontEnumBug) {
                            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
                            for(var k = 0; k < dontEnums.length; ++k){
                                if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
                                    theKeys.push(dontEnums[k]);
                                }
                            }
                        }
                        return theKeys;
                    };
                }
                module1.exports = keysShim;
            /***/ },
            /***/ 3464: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_1687186__) {
                "use strict";
                var slice = Array.prototype.slice;
                var isArgs = __nested_webpack_require_1687186__(801);
                var origKeys = Object.keys;
                var keysShim = origKeys ? function keys(o) {
                    return origKeys(o);
                } : __nested_webpack_require_1687186__(5691);
                var originalKeys = Object.keys;
                keysShim.shim = function shimObjectKeys() {
                    if (Object.keys) {
                        var keysWorksWithArguments = function() {
                            // Safari 5.0 bug
                            var args = Object.keys(arguments);
                            return args && args.length === arguments.length;
                        }(1, 2);
                        if (!keysWorksWithArguments) {
                            Object.keys = function keys(object) {
                                if (isArgs(object)) {
                                    return originalKeys(slice.call(object));
                                }
                                return originalKeys(object);
                            };
                        }
                    } else {
                        Object.keys = keysShim;
                    }
                    return Object.keys || keysShim;
                };
                module1.exports = keysShim;
            /***/ },
            /***/ 801: /***/ function(module1) {
                "use strict";
                var toStr = Object.prototype.toString;
                module1.exports = function isArguments(value) {
                    var str = toStr.call(value);
                    var isArgs = str === "[object Arguments]";
                    if (!isArgs) {
                        isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
                    }
                    return isArgs;
                };
            /***/ },
            /***/ 4406: /***/ function(module1) {
                var defaultSetTimout = function defaultSetTimout() {
                    throw new Error("setTimeout has not been defined");
                };
                var defaultClearTimeout = function defaultClearTimeout() {
                    throw new Error("clearTimeout has not been defined");
                };
                var runTimeout = function runTimeout(fun) {
                    if (cachedSetTimeout === setTimeout) {
                        //normal enviroments in sane situations
                        return setTimeout(fun, 0);
                    }
                    // if setTimeout wasn't available but was latter defined
                    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                        cachedSetTimeout = setTimeout;
                        return setTimeout(fun, 0);
                    }
                    try {
                        // when when somebody has screwed with setTimeout but no I.E. maddness
                        return cachedSetTimeout(fun, 0);
                    } catch (e) {
                        try {
                            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                            return cachedSetTimeout.call(null, fun, 0);
                        } catch (e) {
                            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                            return cachedSetTimeout.call(this, fun, 0);
                        }
                    }
                };
                var runClearTimeout = function runClearTimeout(marker) {
                    if (cachedClearTimeout === clearTimeout) {
                        //normal enviroments in sane situations
                        return clearTimeout(marker);
                    }
                    // if clearTimeout wasn't available but was latter defined
                    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                        cachedClearTimeout = clearTimeout;
                        return clearTimeout(marker);
                    }
                    try {
                        // when when somebody has screwed with setTimeout but no I.E. maddness
                        return cachedClearTimeout(marker);
                    } catch (e) {
                        try {
                            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                            return cachedClearTimeout.call(null, marker);
                        } catch (e) {
                            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                            return cachedClearTimeout.call(this, marker);
                        }
                    }
                };
                var cleanUpNextTick = function cleanUpNextTick() {
                    if (!draining || !currentQueue) {
                        return;
                    }
                    draining = false;
                    if (currentQueue.length) {
                        queue = currentQueue.concat(queue);
                    } else {
                        queueIndex = -1;
                    }
                    if (queue.length) {
                        drainQueue();
                    }
                };
                var drainQueue = function drainQueue() {
                    if (draining) {
                        return;
                    }
                    var timeout = runTimeout(cleanUpNextTick);
                    draining = true;
                    var len = queue.length;
                    while(len){
                        currentQueue = queue;
                        queue = [];
                        while(++queueIndex < len){
                            if (currentQueue) {
                                currentQueue[queueIndex].run();
                            }
                        }
                        queueIndex = -1;
                        len = queue.length;
                    }
                    currentQueue = null;
                    draining = false;
                    runClearTimeout(timeout);
                };
                var Item = // v8 likes predictible objects
                function Item(fun, array) {
                    this.fun = fun;
                    this.array = array;
                };
                var noop = function noop() {};
                // shim for using process in browser
                var process = module1.exports = {};
                // cached from whatever global is present so that test runners that stub it
                // don't break things.  But we need to wrap it in a try catch in case it is
                // wrapped in strict mode code which doesn't define any globals.  It's inside a
                // function because try/catches deoptimize in certain engines.
                var cachedSetTimeout;
                var cachedClearTimeout;
                (function() {
                    try {
                        if (typeof setTimeout === "function") {
                            cachedSetTimeout = setTimeout;
                        } else {
                            cachedSetTimeout = defaultSetTimout;
                        }
                    } catch (e) {
                        cachedSetTimeout = defaultSetTimout;
                    }
                    try {
                        if (typeof clearTimeout === "function") {
                            cachedClearTimeout = clearTimeout;
                        } else {
                            cachedClearTimeout = defaultClearTimeout;
                        }
                    } catch (e) {
                        cachedClearTimeout = defaultClearTimeout;
                    }
                })();
                var queue = [];
                var draining = false;
                var currentQueue;
                var queueIndex = -1;
                process.nextTick = function(fun) {
                    var args = new Array(arguments.length - 1);
                    if (arguments.length > 1) {
                        for(var i = 1; i < arguments.length; i++){
                            args[i - 1] = arguments[i];
                        }
                    }
                    queue.push(new Item(fun, args));
                    if (queue.length === 1 && !draining) {
                        runTimeout(drainQueue);
                    }
                };
                Item.prototype.run = function() {
                    this.fun.apply(null, this.array);
                };
                process.title = "browser";
                process.browser = true;
                process.env = {};
                process.argv = [];
                process.version = ""; // empty string to avoid regexp issues
                process.versions = {};
                process.on = noop;
                process.addListener = noop;
                process.once = noop;
                process.off = noop;
                process.removeListener = noop;
                process.removeAllListeners = noop;
                process.emit = noop;
                process.prependListener = noop;
                process.prependOnceListener = noop;
                process.listeners = function(name) {
                    return [];
                };
                process.binding = function(name) {
                    throw new Error("process.binding is not supported");
                };
                process.cwd = function() {
                    return "/";
                };
                process.chdir = function(dir) {
                    throw new Error("process.chdir is not supported");
                };
                process.umask = function() {
                    return 0;
                };
            /***/ },
            /***/ 82: /***/ function(module1) {
                module1.exports = function isBuffer(arg) {
                    return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
                };
            /***/ },
            /***/ 4895: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1698041__) {
                "use strict";
                var uncurryThis = function uncurryThis(f) {
                    return f.call.bind(f);
                };
                var checkBoxedPrimitive = function checkBoxedPrimitive(value, prototypeValueOf) {
                    if (typeof value !== "object") {
                        return false;
                    }
                    try {
                        prototypeValueOf(value);
                        return true;
                    } catch (e) {
                        return false;
                    }
                };
                var isPromise = // Taken from here and modified for better browser support
                // https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
                function isPromise(input) {
                    return typeof Promise !== "undefined" && _instanceof(input, Promise) || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
                };
                var isArrayBufferView = function isArrayBufferView(value) {
                    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
                        return ArrayBuffer.isView(value);
                    }
                    return isTypedArray(value) || isDataView(value);
                };
                var isUint8Array = function isUint8Array(value) {
                    return whichTypedArray(value) === "Uint8Array";
                };
                var isUint8ClampedArray = function isUint8ClampedArray(value) {
                    return whichTypedArray(value) === "Uint8ClampedArray";
                };
                var isUint16Array = function isUint16Array(value) {
                    return whichTypedArray(value) === "Uint16Array";
                };
                var isUint32Array = function isUint32Array(value) {
                    return whichTypedArray(value) === "Uint32Array";
                };
                var isInt8Array = function isInt8Array(value) {
                    return whichTypedArray(value) === "Int8Array";
                };
                var isInt16Array = function isInt16Array(value) {
                    return whichTypedArray(value) === "Int16Array";
                };
                var isInt32Array = function isInt32Array(value) {
                    return whichTypedArray(value) === "Int32Array";
                };
                var isFloat32Array = function isFloat32Array(value) {
                    return whichTypedArray(value) === "Float32Array";
                };
                var isFloat64Array = function isFloat64Array(value) {
                    return whichTypedArray(value) === "Float64Array";
                };
                var isBigInt64Array = function isBigInt64Array(value) {
                    return whichTypedArray(value) === "BigInt64Array";
                };
                var isBigUint64Array = function isBigUint64Array(value) {
                    return whichTypedArray(value) === "BigUint64Array";
                };
                var isMapToString = function isMapToString(value) {
                    return ObjectToString(value) === "[object Map]";
                };
                var isMap = function isMap(value) {
                    if (typeof Map === "undefined") {
                        return false;
                    }
                    return isMapToString.working ? isMapToString(value) : _instanceof(value, Map);
                };
                var isSetToString = function isSetToString(value) {
                    return ObjectToString(value) === "[object Set]";
                };
                var isSet = function isSet(value) {
                    if (typeof Set === "undefined") {
                        return false;
                    }
                    return isSetToString.working ? isSetToString(value) : _instanceof(value, Set);
                };
                var isWeakMapToString = function isWeakMapToString(value) {
                    return ObjectToString(value) === "[object WeakMap]";
                };
                var isWeakMap = function isWeakMap(value) {
                    if (typeof WeakMap === "undefined") {
                        return false;
                    }
                    return isWeakMapToString.working ? isWeakMapToString(value) : _instanceof(value, WeakMap);
                };
                var isWeakSetToString = function isWeakSetToString(value) {
                    return ObjectToString(value) === "[object WeakSet]";
                };
                var isWeakSet = function isWeakSet(value) {
                    return isWeakSetToString(value);
                };
                var isArrayBufferToString = function isArrayBufferToString(value) {
                    return ObjectToString(value) === "[object ArrayBuffer]";
                };
                var isArrayBuffer = function isArrayBuffer(value) {
                    if (typeof ArrayBuffer === "undefined") {
                        return false;
                    }
                    return isArrayBufferToString.working ? isArrayBufferToString(value) : _instanceof(value, ArrayBuffer);
                };
                var isDataViewToString = function isDataViewToString(value) {
                    return ObjectToString(value) === "[object DataView]";
                };
                var isDataView = function isDataView(value) {
                    if (typeof DataView === "undefined") {
                        return false;
                    }
                    return isDataViewToString.working ? isDataViewToString(value) : _instanceof(value, DataView);
                };
                var isSharedArrayBufferToString = function isSharedArrayBufferToString(value) {
                    return ObjectToString(value) === "[object SharedArrayBuffer]";
                };
                var isSharedArrayBuffer = function isSharedArrayBuffer(value) {
                    if (typeof SharedArrayBufferCopy === "undefined") {
                        return false;
                    }
                    if (typeof isSharedArrayBufferToString.working === "undefined") {
                        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
                    }
                    return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : _instanceof(value, SharedArrayBufferCopy);
                };
                var isAsyncFunction = function isAsyncFunction(value) {
                    return ObjectToString(value) === "[object AsyncFunction]";
                };
                var isMapIterator = function isMapIterator(value) {
                    return ObjectToString(value) === "[object Map Iterator]";
                };
                var isSetIterator = function isSetIterator(value) {
                    return ObjectToString(value) === "[object Set Iterator]";
                };
                var isGeneratorObject = function isGeneratorObject(value) {
                    return ObjectToString(value) === "[object Generator]";
                };
                var isWebAssemblyCompiledModule = function isWebAssemblyCompiledModule(value) {
                    return ObjectToString(value) === "[object WebAssembly.Module]";
                };
                var isNumberObject = function isNumberObject(value) {
                    return checkBoxedPrimitive(value, numberValue);
                };
                var isStringObject = function isStringObject(value) {
                    return checkBoxedPrimitive(value, stringValue);
                };
                var isBooleanObject = function isBooleanObject(value) {
                    return checkBoxedPrimitive(value, booleanValue);
                };
                var isBigIntObject = function isBigIntObject(value) {
                    return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
                };
                var isSymbolObject = function isSymbolObject(value) {
                    return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
                };
                var isBoxedPrimitive = function isBoxedPrimitive(value) {
                    return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
                };
                var isAnyArrayBuffer = function isAnyArrayBuffer(value) {
                    return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
                };
                // Currently in sync with Node.js lib/internal/util/types.js
                // https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
                var isArgumentsObject = __nested_webpack_require_1698041__(2635);
                var isGeneratorFunction = __nested_webpack_require_1698041__(3138);
                var whichTypedArray = __nested_webpack_require_1698041__(2094);
                var isTypedArray = __nested_webpack_require_1698041__(198);
                var BigIntSupported = typeof BigInt !== "undefined";
                var SymbolSupported = typeof Symbol !== "undefined";
                var ObjectToString = uncurryThis(Object.prototype.toString);
                var numberValue = uncurryThis(Number.prototype.valueOf);
                var stringValue = uncurryThis(String.prototype.valueOf);
                var booleanValue = uncurryThis(Boolean.prototype.valueOf);
                if (BigIntSupported) {
                    var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
                }
                if (SymbolSupported) {
                    var symbolValue = uncurryThis(Symbol.prototype.valueOf);
                }
                exports1.isArgumentsObject = isArgumentsObject;
                exports1.isGeneratorFunction = isGeneratorFunction;
                exports1.isTypedArray = isTypedArray;
                exports1.isPromise = isPromise;
                exports1.isArrayBufferView = isArrayBufferView;
                exports1.isUint8Array = isUint8Array;
                exports1.isUint8ClampedArray = isUint8ClampedArray;
                exports1.isUint16Array = isUint16Array;
                exports1.isUint32Array = isUint32Array;
                exports1.isInt8Array = isInt8Array;
                exports1.isInt16Array = isInt16Array;
                exports1.isInt32Array = isInt32Array;
                exports1.isFloat32Array = isFloat32Array;
                exports1.isFloat64Array = isFloat64Array;
                exports1.isBigInt64Array = isBigInt64Array;
                exports1.isBigUint64Array = isBigUint64Array;
                isMapToString.working = typeof Map !== "undefined" && isMapToString(new Map());
                exports1.isMap = isMap;
                isSetToString.working = typeof Set !== "undefined" && isSetToString(new Set());
                exports1.isSet = isSet;
                isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(new WeakMap());
                exports1.isWeakMap = isWeakMap;
                isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(new WeakSet());
                exports1.isWeakSet = isWeakSet;
                isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
                exports1.isArrayBuffer = isArrayBuffer;
                isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
                exports1.isDataView = isDataView;
                // Store a copy of SharedArrayBuffer in case it's deleted elsewhere
                var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : undefined;
                exports1.isSharedArrayBuffer = isSharedArrayBuffer;
                exports1.isAsyncFunction = isAsyncFunction;
                exports1.isMapIterator = isMapIterator;
                exports1.isSetIterator = isSetIterator;
                exports1.isGeneratorObject = isGeneratorObject;
                exports1.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
                exports1.isNumberObject = isNumberObject;
                exports1.isStringObject = isStringObject;
                exports1.isBooleanObject = isBooleanObject;
                exports1.isBigIntObject = isBigIntObject;
                exports1.isSymbolObject = isSymbolObject;
                exports1.isBoxedPrimitive = isBoxedPrimitive;
                exports1.isAnyArrayBuffer = isAnyArrayBuffer;
                [
                    "isProxy",
                    "isExternal",
                    "isModuleNamespaceObject"
                ].forEach(function(method) {
                    Object.defineProperty(exports1, method, {
                        enumerable: false,
                        value: function value() {
                            throw new Error(method + " is not supported in userland");
                        }
                    });
                });
            /***/ },
            /***/ 3335: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1711470__) {
                var inspect = /**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */ /* legacy: obj, showHidden, depth, colors*/ function inspect(obj, opts) {
                    // default options
                    var ctx = {
                        seen: [],
                        stylize: stylizeNoColor
                    };
                    // legacy...
                    if (arguments.length >= 3) ctx.depth = arguments[2];
                    if (arguments.length >= 4) ctx.colors = arguments[3];
                    if (isBoolean(opts)) {
                        // legacy...
                        ctx.showHidden = opts;
                    } else if (opts) {
                        // got an "options" object
                        exports1._extend(ctx, opts);
                    }
                    // set default options
                    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
                    if (isUndefined(ctx.depth)) ctx.depth = 2;
                    if (isUndefined(ctx.colors)) ctx.colors = false;
                    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
                    if (ctx.colors) ctx.stylize = stylizeWithColor;
                    return formatValue(ctx, obj, ctx.depth);
                };
                var stylizeWithColor = function stylizeWithColor(str, styleType) {
                    var style = inspect.styles[styleType];
                    if (style) {
                        return "\x1b[" + inspect.colors[style][0] + "m" + str + "\x1b[" + inspect.colors[style][1] + "m";
                    } else {
                        return str;
                    }
                };
                var stylizeNoColor = function stylizeNoColor(str, styleType) {
                    return str;
                };
                var arrayToHash = function arrayToHash(array) {
                    var hash = {};
                    array.forEach(function(val, idx) {
                        hash[val] = true;
                    });
                    return hash;
                };
                var formatPrimitive = function formatPrimitive(ctx, value) {
                    if (isUndefined(value)) return ctx.stylize("undefined", "undefined");
                    if (isString(value)) {
                        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                        return ctx.stylize(simple, "string");
                    }
                    if (isNumber(value)) return ctx.stylize("" + value, "number");
                    if (isBoolean(value)) return ctx.stylize("" + value, "boolean");
                    // For some reason typeof null is "object", so special case here.
                    if (isNull(value)) return ctx.stylize("null", "null");
                };
                var formatError = function formatError(value) {
                    return "[" + Error.prototype.toString.call(value) + "]";
                };
                var formatArray = function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                    var output = [];
                    for(var i = 0, l = value.length; i < l; ++i){
                        if (hasOwnProperty(value, String(i))) {
                            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
                        } else {
                            output.push("");
                        }
                    }
                    keys.forEach(function(key) {
                        if (!key.match(/^\d+$/)) {
                            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
                        }
                    });
                    return output;
                };
                var formatProperty = function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                    var name, str, desc;
                    desc = Object.getOwnPropertyDescriptor(value, key) || {
                        value: value[key]
                    };
                    if (desc.get) {
                        if (desc.set) {
                            str = ctx.stylize("[Getter/Setter]", "special");
                        } else {
                            str = ctx.stylize("[Getter]", "special");
                        }
                    } else {
                        if (desc.set) {
                            str = ctx.stylize("[Setter]", "special");
                        }
                    }
                    if (!hasOwnProperty(visibleKeys, key)) {
                        name = "[" + key + "]";
                    }
                    if (!str) {
                        if (ctx.seen.indexOf(desc.value) < 0) {
                            if (isNull(recurseTimes)) {
                                str = formatValue(ctx, desc.value, null);
                            } else {
                                str = formatValue(ctx, desc.value, recurseTimes - 1);
                            }
                            if (str.indexOf("\n") > -1) {
                                if (array) {
                                    str = str.split("\n").map(function(line) {
                                        return "  " + line;
                                    }).join("\n").slice(2);
                                } else {
                                    str = "\n" + str.split("\n").map(function(line) {
                                        return "   " + line;
                                    }).join("\n");
                                }
                            }
                        } else {
                            str = ctx.stylize("[Circular]", "special");
                        }
                    }
                    if (isUndefined(name)) {
                        if (array && key.match(/^\d+$/)) {
                            return str;
                        }
                        name = JSON.stringify("" + key);
                        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                            name = name.slice(1, -1);
                            name = ctx.stylize(name, "name");
                        } else {
                            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                            name = ctx.stylize(name, "string");
                        }
                    }
                    return name + ": " + str;
                };
                var reduceToSingleString = function reduceToSingleString(output, base, braces) {
                    var numLinesEst = 0;
                    var length = output.reduce(function(prev, cur) {
                        numLinesEst++;
                        if (cur.indexOf("\n") >= 0) numLinesEst++;
                        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
                    }, 0);
                    if (length > 60) {
                        return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
                    }
                    return braces[0] + base + " " + output.join(", ") + " " + braces[1];
                };
                var isArray = function isArray(ar) {
                    return Array.isArray(ar);
                };
                var isBoolean = function isBoolean(arg) {
                    return typeof arg === "boolean";
                };
                var isNull = function isNull(arg) {
                    return arg === null;
                };
                var isNullOrUndefined = function isNullOrUndefined(arg) {
                    return arg == null;
                };
                var isNumber = function isNumber(arg) {
                    return typeof arg === "number";
                };
                var isString = function isString(arg) {
                    return typeof arg === "string";
                };
                var isSymbol = function isSymbol(arg) {
                    return (typeof arg === "undefined" ? "undefined" : _type_of(arg)) === "symbol";
                };
                var isUndefined = function isUndefined(arg) {
                    return arg === void 0;
                };
                var isRegExp = function isRegExp(re) {
                    return isObject(re) && objectToString(re) === "[object RegExp]";
                };
                var isObject = function isObject(arg) {
                    return typeof arg === "object" && arg !== null;
                };
                var isDate = function isDate(d) {
                    return isObject(d) && objectToString(d) === "[object Date]";
                };
                var isError = function isError(e) {
                    return isObject(e) && (objectToString(e) === "[object Error]" || _instanceof(e, Error));
                };
                var isFunction = function isFunction(arg) {
                    return typeof arg === "function";
                };
                var isPrimitive = function isPrimitive(arg) {
                    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || (typeof arg === "undefined" ? "undefined" : _type_of(arg)) === "symbol" || // ES6 symbol
                    typeof arg === "undefined";
                };
                var objectToString = function objectToString(o) {
                    return Object.prototype.toString.call(o);
                };
                var pad = function pad(n) {
                    return n < 10 ? "0" + n.toString(10) : n.toString(10);
                };
                var timestamp = // 26 Feb 16:19:34
                function timestamp() {
                    var d = new Date();
                    var time = [
                        pad(d.getHours()),
                        pad(d.getMinutes()),
                        pad(d.getSeconds())
                    ].join(":");
                    return [
                        d.getDate(),
                        months[d.getMonth()],
                        time
                    ].join(" ");
                };
                var hasOwnProperty = function hasOwnProperty(obj, prop) {
                    return Object.prototype.hasOwnProperty.call(obj, prop);
                };
                var callbackifyOnRejected = function callbackifyOnRejected(reason, cb) {
                    // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
                    // Because `null` is a special error value in callbacks which means "no error
                    // occurred", we error-wrap so the callback consumer can distinguish between
                    // "the promise rejected with null" or "the promise fulfilled with undefined".
                    if (!reason) {
                        var newReason = new Error("Promise was rejected with a falsy value");
                        newReason.reason = reason;
                        reason = newReason;
                    }
                    return cb(reason);
                };
                var callbackify = function callbackify(original) {
                    if (typeof original !== "function") {
                        throw new TypeError('The "original" argument must be of type Function');
                    }
                    // We DO NOT return the promise as it gives the user a false sense that
                    // the promise is actually somehow related to the callback's execution
                    // and that the callback throwing will reject the promise.
                    function callbackified() {
                        var args = [];
                        for(var i = 0; i < arguments.length; i++){
                            args.push(arguments[i]);
                        }
                        var maybeCb = args.pop();
                        if (typeof maybeCb !== "function") {
                            throw new TypeError("The last argument must be of type Function");
                        }
                        var _$self = this;
                        var cb = function cb() {
                            return maybeCb.apply(_$self, arguments);
                        };
                        // In true node style we process the callback on `nextTick` with all the
                        // implications (stack, `uncaughtException`, `async_hooks`)
                        original.apply(this, args).then(function(ret) {
                            process.nextTick(cb.bind(null, null, ret));
                        }, function(rej) {
                            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
                        });
                    }
                    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
                    Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
                    return callbackified;
                };
                /* provided dependency */ var process = __nested_webpack_require_1711470__(4406);
                /* provided dependency */ var console = __nested_webpack_require_1711470__(3716);
                // Copyright Joyent, Inc. and other Node contributors.
                //
                // Permission is hereby granted, free of charge, to any person obtaining a
                // copy of this software and associated documentation files (the
                // "Software"), to deal in the Software without restriction, including
                // without limitation the rights to use, copy, modify, merge, publish,
                // distribute, sublicense, and/or sell copies of the Software, and to permit
                // persons to whom the Software is furnished to do so, subject to the
                // following conditions:
                //
                // The above copyright notice and this permission notice shall be included
                // in all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
                // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
                // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
                // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
                // USE OR OTHER DEALINGS IN THE SOFTWARE.
                var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
                    var keys = Object.keys(obj);
                    var descriptors = {};
                    for(var i = 0; i < keys.length; i++){
                        descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
                    }
                    return descriptors;
                };
                var formatRegExp = /%[sdj%]/g;
                exports1.format = function(f) {
                    if (!isString(f)) {
                        var objects = [];
                        for(var i = 0; i < arguments.length; i++){
                            objects.push(inspect(arguments[i]));
                        }
                        return objects.join(" ");
                    }
                    var i = 1;
                    var args = arguments;
                    var len = args.length;
                    var str = String(f).replace(formatRegExp, function(x) {
                        if (x === "%%") return "%";
                        if (i >= len) return x;
                        switch(x){
                            case "%s":
                                return String(args[i++]);
                            case "%d":
                                return Number(args[i++]);
                            case "%j":
                                try {
                                    return JSON.stringify(args[i++]);
                                } catch (_) {
                                    return "[Circular]";
                                }
                            default:
                                return x;
                        }
                    });
                    for(var x = args[i]; i < len; x = args[++i]){
                        if (isNull(x) || !isObject(x)) {
                            str += " " + x;
                        } else {
                            str += " " + inspect(x);
                        }
                    }
                    return str;
                };
                // Mark that a method should not be used.
                // Returns a modified function which warns once by default.
                // If --no-deprecation is set, then it is a no-op.
                exports1.deprecate = function(fn, msg) {
                    var deprecated = function deprecated() {
                        if (!warned) {
                            if (process.throwDeprecation) {
                                throw new Error(msg);
                            } else if (process.traceDeprecation) {
                                console.trace(msg);
                            } else {
                                console.error(msg);
                            }
                            warned = true;
                        }
                        return fn.apply(this, arguments);
                    };
                    if (typeof process !== "undefined" && process.noDeprecation === true) {
                        return fn;
                    }
                    // Allow for deprecating things in the process of starting up.
                    if (typeof process === "undefined") {
                        return function() {
                            return exports1.deprecate(fn, msg).apply(this, arguments);
                        };
                    }
                    var warned = false;
                    return deprecated;
                };
                var debugs = {};
                var debugEnvRegex = /^$/;
                if (process.env.NODE_DEBUG) {
                    var debugEnv = process.env.NODE_DEBUG;
                    debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
                    debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
                }
                exports1.debuglog = function(set) {
                    set = set.toUpperCase();
                    if (!debugs[set]) {
                        if (debugEnvRegex.test(set)) {
                            var pid = process.pid;
                            debugs[set] = function() {
                                var msg = exports1.format.apply(exports1, arguments);
                                console.error("%s %d: %s", set, pid, msg);
                            };
                        } else {
                            debugs[set] = function() {};
                        }
                    }
                    return debugs[set];
                };
                exports1.inspect = inspect;
                // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
                inspect.colors = {
                    "bold": [
                        1,
                        22
                    ],
                    "italic": [
                        3,
                        23
                    ],
                    "underline": [
                        4,
                        24
                    ],
                    "inverse": [
                        7,
                        27
                    ],
                    "white": [
                        37,
                        39
                    ],
                    "grey": [
                        90,
                        39
                    ],
                    "black": [
                        30,
                        39
                    ],
                    "blue": [
                        34,
                        39
                    ],
                    "cyan": [
                        36,
                        39
                    ],
                    "green": [
                        32,
                        39
                    ],
                    "magenta": [
                        35,
                        39
                    ],
                    "red": [
                        31,
                        39
                    ],
                    "yellow": [
                        33,
                        39
                    ]
                };
                // Don't use 'blue' not visible on cmd.exe
                inspect.styles = {
                    "special": "cyan",
                    "number": "yellow",
                    "boolean": "yellow",
                    "undefined": "grey",
                    "null": "bold",
                    "string": "green",
                    "date": "magenta",
                    // "name": intentionally not styling
                    "regexp": "red"
                };
                function formatValue(ctx, value, recurseTimes) {
                    // Provide a hook for user-specified inspect functions.
                    // Check that value is an object with an inspect function on it
                    if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
                    value.inspect !== exports1.inspect && // Also filter out any prototype objects using the circular check.
                    !(value.constructor && value.constructor.prototype === value)) {
                        var ret = value.inspect(recurseTimes, ctx);
                        if (!isString(ret)) {
                            ret = formatValue(ctx, ret, recurseTimes);
                        }
                        return ret;
                    }
                    // Primitive types cannot have properties
                    var primitive = formatPrimitive(ctx, value);
                    if (primitive) {
                        return primitive;
                    }
                    // Look up the keys of the object.
                    var keys = Object.keys(value);
                    var visibleKeys = arrayToHash(keys);
                    if (ctx.showHidden) {
                        keys = Object.getOwnPropertyNames(value);
                    }
                    // IE doesn't make error fields non-enumerable
                    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
                    if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
                        return formatError(value);
                    }
                    // Some type of object without properties can be shortcutted.
                    if (keys.length === 0) {
                        if (isFunction(value)) {
                            var name = value.name ? ": " + value.name : "";
                            return ctx.stylize("[Function" + name + "]", "special");
                        }
                        if (isRegExp(value)) {
                            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                        }
                        if (isDate(value)) {
                            return ctx.stylize(Date.prototype.toString.call(value), "date");
                        }
                        if (isError(value)) {
                            return formatError(value);
                        }
                    }
                    var base = "", array = false, braces = [
                        "{",
                        "}"
                    ];
                    // Make Array say that they are Array
                    if (isArray(value)) {
                        array = true;
                        braces = [
                            "[",
                            "]"
                        ];
                    }
                    // Make functions say that they are functions
                    if (isFunction(value)) {
                        var n = value.name ? ": " + value.name : "";
                        base = " [Function" + n + "]";
                    }
                    // Make RegExps say that they are RegExps
                    if (isRegExp(value)) {
                        base = " " + RegExp.prototype.toString.call(value);
                    }
                    // Make dates with properties first say the date
                    if (isDate(value)) {
                        base = " " + Date.prototype.toUTCString.call(value);
                    }
                    // Make error with message first say the error
                    if (isError(value)) {
                        base = " " + formatError(value);
                    }
                    if (keys.length === 0 && (!array || value.length == 0)) {
                        return braces[0] + base + braces[1];
                    }
                    if (recurseTimes < 0) {
                        if (isRegExp(value)) {
                            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                        } else {
                            return ctx.stylize("[Object]", "special");
                        }
                    }
                    ctx.seen.push(value);
                    var output;
                    if (array) {
                        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
                    } else {
                        output = keys.map(function(key) {
                            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                        });
                    }
                    ctx.seen.pop();
                    return reduceToSingleString(output, base, braces);
                }
                // NOTE: These type checking functions intentionally don't use `instanceof`
                // because it is fragile and can be easily faked with `Object.create()`.
                exports1.types = __nested_webpack_require_1711470__(4895);
                exports1.isArray = isArray;
                exports1.isBoolean = isBoolean;
                exports1.isNull = isNull;
                exports1.isNullOrUndefined = isNullOrUndefined;
                exports1.isNumber = isNumber;
                exports1.isString = isString;
                exports1.isSymbol = isSymbol;
                exports1.isUndefined = isUndefined;
                exports1.isRegExp = isRegExp;
                exports1.types.isRegExp = isRegExp;
                exports1.isObject = isObject;
                exports1.isDate = isDate;
                exports1.types.isDate = isDate;
                exports1.isError = isError;
                exports1.types.isNativeError = isError;
                exports1.isFunction = isFunction;
                exports1.isPrimitive = isPrimitive;
                exports1.isBuffer = __nested_webpack_require_1711470__(82);
                var months = [
                    "Jan",
                    "Feb",
                    "Mar",
                    "Apr",
                    "May",
                    "Jun",
                    "Jul",
                    "Aug",
                    "Sep",
                    "Oct",
                    "Nov",
                    "Dec"
                ];
                // log is just a thin wrapper to console.log that prepends a timestamp
                exports1.log = function() {
                    console.log("%s - %s", timestamp(), exports1.format.apply(exports1, arguments));
                };
                /**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */ exports1.inherits = __nested_webpack_require_1711470__(1285);
                exports1._extend = function(origin, add) {
                    // Don't do anything if add isn't an object
                    if (!add || !isObject(add)) return origin;
                    var keys = Object.keys(add);
                    var i = keys.length;
                    while(i--){
                        origin[keys[i]] = add[keys[i]];
                    }
                    return origin;
                };
                var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : undefined;
                exports1.promisify = function promisify(original) {
                    var fn = function fn() {
                        var promiseResolve, promiseReject;
                        var promise = new Promise(function(resolve, reject) {
                            promiseResolve = resolve;
                            promiseReject = reject;
                        });
                        var args = [];
                        for(var i = 0; i < arguments.length; i++){
                            args.push(arguments[i]);
                        }
                        args.push(function(err, value) {
                            if (err) {
                                promiseReject(err);
                            } else {
                                promiseResolve(value);
                            }
                        });
                        try {
                            original.apply(this, args);
                        } catch (err) {
                            promiseReject(err);
                        }
                        return promise;
                    };
                    if (typeof original !== "function") throw new TypeError('The "original" argument must be of type Function');
                    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
                        var fn = original[kCustomPromisifiedSymbol];
                        if (typeof fn !== "function") {
                            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                        }
                        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                            value: fn,
                            enumerable: false,
                            writable: false,
                            configurable: true
                        });
                        return fn;
                    }
                    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
                    if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                        value: fn,
                        enumerable: false,
                        writable: false,
                        configurable: true
                    });
                    return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
                };
                exports1.promisify.custom = kCustomPromisifiedSymbol;
                exports1.callbackify = callbackify;
            /***/ },
            /***/ 1200: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_1743748__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */ module1.exports = __nested_webpack_require_1743748__(5953);
            /***/ },
            /***/ 5953: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1744306__) {
                "use strict";
                var createMessageConnection = function createMessageConnection(reader, writer, logger, options) {
                    if (logger === undefined) {
                        logger = api_1.NullLogger;
                    }
                    if (api_1.ConnectionStrategy.is(options)) {
                        options = {
                            connectionStrategy: options
                        };
                    }
                    return (0, api_1.createMessageConnection)(reader, writer, logger, options);
                };
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function get() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createMessageConnection = exports1.BrowserMessageWriter = exports1.BrowserMessageReader = void 0;
                var ril_1 = __nested_webpack_require_1744306__(3632);
                // Install the browser runtime abstract.
                ril_1.default.install();
                var api_1 = __nested_webpack_require_1744306__(5247);
                __exportStar(__nested_webpack_require_1744306__(5247), exports1);
                var BrowserMessageReader = /*#__PURE__*/ function(_api_1_AbstractMessageReader) {
                    _inherits(BrowserMessageReader, _api_1_AbstractMessageReader);
                    var _super = _create_super(BrowserMessageReader);
                    function BrowserMessageReader(context) {
                        _class_call_check(this, BrowserMessageReader);
                        var _this;
                        _this = _super.call(this);
                        _this._onData = new api_1.Emitter();
                        _this._messageListener = function(event) {
                            _this._onData.fire(event.data);
                        };
                        context.addEventListener("error", function(event) {
                            return _this.fireError(event);
                        });
                        context.onmessage = _this._messageListener;
                        return _this;
                    }
                    _create_class(BrowserMessageReader, [
                        {
                            key: "listen",
                            value: function listen(callback) {
                                return this._onData.event(callback);
                            }
                        }
                    ]);
                    return BrowserMessageReader;
                }(api_1.AbstractMessageReader);
                exports1.BrowserMessageReader = BrowserMessageReader;
                var BrowserMessageWriter = /*#__PURE__*/ function(_api_1_AbstractMessageWriter) {
                    _inherits(BrowserMessageWriter, _api_1_AbstractMessageWriter);
                    var _super = _create_super(BrowserMessageWriter);
                    function BrowserMessageWriter(context) {
                        _class_call_check(this, BrowserMessageWriter);
                        var _this;
                        _this = _super.call(this);
                        _this.context = context;
                        _this.errorCount = 0;
                        context.addEventListener("error", function(event) {
                            return _this.fireError(event);
                        });
                        return _this;
                    }
                    _create_class(BrowserMessageWriter, [
                        {
                            key: "write",
                            value: function write(msg) {
                                try {
                                    this.context.postMessage(msg);
                                    return Promise.resolve();
                                } catch (error) {
                                    this.handleError(error, msg);
                                    return Promise.reject(error);
                                }
                            }
                        },
                        {
                            key: "handleError",
                            value: function handleError(error, msg) {
                                this.errorCount++;
                                this.fireError(error, msg, this.errorCount);
                            }
                        },
                        {
                            key: "end",
                            value: function end() {}
                        }
                    ]);
                    return BrowserMessageWriter;
                }(api_1.AbstractMessageWriter);
                exports1.BrowserMessageWriter = BrowserMessageWriter;
                exports1.createMessageConnection = createMessageConnection;
            //# sourceMappingURL=main.js.map
            /***/ },
            /***/ 3632: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1750593__) {
                "use strict";
                var RIL = function RIL() {
                    return _ril;
                };
                /* provided dependency */ var console = __nested_webpack_require_1750593__(3716);
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                var ral_1 = __nested_webpack_require_1750593__(5706);
                var disposable_1 = __nested_webpack_require_1750593__(8437);
                var events_1 = __nested_webpack_require_1750593__(5165);
                var messageBuffer_1 = __nested_webpack_require_1750593__(8652);
                var MessageBuffer = /*#__PURE__*/ function(_messageBuffer_1_AbstractMessageBuffer) {
                    _inherits(MessageBuffer, _messageBuffer_1_AbstractMessageBuffer);
                    var _super = _create_super(MessageBuffer);
                    function MessageBuffer() {
                        var encoding = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "utf-8";
                        _class_call_check(this, MessageBuffer);
                        var _this;
                        _this = _super.call(this, encoding);
                        _this.asciiDecoder = new TextDecoder("ascii");
                        return _this;
                    }
                    _create_class(MessageBuffer, [
                        {
                            key: "emptyBuffer",
                            value: function emptyBuffer() {
                                return MessageBuffer.emptyBuffer;
                            }
                        },
                        {
                            key: "fromString",
                            value: function fromString(value, _encoding) {
                                return new TextEncoder().encode(value);
                            }
                        },
                        {
                            key: "toString",
                            value: function toString(value, encoding) {
                                if (encoding === "ascii") {
                                    return this.asciiDecoder.decode(value);
                                } else {
                                    return new TextDecoder(encoding).decode(value);
                                }
                            }
                        },
                        {
                            key: "asNative",
                            value: function asNative(buffer, length) {
                                if (length === undefined) {
                                    return buffer;
                                } else {
                                    return buffer.slice(0, length);
                                }
                            }
                        },
                        {
                            key: "allocNative",
                            value: function allocNative(length) {
                                return new Uint8Array(length);
                            }
                        }
                    ]);
                    return MessageBuffer;
                }(messageBuffer_1.AbstractMessageBuffer);
                MessageBuffer.emptyBuffer = new Uint8Array(0);
                var ReadableStreamWrapper = /*#__PURE__*/ function() {
                    function ReadableStreamWrapper(socket) {
                        var _this = this;
                        _class_call_check(this, ReadableStreamWrapper);
                        this.socket = socket;
                        this._onData = new events_1.Emitter();
                        this._messageListener = function(event) {
                            var blob = event.data;
                            blob.arrayBuffer().then(function(buffer) {
                                _this._onData.fire(new Uint8Array(buffer));
                            }, function() {
                                (0, ral_1.default)().console.error("Converting blob to array buffer failed.");
                            });
                        };
                        this.socket.addEventListener("message", this._messageListener);
                    }
                    _create_class(ReadableStreamWrapper, [
                        {
                            key: "onClose",
                            value: function onClose(listener) {
                                var _this = this;
                                this.socket.addEventListener("close", listener);
                                return disposable_1.Disposable.create(function() {
                                    return _this.socket.removeEventListener("close", listener);
                                });
                            }
                        },
                        {
                            key: "onError",
                            value: function onError(listener) {
                                var _this = this;
                                this.socket.addEventListener("error", listener);
                                return disposable_1.Disposable.create(function() {
                                    return _this.socket.removeEventListener("error", listener);
                                });
                            }
                        },
                        {
                            key: "onEnd",
                            value: function onEnd(listener) {
                                var _this = this;
                                this.socket.addEventListener("end", listener);
                                return disposable_1.Disposable.create(function() {
                                    return _this.socket.removeEventListener("end", listener);
                                });
                            }
                        },
                        {
                            key: "onData",
                            value: function onData(listener) {
                                return this._onData.event(listener);
                            }
                        }
                    ]);
                    return ReadableStreamWrapper;
                }();
                var WritableStreamWrapper = /*#__PURE__*/ function() {
                    function WritableStreamWrapper(socket) {
                        _class_call_check(this, WritableStreamWrapper);
                        this.socket = socket;
                    }
                    _create_class(WritableStreamWrapper, [
                        {
                            key: "onClose",
                            value: function onClose(listener) {
                                var _this = this;
                                this.socket.addEventListener("close", listener);
                                return disposable_1.Disposable.create(function() {
                                    return _this.socket.removeEventListener("close", listener);
                                });
                            }
                        },
                        {
                            key: "onError",
                            value: function onError(listener) {
                                var _this = this;
                                this.socket.addEventListener("error", listener);
                                return disposable_1.Disposable.create(function() {
                                    return _this.socket.removeEventListener("error", listener);
                                });
                            }
                        },
                        {
                            key: "onEnd",
                            value: function onEnd(listener) {
                                var _this = this;
                                this.socket.addEventListener("end", listener);
                                return disposable_1.Disposable.create(function() {
                                    return _this.socket.removeEventListener("end", listener);
                                });
                            }
                        },
                        {
                            key: "write",
                            value: function write(data, encoding) {
                                if (typeof data === "string") {
                                    if (encoding !== undefined && encoding !== "utf-8") {
                                        throw new Error("In a Browser environments only utf-8 text encoding is supported. But got encoding: ".concat(encoding));
                                    }
                                    this.socket.send(data);
                                } else {
                                    this.socket.send(data);
                                }
                                return Promise.resolve();
                            }
                        },
                        {
                            key: "end",
                            value: function end() {
                                this.socket.close();
                            }
                        }
                    ]);
                    return WritableStreamWrapper;
                }();
                var _textEncoder = new TextEncoder();
                var _ril = Object.freeze({
                    messageBuffer: Object.freeze({
                        create: function(encoding) {
                            return new MessageBuffer(encoding);
                        }
                    }),
                    applicationJson: Object.freeze({
                        encoder: Object.freeze({
                            name: "application/json",
                            encode: function(msg, options) {
                                if (options.charset !== "utf-8") {
                                    throw new Error("In a Browser environments only utf-8 text encoding is supported. But got encoding: ".concat(options.charset));
                                }
                                return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, undefined, 0)));
                            }
                        }),
                        decoder: Object.freeze({
                            name: "application/json",
                            decode: function(buffer, options) {
                                if (!_instanceof(buffer, Uint8Array)) {
                                    throw new Error("In a Browser environments only Uint8Arrays are supported.");
                                }
                                return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
                            }
                        })
                    }),
                    stream: Object.freeze({
                        asReadableStream: function(socket) {
                            return new ReadableStreamWrapper(socket);
                        },
                        asWritableStream: function(socket) {
                            return new WritableStreamWrapper(socket);
                        }
                    }),
                    console: console,
                    timer: Object.freeze({
                        setTimeout: function setTimeout1(callback, ms) {
                            for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){
                                args[_key - 2] = arguments[_key];
                            }
                            var handle = setTimeout.apply(void 0, [
                                callback,
                                ms
                            ].concat(_to_consumable_array(args)));
                            return {
                                dispose: function() {
                                    return clearTimeout(handle);
                                }
                            };
                        },
                        setImmediate: function setImmediate(callback) {
                            for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                                args[_key - 1] = arguments[_key];
                            }
                            var handle = setTimeout.apply(void 0, [
                                callback,
                                0
                            ].concat(_to_consumable_array(args)));
                            return {
                                dispose: function() {
                                    return clearTimeout(handle);
                                }
                            };
                        },
                        setInterval: function setInterval1(callback, ms) {
                            for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){
                                args[_key - 2] = arguments[_key];
                            }
                            var handle = setInterval.apply(void 0, [
                                callback,
                                ms
                            ].concat(_to_consumable_array(args)));
                            return {
                                dispose: function() {
                                    return clearInterval(handle);
                                }
                            };
                        }
                    })
                });
                (function(RIL) {
                    var install = function install() {
                        ral_1.default.install(_ril);
                    };
                    RIL.install = install;
                })(RIL || (RIL = {}));
                exports1["default"] = RIL;
            //# sourceMappingURL=ril.js.map
            /***/ },
            /***/ 5247: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1765005__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ /// <reference path="../../typings/thenable.d.ts" />
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.TraceFormat = exports1.TraceValues = exports1.Trace = exports1.ProgressType = exports1.ProgressToken = exports1.createMessageConnection = exports1.NullLogger = exports1.ConnectionOptions = exports1.ConnectionStrategy = exports1.WriteableStreamMessageWriter = exports1.AbstractMessageWriter = exports1.MessageWriter = exports1.ReadableStreamMessageReader = exports1.AbstractMessageReader = exports1.MessageReader = exports1.CancellationToken = exports1.CancellationTokenSource = exports1.Emitter = exports1.Event = exports1.Disposable = exports1.LRUCache = exports1.Touch = exports1.LinkedMap = exports1.ParameterStructures = exports1.NotificationType9 = exports1.NotificationType8 = exports1.NotificationType7 = exports1.NotificationType6 = exports1.NotificationType5 = exports1.NotificationType4 = exports1.NotificationType3 = exports1.NotificationType2 = exports1.NotificationType1 = exports1.NotificationType0 = exports1.NotificationType = exports1.ErrorCodes = exports1.ResponseError = exports1.RequestType9 = exports1.RequestType8 = exports1.RequestType7 = exports1.RequestType6 = exports1.RequestType5 = exports1.RequestType4 = exports1.RequestType3 = exports1.RequestType2 = exports1.RequestType1 = exports1.RequestType0 = exports1.RequestType = exports1.Message = exports1.RAL = void 0;
                exports1.CancellationStrategy = exports1.CancellationSenderStrategy = exports1.CancellationReceiverStrategy = exports1.ConnectionError = exports1.ConnectionErrors = exports1.LogTraceNotification = exports1.SetTraceNotification = void 0;
                var messages_1 = __nested_webpack_require_1765005__(9141);
                Object.defineProperty(exports1, "Message", {
                    enumerable: true,
                    get: function get() {
                        return messages_1.Message;
                    }
                });
                Object.defineProperty(exports1, "RequestType", {
                    enumerable: true,
                    get: function get() {
                        return messages_1.RequestType;
                    }
                });
                Object.defineProperty(exports1, "RequestType0", {
                    enumerable: true,
                    get: function get() {
                        return messages_1.RequestType0;
                    }
                });
                Object.defineProperty(exports1, "RequestType1", {
                    enumerable: true,
                    get: function get() {
                        return messages_1.RequestType1;
                    }
                });
                Object.defineProperty(exports1, "RequestType2", {
                    enumerable: true,
                    get: function get() {
                        return messages_1.RequestType2;
                    }
                });
                Object.defineProperty(exports1, "RequestType3", {
                    enumerable: true,
                    get: function get() {
                        return messages_1.RequestType3;
                    }
                });
                Object.defineProperty(exports1, "RequestType4", {
                    enumerable: true,
                    get: function get() {
                        return messages_1.RequestType4;
                    }
                });
                Object.defineProperty(exports1, "RequestType5", {
                    enumerable: true,
                    get: function get() {
                        return messages_1.RequestType5;
                    }
                });
                Object.defineProperty(exports1, "RequestType6", {
                    enumerable: true,
                    get: function get() {
                        return messages_1.RequestType6;
                    }
                });
                Object.defineProperty(exports1, "RequestType7", {
                    enumerable: true,
                    get: function get() {
                        return messages_1.RequestType7;
                    }
                });
                Object.defineProperty(exports1, "RequestType8", {
                    enumerable: true,
                    get: function get() {
                        return messages_1.RequestType8;
                    }
                });
                Object.defineProperty(exports1, "RequestType9", {
                    enumerable: true,
                    get: function get() {
                        return messages_1.RequestType9;
                    }
                });
                Object.defineProperty(exports1, "ResponseError", {
                    enumerable: true,
                    get: function get() {
                        return messages_1.ResponseError;
                    }
                });
                Object.defineProperty(exports1, "ErrorCodes", {
                    enumerable: true,
                    get: function get() {
                        return messages_1.ErrorCodes;
                    }
                });
                Object.defineProperty(exports1, "NotificationType", {
                    enumerable: true,
                    get: function get() {
                        return messages_1.NotificationType;
                    }
                });
                Object.defineProperty(exports1, "NotificationType0", {
                    enumerable: true,
                    get: function get() {
                        return messages_1.NotificationType0;
                    }
                });
                Object.defineProperty(exports1, "NotificationType1", {
                    enumerable: true,
                    get: function get() {
                        return messages_1.NotificationType1;
                    }
                });
                Object.defineProperty(exports1, "NotificationType2", {
                    enumerable: true,
                    get: function get() {
                        return messages_1.NotificationType2;
                    }
                });
                Object.defineProperty(exports1, "NotificationType3", {
                    enumerable: true,
                    get: function get() {
                        return messages_1.NotificationType3;
                    }
                });
                Object.defineProperty(exports1, "NotificationType4", {
                    enumerable: true,
                    get: function get() {
                        return messages_1.NotificationType4;
                    }
                });
                Object.defineProperty(exports1, "NotificationType5", {
                    enumerable: true,
                    get: function get() {
                        return messages_1.NotificationType5;
                    }
                });
                Object.defineProperty(exports1, "NotificationType6", {
                    enumerable: true,
                    get: function get() {
                        return messages_1.NotificationType6;
                    }
                });
                Object.defineProperty(exports1, "NotificationType7", {
                    enumerable: true,
                    get: function get() {
                        return messages_1.NotificationType7;
                    }
                });
                Object.defineProperty(exports1, "NotificationType8", {
                    enumerable: true,
                    get: function get() {
                        return messages_1.NotificationType8;
                    }
                });
                Object.defineProperty(exports1, "NotificationType9", {
                    enumerable: true,
                    get: function get() {
                        return messages_1.NotificationType9;
                    }
                });
                Object.defineProperty(exports1, "ParameterStructures", {
                    enumerable: true,
                    get: function get() {
                        return messages_1.ParameterStructures;
                    }
                });
                var linkedMap_1 = __nested_webpack_require_1765005__(7040);
                Object.defineProperty(exports1, "LinkedMap", {
                    enumerable: true,
                    get: function get() {
                        return linkedMap_1.LinkedMap;
                    }
                });
                Object.defineProperty(exports1, "LRUCache", {
                    enumerable: true,
                    get: function get() {
                        return linkedMap_1.LRUCache;
                    }
                });
                Object.defineProperty(exports1, "Touch", {
                    enumerable: true,
                    get: function get() {
                        return linkedMap_1.Touch;
                    }
                });
                var disposable_1 = __nested_webpack_require_1765005__(8437);
                Object.defineProperty(exports1, "Disposable", {
                    enumerable: true,
                    get: function get() {
                        return disposable_1.Disposable;
                    }
                });
                var events_1 = __nested_webpack_require_1765005__(5165);
                Object.defineProperty(exports1, "Event", {
                    enumerable: true,
                    get: function get() {
                        return events_1.Event;
                    }
                });
                Object.defineProperty(exports1, "Emitter", {
                    enumerable: true,
                    get: function get() {
                        return events_1.Emitter;
                    }
                });
                var cancellation_1 = __nested_webpack_require_1765005__(415);
                Object.defineProperty(exports1, "CancellationTokenSource", {
                    enumerable: true,
                    get: function get() {
                        return cancellation_1.CancellationTokenSource;
                    }
                });
                Object.defineProperty(exports1, "CancellationToken", {
                    enumerable: true,
                    get: function get() {
                        return cancellation_1.CancellationToken;
                    }
                });
                var messageReader_1 = __nested_webpack_require_1765005__(451);
                Object.defineProperty(exports1, "MessageReader", {
                    enumerable: true,
                    get: function get() {
                        return messageReader_1.MessageReader;
                    }
                });
                Object.defineProperty(exports1, "AbstractMessageReader", {
                    enumerable: true,
                    get: function get() {
                        return messageReader_1.AbstractMessageReader;
                    }
                });
                Object.defineProperty(exports1, "ReadableStreamMessageReader", {
                    enumerable: true,
                    get: function get() {
                        return messageReader_1.ReadableStreamMessageReader;
                    }
                });
                var messageWriter_1 = __nested_webpack_require_1765005__(1251);
                Object.defineProperty(exports1, "MessageWriter", {
                    enumerable: true,
                    get: function get() {
                        return messageWriter_1.MessageWriter;
                    }
                });
                Object.defineProperty(exports1, "AbstractMessageWriter", {
                    enumerable: true,
                    get: function get() {
                        return messageWriter_1.AbstractMessageWriter;
                    }
                });
                Object.defineProperty(exports1, "WriteableStreamMessageWriter", {
                    enumerable: true,
                    get: function get() {
                        return messageWriter_1.WriteableStreamMessageWriter;
                    }
                });
                var connection_1 = __nested_webpack_require_1765005__(1908);
                Object.defineProperty(exports1, "ConnectionStrategy", {
                    enumerable: true,
                    get: function get() {
                        return connection_1.ConnectionStrategy;
                    }
                });
                Object.defineProperty(exports1, "ConnectionOptions", {
                    enumerable: true,
                    get: function get() {
                        return connection_1.ConnectionOptions;
                    }
                });
                Object.defineProperty(exports1, "NullLogger", {
                    enumerable: true,
                    get: function get() {
                        return connection_1.NullLogger;
                    }
                });
                Object.defineProperty(exports1, "createMessageConnection", {
                    enumerable: true,
                    get: function get() {
                        return connection_1.createMessageConnection;
                    }
                });
                Object.defineProperty(exports1, "ProgressToken", {
                    enumerable: true,
                    get: function get() {
                        return connection_1.ProgressToken;
                    }
                });
                Object.defineProperty(exports1, "ProgressType", {
                    enumerable: true,
                    get: function get() {
                        return connection_1.ProgressType;
                    }
                });
                Object.defineProperty(exports1, "Trace", {
                    enumerable: true,
                    get: function get() {
                        return connection_1.Trace;
                    }
                });
                Object.defineProperty(exports1, "TraceValues", {
                    enumerable: true,
                    get: function get() {
                        return connection_1.TraceValues;
                    }
                });
                Object.defineProperty(exports1, "TraceFormat", {
                    enumerable: true,
                    get: function get() {
                        return connection_1.TraceFormat;
                    }
                });
                Object.defineProperty(exports1, "SetTraceNotification", {
                    enumerable: true,
                    get: function get() {
                        return connection_1.SetTraceNotification;
                    }
                });
                Object.defineProperty(exports1, "LogTraceNotification", {
                    enumerable: true,
                    get: function get() {
                        return connection_1.LogTraceNotification;
                    }
                });
                Object.defineProperty(exports1, "ConnectionErrors", {
                    enumerable: true,
                    get: function get() {
                        return connection_1.ConnectionErrors;
                    }
                });
                Object.defineProperty(exports1, "ConnectionError", {
                    enumerable: true,
                    get: function get() {
                        return connection_1.ConnectionError;
                    }
                });
                Object.defineProperty(exports1, "CancellationReceiverStrategy", {
                    enumerable: true,
                    get: function get() {
                        return connection_1.CancellationReceiverStrategy;
                    }
                });
                Object.defineProperty(exports1, "CancellationSenderStrategy", {
                    enumerable: true,
                    get: function get() {
                        return connection_1.CancellationSenderStrategy;
                    }
                });
                Object.defineProperty(exports1, "CancellationStrategy", {
                    enumerable: true,
                    get: function get() {
                        return connection_1.CancellationStrategy;
                    }
                });
                var ral_1 = __nested_webpack_require_1765005__(5706);
                exports1.RAL = ral_1.default;
            //# sourceMappingURL=api.js.map
            /***/ },
            /***/ 415: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1781967__) {
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.CancellationTokenSource = exports1.CancellationToken = void 0;
                var ral_1 = __nested_webpack_require_1781967__(5706);
                var Is = __nested_webpack_require_1781967__(8811);
                var events_1 = __nested_webpack_require_1781967__(5165);
                var CancellationToken;
                (function(CancellationToken) {
                    var is = function is(value) {
                        var candidate = value;
                        return candidate && (candidate === CancellationToken.None || candidate === CancellationToken.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
                    };
                    CancellationToken.None = Object.freeze({
                        isCancellationRequested: false,
                        onCancellationRequested: events_1.Event.None
                    });
                    CancellationToken.Cancelled = Object.freeze({
                        isCancellationRequested: true,
                        onCancellationRequested: events_1.Event.None
                    });
                    CancellationToken.is = is;
                })(CancellationToken = exports1.CancellationToken || (exports1.CancellationToken = {}));
                var shortcutEvent = Object.freeze(function(callback, context) {
                    var handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
                    return {
                        dispose: function dispose() {
                            handle.dispose();
                        }
                    };
                });
                var MutableToken = /*#__PURE__*/ function() {
                    function MutableToken() {
                        _class_call_check(this, MutableToken);
                        this._isCancelled = false;
                    }
                    _create_class(MutableToken, [
                        {
                            key: "cancel",
                            value: function cancel() {
                                if (!this._isCancelled) {
                                    this._isCancelled = true;
                                    if (this._emitter) {
                                        this._emitter.fire(undefined);
                                        this.dispose();
                                    }
                                }
                            }
                        },
                        {
                            key: "isCancellationRequested",
                            get: function get() {
                                return this._isCancelled;
                            }
                        },
                        {
                            key: "onCancellationRequested",
                            get: function get() {
                                if (this._isCancelled) {
                                    return shortcutEvent;
                                }
                                if (!this._emitter) {
                                    this._emitter = new events_1.Emitter();
                                }
                                return this._emitter.event;
                            }
                        },
                        {
                            key: "dispose",
                            value: function dispose() {
                                if (this._emitter) {
                                    this._emitter.dispose();
                                    this._emitter = undefined;
                                }
                            }
                        }
                    ]);
                    return MutableToken;
                }();
                var CancellationTokenSource = /*#__PURE__*/ function() {
                    function CancellationTokenSource() {
                        _class_call_check(this, CancellationTokenSource);
                    }
                    _create_class(CancellationTokenSource, [
                        {
                            key: "token",
                            get: function get() {
                                if (!this._token) {
                                    // be lazy and create the token only when
                                    // actually needed
                                    this._token = new MutableToken();
                                }
                                return this._token;
                            }
                        },
                        {
                            key: "cancel",
                            value: function cancel() {
                                if (!this._token) {
                                    // save an object by returning the default
                                    // cancelled token when cancellation happens
                                    // before someone asks for the token
                                    this._token = CancellationToken.Cancelled;
                                } else {
                                    this._token.cancel();
                                }
                            }
                        },
                        {
                            key: "dispose",
                            value: function dispose() {
                                if (!this._token) {
                                    // ensure to initialize with an empty token if we had none
                                    this._token = CancellationToken.None;
                                } else if (_instanceof(this._token, MutableToken)) {
                                    // actually dispose
                                    this._token.dispose();
                                }
                            }
                        }
                    ]);
                    return CancellationTokenSource;
                }();
                exports1.CancellationTokenSource = CancellationTokenSource;
            //# sourceMappingURL=cancellation.js.map
            /***/ },
            /***/ 1908: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1788703__) {
                "use strict";
                var createMessageConnection = function createMessageConnection(messageReader, messageWriter, _logger, options) {
                    var logger = _logger !== undefined ? _logger : exports1.NullLogger;
                    var sequenceNumber = 0;
                    var notificationSequenceNumber = 0;
                    var unknownResponseSequenceNumber = 0;
                    var version = "2.0";
                    var starRequestHandler = undefined;
                    var requestHandlers = new Map();
                    var starNotificationHandler = undefined;
                    var notificationHandlers = new Map();
                    var progressHandlers = new Map();
                    var timer;
                    var messageQueue = new linkedMap_1.LinkedMap();
                    var responsePromises = new Map();
                    var knownCanceledRequests = new Set();
                    var requestTokens = new Map();
                    var trace = Trace.Off;
                    var traceFormat = TraceFormat.Text;
                    var tracer;
                    var state = ConnectionState.New;
                    var errorEmitter = new events_1.Emitter();
                    var closeEmitter = new events_1.Emitter();
                    var unhandledNotificationEmitter = new events_1.Emitter();
                    var unhandledProgressEmitter = new events_1.Emitter();
                    var disposeEmitter = new events_1.Emitter();
                    var cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
                    function createRequestQueueKey(id) {
                        if (id === null) {
                            throw new Error("Can't send requests with id null since the response can't be correlated.");
                        }
                        return "req-" + id.toString();
                    }
                    function createResponseQueueKey(id) {
                        if (id === null) {
                            return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
                        } else {
                            return "res-" + id.toString();
                        }
                    }
                    function createNotificationQueueKey() {
                        return "not-" + (++notificationSequenceNumber).toString();
                    }
                    function addMessageToQueue(queue, message) {
                        if (messages_1.Message.isRequest(message)) {
                            queue.set(createRequestQueueKey(message.id), message);
                        } else if (messages_1.Message.isResponse(message)) {
                            queue.set(createResponseQueueKey(message.id), message);
                        } else {
                            queue.set(createNotificationQueueKey(), message);
                        }
                    }
                    function cancelUndispatched(_message) {
                        return undefined;
                    }
                    function isListening() {
                        return state === ConnectionState.Listening;
                    }
                    function isClosed() {
                        return state === ConnectionState.Closed;
                    }
                    function isDisposed() {
                        return state === ConnectionState.Disposed;
                    }
                    function closeHandler() {
                        if (state === ConnectionState.New || state === ConnectionState.Listening) {
                            state = ConnectionState.Closed;
                            closeEmitter.fire(undefined);
                        }
                    // If the connection is disposed don't sent close events.
                    }
                    function readErrorHandler(error) {
                        errorEmitter.fire([
                            error,
                            undefined,
                            undefined
                        ]);
                    }
                    function writeErrorHandler(data) {
                        errorEmitter.fire(data);
                    }
                    messageReader.onClose(closeHandler);
                    messageReader.onError(readErrorHandler);
                    messageWriter.onClose(closeHandler);
                    messageWriter.onError(writeErrorHandler);
                    function triggerMessageQueue() {
                        if (timer || messageQueue.size === 0) {
                            return;
                        }
                        timer = (0, ral_1.default)().timer.setImmediate(function() {
                            timer = undefined;
                            processMessageQueue();
                        });
                    }
                    function processMessageQueue() {
                        if (messageQueue.size === 0) {
                            return;
                        }
                        var message = messageQueue.shift();
                        try {
                            if (messages_1.Message.isRequest(message)) {
                                handleRequest(message);
                            } else if (messages_1.Message.isNotification(message)) {
                                handleNotification(message);
                            } else if (messages_1.Message.isResponse(message)) {
                                handleResponse(message);
                            } else {
                                handleInvalidMessage(message);
                            }
                        } finally{
                            triggerMessageQueue();
                        }
                    }
                    var callback = function(message) {
                        try {
                            // We have received a cancellation message. Check if the message is still in the queue
                            // and cancel it if allowed to do so.
                            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
                                var cancelId = message.params.id;
                                var key = createRequestQueueKey(cancelId);
                                var toCancel = messageQueue.get(key);
                                if (messages_1.Message.isRequest(toCancel)) {
                                    var strategy = options === null || options === void 0 ? void 0 : options.connectionStrategy;
                                    var response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                                    if (response && (response.error !== undefined || response.result !== undefined)) {
                                        messageQueue.delete(key);
                                        requestTokens.delete(cancelId);
                                        response.id = toCancel.id;
                                        traceSendingResponse(response, message.method, Date.now());
                                        messageWriter.write(response).catch(function() {
                                            return logger.error("Sending response for canceled message failed.");
                                        });
                                        return;
                                    }
                                }
                                var cancellationToken = requestTokens.get(cancelId);
                                // The request is already running. Cancel the token
                                if (cancellationToken !== undefined) {
                                    cancellationToken.cancel();
                                    traceReceivedNotification(message);
                                    return;
                                } else {
                                    // Remember the cancel but still queue the message to
                                    // clean up state in process message.
                                    knownCanceledRequests.add(cancelId);
                                }
                            }
                            addMessageToQueue(messageQueue, message);
                        } finally{
                            triggerMessageQueue();
                        }
                    };
                    function handleRequest(requestMessage) {
                        if (isDisposed()) {
                            // we return here silently since we fired an event when the
                            // connection got disposed.
                            return;
                        }
                        function reply(resultOrError, method, startTime) {
                            var message = {
                                jsonrpc: version,
                                id: requestMessage.id
                            };
                            if (_instanceof(resultOrError, messages_1.ResponseError)) {
                                message.error = resultOrError.toJson();
                            } else {
                                message.result = resultOrError === undefined ? null : resultOrError;
                            }
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(function() {
                                return logger.error("Sending response failed.");
                            });
                        }
                        function replyError(error, method, startTime) {
                            var message = {
                                jsonrpc: version,
                                id: requestMessage.id,
                                error: error.toJson()
                            };
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(function() {
                                return logger.error("Sending response failed.");
                            });
                        }
                        function replySuccess(result, method, startTime) {
                            // The JSON RPC defines that a response must either have a result or an error
                            // So we can't treat undefined as a valid response result.
                            if (result === undefined) {
                                result = null;
                            }
                            var message = {
                                jsonrpc: version,
                                id: requestMessage.id,
                                result: result
                            };
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(function() {
                                return logger.error("Sending response failed.");
                            });
                        }
                        traceReceivedRequest(requestMessage);
                        var element = requestHandlers.get(requestMessage.method);
                        var type;
                        var requestHandler;
                        if (element) {
                            type = element.type;
                            requestHandler = element.handler;
                        }
                        var startTime = Date.now();
                        if (requestHandler || starRequestHandler) {
                            var _requestMessage_id;
                            var tokenKey = (_requestMessage_id = requestMessage.id) !== null && _requestMessage_id !== void 0 ? _requestMessage_id : String(Date.now()); //
                            var cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);
                            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
                                cancellationSource.cancel();
                            }
                            if (requestMessage.id !== null) {
                                requestTokens.set(tokenKey, cancellationSource);
                            }
                            try {
                                var handlerResult;
                                if (requestHandler) {
                                    if (requestMessage.params === undefined) {
                                        if (type !== undefined && type.numberOfParams !== 0) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, "Request ".concat(requestMessage.method, " defines ").concat(type.numberOfParams, " params but received none.")), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(cancellationSource.token);
                                    } else if (Array.isArray(requestMessage.params)) {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, "Request ".concat(requestMessage.method, " defines parameters by name but received parameters by position")), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler.apply(void 0, _to_consumable_array(requestMessage.params).concat([
                                            cancellationSource.token
                                        ]));
                                    } else {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, "Request ".concat(requestMessage.method, " defines parameters by position but received parameters by name")), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                                    }
                                } else if (starRequestHandler) {
                                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                                }
                                var promise = handlerResult;
                                if (!handlerResult) {
                                    requestTokens.delete(tokenKey);
                                    replySuccess(handlerResult, requestMessage.method, startTime);
                                } else if (promise.then) {
                                    promise.then(function(resultOrError) {
                                        requestTokens.delete(tokenKey);
                                        reply(resultOrError, requestMessage.method, startTime);
                                    }, function(error) {
                                        requestTokens.delete(tokenKey);
                                        if (_instanceof(error, messages_1.ResponseError)) {
                                            replyError(error, requestMessage.method, startTime);
                                        } else if (error && Is.string(error.message)) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, "Request ".concat(requestMessage.method, " failed with message: ").concat(error.message)), requestMessage.method, startTime);
                                        } else {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, "Request ".concat(requestMessage.method, " failed unexpectedly without providing any details.")), requestMessage.method, startTime);
                                        }
                                    });
                                } else {
                                    requestTokens.delete(tokenKey);
                                    reply(handlerResult, requestMessage.method, startTime);
                                }
                            } catch (error) {
                                requestTokens.delete(tokenKey);
                                if (_instanceof(error, messages_1.ResponseError)) {
                                    reply(error, requestMessage.method, startTime);
                                } else if (error && Is.string(error.message)) {
                                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, "Request ".concat(requestMessage.method, " failed with message: ").concat(error.message)), requestMessage.method, startTime);
                                } else {
                                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, "Request ".concat(requestMessage.method, " failed unexpectedly without providing any details.")), requestMessage.method, startTime);
                                }
                            }
                        } else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, "Unhandled method ".concat(requestMessage.method)), requestMessage.method, startTime);
                        }
                    }
                    function handleResponse(responseMessage) {
                        if (isDisposed()) {
                            // See handle request.
                            return;
                        }
                        if (responseMessage.id === null) {
                            if (responseMessage.error) {
                                logger.error("Received response message without id: Error is: \n".concat(JSON.stringify(responseMessage.error, undefined, 4)));
                            } else {
                                logger.error("Received response message without id. No further error information provided.");
                            }
                        } else {
                            var key = responseMessage.id;
                            var responsePromise = responsePromises.get(key);
                            traceReceivedResponse(responseMessage, responsePromise);
                            if (responsePromise !== undefined) {
                                responsePromises.delete(key);
                                try {
                                    if (responseMessage.error) {
                                        var _$error = responseMessage.error;
                                        responsePromise.reject(new messages_1.ResponseError(_$error.code, _$error.message, _$error.data));
                                    } else if (responseMessage.result !== undefined) {
                                        responsePromise.resolve(responseMessage.result);
                                    } else {
                                        throw new Error("Should never happen.");
                                    }
                                } catch (error) {
                                    if (error.message) {
                                        logger.error("Response handler '".concat(responsePromise.method, "' failed with message: ").concat(error.message));
                                    } else {
                                        logger.error("Response handler '".concat(responsePromise.method, "' failed unexpectedly."));
                                    }
                                }
                            }
                        }
                    }
                    function handleNotification(message) {
                        if (isDisposed()) {
                            // See handle request.
                            return;
                        }
                        var type = undefined;
                        var notificationHandler;
                        if (message.method === CancelNotification.type.method) {
                            var cancelId = message.params.id;
                            knownCanceledRequests.delete(cancelId);
                            traceReceivedNotification(message);
                            return;
                        } else {
                            var element = notificationHandlers.get(message.method);
                            if (element) {
                                notificationHandler = element.handler;
                                type = element.type;
                            }
                        }
                        if (notificationHandler || starNotificationHandler) {
                            try {
                                traceReceivedNotification(message);
                                if (notificationHandler) {
                                    if (message.params === undefined) {
                                        if (type !== undefined) {
                                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                                                logger.error("Notification ".concat(message.method, " defines ").concat(type.numberOfParams, " params but received none."));
                                            }
                                        }
                                        notificationHandler();
                                    } else if (Array.isArray(message.params)) {
                                        // There are JSON-RPC libraries that send progress message as positional params although
                                        // specified as named. So convert them if this is the case.
                                        var params = message.params;
                                        if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                                            notificationHandler({
                                                token: params[0],
                                                value: params[1]
                                            });
                                        } else {
                                            if (type !== undefined) {
                                                if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                                                    logger.error("Notification ".concat(message.method, " defines parameters by name but received parameters by position"));
                                                }
                                                if (type.numberOfParams !== message.params.length) {
                                                    logger.error("Notification ".concat(message.method, " defines ").concat(type.numberOfParams, " params but received ").concat(params.length, " arguments"));
                                                }
                                            }
                                            notificationHandler.apply(void 0, _to_consumable_array(params));
                                        }
                                    } else {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                                            logger.error("Notification ".concat(message.method, " defines parameters by position but received parameters by name"));
                                        }
                                        notificationHandler(message.params);
                                    }
                                } else if (starNotificationHandler) {
                                    starNotificationHandler(message.method, message.params);
                                }
                            } catch (error) {
                                if (error.message) {
                                    logger.error("Notification handler '".concat(message.method, "' failed with message: ").concat(error.message));
                                } else {
                                    logger.error("Notification handler '".concat(message.method, "' failed unexpectedly."));
                                }
                            }
                        } else {
                            unhandledNotificationEmitter.fire(message);
                        }
                    }
                    function handleInvalidMessage(message) {
                        if (!message) {
                            logger.error("Received empty message.");
                            return;
                        }
                        logger.error("Received message which is neither a response nor a notification message:\n".concat(JSON.stringify(message, null, 4)));
                        // Test whether we find an id to reject the promise
                        var responseMessage = message;
                        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
                            var key = responseMessage.id;
                            var responseHandler = responsePromises.get(key);
                            if (responseHandler) {
                                responseHandler.reject(new Error("The received response has neither a result nor an error property."));
                            }
                        }
                    }
                    function stringifyTrace(params) {
                        if (params === undefined || params === null) {
                            return undefined;
                        }
                        switch(trace){
                            case Trace.Verbose:
                                return JSON.stringify(params, null, 4);
                            case Trace.Compact:
                                return JSON.stringify(params);
                            default:
                                return undefined;
                        }
                    }
                    function traceSendingRequest(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            var data = undefined;
                            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                                data = "Params: ".concat(stringifyTrace(message.params), "\n\n");
                            }
                            tracer.log("Sending request '".concat(message.method, " - (").concat(message.id, ")'."), data);
                        } else {
                            logLSPMessage("send-request", message);
                        }
                    }
                    function traceSendingNotification(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            var data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.params) {
                                    data = "Params: ".concat(stringifyTrace(message.params), "\n\n");
                                } else {
                                    data = "No parameters provided.\n\n";
                                }
                            }
                            tracer.log("Sending notification '".concat(message.method, "'."), data);
                        } else {
                            logLSPMessage("send-notification", message);
                        }
                    }
                    function traceSendingResponse(message, method, startTime) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            var data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.error && message.error.data) {
                                    data = "Error data: ".concat(stringifyTrace(message.error.data), "\n\n");
                                } else {
                                    if (message.result) {
                                        data = "Result: ".concat(stringifyTrace(message.result), "\n\n");
                                    } else if (message.error === undefined) {
                                        data = "No result returned.\n\n";
                                    }
                                }
                            }
                            tracer.log("Sending response '".concat(method, " - (").concat(message.id, ")'. Processing request took ").concat(Date.now() - startTime, "ms"), data);
                        } else {
                            logLSPMessage("send-response", message);
                        }
                    }
                    function traceReceivedRequest(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            var data = undefined;
                            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                                data = "Params: ".concat(stringifyTrace(message.params), "\n\n");
                            }
                            tracer.log("Received request '".concat(message.method, " - (").concat(message.id, ")'."), data);
                        } else {
                            logLSPMessage("receive-request", message);
                        }
                    }
                    function traceReceivedNotification(message) {
                        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            var data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.params) {
                                    data = "Params: ".concat(stringifyTrace(message.params), "\n\n");
                                } else {
                                    data = "No parameters provided.\n\n";
                                }
                            }
                            tracer.log("Received notification '".concat(message.method, "'."), data);
                        } else {
                            logLSPMessage("receive-notification", message);
                        }
                    }
                    function traceReceivedResponse(message, responsePromise) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            var data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.error && message.error.data) {
                                    data = "Error data: ".concat(stringifyTrace(message.error.data), "\n\n");
                                } else {
                                    if (message.result) {
                                        data = "Result: ".concat(stringifyTrace(message.result), "\n\n");
                                    } else if (message.error === undefined) {
                                        data = "No result returned.\n\n";
                                    }
                                }
                            }
                            if (responsePromise) {
                                var error = message.error ? " Request failed: ".concat(message.error.message, " (").concat(message.error.code, ").") : "";
                                tracer.log("Received response '".concat(responsePromise.method, " - (").concat(message.id, ")' in ").concat(Date.now() - responsePromise.timerStart, "ms.").concat(error), data);
                            } else {
                                tracer.log("Received response ".concat(message.id, " without active response promise."), data);
                            }
                        } else {
                            logLSPMessage("receive-response", message);
                        }
                    }
                    function logLSPMessage(type, message) {
                        if (!tracer || trace === Trace.Off) {
                            return;
                        }
                        var lspMessage = {
                            isLSPMessage: true,
                            type: type,
                            message: message,
                            timestamp: Date.now()
                        };
                        tracer.log(lspMessage);
                    }
                    function throwIfClosedOrDisposed() {
                        if (isClosed()) {
                            throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
                        }
                        if (isDisposed()) {
                            throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
                        }
                    }
                    function throwIfListening() {
                        if (isListening()) {
                            throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
                        }
                    }
                    function throwIfNotListening() {
                        if (!isListening()) {
                            throw new Error("Call listen() first.");
                        }
                    }
                    function undefinedToNull(param) {
                        if (param === undefined) {
                            return null;
                        } else {
                            return param;
                        }
                    }
                    function nullToUndefined(param) {
                        if (param === null) {
                            return undefined;
                        } else {
                            return param;
                        }
                    }
                    function isNamedParam(param) {
                        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === "object";
                    }
                    function computeSingleParam(parameterStructures, param) {
                        switch(parameterStructures){
                            case messages_1.ParameterStructures.auto:
                                if (isNamedParam(param)) {
                                    return nullToUndefined(param);
                                } else {
                                    return [
                                        undefinedToNull(param)
                                    ];
                                }
                            case messages_1.ParameterStructures.byName:
                                if (!isNamedParam(param)) {
                                    throw new Error("Received parameters by name but param is not an object literal.");
                                }
                                return nullToUndefined(param);
                            case messages_1.ParameterStructures.byPosition:
                                return [
                                    undefinedToNull(param)
                                ];
                            default:
                                throw new Error("Unknown parameter structure ".concat(parameterStructures.toString()));
                        }
                    }
                    function computeMessageParams(type, params) {
                        var result;
                        var numberOfParams = type.numberOfParams;
                        switch(numberOfParams){
                            case 0:
                                result = undefined;
                                break;
                            case 1:
                                result = computeSingleParam(type.parameterStructures, params[0]);
                                break;
                            default:
                                result = [];
                                for(var i = 0; i < params.length && i < numberOfParams; i++){
                                    result.push(undefinedToNull(params[i]));
                                }
                                if (params.length < numberOfParams) {
                                    for(var i1 = params.length; i1 < numberOfParams; i1++){
                                        result.push(null);
                                    }
                                }
                                break;
                        }
                        return result;
                    }
                    var connection = {
                        sendNotification: function(type) {
                            for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                                args[_key - 1] = arguments[_key];
                            }
                            throwIfClosedOrDisposed();
                            var method;
                            var messageParams;
                            if (Is.string(type)) {
                                method = type;
                                var first = args[0];
                                var paramStart = 0;
                                var parameterStructures = messages_1.ParameterStructures.auto;
                                if (messages_1.ParameterStructures.is(first)) {
                                    paramStart = 1;
                                    parameterStructures = first;
                                }
                                var paramEnd = args.length;
                                var numberOfParams = paramEnd - paramStart;
                                switch(numberOfParams){
                                    case 0:
                                        messageParams = undefined;
                                        break;
                                    case 1:
                                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                                        break;
                                    default:
                                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                                            throw new Error("Received ".concat(numberOfParams, " parameters for 'by Name' notification parameter structure."));
                                        }
                                        messageParams = args.slice(paramStart, paramEnd).map(function(value) {
                                            return undefinedToNull(value);
                                        });
                                        break;
                                }
                            } else {
                                var params = args;
                                method = type.method;
                                messageParams = computeMessageParams(type, params);
                            }
                            var notificationMessage = {
                                jsonrpc: version,
                                method: method,
                                params: messageParams
                            };
                            traceSendingNotification(notificationMessage);
                            return messageWriter.write(notificationMessage).catch(function() {
                                return logger.error("Sending notification failed.");
                            });
                        },
                        onNotification: function(type, handler) {
                            throwIfClosedOrDisposed();
                            var method;
                            if (Is.func(type)) {
                                starNotificationHandler = type;
                            } else if (handler) {
                                if (Is.string(type)) {
                                    method = type;
                                    notificationHandlers.set(type, {
                                        type: undefined,
                                        handler: handler
                                    });
                                } else {
                                    method = type.method;
                                    notificationHandlers.set(type.method, {
                                        type: type,
                                        handler: handler
                                    });
                                }
                            }
                            return {
                                dispose: function() {
                                    if (method !== undefined) {
                                        notificationHandlers.delete(method);
                                    } else {
                                        starNotificationHandler = undefined;
                                    }
                                }
                            };
                        },
                        onProgress: function(_type, token, handler) {
                            if (progressHandlers.has(token)) {
                                throw new Error("Progress handler for token ".concat(token, " already registered"));
                            }
                            progressHandlers.set(token, handler);
                            return {
                                dispose: function() {
                                    progressHandlers.delete(token);
                                }
                            };
                        },
                        sendProgress: function(_type, token, value) {
                            return connection.sendNotification(ProgressNotification.type, {
                                token: token,
                                value: value
                            });
                        },
                        onUnhandledProgress: unhandledProgressEmitter.event,
                        sendRequest: function(type) {
                            for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                                args[_key - 1] = arguments[_key];
                            }
                            throwIfClosedOrDisposed();
                            throwIfNotListening();
                            var method;
                            var messageParams;
                            var token = undefined;
                            if (Is.string(type)) {
                                method = type;
                                var first = args[0];
                                var last = args[args.length - 1];
                                var paramStart = 0;
                                var parameterStructures = messages_1.ParameterStructures.auto;
                                if (messages_1.ParameterStructures.is(first)) {
                                    paramStart = 1;
                                    parameterStructures = first;
                                }
                                var paramEnd = args.length;
                                if (cancellation_1.CancellationToken.is(last)) {
                                    paramEnd = paramEnd - 1;
                                    token = last;
                                }
                                var numberOfParams = paramEnd - paramStart;
                                switch(numberOfParams){
                                    case 0:
                                        messageParams = undefined;
                                        break;
                                    case 1:
                                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                                        break;
                                    default:
                                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                                            throw new Error("Received ".concat(numberOfParams, " parameters for 'by Name' request parameter structure."));
                                        }
                                        messageParams = args.slice(paramStart, paramEnd).map(function(value) {
                                            return undefinedToNull(value);
                                        });
                                        break;
                                }
                            } else {
                                var params = args;
                                method = type.method;
                                messageParams = computeMessageParams(type, params);
                                var numberOfParams1 = type.numberOfParams;
                                token = cancellation_1.CancellationToken.is(params[numberOfParams1]) ? params[numberOfParams1] : undefined;
                            }
                            var id = sequenceNumber++;
                            var disposable;
                            if (token) {
                                disposable = token.onCancellationRequested(function() {
                                    var p = cancellationStrategy.sender.sendCancellation(connection, id);
                                    if (p === undefined) {
                                        logger.log("Received no promise from cancellation strategy when cancelling id ".concat(id));
                                        return Promise.resolve();
                                    } else {
                                        return p.catch(function() {
                                            logger.log("Sending cancellation messages for id ".concat(id, " failed"));
                                        });
                                    }
                                });
                            }
                            var result = new Promise(function(resolve, reject) {
                                var requestMessage = {
                                    jsonrpc: version,
                                    id: id,
                                    method: method,
                                    params: messageParams
                                };
                                var resolveWithCleanup = function(r) {
                                    resolve(r);
                                    cancellationStrategy.sender.cleanup(id);
                                    disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
                                };
                                var rejectWithCleanup = function(r) {
                                    reject(r);
                                    cancellationStrategy.sender.cleanup(id);
                                    disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
                                };
                                var responsePromise = {
                                    method: method,
                                    timerStart: Date.now(),
                                    resolve: resolveWithCleanup,
                                    reject: rejectWithCleanup
                                };
                                traceSendingRequest(requestMessage);
                                try {
                                    messageWriter.write(requestMessage).catch(function() {
                                        return logger.error("Sending request failed.");
                                    });
                                } catch (e) {
                                    // Writing the message failed. So we need to reject the promise.
                                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : "Unknown reason"));
                                    responsePromise = null;
                                }
                                if (responsePromise) {
                                    responsePromises.set(id, responsePromise);
                                }
                            });
                            return result;
                        },
                        onRequest: function(type, handler) {
                            throwIfClosedOrDisposed();
                            var method = null;
                            if (StarRequestHandler.is(type)) {
                                method = undefined;
                                starRequestHandler = type;
                            } else if (Is.string(type)) {
                                method = null;
                                if (handler !== undefined) {
                                    method = type;
                                    requestHandlers.set(type, {
                                        handler: handler,
                                        type: undefined
                                    });
                                }
                            } else {
                                if (handler !== undefined) {
                                    method = type.method;
                                    requestHandlers.set(type.method, {
                                        type: type,
                                        handler: handler
                                    });
                                }
                            }
                            return {
                                dispose: function() {
                                    if (method === null) {
                                        return;
                                    }
                                    if (method !== undefined) {
                                        requestHandlers.delete(method);
                                    } else {
                                        starRequestHandler = undefined;
                                    }
                                }
                            };
                        },
                        hasPendingResponse: function() {
                            return responsePromises.size > 0;
                        },
                        trace: function() {
                            var _ref = _async_to_generator(function(_value, _tracer, sendNotificationOrTraceOptions) {
                                var _sendNotification, _traceFormat;
                                return _ts_generator(this, function(_state) {
                                    switch(_state.label){
                                        case 0:
                                            _sendNotification = false;
                                            _traceFormat = TraceFormat.Text;
                                            if (sendNotificationOrTraceOptions !== undefined) {
                                                if (Is.boolean(sendNotificationOrTraceOptions)) {
                                                    _sendNotification = sendNotificationOrTraceOptions;
                                                } else {
                                                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                                                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                                                }
                                            }
                                            trace = _value;
                                            traceFormat = _traceFormat;
                                            if (trace === Trace.Off) {
                                                tracer = undefined;
                                            } else {
                                                tracer = _tracer;
                                            }
                                            if (!(_sendNotification && !isClosed() && !isDisposed())) return [
                                                3,
                                                2
                                            ];
                                            return [
                                                4,
                                                connection.sendNotification(SetTraceNotification.type, {
                                                    value: Trace.toString(_value)
                                                })
                                            ];
                                        case 1:
                                            _state.sent();
                                            _state.label = 2;
                                        case 2:
                                            return [
                                                2
                                            ];
                                    }
                                });
                            });
                            return function(_value, _tracer, sendNotificationOrTraceOptions) {
                                return _ref.apply(this, arguments);
                            };
                        }(),
                        onError: errorEmitter.event,
                        onClose: closeEmitter.event,
                        onUnhandledNotification: unhandledNotificationEmitter.event,
                        onDispose: disposeEmitter.event,
                        end: function() {
                            messageWriter.end();
                        },
                        dispose: function() {
                            if (isDisposed()) {
                                return;
                            }
                            state = ConnectionState.Disposed;
                            disposeEmitter.fire(undefined);
                            var error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
                            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                            try {
                                for(var _iterator = responsePromises.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                    var promise = _step.value;
                                    promise.reject(error);
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                                        _iterator.return();
                                    }
                                } finally{
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                            responsePromises = new Map();
                            requestTokens = new Map();
                            knownCanceledRequests = new Set();
                            messageQueue = new linkedMap_1.LinkedMap();
                            // Test for backwards compatibility
                            if (Is.func(messageWriter.dispose)) {
                                messageWriter.dispose();
                            }
                            if (Is.func(messageReader.dispose)) {
                                messageReader.dispose();
                            }
                        },
                        listen: function() {
                            throwIfClosedOrDisposed();
                            throwIfListening();
                            state = ConnectionState.Listening;
                            messageReader.listen(callback);
                        },
                        inspect: function() {
                            // eslint-disable-next-line no-console
                            (0, ral_1.default)().console.log("inspect");
                        }
                    };
                    connection.onNotification(LogTraceNotification.type, function(params) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        var verbose = trace === Trace.Verbose || trace === Trace.Compact;
                        tracer.log(params.message, verbose ? params.verbose : undefined);
                    });
                    connection.onNotification(ProgressNotification.type, function(params) {
                        var handler = progressHandlers.get(params.token);
                        if (handler) {
                            handler(params.value);
                        } else {
                            unhandledProgressEmitter.fire(params);
                        }
                    });
                    return connection;
                };
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createMessageConnection = exports1.ConnectionOptions = exports1.CancellationStrategy = exports1.CancellationSenderStrategy = exports1.CancellationReceiverStrategy = exports1.ConnectionStrategy = exports1.ConnectionError = exports1.ConnectionErrors = exports1.LogTraceNotification = exports1.SetTraceNotification = exports1.TraceFormat = exports1.TraceValues = exports1.Trace = exports1.NullLogger = exports1.ProgressType = exports1.ProgressToken = void 0;
                var ral_1 = __nested_webpack_require_1788703__(5706);
                var Is = __nested_webpack_require_1788703__(8811);
                var messages_1 = __nested_webpack_require_1788703__(9141);
                var linkedMap_1 = __nested_webpack_require_1788703__(7040);
                var events_1 = __nested_webpack_require_1788703__(5165);
                var cancellation_1 = __nested_webpack_require_1788703__(415);
                var CancelNotification;
                (function(CancelNotification) {
                    CancelNotification.type = new messages_1.NotificationType("$/cancelRequest");
                })(CancelNotification || (CancelNotification = {}));
                var ProgressToken;
                (function(ProgressToken) {
                    var is = function is(value) {
                        return typeof value === "string" || typeof value === "number";
                    };
                    ProgressToken.is = is;
                })(ProgressToken = exports1.ProgressToken || (exports1.ProgressToken = {}));
                var ProgressNotification;
                (function(ProgressNotification) {
                    ProgressNotification.type = new messages_1.NotificationType("$/progress");
                })(ProgressNotification || (ProgressNotification = {}));
                var ProgressType = function ProgressType() {
                    _class_call_check(this, ProgressType);
                };
                exports1.ProgressType = ProgressType;
                var StarRequestHandler;
                (function(StarRequestHandler) {
                    var is = function is(value) {
                        return Is.func(value);
                    };
                    StarRequestHandler.is = is;
                })(StarRequestHandler || (StarRequestHandler = {}));
                exports1.NullLogger = Object.freeze({
                    error: function() {},
                    warn: function() {},
                    info: function() {},
                    log: function() {}
                });
                var Trace;
                (function(Trace) {
                    Trace[Trace["Off"] = 0] = "Off";
                    Trace[Trace["Messages"] = 1] = "Messages";
                    Trace[Trace["Compact"] = 2] = "Compact";
                    Trace[Trace["Verbose"] = 3] = "Verbose";
                })(Trace = exports1.Trace || (exports1.Trace = {}));
                var TraceValues;
                (function(TraceValues) {
                    /**
     * Turn tracing off.
     */ TraceValues.Off = "off";
                    /**
     * Trace messages only.
     */ TraceValues.Messages = "messages";
                    /**
     * Compact message tracing.
     */ TraceValues.Compact = "compact";
                    /**
     * Verbose message tracing.
     */ TraceValues.Verbose = "verbose";
                })(TraceValues = exports1.TraceValues || (exports1.TraceValues = {}));
                (function(Trace) {
                    var fromString = function fromString(value) {
                        if (!Is.string(value)) {
                            return Trace.Off;
                        }
                        value = value.toLowerCase();
                        switch(value){
                            case "off":
                                return Trace.Off;
                            case "messages":
                                return Trace.Messages;
                            case "compact":
                                return Trace.Compact;
                            case "verbose":
                                return Trace.Verbose;
                            default:
                                return Trace.Off;
                        }
                    };
                    var toString = function toString(value) {
                        switch(value){
                            case Trace.Off:
                                return "off";
                            case Trace.Messages:
                                return "messages";
                            case Trace.Compact:
                                return "compact";
                            case Trace.Verbose:
                                return "verbose";
                            default:
                                return "off";
                        }
                    };
                    Trace.fromString = fromString;
                    Trace.toString = toString;
                })(Trace = exports1.Trace || (exports1.Trace = {}));
                var TraceFormat;
                (function(TraceFormat) {
                    TraceFormat["Text"] = "text";
                    TraceFormat["JSON"] = "json";
                })(TraceFormat = exports1.TraceFormat || (exports1.TraceFormat = {}));
                (function(TraceFormat) {
                    var fromString = function fromString(value) {
                        if (!Is.string(value)) {
                            return TraceFormat.Text;
                        }
                        value = value.toLowerCase();
                        if (value === "json") {
                            return TraceFormat.JSON;
                        } else {
                            return TraceFormat.Text;
                        }
                    };
                    TraceFormat.fromString = fromString;
                })(TraceFormat = exports1.TraceFormat || (exports1.TraceFormat = {}));
                var SetTraceNotification;
                (function(SetTraceNotification) {
                    SetTraceNotification.type = new messages_1.NotificationType("$/setTrace");
                })(SetTraceNotification = exports1.SetTraceNotification || (exports1.SetTraceNotification = {}));
                var LogTraceNotification;
                (function(LogTraceNotification) {
                    LogTraceNotification.type = new messages_1.NotificationType("$/logTrace");
                })(LogTraceNotification = exports1.LogTraceNotification || (exports1.LogTraceNotification = {}));
                var ConnectionErrors;
                (function(ConnectionErrors) {
                    /**
     * The connection is closed.
     */ ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
                    /**
     * The connection got disposed.
     */ ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
                    /**
     * The connection is already in listening mode.
     */ ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
                })(ConnectionErrors = exports1.ConnectionErrors || (exports1.ConnectionErrors = {}));
                var ConnectionError = /*#__PURE__*/ function(Error1) {
                    _inherits(ConnectionError, Error1);
                    var _super = _create_super(ConnectionError);
                    function ConnectionError(code, message) {
                        _class_call_check(this, ConnectionError);
                        var _this;
                        _this = _super.call(this, message);
                        _this.code = code;
                        Object.setPrototypeOf(_assert_this_initialized(_this), ConnectionError.prototype);
                        return _this;
                    }
                    return ConnectionError;
                }(_wrap_native_super(Error));
                exports1.ConnectionError = ConnectionError;
                var ConnectionStrategy;
                (function(ConnectionStrategy) {
                    var is = function is(value) {
                        var candidate = value;
                        return candidate && Is.func(candidate.cancelUndispatched);
                    };
                    ConnectionStrategy.is = is;
                })(ConnectionStrategy = exports1.ConnectionStrategy || (exports1.ConnectionStrategy = {}));
                var CancellationReceiverStrategy;
                (function(CancellationReceiverStrategy) {
                    var is = function is(value) {
                        var candidate = value;
                        return candidate && Is.func(candidate.createCancellationTokenSource);
                    };
                    CancellationReceiverStrategy.Message = Object.freeze({
                        createCancellationTokenSource: function createCancellationTokenSource(_) {
                            return new cancellation_1.CancellationTokenSource();
                        }
                    });
                    CancellationReceiverStrategy.is = is;
                })(CancellationReceiverStrategy = exports1.CancellationReceiverStrategy || (exports1.CancellationReceiverStrategy = {}));
                var CancellationSenderStrategy;
                (function(CancellationSenderStrategy) {
                    var is = function is(value) {
                        var candidate = value;
                        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
                    };
                    CancellationSenderStrategy.Message = Object.freeze({
                        sendCancellation: function sendCancellation(conn, id) {
                            return conn.sendNotification(CancelNotification.type, {
                                id: id
                            });
                        },
                        cleanup: function cleanup(_) {}
                    });
                    CancellationSenderStrategy.is = is;
                })(CancellationSenderStrategy = exports1.CancellationSenderStrategy || (exports1.CancellationSenderStrategy = {}));
                var CancellationStrategy;
                (function(CancellationStrategy) {
                    var is = function is(value) {
                        var candidate = value;
                        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
                    };
                    CancellationStrategy.Message = Object.freeze({
                        receiver: CancellationReceiverStrategy.Message,
                        sender: CancellationSenderStrategy.Message
                    });
                    CancellationStrategy.is = is;
                })(CancellationStrategy = exports1.CancellationStrategy || (exports1.CancellationStrategy = {}));
                var ConnectionOptions;
                (function(ConnectionOptions) {
                    var is = function is(value) {
                        var candidate = value;
                        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));
                    };
                    ConnectionOptions.is = is;
                })(ConnectionOptions = exports1.ConnectionOptions || (exports1.ConnectionOptions = {}));
                var ConnectionState;
                (function(ConnectionState) {
                    ConnectionState[ConnectionState["New"] = 1] = "New";
                    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
                    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
                    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
                })(ConnectionState || (ConnectionState = {}));
                exports1.createMessageConnection = createMessageConnection;
            //# sourceMappingURL=connection.js.map
            /***/ },
            /***/ 8437: /***/ function(__unused_webpack_module, exports1) {
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Disposable = void 0;
                var Disposable;
                (function(Disposable) {
                    var create = function create(func) {
                        return {
                            dispose: func
                        };
                    };
                    Disposable.create = create;
                })(Disposable = exports1.Disposable || (exports1.Disposable = {}));
            //# sourceMappingURL=disposable.js.map
            /***/ },
            /***/ 5165: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1862128__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Emitter = exports1.Event = void 0;
                var ral_1 = __nested_webpack_require_1862128__(5706);
                var Event;
                (function(Event) {
                    var _disposable = {
                        dispose: function dispose() {}
                    };
                    Event.None = function() {
                        return _disposable;
                    };
                })(Event = exports1.Event || (exports1.Event = {}));
                var CallbackList = /*#__PURE__*/ function() {
                    function CallbackList() {
                        _class_call_check(this, CallbackList);
                    }
                    _create_class(CallbackList, [
                        {
                            key: "add",
                            value: function add(callback) {
                                var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, bucket = arguments.length > 2 ? arguments[2] : void 0;
                                var _this = this;
                                if (!this._callbacks) {
                                    this._callbacks = [];
                                    this._contexts = [];
                                }
                                this._callbacks.push(callback);
                                this._contexts.push(context);
                                if (Array.isArray(bucket)) {
                                    bucket.push({
                                        dispose: function() {
                                            return _this.remove(callback, context);
                                        }
                                    });
                                }
                            }
                        },
                        {
                            key: "remove",
                            value: function remove(callback) {
                                var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                                if (!this._callbacks) {
                                    return;
                                }
                                var foundCallbackWithDifferentContext = false;
                                for(var i = 0, len = this._callbacks.length; i < len; i++){
                                    if (this._callbacks[i] === callback) {
                                        if (this._contexts[i] === context) {
                                            // callback & context match => remove it
                                            this._callbacks.splice(i, 1);
                                            this._contexts.splice(i, 1);
                                            return;
                                        } else {
                                            foundCallbackWithDifferentContext = true;
                                        }
                                    }
                                }
                                if (foundCallbackWithDifferentContext) {
                                    throw new Error("When adding a listener with a context, you should remove it with the same context");
                                }
                            }
                        },
                        {
                            key: "invoke",
                            value: function invoke() {
                                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                                    args[_key] = arguments[_key];
                                }
                                if (!this._callbacks) {
                                    return [];
                                }
                                var ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
                                for(var i = 0, len = callbacks.length; i < len; i++){
                                    try {
                                        ret.push(callbacks[i].apply(contexts[i], args));
                                    } catch (e) {
                                        // eslint-disable-next-line no-console
                                        (0, ral_1.default)().console.error(e);
                                    }
                                }
                                return ret;
                            }
                        },
                        {
                            key: "isEmpty",
                            value: function isEmpty() {
                                return !this._callbacks || this._callbacks.length === 0;
                            }
                        },
                        {
                            key: "dispose",
                            value: function dispose() {
                                this._callbacks = undefined;
                                this._contexts = undefined;
                            }
                        }
                    ]);
                    return CallbackList;
                }();
                var Emitter = /*#__PURE__*/ function() {
                    function Emitter(_options) {
                        _class_call_check(this, Emitter);
                        this._options = _options;
                    }
                    _create_class(Emitter, [
                        {
                            key: "event",
                            get: /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */ function get() {
                                var _this = this;
                                if (!this._event) {
                                    this._event = function(listener, thisArgs, disposables) {
                                        if (!_this._callbacks) {
                                            _this._callbacks = new CallbackList();
                                        }
                                        if (_this._options && _this._options.onFirstListenerAdd && _this._callbacks.isEmpty()) {
                                            _this._options.onFirstListenerAdd(_this);
                                        }
                                        _this._callbacks.add(listener, thisArgs);
                                        var result = {
                                            dispose: function() {
                                                if (!_this._callbacks) {
                                                    // disposable is disposed after emitter is disposed.
                                                    return;
                                                }
                                                _this._callbacks.remove(listener, thisArgs);
                                                result.dispose = Emitter._noop;
                                                if (_this._options && _this._options.onLastListenerRemove && _this._callbacks.isEmpty()) {
                                                    _this._options.onLastListenerRemove(_this);
                                                }
                                            }
                                        };
                                        if (Array.isArray(disposables)) {
                                            disposables.push(result);
                                        }
                                        return result;
                                    };
                                }
                                return this._event;
                            }
                        },
                        {
                            /**
     * To be kept private to fire an event to
     * subscribers
     */ key: "fire",
                            value: function fire(event) {
                                if (this._callbacks) {
                                    this._callbacks.invoke.call(this._callbacks, event);
                                }
                            }
                        },
                        {
                            key: "dispose",
                            value: function dispose() {
                                if (this._callbacks) {
                                    this._callbacks.dispose();
                                    this._callbacks = undefined;
                                }
                            }
                        }
                    ]);
                    return Emitter;
                }();
                exports1.Emitter = Emitter;
                Emitter._noop = function() {};
            //# sourceMappingURL=events.js.map
            /***/ },
            /***/ 8811: /***/ function(__unused_webpack_module, exports1) {
                "use strict";
                var boolean = function boolean(value) {
                    return value === true || value === false;
                };
                var string = function string(value) {
                    return typeof value === "string" || _instanceof(value, String);
                };
                var number = function number(value) {
                    return typeof value === "number" || _instanceof(value, Number);
                };
                var error = function error(value) {
                    return _instanceof(value, Error);
                };
                var func = function func(value) {
                    return typeof value === "function";
                };
                var array = function array(value) {
                    return Array.isArray(value);
                };
                var stringArray = function stringArray(value) {
                    return array(value) && value.every(function(elem) {
                        return string(elem);
                    });
                };
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.stringArray = exports1.array = exports1.func = exports1.error = exports1.number = exports1.string = exports1.boolean = void 0;
                exports1.boolean = boolean;
                exports1.string = string;
                exports1.number = number;
                exports1.error = error;
                exports1.func = func;
                exports1.array = array;
                exports1.stringArray = stringArray;
            //# sourceMappingURL=is.js.map
            /***/ },
            /***/ 7040: /***/ function(__unused_webpack_module, exports1) {
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ var _a;
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LRUCache = exports1.LinkedMap = exports1.Touch = void 0;
                var Touch;
                (function(Touch) {
                    Touch.None = 0;
                    Touch.First = 1;
                    Touch.AsOld = Touch.First;
                    Touch.Last = 2;
                    Touch.AsNew = Touch.Last;
                })(Touch = exports1.Touch || (exports1.Touch = {}));
                var LinkedMap = /*#__PURE__*/ function() {
                    function LinkedMap() {
                        _class_call_check(this, LinkedMap);
                        this[_a] = "LinkedMap";
                        this._map = new Map();
                        this._head = undefined;
                        this._tail = undefined;
                        this._size = 0;
                        this._state = 0;
                    }
                    _create_class(LinkedMap, [
                        {
                            key: "clear",
                            value: function clear() {
                                this._map.clear();
                                this._head = undefined;
                                this._tail = undefined;
                                this._size = 0;
                                this._state++;
                            }
                        },
                        {
                            key: "isEmpty",
                            value: function isEmpty() {
                                return !this._head && !this._tail;
                            }
                        },
                        {
                            key: "size",
                            get: function get() {
                                return this._size;
                            }
                        },
                        {
                            key: "first",
                            get: function get() {
                                var _this__head;
                                return (_this__head = this._head) === null || _this__head === void 0 ? void 0 : _this__head.value;
                            }
                        },
                        {
                            key: "last",
                            get: function get() {
                                var _this__tail;
                                return (_this__tail = this._tail) === null || _this__tail === void 0 ? void 0 : _this__tail.value;
                            }
                        },
                        {
                            key: "has",
                            value: function has(key) {
                                return this._map.has(key);
                            }
                        },
                        {
                            key: "get",
                            value: function get(key) {
                                var touch = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Touch.None;
                                var item = this._map.get(key);
                                if (!item) {
                                    return undefined;
                                }
                                if (touch !== Touch.None) {
                                    this.touch(item, touch);
                                }
                                return item.value;
                            }
                        },
                        {
                            key: "set",
                            value: function set(key, value) {
                                var touch = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Touch.None;
                                var item = this._map.get(key);
                                if (item) {
                                    item.value = value;
                                    if (touch !== Touch.None) {
                                        this.touch(item, touch);
                                    }
                                } else {
                                    item = {
                                        key: key,
                                        value: value,
                                        next: undefined,
                                        previous: undefined
                                    };
                                    switch(touch){
                                        case Touch.None:
                                            this.addItemLast(item);
                                            break;
                                        case Touch.First:
                                            this.addItemFirst(item);
                                            break;
                                        case Touch.Last:
                                            this.addItemLast(item);
                                            break;
                                        default:
                                            this.addItemLast(item);
                                            break;
                                    }
                                    this._map.set(key, item);
                                    this._size++;
                                }
                                return this;
                            }
                        },
                        {
                            key: "delete",
                            value: function _delete(key) {
                                return !!this.remove(key);
                            }
                        },
                        {
                            key: "remove",
                            value: function remove(key) {
                                var item = this._map.get(key);
                                if (!item) {
                                    return undefined;
                                }
                                this._map.delete(key);
                                this.removeItem(item);
                                this._size--;
                                return item.value;
                            }
                        },
                        {
                            key: "shift",
                            value: function shift() {
                                if (!this._head && !this._tail) {
                                    return undefined;
                                }
                                if (!this._head || !this._tail) {
                                    throw new Error("Invalid list");
                                }
                                var item = this._head;
                                this._map.delete(item.key);
                                this.removeItem(item);
                                this._size--;
                                return item.value;
                            }
                        },
                        {
                            key: "forEach",
                            value: function forEach(callbackfn, thisArg) {
                                var state = this._state;
                                var current = this._head;
                                while(current){
                                    if (thisArg) {
                                        callbackfn.bind(thisArg)(current.value, current.key, this);
                                    } else {
                                        callbackfn(current.value, current.key, this);
                                    }
                                    if (this._state !== state) {
                                        throw new Error("LinkedMap got modified during iteration.");
                                    }
                                    current = current.next;
                                }
                            }
                        },
                        {
                            key: "keys",
                            value: function keys() {
                                var _this = this;
                                var state = this._state;
                                var current = this._head;
                                var _obj;
                                var iterator = (_obj = {}, _define_property(_obj, Symbol.iterator, function() {
                                    return iterator;
                                }), _define_property(_obj, "next", function() {
                                    if (_this._state !== state) {
                                        throw new Error("LinkedMap got modified during iteration.");
                                    }
                                    if (current) {
                                        var result = {
                                            value: current.key,
                                            done: false
                                        };
                                        current = current.next;
                                        return result;
                                    } else {
                                        return {
                                            value: undefined,
                                            done: true
                                        };
                                    }
                                }), _obj);
                                return iterator;
                            }
                        },
                        {
                            key: "values",
                            value: function values() {
                                var _this = this;
                                var state = this._state;
                                var current = this._head;
                                var _obj;
                                var iterator = (_obj = {}, _define_property(_obj, Symbol.iterator, function() {
                                    return iterator;
                                }), _define_property(_obj, "next", function() {
                                    if (_this._state !== state) {
                                        throw new Error("LinkedMap got modified during iteration.");
                                    }
                                    if (current) {
                                        var result = {
                                            value: current.value,
                                            done: false
                                        };
                                        current = current.next;
                                        return result;
                                    } else {
                                        return {
                                            value: undefined,
                                            done: true
                                        };
                                    }
                                }), _obj);
                                return iterator;
                            }
                        },
                        {
                            key: "entries",
                            value: function entries() {
                                var _this = this;
                                var state = this._state;
                                var current = this._head;
                                var _obj;
                                var iterator = (_obj = {}, _define_property(_obj, Symbol.iterator, function() {
                                    return iterator;
                                }), _define_property(_obj, "next", function() {
                                    if (_this._state !== state) {
                                        throw new Error("LinkedMap got modified during iteration.");
                                    }
                                    if (current) {
                                        var result = {
                                            value: [
                                                current.key,
                                                current.value
                                            ],
                                            done: false
                                        };
                                        current = current.next;
                                        return result;
                                    } else {
                                        return {
                                            value: undefined,
                                            done: true
                                        };
                                    }
                                }), _obj);
                                return iterator;
                            }
                        },
                        {
                            key: (_a = Symbol.toStringTag, Symbol.iterator),
                            value: function value() {
                                return this.entries();
                            }
                        },
                        {
                            key: "trimOld",
                            value: function trimOld(newSize) {
                                if (newSize >= this.size) {
                                    return;
                                }
                                if (newSize === 0) {
                                    this.clear();
                                    return;
                                }
                                var current = this._head;
                                var currentSize = this.size;
                                while(current && currentSize > newSize){
                                    this._map.delete(current.key);
                                    current = current.next;
                                    currentSize--;
                                }
                                this._head = current;
                                this._size = currentSize;
                                if (current) {
                                    current.previous = undefined;
                                }
                                this._state++;
                            }
                        },
                        {
                            key: "addItemFirst",
                            value: function addItemFirst(item) {
                                // First time Insert
                                if (!this._head && !this._tail) {
                                    this._tail = item;
                                } else if (!this._head) {
                                    throw new Error("Invalid list");
                                } else {
                                    item.next = this._head;
                                    this._head.previous = item;
                                }
                                this._head = item;
                                this._state++;
                            }
                        },
                        {
                            key: "addItemLast",
                            value: function addItemLast(item) {
                                // First time Insert
                                if (!this._head && !this._tail) {
                                    this._head = item;
                                } else if (!this._tail) {
                                    throw new Error("Invalid list");
                                } else {
                                    item.previous = this._tail;
                                    this._tail.next = item;
                                }
                                this._tail = item;
                                this._state++;
                            }
                        },
                        {
                            key: "removeItem",
                            value: function removeItem(item) {
                                if (item === this._head && item === this._tail) {
                                    this._head = undefined;
                                    this._tail = undefined;
                                } else if (item === this._head) {
                                    // This can only happened if size === 1 which is handle
                                    // by the case above.
                                    if (!item.next) {
                                        throw new Error("Invalid list");
                                    }
                                    item.next.previous = undefined;
                                    this._head = item.next;
                                } else if (item === this._tail) {
                                    // This can only happened if size === 1 which is handle
                                    // by the case above.
                                    if (!item.previous) {
                                        throw new Error("Invalid list");
                                    }
                                    item.previous.next = undefined;
                                    this._tail = item.previous;
                                } else {
                                    var next = item.next;
                                    var previous = item.previous;
                                    if (!next || !previous) {
                                        throw new Error("Invalid list");
                                    }
                                    next.previous = previous;
                                    previous.next = next;
                                }
                                item.next = undefined;
                                item.previous = undefined;
                                this._state++;
                            }
                        },
                        {
                            key: "touch",
                            value: function touch(item, touch) {
                                if (!this._head || !this._tail) {
                                    throw new Error("Invalid list");
                                }
                                if (touch !== Touch.First && touch !== Touch.Last) {
                                    return;
                                }
                                if (touch === Touch.First) {
                                    if (item === this._head) {
                                        return;
                                    }
                                    var next = item.next;
                                    var previous = item.previous;
                                    // Unlink the item
                                    if (item === this._tail) {
                                        // previous must be defined since item was not head but is tail
                                        // So there are more than on item in the map
                                        previous.next = undefined;
                                        this._tail = previous;
                                    } else {
                                        // Both next and previous are not undefined since item was neither head nor tail.
                                        next.previous = previous;
                                        previous.next = next;
                                    }
                                    // Insert the node at head
                                    item.previous = undefined;
                                    item.next = this._head;
                                    this._head.previous = item;
                                    this._head = item;
                                    this._state++;
                                } else if (touch === Touch.Last) {
                                    if (item === this._tail) {
                                        return;
                                    }
                                    var next1 = item.next;
                                    var previous1 = item.previous;
                                    // Unlink the item.
                                    if (item === this._head) {
                                        // next must be defined since item was not tail but is head
                                        // So there are more than on item in the map
                                        next1.previous = undefined;
                                        this._head = next1;
                                    } else {
                                        // Both next and previous are not undefined since item was neither head nor tail.
                                        next1.previous = previous1;
                                        previous1.next = next1;
                                    }
                                    item.next = undefined;
                                    item.previous = this._tail;
                                    this._tail.next = item;
                                    this._tail = item;
                                    this._state++;
                                }
                            }
                        },
                        {
                            key: "toJSON",
                            value: function toJSON() {
                                var data = [];
                                this.forEach(function(value, key) {
                                    data.push([
                                        key,
                                        value
                                    ]);
                                });
                                return data;
                            }
                        },
                        {
                            key: "fromJSON",
                            value: function fromJSON(data) {
                                this.clear();
                                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                try {
                                    for(var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                        var _step_value = _sliced_to_array(_step.value, 2), key = _step_value[0], value = _step_value[1];
                                        this.set(key, value);
                                    }
                                } catch (err) {
                                    _didIteratorError = true;
                                    _iteratorError = err;
                                } finally{
                                    try {
                                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                                            _iterator.return();
                                        }
                                    } finally{
                                        if (_didIteratorError) {
                                            throw _iteratorError;
                                        }
                                    }
                                }
                            }
                        }
                    ]);
                    return LinkedMap;
                }();
                exports1.LinkedMap = LinkedMap;
                var LRUCache = /*#__PURE__*/ function(LinkedMap) {
                    _inherits(LRUCache, LinkedMap);
                    var _super = _create_super(LRUCache);
                    function LRUCache(limit) {
                        var ratio = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
                        _class_call_check(this, LRUCache);
                        var _this;
                        _this = _super.call(this);
                        _this._limit = limit;
                        _this._ratio = Math.min(Math.max(0, ratio), 1);
                        return _this;
                    }
                    _create_class(LRUCache, [
                        {
                            key: "limit",
                            get: function get() {
                                return this._limit;
                            },
                            set: function set(limit) {
                                this._limit = limit;
                                this.checkTrim();
                            }
                        },
                        {
                            key: "ratio",
                            get: function get() {
                                return this._ratio;
                            },
                            set: function set(ratio) {
                                this._ratio = Math.min(Math.max(0, ratio), 1);
                                this.checkTrim();
                            }
                        },
                        {
                            key: "get",
                            value: function get(key) {
                                var touch = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Touch.AsNew;
                                return _get(_get_prototype_of(LRUCache.prototype), "get", this).call(this, key, touch);
                            }
                        },
                        {
                            key: "peek",
                            value: function peek(key) {
                                return _get(_get_prototype_of(LRUCache.prototype), "get", this).call(this, key, Touch.None);
                            }
                        },
                        {
                            key: "set",
                            value: function set(key, value) {
                                _get(_get_prototype_of(LRUCache.prototype), "set", this).call(this, key, value, Touch.Last);
                                this.checkTrim();
                                return this;
                            }
                        },
                        {
                            key: "checkTrim",
                            value: function checkTrim() {
                                if (this.size > this._limit) {
                                    this.trimOld(Math.round(this._limit * this._ratio));
                                }
                            }
                        }
                    ]);
                    return LRUCache;
                }(LinkedMap);
                exports1.LRUCache = LRUCache;
            //# sourceMappingURL=linkedMap.js.map
            /***/ },
            /***/ 8652: /***/ function(__unused_webpack_module, exports1) {
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.AbstractMessageBuffer = void 0;
                var CR = 13;
                var LF = 10;
                var CRLF = "\r\n";
                var AbstractMessageBuffer = /*#__PURE__*/ function() {
                    function AbstractMessageBuffer() {
                        var encoding = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "utf-8";
                        _class_call_check(this, AbstractMessageBuffer);
                        this._encoding = encoding;
                        this._chunks = [];
                        this._totalLength = 0;
                    }
                    _create_class(AbstractMessageBuffer, [
                        {
                            key: "encoding",
                            get: function get() {
                                return this._encoding;
                            }
                        },
                        {
                            key: "append",
                            value: function append(chunk) {
                                var toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
                                this._chunks.push(toAppend);
                                this._totalLength += toAppend.byteLength;
                            }
                        },
                        {
                            key: "tryReadHeaders",
                            value: function tryReadHeaders() {
                                if (this._chunks.length === 0) {
                                    return undefined;
                                }
                                var state = 0;
                                var chunkIndex = 0;
                                var offset = 0;
                                var chunkBytesRead = 0;
                                row: while(chunkIndex < this._chunks.length){
                                    var chunk = this._chunks[chunkIndex];
                                    offset = 0;
                                    column: while(offset < chunk.length){
                                        var value = chunk[offset];
                                        switch(value){
                                            case CR:
                                                switch(state){
                                                    case 0:
                                                        state = 1;
                                                        break;
                                                    case 2:
                                                        state = 3;
                                                        break;
                                                    default:
                                                        state = 0;
                                                }
                                                break;
                                            case LF:
                                                switch(state){
                                                    case 1:
                                                        state = 2;
                                                        break;
                                                    case 3:
                                                        state = 4;
                                                        offset++;
                                                        break row;
                                                    default:
                                                        state = 0;
                                                }
                                                break;
                                            default:
                                                state = 0;
                                        }
                                        offset++;
                                    }
                                    chunkBytesRead += chunk.byteLength;
                                    chunkIndex++;
                                }
                                if (state !== 4) {
                                    return undefined;
                                }
                                // The buffer contains the two CRLF at the end. So we will
                                // have two empty lines after the split at the end as well.
                                var buffer = this._read(chunkBytesRead + offset);
                                var result = new Map();
                                var headers = this.toString(buffer, "ascii").split(CRLF);
                                if (headers.length < 2) {
                                    return result;
                                }
                                for(var i = 0; i < headers.length - 2; i++){
                                    var header = headers[i];
                                    var index = header.indexOf(":");
                                    if (index === -1) {
                                        throw new Error("Message header must separate key and value using :");
                                    }
                                    var key = header.substr(0, index);
                                    var value1 = header.substr(index + 1).trim();
                                    result.set(key, value1);
                                }
                                return result;
                            }
                        },
                        {
                            key: "tryReadBody",
                            value: function tryReadBody(length) {
                                if (this._totalLength < length) {
                                    return undefined;
                                }
                                return this._read(length);
                            }
                        },
                        {
                            key: "numberOfBytes",
                            get: function get() {
                                return this._totalLength;
                            }
                        },
                        {
                            key: "_read",
                            value: function _read(byteCount) {
                                if (byteCount === 0) {
                                    return this.emptyBuffer();
                                }
                                if (byteCount > this._totalLength) {
                                    throw new Error("Cannot read so many bytes!");
                                }
                                if (this._chunks[0].byteLength === byteCount) {
                                    // super fast path, precisely first chunk must be returned
                                    var chunk = this._chunks[0];
                                    this._chunks.shift();
                                    this._totalLength -= byteCount;
                                    return this.asNative(chunk);
                                }
                                if (this._chunks[0].byteLength > byteCount) {
                                    // fast path, the reading is entirely within the first chunk
                                    var chunk1 = this._chunks[0];
                                    var result = this.asNative(chunk1, byteCount);
                                    this._chunks[0] = chunk1.slice(byteCount);
                                    this._totalLength -= byteCount;
                                    return result;
                                }
                                var result1 = this.allocNative(byteCount);
                                var resultOffset = 0;
                                var chunkIndex = 0;
                                while(byteCount > 0){
                                    var chunk2 = this._chunks[chunkIndex];
                                    if (chunk2.byteLength > byteCount) {
                                        // this chunk will survive
                                        var chunkPart = chunk2.slice(0, byteCount);
                                        result1.set(chunkPart, resultOffset);
                                        resultOffset += byteCount;
                                        this._chunks[chunkIndex] = chunk2.slice(byteCount);
                                        this._totalLength -= byteCount;
                                        byteCount -= byteCount;
                                    } else {
                                        // this chunk will be entirely read
                                        result1.set(chunk2, resultOffset);
                                        resultOffset += chunk2.byteLength;
                                        this._chunks.shift();
                                        this._totalLength -= chunk2.byteLength;
                                        byteCount -= chunk2.byteLength;
                                    }
                                }
                                return result1;
                            }
                        }
                    ]);
                    return AbstractMessageBuffer;
                }();
                exports1.AbstractMessageBuffer = AbstractMessageBuffer;
            //# sourceMappingURL=messageBuffer.js.map
            /***/ },
            /***/ 451: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1911612__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ReadableStreamMessageReader = exports1.AbstractMessageReader = exports1.MessageReader = void 0;
                var ral_1 = __nested_webpack_require_1911612__(5706);
                var Is = __nested_webpack_require_1911612__(8811);
                var events_1 = __nested_webpack_require_1911612__(5165);
                var MessageReader;
                (function(MessageReader) {
                    var is = function is(value) {
                        var candidate = value;
                        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
                    };
                    MessageReader.is = is;
                })(MessageReader = exports1.MessageReader || (exports1.MessageReader = {}));
                var AbstractMessageReader = /*#__PURE__*/ function() {
                    function AbstractMessageReader() {
                        _class_call_check(this, AbstractMessageReader);
                        this.errorEmitter = new events_1.Emitter();
                        this.closeEmitter = new events_1.Emitter();
                        this.partialMessageEmitter = new events_1.Emitter();
                    }
                    _create_class(AbstractMessageReader, [
                        {
                            key: "dispose",
                            value: function dispose() {
                                this.errorEmitter.dispose();
                                this.closeEmitter.dispose();
                            }
                        },
                        {
                            key: "onError",
                            get: function get() {
                                return this.errorEmitter.event;
                            }
                        },
                        {
                            key: "fireError",
                            value: function fireError(error) {
                                this.errorEmitter.fire(this.asError(error));
                            }
                        },
                        {
                            key: "onClose",
                            get: function get() {
                                return this.closeEmitter.event;
                            }
                        },
                        {
                            key: "fireClose",
                            value: function fireClose() {
                                this.closeEmitter.fire(undefined);
                            }
                        },
                        {
                            key: "onPartialMessage",
                            get: function get() {
                                return this.partialMessageEmitter.event;
                            }
                        },
                        {
                            key: "firePartialMessage",
                            value: function firePartialMessage(info) {
                                this.partialMessageEmitter.fire(info);
                            }
                        },
                        {
                            key: "asError",
                            value: function asError(error) {
                                if (_instanceof(error, Error)) {
                                    return error;
                                } else {
                                    return new Error("Reader received error. Reason: ".concat(Is.string(error.message) ? error.message : "unknown"));
                                }
                            }
                        }
                    ]);
                    return AbstractMessageReader;
                }();
                exports1.AbstractMessageReader = AbstractMessageReader;
                var ResolvedMessageReaderOptions;
                (function(ResolvedMessageReaderOptions) {
                    var fromOptions = function fromOptions(options) {
                        var charset;
                        var result;
                        var contentDecoder;
                        var contentDecoders = new Map();
                        var contentTypeDecoder;
                        var contentTypeDecoders = new Map();
                        if (options === undefined || typeof options === "string") {
                            charset = options !== null && options !== void 0 ? options : "utf-8";
                        } else {
                            var _options_charset;
                            charset = (_options_charset = options.charset) !== null && _options_charset !== void 0 ? _options_charset : "utf-8";
                            if (options.contentDecoder !== undefined) {
                                contentDecoder = options.contentDecoder;
                                contentDecoders.set(contentDecoder.name, contentDecoder);
                            }
                            if (options.contentDecoders !== undefined) {
                                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                try {
                                    for(var _iterator = options.contentDecoders[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                        var decoder = _step.value;
                                        contentDecoders.set(decoder.name, decoder);
                                    }
                                } catch (err) {
                                    _didIteratorError = true;
                                    _iteratorError = err;
                                } finally{
                                    try {
                                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                                            _iterator.return();
                                        }
                                    } finally{
                                        if (_didIteratorError) {
                                            throw _iteratorError;
                                        }
                                    }
                                }
                            }
                            if (options.contentTypeDecoder !== undefined) {
                                contentTypeDecoder = options.contentTypeDecoder;
                                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
                            }
                            if (options.contentTypeDecoders !== undefined) {
                                var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                                try {
                                    for(var _iterator1 = options.contentTypeDecoders[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                        var decoder1 = _step1.value;
                                        contentTypeDecoders.set(decoder1.name, decoder1);
                                    }
                                } catch (err) {
                                    _didIteratorError1 = true;
                                    _iteratorError1 = err;
                                } finally{
                                    try {
                                        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                            _iterator1.return();
                                        }
                                    } finally{
                                        if (_didIteratorError1) {
                                            throw _iteratorError1;
                                        }
                                    }
                                }
                            }
                        }
                        if (contentTypeDecoder === undefined) {
                            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
                            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
                        }
                        return {
                            charset: charset,
                            contentDecoder: contentDecoder,
                            contentDecoders: contentDecoders,
                            contentTypeDecoder: contentTypeDecoder,
                            contentTypeDecoders: contentTypeDecoders
                        };
                    };
                    ResolvedMessageReaderOptions.fromOptions = fromOptions;
                })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
                var ReadableStreamMessageReader = /*#__PURE__*/ function(AbstractMessageReader) {
                    _inherits(ReadableStreamMessageReader, AbstractMessageReader);
                    var _super = _create_super(ReadableStreamMessageReader);
                    function ReadableStreamMessageReader(readable, options) {
                        _class_call_check(this, ReadableStreamMessageReader);
                        var _this;
                        _this = _super.call(this);
                        _this.readable = readable;
                        _this.options = ResolvedMessageReaderOptions.fromOptions(options);
                        _this.buffer = (0, ral_1.default)().messageBuffer.create(_this.options.charset);
                        _this._partialMessageTimeout = 10000;
                        _this.nextMessageLength = -1;
                        _this.messageToken = 0;
                        return _this;
                    }
                    _create_class(ReadableStreamMessageReader, [
                        {
                            key: "partialMessageTimeout",
                            get: function get() {
                                return this._partialMessageTimeout;
                            },
                            set: function set(timeout) {
                                this._partialMessageTimeout = timeout;
                            }
                        },
                        {
                            key: "listen",
                            value: function listen(callback) {
                                var _this = this;
                                this.nextMessageLength = -1;
                                this.messageToken = 0;
                                this.partialMessageTimer = undefined;
                                this.callback = callback;
                                var result = this.readable.onData(function(data) {
                                    _this.onData(data);
                                });
                                this.readable.onError(function(error) {
                                    return _this.fireError(error);
                                });
                                this.readable.onClose(function() {
                                    return _this.fireClose();
                                });
                                return result;
                            }
                        },
                        {
                            key: "onData",
                            value: function onData(data) {
                                var _this = this;
                                this.buffer.append(data);
                                while(true){
                                    if (this.nextMessageLength === -1) {
                                        var headers = this.buffer.tryReadHeaders();
                                        if (!headers) {
                                            return;
                                        }
                                        var contentLength = headers.get("Content-Length");
                                        if (!contentLength) {
                                            throw new Error("Header must provide a Content-Length property.");
                                        }
                                        var length = parseInt(contentLength);
                                        if (isNaN(length)) {
                                            throw new Error("Content-Length value must be a number.");
                                        }
                                        this.nextMessageLength = length;
                                    }
                                    var body = this.buffer.tryReadBody(this.nextMessageLength);
                                    if (body === undefined) {
                                        /** We haven't received the full message yet. */ this.setPartialMessageTimer();
                                        return;
                                    }
                                    this.clearPartialMessageTimer();
                                    this.nextMessageLength = -1;
                                    var p = void 0;
                                    if (this.options.contentDecoder !== undefined) {
                                        p = this.options.contentDecoder.decode(body);
                                    } else {
                                        p = Promise.resolve(body);
                                    }
                                    p.then(function(value) {
                                        _this.options.contentTypeDecoder.decode(value, _this.options).then(function(msg) {
                                            _this.callback(msg);
                                        }, function(error) {
                                            _this.fireError(error);
                                        });
                                    }, function(error) {
                                        _this.fireError(error);
                                    });
                                }
                            }
                        },
                        {
                            key: "clearPartialMessageTimer",
                            value: function clearPartialMessageTimer() {
                                if (this.partialMessageTimer) {
                                    this.partialMessageTimer.dispose();
                                    this.partialMessageTimer = undefined;
                                }
                            }
                        },
                        {
                            key: "setPartialMessageTimer",
                            value: function setPartialMessageTimer() {
                                var _this = this;
                                this.clearPartialMessageTimer();
                                if (this._partialMessageTimeout <= 0) {
                                    return;
                                }
                                this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout(function(token, timeout) {
                                    _this.partialMessageTimer = undefined;
                                    if (token === _this.messageToken) {
                                        _this.firePartialMessage({
                                            messageToken: token,
                                            waitingTime: timeout
                                        });
                                        _this.setPartialMessageTimer();
                                    }
                                }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
                            }
                        }
                    ]);
                    return ReadableStreamMessageReader;
                }(AbstractMessageReader);
                exports1.ReadableStreamMessageReader = ReadableStreamMessageReader;
            //# sourceMappingURL=messageReader.js.map
            /***/ },
            /***/ 1251: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1928494__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WriteableStreamMessageWriter = exports1.AbstractMessageWriter = exports1.MessageWriter = void 0;
                var ral_1 = __nested_webpack_require_1928494__(5706);
                var Is = __nested_webpack_require_1928494__(8811);
                var semaphore_1 = __nested_webpack_require_1928494__(2339);
                var events_1 = __nested_webpack_require_1928494__(5165);
                var ContentLength = "Content-Length: ";
                var CRLF = "\r\n";
                var MessageWriter;
                (function(MessageWriter) {
                    var is = function is(value) {
                        var candidate = value;
                        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
                    };
                    MessageWriter.is = is;
                })(MessageWriter = exports1.MessageWriter || (exports1.MessageWriter = {}));
                var AbstractMessageWriter = /*#__PURE__*/ function() {
                    function AbstractMessageWriter() {
                        _class_call_check(this, AbstractMessageWriter);
                        this.errorEmitter = new events_1.Emitter();
                        this.closeEmitter = new events_1.Emitter();
                    }
                    _create_class(AbstractMessageWriter, [
                        {
                            key: "dispose",
                            value: function dispose() {
                                this.errorEmitter.dispose();
                                this.closeEmitter.dispose();
                            }
                        },
                        {
                            key: "onError",
                            get: function get() {
                                return this.errorEmitter.event;
                            }
                        },
                        {
                            key: "fireError",
                            value: function fireError(error, message, count) {
                                this.errorEmitter.fire([
                                    this.asError(error),
                                    message,
                                    count
                                ]);
                            }
                        },
                        {
                            key: "onClose",
                            get: function get() {
                                return this.closeEmitter.event;
                            }
                        },
                        {
                            key: "fireClose",
                            value: function fireClose() {
                                this.closeEmitter.fire(undefined);
                            }
                        },
                        {
                            key: "asError",
                            value: function asError(error) {
                                if (_instanceof(error, Error)) {
                                    return error;
                                } else {
                                    return new Error("Writer received error. Reason: ".concat(Is.string(error.message) ? error.message : "unknown"));
                                }
                            }
                        }
                    ]);
                    return AbstractMessageWriter;
                }();
                exports1.AbstractMessageWriter = AbstractMessageWriter;
                var ResolvedMessageWriterOptions;
                (function(ResolvedMessageWriterOptions) {
                    var fromOptions = function fromOptions(options) {
                        if (options === undefined || typeof options === "string") {
                            return {
                                charset: options !== null && options !== void 0 ? options : "utf-8",
                                contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder
                            };
                        } else {
                            var _options_charset, _options_contentTypeEncoder;
                            return {
                                charset: (_options_charset = options.charset) !== null && _options_charset !== void 0 ? _options_charset : "utf-8",
                                contentEncoder: options.contentEncoder,
                                contentTypeEncoder: (_options_contentTypeEncoder = options.contentTypeEncoder) !== null && _options_contentTypeEncoder !== void 0 ? _options_contentTypeEncoder : (0, ral_1.default)().applicationJson.encoder
                            };
                        }
                    };
                    ResolvedMessageWriterOptions.fromOptions = fromOptions;
                })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
                var WriteableStreamMessageWriter = /*#__PURE__*/ function(AbstractMessageWriter) {
                    _inherits(WriteableStreamMessageWriter, AbstractMessageWriter);
                    var _super = _create_super(WriteableStreamMessageWriter);
                    function WriteableStreamMessageWriter(writable, options) {
                        _class_call_check(this, WriteableStreamMessageWriter);
                        var _this;
                        _this = _super.call(this);
                        _this.writable = writable;
                        _this.options = ResolvedMessageWriterOptions.fromOptions(options);
                        _this.errorCount = 0;
                        _this.writeSemaphore = new semaphore_1.Semaphore(1);
                        _this.writable.onError(function(error) {
                            return _this.fireError(error);
                        });
                        _this.writable.onClose(function() {
                            return _this.fireClose();
                        });
                        return _this;
                    }
                    _create_class(WriteableStreamMessageWriter, [
                        {
                            key: "write",
                            value: function write(msg) {
                                var _this = this;
                                return _async_to_generator(function() {
                                    return _ts_generator(this, function(_state) {
                                        return [
                                            2,
                                            _this.writeSemaphore.lock(/*#__PURE__*/ _async_to_generator(function() {
                                                var payload;
                                                return _ts_generator(this, function(_state) {
                                                    payload = _this.options.contentTypeEncoder.encode(msg, _this.options).then(function(buffer) {
                                                        if (_this.options.contentEncoder !== undefined) {
                                                            return _this.options.contentEncoder.encode(buffer);
                                                        } else {
                                                            return buffer;
                                                        }
                                                    });
                                                    return [
                                                        2,
                                                        payload.then(function(buffer) {
                                                            var headers = [];
                                                            headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
                                                            headers.push(CRLF);
                                                            return _this.doWrite(msg, headers, buffer);
                                                        }, function(error) {
                                                            _this.fireError(error);
                                                            throw error;
                                                        })
                                                    ];
                                                });
                                            }))
                                        ];
                                    });
                                })();
                            }
                        },
                        {
                            key: "doWrite",
                            value: function doWrite(msg, headers, data) {
                                var _this = this;
                                return _async_to_generator(function() {
                                    var error;
                                    return _ts_generator(this, function(_state) {
                                        switch(_state.label){
                                            case 0:
                                                _state.trys.push([
                                                    0,
                                                    2,
                                                    ,
                                                    3
                                                ]);
                                                return [
                                                    4,
                                                    _this.writable.write(headers.join(""), "ascii")
                                                ];
                                            case 1:
                                                _state.sent();
                                                return [
                                                    2,
                                                    _this.writable.write(data)
                                                ];
                                            case 2:
                                                error = _state.sent();
                                                _this.handleError(error, msg);
                                                return [
                                                    2,
                                                    Promise.reject(error)
                                                ];
                                            case 3:
                                                return [
                                                    2
                                                ];
                                        }
                                    });
                                })();
                            }
                        },
                        {
                            key: "handleError",
                            value: function handleError(error, msg) {
                                this.errorCount++;
                                this.fireError(error, msg, this.errorCount);
                            }
                        },
                        {
                            key: "end",
                            value: function end() {
                                this.writable.end();
                            }
                        }
                    ]);
                    return WriteableStreamMessageWriter;
                }(AbstractMessageWriter);
                exports1.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
            //# sourceMappingURL=messageWriter.js.map
            /***/ },
            /***/ 9141: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1940858__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Message = exports1.NotificationType9 = exports1.NotificationType8 = exports1.NotificationType7 = exports1.NotificationType6 = exports1.NotificationType5 = exports1.NotificationType4 = exports1.NotificationType3 = exports1.NotificationType2 = exports1.NotificationType1 = exports1.NotificationType0 = exports1.NotificationType = exports1.RequestType9 = exports1.RequestType8 = exports1.RequestType7 = exports1.RequestType6 = exports1.RequestType5 = exports1.RequestType4 = exports1.RequestType3 = exports1.RequestType2 = exports1.RequestType1 = exports1.RequestType = exports1.RequestType0 = exports1.AbstractMessageSignature = exports1.ParameterStructures = exports1.ResponseError = exports1.ErrorCodes = void 0;
                var is = __nested_webpack_require_1940858__(8811);
                /**
 * Predefined error codes.
 */ var ErrorCodes;
                (function(ErrorCodes) {
                    // Defined by JSON RPC
                    ErrorCodes.ParseError = -32700;
                    ErrorCodes.InvalidRequest = -32600;
                    ErrorCodes.MethodNotFound = -32601;
                    ErrorCodes.InvalidParams = -32602;
                    ErrorCodes.InternalError = -32603;
                    /**
     * This is the start range of JSON RPC reserved error codes.
     * It doesn't denote a real error code. No application error codes should
     * be defined between the start and end range. For backwards
     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
     * are left in the range.
     *
     * @since 3.16.0
    */ ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;
                    /** @deprecated use  jsonrpcReservedErrorRangeStart */ ErrorCodes.serverErrorStart = -32099;
                    /**
     * An error occurred when write a message to the transport layer.
     */ ErrorCodes.MessageWriteError = -32099;
                    /**
     * An error occurred when reading a message from the transport layer.
     */ ErrorCodes.MessageReadError = -32098;
                    /**
     * The connection got disposed or lost and all pending responses got
     * rejected.
     */ ErrorCodes.PendingResponseRejected = -32097;
                    /**
     * The connection is inactive and a use of it failed.
     */ ErrorCodes.ConnectionInactive = -32096;
                    /**
     * Error code indicating that a server received a notification or
     * request before the server has received the `initialize` request.
     */ ErrorCodes.ServerNotInitialized = -32002;
                    ErrorCodes.UnknownErrorCode = -32001;
                    /**
     * This is the end range of JSON RPC reserved error codes.
     * It doesn't denote a real error code.
     *
     * @since 3.16.0
    */ ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;
                    /** @deprecated use  jsonrpcReservedErrorRangeEnd */ ErrorCodes.serverErrorEnd = -32000;
                })(ErrorCodes = exports1.ErrorCodes || (exports1.ErrorCodes = {}));
                /**
 * An error object return in a response in case a request
 * has failed.
 */ var ResponseError = /*#__PURE__*/ function(Error1) {
                    _inherits(ResponseError, Error1);
                    var _super = _create_super(ResponseError);
                    function ResponseError(code, message, data) {
                        _class_call_check(this, ResponseError);
                        var _this;
                        _this = _super.call(this, message);
                        _this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
                        _this.data = data;
                        Object.setPrototypeOf(_assert_this_initialized(_this), ResponseError.prototype);
                        return _this;
                    }
                    _create_class(ResponseError, [
                        {
                            key: "toJson",
                            value: function toJson() {
                                var result = {
                                    code: this.code,
                                    message: this.message
                                };
                                if (this.data !== undefined) {
                                    result.data = this.data;
                                }
                                return result;
                            }
                        }
                    ]);
                    return ResponseError;
                }(_wrap_native_super(Error));
                exports1.ResponseError = ResponseError;
                var ParameterStructures = /*#__PURE__*/ function() {
                    function ParameterStructures(kind) {
                        _class_call_check(this, ParameterStructures);
                        this.kind = kind;
                    }
                    _create_class(ParameterStructures, [
                        {
                            key: "toString",
                            value: function toString() {
                                return this.kind;
                            }
                        }
                    ], [
                        {
                            key: "is",
                            value: function is(value) {
                                return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
                            }
                        }
                    ]);
                    return ParameterStructures;
                }();
                exports1.ParameterStructures = ParameterStructures;
                /**
 * The parameter structure is automatically inferred on the number of parameters
 * and the parameter type in case of a single param.
 */ ParameterStructures.auto = new ParameterStructures("auto");
                /**
 * Forces `byPosition` parameter structure. This is useful if you have a single
 * parameter which has a literal type.
 */ ParameterStructures.byPosition = new ParameterStructures("byPosition");
                /**
 * Forces `byName` parameter structure. This is only useful when having a single
 * parameter. The library will report errors if used with a different number of
 * parameters.
 */ ParameterStructures.byName = new ParameterStructures("byName");
                /**
 * An abstract implementation of a MessageType.
 */ var AbstractMessageSignature = /*#__PURE__*/ function() {
                    function AbstractMessageSignature(method, numberOfParams) {
                        _class_call_check(this, AbstractMessageSignature);
                        this.method = method;
                        this.numberOfParams = numberOfParams;
                    }
                    _create_class(AbstractMessageSignature, [
                        {
                            key: "parameterStructures",
                            get: function get() {
                                return ParameterStructures.auto;
                            }
                        }
                    ]);
                    return AbstractMessageSignature;
                }();
                exports1.AbstractMessageSignature = AbstractMessageSignature;
                /**
 * Classes to type request response pairs
 */ var RequestType0 = /*#__PURE__*/ function(AbstractMessageSignature) {
                    _inherits(RequestType0, AbstractMessageSignature);
                    var _super = _create_super(RequestType0);
                    function RequestType0(method) {
                        _class_call_check(this, RequestType0);
                        return _super.call(this, method, 0);
                    }
                    return RequestType0;
                }(AbstractMessageSignature);
                exports1.RequestType0 = RequestType0;
                var RequestType = /*#__PURE__*/ function(AbstractMessageSignature) {
                    _inherits(RequestType, AbstractMessageSignature);
                    var _super = _create_super(RequestType);
                    function RequestType(method) {
                        var _parameterStructures = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ParameterStructures.auto;
                        _class_call_check(this, RequestType);
                        var _this;
                        _this = _super.call(this, method, 1);
                        _this._parameterStructures = _parameterStructures;
                        return _this;
                    }
                    _create_class(RequestType, [
                        {
                            key: "parameterStructures",
                            get: function get() {
                                return this._parameterStructures;
                            }
                        }
                    ]);
                    return RequestType;
                }(AbstractMessageSignature);
                exports1.RequestType = RequestType;
                var RequestType1 = /*#__PURE__*/ function(AbstractMessageSignature) {
                    _inherits(RequestType1, AbstractMessageSignature);
                    var _super = _create_super(RequestType1);
                    function RequestType1(method) {
                        var _parameterStructures = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ParameterStructures.auto;
                        _class_call_check(this, RequestType1);
                        var _this;
                        _this = _super.call(this, method, 1);
                        _this._parameterStructures = _parameterStructures;
                        return _this;
                    }
                    _create_class(RequestType1, [
                        {
                            key: "parameterStructures",
                            get: function get() {
                                return this._parameterStructures;
                            }
                        }
                    ]);
                    return RequestType1;
                }(AbstractMessageSignature);
                exports1.RequestType1 = RequestType1;
                var RequestType2 = /*#__PURE__*/ function(AbstractMessageSignature) {
                    _inherits(RequestType2, AbstractMessageSignature);
                    var _super = _create_super(RequestType2);
                    function RequestType2(method) {
                        _class_call_check(this, RequestType2);
                        return _super.call(this, method, 2);
                    }
                    return RequestType2;
                }(AbstractMessageSignature);
                exports1.RequestType2 = RequestType2;
                var RequestType3 = /*#__PURE__*/ function(AbstractMessageSignature) {
                    _inherits(RequestType3, AbstractMessageSignature);
                    var _super = _create_super(RequestType3);
                    function RequestType3(method) {
                        _class_call_check(this, RequestType3);
                        return _super.call(this, method, 3);
                    }
                    return RequestType3;
                }(AbstractMessageSignature);
                exports1.RequestType3 = RequestType3;
                var RequestType4 = /*#__PURE__*/ function(AbstractMessageSignature) {
                    _inherits(RequestType4, AbstractMessageSignature);
                    var _super = _create_super(RequestType4);
                    function RequestType4(method) {
                        _class_call_check(this, RequestType4);
                        return _super.call(this, method, 4);
                    }
                    return RequestType4;
                }(AbstractMessageSignature);
                exports1.RequestType4 = RequestType4;
                var RequestType5 = /*#__PURE__*/ function(AbstractMessageSignature) {
                    _inherits(RequestType5, AbstractMessageSignature);
                    var _super = _create_super(RequestType5);
                    function RequestType5(method) {
                        _class_call_check(this, RequestType5);
                        return _super.call(this, method, 5);
                    }
                    return RequestType5;
                }(AbstractMessageSignature);
                exports1.RequestType5 = RequestType5;
                var RequestType6 = /*#__PURE__*/ function(AbstractMessageSignature) {
                    _inherits(RequestType6, AbstractMessageSignature);
                    var _super = _create_super(RequestType6);
                    function RequestType6(method) {
                        _class_call_check(this, RequestType6);
                        return _super.call(this, method, 6);
                    }
                    return RequestType6;
                }(AbstractMessageSignature);
                exports1.RequestType6 = RequestType6;
                var RequestType7 = /*#__PURE__*/ function(AbstractMessageSignature) {
                    _inherits(RequestType7, AbstractMessageSignature);
                    var _super = _create_super(RequestType7);
                    function RequestType7(method) {
                        _class_call_check(this, RequestType7);
                        return _super.call(this, method, 7);
                    }
                    return RequestType7;
                }(AbstractMessageSignature);
                exports1.RequestType7 = RequestType7;
                var RequestType8 = /*#__PURE__*/ function(AbstractMessageSignature) {
                    _inherits(RequestType8, AbstractMessageSignature);
                    var _super = _create_super(RequestType8);
                    function RequestType8(method) {
                        _class_call_check(this, RequestType8);
                        return _super.call(this, method, 8);
                    }
                    return RequestType8;
                }(AbstractMessageSignature);
                exports1.RequestType8 = RequestType8;
                var RequestType9 = /*#__PURE__*/ function(AbstractMessageSignature) {
                    _inherits(RequestType9, AbstractMessageSignature);
                    var _super = _create_super(RequestType9);
                    function RequestType9(method) {
                        _class_call_check(this, RequestType9);
                        return _super.call(this, method, 9);
                    }
                    return RequestType9;
                }(AbstractMessageSignature);
                exports1.RequestType9 = RequestType9;
                var NotificationType = /*#__PURE__*/ function(AbstractMessageSignature) {
                    _inherits(NotificationType, AbstractMessageSignature);
                    var _super = _create_super(NotificationType);
                    function NotificationType(method) {
                        var _parameterStructures = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ParameterStructures.auto;
                        _class_call_check(this, NotificationType);
                        var _this;
                        _this = _super.call(this, method, 1);
                        _this._parameterStructures = _parameterStructures;
                        return _this;
                    }
                    _create_class(NotificationType, [
                        {
                            key: "parameterStructures",
                            get: function get() {
                                return this._parameterStructures;
                            }
                        }
                    ]);
                    return NotificationType;
                }(AbstractMessageSignature);
                exports1.NotificationType = NotificationType;
                var NotificationType0 = /*#__PURE__*/ function(AbstractMessageSignature) {
                    _inherits(NotificationType0, AbstractMessageSignature);
                    var _super = _create_super(NotificationType0);
                    function NotificationType0(method) {
                        _class_call_check(this, NotificationType0);
                        return _super.call(this, method, 0);
                    }
                    return NotificationType0;
                }(AbstractMessageSignature);
                exports1.NotificationType0 = NotificationType0;
                var NotificationType1 = /*#__PURE__*/ function(AbstractMessageSignature) {
                    _inherits(NotificationType1, AbstractMessageSignature);
                    var _super = _create_super(NotificationType1);
                    function NotificationType1(method) {
                        var _parameterStructures = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ParameterStructures.auto;
                        _class_call_check(this, NotificationType1);
                        var _this;
                        _this = _super.call(this, method, 1);
                        _this._parameterStructures = _parameterStructures;
                        return _this;
                    }
                    _create_class(NotificationType1, [
                        {
                            key: "parameterStructures",
                            get: function get() {
                                return this._parameterStructures;
                            }
                        }
                    ]);
                    return NotificationType1;
                }(AbstractMessageSignature);
                exports1.NotificationType1 = NotificationType1;
                var NotificationType2 = /*#__PURE__*/ function(AbstractMessageSignature) {
                    _inherits(NotificationType2, AbstractMessageSignature);
                    var _super = _create_super(NotificationType2);
                    function NotificationType2(method) {
                        _class_call_check(this, NotificationType2);
                        return _super.call(this, method, 2);
                    }
                    return NotificationType2;
                }(AbstractMessageSignature);
                exports1.NotificationType2 = NotificationType2;
                var NotificationType3 = /*#__PURE__*/ function(AbstractMessageSignature) {
                    _inherits(NotificationType3, AbstractMessageSignature);
                    var _super = _create_super(NotificationType3);
                    function NotificationType3(method) {
                        _class_call_check(this, NotificationType3);
                        return _super.call(this, method, 3);
                    }
                    return NotificationType3;
                }(AbstractMessageSignature);
                exports1.NotificationType3 = NotificationType3;
                var NotificationType4 = /*#__PURE__*/ function(AbstractMessageSignature) {
                    _inherits(NotificationType4, AbstractMessageSignature);
                    var _super = _create_super(NotificationType4);
                    function NotificationType4(method) {
                        _class_call_check(this, NotificationType4);
                        return _super.call(this, method, 4);
                    }
                    return NotificationType4;
                }(AbstractMessageSignature);
                exports1.NotificationType4 = NotificationType4;
                var NotificationType5 = /*#__PURE__*/ function(AbstractMessageSignature) {
                    _inherits(NotificationType5, AbstractMessageSignature);
                    var _super = _create_super(NotificationType5);
                    function NotificationType5(method) {
                        _class_call_check(this, NotificationType5);
                        return _super.call(this, method, 5);
                    }
                    return NotificationType5;
                }(AbstractMessageSignature);
                exports1.NotificationType5 = NotificationType5;
                var NotificationType6 = /*#__PURE__*/ function(AbstractMessageSignature) {
                    _inherits(NotificationType6, AbstractMessageSignature);
                    var _super = _create_super(NotificationType6);
                    function NotificationType6(method) {
                        _class_call_check(this, NotificationType6);
                        return _super.call(this, method, 6);
                    }
                    return NotificationType6;
                }(AbstractMessageSignature);
                exports1.NotificationType6 = NotificationType6;
                var NotificationType7 = /*#__PURE__*/ function(AbstractMessageSignature) {
                    _inherits(NotificationType7, AbstractMessageSignature);
                    var _super = _create_super(NotificationType7);
                    function NotificationType7(method) {
                        _class_call_check(this, NotificationType7);
                        return _super.call(this, method, 7);
                    }
                    return NotificationType7;
                }(AbstractMessageSignature);
                exports1.NotificationType7 = NotificationType7;
                var NotificationType8 = /*#__PURE__*/ function(AbstractMessageSignature) {
                    _inherits(NotificationType8, AbstractMessageSignature);
                    var _super = _create_super(NotificationType8);
                    function NotificationType8(method) {
                        _class_call_check(this, NotificationType8);
                        return _super.call(this, method, 8);
                    }
                    return NotificationType8;
                }(AbstractMessageSignature);
                exports1.NotificationType8 = NotificationType8;
                var NotificationType9 = /*#__PURE__*/ function(AbstractMessageSignature) {
                    _inherits(NotificationType9, AbstractMessageSignature);
                    var _super = _create_super(NotificationType9);
                    function NotificationType9(method) {
                        _class_call_check(this, NotificationType9);
                        return _super.call(this, method, 9);
                    }
                    return NotificationType9;
                }(AbstractMessageSignature);
                exports1.NotificationType9 = NotificationType9;
                var Message;
                (function(Message) {
                    var isRequest = /**
     * Tests if the given message is a request message
     */ function isRequest(message) {
                        var candidate = message;
                        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
                    };
                    var isNotification = /**
     * Tests if the given message is a notification message
     */ function isNotification(message) {
                        var candidate = message;
                        return candidate && is.string(candidate.method) && message.id === void 0;
                    };
                    var isResponse = /**
     * Tests if the given message is a response message
     */ function isResponse(message) {
                        var candidate = message;
                        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
                    };
                    Message.isRequest = isRequest;
                    Message.isNotification = isNotification;
                    Message.isResponse = isResponse;
                })(Message = exports1.Message || (exports1.Message = {}));
            //# sourceMappingURL=messages.js.map
            /***/ },
            /***/ 5706: /***/ function(__unused_webpack_module, exports1) {
                "use strict";
                var RAL = function RAL() {
                    if (_ral === undefined) {
                        throw new Error("No runtime abstraction layer installed");
                    }
                    return _ral;
                };
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                var _ral;
                (function(RAL) {
                    var install = function install(ral) {
                        if (ral === undefined) {
                            throw new Error("No runtime abstraction layer provided");
                        }
                        _ral = ral;
                    };
                    RAL.install = install;
                })(RAL || (RAL = {}));
                exports1["default"] = RAL;
            //# sourceMappingURL=ral.js.map
            /***/ },
            /***/ 2339: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1966701__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Semaphore = void 0;
                var ral_1 = __nested_webpack_require_1966701__(5706);
                var Semaphore = /*#__PURE__*/ function() {
                    function Semaphore() {
                        var capacity = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
                        _class_call_check(this, Semaphore);
                        if (capacity <= 0) {
                            throw new Error("Capacity must be greater than 0");
                        }
                        this._capacity = capacity;
                        this._active = 0;
                        this._waiting = [];
                    }
                    _create_class(Semaphore, [
                        {
                            key: "lock",
                            value: function lock(thunk) {
                                var _this = this;
                                return new Promise(function(resolve, reject) {
                                    _this._waiting.push({
                                        thunk: thunk,
                                        resolve: resolve,
                                        reject: reject
                                    });
                                    _this.runNext();
                                });
                            }
                        },
                        {
                            key: "active",
                            get: function get() {
                                return this._active;
                            }
                        },
                        {
                            key: "runNext",
                            value: function runNext() {
                                var _this = this;
                                if (this._waiting.length === 0 || this._active === this._capacity) {
                                    return;
                                }
                                (0, ral_1.default)().timer.setImmediate(function() {
                                    return _this.doRunNext();
                                });
                            }
                        },
                        {
                            key: "doRunNext",
                            value: function doRunNext() {
                                var _this = this;
                                if (this._waiting.length === 0 || this._active === this._capacity) {
                                    return;
                                }
                                var next = this._waiting.shift();
                                this._active++;
                                if (this._active > this._capacity) {
                                    throw new Error("To many thunks active");
                                }
                                try {
                                    var result = next.thunk();
                                    if (_instanceof(result, Promise)) {
                                        result.then(function(value) {
                                            _this._active--;
                                            next.resolve(value);
                                            _this.runNext();
                                        }, function(err) {
                                            _this._active--;
                                            next.reject(err);
                                            _this.runNext();
                                        });
                                    } else {
                                        this._active--;
                                        next.resolve(result);
                                        this.runNext();
                                    }
                                } catch (err) {
                                    this._active--;
                                    next.reject(err);
                                    this.runNext();
                                }
                            }
                        }
                    ]);
                    return Semaphore;
                }();
                exports1.Semaphore = Semaphore;
            //# sourceMappingURL=semaphore.js.map
            /***/ },
            /***/ 294: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1971634__) {
                "use strict";
                var createProtocolConnection = function createProtocolConnection(reader, writer, logger, options) {
                    return (0, browser_1.createMessageConnection)(reader, writer, logger, options);
                };
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function get() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createProtocolConnection = void 0;
                var browser_1 = __nested_webpack_require_1971634__(1200);
                __exportStar(__nested_webpack_require_1971634__(1200), exports1);
                __exportStar(__nested_webpack_require_1971634__(0), exports1);
                exports1.createProtocolConnection = createProtocolConnection;
            //# sourceMappingURL=main.js.map
            /***/ },
            /***/ 0: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1973896__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function get() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LSPErrorCodes = exports1.createProtocolConnection = void 0;
                __exportStar(__nested_webpack_require_1973896__(5953), exports1);
                __exportStar(__nested_webpack_require_1973896__(4767), exports1);
                __exportStar(__nested_webpack_require_1973896__(8599), exports1);
                __exportStar(__nested_webpack_require_1973896__(6525), exports1);
                var connection_1 = __nested_webpack_require_1973896__(2798);
                Object.defineProperty(exports1, "createProtocolConnection", {
                    enumerable: true,
                    get: function get() {
                        return connection_1.createProtocolConnection;
                    }
                });
                var LSPErrorCodes;
                (function(LSPErrorCodes) {
                    /**
    * This is the start range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */ LSPErrorCodes.lspReservedErrorRangeStart = -32899;
                    /**
     * A request failed but it was syntactically correct, e.g the
     * method name was known and the parameters were valid. The error
     * message should contain human readable information about why
     * the request failed.
     *
     * @since 3.17.0
     */ LSPErrorCodes.RequestFailed = -32803;
                    /**
     * The server cancelled the request. This error code should
     * only be used for requests that explicitly support being
     * server cancellable.
     *
     * @since 3.17.0
     */ LSPErrorCodes.ServerCancelled = -32802;
                    /**
     * The server detected that the content of a document got
     * modified outside normal conditions. A server should
     * NOT send this error code if it detects a content change
     * in it unprocessed messages. The result even computed
     * on an older state might still be useful for the client.
     *
     * If a client decides that a result is not of any use anymore
     * the client should cancel the request.
     */ LSPErrorCodes.ContentModified = -32801;
                    /**
     * The client has canceled a request and a server as detected
     * the cancel.
     */ LSPErrorCodes.RequestCancelled = -32800;
                    /**
    * This is the end range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */ LSPErrorCodes.lspReservedErrorRangeEnd = -32800;
                })(LSPErrorCodes = exports1.LSPErrorCodes || (exports1.LSPErrorCodes = {}));
            //# sourceMappingURL=api.js.map
            /***/ },
            /***/ 2798: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1978107__) {
                "use strict";
                var createProtocolConnection = function createProtocolConnection(input, output, logger, options) {
                    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
                        options = {
                            connectionStrategy: options
                        };
                    }
                    return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
                };
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createProtocolConnection = void 0;
                var vscode_jsonrpc_1 = __nested_webpack_require_1978107__(5953);
                exports1.createProtocolConnection = createProtocolConnection;
            //# sourceMappingURL=connection.js.map
            /***/ },
            /***/ 8599: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1979432__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ProtocolNotificationType = exports1.ProtocolNotificationType0 = exports1.ProtocolRequestType = exports1.ProtocolRequestType0 = exports1.RegistrationType = exports1.MessageDirection = void 0;
                var vscode_jsonrpc_1 = __nested_webpack_require_1979432__(5953);
                var MessageDirection;
                (function(MessageDirection) {
                    MessageDirection["clientToServer"] = "clientToServer";
                    MessageDirection["serverToClient"] = "serverToClient";
                    MessageDirection["both"] = "both";
                })(MessageDirection = exports1.MessageDirection || (exports1.MessageDirection = {}));
                var RegistrationType = function RegistrationType(method) {
                    _class_call_check(this, RegistrationType);
                    this.method = method;
                };
                exports1.RegistrationType = RegistrationType;
                var ProtocolRequestType0 = /*#__PURE__*/ function(_vscode_jsonrpc_1_RequestType0) {
                    _inherits(ProtocolRequestType0, _vscode_jsonrpc_1_RequestType0);
                    var _super = _create_super(ProtocolRequestType0);
                    function ProtocolRequestType0(method) {
                        _class_call_check(this, ProtocolRequestType0);
                        return _super.call(this, method);
                    }
                    return ProtocolRequestType0;
                }(vscode_jsonrpc_1.RequestType0);
                exports1.ProtocolRequestType0 = ProtocolRequestType0;
                var ProtocolRequestType = /*#__PURE__*/ function(_vscode_jsonrpc_1_RequestType) {
                    _inherits(ProtocolRequestType, _vscode_jsonrpc_1_RequestType);
                    var _super = _create_super(ProtocolRequestType);
                    function ProtocolRequestType(method) {
                        _class_call_check(this, ProtocolRequestType);
                        return _super.call(this, method, vscode_jsonrpc_1.ParameterStructures.byName);
                    }
                    return ProtocolRequestType;
                }(vscode_jsonrpc_1.RequestType);
                exports1.ProtocolRequestType = ProtocolRequestType;
                var ProtocolNotificationType0 = /*#__PURE__*/ function(_vscode_jsonrpc_1_NotificationType0) {
                    _inherits(ProtocolNotificationType0, _vscode_jsonrpc_1_NotificationType0);
                    var _super = _create_super(ProtocolNotificationType0);
                    function ProtocolNotificationType0(method) {
                        _class_call_check(this, ProtocolNotificationType0);
                        return _super.call(this, method);
                    }
                    return ProtocolNotificationType0;
                }(vscode_jsonrpc_1.NotificationType0);
                exports1.ProtocolNotificationType0 = ProtocolNotificationType0;
                var ProtocolNotificationType = /*#__PURE__*/ function(_vscode_jsonrpc_1_NotificationType) {
                    _inherits(ProtocolNotificationType, _vscode_jsonrpc_1_NotificationType);
                    var _super = _create_super(ProtocolNotificationType);
                    function ProtocolNotificationType(method) {
                        _class_call_check(this, ProtocolNotificationType);
                        return _super.call(this, method, vscode_jsonrpc_1.ParameterStructures.byName);
                    }
                    return ProtocolNotificationType;
                }(vscode_jsonrpc_1.NotificationType);
                exports1.ProtocolNotificationType = ProtocolNotificationType;
            //# sourceMappingURL=messages.js.map
            /***/ },
            /***/ 4434: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1983747__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.CallHierarchyOutgoingCallsRequest = exports1.CallHierarchyIncomingCallsRequest = exports1.CallHierarchyPrepareRequest = void 0;
                var messages_1 = __nested_webpack_require_1983747__(8599);
                /**
 * A request to result a `CallHierarchyItem` in a document at a given position.
 * Can be used as an input to an incoming or outgoing call hierarchy.
 *
 * @since 3.16.0
 */ var CallHierarchyPrepareRequest;
                (function(CallHierarchyPrepareRequest) {
                    CallHierarchyPrepareRequest.method = "textDocument/prepareCallHierarchy";
                    CallHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);
                })(CallHierarchyPrepareRequest = exports1.CallHierarchyPrepareRequest || (exports1.CallHierarchyPrepareRequest = {}));
                /**
 * A request to resolve the incoming calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */ var CallHierarchyIncomingCallsRequest;
                (function(CallHierarchyIncomingCallsRequest) {
                    CallHierarchyIncomingCallsRequest.method = "callHierarchy/incomingCalls";
                    CallHierarchyIncomingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);
                })(CallHierarchyIncomingCallsRequest = exports1.CallHierarchyIncomingCallsRequest || (exports1.CallHierarchyIncomingCallsRequest = {}));
                /**
 * A request to resolve the outgoing calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */ var CallHierarchyOutgoingCallsRequest;
                (function(CallHierarchyOutgoingCallsRequest) {
                    CallHierarchyOutgoingCallsRequest.method = "callHierarchy/outgoingCalls";
                    CallHierarchyOutgoingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);
                })(CallHierarchyOutgoingCallsRequest = exports1.CallHierarchyOutgoingCallsRequest || (exports1.CallHierarchyOutgoingCallsRequest = {}));
            //# sourceMappingURL=protocol.callHierarchy.js.map
            /***/ },
            /***/ 7908: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1986846__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ColorPresentationRequest = exports1.DocumentColorRequest = void 0;
                var messages_1 = __nested_webpack_require_1986846__(8599);
                /**
 * A request to list all color symbols found in a given text document. The request's
 * parameter is of type [DocumentColorParams](#DocumentColorParams) the
 * response is of type [ColorInformation[]](#ColorInformation) or a Thenable
 * that resolves to such.
 */ var DocumentColorRequest;
                (function(DocumentColorRequest) {
                    DocumentColorRequest.method = "textDocument/documentColor";
                    DocumentColorRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);
                })(DocumentColorRequest = exports1.DocumentColorRequest || (exports1.DocumentColorRequest = {}));
                /**
 * A request to list all presentation for a color. The request's
 * parameter is of type [ColorPresentationParams](#ColorPresentationParams) the
 * response is of type [ColorInformation[]](#ColorInformation) or a Thenable
 * that resolves to such.
 */ var ColorPresentationRequest;
                (function(ColorPresentationRequest) {
                    ColorPresentationRequest.method = "textDocument/colorPresentation";
                    ColorPresentationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ColorPresentationRequest.type = new messages_1.ProtocolRequestType(ColorPresentationRequest.method);
                })(ColorPresentationRequest = exports1.ColorPresentationRequest || (exports1.ColorPresentationRequest = {}));
            //# sourceMappingURL=protocol.colorProvider.js.map
            /***/ },
            /***/ 5442: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1989245__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ConfigurationRequest = void 0;
                var messages_1 = __nested_webpack_require_1989245__(8599);
                //---- Get Configuration request ----
                /**
 * The 'workspace/configuration' request is sent from the server to the client to fetch a certain
 * configuration setting.
 *
 * This pull model replaces the old push model were the client signaled configuration change via an
 * event. If the server still needs to react to configuration changes (since the server caches the
 * result of `workspace/configuration` requests) the server should register for an empty configuration
 * change event and empty the cache if such an event is received.
 */ var ConfigurationRequest;
                (function(ConfigurationRequest) {
                    ConfigurationRequest.method = "workspace/configuration";
                    ConfigurationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ConfigurationRequest.type = new messages_1.ProtocolRequestType(ConfigurationRequest.method);
                })(ConfigurationRequest = exports1.ConfigurationRequest || (exports1.ConfigurationRequest = {}));
            //# sourceMappingURL=protocol.configuration.js.map
            /***/ },
            /***/ 7210: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1991095__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DeclarationRequest = void 0;
                var messages_1 = __nested_webpack_require_1991095__(8599);
                // @ts-ignore: to avoid inlining LocationLink as dynamic import
                var __noDynamicImport;
                /**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositionParams]
 * (#TextDocumentPositionParams) the response is of type [Declaration](#Declaration)
 * or a typed array of [DeclarationLink](#DeclarationLink) or a Thenable that resolves
 * to such.
 */ var DeclarationRequest;
                (function(DeclarationRequest) {
                    DeclarationRequest.method = "textDocument/declaration";
                    DeclarationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);
                })(DeclarationRequest = exports1.DeclarationRequest || (exports1.DeclarationRequest = {}));
            //# sourceMappingURL=protocol.declaration.js.map
            /***/ },
            /***/ 5692: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1992846__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DiagnosticRefreshRequest = exports1.WorkspaceDiagnosticRequest = exports1.DocumentDiagnosticRequest = exports1.DocumentDiagnosticReportKind = exports1.DiagnosticServerCancellationData = void 0;
                var vscode_jsonrpc_1 = __nested_webpack_require_1992846__(5953);
                var Is = __nested_webpack_require_1992846__(2523);
                var messages_1 = __nested_webpack_require_1992846__(8599);
                /**
 * @since 3.17.0
 */ var DiagnosticServerCancellationData;
                (function(DiagnosticServerCancellationData) {
                    var is = function is(value) {
                        var candidate = value;
                        return candidate && Is.boolean(candidate.retriggerRequest);
                    };
                    DiagnosticServerCancellationData.is = is;
                })(DiagnosticServerCancellationData = exports1.DiagnosticServerCancellationData || (exports1.DiagnosticServerCancellationData = {}));
                /**
 * The document diagnostic report kinds.
 *
 * @since 3.17.0
 */ var DocumentDiagnosticReportKind;
                (function(DocumentDiagnosticReportKind) {
                    /**
     * A diagnostic report with a full
     * set of problems.
     */ DocumentDiagnosticReportKind.Full = "full";
                    /**
     * A report indicating that the last
     * returned report is still accurate.
     */ DocumentDiagnosticReportKind.Unchanged = "unchanged";
                })(DocumentDiagnosticReportKind = exports1.DocumentDiagnosticReportKind || (exports1.DocumentDiagnosticReportKind = {}));
                /**
 * The document diagnostic request definition.
 *
 * @since 3.17.0
 */ var DocumentDiagnosticRequest;
                (function(DocumentDiagnosticRequest) {
                    DocumentDiagnosticRequest.method = "textDocument/diagnostic";
                    DocumentDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentDiagnosticRequest.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest.method);
                    DocumentDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
                })(DocumentDiagnosticRequest = exports1.DocumentDiagnosticRequest || (exports1.DocumentDiagnosticRequest = {}));
                /**
 * The workspace diagnostic request definition.
 *
 * @since 3.17.0
 */ var WorkspaceDiagnosticRequest;
                (function(WorkspaceDiagnosticRequest) {
                    WorkspaceDiagnosticRequest.method = "workspace/diagnostic";
                    WorkspaceDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkspaceDiagnosticRequest.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest.method);
                    WorkspaceDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
                })(WorkspaceDiagnosticRequest = exports1.WorkspaceDiagnosticRequest || (exports1.WorkspaceDiagnosticRequest = {}));
                /**
 * The diagnostic refresh request definition.
 *
 * @since 3.17.0
 */ var DiagnosticRefreshRequest;
                (function(DiagnosticRefreshRequest) {
                    DiagnosticRefreshRequest.method = "workspace/diagnostic/refresh";
                    DiagnosticRefreshRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DiagnosticRefreshRequest.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest.method);
                })(DiagnosticRefreshRequest = exports1.DiagnosticRefreshRequest || (exports1.DiagnosticRefreshRequest = {}));
            //# sourceMappingURL=protocol.diagnostic.js.map
            /***/ },
            /***/ 6190: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_1997159__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WillDeleteFilesRequest = exports1.DidDeleteFilesNotification = exports1.DidRenameFilesNotification = exports1.WillRenameFilesRequest = exports1.DidCreateFilesNotification = exports1.WillCreateFilesRequest = exports1.FileOperationPatternKind = void 0;
                var messages_1 = __nested_webpack_require_1997159__(8599);
                /**
 * A pattern kind describing if a glob pattern matches a file a folder or
 * both.
 *
 * @since 3.16.0
 */ var FileOperationPatternKind;
                (function(FileOperationPatternKind) {
                    /**
     * The pattern matches a file only.
     */ FileOperationPatternKind.file = "file";
                    /**
     * The pattern matches a folder only.
     */ FileOperationPatternKind.folder = "folder";
                })(FileOperationPatternKind = exports1.FileOperationPatternKind || (exports1.FileOperationPatternKind = {}));
                /**
 * The will create files request is sent from the client to the server before files are actually
 * created as long as the creation is triggered from within the client.
 *
 * @since 3.16.0
 */ var WillCreateFilesRequest;
                (function(WillCreateFilesRequest) {
                    WillCreateFilesRequest.method = "workspace/willCreateFiles";
                    WillCreateFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillCreateFilesRequest.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest.method);
                })(WillCreateFilesRequest = exports1.WillCreateFilesRequest || (exports1.WillCreateFilesRequest = {}));
                /**
 * The did create files notification is sent from the client to the server when
 * files were created from within the client.
 *
 * @since 3.16.0
 */ var DidCreateFilesNotification;
                (function(DidCreateFilesNotification) {
                    DidCreateFilesNotification.method = "workspace/didCreateFiles";
                    DidCreateFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidCreateFilesNotification.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification.method);
                })(DidCreateFilesNotification = exports1.DidCreateFilesNotification || (exports1.DidCreateFilesNotification = {}));
                /**
 * The will rename files request is sent from the client to the server before files are actually
 * renamed as long as the rename is triggered from within the client.
 *
 * @since 3.16.0
 */ var WillRenameFilesRequest;
                (function(WillRenameFilesRequest) {
                    WillRenameFilesRequest.method = "workspace/willRenameFiles";
                    WillRenameFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillRenameFilesRequest.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest.method);
                })(WillRenameFilesRequest = exports1.WillRenameFilesRequest || (exports1.WillRenameFilesRequest = {}));
                /**
 * The did rename files notification is sent from the client to the server when
 * files were renamed from within the client.
 *
 * @since 3.16.0
 */ var DidRenameFilesNotification;
                (function(DidRenameFilesNotification) {
                    DidRenameFilesNotification.method = "workspace/didRenameFiles";
                    DidRenameFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidRenameFilesNotification.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification.method);
                })(DidRenameFilesNotification = exports1.DidRenameFilesNotification || (exports1.DidRenameFilesNotification = {}));
                /**
 * The will delete files request is sent from the client to the server before files are actually
 * deleted as long as the deletion is triggered from within the client.
 *
 * @since 3.16.0
 */ var DidDeleteFilesNotification;
                (function(DidDeleteFilesNotification) {
                    DidDeleteFilesNotification.method = "workspace/didDeleteFiles";
                    DidDeleteFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidDeleteFilesNotification.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification.method);
                })(DidDeleteFilesNotification = exports1.DidDeleteFilesNotification || (exports1.DidDeleteFilesNotification = {}));
                /**
 * The did delete files notification is sent from the client to the server when
 * files were deleted from within the client.
 *
 * @since 3.16.0
 */ var WillDeleteFilesRequest;
                (function(WillDeleteFilesRequest) {
                    WillDeleteFilesRequest.method = "workspace/willDeleteFiles";
                    WillDeleteFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillDeleteFilesRequest.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest.method);
                })(WillDeleteFilesRequest = exports1.WillDeleteFilesRequest || (exports1.WillDeleteFilesRequest = {}));
            //# sourceMappingURL=protocol.fileOperations.js.map
            /***/ },
            /***/ 7029: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_2003031__) {
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.FoldingRangeRequest = void 0;
                var messages_1 = __nested_webpack_require_2003031__(8599);
                /**
 * A request to provide folding ranges in a document. The request's
 * parameter is of type [FoldingRangeParams](#FoldingRangeParams), the
 * response is of type [FoldingRangeList](#FoldingRangeList) or a Thenable
 * that resolves to such.
 */ var FoldingRangeRequest;
                (function(FoldingRangeRequest) {
                    FoldingRangeRequest.method = "textDocument/foldingRange";
                    FoldingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);
                })(FoldingRangeRequest = exports1.FoldingRangeRequest || (exports1.FoldingRangeRequest = {}));
            //# sourceMappingURL=protocol.foldingRange.js.map
            /***/ },
            /***/ 9380: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_2004565__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ImplementationRequest = void 0;
                var messages_1 = __nested_webpack_require_2004565__(8599);
                // @ts-ignore: to avoid inlining LocationLink as dynamic import
                var __noDynamicImport;
                /**
 * A request to resolve the implementation locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositionParams]
 * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */ var ImplementationRequest;
                (function(ImplementationRequest) {
                    ImplementationRequest.method = "textDocument/implementation";
                    ImplementationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);
                })(ImplementationRequest = exports1.ImplementationRequest || (exports1.ImplementationRequest = {}));
            //# sourceMappingURL=protocol.implementation.js.map
            /***/ },
            /***/ 6315: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_2006290__) {
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.InlayHintRefreshRequest = exports1.InlayHintResolveRequest = exports1.InlayHintRequest = void 0;
                var messages_1 = __nested_webpack_require_2006290__(8599);
                /**
 * A request to provide inlay hints in a document. The request's parameter is of
 * type [InlayHintsParams](#InlayHintsParams), the response is of type
 * [InlayHint[]](#InlayHint[]) or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */ var InlayHintRequest;
                (function(InlayHintRequest) {
                    InlayHintRequest.method = "textDocument/inlayHint";
                    InlayHintRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlayHintRequest.type = new messages_1.ProtocolRequestType(InlayHintRequest.method);
                })(InlayHintRequest = exports1.InlayHintRequest || (exports1.InlayHintRequest = {}));
                /**
 * A request to resolve additional properties for an inlay hint.
 * The request's parameter is of type [InlayHint](#InlayHint), the response is
 * of type [InlayHint](#InlayHint) or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */ var InlayHintResolveRequest;
                (function(InlayHintResolveRequest) {
                    InlayHintResolveRequest.method = "inlayHint/resolve";
                    InlayHintResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlayHintResolveRequest.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest.method);
                })(InlayHintResolveRequest = exports1.InlayHintResolveRequest || (exports1.InlayHintResolveRequest = {}));
                /**
 * @since 3.17.0
 */ var InlayHintRefreshRequest;
                (function(InlayHintRefreshRequest) {
                    InlayHintRefreshRequest.method = "workspace/inlayHint/refresh";
                    InlayHintRefreshRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlayHintRefreshRequest.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest.method);
                })(InlayHintRefreshRequest = exports1.InlayHintRefreshRequest || (exports1.InlayHintRefreshRequest = {}));
            //# sourceMappingURL=protocol.inlayHint.js.map
            /***/ },
            /***/ 7425: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_2009180__) {
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.InlineValueRefreshRequest = exports1.InlineValueRequest = void 0;
                var messages_1 = __nested_webpack_require_2009180__(8599);
                /**
 * A request to provide inline values in a document. The request's parameter is of
 * type [InlineValueParams](#InlineValueParams), the response is of type
 * [InlineValue[]](#InlineValue[]) or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */ var InlineValueRequest;
                (function(InlineValueRequest) {
                    InlineValueRequest.method = "textDocument/inlineValue";
                    InlineValueRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlineValueRequest.type = new messages_1.ProtocolRequestType(InlineValueRequest.method);
                })(InlineValueRequest = exports1.InlineValueRequest || (exports1.InlineValueRequest = {}));
                /**
 * @since 3.17.0
 */ var InlineValueRefreshRequest;
                (function(InlineValueRefreshRequest) {
                    InlineValueRefreshRequest.method = "workspace/inlineValue/refresh";
                    InlineValueRefreshRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlineValueRefreshRequest.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest.method);
                })(InlineValueRefreshRequest = exports1.InlineValueRefreshRequest || (exports1.InlineValueRefreshRequest = {}));
            //# sourceMappingURL=protocol.inlineValue.js.map
            /***/ },
            /***/ 6525: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_2011324__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WorkspaceSymbolRequest = exports1.CodeActionResolveRequest = exports1.CodeActionRequest = exports1.DocumentSymbolRequest = exports1.DocumentHighlightRequest = exports1.ReferencesRequest = exports1.DefinitionRequest = exports1.SignatureHelpRequest = exports1.SignatureHelpTriggerKind = exports1.HoverRequest = exports1.CompletionResolveRequest = exports1.CompletionRequest = exports1.CompletionTriggerKind = exports1.PublishDiagnosticsNotification = exports1.WatchKind = exports1.RelativePattern = exports1.FileChangeType = exports1.DidChangeWatchedFilesNotification = exports1.WillSaveTextDocumentWaitUntilRequest = exports1.WillSaveTextDocumentNotification = exports1.TextDocumentSaveReason = exports1.DidSaveTextDocumentNotification = exports1.DidCloseTextDocumentNotification = exports1.DidChangeTextDocumentNotification = exports1.TextDocumentContentChangeEvent = exports1.DidOpenTextDocumentNotification = exports1.TextDocumentSyncKind = exports1.TelemetryEventNotification = exports1.LogMessageNotification = exports1.ShowMessageRequest = exports1.ShowMessageNotification = exports1.MessageType = exports1.DidChangeConfigurationNotification = exports1.ExitNotification = exports1.ShutdownRequest = exports1.InitializedNotification = exports1.InitializeErrorCodes = exports1.InitializeRequest = exports1.WorkDoneProgressOptions = exports1.TextDocumentRegistrationOptions = exports1.StaticRegistrationOptions = exports1.PositionEncodingKind = exports1.FailureHandlingKind = exports1.ResourceOperationKind = exports1.UnregistrationRequest = exports1.RegistrationRequest = exports1.DocumentSelector = exports1.NotebookCellTextDocumentFilter = exports1.NotebookDocumentFilter = exports1.TextDocumentFilter = void 0;
                exports1.TypeHierarchySubtypesRequest = exports1.TypeHierarchyPrepareRequest = exports1.MonikerRequest = exports1.MonikerKind = exports1.UniquenessLevel = exports1.WillDeleteFilesRequest = exports1.DidDeleteFilesNotification = exports1.WillRenameFilesRequest = exports1.DidRenameFilesNotification = exports1.WillCreateFilesRequest = exports1.DidCreateFilesNotification = exports1.FileOperationPatternKind = exports1.LinkedEditingRangeRequest = exports1.ShowDocumentRequest = exports1.SemanticTokensRegistrationType = exports1.SemanticTokensRefreshRequest = exports1.SemanticTokensRangeRequest = exports1.SemanticTokensDeltaRequest = exports1.SemanticTokensRequest = exports1.TokenFormat = exports1.CallHierarchyPrepareRequest = exports1.CallHierarchyOutgoingCallsRequest = exports1.CallHierarchyIncomingCallsRequest = exports1.WorkDoneProgressCancelNotification = exports1.WorkDoneProgressCreateRequest = exports1.WorkDoneProgress = exports1.SelectionRangeRequest = exports1.DeclarationRequest = exports1.FoldingRangeRequest = exports1.ColorPresentationRequest = exports1.DocumentColorRequest = exports1.ConfigurationRequest = exports1.DidChangeWorkspaceFoldersNotification = exports1.WorkspaceFoldersRequest = exports1.TypeDefinitionRequest = exports1.ImplementationRequest = exports1.ApplyWorkspaceEditRequest = exports1.ExecuteCommandRequest = exports1.PrepareRenameRequest = exports1.RenameRequest = exports1.PrepareSupportDefaultBehavior = exports1.DocumentOnTypeFormattingRequest = exports1.DocumentRangeFormattingRequest = exports1.DocumentFormattingRequest = exports1.DocumentLinkResolveRequest = exports1.DocumentLinkRequest = exports1.CodeLensRefreshRequest = exports1.CodeLensResolveRequest = exports1.CodeLensRequest = exports1.WorkspaceSymbolResolveRequest = void 0;
                exports1.DidCloseNotebookDocumentNotification = exports1.DidSaveNotebookDocumentNotification = exports1.DidChangeNotebookDocumentNotification = exports1.NotebookCellArrayChange = exports1.DidOpenNotebookDocumentNotification = exports1.NotebookDocumentSyncRegistrationType = exports1.NotebookDocument = exports1.NotebookCell = exports1.ExecutionSummary = exports1.NotebookCellKind = exports1.DiagnosticRefreshRequest = exports1.WorkspaceDiagnosticRequest = exports1.DocumentDiagnosticRequest = exports1.DocumentDiagnosticReportKind = exports1.DiagnosticServerCancellationData = exports1.InlayHintRefreshRequest = exports1.InlayHintResolveRequest = exports1.InlayHintRequest = exports1.InlineValueRefreshRequest = exports1.InlineValueRequest = exports1.TypeHierarchySupertypesRequest = void 0;
                var messages_1 = __nested_webpack_require_2011324__(8599);
                var vscode_languageserver_types_1 = __nested_webpack_require_2011324__(4767);
                var Is = __nested_webpack_require_2011324__(2523);
                var protocol_implementation_1 = __nested_webpack_require_2011324__(9380);
                Object.defineProperty(exports1, "ImplementationRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_implementation_1.ImplementationRequest;
                    }
                });
                var protocol_typeDefinition_1 = __nested_webpack_require_2011324__(8642);
                Object.defineProperty(exports1, "TypeDefinitionRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_typeDefinition_1.TypeDefinitionRequest;
                    }
                });
                var protocol_workspaceFolder_1 = __nested_webpack_require_2011324__(3402);
                Object.defineProperty(exports1, "WorkspaceFoldersRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
                    }
                });
                Object.defineProperty(exports1, "DidChangeWorkspaceFoldersNotification", {
                    enumerable: true,
                    get: function get() {
                        return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
                    }
                });
                var protocol_configuration_1 = __nested_webpack_require_2011324__(5442);
                Object.defineProperty(exports1, "ConfigurationRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_configuration_1.ConfigurationRequest;
                    }
                });
                var protocol_colorProvider_1 = __nested_webpack_require_2011324__(7908);
                Object.defineProperty(exports1, "DocumentColorRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_colorProvider_1.DocumentColorRequest;
                    }
                });
                Object.defineProperty(exports1, "ColorPresentationRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_colorProvider_1.ColorPresentationRequest;
                    }
                });
                var protocol_foldingRange_1 = __nested_webpack_require_2011324__(7029);
                Object.defineProperty(exports1, "FoldingRangeRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_foldingRange_1.FoldingRangeRequest;
                    }
                });
                var protocol_declaration_1 = __nested_webpack_require_2011324__(7210);
                Object.defineProperty(exports1, "DeclarationRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_declaration_1.DeclarationRequest;
                    }
                });
                var protocol_selectionRange_1 = __nested_webpack_require_2011324__(2392);
                Object.defineProperty(exports1, "SelectionRangeRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_selectionRange_1.SelectionRangeRequest;
                    }
                });
                var protocol_progress_1 = __nested_webpack_require_2011324__(7895);
                Object.defineProperty(exports1, "WorkDoneProgress", {
                    enumerable: true,
                    get: function get() {
                        return protocol_progress_1.WorkDoneProgress;
                    }
                });
                Object.defineProperty(exports1, "WorkDoneProgressCreateRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_progress_1.WorkDoneProgressCreateRequest;
                    }
                });
                Object.defineProperty(exports1, "WorkDoneProgressCancelNotification", {
                    enumerable: true,
                    get: function get() {
                        return protocol_progress_1.WorkDoneProgressCancelNotification;
                    }
                });
                var protocol_callHierarchy_1 = __nested_webpack_require_2011324__(4434);
                Object.defineProperty(exports1, "CallHierarchyIncomingCallsRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
                    }
                });
                Object.defineProperty(exports1, "CallHierarchyOutgoingCallsRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
                    }
                });
                Object.defineProperty(exports1, "CallHierarchyPrepareRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
                    }
                });
                var protocol_semanticTokens_1 = __nested_webpack_require_2011324__(8489);
                Object.defineProperty(exports1, "TokenFormat", {
                    enumerable: true,
                    get: function get() {
                        return protocol_semanticTokens_1.TokenFormat;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_semanticTokens_1.SemanticTokensRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensDeltaRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRangeRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_semanticTokens_1.SemanticTokensRangeRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRefreshRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRegistrationType", {
                    enumerable: true,
                    get: function get() {
                        return protocol_semanticTokens_1.SemanticTokensRegistrationType;
                    }
                });
                var protocol_showDocument_1 = __nested_webpack_require_2011324__(1541);
                Object.defineProperty(exports1, "ShowDocumentRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_showDocument_1.ShowDocumentRequest;
                    }
                });
                var protocol_linkedEditingRange_1 = __nested_webpack_require_2011324__(527);
                Object.defineProperty(exports1, "LinkedEditingRangeRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
                    }
                });
                var protocol_fileOperations_1 = __nested_webpack_require_2011324__(6190);
                Object.defineProperty(exports1, "FileOperationPatternKind", {
                    enumerable: true,
                    get: function get() {
                        return protocol_fileOperations_1.FileOperationPatternKind;
                    }
                });
                Object.defineProperty(exports1, "DidCreateFilesNotification", {
                    enumerable: true,
                    get: function get() {
                        return protocol_fileOperations_1.DidCreateFilesNotification;
                    }
                });
                Object.defineProperty(exports1, "WillCreateFilesRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_fileOperations_1.WillCreateFilesRequest;
                    }
                });
                Object.defineProperty(exports1, "DidRenameFilesNotification", {
                    enumerable: true,
                    get: function get() {
                        return protocol_fileOperations_1.DidRenameFilesNotification;
                    }
                });
                Object.defineProperty(exports1, "WillRenameFilesRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_fileOperations_1.WillRenameFilesRequest;
                    }
                });
                Object.defineProperty(exports1, "DidDeleteFilesNotification", {
                    enumerable: true,
                    get: function get() {
                        return protocol_fileOperations_1.DidDeleteFilesNotification;
                    }
                });
                Object.defineProperty(exports1, "WillDeleteFilesRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_fileOperations_1.WillDeleteFilesRequest;
                    }
                });
                var protocol_moniker_1 = __nested_webpack_require_2011324__(1964);
                Object.defineProperty(exports1, "UniquenessLevel", {
                    enumerable: true,
                    get: function get() {
                        return protocol_moniker_1.UniquenessLevel;
                    }
                });
                Object.defineProperty(exports1, "MonikerKind", {
                    enumerable: true,
                    get: function get() {
                        return protocol_moniker_1.MonikerKind;
                    }
                });
                Object.defineProperty(exports1, "MonikerRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_moniker_1.MonikerRequest;
                    }
                });
                var protocol_typeHierarchy_1 = __nested_webpack_require_2011324__(5318);
                Object.defineProperty(exports1, "TypeHierarchyPrepareRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
                    }
                });
                Object.defineProperty(exports1, "TypeHierarchySubtypesRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
                    }
                });
                Object.defineProperty(exports1, "TypeHierarchySupertypesRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
                    }
                });
                var protocol_inlineValue_1 = __nested_webpack_require_2011324__(7425);
                Object.defineProperty(exports1, "InlineValueRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_inlineValue_1.InlineValueRequest;
                    }
                });
                Object.defineProperty(exports1, "InlineValueRefreshRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_inlineValue_1.InlineValueRefreshRequest;
                    }
                });
                var protocol_inlayHint_1 = __nested_webpack_require_2011324__(6315);
                Object.defineProperty(exports1, "InlayHintRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_inlayHint_1.InlayHintRequest;
                    }
                });
                Object.defineProperty(exports1, "InlayHintResolveRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_inlayHint_1.InlayHintResolveRequest;
                    }
                });
                Object.defineProperty(exports1, "InlayHintRefreshRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_inlayHint_1.InlayHintRefreshRequest;
                    }
                });
                var protocol_diagnostic_1 = __nested_webpack_require_2011324__(5692);
                Object.defineProperty(exports1, "DiagnosticServerCancellationData", {
                    enumerable: true,
                    get: function get() {
                        return protocol_diagnostic_1.DiagnosticServerCancellationData;
                    }
                });
                Object.defineProperty(exports1, "DocumentDiagnosticReportKind", {
                    enumerable: true,
                    get: function get() {
                        return protocol_diagnostic_1.DocumentDiagnosticReportKind;
                    }
                });
                Object.defineProperty(exports1, "DocumentDiagnosticRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_diagnostic_1.DocumentDiagnosticRequest;
                    }
                });
                Object.defineProperty(exports1, "WorkspaceDiagnosticRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
                    }
                });
                Object.defineProperty(exports1, "DiagnosticRefreshRequest", {
                    enumerable: true,
                    get: function get() {
                        return protocol_diagnostic_1.DiagnosticRefreshRequest;
                    }
                });
                var protocol_notebook_1 = __nested_webpack_require_2011324__(4460);
                Object.defineProperty(exports1, "NotebookCellKind", {
                    enumerable: true,
                    get: function get() {
                        return protocol_notebook_1.NotebookCellKind;
                    }
                });
                Object.defineProperty(exports1, "ExecutionSummary", {
                    enumerable: true,
                    get: function get() {
                        return protocol_notebook_1.ExecutionSummary;
                    }
                });
                Object.defineProperty(exports1, "NotebookCell", {
                    enumerable: true,
                    get: function get() {
                        return protocol_notebook_1.NotebookCell;
                    }
                });
                Object.defineProperty(exports1, "NotebookDocument", {
                    enumerable: true,
                    get: function get() {
                        return protocol_notebook_1.NotebookDocument;
                    }
                });
                Object.defineProperty(exports1, "NotebookDocumentSyncRegistrationType", {
                    enumerable: true,
                    get: function get() {
                        return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
                    }
                });
                Object.defineProperty(exports1, "DidOpenNotebookDocumentNotification", {
                    enumerable: true,
                    get: function get() {
                        return protocol_notebook_1.DidOpenNotebookDocumentNotification;
                    }
                });
                Object.defineProperty(exports1, "NotebookCellArrayChange", {
                    enumerable: true,
                    get: function get() {
                        return protocol_notebook_1.NotebookCellArrayChange;
                    }
                });
                Object.defineProperty(exports1, "DidChangeNotebookDocumentNotification", {
                    enumerable: true,
                    get: function get() {
                        return protocol_notebook_1.DidChangeNotebookDocumentNotification;
                    }
                });
                Object.defineProperty(exports1, "DidSaveNotebookDocumentNotification", {
                    enumerable: true,
                    get: function get() {
                        return protocol_notebook_1.DidSaveNotebookDocumentNotification;
                    }
                });
                Object.defineProperty(exports1, "DidCloseNotebookDocumentNotification", {
                    enumerable: true,
                    get: function get() {
                        return protocol_notebook_1.DidCloseNotebookDocumentNotification;
                    }
                });
                // @ts-ignore: to avoid inlining LocationLink as dynamic import
                var __noDynamicImport;
                /**
 * The TextDocumentFilter namespace provides helper functions to work with
 * [TextDocumentFilter](#TextDocumentFilter) literals.
 *
 * @since 3.17.0
 */ var TextDocumentFilter;
                (function(TextDocumentFilter) {
                    var is = function is(value) {
                        var candidate = value;
                        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
                    };
                    TextDocumentFilter.is = is;
                })(TextDocumentFilter = exports1.TextDocumentFilter || (exports1.TextDocumentFilter = {}));
                /**
 * The NotebookDocumentFilter namespace provides helper functions to work with
 * [NotebookDocumentFilter](#NotebookDocumentFilter) literals.
 *
 * @since 3.17.0
 */ var NotebookDocumentFilter;
                (function(NotebookDocumentFilter) {
                    var is = function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
                    };
                    NotebookDocumentFilter.is = is;
                })(NotebookDocumentFilter = exports1.NotebookDocumentFilter || (exports1.NotebookDocumentFilter = {}));
                /**
 * The NotebookCellTextDocumentFilter namespace provides helper functions to work with
 * [NotebookCellTextDocumentFilter](#NotebookCellTextDocumentFilter) literals.
 *
 * @since 3.17.0
 */ var NotebookCellTextDocumentFilter;
                (function(NotebookCellTextDocumentFilter) {
                    var is = function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === undefined || Is.string(candidate.language));
                    };
                    NotebookCellTextDocumentFilter.is = is;
                })(NotebookCellTextDocumentFilter = exports1.NotebookCellTextDocumentFilter || (exports1.NotebookCellTextDocumentFilter = {}));
                /**
 * The DocumentSelector namespace provides helper functions to work with
 * [DocumentSelector](#DocumentSelector)s.
 */ var DocumentSelector;
                (function(DocumentSelector) {
                    var is = function is(value) {
                        if (!Array.isArray(value)) {
                            return false;
                        }
                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        try {
                            for(var _iterator = value[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                var elem = _step.value;
                                if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
                                    return false;
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            } finally{
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                        return true;
                    };
                    DocumentSelector.is = is;
                })(DocumentSelector = exports1.DocumentSelector || (exports1.DocumentSelector = {}));
                /**
 * The `client/registerCapability` request is sent from the server to the client to register a new capability
 * handler on the client side.
 */ var RegistrationRequest;
                (function(RegistrationRequest) {
                    RegistrationRequest.method = "client/registerCapability";
                    RegistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    RegistrationRequest.type = new messages_1.ProtocolRequestType(RegistrationRequest.method);
                })(RegistrationRequest = exports1.RegistrationRequest || (exports1.RegistrationRequest = {}));
                /**
 * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
 * handler on the client side.
 */ var UnregistrationRequest;
                (function(UnregistrationRequest) {
                    UnregistrationRequest.method = "client/unregisterCapability";
                    UnregistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    UnregistrationRequest.type = new messages_1.ProtocolRequestType(UnregistrationRequest.method);
                })(UnregistrationRequest = exports1.UnregistrationRequest || (exports1.UnregistrationRequest = {}));
                var ResourceOperationKind;
                (function(ResourceOperationKind) {
                    /**
     * Supports creating new files and folders.
     */ ResourceOperationKind.Create = "create";
                    /**
     * Supports renaming existing files and folders.
     */ ResourceOperationKind.Rename = "rename";
                    /**
     * Supports deleting existing files and folders.
     */ ResourceOperationKind.Delete = "delete";
                })(ResourceOperationKind = exports1.ResourceOperationKind || (exports1.ResourceOperationKind = {}));
                var FailureHandlingKind;
                (function(FailureHandlingKind) {
                    /**
     * Applying the workspace change is simply aborted if one of the changes provided
     * fails. All operations executed before the failing operation stay executed.
     */ FailureHandlingKind.Abort = "abort";
                    /**
     * All operations are executed transactional. That means they either all
     * succeed or no changes at all are applied to the workspace.
     */ FailureHandlingKind.Transactional = "transactional";
                    /**
     * If the workspace edit contains only textual file changes they are executed transactional.
     * If resource changes (create, rename or delete file) are part of the change the failure
     * handling strategy is abort.
     */ FailureHandlingKind.TextOnlyTransactional = "textOnlyTransactional";
                    /**
     * The client tries to undo the operations already executed. But there is no
     * guarantee that this is succeeding.
     */ FailureHandlingKind.Undo = "undo";
                })(FailureHandlingKind = exports1.FailureHandlingKind || (exports1.FailureHandlingKind = {}));
                /**
 * A set of predefined position encoding kinds.
 *
 * @since 3.17.0
 */ var PositionEncodingKind;
                (function(PositionEncodingKind) {
                    /**
     * Character offsets count UTF-8 code units.
     */ PositionEncodingKind.UTF8 = "utf-8";
                    /**
     * Character offsets count UTF-16 code units.
     *
     * This is the default and must always be supported
     * by servers
     */ PositionEncodingKind.UTF16 = "utf-16";
                    /**
     * Character offsets count UTF-32 code units.
     *
     * Implementation note: these are the same as Unicode code points,
     * so this `PositionEncodingKind` may also be used for an
     * encoding-agnostic representation of character offsets.
     */ PositionEncodingKind.UTF32 = "utf-32";
                })(PositionEncodingKind = exports1.PositionEncodingKind || (exports1.PositionEncodingKind = {}));
                /**
 * The StaticRegistrationOptions namespace provides helper functions to work with
 * [StaticRegistrationOptions](#StaticRegistrationOptions) literals.
 */ var StaticRegistrationOptions;
                (function(StaticRegistrationOptions) {
                    var hasId = function hasId(value) {
                        var candidate = value;
                        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
                    };
                    StaticRegistrationOptions.hasId = hasId;
                })(StaticRegistrationOptions = exports1.StaticRegistrationOptions || (exports1.StaticRegistrationOptions = {}));
                /**
 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
 * [TextDocumentRegistrationOptions](#TextDocumentRegistrationOptions) literals.
 */ var TextDocumentRegistrationOptions;
                (function(TextDocumentRegistrationOptions) {
                    var is = function is(value) {
                        var candidate = value;
                        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
                    };
                    TextDocumentRegistrationOptions.is = is;
                })(TextDocumentRegistrationOptions = exports1.TextDocumentRegistrationOptions || (exports1.TextDocumentRegistrationOptions = {}));
                /**
 * The WorkDoneProgressOptions namespace provides helper functions to work with
 * [WorkDoneProgressOptions](#WorkDoneProgressOptions) literals.
 */ var WorkDoneProgressOptions;
                (function(WorkDoneProgressOptions) {
                    var is = function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));
                    };
                    var hasWorkDoneProgress = function hasWorkDoneProgress(value) {
                        var candidate = value;
                        return candidate && Is.boolean(candidate.workDoneProgress);
                    };
                    WorkDoneProgressOptions.is = is;
                    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;
                })(WorkDoneProgressOptions = exports1.WorkDoneProgressOptions || (exports1.WorkDoneProgressOptions = {}));
                /**
 * The initialize request is sent from the client to the server.
 * It is sent once as the request after starting up the server.
 * The requests parameter is of type [InitializeParams](#InitializeParams)
 * the response if of type [InitializeResult](#InitializeResult) of a Thenable that
 * resolves to such.
 */ var InitializeRequest;
                (function(InitializeRequest) {
                    InitializeRequest.method = "initialize";
                    InitializeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InitializeRequest.type = new messages_1.ProtocolRequestType(InitializeRequest.method);
                })(InitializeRequest = exports1.InitializeRequest || (exports1.InitializeRequest = {}));
                /**
 * Known error codes for an `InitializeErrorCodes`;
 */ var InitializeErrorCodes;
                (function(InitializeErrorCodes) {
                    /**
     * If the protocol version provided by the client can't be handled by the server.
     *
     * @deprecated This initialize error got replaced by client capabilities. There is
     * no version handshake in version 3.0x
     */ InitializeErrorCodes.unknownProtocolVersion = 1;
                })(InitializeErrorCodes = exports1.InitializeErrorCodes || (exports1.InitializeErrorCodes = {}));
                /**
 * The initialized notification is sent from the client to the
 * server after the client is fully initialized and the server
 * is allowed to send requests from the server to the client.
 */ var InitializedNotification;
                (function(InitializedNotification) {
                    InitializedNotification.method = "initialized";
                    InitializedNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    InitializedNotification.type = new messages_1.ProtocolNotificationType(InitializedNotification.method);
                })(InitializedNotification = exports1.InitializedNotification || (exports1.InitializedNotification = {}));
                //---- Shutdown Method ----
                /**
 * A shutdown request is sent from the client to the server.
 * It is sent once when the client decides to shutdown the
 * server. The only notification that is sent after a shutdown request
 * is the exit event.
 */ var ShutdownRequest;
                (function(ShutdownRequest) {
                    ShutdownRequest.method = "shutdown";
                    ShutdownRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ShutdownRequest.type = new messages_1.ProtocolRequestType0(ShutdownRequest.method);
                })(ShutdownRequest = exports1.ShutdownRequest || (exports1.ShutdownRequest = {}));
                //---- Exit Notification ----
                /**
 * The exit event is sent from the client to the server to
 * ask the server to exit its process.
 */ var ExitNotification;
                (function(ExitNotification) {
                    ExitNotification.method = "exit";
                    ExitNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    ExitNotification.type = new messages_1.ProtocolNotificationType0(ExitNotification.method);
                })(ExitNotification = exports1.ExitNotification || (exports1.ExitNotification = {}));
                /**
 * The configuration change notification is sent from the client to the server
 * when the client's configuration has changed. The notification contains
 * the changed configuration as defined by the language client.
 */ var DidChangeConfigurationNotification;
                (function(DidChangeConfigurationNotification) {
                    DidChangeConfigurationNotification.method = "workspace/didChangeConfiguration";
                    DidChangeConfigurationNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification.method);
                })(DidChangeConfigurationNotification = exports1.DidChangeConfigurationNotification || (exports1.DidChangeConfigurationNotification = {}));
                //---- Message show and log notifications ----
                /**
 * The message type
 */ var MessageType;
                (function(MessageType) {
                    /**
     * An error message.
     */ MessageType.Error = 1;
                    /**
     * A warning message.
     */ MessageType.Warning = 2;
                    /**
     * An information message.
     */ MessageType.Info = 3;
                    /**
     * A log message.
     */ MessageType.Log = 4;
                })(MessageType = exports1.MessageType || (exports1.MessageType = {}));
                /**
 * The show message notification is sent from a server to a client to ask
 * the client to display a particular message in the user interface.
 */ var ShowMessageNotification;
                (function(ShowMessageNotification) {
                    ShowMessageNotification.method = "window/showMessage";
                    ShowMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    ShowMessageNotification.type = new messages_1.ProtocolNotificationType(ShowMessageNotification.method);
                })(ShowMessageNotification = exports1.ShowMessageNotification || (exports1.ShowMessageNotification = {}));
                /**
 * The show message request is sent from the server to the client to show a message
 * and a set of options actions to the user.
 */ var ShowMessageRequest;
                (function(ShowMessageRequest) {
                    ShowMessageRequest.method = "window/showMessageRequest";
                    ShowMessageRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ShowMessageRequest.type = new messages_1.ProtocolRequestType(ShowMessageRequest.method);
                })(ShowMessageRequest = exports1.ShowMessageRequest || (exports1.ShowMessageRequest = {}));
                /**
 * The log message notification is sent from the server to the client to ask
 * the client to log a particular message.
 */ var LogMessageNotification;
                (function(LogMessageNotification) {
                    LogMessageNotification.method = "window/logMessage";
                    LogMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    LogMessageNotification.type = new messages_1.ProtocolNotificationType(LogMessageNotification.method);
                })(LogMessageNotification = exports1.LogMessageNotification || (exports1.LogMessageNotification = {}));
                //---- Telemetry notification
                /**
 * The telemetry event notification is sent from the server to the client to ask
 * the client to log telemetry data.
 */ var TelemetryEventNotification;
                (function(TelemetryEventNotification) {
                    TelemetryEventNotification.method = "telemetry/event";
                    TelemetryEventNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification.method);
                })(TelemetryEventNotification = exports1.TelemetryEventNotification || (exports1.TelemetryEventNotification = {}));
                /**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */ var TextDocumentSyncKind;
                (function(TextDocumentSyncKind) {
                    /**
     * Documents should not be synced at all.
     */ TextDocumentSyncKind.None = 0;
                    /**
     * Documents are synced by always sending the full content
     * of the document.
     */ TextDocumentSyncKind.Full = 1;
                    /**
     * Documents are synced by sending the full content on open.
     * After that only incremental updates to the document are
     * send.
     */ TextDocumentSyncKind.Incremental = 2;
                })(TextDocumentSyncKind = exports1.TextDocumentSyncKind || (exports1.TextDocumentSyncKind = {}));
                /**
 * The document open notification is sent from the client to the server to signal
 * newly opened text documents. The document's truth is now managed by the client
 * and the server must not try to read the document's truth using the document's
 * uri. Open in this sense means it is managed by the client. It doesn't necessarily
 * mean that its content is presented in an editor. An open notification must not
 * be sent more than once without a corresponding close notification send before.
 * This means open and close notification must be balanced and the max open count
 * is one.
 */ var DidOpenTextDocumentNotification;
                (function(DidOpenTextDocumentNotification) {
                    DidOpenTextDocumentNotification.method = "textDocument/didOpen";
                    DidOpenTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);
                })(DidOpenTextDocumentNotification = exports1.DidOpenTextDocumentNotification || (exports1.DidOpenTextDocumentNotification = {}));
                var TextDocumentContentChangeEvent;
                (function(TextDocumentContentChangeEvent) {
                    var isIncremental = /**
     * Checks whether the information describes a delta event.
     */ function isIncremental(event) {
                        var candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === "string" && candidate.range !== undefined && (candidate.rangeLength === undefined || typeof candidate.rangeLength === "number");
                    };
                    var isFull = /**
     * Checks whether the information describes a full replacement event.
     */ function isFull(event) {
                        var candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === "string" && candidate.range === undefined && candidate.rangeLength === undefined;
                    };
                    TextDocumentContentChangeEvent.isIncremental = isIncremental;
                    TextDocumentContentChangeEvent.isFull = isFull;
                })(TextDocumentContentChangeEvent = exports1.TextDocumentContentChangeEvent || (exports1.TextDocumentContentChangeEvent = {}));
                /**
 * The document change notification is sent from the client to the server to signal
 * changes to a text document.
 */ var DidChangeTextDocumentNotification;
                (function(DidChangeTextDocumentNotification) {
                    DidChangeTextDocumentNotification.method = "textDocument/didChange";
                    DidChangeTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);
                })(DidChangeTextDocumentNotification = exports1.DidChangeTextDocumentNotification || (exports1.DidChangeTextDocumentNotification = {}));
                /**
 * The document close notification is sent from the client to the server when
 * the document got closed in the client. The document's truth now exists where
 * the document's uri points to (e.g. if the document's uri is a file uri the
 * truth now exists on disk). As with the open notification the close notification
 * is about managing the document's content. Receiving a close notification
 * doesn't mean that the document was open in an editor before. A close
 * notification requires a previous open notification to be sent.
 */ var DidCloseTextDocumentNotification;
                (function(DidCloseTextDocumentNotification) {
                    DidCloseTextDocumentNotification.method = "textDocument/didClose";
                    DidCloseTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);
                })(DidCloseTextDocumentNotification = exports1.DidCloseTextDocumentNotification || (exports1.DidCloseTextDocumentNotification = {}));
                /**
 * The document save notification is sent from the client to the server when
 * the document got saved in the client.
 */ var DidSaveTextDocumentNotification;
                (function(DidSaveTextDocumentNotification) {
                    DidSaveTextDocumentNotification.method = "textDocument/didSave";
                    DidSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);
                })(DidSaveTextDocumentNotification = exports1.DidSaveTextDocumentNotification || (exports1.DidSaveTextDocumentNotification = {}));
                /**
 * Represents reasons why a text document is saved.
 */ var TextDocumentSaveReason;
                (function(TextDocumentSaveReason) {
                    /**
     * Manually triggered, e.g. by the user pressing save, by starting debugging,
     * or by an API call.
     */ TextDocumentSaveReason.Manual = 1;
                    /**
     * Automatic after a delay.
     */ TextDocumentSaveReason.AfterDelay = 2;
                    /**
     * When the editor lost focus.
     */ TextDocumentSaveReason.FocusOut = 3;
                })(TextDocumentSaveReason = exports1.TextDocumentSaveReason || (exports1.TextDocumentSaveReason = {}));
                /**
 * A document will save notification is sent from the client to the server before
 * the document is actually saved.
 */ var WillSaveTextDocumentNotification;
                (function(WillSaveTextDocumentNotification) {
                    WillSaveTextDocumentNotification.method = "textDocument/willSave";
                    WillSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);
                })(WillSaveTextDocumentNotification = exports1.WillSaveTextDocumentNotification || (exports1.WillSaveTextDocumentNotification = {}));
                /**
 * A document will save request is sent from the client to the server before
 * the document is actually saved. The request can return an array of TextEdits
 * which will be applied to the text document before it is saved. Please note that
 * clients might drop results if computing the text edits took too long or if a
 * server constantly fails on this request. This is done to keep the save fast and
 * reliable.
 */ var WillSaveTextDocumentWaitUntilRequest;
                (function(WillSaveTextDocumentWaitUntilRequest) {
                    WillSaveTextDocumentWaitUntilRequest.method = "textDocument/willSaveWaitUntil";
                    WillSaveTextDocumentWaitUntilRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);
                })(WillSaveTextDocumentWaitUntilRequest = exports1.WillSaveTextDocumentWaitUntilRequest || (exports1.WillSaveTextDocumentWaitUntilRequest = {}));
                /**
 * The watched files notification is sent from the client to the server when
 * the client detects changes to file watched by the language client.
 */ var DidChangeWatchedFilesNotification;
                (function(DidChangeWatchedFilesNotification) {
                    DidChangeWatchedFilesNotification.method = "workspace/didChangeWatchedFiles";
                    DidChangeWatchedFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification.method);
                })(DidChangeWatchedFilesNotification = exports1.DidChangeWatchedFilesNotification || (exports1.DidChangeWatchedFilesNotification = {}));
                /**
 * The file event type
 */ var FileChangeType;
                (function(FileChangeType) {
                    /**
     * The file got created.
     */ FileChangeType.Created = 1;
                    /**
     * The file got changed.
     */ FileChangeType.Changed = 2;
                    /**
     * The file got deleted.
     */ FileChangeType.Deleted = 3;
                })(FileChangeType = exports1.FileChangeType || (exports1.FileChangeType = {}));
                var RelativePattern;
                (function(RelativePattern) {
                    var is = function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
                    };
                    RelativePattern.is = is;
                })(RelativePattern = exports1.RelativePattern || (exports1.RelativePattern = {}));
                var WatchKind;
                (function(WatchKind) {
                    /**
     * Interested in create events.
     */ WatchKind.Create = 1;
                    /**
     * Interested in change events
     */ WatchKind.Change = 2;
                    /**
     * Interested in delete events
     */ WatchKind.Delete = 4;
                })(WatchKind = exports1.WatchKind || (exports1.WatchKind = {}));
                /**
 * Diagnostics notification are sent from the server to the client to signal
 * results of validation runs.
 */ var PublishDiagnosticsNotification;
                (function(PublishDiagnosticsNotification) {
                    PublishDiagnosticsNotification.method = "textDocument/publishDiagnostics";
                    PublishDiagnosticsNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification.method);
                })(PublishDiagnosticsNotification = exports1.PublishDiagnosticsNotification || (exports1.PublishDiagnosticsNotification = {}));
                /**
 * How a completion was triggered
 */ var CompletionTriggerKind;
                (function(CompletionTriggerKind) {
                    /**
     * Completion was triggered by typing an identifier (24x7 code
     * complete), manual invocation (e.g Ctrl+Space) or via API.
     */ CompletionTriggerKind.Invoked = 1;
                    /**
     * Completion was triggered by a trigger character specified by
     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
     */ CompletionTriggerKind.TriggerCharacter = 2;
                    /**
     * Completion was re-triggered as current completion list is incomplete
     */ CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
                })(CompletionTriggerKind = exports1.CompletionTriggerKind || (exports1.CompletionTriggerKind = {}));
                /**
 * Request to request completion at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response
 * is of type [CompletionItem[]](#CompletionItem) or [CompletionList](#CompletionList)
 * or a Thenable that resolves to such.
 *
 * The request can delay the computation of the [`detail`](#CompletionItem.detail)
 * and [`documentation`](#CompletionItem.documentation) properties to the `completionItem/resolve`
 * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
 * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
 */ var CompletionRequest;
                (function(CompletionRequest) {
                    CompletionRequest.method = "textDocument/completion";
                    CompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);
                })(CompletionRequest = exports1.CompletionRequest || (exports1.CompletionRequest = {}));
                /**
 * Request to resolve additional information for a given completion item.The request's
 * parameter is of type [CompletionItem](#CompletionItem) the response
 * is of type [CompletionItem](#CompletionItem) or a Thenable that resolves to such.
 */ var CompletionResolveRequest;
                (function(CompletionResolveRequest) {
                    CompletionResolveRequest.method = "completionItem/resolve";
                    CompletionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);
                })(CompletionResolveRequest = exports1.CompletionResolveRequest || (exports1.CompletionResolveRequest = {}));
                /**
 * Request to request hover information at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response is of
 * type [Hover](#Hover) or a Thenable that resolves to such.
 */ var HoverRequest;
                (function(HoverRequest) {
                    HoverRequest.method = "textDocument/hover";
                    HoverRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);
                })(HoverRequest = exports1.HoverRequest || (exports1.HoverRequest = {}));
                /**
 * How a signature help was triggered.
 *
 * @since 3.15.0
 */ var SignatureHelpTriggerKind;
                (function(SignatureHelpTriggerKind) {
                    /**
     * Signature help was invoked manually by the user or by a command.
     */ SignatureHelpTriggerKind.Invoked = 1;
                    /**
     * Signature help was triggered by a trigger character.
     */ SignatureHelpTriggerKind.TriggerCharacter = 2;
                    /**
     * Signature help was triggered by the cursor moving or by the document content changing.
     */ SignatureHelpTriggerKind.ContentChange = 3;
                })(SignatureHelpTriggerKind = exports1.SignatureHelpTriggerKind || (exports1.SignatureHelpTriggerKind = {}));
                var SignatureHelpRequest;
                (function(SignatureHelpRequest) {
                    SignatureHelpRequest.method = "textDocument/signatureHelp";
                    SignatureHelpRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);
                })(SignatureHelpRequest = exports1.SignatureHelpRequest || (exports1.SignatureHelpRequest = {}));
                /**
 * A request to resolve the definition location of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the response is of either type [Definition](#Definition)
 * or a typed array of [DefinitionLink](#DefinitionLink) or a Thenable that resolves
 * to such.
 */ var DefinitionRequest;
                (function(DefinitionRequest) {
                    DefinitionRequest.method = "textDocument/definition";
                    DefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);
                })(DefinitionRequest = exports1.DefinitionRequest || (exports1.DefinitionRequest = {}));
                /**
 * A request to resolve project-wide references for the symbol denoted
 * by the given text document position. The request's parameter is of
 * type [ReferenceParams](#ReferenceParams) the response is of type
 * [Location[]](#Location) or a Thenable that resolves to such.
 */ var ReferencesRequest;
                (function(ReferencesRequest) {
                    ReferencesRequest.method = "textDocument/references";
                    ReferencesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);
                })(ReferencesRequest = exports1.ReferencesRequest || (exports1.ReferencesRequest = {}));
                /**
 * Request to resolve a [DocumentHighlight](#DocumentHighlight) for a given
 * text document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the request response is of type [DocumentHighlight[]]
 * (#DocumentHighlight) or a Thenable that resolves to such.
 */ var DocumentHighlightRequest;
                (function(DocumentHighlightRequest) {
                    DocumentHighlightRequest.method = "textDocument/documentHighlight";
                    DocumentHighlightRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);
                })(DocumentHighlightRequest = exports1.DocumentHighlightRequest || (exports1.DocumentHighlightRequest = {}));
                /**
 * A request to list all symbols found in a given text document. The request's
 * parameter is of type [TextDocumentIdentifier](#TextDocumentIdentifier) the
 * response is of type [SymbolInformation[]](#SymbolInformation) or a Thenable
 * that resolves to such.
 */ var DocumentSymbolRequest;
                (function(DocumentSymbolRequest) {
                    DocumentSymbolRequest.method = "textDocument/documentSymbol";
                    DocumentSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);
                })(DocumentSymbolRequest = exports1.DocumentSymbolRequest || (exports1.DocumentSymbolRequest = {}));
                /**
 * A request to provide commands for the given text document and range.
 */ var CodeActionRequest;
                (function(CodeActionRequest) {
                    CodeActionRequest.method = "textDocument/codeAction";
                    CodeActionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);
                })(CodeActionRequest = exports1.CodeActionRequest || (exports1.CodeActionRequest = {}));
                /**
 * Request to resolve additional information for a given code action.The request's
 * parameter is of type [CodeAction](#CodeAction) the response
 * is of type [CodeAction](#CodeAction) or a Thenable that resolves to such.
 */ var CodeActionResolveRequest;
                (function(CodeActionResolveRequest) {
                    CodeActionResolveRequest.method = "codeAction/resolve";
                    CodeActionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeActionResolveRequest.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest.method);
                })(CodeActionResolveRequest = exports1.CodeActionResolveRequest || (exports1.CodeActionResolveRequest = {}));
                /**
 * A request to list project-wide symbols matching the query string given
 * by the [WorkspaceSymbolParams](#WorkspaceSymbolParams). The response is
 * of type [SymbolInformation[]](#SymbolInformation) or a Thenable that
 * resolves to such.
 *
 * @since 3.17.0 - support for WorkspaceSymbol in the returned data. Clients
 *  need to advertise support for WorkspaceSymbols via the client capability
 *  `workspace.symbol.resolveSupport`.
 *
 */ var WorkspaceSymbolRequest;
                (function(WorkspaceSymbolRequest) {
                    WorkspaceSymbolRequest.method = "workspace/symbol";
                    WorkspaceSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);
                })(WorkspaceSymbolRequest = exports1.WorkspaceSymbolRequest || (exports1.WorkspaceSymbolRequest = {}));
                /**
 * A request to resolve the range inside the workspace
 * symbol's location.
 *
 * @since 3.17.0
 */ var WorkspaceSymbolResolveRequest;
                (function(WorkspaceSymbolResolveRequest) {
                    WorkspaceSymbolResolveRequest.method = "workspaceSymbol/resolve";
                    WorkspaceSymbolResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkspaceSymbolResolveRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest.method);
                })(WorkspaceSymbolResolveRequest = exports1.WorkspaceSymbolResolveRequest || (exports1.WorkspaceSymbolResolveRequest = {}));
                /**
 * A request to provide code lens for the given text document.
 */ var CodeLensRequest;
                (function(CodeLensRequest) {
                    CodeLensRequest.method = "textDocument/codeLens";
                    CodeLensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeLensRequest.type = new messages_1.ProtocolRequestType(CodeLensRequest.method);
                })(CodeLensRequest = exports1.CodeLensRequest || (exports1.CodeLensRequest = {}));
                /**
 * A request to resolve a command for a given code lens.
 */ var CodeLensResolveRequest;
                (function(CodeLensResolveRequest) {
                    CodeLensResolveRequest.method = "codeLens/resolve";
                    CodeLensResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest.method);
                })(CodeLensResolveRequest = exports1.CodeLensResolveRequest || (exports1.CodeLensResolveRequest = {}));
                /**
 * A request to refresh all code actions
 *
 * @since 3.16.0
 */ var CodeLensRefreshRequest;
                (function(CodeLensRefreshRequest) {
                    CodeLensRefreshRequest.method = "workspace/codeLens/refresh";
                    CodeLensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    CodeLensRefreshRequest.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest.method);
                })(CodeLensRefreshRequest = exports1.CodeLensRefreshRequest || (exports1.CodeLensRefreshRequest = {}));
                /**
 * A request to provide document links
 */ var DocumentLinkRequest;
                (function(DocumentLinkRequest) {
                    DocumentLinkRequest.method = "textDocument/documentLink";
                    DocumentLinkRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);
                })(DocumentLinkRequest = exports1.DocumentLinkRequest || (exports1.DocumentLinkRequest = {}));
                /**
 * Request to resolve additional information for a given document link. The request's
 * parameter is of type [DocumentLink](#DocumentLink) the response
 * is of type [DocumentLink](#DocumentLink) or a Thenable that resolves to such.
 */ var DocumentLinkResolveRequest;
                (function(DocumentLinkResolveRequest) {
                    DocumentLinkResolveRequest.method = "documentLink/resolve";
                    DocumentLinkResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest.method);
                })(DocumentLinkResolveRequest = exports1.DocumentLinkResolveRequest || (exports1.DocumentLinkResolveRequest = {}));
                /**
 * A request to to format a whole document.
 */ var DocumentFormattingRequest;
                (function(DocumentFormattingRequest) {
                    DocumentFormattingRequest.method = "textDocument/formatting";
                    DocumentFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);
                })(DocumentFormattingRequest = exports1.DocumentFormattingRequest || (exports1.DocumentFormattingRequest = {}));
                /**
 * A request to to format a range in a document.
 */ var DocumentRangeFormattingRequest;
                (function(DocumentRangeFormattingRequest) {
                    DocumentRangeFormattingRequest.method = "textDocument/rangeFormatting";
                    DocumentRangeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);
                })(DocumentRangeFormattingRequest = exports1.DocumentRangeFormattingRequest || (exports1.DocumentRangeFormattingRequest = {}));
                /**
 * A request to format a document on type.
 */ var DocumentOnTypeFormattingRequest;
                (function(DocumentOnTypeFormattingRequest) {
                    DocumentOnTypeFormattingRequest.method = "textDocument/onTypeFormatting";
                    DocumentOnTypeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);
                })(DocumentOnTypeFormattingRequest = exports1.DocumentOnTypeFormattingRequest || (exports1.DocumentOnTypeFormattingRequest = {}));
                //---- Rename ----------------------------------------------
                var PrepareSupportDefaultBehavior;
                (function(PrepareSupportDefaultBehavior) {
                    /**
     * The client's default behavior is to select the identifier
     * according the to language's syntax rule.
     */ PrepareSupportDefaultBehavior.Identifier = 1;
                })(PrepareSupportDefaultBehavior = exports1.PrepareSupportDefaultBehavior || (exports1.PrepareSupportDefaultBehavior = {}));
                /**
 * A request to rename a symbol.
 */ var RenameRequest;
                (function(RenameRequest) {
                    RenameRequest.method = "textDocument/rename";
                    RenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);
                })(RenameRequest = exports1.RenameRequest || (exports1.RenameRequest = {}));
                /**
 * A request to test and perform the setup necessary for a rename.
 *
 * @since 3.16 - support for default behavior
 */ var PrepareRenameRequest;
                (function(PrepareRenameRequest) {
                    PrepareRenameRequest.method = "textDocument/prepareRename";
                    PrepareRenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);
                })(PrepareRenameRequest = exports1.PrepareRenameRequest || (exports1.PrepareRenameRequest = {}));
                /**
 * A request send from the client to the server to execute a command. The request might return
 * a workspace edit which the client will apply to the workspace.
 */ var ExecuteCommandRequest;
                (function(ExecuteCommandRequest) {
                    ExecuteCommandRequest.method = "workspace/executeCommand";
                    ExecuteCommandRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest.method);
                })(ExecuteCommandRequest = exports1.ExecuteCommandRequest || (exports1.ExecuteCommandRequest = {}));
                /**
 * A request sent from the server to the client to modified certain resources.
 */ var ApplyWorkspaceEditRequest;
                (function(ApplyWorkspaceEditRequest) {
                    ApplyWorkspaceEditRequest.method = "workspace/applyEdit";
                    ApplyWorkspaceEditRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
                })(ApplyWorkspaceEditRequest = exports1.ApplyWorkspaceEditRequest || (exports1.ApplyWorkspaceEditRequest = {}));
            //# sourceMappingURL=protocol.js.map
            /***/ },
            /***/ 527: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_2082112__) {
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LinkedEditingRangeRequest = void 0;
                var messages_1 = __nested_webpack_require_2082112__(8599);
                /**
 * A request to provide ranges that can be edited together.
 *
 * @since 3.16.0
 */ var LinkedEditingRangeRequest;
                (function(LinkedEditingRangeRequest) {
                    LinkedEditingRangeRequest.method = "textDocument/linkedEditingRange";
                    LinkedEditingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    LinkedEditingRangeRequest.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest.method);
                })(LinkedEditingRangeRequest = exports1.LinkedEditingRangeRequest || (exports1.LinkedEditingRangeRequest = {}));
            //# sourceMappingURL=protocol.linkedEditingRange.js.map
            /***/ },
            /***/ 1964: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_2083558__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.MonikerRequest = exports1.MonikerKind = exports1.UniquenessLevel = void 0;
                var messages_1 = __nested_webpack_require_2083558__(8599);
                /**
 * Moniker uniqueness level to define scope of the moniker.
 *
 * @since 3.16.0
 */ var UniquenessLevel;
                (function(UniquenessLevel) {
                    /**
     * The moniker is only unique inside a document
     */ UniquenessLevel.document = "document";
                    /**
     * The moniker is unique inside a project for which a dump got created
     */ UniquenessLevel.project = "project";
                    /**
     * The moniker is unique inside the group to which a project belongs
     */ UniquenessLevel.group = "group";
                    /**
     * The moniker is unique inside the moniker scheme.
     */ UniquenessLevel.scheme = "scheme";
                    /**
     * The moniker is globally unique
     */ UniquenessLevel.global = "global";
                })(UniquenessLevel = exports1.UniquenessLevel || (exports1.UniquenessLevel = {}));
                /**
 * The moniker kind.
 *
 * @since 3.16.0
 */ var MonikerKind;
                (function(MonikerKind) {
                    /**
     * The moniker represent a symbol that is imported into a project
     */ MonikerKind.$import = "import";
                    /**
     * The moniker represents a symbol that is exported from a project
     */ MonikerKind.$export = "export";
                    /**
     * The moniker represents a symbol that is local to a project (e.g. a local
     * variable of a function, a class not visible outside the project, ...)
     */ MonikerKind.local = "local";
                })(MonikerKind = exports1.MonikerKind || (exports1.MonikerKind = {}));
                /**
 * A request to get the moniker of a symbol at a given text document position.
 * The request parameter is of type [TextDocumentPositionParams](#TextDocumentPositionParams).
 * The response is of type [Moniker[]](#Moniker[]) or `null`.
 */ var MonikerRequest;
                (function(MonikerRequest) {
                    MonikerRequest.method = "textDocument/moniker";
                    MonikerRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    MonikerRequest.type = new messages_1.ProtocolRequestType(MonikerRequest.method);
                })(MonikerRequest = exports1.MonikerRequest || (exports1.MonikerRequest = {}));
            //# sourceMappingURL=protocol.moniker.js.map
            /***/ },
            /***/ 4460: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_2086675__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DidCloseNotebookDocumentNotification = exports1.DidSaveNotebookDocumentNotification = exports1.DidChangeNotebookDocumentNotification = exports1.NotebookCellArrayChange = exports1.DidOpenNotebookDocumentNotification = exports1.NotebookDocumentSyncRegistrationType = exports1.NotebookDocument = exports1.NotebookCell = exports1.ExecutionSummary = exports1.NotebookCellKind = void 0;
                var vscode_languageserver_types_1 = __nested_webpack_require_2086675__(4767);
                var Is = __nested_webpack_require_2086675__(2523);
                var messages_1 = __nested_webpack_require_2086675__(8599);
                /**
 * A notebook cell kind.
 *
 * @since 3.17.0
 */ var NotebookCellKind;
                (function(NotebookCellKind) {
                    var is = function is(value) {
                        return value === 1 || value === 2;
                    };
                    /**
     * A markup-cell is formatted source that is used for display.
     */ NotebookCellKind.Markup = 1;
                    /**
     * A code-cell is source code.
     */ NotebookCellKind.Code = 2;
                    NotebookCellKind.is = is;
                })(NotebookCellKind = exports1.NotebookCellKind || (exports1.NotebookCellKind = {}));
                var ExecutionSummary;
                (function(ExecutionSummary) {
                    var create = function create(executionOrder, success) {
                        var result = {
                            executionOrder: executionOrder
                        };
                        if (success === true || success === false) {
                            result.success = success;
                        }
                        return result;
                    };
                    var is = function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === undefined || Is.boolean(candidate.success));
                    };
                    var equals = function equals(one, other) {
                        if (one === other) {
                            return true;
                        }
                        if (one === null || one === undefined || other === null || other === undefined) {
                            return false;
                        }
                        return one.executionOrder === other.executionOrder && one.success === other.success;
                    };
                    ExecutionSummary.create = create;
                    ExecutionSummary.is = is;
                    ExecutionSummary.equals = equals;
                })(ExecutionSummary = exports1.ExecutionSummary || (exports1.ExecutionSummary = {}));
                var NotebookCell;
                (function(NotebookCell) {
                    var create = function create(kind, document1) {
                        return {
                            kind: kind,
                            document: document1
                        };
                    };
                    var is = function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === undefined || Is.objectLiteral(candidate.metadata));
                    };
                    var diff = function diff(one, two) {
                        var result = new Set();
                        if (one.document !== two.document) {
                            result.add("document");
                        }
                        if (one.kind !== two.kind) {
                            result.add("kind");
                        }
                        if (one.executionSummary !== two.executionSummary) {
                            result.add("executionSummary");
                        }
                        if ((one.metadata !== undefined || two.metadata !== undefined) && !equalsMetadata(one.metadata, two.metadata)) {
                            result.add("metadata");
                        }
                        if ((one.executionSummary !== undefined || two.executionSummary !== undefined) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
                            result.add("executionSummary");
                        }
                        return result;
                    };
                    NotebookCell.create = create;
                    NotebookCell.is = is;
                    NotebookCell.diff = diff;
                    function equalsMetadata(one, other) {
                        if (one === other) {
                            return true;
                        }
                        if (one === null || one === undefined || other === null || other === undefined) {
                            return false;
                        }
                        if ((typeof one === "undefined" ? "undefined" : _type_of(one)) !== (typeof other === "undefined" ? "undefined" : _type_of(other))) {
                            return false;
                        }
                        if (typeof one !== "object") {
                            return false;
                        }
                        var oneArray = Array.isArray(one);
                        var otherArray = Array.isArray(other);
                        if (oneArray !== otherArray) {
                            return false;
                        }
                        if (oneArray && otherArray) {
                            if (one.length !== other.length) {
                                return false;
                            }
                            for(var i = 0; i < one.length; i++){
                                if (!equalsMetadata(one[i], other[i])) {
                                    return false;
                                }
                            }
                        }
                        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
                            var oneKeys = Object.keys(one);
                            var otherKeys = Object.keys(other);
                            if (oneKeys.length !== otherKeys.length) {
                                return false;
                            }
                            oneKeys.sort();
                            otherKeys.sort();
                            if (!equalsMetadata(oneKeys, otherKeys)) {
                                return false;
                            }
                            for(var i1 = 0; i1 < oneKeys.length; i1++){
                                var prop = oneKeys[i1];
                                if (!equalsMetadata(one[prop], other[prop])) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                })(NotebookCell = exports1.NotebookCell || (exports1.NotebookCell = {}));
                var NotebookDocument;
                (function(NotebookDocument) {
                    var create = function create(uri, notebookType, version, cells) {
                        return {
                            uri: uri,
                            notebookType: notebookType,
                            version: version,
                            cells: cells
                        };
                    };
                    var is = function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
                    };
                    NotebookDocument.create = create;
                    NotebookDocument.is = is;
                })(NotebookDocument = exports1.NotebookDocument || (exports1.NotebookDocument = {}));
                var NotebookDocumentSyncRegistrationType;
                (function(NotebookDocumentSyncRegistrationType) {
                    NotebookDocumentSyncRegistrationType.method = "notebookDocument/sync";
                    NotebookDocumentSyncRegistrationType.messageDirection = messages_1.MessageDirection.clientToServer;
                    NotebookDocumentSyncRegistrationType.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType.method);
                })(NotebookDocumentSyncRegistrationType = exports1.NotebookDocumentSyncRegistrationType || (exports1.NotebookDocumentSyncRegistrationType = {}));
                /**
 * A notification sent when a notebook opens.
 *
 * @since 3.17.0
 */ var DidOpenNotebookDocumentNotification;
                (function(DidOpenNotebookDocumentNotification) {
                    DidOpenNotebookDocumentNotification.method = "notebookDocument/didOpen";
                    DidOpenNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidOpenNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification.method);
                    DidOpenNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidOpenNotebookDocumentNotification = exports1.DidOpenNotebookDocumentNotification || (exports1.DidOpenNotebookDocumentNotification = {}));
                var NotebookCellArrayChange;
                (function(NotebookCellArrayChange) {
                    var is = function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === undefined || Is.typedArray(candidate.cells, NotebookCell.is));
                    };
                    var create = function create(start, deleteCount, cells) {
                        var result = {
                            start: start,
                            deleteCount: deleteCount
                        };
                        if (cells !== undefined) {
                            result.cells = cells;
                        }
                        return result;
                    };
                    NotebookCellArrayChange.is = is;
                    NotebookCellArrayChange.create = create;
                })(NotebookCellArrayChange = exports1.NotebookCellArrayChange || (exports1.NotebookCellArrayChange = {}));
                var DidChangeNotebookDocumentNotification;
                (function(DidChangeNotebookDocumentNotification) {
                    DidChangeNotebookDocumentNotification.method = "notebookDocument/didChange";
                    DidChangeNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification.method);
                    DidChangeNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidChangeNotebookDocumentNotification = exports1.DidChangeNotebookDocumentNotification || (exports1.DidChangeNotebookDocumentNotification = {}));
                /**
 * A notification sent when a notebook document is saved.
 *
 * @since 3.17.0
 */ var DidSaveNotebookDocumentNotification;
                (function(DidSaveNotebookDocumentNotification) {
                    DidSaveNotebookDocumentNotification.method = "notebookDocument/didSave";
                    DidSaveNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidSaveNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification.method);
                    DidSaveNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidSaveNotebookDocumentNotification = exports1.DidSaveNotebookDocumentNotification || (exports1.DidSaveNotebookDocumentNotification = {}));
                /**
 * A notification sent when a notebook closes.
 *
 * @since 3.17.0
 */ var DidCloseNotebookDocumentNotification;
                (function(DidCloseNotebookDocumentNotification) {
                    DidCloseNotebookDocumentNotification.method = "notebookDocument/didClose";
                    DidCloseNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidCloseNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification.method);
                    DidCloseNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidCloseNotebookDocumentNotification = exports1.DidCloseNotebookDocumentNotification || (exports1.DidCloseNotebookDocumentNotification = {}));
            //# sourceMappingURL=protocol.notebook.js.map
            /***/ },
            /***/ 7895: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_2100598__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WorkDoneProgressCancelNotification = exports1.WorkDoneProgressCreateRequest = exports1.WorkDoneProgress = void 0;
                var vscode_jsonrpc_1 = __nested_webpack_require_2100598__(5953);
                var messages_1 = __nested_webpack_require_2100598__(8599);
                var WorkDoneProgress;
                (function(WorkDoneProgress) {
                    var is = function is(value) {
                        return value === WorkDoneProgress.type;
                    };
                    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();
                    WorkDoneProgress.is = is;
                })(WorkDoneProgress = exports1.WorkDoneProgress || (exports1.WorkDoneProgress = {}));
                /**
 * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress
 * reporting from the server.
 */ var WorkDoneProgressCreateRequest;
                (function(WorkDoneProgressCreateRequest) {
                    WorkDoneProgressCreateRequest.method = "window/workDoneProgress/create";
                    WorkDoneProgressCreateRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest.method);
                })(WorkDoneProgressCreateRequest = exports1.WorkDoneProgressCreateRequest || (exports1.WorkDoneProgressCreateRequest = {}));
                /**
 * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
 * initiated on the server side.
 */ var WorkDoneProgressCancelNotification;
                (function(WorkDoneProgressCancelNotification) {
                    WorkDoneProgressCancelNotification.method = "window/workDoneProgress/cancel";
                    WorkDoneProgressCancelNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification.method);
                })(WorkDoneProgressCancelNotification = exports1.WorkDoneProgressCancelNotification || (exports1.WorkDoneProgressCancelNotification = {}));
            //# sourceMappingURL=protocol.progress.js.map
            /***/ },
            /***/ 2392: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_2103510__) {
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.SelectionRangeRequest = void 0;
                var messages_1 = __nested_webpack_require_2103510__(8599);
                /**
 * A request to provide selection ranges in a document. The request's
 * parameter is of type [SelectionRangeParams](#SelectionRangeParams), the
 * response is of type [SelectionRange[]](#SelectionRange[]) or a Thenable
 * that resolves to such.
 */ var SelectionRangeRequest;
                (function(SelectionRangeRequest) {
                    SelectionRangeRequest.method = "textDocument/selectionRange";
                    SelectionRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);
                })(SelectionRangeRequest = exports1.SelectionRangeRequest || (exports1.SelectionRangeRequest = {}));
            //# sourceMappingURL=protocol.selectionRange.js.map
            /***/ },
            /***/ 8489: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_2105074__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.SemanticTokensRefreshRequest = exports1.SemanticTokensRangeRequest = exports1.SemanticTokensDeltaRequest = exports1.SemanticTokensRequest = exports1.SemanticTokensRegistrationType = exports1.TokenFormat = void 0;
                var messages_1 = __nested_webpack_require_2105074__(8599);
                //------- 'textDocument/semanticTokens' -----
                var TokenFormat;
                (function(TokenFormat) {
                    TokenFormat.Relative = "relative";
                })(TokenFormat = exports1.TokenFormat || (exports1.TokenFormat = {}));
                var SemanticTokensRegistrationType;
                (function(SemanticTokensRegistrationType) {
                    SemanticTokensRegistrationType.method = "textDocument/semanticTokens";
                    SemanticTokensRegistrationType.type = new messages_1.RegistrationType(SemanticTokensRegistrationType.method);
                })(SemanticTokensRegistrationType = exports1.SemanticTokensRegistrationType || (exports1.SemanticTokensRegistrationType = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensRequest;
                (function(SemanticTokensRequest) {
                    SemanticTokensRequest.method = "textDocument/semanticTokens/full";
                    SemanticTokensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);
                    SemanticTokensRequest.registrationMethod = SemanticTokensRegistrationType.method;
                })(SemanticTokensRequest = exports1.SemanticTokensRequest || (exports1.SemanticTokensRequest = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensDeltaRequest;
                (function(SemanticTokensDeltaRequest) {
                    SemanticTokensDeltaRequest.method = "textDocument/semanticTokens/full/delta";
                    SemanticTokensDeltaRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensDeltaRequest.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest.method);
                    SemanticTokensDeltaRequest.registrationMethod = SemanticTokensRegistrationType.method;
                })(SemanticTokensDeltaRequest = exports1.SemanticTokensDeltaRequest || (exports1.SemanticTokensDeltaRequest = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensRangeRequest;
                (function(SemanticTokensRangeRequest) {
                    SemanticTokensRangeRequest.method = "textDocument/semanticTokens/range";
                    SemanticTokensRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);
                    SemanticTokensRangeRequest.registrationMethod = SemanticTokensRegistrationType.method;
                })(SemanticTokensRangeRequest = exports1.SemanticTokensRangeRequest || (exports1.SemanticTokensRangeRequest = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensRefreshRequest;
                (function(SemanticTokensRefreshRequest) {
                    SemanticTokensRefreshRequest.method = "workspace/semanticTokens/refresh";
                    SemanticTokensRefreshRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensRefreshRequest.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest.method);
                })(SemanticTokensRefreshRequest = exports1.SemanticTokensRefreshRequest || (exports1.SemanticTokensRefreshRequest = {}));
            //# sourceMappingURL=protocol.semanticTokens.js.map
            /***/ },
            /***/ 1541: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_2109454__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ShowDocumentRequest = void 0;
                var messages_1 = __nested_webpack_require_2109454__(8599);
                /**
 * A request to show a document. This request might open an
 * external program depending on the value of the URI to open.
 * For example a request to open `https://code.visualstudio.com/`
 * will very likely open the URI in a WEB browser.
 *
 * @since 3.16.0
*/ var ShowDocumentRequest;
                (function(ShowDocumentRequest) {
                    ShowDocumentRequest.method = "window/showDocument";
                    ShowDocumentRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ShowDocumentRequest.type = new messages_1.ProtocolRequestType(ShowDocumentRequest.method);
                })(ShowDocumentRequest = exports1.ShowDocumentRequest || (exports1.ShowDocumentRequest = {}));
            //# sourceMappingURL=protocol.showDocument.js.map
            /***/ },
            /***/ 8642: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_2110999__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.TypeDefinitionRequest = void 0;
                var messages_1 = __nested_webpack_require_2110999__(8599);
                // @ts-ignore: to avoid inlining LocatioLink as dynamic import
                var __noDynamicImport;
                /**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */ var TypeDefinitionRequest;
                (function(TypeDefinitionRequest) {
                    TypeDefinitionRequest.method = "textDocument/typeDefinition";
                    TypeDefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);
                })(TypeDefinitionRequest = exports1.TypeDefinitionRequest || (exports1.TypeDefinitionRequest = {}));
            //# sourceMappingURL=protocol.typeDefinition.js.map
            /***/ },
            /***/ 5318: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_2112723__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.TypeHierarchySubtypesRequest = exports1.TypeHierarchySupertypesRequest = exports1.TypeHierarchyPrepareRequest = void 0;
                var messages_1 = __nested_webpack_require_2112723__(8599);
                /**
 * A request to result a `TypeHierarchyItem` in a document at a given position.
 * Can be used as an input to a subtypes or supertypes type hierarchy.
 *
 * @since 3.17.0
 */ var TypeHierarchyPrepareRequest;
                (function(TypeHierarchyPrepareRequest) {
                    TypeHierarchyPrepareRequest.method = "textDocument/prepareTypeHierarchy";
                    TypeHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest.method);
                })(TypeHierarchyPrepareRequest = exports1.TypeHierarchyPrepareRequest || (exports1.TypeHierarchyPrepareRequest = {}));
                /**
 * A request to resolve the supertypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */ var TypeHierarchySupertypesRequest;
                (function(TypeHierarchySupertypesRequest) {
                    TypeHierarchySupertypesRequest.method = "typeHierarchy/supertypes";
                    TypeHierarchySupertypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeHierarchySupertypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest.method);
                })(TypeHierarchySupertypesRequest = exports1.TypeHierarchySupertypesRequest || (exports1.TypeHierarchySupertypesRequest = {}));
                /**
 * A request to resolve the subtypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */ var TypeHierarchySubtypesRequest;
                (function(TypeHierarchySubtypesRequest) {
                    TypeHierarchySubtypesRequest.method = "typeHierarchy/subtypes";
                    TypeHierarchySubtypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeHierarchySubtypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest.method);
                })(TypeHierarchySubtypesRequest = exports1.TypeHierarchySubtypesRequest || (exports1.TypeHierarchySubtypesRequest = {}));
            //# sourceMappingURL=protocol.typeHierarchy.js.map
            /***/ },
            /***/ 3402: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_2115725__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DidChangeWorkspaceFoldersNotification = exports1.WorkspaceFoldersRequest = void 0;
                var messages_1 = __nested_webpack_require_2115725__(8599);
                /**
 * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
 */ var WorkspaceFoldersRequest;
                (function(WorkspaceFoldersRequest) {
                    WorkspaceFoldersRequest.method = "workspace/workspaceFolders";
                    WorkspaceFoldersRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest.method);
                })(WorkspaceFoldersRequest = exports1.WorkspaceFoldersRequest || (exports1.WorkspaceFoldersRequest = {}));
                /**
 * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
 * folder configuration changes.
 */ var DidChangeWorkspaceFoldersNotification;
                (function(DidChangeWorkspaceFoldersNotification) {
                    DidChangeWorkspaceFoldersNotification.method = "workspace/didChangeWorkspaceFolders";
                    DidChangeWorkspaceFoldersNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification.method);
                })(DidChangeWorkspaceFoldersNotification = exports1.DidChangeWorkspaceFoldersNotification || (exports1.DidChangeWorkspaceFoldersNotification = {}));
            //# sourceMappingURL=protocol.workspaceFolder.js.map
            /***/ },
            /***/ 2523: /***/ function(__unused_webpack_module, exports1) {
                "use strict";
                var boolean = function boolean(value) {
                    return value === true || value === false;
                };
                var string = function string(value) {
                    return typeof value === "string" || _instanceof(value, String);
                };
                var number = function number(value) {
                    return typeof value === "number" || _instanceof(value, Number);
                };
                var error = function error(value) {
                    return _instanceof(value, Error);
                };
                var func = function func(value) {
                    return typeof value === "function";
                };
                var array = function array(value) {
                    return Array.isArray(value);
                };
                var stringArray = function stringArray(value) {
                    return array(value) && value.every(function(elem) {
                        return string(elem);
                    });
                };
                var typedArray = function typedArray(value, check) {
                    return Array.isArray(value) && value.every(check);
                };
                var objectLiteral = function objectLiteral(value) {
                    // Strictly speaking class instances pass this check as well. Since the LSP
                    // doesn't use classes we ignore this for now. If we do we need to add something
                    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
                    return value !== null && typeof value === "object";
                };
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.objectLiteral = exports1.typedArray = exports1.stringArray = exports1.array = exports1.func = exports1.error = exports1.number = exports1.string = exports1.boolean = void 0;
                exports1.boolean = boolean;
                exports1.string = string;
                exports1.number = number;
                exports1.error = error;
                exports1.func = func;
                exports1.array = array;
                exports1.stringArray = stringArray;
                exports1.typedArray = typedArray;
                exports1.objectLiteral = objectLiteral;
            //# sourceMappingURL=is.js.map
            /***/ },
            /***/ 4767: /***/ function(__unused_webpack_module, __webpack_exports__, __nested_webpack_require_2120951__) {
                "use strict";
                __nested_webpack_require_2120951__.r(__webpack_exports__);
                /* harmony export */ __nested_webpack_require_2120951__.d(__webpack_exports__, {
                    /* harmony export */ "AnnotatedTextEdit": function() {
                        return /* binding */ AnnotatedTextEdit;
                    },
                    /* harmony export */ "ChangeAnnotation": function() {
                        return /* binding */ ChangeAnnotation;
                    },
                    /* harmony export */ "ChangeAnnotationIdentifier": function() {
                        return /* binding */ ChangeAnnotationIdentifier;
                    },
                    /* harmony export */ "CodeAction": function() {
                        return /* binding */ CodeAction;
                    },
                    /* harmony export */ "CodeActionContext": function() {
                        return /* binding */ CodeActionContext;
                    },
                    /* harmony export */ "CodeActionKind": function() {
                        return /* binding */ CodeActionKind;
                    },
                    /* harmony export */ "CodeActionTriggerKind": function() {
                        return /* binding */ CodeActionTriggerKind;
                    },
                    /* harmony export */ "CodeDescription": function() {
                        return /* binding */ CodeDescription;
                    },
                    /* harmony export */ "CodeLens": function() {
                        return /* binding */ CodeLens;
                    },
                    /* harmony export */ "Color": function() {
                        return /* binding */ Color;
                    },
                    /* harmony export */ "ColorInformation": function() {
                        return /* binding */ ColorInformation;
                    },
                    /* harmony export */ "ColorPresentation": function() {
                        return /* binding */ ColorPresentation;
                    },
                    /* harmony export */ "Command": function() {
                        return /* binding */ Command;
                    },
                    /* harmony export */ "CompletionItem": function() {
                        return /* binding */ CompletionItem;
                    },
                    /* harmony export */ "CompletionItemKind": function() {
                        return /* binding */ CompletionItemKind1;
                    },
                    /* harmony export */ "CompletionItemLabelDetails": function() {
                        return /* binding */ CompletionItemLabelDetails;
                    },
                    /* harmony export */ "CompletionItemTag": function() {
                        return /* binding */ CompletionItemTag;
                    },
                    /* harmony export */ "CompletionList": function() {
                        return /* binding */ CompletionList;
                    },
                    /* harmony export */ "CreateFile": function() {
                        return /* binding */ CreateFile;
                    },
                    /* harmony export */ "DeleteFile": function() {
                        return /* binding */ DeleteFile;
                    },
                    /* harmony export */ "Diagnostic": function() {
                        return /* binding */ Diagnostic;
                    },
                    /* harmony export */ "DiagnosticRelatedInformation": function() {
                        return /* binding */ DiagnosticRelatedInformation;
                    },
                    /* harmony export */ "DiagnosticSeverity": function() {
                        return /* binding */ DiagnosticSeverity;
                    },
                    /* harmony export */ "DiagnosticTag": function() {
                        return /* binding */ DiagnosticTag;
                    },
                    /* harmony export */ "DocumentHighlight": function() {
                        return /* binding */ DocumentHighlight;
                    },
                    /* harmony export */ "DocumentHighlightKind": function() {
                        return /* binding */ DocumentHighlightKind;
                    },
                    /* harmony export */ "DocumentLink": function() {
                        return /* binding */ DocumentLink;
                    },
                    /* harmony export */ "DocumentSymbol": function() {
                        return /* binding */ DocumentSymbol;
                    },
                    /* harmony export */ "DocumentUri": function() {
                        return /* binding */ DocumentUri;
                    },
                    /* harmony export */ "EOL": function() {
                        return /* binding */ EOL;
                    },
                    /* harmony export */ "FoldingRange": function() {
                        return /* binding */ FoldingRange;
                    },
                    /* harmony export */ "FoldingRangeKind": function() {
                        return /* binding */ FoldingRangeKind;
                    },
                    /* harmony export */ "FormattingOptions": function() {
                        return /* binding */ FormattingOptions;
                    },
                    /* harmony export */ "Hover": function() {
                        return /* binding */ Hover;
                    },
                    /* harmony export */ "InlayHint": function() {
                        return /* binding */ InlayHint;
                    },
                    /* harmony export */ "InlayHintKind": function() {
                        return /* binding */ InlayHintKind;
                    },
                    /* harmony export */ "InlayHintLabelPart": function() {
                        return /* binding */ InlayHintLabelPart;
                    },
                    /* harmony export */ "InlineValueContext": function() {
                        return /* binding */ InlineValueContext;
                    },
                    /* harmony export */ "InlineValueEvaluatableExpression": function() {
                        return /* binding */ InlineValueEvaluatableExpression;
                    },
                    /* harmony export */ "InlineValueText": function() {
                        return /* binding */ InlineValueText;
                    },
                    /* harmony export */ "InlineValueVariableLookup": function() {
                        return /* binding */ InlineValueVariableLookup;
                    },
                    /* harmony export */ "InsertReplaceEdit": function() {
                        return /* binding */ InsertReplaceEdit;
                    },
                    /* harmony export */ "InsertTextFormat": function() {
                        return /* binding */ InsertTextFormat1;
                    },
                    /* harmony export */ "InsertTextMode": function() {
                        return /* binding */ InsertTextMode;
                    },
                    /* harmony export */ "Location": function() {
                        return /* binding */ Location;
                    },
                    /* harmony export */ "LocationLink": function() {
                        return /* binding */ LocationLink;
                    },
                    /* harmony export */ "MarkedString": function() {
                        return /* binding */ MarkedString1;
                    },
                    /* harmony export */ "MarkupContent": function() {
                        return /* binding */ MarkupContent1;
                    },
                    /* harmony export */ "MarkupKind": function() {
                        return /* binding */ MarkupKind;
                    },
                    /* harmony export */ "OptionalVersionedTextDocumentIdentifier": function() {
                        return /* binding */ OptionalVersionedTextDocumentIdentifier;
                    },
                    /* harmony export */ "ParameterInformation": function() {
                        return /* binding */ ParameterInformation;
                    },
                    /* harmony export */ "Position": function() {
                        return /* binding */ Position;
                    },
                    /* harmony export */ "Range": function() {
                        return /* binding */ Range;
                    },
                    /* harmony export */ "RenameFile": function() {
                        return /* binding */ RenameFile;
                    },
                    /* harmony export */ "SelectionRange": function() {
                        return /* binding */ SelectionRange;
                    },
                    /* harmony export */ "SemanticTokenModifiers": function() {
                        return /* binding */ SemanticTokenModifiers;
                    },
                    /* harmony export */ "SemanticTokenTypes": function() {
                        return /* binding */ SemanticTokenTypes;
                    },
                    /* harmony export */ "SemanticTokens": function() {
                        return /* binding */ SemanticTokens;
                    },
                    /* harmony export */ "SignatureInformation": function() {
                        return /* binding */ SignatureInformation;
                    },
                    /* harmony export */ "SymbolInformation": function() {
                        return /* binding */ SymbolInformation;
                    },
                    /* harmony export */ "SymbolKind": function() {
                        return /* binding */ SymbolKind;
                    },
                    /* harmony export */ "SymbolTag": function() {
                        return /* binding */ SymbolTag;
                    },
                    /* harmony export */ "TextDocument": function() {
                        return /* binding */ TextDocument;
                    },
                    /* harmony export */ "TextDocumentEdit": function() {
                        return /* binding */ TextDocumentEdit;
                    },
                    /* harmony export */ "TextDocumentIdentifier": function() {
                        return /* binding */ TextDocumentIdentifier;
                    },
                    /* harmony export */ "TextDocumentItem": function() {
                        return /* binding */ TextDocumentItem;
                    },
                    /* harmony export */ "TextEdit": function() {
                        return /* binding */ TextEdit;
                    },
                    /* harmony export */ "URI": function() {
                        return /* binding */ URI;
                    },
                    /* harmony export */ "VersionedTextDocumentIdentifier": function() {
                        return /* binding */ VersionedTextDocumentIdentifier;
                    },
                    /* harmony export */ "WorkspaceChange": function() {
                        return /* binding */ WorkspaceChange;
                    },
                    /* harmony export */ "WorkspaceEdit": function() {
                        return /* binding */ WorkspaceEdit;
                    },
                    /* harmony export */ "WorkspaceFolder": function() {
                        return /* binding */ WorkspaceFolder;
                    },
                    /* harmony export */ "WorkspaceSymbol": function() {
                        return /* binding */ WorkspaceSymbol;
                    },
                    /* harmony export */ "integer": function() {
                        return /* binding */ integer;
                    },
                    /* harmony export */ "uinteger": function() {
                        return /* binding */ uinteger;
                    }
                });
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var DocumentUri;
                (function(DocumentUri) {
                    var is = function is(value) {
                        return typeof value === "string";
                    };
                    DocumentUri.is = is;
                })(DocumentUri || (DocumentUri = {}));
                var URI;
                (function(URI) {
                    var is = function is(value) {
                        return typeof value === "string";
                    };
                    URI.is = is;
                })(URI || (URI = {}));
                var integer;
                (function(integer) {
                    var is = function is(value) {
                        return typeof value === "number" && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;
                    };
                    integer.MIN_VALUE = -2147483648;
                    integer.MAX_VALUE = 2147483647;
                    integer.is = is;
                })(integer || (integer = {}));
                var uinteger;
                (function(uinteger) {
                    var is = function is(value) {
                        return typeof value === "number" && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;
                    };
                    uinteger.MIN_VALUE = 0;
                    uinteger.MAX_VALUE = 2147483647;
                    uinteger.is = is;
                })(uinteger || (uinteger = {}));
                /**
 * The Position namespace provides helper functions to work with
 * [Position](#Position) literals.
 */ var Position;
                (function(Position) {
                    var create = /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */ function create(line, character) {
                        if (line === Number.MAX_VALUE) {
                            line = uinteger.MAX_VALUE;
                        }
                        if (character === Number.MAX_VALUE) {
                            character = uinteger.MAX_VALUE;
                        }
                        return {
                            line: line,
                            character: character
                        };
                    };
                    var is = /**
     * Checks whether the given literal conforms to the [Position](#Position) interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
                    };
                    Position.create = create;
                    Position.is = is;
                })(Position || (Position = {}));
                /**
 * The Range namespace provides helper functions to work with
 * [Range](#Range) literals.
 */ var Range;
                (function(Range) {
                    var create = function create(one, two, three, four) {
                        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
                            return {
                                start: Position.create(one, two),
                                end: Position.create(three, four)
                            };
                        } else if (Position.is(one) && Position.is(two)) {
                            return {
                                start: one,
                                end: two
                            };
                        } else {
                            throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
                        }
                    };
                    var is = /**
     * Checks whether the given literal conforms to the [Range](#Range) interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
                    };
                    Range.create = create;
                    Range.is = is;
                })(Range || (Range = {}));
                /**
 * The Location namespace provides helper functions to work with
 * [Location](#Location) literals.
 */ var Location;
                (function(Location) {
                    var create = /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */ function create(uri, range) {
                        return {
                            uri: uri,
                            range: range
                        };
                    };
                    var is = /**
     * Checks whether the given literal conforms to the [Location](#Location) interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
                    };
                    Location.create = create;
                    Location.is = is;
                })(Location || (Location = {}));
                /**
 * The LocationLink namespace provides helper functions to work with
 * [LocationLink](#LocationLink) literals.
 */ var LocationLink;
                (function(LocationLink) {
                    var create = /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */ function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
                        return {
                            targetUri: targetUri,
                            targetRange: targetRange,
                            targetSelectionRange: targetSelectionRange,
                            originSelectionRange: originSelectionRange
                        };
                    };
                    var is = /**
     * Checks whether the given literal conforms to the [LocationLink](#LocationLink) interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
                    };
                    LocationLink.create = create;
                    LocationLink.is = is;
                })(LocationLink || (LocationLink = {}));
                /**
 * The Color namespace provides helper functions to work with
 * [Color](#Color) literals.
 */ var Color;
                (function(Color) {
                    var create = /**
     * Creates a new Color literal.
     */ function create(red, green, blue, alpha) {
                        return {
                            red: red,
                            green: green,
                            blue: blue,
                            alpha: alpha
                        };
                    };
                    var is = /**
     * Checks whether the given literal conforms to the [Color](#Color) interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
                    };
                    Color.create = create;
                    Color.is = is;
                })(Color || (Color = {}));
                /**
 * The ColorInformation namespace provides helper functions to work with
 * [ColorInformation](#ColorInformation) literals.
 */ var ColorInformation;
                (function(ColorInformation) {
                    var create = /**
     * Creates a new ColorInformation literal.
     */ function create(range, color) {
                        return {
                            range: range,
                            color: color
                        };
                    };
                    var is = /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
                    };
                    ColorInformation.create = create;
                    ColorInformation.is = is;
                })(ColorInformation || (ColorInformation = {}));
                /**
 * The Color namespace provides helper functions to work with
 * [ColorPresentation](#ColorPresentation) literals.
 */ var ColorPresentation;
                (function(ColorPresentation) {
                    var create = /**
     * Creates a new ColorInformation literal.
     */ function create(label, textEdit, additionalTextEdits) {
                        return {
                            label: label,
                            textEdit: textEdit,
                            additionalTextEdits: additionalTextEdits
                        };
                    };
                    var is = /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
                    };
                    ColorPresentation.create = create;
                    ColorPresentation.is = is;
                })(ColorPresentation || (ColorPresentation = {}));
                /**
 * A set of predefined range kinds.
 */ var FoldingRangeKind;
                (function(FoldingRangeKind) {
                    /**
     * Folding range for a comment
     */ FoldingRangeKind.Comment = "comment";
                    /**
     * Folding range for an import or include
     */ FoldingRangeKind.Imports = "imports";
                    /**
     * Folding range for a region (e.g. `#region`)
     */ FoldingRangeKind.Region = "region";
                })(FoldingRangeKind || (FoldingRangeKind = {}));
                /**
 * The folding range namespace provides helper functions to work with
 * [FoldingRange](#FoldingRange) literals.
 */ var FoldingRange;
                (function(FoldingRange) {
                    var create = /**
     * Creates a new FoldingRange literal.
     */ function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
                        var result = {
                            startLine: startLine,
                            endLine: endLine
                        };
                        if (Is.defined(startCharacter)) {
                            result.startCharacter = startCharacter;
                        }
                        if (Is.defined(endCharacter)) {
                            result.endCharacter = endCharacter;
                        }
                        if (Is.defined(kind)) {
                            result.kind = kind;
                        }
                        if (Is.defined(collapsedText)) {
                            result.collapsedText = collapsedText;
                        }
                        return result;
                    };
                    var is = /**
     * Checks whether the given literal conforms to the [FoldingRange](#FoldingRange) interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
                    };
                    FoldingRange.create = create;
                    FoldingRange.is = is;
                })(FoldingRange || (FoldingRange = {}));
                /**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) literals.
 */ var DiagnosticRelatedInformation;
                (function(DiagnosticRelatedInformation) {
                    var create = /**
     * Creates a new DiagnosticRelatedInformation literal.
     */ function create(location, message) {
                        return {
                            location: location,
                            message: message
                        };
                    };
                    var is = /**
     * Checks whether the given literal conforms to the [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
                    };
                    DiagnosticRelatedInformation.create = create;
                    DiagnosticRelatedInformation.is = is;
                })(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
                /**
 * The diagnostic's severity.
 */ var DiagnosticSeverity;
                (function(DiagnosticSeverity) {
                    /**
     * Reports an error.
     */ DiagnosticSeverity.Error = 1;
                    /**
     * Reports a warning.
     */ DiagnosticSeverity.Warning = 2;
                    /**
     * Reports an information.
     */ DiagnosticSeverity.Information = 3;
                    /**
     * Reports a hint.
     */ DiagnosticSeverity.Hint = 4;
                })(DiagnosticSeverity || (DiagnosticSeverity = {}));
                /**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */ var DiagnosticTag;
                (function(DiagnosticTag) {
                    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */ DiagnosticTag.Unnecessary = 1;
                    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */ DiagnosticTag.Deprecated = 2;
                })(DiagnosticTag || (DiagnosticTag = {}));
                /**
 * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
 *
 * @since 3.16.0
 */ var CodeDescription;
                (function(CodeDescription) {
                    var is = function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.href);
                    };
                    CodeDescription.is = is;
                })(CodeDescription || (CodeDescription = {}));
                /**
 * The Diagnostic namespace provides helper functions to work with
 * [Diagnostic](#Diagnostic) literals.
 */ var Diagnostic;
                (function(Diagnostic) {
                    var create = /**
     * Creates a new Diagnostic literal.
     */ function create(range, message, severity, code, source, relatedInformation) {
                        var result = {
                            range: range,
                            message: message
                        };
                        if (Is.defined(severity)) {
                            result.severity = severity;
                        }
                        if (Is.defined(code)) {
                            result.code = code;
                        }
                        if (Is.defined(source)) {
                            result.source = source;
                        }
                        if (Is.defined(relatedInformation)) {
                            result.relatedInformation = relatedInformation;
                        }
                        return result;
                    };
                    var is = /**
     * Checks whether the given literal conforms to the [Diagnostic](#Diagnostic) interface.
     */ function is(value) {
                        var _a;
                        var candidate = value;
                        return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
                    };
                    Diagnostic.create = create;
                    Diagnostic.is = is;
                })(Diagnostic || (Diagnostic = {}));
                /**
 * The Command namespace provides helper functions to work with
 * [Command](#Command) literals.
 */ var Command;
                (function(Command) {
                    var create = /**
     * Creates a new Command literal.
     */ function create(title, command) {
                        var args = [];
                        for(var _i = 2; _i < arguments.length; _i++){
                            args[_i - 2] = arguments[_i];
                        }
                        var result = {
                            title: title,
                            command: command
                        };
                        if (Is.defined(args) && args.length > 0) {
                            result.arguments = args;
                        }
                        return result;
                    };
                    var is = /**
     * Checks whether the given literal conforms to the [Command](#Command) interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
                    };
                    Command.create = create;
                    Command.is = is;
                })(Command || (Command = {}));
                /**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */ var TextEdit;
                (function(TextEdit) {
                    var replace = /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */ function replace(range, newText) {
                        return {
                            range: range,
                            newText: newText
                        };
                    };
                    var insert = /**
     * Creates an insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */ function insert(position, newText) {
                        return {
                            range: {
                                start: position,
                                end: position
                            },
                            newText: newText
                        };
                    };
                    var del = /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */ function del(range) {
                        return {
                            range: range,
                            newText: ""
                        };
                    };
                    var is = function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
                    };
                    TextEdit.replace = replace;
                    TextEdit.insert = insert;
                    TextEdit.del = del;
                    TextEdit.is = is;
                })(TextEdit || (TextEdit = {}));
                var ChangeAnnotation;
                (function(ChangeAnnotation) {
                    var create = function create(label, needsConfirmation, description) {
                        var result = {
                            label: label
                        };
                        if (needsConfirmation !== undefined) {
                            result.needsConfirmation = needsConfirmation;
                        }
                        if (description !== undefined) {
                            result.description = description;
                        }
                        return result;
                    };
                    var is = function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) && (Is.string(candidate.description) || candidate.description === undefined);
                    };
                    ChangeAnnotation.create = create;
                    ChangeAnnotation.is = is;
                })(ChangeAnnotation || (ChangeAnnotation = {}));
                var ChangeAnnotationIdentifier;
                (function(ChangeAnnotationIdentifier) {
                    var is = function is(value) {
                        var candidate = value;
                        return Is.string(candidate);
                    };
                    ChangeAnnotationIdentifier.is = is;
                })(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
                var AnnotatedTextEdit;
                (function(AnnotatedTextEdit) {
                    var replace = /**
     * Creates an annotated replace text edit.
     *
     * @param range The range of text to be replaced.
     * @param newText The new text.
     * @param annotation The annotation.
     */ function replace(range, newText, annotation) {
                        return {
                            range: range,
                            newText: newText,
                            annotationId: annotation
                        };
                    };
                    var insert = /**
     * Creates an annotated insert text edit.
     *
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     * @param annotation The annotation.
     */ function insert(position, newText, annotation) {
                        return {
                            range: {
                                start: position,
                                end: position
                            },
                            newText: newText,
                            annotationId: annotation
                        };
                    };
                    var del = /**
     * Creates an annotated delete text edit.
     *
     * @param range The range of text to be deleted.
     * @param annotation The annotation.
     */ function del(range, annotation) {
                        return {
                            range: range,
                            newText: "",
                            annotationId: annotation
                        };
                    };
                    var is = function is(value) {
                        var candidate = value;
                        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    };
                    AnnotatedTextEdit.replace = replace;
                    AnnotatedTextEdit.insert = insert;
                    AnnotatedTextEdit.del = del;
                    AnnotatedTextEdit.is = is;
                })(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
                /**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */ var TextDocumentEdit;
                (function(TextDocumentEdit) {
                    var create = /**
     * Creates a new `TextDocumentEdit`
     */ function create(textDocument, edits) {
                        return {
                            textDocument: textDocument,
                            edits: edits
                        };
                    };
                    var is = function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
                    };
                    TextDocumentEdit.create = create;
                    TextDocumentEdit.is = is;
                })(TextDocumentEdit || (TextDocumentEdit = {}));
                var CreateFile;
                (function(CreateFile) {
                    var create = function create(uri, options, annotation) {
                        var result = {
                            kind: "create",
                            uri: uri
                        };
                        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
                            result.options = options;
                        }
                        if (annotation !== undefined) {
                            result.annotationId = annotation;
                        }
                        return result;
                    };
                    var is = function is(value) {
                        var candidate = value;
                        return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    };
                    CreateFile.create = create;
                    CreateFile.is = is;
                })(CreateFile || (CreateFile = {}));
                var RenameFile;
                (function(RenameFile) {
                    var create = function create(oldUri, newUri, options, annotation) {
                        var result = {
                            kind: "rename",
                            oldUri: oldUri,
                            newUri: newUri
                        };
                        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
                            result.options = options;
                        }
                        if (annotation !== undefined) {
                            result.annotationId = annotation;
                        }
                        return result;
                    };
                    var is = function is(value) {
                        var candidate = value;
                        return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    };
                    RenameFile.create = create;
                    RenameFile.is = is;
                })(RenameFile || (RenameFile = {}));
                var DeleteFile;
                (function(DeleteFile) {
                    var create = function create(uri, options, annotation) {
                        var result = {
                            kind: "delete",
                            uri: uri
                        };
                        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
                            result.options = options;
                        }
                        if (annotation !== undefined) {
                            result.annotationId = annotation;
                        }
                        return result;
                    };
                    var is = function is(value) {
                        var candidate = value;
                        return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    };
                    DeleteFile.create = create;
                    DeleteFile.is = is;
                })(DeleteFile || (DeleteFile = {}));
                var WorkspaceEdit;
                (function(WorkspaceEdit) {
                    var is = function is(value) {
                        var candidate = value;
                        return candidate && (candidate.changes !== undefined || candidate.documentChanges !== undefined) && (candidate.documentChanges === undefined || candidate.documentChanges.every(function(change) {
                            if (Is.string(change.kind)) {
                                return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                            } else {
                                return TextDocumentEdit.is(change);
                            }
                        }));
                    };
                    WorkspaceEdit.is = is;
                })(WorkspaceEdit || (WorkspaceEdit = {}));
                var TextEditChangeImpl = /** @class */ function() {
                    var TextEditChangeImpl = function TextEditChangeImpl(edits, changeAnnotations) {
                        this.edits = edits;
                        this.changeAnnotations = changeAnnotations;
                    };
                    TextEditChangeImpl.prototype.insert = function(position, newText, annotation) {
                        var edit;
                        var id;
                        if (annotation === undefined) {
                            edit = TextEdit.insert(position, newText);
                        } else if (ChangeAnnotationIdentifier.is(annotation)) {
                            id = annotation;
                            edit = AnnotatedTextEdit.insert(position, newText, annotation);
                        } else {
                            this.assertChangeAnnotations(this.changeAnnotations);
                            id = this.changeAnnotations.manage(annotation);
                            edit = AnnotatedTextEdit.insert(position, newText, id);
                        }
                        this.edits.push(edit);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    TextEditChangeImpl.prototype.replace = function(range, newText, annotation) {
                        var edit;
                        var id;
                        if (annotation === undefined) {
                            edit = TextEdit.replace(range, newText);
                        } else if (ChangeAnnotationIdentifier.is(annotation)) {
                            id = annotation;
                            edit = AnnotatedTextEdit.replace(range, newText, annotation);
                        } else {
                            this.assertChangeAnnotations(this.changeAnnotations);
                            id = this.changeAnnotations.manage(annotation);
                            edit = AnnotatedTextEdit.replace(range, newText, id);
                        }
                        this.edits.push(edit);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    TextEditChangeImpl.prototype.delete = function(range, annotation) {
                        var edit;
                        var id;
                        if (annotation === undefined) {
                            edit = TextEdit.del(range);
                        } else if (ChangeAnnotationIdentifier.is(annotation)) {
                            id = annotation;
                            edit = AnnotatedTextEdit.del(range, annotation);
                        } else {
                            this.assertChangeAnnotations(this.changeAnnotations);
                            id = this.changeAnnotations.manage(annotation);
                            edit = AnnotatedTextEdit.del(range, id);
                        }
                        this.edits.push(edit);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    TextEditChangeImpl.prototype.add = function(edit) {
                        this.edits.push(edit);
                    };
                    TextEditChangeImpl.prototype.all = function() {
                        return this.edits;
                    };
                    TextEditChangeImpl.prototype.clear = function() {
                        this.edits.splice(0, this.edits.length);
                    };
                    TextEditChangeImpl.prototype.assertChangeAnnotations = function(value) {
                        if (value === undefined) {
                            throw new Error("Text edit change is not configured to manage change annotations.");
                        }
                    };
                    return TextEditChangeImpl;
                }();
                /**
 * A helper class
 */ var ChangeAnnotations = /** @class */ function() {
                    var ChangeAnnotations = function ChangeAnnotations(annotations) {
                        this._annotations = annotations === undefined ? Object.create(null) : annotations;
                        this._counter = 0;
                        this._size = 0;
                    };
                    ChangeAnnotations.prototype.all = function() {
                        return this._annotations;
                    };
                    Object.defineProperty(ChangeAnnotations.prototype, "size", {
                        get: function get() {
                            return this._size;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    ChangeAnnotations.prototype.manage = function(idOrAnnotation, annotation) {
                        var id;
                        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
                            id = idOrAnnotation;
                        } else {
                            id = this.nextId();
                            annotation = idOrAnnotation;
                        }
                        if (this._annotations[id] !== undefined) {
                            throw new Error("Id ".concat(id, " is already in use."));
                        }
                        if (annotation === undefined) {
                            throw new Error("No annotation provided for id ".concat(id));
                        }
                        this._annotations[id] = annotation;
                        this._size++;
                        return id;
                    };
                    ChangeAnnotations.prototype.nextId = function() {
                        this._counter++;
                        return this._counter.toString();
                    };
                    return ChangeAnnotations;
                }();
                /**
 * A workspace change helps constructing changes to a workspace.
 */ var WorkspaceChange = /** @class */ function() {
                    var WorkspaceChange = function WorkspaceChange(workspaceEdit) {
                        var _this = this;
                        this._textEditChanges = Object.create(null);
                        if (workspaceEdit !== undefined) {
                            this._workspaceEdit = workspaceEdit;
                            if (workspaceEdit.documentChanges) {
                                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                                workspaceEdit.documentChanges.forEach(function(change) {
                                    if (TextDocumentEdit.is(change)) {
                                        var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                                        _this._textEditChanges[change.textDocument.uri] = textEditChange;
                                    }
                                });
                            } else if (workspaceEdit.changes) {
                                Object.keys(workspaceEdit.changes).forEach(function(key) {
                                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                                    _this._textEditChanges[key] = textEditChange;
                                });
                            }
                        } else {
                            this._workspaceEdit = {};
                        }
                    };
                    Object.defineProperty(WorkspaceChange.prototype, "edit", {
                        /**
         * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal
         * use to be returned from a workspace edit operation like rename.
         */ get: function get() {
                            this.initDocumentChanges();
                            if (this._changeAnnotations !== undefined) {
                                if (this._changeAnnotations.size === 0) {
                                    this._workspaceEdit.changeAnnotations = undefined;
                                } else {
                                    this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                                }
                            }
                            return this._workspaceEdit;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    WorkspaceChange.prototype.getTextEditChange = function(key) {
                        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
                            this.initDocumentChanges();
                            if (this._workspaceEdit.documentChanges === undefined) {
                                throw new Error("Workspace edit is not configured for document changes.");
                            }
                            var textDocument = {
                                uri: key.uri,
                                version: key.version
                            };
                            var result = this._textEditChanges[textDocument.uri];
                            if (!result) {
                                var edits = [];
                                var textDocumentEdit = {
                                    textDocument: textDocument,
                                    edits: edits
                                };
                                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                                this._textEditChanges[textDocument.uri] = result;
                            }
                            return result;
                        } else {
                            this.initChanges();
                            if (this._workspaceEdit.changes === undefined) {
                                throw new Error("Workspace edit is not configured for normal text edit changes.");
                            }
                            var result = this._textEditChanges[key];
                            if (!result) {
                                var edits = [];
                                this._workspaceEdit.changes[key] = edits;
                                result = new TextEditChangeImpl(edits);
                                this._textEditChanges[key] = result;
                            }
                            return result;
                        }
                    };
                    WorkspaceChange.prototype.initDocumentChanges = function() {
                        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
                            this._changeAnnotations = new ChangeAnnotations();
                            this._workspaceEdit.documentChanges = [];
                            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                        }
                    };
                    WorkspaceChange.prototype.initChanges = function() {
                        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
                            this._workspaceEdit.changes = Object.create(null);
                        }
                    };
                    WorkspaceChange.prototype.createFile = function(uri, optionsOrAnnotation, options) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error("Workspace edit is not configured for document changes.");
                        }
                        var annotation;
                        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                            annotation = optionsOrAnnotation;
                        } else {
                            options = optionsOrAnnotation;
                        }
                        var operation;
                        var id;
                        if (annotation === undefined) {
                            operation = CreateFile.create(uri, options);
                        } else {
                            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                            operation = CreateFile.create(uri, options, id);
                        }
                        this._workspaceEdit.documentChanges.push(operation);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    WorkspaceChange.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error("Workspace edit is not configured for document changes.");
                        }
                        var annotation;
                        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                            annotation = optionsOrAnnotation;
                        } else {
                            options = optionsOrAnnotation;
                        }
                        var operation;
                        var id;
                        if (annotation === undefined) {
                            operation = RenameFile.create(oldUri, newUri, options);
                        } else {
                            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                            operation = RenameFile.create(oldUri, newUri, options, id);
                        }
                        this._workspaceEdit.documentChanges.push(operation);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    WorkspaceChange.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error("Workspace edit is not configured for document changes.");
                        }
                        var annotation;
                        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                            annotation = optionsOrAnnotation;
                        } else {
                            options = optionsOrAnnotation;
                        }
                        var operation;
                        var id;
                        if (annotation === undefined) {
                            operation = DeleteFile.create(uri, options);
                        } else {
                            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                            operation = DeleteFile.create(uri, options, id);
                        }
                        this._workspaceEdit.documentChanges.push(operation);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    return WorkspaceChange;
                }();
                /**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * [TextDocumentIdentifier](#TextDocumentIdentifier) literals.
 */ var TextDocumentIdentifier;
                (function(TextDocumentIdentifier) {
                    var create = /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */ function create(uri) {
                        return {
                            uri: uri
                        };
                    };
                    var is = /**
     * Checks whether the given literal conforms to the [TextDocumentIdentifier](#TextDocumentIdentifier) interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri);
                    };
                    TextDocumentIdentifier.create = create;
                    TextDocumentIdentifier.is = is;
                })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
                /**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) literals.
 */ var VersionedTextDocumentIdentifier;
                (function(VersionedTextDocumentIdentifier) {
                    var create = /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */ function create(uri, version) {
                        return {
                            uri: uri,
                            version: version
                        };
                    };
                    var is = /**
     * Checks whether the given literal conforms to the [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
                    };
                    VersionedTextDocumentIdentifier.create = create;
                    VersionedTextDocumentIdentifier.is = is;
                })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
                /**
 * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
 * [OptionalVersionedTextDocumentIdentifier](#OptionalVersionedTextDocumentIdentifier) literals.
 */ var OptionalVersionedTextDocumentIdentifier;
                (function(OptionalVersionedTextDocumentIdentifier) {
                    var create = /**
     * Creates a new OptionalVersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */ function create(uri, version) {
                        return {
                            uri: uri,
                            version: version
                        };
                    };
                    var is = /**
     * Checks whether the given literal conforms to the [OptionalVersionedTextDocumentIdentifier](#OptionalVersionedTextDocumentIdentifier) interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
                    };
                    OptionalVersionedTextDocumentIdentifier.create = create;
                    OptionalVersionedTextDocumentIdentifier.is = is;
                })(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
                /**
 * The TextDocumentItem namespace provides helper functions to work with
 * [TextDocumentItem](#TextDocumentItem) literals.
 */ var TextDocumentItem;
                (function(TextDocumentItem) {
                    var create = /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */ function create(uri, languageId, version, text) {
                        return {
                            uri: uri,
                            languageId: languageId,
                            version: version,
                            text: text
                        };
                    };
                    var is = /**
     * Checks whether the given literal conforms to the [TextDocumentItem](#TextDocumentItem) interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
                    };
                    TextDocumentItem.create = create;
                    TextDocumentItem.is = is;
                })(TextDocumentItem || (TextDocumentItem = {}));
                /**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */ var MarkupKind;
                (function(MarkupKind) {
                    var is = /**
     * Checks whether the given value is a value of the [MarkupKind](#MarkupKind) type.
     */ function is(value) {
                        var candidate = value;
                        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
                    };
                    /**
     * Plain text is supported as a content format
     */ MarkupKind.PlainText = "plaintext";
                    /**
     * Markdown is supported as a content format
     */ MarkupKind.Markdown = "markdown";
                    MarkupKind.is = is;
                })(MarkupKind || (MarkupKind = {}));
                var MarkupContent1;
                (function(MarkupContent1) {
                    var is = /**
     * Checks whether the given value conforms to the [MarkupContent](#MarkupContent) interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
                    };
                    MarkupContent1.is = is;
                })(MarkupContent1 || (MarkupContent1 = {}));
                /**
 * The kind of a completion entry.
 */ var CompletionItemKind1;
                (function(CompletionItemKind1) {
                    CompletionItemKind1.Text = 1;
                    CompletionItemKind1.Method = 2;
                    CompletionItemKind1.Function = 3;
                    CompletionItemKind1.Constructor = 4;
                    CompletionItemKind1.Field = 5;
                    CompletionItemKind1.Variable = 6;
                    CompletionItemKind1.Class = 7;
                    CompletionItemKind1.Interface = 8;
                    CompletionItemKind1.Module = 9;
                    CompletionItemKind1.Property = 10;
                    CompletionItemKind1.Unit = 11;
                    CompletionItemKind1.Value = 12;
                    CompletionItemKind1.Enum = 13;
                    CompletionItemKind1.Keyword = 14;
                    CompletionItemKind1.Snippet = 15;
                    CompletionItemKind1.Color = 16;
                    CompletionItemKind1.File = 17;
                    CompletionItemKind1.Reference = 18;
                    CompletionItemKind1.Folder = 19;
                    CompletionItemKind1.EnumMember = 20;
                    CompletionItemKind1.Constant = 21;
                    CompletionItemKind1.Struct = 22;
                    CompletionItemKind1.Event = 23;
                    CompletionItemKind1.Operator = 24;
                    CompletionItemKind1.TypeParameter = 25;
                })(CompletionItemKind1 || (CompletionItemKind1 = {}));
                /**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */ var InsertTextFormat1;
                (function(InsertTextFormat1) {
                    /**
     * The primary text to be inserted is treated as a plain string.
     */ InsertTextFormat1.PlainText = 1;
                    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
     */ InsertTextFormat1.Snippet = 2;
                })(InsertTextFormat1 || (InsertTextFormat1 = {}));
                /**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */ var CompletionItemTag;
                (function(CompletionItemTag) {
                    /**
     * Render a completion as obsolete, usually using a strike-out.
     */ CompletionItemTag.Deprecated = 1;
                })(CompletionItemTag || (CompletionItemTag = {}));
                /**
 * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
 *
 * @since 3.16.0
 */ var InsertReplaceEdit;
                (function(InsertReplaceEdit) {
                    var create = /**
     * Creates a new insert / replace edit
     */ function create(newText, insert, replace) {
                        return {
                            newText: newText,
                            insert: insert,
                            replace: replace
                        };
                    };
                    var is = /**
     * Checks whether the given literal conforms to the [InsertReplaceEdit](#InsertReplaceEdit) interface.
     */ function is(value) {
                        var candidate = value;
                        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
                    };
                    InsertReplaceEdit.create = create;
                    InsertReplaceEdit.is = is;
                })(InsertReplaceEdit || (InsertReplaceEdit = {}));
                /**
 * How whitespace and indentation is handled during completion
 * item insertion.
 *
 * @since 3.16.0
 */ var InsertTextMode;
                (function(InsertTextMode) {
                    /**
     * The insertion or replace strings is taken as it is. If the
     * value is multi line the lines below the cursor will be
     * inserted using the indentation defined in the string value.
     * The client will not apply any kind of adjustments to the
     * string.
     */ InsertTextMode.asIs = 1;
                    /**
     * The editor adjusts leading whitespace of new lines so that
     * they match the indentation up to the cursor of the line for
     * which the item is accepted.
     *
     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
     * multi line completion item is indented using 2 tabs and all
     * following lines inserted will be indented using 2 tabs as well.
     */ InsertTextMode.adjustIndentation = 2;
                })(InsertTextMode || (InsertTextMode = {}));
                var CompletionItemLabelDetails;
                (function(CompletionItemLabelDetails) {
                    var is = function is(value) {
                        var candidate = value;
                        return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) && (Is.string(candidate.description) || candidate.description === undefined);
                    };
                    CompletionItemLabelDetails.is = is;
                })(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
                /**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */ var CompletionItem;
                (function(CompletionItem) {
                    var create = /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */ function create(label) {
                        return {
                            label: label
                        };
                    };
                    CompletionItem.create = create;
                })(CompletionItem || (CompletionItem = {}));
                /**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */ var CompletionList;
                (function(CompletionList) {
                    var create = /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */ function create(items, isIncomplete) {
                        return {
                            items: items ? items : [],
                            isIncomplete: !!isIncomplete
                        };
                    };
                    CompletionList.create = create;
                })(CompletionList || (CompletionList = {}));
                var MarkedString1;
                (function(MarkedString1) {
                    var fromPlainText = /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */ function fromPlainText(plainText) {
                        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&"); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
                    };
                    var is = /**
     * Checks whether the given value conforms to the [MarkedString](#MarkedString) type.
     */ function is(value) {
                        var candidate = value;
                        return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
                    };
                    MarkedString1.fromPlainText = fromPlainText;
                    MarkedString1.is = is;
                })(MarkedString1 || (MarkedString1 = {}));
                var Hover;
                (function(Hover) {
                    var is = /**
     * Checks whether the given value conforms to the [Hover](#Hover) interface.
     */ function is(value) {
                        var candidate = value;
                        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent1.is(candidate.contents) || MarkedString1.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString1.is)) && (value.range === undefined || Range.is(value.range));
                    };
                    Hover.is = is;
                })(Hover || (Hover = {}));
                /**
 * The ParameterInformation namespace provides helper functions to work with
 * [ParameterInformation](#ParameterInformation) literals.
 */ var ParameterInformation;
                (function(ParameterInformation) {
                    var create = /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */ function create(label, documentation) {
                        return documentation ? {
                            label: label,
                            documentation: documentation
                        } : {
                            label: label
                        };
                    };
                    ParameterInformation.create = create;
                })(ParameterInformation || (ParameterInformation = {}));
                /**
 * The SignatureInformation namespace provides helper functions to work with
 * [SignatureInformation](#SignatureInformation) literals.
 */ var SignatureInformation;
                (function(SignatureInformation) {
                    var create = function create(label, documentation) {
                        var parameters = [];
                        for(var _i = 2; _i < arguments.length; _i++){
                            parameters[_i - 2] = arguments[_i];
                        }
                        var result = {
                            label: label
                        };
                        if (Is.defined(documentation)) {
                            result.documentation = documentation;
                        }
                        if (Is.defined(parameters)) {
                            result.parameters = parameters;
                        } else {
                            result.parameters = [];
                        }
                        return result;
                    };
                    SignatureInformation.create = create;
                })(SignatureInformation || (SignatureInformation = {}));
                /**
 * A document highlight kind.
 */ var DocumentHighlightKind;
                (function(DocumentHighlightKind) {
                    /**
     * A textual occurrence.
     */ DocumentHighlightKind.Text = 1;
                    /**
     * Read-access of a symbol, like reading a variable.
     */ DocumentHighlightKind.Read = 2;
                    /**
     * Write-access of a symbol, like writing to a variable.
     */ DocumentHighlightKind.Write = 3;
                })(DocumentHighlightKind || (DocumentHighlightKind = {}));
                /**
 * DocumentHighlight namespace to provide helper functions to work with
 * [DocumentHighlight](#DocumentHighlight) literals.
 */ var DocumentHighlight;
                (function(DocumentHighlight) {
                    var create = /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     * @param kind The highlight kind
     */ function create(range, kind) {
                        var result = {
                            range: range
                        };
                        if (Is.number(kind)) {
                            result.kind = kind;
                        }
                        return result;
                    };
                    DocumentHighlight.create = create;
                })(DocumentHighlight || (DocumentHighlight = {}));
                /**
 * A symbol kind.
 */ var SymbolKind;
                (function(SymbolKind) {
                    SymbolKind.File = 1;
                    SymbolKind.Module = 2;
                    SymbolKind.Namespace = 3;
                    SymbolKind.Package = 4;
                    SymbolKind.Class = 5;
                    SymbolKind.Method = 6;
                    SymbolKind.Property = 7;
                    SymbolKind.Field = 8;
                    SymbolKind.Constructor = 9;
                    SymbolKind.Enum = 10;
                    SymbolKind.Interface = 11;
                    SymbolKind.Function = 12;
                    SymbolKind.Variable = 13;
                    SymbolKind.Constant = 14;
                    SymbolKind.String = 15;
                    SymbolKind.Number = 16;
                    SymbolKind.Boolean = 17;
                    SymbolKind.Array = 18;
                    SymbolKind.Object = 19;
                    SymbolKind.Key = 20;
                    SymbolKind.Null = 21;
                    SymbolKind.EnumMember = 22;
                    SymbolKind.Struct = 23;
                    SymbolKind.Event = 24;
                    SymbolKind.Operator = 25;
                    SymbolKind.TypeParameter = 26;
                })(SymbolKind || (SymbolKind = {}));
                /**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 *
 * @since 3.16
 */ var SymbolTag;
                (function(SymbolTag) {
                    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */ SymbolTag.Deprecated = 1;
                })(SymbolTag || (SymbolTag = {}));
                var SymbolInformation;
                (function(SymbolInformation) {
                    var create = /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol.
     * @param containerName The name of the symbol containing the symbol.
     */ function create(name, kind, range, uri, containerName) {
                        var result = {
                            name: name,
                            kind: kind,
                            location: {
                                uri: uri,
                                range: range
                            }
                        };
                        if (containerName) {
                            result.containerName = containerName;
                        }
                        return result;
                    };
                    SymbolInformation.create = create;
                })(SymbolInformation || (SymbolInformation = {}));
                var WorkspaceSymbol;
                (function(WorkspaceSymbol) {
                    var create = /**
     * Create a new workspace symbol.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param uri The resource of the location of the symbol.
     * @param range An options range of the location.
     * @returns A WorkspaceSymbol.
     */ function create(name, kind, uri, range) {
                        return range !== undefined ? {
                            name: name,
                            kind: kind,
                            location: {
                                uri: uri,
                                range: range
                            }
                        } : {
                            name: name,
                            kind: kind,
                            location: {
                                uri: uri
                            }
                        };
                    };
                    WorkspaceSymbol.create = create;
                })(WorkspaceSymbol || (WorkspaceSymbol = {}));
                var DocumentSymbol;
                (function(DocumentSymbol) {
                    var create = /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */ function create(name, detail, kind, range, selectionRange, children) {
                        var result = {
                            name: name,
                            detail: detail,
                            kind: kind,
                            range: range,
                            selectionRange: selectionRange
                        };
                        if (children !== undefined) {
                            result.children = children;
                        }
                        return result;
                    };
                    var is = /**
     * Checks whether the given literal conforms to the [DocumentSymbol](#DocumentSymbol) interface.
     */ function is(value) {
                        var candidate = value;
                        return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === undefined || Is.string(candidate.detail)) && (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) && (candidate.children === undefined || Array.isArray(candidate.children)) && (candidate.tags === undefined || Array.isArray(candidate.tags));
                    };
                    DocumentSymbol.create = create;
                    DocumentSymbol.is = is;
                })(DocumentSymbol || (DocumentSymbol = {}));
                /**
 * A set of predefined code action kinds
 */ var CodeActionKind;
                (function(CodeActionKind) {
                    /**
     * Empty kind.
     */ CodeActionKind.Empty = "";
                    /**
     * Base kind for quickfix actions: 'quickfix'
     */ CodeActionKind.QuickFix = "quickfix";
                    /**
     * Base kind for refactoring actions: 'refactor'
     */ CodeActionKind.Refactor = "refactor";
                    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */ CodeActionKind.RefactorExtract = "refactor.extract";
                    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */ CodeActionKind.RefactorInline = "refactor.inline";
                    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */ CodeActionKind.RefactorRewrite = "refactor.rewrite";
                    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */ CodeActionKind.Source = "source";
                    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */ CodeActionKind.SourceOrganizeImports = "source.organizeImports";
                    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */ CodeActionKind.SourceFixAll = "source.fixAll";
                })(CodeActionKind || (CodeActionKind = {}));
                /**
 * The reason why code actions were requested.
 *
 * @since 3.17.0
 */ var CodeActionTriggerKind;
                (function(CodeActionTriggerKind) {
                    /**
     * Code actions were explicitly requested by the user or by an extension.
     */ CodeActionTriggerKind.Invoked = 1;
                    /**
     * Code actions were requested automatically.
     *
     * This typically happens when current selection in a file changes, but can
     * also be triggered when file content changes.
     */ CodeActionTriggerKind.Automatic = 2;
                })(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
                /**
 * The CodeActionContext namespace provides helper functions to work with
 * [CodeActionContext](#CodeActionContext) literals.
 */ var CodeActionContext;
                (function(CodeActionContext) {
                    var create = /**
     * Creates a new CodeActionContext literal.
     */ function create(diagnostics, only, triggerKind) {
                        var result = {
                            diagnostics: diagnostics
                        };
                        if (only !== undefined && only !== null) {
                            result.only = only;
                        }
                        if (triggerKind !== undefined && triggerKind !== null) {
                            result.triggerKind = triggerKind;
                        }
                        return result;
                    };
                    var is = /**
     * Checks whether the given literal conforms to the [CodeActionContext](#CodeActionContext) interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
                    };
                    CodeActionContext.create = create;
                    CodeActionContext.is = is;
                })(CodeActionContext || (CodeActionContext = {}));
                var CodeAction;
                (function(CodeAction) {
                    var create = function create(title, kindOrCommandOrEdit, kind) {
                        var result = {
                            title: title
                        };
                        var checkKind = true;
                        if (typeof kindOrCommandOrEdit === "string") {
                            checkKind = false;
                            result.kind = kindOrCommandOrEdit;
                        } else if (Command.is(kindOrCommandOrEdit)) {
                            result.command = kindOrCommandOrEdit;
                        } else {
                            result.edit = kindOrCommandOrEdit;
                        }
                        if (checkKind && kind !== undefined) {
                            result.kind = kind;
                        }
                        return result;
                    };
                    var is = function is(value) {
                        var candidate = value;
                        return candidate && Is.string(candidate.title) && (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === undefined || Is.string(candidate.kind)) && (candidate.edit !== undefined || candidate.command !== undefined) && (candidate.command === undefined || Command.is(candidate.command)) && (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) && (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
                    };
                    CodeAction.create = create;
                    CodeAction.is = is;
                })(CodeAction || (CodeAction = {}));
                /**
 * The CodeLens namespace provides helper functions to work with
 * [CodeLens](#CodeLens) literals.
 */ var CodeLens;
                (function(CodeLens) {
                    var create = /**
     * Creates a new CodeLens literal.
     */ function create(range, data) {
                        var result = {
                            range: range
                        };
                        if (Is.defined(data)) {
                            result.data = data;
                        }
                        return result;
                    };
                    var is = /**
     * Checks whether the given literal conforms to the [CodeLens](#CodeLens) interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
                    };
                    CodeLens.create = create;
                    CodeLens.is = is;
                })(CodeLens || (CodeLens = {}));
                /**
 * The FormattingOptions namespace provides helper functions to work with
 * [FormattingOptions](#FormattingOptions) literals.
 */ var FormattingOptions;
                (function(FormattingOptions) {
                    var create = /**
     * Creates a new FormattingOptions literal.
     */ function create(tabSize, insertSpaces) {
                        return {
                            tabSize: tabSize,
                            insertSpaces: insertSpaces
                        };
                    };
                    var is = /**
     * Checks whether the given literal conforms to the [FormattingOptions](#FormattingOptions) interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
                    };
                    FormattingOptions.create = create;
                    FormattingOptions.is = is;
                })(FormattingOptions || (FormattingOptions = {}));
                /**
 * The DocumentLink namespace provides helper functions to work with
 * [DocumentLink](#DocumentLink) literals.
 */ var DocumentLink;
                (function(DocumentLink) {
                    var create = /**
     * Creates a new DocumentLink literal.
     */ function create(range, target, data) {
                        return {
                            range: range,
                            target: target,
                            data: data
                        };
                    };
                    var is = /**
     * Checks whether the given literal conforms to the [DocumentLink](#DocumentLink) interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
                    };
                    DocumentLink.create = create;
                    DocumentLink.is = is;
                })(DocumentLink || (DocumentLink = {}));
                /**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */ var SelectionRange;
                (function(SelectionRange) {
                    var create = /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */ function create(range, parent) {
                        return {
                            range: range,
                            parent: parent
                        };
                    };
                    var is = function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
                    };
                    SelectionRange.create = create;
                    SelectionRange.is = is;
                })(SelectionRange || (SelectionRange = {}));
                /**
 * A set of predefined token types. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */ var SemanticTokenTypes;
                (function(SemanticTokenTypes) {
                    SemanticTokenTypes["namespace"] = "namespace";
                    /**
     * Represents a generic type. Acts as a fallback for types which can't be mapped to
     * a specific type like class or enum.
     */ SemanticTokenTypes["type"] = "type";
                    SemanticTokenTypes["class"] = "class";
                    SemanticTokenTypes["enum"] = "enum";
                    SemanticTokenTypes["interface"] = "interface";
                    SemanticTokenTypes["struct"] = "struct";
                    SemanticTokenTypes["typeParameter"] = "typeParameter";
                    SemanticTokenTypes["parameter"] = "parameter";
                    SemanticTokenTypes["variable"] = "variable";
                    SemanticTokenTypes["property"] = "property";
                    SemanticTokenTypes["enumMember"] = "enumMember";
                    SemanticTokenTypes["event"] = "event";
                    SemanticTokenTypes["function"] = "function";
                    SemanticTokenTypes["method"] = "method";
                    SemanticTokenTypes["macro"] = "macro";
                    SemanticTokenTypes["keyword"] = "keyword";
                    SemanticTokenTypes["modifier"] = "modifier";
                    SemanticTokenTypes["comment"] = "comment";
                    SemanticTokenTypes["string"] = "string";
                    SemanticTokenTypes["number"] = "number";
                    SemanticTokenTypes["regexp"] = "regexp";
                    SemanticTokenTypes["operator"] = "operator";
                    /**
     * @since 3.17.0
     */ SemanticTokenTypes["decorator"] = "decorator";
                })(SemanticTokenTypes || (SemanticTokenTypes = {}));
                /**
 * A set of predefined token modifiers. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */ var SemanticTokenModifiers;
                (function(SemanticTokenModifiers) {
                    SemanticTokenModifiers["declaration"] = "declaration";
                    SemanticTokenModifiers["definition"] = "definition";
                    SemanticTokenModifiers["readonly"] = "readonly";
                    SemanticTokenModifiers["static"] = "static";
                    SemanticTokenModifiers["deprecated"] = "deprecated";
                    SemanticTokenModifiers["abstract"] = "abstract";
                    SemanticTokenModifiers["async"] = "async";
                    SemanticTokenModifiers["modification"] = "modification";
                    SemanticTokenModifiers["documentation"] = "documentation";
                    SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";
                })(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokens;
                (function(SemanticTokens) {
                    var is = function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
                    };
                    SemanticTokens.is = is;
                })(SemanticTokens || (SemanticTokens = {}));
                /**
 * The InlineValueText namespace provides functions to deal with InlineValueTexts.
 *
 * @since 3.17.0
 */ var InlineValueText;
                (function(InlineValueText) {
                    var create = /**
     * Creates a new InlineValueText literal.
     */ function create(range, text) {
                        return {
                            range: range,
                            text: text
                        };
                    };
                    var is = function is(value) {
                        var candidate = value;
                        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
                    };
                    InlineValueText.create = create;
                    InlineValueText.is = is;
                })(InlineValueText || (InlineValueText = {}));
                /**
 * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.
 *
 * @since 3.17.0
 */ var InlineValueVariableLookup;
                (function(InlineValueVariableLookup) {
                    var create = /**
     * Creates a new InlineValueText literal.
     */ function create(range, variableName, caseSensitiveLookup) {
                        return {
                            range: range,
                            variableName: variableName,
                            caseSensitiveLookup: caseSensitiveLookup
                        };
                    };
                    var is = function is(value) {
                        var candidate = value;
                        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === undefined);
                    };
                    InlineValueVariableLookup.create = create;
                    InlineValueVariableLookup.is = is;
                })(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
                /**
 * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.
 *
 * @since 3.17.0
 */ var InlineValueEvaluatableExpression;
                (function(InlineValueEvaluatableExpression) {
                    var create = /**
     * Creates a new InlineValueEvaluatableExpression literal.
     */ function create(range, expression) {
                        return {
                            range: range,
                            expression: expression
                        };
                    };
                    var is = function is(value) {
                        var candidate = value;
                        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === undefined);
                    };
                    InlineValueEvaluatableExpression.create = create;
                    InlineValueEvaluatableExpression.is = is;
                })(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
                /**
 * The InlineValueContext namespace provides helper functions to work with
 * [InlineValueContext](#InlineValueContext) literals.
 *
 * @since 3.17.0
 */ var InlineValueContext;
                (function(InlineValueContext) {
                    var create = /**
     * Creates a new InlineValueContext literal.
     */ function create(frameId, stoppedLocation) {
                        return {
                            frameId: frameId,
                            stoppedLocation: stoppedLocation
                        };
                    };
                    var is = /**
     * Checks whether the given literal conforms to the [InlineValueContext](#InlineValueContext) interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Range.is(value.stoppedLocation);
                    };
                    InlineValueContext.create = create;
                    InlineValueContext.is = is;
                })(InlineValueContext || (InlineValueContext = {}));
                /**
 * Inlay hint kinds.
 *
 * @since 3.17.0
 */ var InlayHintKind;
                (function(InlayHintKind) {
                    var is = function is(value) {
                        return value === 1 || value === 2;
                    };
                    /**
     * An inlay hint that for a type annotation.
     */ InlayHintKind.Type = 1;
                    /**
     * An inlay hint that is for a parameter.
     */ InlayHintKind.Parameter = 2;
                    InlayHintKind.is = is;
                })(InlayHintKind || (InlayHintKind = {}));
                var InlayHintLabelPart;
                (function(InlayHintLabelPart) {
                    var create = function create(value) {
                        return {
                            value: value
                        };
                    };
                    var is = function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent1.is(candidate.tooltip)) && (candidate.location === undefined || Location.is(candidate.location)) && (candidate.command === undefined || Command.is(candidate.command));
                    };
                    InlayHintLabelPart.create = create;
                    InlayHintLabelPart.is = is;
                })(InlayHintLabelPart || (InlayHintLabelPart = {}));
                var InlayHint;
                (function(InlayHint) {
                    var create = function create(position, label, kind) {
                        var result = {
                            position: position,
                            label: label
                        };
                        if (kind !== undefined) {
                            result.kind = kind;
                        }
                        return result;
                    };
                    var is = function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === undefined || InlayHintKind.is(candidate.kind)) && candidate.textEdits === undefined || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent1.is(candidate.tooltip)) && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));
                    };
                    InlayHint.create = create;
                    InlayHint.is = is;
                })(InlayHint || (InlayHint = {}));
                var WorkspaceFolder;
                (function(WorkspaceFolder) {
                    var is = function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
                    };
                    WorkspaceFolder.is = is;
                })(WorkspaceFolder || (WorkspaceFolder = {}));
                var EOL = [
                    "\n",
                    "\r\n",
                    "\r"
                ];
                /**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */ var TextDocument;
                (function(TextDocument) {
                    var create = /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId The document's language Id.
     * @param version The document's version.
     * @param content The document's content.
     */ function create(uri, languageId, version, content) {
                        return new FullTextDocument(uri, languageId, version, content);
                    };
                    var is = /**
     * Checks whether the given literal conforms to the [ITextDocument](#ITextDocument) interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
                    };
                    var applyEdits = function applyEdits(document1, edits) {
                        var text = document1.getText();
                        var sortedEdits = mergeSort(edits, function(a, b) {
                            var diff = a.range.start.line - b.range.start.line;
                            if (diff === 0) {
                                return a.range.start.character - b.range.start.character;
                            }
                            return diff;
                        });
                        var lastModifiedOffset = text.length;
                        for(var i = sortedEdits.length - 1; i >= 0; i--){
                            var e = sortedEdits[i];
                            var startOffset = document1.offsetAt(e.range.start);
                            var endOffset = document1.offsetAt(e.range.end);
                            if (endOffset <= lastModifiedOffset) {
                                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
                            } else {
                                throw new Error("Overlapping edit");
                            }
                            lastModifiedOffset = startOffset;
                        }
                        return text;
                    };
                    TextDocument.create = create;
                    TextDocument.is = is;
                    TextDocument.applyEdits = applyEdits;
                    function mergeSort(data, compare) {
                        if (data.length <= 1) {
                            // sorted
                            return data;
                        }
                        var p = data.length / 2 | 0;
                        var left = data.slice(0, p);
                        var right = data.slice(p);
                        mergeSort(left, compare);
                        mergeSort(right, compare);
                        var leftIdx = 0;
                        var rightIdx = 0;
                        var i = 0;
                        while(leftIdx < left.length && rightIdx < right.length){
                            var ret = compare(left[leftIdx], right[rightIdx]);
                            if (ret <= 0) {
                                // smaller_equal -> take left to preserve order
                                data[i++] = left[leftIdx++];
                            } else {
                                // greater -> take right
                                data[i++] = right[rightIdx++];
                            }
                        }
                        while(leftIdx < left.length){
                            data[i++] = left[leftIdx++];
                        }
                        while(rightIdx < right.length){
                            data[i++] = right[rightIdx++];
                        }
                        return data;
                    }
                })(TextDocument || (TextDocument = {}));
                /**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */ var FullTextDocument = /** @class */ function() {
                    var FullTextDocument = function FullTextDocument(uri, languageId, version, content) {
                        this._uri = uri;
                        this._languageId = languageId;
                        this._version = version;
                        this._content = content;
                        this._lineOffsets = undefined;
                    };
                    Object.defineProperty(FullTextDocument.prototype, "uri", {
                        get: function get() {
                            return this._uri;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(FullTextDocument.prototype, "languageId", {
                        get: function get() {
                            return this._languageId;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(FullTextDocument.prototype, "version", {
                        get: function get() {
                            return this._version;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    FullTextDocument.prototype.getText = function(range) {
                        if (range) {
                            var start = this.offsetAt(range.start);
                            var end = this.offsetAt(range.end);
                            return this._content.substring(start, end);
                        }
                        return this._content;
                    };
                    FullTextDocument.prototype.update = function(event, version) {
                        this._content = event.text;
                        this._version = version;
                        this._lineOffsets = undefined;
                    };
                    FullTextDocument.prototype.getLineOffsets = function() {
                        if (this._lineOffsets === undefined) {
                            var lineOffsets = [];
                            var text = this._content;
                            var isLineStart = true;
                            for(var i = 0; i < text.length; i++){
                                if (isLineStart) {
                                    lineOffsets.push(i);
                                    isLineStart = false;
                                }
                                var ch = text.charAt(i);
                                isLineStart = ch === "\r" || ch === "\n";
                                if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
                                    i++;
                                }
                            }
                            if (isLineStart && text.length > 0) {
                                lineOffsets.push(text.length);
                            }
                            this._lineOffsets = lineOffsets;
                        }
                        return this._lineOffsets;
                    };
                    FullTextDocument.prototype.positionAt = function(offset) {
                        offset = Math.max(Math.min(offset, this._content.length), 0);
                        var lineOffsets = this.getLineOffsets();
                        var low = 0, high = lineOffsets.length;
                        if (high === 0) {
                            return Position.create(0, offset);
                        }
                        while(low < high){
                            var mid = Math.floor((low + high) / 2);
                            if (lineOffsets[mid] > offset) {
                                high = mid;
                            } else {
                                low = mid + 1;
                            }
                        }
                        // low is the least x for which the line offset is larger than the current offset
                        // or array.length if no line offset is larger than the current offset
                        var line = low - 1;
                        return Position.create(line, offset - lineOffsets[line]);
                    };
                    FullTextDocument.prototype.offsetAt = function(position) {
                        var lineOffsets = this.getLineOffsets();
                        if (position.line >= lineOffsets.length) {
                            return this._content.length;
                        } else if (position.line < 0) {
                            return 0;
                        }
                        var lineOffset = lineOffsets[position.line];
                        var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
                        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
                    };
                    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
                        get: function get() {
                            return this.getLineOffsets().length;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    return FullTextDocument;
                }();
                var Is;
                (function(Is) {
                    var defined = function defined(value) {
                        return typeof value !== "undefined";
                    };
                    var undefined1 = function undefined1(value) {
                        return typeof value === "undefined";
                    };
                    var boolean = function boolean(value) {
                        return value === true || value === false;
                    };
                    var string = function string(value) {
                        return toString.call(value) === "[object String]";
                    };
                    var number = function number(value) {
                        return toString.call(value) === "[object Number]";
                    };
                    var numberRange = function numberRange(value, min, max) {
                        return toString.call(value) === "[object Number]" && min <= value && value <= max;
                    };
                    var integer = function integer(value) {
                        return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
                    };
                    var uinteger = function uinteger(value) {
                        return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
                    };
                    var func = function func(value) {
                        return toString.call(value) === "[object Function]";
                    };
                    var objectLiteral = function objectLiteral(value) {
                        // Strictly speaking class instances pass this check as well. Since the LSP
                        // doesn't use classes we ignore this for now. If we do we need to add something
                        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
                        return value !== null && typeof value === "object";
                    };
                    var typedArray = function typedArray(value, check) {
                        return Array.isArray(value) && value.every(check);
                    };
                    var toString = Object.prototype.toString;
                    Is.defined = defined;
                    Is.undefined = undefined1;
                    Is.boolean = boolean;
                    Is.string = string;
                    Is.number = number;
                    Is.numberRange = numberRange;
                    Is.integer = integer;
                    Is.uinteger = uinteger;
                    Is.func = func;
                    Is.objectLiteral = objectLiteral;
                    Is.typedArray = typedArray;
                })(Is || (Is = {}));
            /***/ },
            /***/ 2094: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_2239072__) {
                "use strict";
                var forEach = __nested_webpack_require_2239072__(3243);
                var availableTypedArrays = __nested_webpack_require_2239072__(2191);
                var callBound = __nested_webpack_require_2239072__(2680);
                var gOPD = __nested_webpack_require_2239072__(326);
                var $toString = callBound("Object.prototype.toString");
                var hasToStringTag = __nested_webpack_require_2239072__(7226)();
                var g = typeof globalThis === "undefined" ? __nested_webpack_require_2239072__.g : globalThis;
                var typedArrays = availableTypedArrays();
                var $slice = callBound("String.prototype.slice");
                var toStrTags = {};
                var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
                if (hasToStringTag && gOPD && getPrototypeOf) {
                    forEach(typedArrays, function(typedArray) {
                        if (typeof g[typedArray] === "function") {
                            var arr = new g[typedArray]();
                            if (Symbol.toStringTag in arr) {
                                var proto = getPrototypeOf(arr);
                                var descriptor = gOPD(proto, Symbol.toStringTag);
                                if (!descriptor) {
                                    var superProto = getPrototypeOf(proto);
                                    descriptor = gOPD(superProto, Symbol.toStringTag);
                                }
                                toStrTags[typedArray] = descriptor.get;
                            }
                        }
                    });
                }
                var tryTypedArrays = function tryAllTypedArrays(value) {
                    var foundName = false;
                    forEach(toStrTags, function(getter, typedArray) {
                        if (!foundName) {
                            try {
                                var name = getter.call(value);
                                if (name === typedArray) {
                                    foundName = name;
                                }
                            } catch (e) {}
                        }
                    });
                    return foundName;
                };
                var isTypedArray = __nested_webpack_require_2239072__(198);
                module1.exports = function whichTypedArray(value) {
                    if (!isTypedArray(value)) {
                        return false;
                    }
                    if (!hasToStringTag || !(Symbol.toStringTag in value)) {
                        return $slice($toString(value), 8, -1);
                    }
                    return tryTypedArrays(value);
                };
            /***/ },
            /***/ 2191: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_2241914__) {
                "use strict";
                var possibleNames = [
                    "BigInt64Array",
                    "BigUint64Array",
                    "Float32Array",
                    "Float64Array",
                    "Int16Array",
                    "Int32Array",
                    "Int8Array",
                    "Uint16Array",
                    "Uint32Array",
                    "Uint8Array",
                    "Uint8ClampedArray"
                ];
                var g = typeof globalThis === "undefined" ? __nested_webpack_require_2241914__.g : globalThis;
                module1.exports = function availableTypedArrays() {
                    var out = [];
                    for(var i = 0; i < possibleNames.length; i++){
                        if (typeof g[possibleNames[i]] === "function") {
                            out[out.length] = possibleNames[i];
                        }
                    }
                    return out;
                };
            /***/ }
        };
        /************************************************************************/ /******/ // The module cache
        /******/ var __webpack_module_cache__ = {};
        /******/ /******/ // The require function
        /******/ function __nested_webpack_require_2243179__(moduleId) {
            /******/ // Check if module is in cache
            /******/ var cachedModule = __webpack_module_cache__[moduleId];
            /******/ if (cachedModule !== undefined) {
                /******/ return cachedModule.exports;
            /******/ }
            /******/ // Create a new module (and put it into the cache)
            /******/ var module1 = __webpack_module_cache__[moduleId] = {
                /******/ id: moduleId,
                /******/ loaded: false,
                /******/ exports: {}
            };
            /******/ /******/ // Execute the module function
            /******/ __webpack_modules__[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_2243179__);
            /******/ /******/ // Flag the module as loaded
            /******/ module1.loaded = true;
            /******/ /******/ // Return the exports of the module
            /******/ return module1.exports;
        /******/ }
        /******/ /************************************************************************/ /******/ /* webpack/runtime/define property getters */ /******/ (function() {
            /******/ // define getter functions for harmony exports
            /******/ __nested_webpack_require_2243179__.d = function(exports1, definition) {
                /******/ for(var key in definition){
                    /******/ if (__nested_webpack_require_2243179__.o(definition, key) && !__nested_webpack_require_2243179__.o(exports1, key)) {
                        /******/ Object.defineProperty(exports1, key, {
                            enumerable: true,
                            get: definition[key]
                        });
                    /******/ }
                /******/ }
            /******/ };
        /******/ })();
        /******/ /******/ /* webpack/runtime/global */ /******/ (function() {
            /******/ __nested_webpack_require_2243179__.g = function() {
                /******/ if (typeof globalThis === "object") return globalThis;
                /******/ try {
                    /******/ return this || new Function("return this")();
                /******/ } catch (e) {
                    /******/ if (typeof window === "object") return window;
                /******/ }
            /******/ }();
        /******/ })();
        /******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ (function() {
            /******/ __nested_webpack_require_2243179__.o = function(obj, prop) {
                return Object.prototype.hasOwnProperty.call(obj, prop);
            };
        /******/ })();
        /******/ /******/ /* webpack/runtime/make namespace object */ /******/ (function() {
            /******/ // define __esModule on exports
            /******/ __nested_webpack_require_2243179__.r = function(exports1) {
                /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                    /******/ Object.defineProperty(exports1, Symbol.toStringTag, {
                        value: "Module"
                    });
                /******/ }
                /******/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
            /******/ };
        /******/ })();
        /******/ /******/ /* webpack/runtime/node module decorator */ /******/ (function() {
            /******/ __nested_webpack_require_2243179__.nmd = function(module1) {
                /******/ module1.paths = [];
                /******/ if (!module1.children) module1.children = [];
                /******/ return module1;
            /******/ };
        /******/ })();
        /******/ /************************************************************************/ var __webpack_exports__ = {};
        // This entry need to be wrapped in an IIFE because it need to be in strict mode.
        (function() {
            "use strict";
            var _define_property = function _define_property(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                } else {
                    obj[key] = value;
                }
                return obj;
            };
            var _object_spread = function _object_spread(target) {
                for(var i = 1; i < arguments.length; i++){
                    var source = arguments[i] != null ? arguments[i] : {};
                    var ownKeys = Object.keys(source);
                    if (typeof Object.getOwnPropertySymbols === "function") {
                        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                        }));
                    }
                    ownKeys.forEach(function(key) {
                        _define_property(target, key, source[key]);
                    });
                }
                return target;
            };
            var notEmpty = function notEmpty(value) {
                return value !== null && value !== undefined;
            };
            var checkValueAgainstRegexpArray = function checkValueAgainstRegexpArray(value, regexpArray) {
                if (!regexpArray) {
                    return false;
                }
                for(var i = 0; i < regexpArray.length; i++){
                    if (regexpArray[i].test(value)) {
                        return true;
                    }
                }
                return false;
            };
            var computeLineOffsets = function computeLineOffsets(text, isAtLineStart, textOffset) {
                if (textOffset === void 0) {
                    textOffset = 0;
                }
                var result = isAtLineStart ? [
                    textOffset
                ] : [];
                for(var i = 0; i < text.length; i++){
                    var ch = text.charCodeAt(i);
                    if (ch === 13 /* CharCode.CarriageReturn */  || ch === 10 /* CharCode.LineFeed */ ) {
                        if (ch === 13 /* CharCode.CarriageReturn */  && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */ ) {
                            i++;
                        }
                        result.push(textOffset + i + 1);
                    }
                }
                return result;
            };
            var getWellformedRange = function getWellformedRange(range) {
                var start = range.start;
                var end = range.end;
                if (start.line > end.line || start.line === end.line && start.character > end.character) {
                    return {
                        start: end,
                        end: start
                    };
                }
                return range;
            };
            var getWellformedEdit = function getWellformedEdit(textEdit) {
                var range = getWellformedRange(textEdit.range);
                if (range !== textEdit.range) {
                    return {
                        newText: textEdit.newText,
                        range: range
                    };
                }
                return textEdit;
            };
            var asyncGeneratorStep = function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
                try {
                    var info = gen[key](arg);
                    var value = info.value;
                } catch (error) {
                    reject(error);
                    return;
                }
                if (info.done) {
                    resolve(value);
                } else {
                    Promise.resolve(value).then(_next, _throw);
                }
            };
            var _async_to_generator = function _async_to_generator(fn) {
                return function() {
                    var _$self = this, args = arguments;
                    return new Promise(function(resolve, reject) {
                        var gen = fn.apply(_$self, args);
                        function _next(value) {
                            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
                        }
                        function _throw(err) {
                            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
                        }
                        _next(undefined);
                    });
                };
            };
            var _class_call_check = function _class_call_check(instance, Constructor) {
                if (!_instanceof(instance, Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                }
            };
            var _defineProperties = function _defineProperties(target, props) {
                for(var i = 0; i < props.length; i++){
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                }
            };
            var _create_class = function _create_class(Constructor, protoProps, staticProps) {
                if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                if (staticProps) _defineProperties(Constructor, staticProps);
                return Constructor;
            };
            var base_service_define_property = function base_service_define_property(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                } else {
                    obj[key] = value;
                }
                return obj;
            };
            var _ts_generator = function _ts_generator(thisArg, body) {
                var f, y, t, g, _ = {
                    label: 0,
                    sent: function sent() {
                        if (t[0] & 1) throw t[1];
                        return t[1];
                    },
                    trys: [],
                    ops: []
                };
                return g = {
                    next: verb(0),
                    "throw": verb(1),
                    "return": verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
                    return this;
                }), g;
                function verb(n) {
                    return function(v) {
                        return step([
                            n,
                            v
                        ]);
                    };
                }
                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while(_)try {
                        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [
                            op[0] & 2,
                            t.value
                        ];
                        switch(op[0]){
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {
                                    value: op[1],
                                    done: false
                                };
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [
                                    0
                                ];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue;
                                }
                                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                    _.label = op[1];
                                    break;
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break;
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break;
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue;
                        }
                        op = body.call(thisArg, _);
                    } catch (e) {
                        op = [
                            6,
                            e
                        ];
                        y = 0;
                    } finally{
                        f = t = 0;
                    }
                    if (op[0] & 5) throw op[1];
                    return {
                        value: op[0] ? op[1] : void 0,
                        done: true
                    };
                }
            };
            var fromRange = function fromRange(range) {
                return {
                    start: {
                        line: range.start.row,
                        character: range.start.column
                    },
                    end: {
                        line: range.end.row,
                        character: range.end.column
                    }
                };
            };
            var rangeFromPositions = function rangeFromPositions(start, end) {
                return {
                    start: start,
                    end: end
                };
            };
            var toRange = function toRange(range) {
                return new AceRange(range.start.line, range.start.character, range.end.line, range.end.character);
            };
            var fromPoint = function fromPoint(point) {
                return {
                    line: point.row,
                    character: point.column
                };
            };
            var toPoint = function toPoint(position) {
                return {
                    row: position.line,
                    column: position.character
                };
            };
            var toAnnotations = function toAnnotations(diagnostics) {
                return diagnostics.map(function(el) {
                    return {
                        row: el.range.start.line,
                        column: el.range.start.character,
                        text: el.message,
                        type: el.severity === 1 ? "error" : el.severity === 2 ? "warning" : "info"
                    };
                });
            };
            var toCompletion = function toCompletion(item) {
                var _item_textEdit, _item_command;
                var itemKind = item.kind;
                var kind = itemKind ? Object.keys(CompletionItemKind)[Object.values(CompletionItemKind).indexOf(itemKind)] : undefined;
                var _item_textEdit_newText, _ref;
                var text = (_ref = (_item_textEdit_newText = (_item_textEdit = item.textEdit) === null || _item_textEdit === void 0 ? void 0 : _item_textEdit.newText) !== null && _item_textEdit_newText !== void 0 ? _item_textEdit_newText : item.insertText) !== null && _ref !== void 0 ? _ref : item.label;
                var command = ((_item_command = item.command) === null || _item_command === void 0 ? void 0 : _item_command.command) == "editor.action.triggerSuggest" ? "startAutocomplete" : undefined;
                var range = item.textEdit ? getTextEditRange(item.textEdit) : undefined;
                var completion = {
                    meta: kind,
                    caption: item.label,
                    command: command,
                    range: range,
                    value: "",
                    score: undefined,
                    item: item
                };
                if (item.insertTextFormat == InsertTextFormat.Snippet) {
                    completion["snippet"] = text;
                } else {
                    completion["value"] = text;
                }
                completion["documentation"] = item.documentation; //TODO: this is workaround for services with instant completion
                completion["position"] = item["position"];
                completion["service"] = item["service"]; //TODO: since we have multiple servers, we need to determine which
                // server to use for resolving
                return completion;
            };
            var toCompletions = function toCompletions(completions) {
                if (completions.length > 0) {
                    var combinedCompletions = completions.map(function(el) {
                        if (!el.completions) {
                            return [];
                        }
                        var allCompletions;
                        if (Array.isArray(el.completions)) {
                            allCompletions = el.completions;
                        } else {
                            allCompletions = el.completions.items;
                        }
                        return allCompletions.map(function(item) {
                            item["service"] = el.service;
                            return item;
                        });
                    }).flat();
                    return combinedCompletions.map(function(item) {
                        return toCompletion(item);
                    });
                }
                return [];
            };
            var toResolvedCompletion = function toResolvedCompletion(completion, item) {
                completion["docMarkdown"] = fromMarkupContent(item.documentation);
                return completion;
            };
            var toCompletionItem = function toCompletionItem(completion) {
                var command;
                if (completion["command"]) {
                    command = {
                        title: "triggerSuggest",
                        command: completion["command"]
                    };
                }
                var _completion_caption;
                var completionItem = {
                    label: (_completion_caption = completion.caption) !== null && _completion_caption !== void 0 ? _completion_caption : "",
                    kind: CommonConverter.convertKind(completion.meta),
                    command: command,
                    insertTextFormat: completion["snippet"] ? InsertTextFormat.Snippet : InsertTextFormat.PlainText,
                    documentation: completion["documentation"]
                };
                if (completion["range"]) {
                    var _completion_snippet;
                    completionItem.textEdit = {
                        range: fromRange(completion["range"]),
                        newText: (_completion_snippet = completion["snippet"]) !== null && _completion_snippet !== void 0 ? _completion_snippet : completion["value"]
                    };
                } else {
                    var _completion_snippet1;
                    completionItem.insertText = (_completion_snippet1 = completion["snippet"]) !== null && _completion_snippet1 !== void 0 ? _completion_snippet1 : completion["value"];
                }
                completionItem["fileName"] = completion["fileName"];
                completionItem["position"] = completion["position"];
                completionItem["item"] = completion["item"];
                completionItem["service"] = completion["service"]; //TODO:
                return completionItem;
            };
            var getTextEditRange = function getTextEditRange(textEdit) {
                if (textEdit.hasOwnProperty("insert") && textEdit.hasOwnProperty("replace")) {
                    textEdit = textEdit;
                    var rangeList = new RangeList();
                    rangeList.ranges = [
                        toRange(textEdit.insert),
                        toRange(textEdit.replace)
                    ];
                    rangeList.merge();
                    return rangeList[0];
                } else {
                    textEdit = textEdit;
                    return toRange(textEdit.range);
                }
            };
            var toTooltip = function toTooltip(hover) {
                if (!hover) return;
                var content = hover.map(function(el) {
                    if (MarkupContent.is(el.contents)) {
                        return fromMarkupContent(el.contents);
                    } else if (MarkedString.is(el.contents)) {
                        return "```" + el.contents.value + "```";
                    } else {
                        var contents = el.contents.map(function(el) {
                            if (typeof el !== "string") {
                                return "```".concat(el.value, "```");
                            } else {
                                return el;
                            }
                        });
                        return contents.join("\n\n");
                    }
                });
                //TODO: not to forget about `range` when we will have this feature in editor
                return {
                    content: {
                        type: "markdown",
                        text: content.join("\n\n")
                    }
                };
            };
            var fromSignatureHelp = function fromSignatureHelp(signatureHelp) {
                if (!signatureHelp) return;
                var content = signatureHelp.map(function(el) {
                    var signatureIndex = (el === null || el === void 0 ? void 0 : el.activeSignature) || 0;
                    var activeSignature = el.signatures[signatureIndex];
                    var activeParam = el === null || el === void 0 ? void 0 : el.activeParameter;
                    var contents = activeSignature.label;
                    if (activeParam != undefined && activeSignature.parameters && activeSignature.parameters[activeParam]) {
                        var param = activeSignature.parameters[activeParam].label;
                        if (typeof param == "string") {
                            contents = contents.replace(param, "**".concat(param, "**"));
                        }
                    }
                    if (activeSignature.documentation) {
                        if (MarkupContent.is(activeSignature.documentation)) {
                            return contents + "\n\n" + fromMarkupContent(activeSignature.documentation);
                        } else {
                            contents += "\n\n" + activeSignature.documentation;
                            return contents;
                        }
                    } else {
                        return contents;
                    }
                });
                return {
                    content: {
                        type: "markdown",
                        text: content.join("\n\n")
                    }
                };
            };
            var fromMarkupContent = function fromMarkupContent(content) {
                if (!content) return;
                if (typeof content === "string") {
                    return content;
                } else {
                    return content.value;
                }
            };
            var fromAceDelta = function fromAceDelta(delta, eol) {
                var text = delta.lines.length > 1 ? delta.lines.join(eol) : delta.lines[0];
                return {
                    range: delta.action === "insert" ? rangeFromPositions(fromPoint(delta.start), fromPoint(delta.start)) : rangeFromPositions(fromPoint(delta.start), fromPoint(delta.end)),
                    text: delta.action === "insert" ? text : ""
                };
            };
            var filterDiagnostics = function filterDiagnostics(diagnostics, filterErrors) {
                return common_converters_CommonConverter.excludeByErrorMessage(diagnostics, filterErrors.errorMessagesToIgnore).map(function(el) {
                    if (checkValueAgainstRegexpArray(el.message, filterErrors.errorMessagesToTreatAsWarning)) {
                        el.severity = main.DiagnosticSeverity.Warning;
                    } else if (checkValueAgainstRegexpArray(el.message, filterErrors.errorMessagesToTreatAsInfo)) {
                        el.severity = main.DiagnosticSeverity.Information;
                    }
                    return el;
                });
            };
            var _assert_this_initialized = function _assert_this_initialized(self1) {
                if (self1 === void 0) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return self1;
            };
            var lua_service_asyncGeneratorStep = function lua_service_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
                try {
                    var info = gen[key](arg);
                    var value = info.value;
                } catch (error) {
                    reject(error);
                    return;
                }
                if (info.done) {
                    resolve(value);
                } else {
                    Promise.resolve(value).then(_next, _throw);
                }
            };
            var lua_service_async_to_generator = function lua_service_async_to_generator(fn) {
                return function() {
                    var _$self = this, args = arguments;
                    return new Promise(function(resolve, reject) {
                        var gen = fn.apply(_$self, args);
                        function _next(value) {
                            lua_service_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
                        }
                        function _throw(err) {
                            lua_service_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
                        }
                        _next(undefined);
                    });
                };
            };
            var lua_service_class_call_check = function lua_service_class_call_check(instance, Constructor) {
                if (!_instanceof(instance, Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                }
            };
            var lua_service_defineProperties = function lua_service_defineProperties(target, props) {
                for(var i = 0; i < props.length; i++){
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                }
            };
            var lua_service_create_class = function lua_service_create_class(Constructor, protoProps, staticProps) {
                if (protoProps) lua_service_defineProperties(Constructor.prototype, protoProps);
                if (staticProps) lua_service_defineProperties(Constructor, staticProps);
                return Constructor;
            };
            var lua_service_define_property = function lua_service_define_property(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                } else {
                    obj[key] = value;
                }
                return obj;
            };
            var _inherits = function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function");
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        writable: true,
                        configurable: true
                    }
                });
                if (superClass) _set_prototype_of(subClass, superClass);
            };
            var _instanceof1 = function _instanceof1(left, right) {
                if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
                    return !!right[Symbol.hasInstance](left);
                } else {
                    return _instanceof(left, right);
                }
            };
            var _possible_constructor_return = function _possible_constructor_return(self1, call) {
                if (call && (_type_of(call) === "object" || typeof call === "function")) {
                    return call;
                }
                return _assert_this_initialized(self1);
            };
            var _type_of = function _type_of(obj) {
                "@swc/helpers - typeof";
                return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
            };
            var _is_native_reflect_construct = function _is_native_reflect_construct() {
                if (typeof Reflect === "undefined" || !Reflect.construct) return false;
                if (Reflect.construct.sham) return false;
                if (typeof Proxy === "function") return true;
                try {
                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
                    return true;
                } catch (e) {
                    return false;
                }
            };
            var _create_super = function _create_super(Derived) {
                var hasNativeReflectConstruct = _is_native_reflect_construct();
                return function _createSuperInternal() {
                    var Super = _get_prototype_of(Derived), result;
                    if (hasNativeReflectConstruct) {
                        var NewTarget = _get_prototype_of(this).constructor;
                        result = Reflect.construct(Super, arguments, NewTarget);
                    } else {
                        result = Super.apply(this, arguments);
                    }
                    return _possible_constructor_return(this, result);
                };
            };
            var lua_service_ts_generator = function lua_service_ts_generator(thisArg, body) {
                var f, y, t, g, _ = {
                    label: 0,
                    sent: function sent() {
                        if (t[0] & 1) throw t[1];
                        return t[1];
                    },
                    trys: [],
                    ops: []
                };
                return g = {
                    next: verb(0),
                    "throw": verb(1),
                    "return": verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
                    return this;
                }), g;
                function verb(n) {
                    return function(v) {
                        return step([
                            n,
                            v
                        ]);
                    };
                }
                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while(_)try {
                        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [
                            op[0] & 2,
                            t.value
                        ];
                        switch(op[0]){
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {
                                    value: op[1],
                                    done: false
                                };
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [
                                    0
                                ];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue;
                                }
                                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                    _.label = op[1];
                                    break;
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break;
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break;
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue;
                        }
                        op = body.call(thisArg, _);
                    } catch (e) {
                        op = [
                            6,
                            e
                        ];
                        y = 0;
                    } finally{
                        f = t = 0;
                    }
                    if (op[0] & 5) throw op[1];
                    return {
                        value: op[0] ? op[1] : void 0,
                        done: true
                    };
                }
            };
            // ESM COMPAT FLAG
            __nested_webpack_require_2243179__.r(__webpack_exports__);
            // EXPORTS
            __nested_webpack_require_2243179__.d(__webpack_exports__, {
                "LuaService": function() {
                    return /* binding */ LuaService;
                }
            });
            ; // CONCATENATED MODULE: ./utils.ts
            function mergeObjects(obj1, obj2) {
                if (!obj1) return obj2;
                if (!obj2) return obj1;
                var mergedObjects = _object_spread({}, obj2, obj1); // Give priority to obj1 values by spreading obj2 first, then obj1
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = Object.keys(mergedObjects)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var key = _step.value;
                        if (obj1[key] && obj2[key]) {
                            if (Array.isArray(obj1[key])) {
                                mergedObjects[key] = obj1[key].concat(obj2[key]);
                            } else if (Array.isArray(obj2[key])) {
                                mergedObjects[key] = obj2[key].concat(obj1[key]);
                            } else if (typeof obj1[key] === "object" && typeof obj2[key] === "object") {
                                mergedObjects[key] = mergeObjects(obj1[key], obj2[key]);
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return mergedObjects;
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-languageserver-textdocument/lib/esm/main.js
            /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __spreadArray =  false || function(to, from, pack) {
                if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
                    if (ar || !(i in from)) {
                        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                        ar[i] = from[i];
                    }
                }
                return to.concat(ar || Array.prototype.slice.call(from));
            };
            var FullTextDocument = /** @class */ function() {
                var FullTextDocument = function FullTextDocument(uri, languageId, version, content) {
                    this._uri = uri;
                    this._languageId = languageId;
                    this._version = version;
                    this._content = content;
                    this._lineOffsets = undefined;
                };
                Object.defineProperty(FullTextDocument.prototype, "uri", {
                    get: function get() {
                        return this._uri;
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(FullTextDocument.prototype, "languageId", {
                    get: function get() {
                        return this._languageId;
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(FullTextDocument.prototype, "version", {
                    get: function get() {
                        return this._version;
                    },
                    enumerable: false,
                    configurable: true
                });
                FullTextDocument.prototype.getText = function(range) {
                    if (range) {
                        var start = this.offsetAt(range.start);
                        var end = this.offsetAt(range.end);
                        return this._content.substring(start, end);
                    }
                    return this._content;
                };
                FullTextDocument.prototype.update = function(changes, version) {
                    for(var _i = 0, changes_1 = changes; _i < changes_1.length; _i++){
                        var change = changes_1[_i];
                        if (FullTextDocument.isIncremental(change)) {
                            // makes sure start is before end
                            var range = getWellformedRange(change.range);
                            // update content
                            var startOffset = this.offsetAt(range.start);
                            var endOffset = this.offsetAt(range.end);
                            this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
                            // update the offsets
                            var startLine = Math.max(range.start.line, 0);
                            var endLine = Math.max(range.end.line, 0);
                            var lineOffsets = this._lineOffsets;
                            var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
                            if (endLine - startLine === addedLineOffsets.length) {
                                for(var i = 0, len = addedLineOffsets.length; i < len; i++){
                                    lineOffsets[i + startLine + 1] = addedLineOffsets[i];
                                }
                            } else {
                                if (addedLineOffsets.length < 10000) {
                                    lineOffsets.splice.apply(lineOffsets, __spreadArray([
                                        startLine + 1,
                                        endLine - startLine
                                    ], addedLineOffsets, false));
                                } else {
                                    this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
                                }
                            }
                            var diff = change.text.length - (endOffset - startOffset);
                            if (diff !== 0) {
                                for(var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++){
                                    lineOffsets[i] = lineOffsets[i] + diff;
                                }
                            }
                        } else if (FullTextDocument.isFull(change)) {
                            this._content = change.text;
                            this._lineOffsets = undefined;
                        } else {
                            throw new Error("Unknown change event received");
                        }
                    }
                    this._version = version;
                };
                FullTextDocument.prototype.getLineOffsets = function() {
                    if (this._lineOffsets === undefined) {
                        this._lineOffsets = computeLineOffsets(this._content, true);
                    }
                    return this._lineOffsets;
                };
                FullTextDocument.prototype.positionAt = function(offset) {
                    offset = Math.max(Math.min(offset, this._content.length), 0);
                    var lineOffsets = this.getLineOffsets();
                    var low = 0, high = lineOffsets.length;
                    if (high === 0) {
                        return {
                            line: 0,
                            character: offset
                        };
                    }
                    while(low < high){
                        var mid = Math.floor((low + high) / 2);
                        if (lineOffsets[mid] > offset) {
                            high = mid;
                        } else {
                            low = mid + 1;
                        }
                    }
                    // low is the least x for which the line offset is larger than the current offset
                    // or array.length if no line offset is larger than the current offset
                    var line = low - 1;
                    return {
                        line: line,
                        character: offset - lineOffsets[line]
                    };
                };
                FullTextDocument.prototype.offsetAt = function(position) {
                    var lineOffsets = this.getLineOffsets();
                    if (position.line >= lineOffsets.length) {
                        return this._content.length;
                    } else if (position.line < 0) {
                        return 0;
                    }
                    var lineOffset = lineOffsets[position.line];
                    var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
                    return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
                };
                Object.defineProperty(FullTextDocument.prototype, "lineCount", {
                    get: function get() {
                        return this.getLineOffsets().length;
                    },
                    enumerable: false,
                    configurable: true
                });
                FullTextDocument.isIncremental = function(event) {
                    var candidate = event;
                    return candidate !== undefined && candidate !== null && typeof candidate.text === "string" && candidate.range !== undefined && (candidate.rangeLength === undefined || typeof candidate.rangeLength === "number");
                };
                FullTextDocument.isFull = function(event) {
                    var candidate = event;
                    return candidate !== undefined && candidate !== null && typeof candidate.text === "string" && candidate.range === undefined && candidate.rangeLength === undefined;
                };
                return FullTextDocument;
            }();
            var TextDocument;
            (function(TextDocument) {
                var create = /**
     * Creates a new text document.
     *
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param version The document's initial version number.
     * @param content The document's content.
     */ function create(uri, languageId, version, content) {
                    return new FullTextDocument(uri, languageId, version, content);
                };
                var update = /**
     * Updates a TextDocument by modifying its content.
     *
     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.
     * @param changes the changes to apply to the document.
     * @param version the changes version for the document.
     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.
     *
     */ function update(document1, changes, version) {
                    if (_instanceof(document1, FullTextDocument)) {
                        document1.update(changes, version);
                        return document1;
                    } else {
                        throw new Error("TextDocument.update: document must be created by TextDocument.create");
                    }
                };
                var applyEdits = function applyEdits(document1, edits) {
                    var text = document1.getText();
                    var sortedEdits = mergeSort(edits.map(getWellformedEdit), function(a, b) {
                        var diff = a.range.start.line - b.range.start.line;
                        if (diff === 0) {
                            return a.range.start.character - b.range.start.character;
                        }
                        return diff;
                    });
                    var lastModifiedOffset = 0;
                    var spans = [];
                    for(var _i = 0, sortedEdits_1 = sortedEdits; _i < sortedEdits_1.length; _i++){
                        var e = sortedEdits_1[_i];
                        var startOffset = document1.offsetAt(e.range.start);
                        if (startOffset < lastModifiedOffset) {
                            throw new Error("Overlapping edit");
                        } else if (startOffset > lastModifiedOffset) {
                            spans.push(text.substring(lastModifiedOffset, startOffset));
                        }
                        if (e.newText.length) {
                            spans.push(e.newText);
                        }
                        lastModifiedOffset = document1.offsetAt(e.range.end);
                    }
                    spans.push(text.substr(lastModifiedOffset));
                    return spans.join("");
                };
                TextDocument.create = create;
                TextDocument.update = update;
                TextDocument.applyEdits = applyEdits;
            })(TextDocument || (TextDocument = {}));
            function mergeSort(data, compare) {
                if (data.length <= 1) {
                    // sorted
                    return data;
                }
                var p = data.length / 2 | 0;
                var left = data.slice(0, p);
                var right = data.slice(p);
                mergeSort(left, compare);
                mergeSort(right, compare);
                var leftIdx = 0;
                var rightIdx = 0;
                var i = 0;
                while(leftIdx < left.length && rightIdx < right.length){
                    var ret = compare(left[leftIdx], right[rightIdx]);
                    if (ret <= 0) {
                        // smaller_equal -> take left to preserve order
                        data[i++] = left[leftIdx++];
                    } else {
                        // greater -> take right
                        data[i++] = right[rightIdx++];
                    }
                }
                while(leftIdx < left.length){
                    data[i++] = left[leftIdx++];
                }
                while(rightIdx < right.length){
                    data[i++] = right[rightIdx++];
                }
                return data;
            }
            ; // CONCATENATED MODULE: ./services/base-service.ts
            var BaseService = /*#__PURE__*/ function() {
                "use strict";
                function BaseService(mode) {
                    _class_call_check(this, BaseService);
                    base_service_define_property(this, "mode", void 0);
                    base_service_define_property(this, "documents", {});
                    base_service_define_property(this, "options", {});
                    base_service_define_property(this, "globalOptions", {});
                    base_service_define_property(this, "serviceData", void 0);
                    this.mode = mode;
                }
                _create_class(BaseService, [
                    {
                        key: "addDocument",
                        value: function addDocument(document1) {
                            this.documents[document1.uri] = TextDocument.create(document1.uri, document1.languageId, document1.version, document1.text);
                        //TODO:
                        /*if (options)
            this.setSessionOptions(sessionID, options);*/ }
                    },
                    {
                        key: "getDocument",
                        value: function getDocument(uri) {
                            return this.documents[uri];
                        }
                    },
                    {
                        key: "removeDocument",
                        value: function removeDocument(document1) {
                            delete this.documents[document1.uri];
                            if (this.options[document1.uri]) {
                                delete this.options[document1.uri];
                            }
                        }
                    },
                    {
                        key: "getDocumentValue",
                        value: function getDocumentValue(uri) {
                            var _this_getDocument;
                            return (_this_getDocument = this.getDocument(uri)) === null || _this_getDocument === void 0 ? void 0 : _this_getDocument.getText();
                        }
                    },
                    {
                        key: "setValue",
                        value: function setValue(identifier, value) {
                            var document1 = this.getDocument(identifier.uri);
                            if (document1) {
                                document1 = TextDocument.create(document1.uri, document1.languageId, document1.version, value);
                                this.documents[document1.uri] = document1;
                            }
                        }
                    },
                    {
                        key: "setGlobalOptions",
                        value: function setGlobalOptions(options) {
                            this.globalOptions = options !== null && options !== void 0 ? options : {};
                        }
                    },
                    {
                        key: "setOptions",
                        value: function setOptions(sessionID, options) {
                            var merge = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                            this.options[sessionID] = merge ? mergeObjects(options, this.options[sessionID]) : options;
                        }
                    },
                    {
                        key: "getOption",
                        value: function getOption(sessionID, optionName) {
                            if (this.options[sessionID] && this.options[sessionID][optionName]) {
                                return this.options[sessionID][optionName];
                            } else {
                                return this.globalOptions[optionName];
                            }
                        }
                    },
                    {
                        key: "applyDeltas",
                        value: function applyDeltas(identifier, deltas) {
                            var document1 = this.getDocument(identifier.uri);
                            if (document1) TextDocument.update(document1, deltas, identifier.version);
                        }
                    },
                    {
                        key: "doComplete",
                        value: function doComplete(document1, position) {
                            return _async_to_generator(function() {
                                return _ts_generator(this, function(_state) {
                                    return [
                                        2,
                                        null
                                    ];
                                });
                            })();
                        }
                    },
                    {
                        key: "doHover",
                        value: function doHover(document1, position) {
                            return _async_to_generator(function() {
                                return _ts_generator(this, function(_state) {
                                    return [
                                        2,
                                        null
                                    ];
                                });
                            })();
                        }
                    },
                    {
                        key: "doResolve",
                        value: function doResolve(item) {
                            return _async_to_generator(function() {
                                return _ts_generator(this, function(_state) {
                                    return [
                                        2,
                                        null
                                    ];
                                });
                            })();
                        }
                    },
                    {
                        key: "doValidation",
                        value: function doValidation(document1) {
                            return _async_to_generator(function() {
                                return _ts_generator(this, function(_state) {
                                    return [
                                        2,
                                        []
                                    ];
                                });
                            })();
                        }
                    },
                    {
                        key: "format",
                        value: function format(document1, range, options) {
                            return [];
                        }
                    },
                    {
                        key: "provideSignatureHelp",
                        value: function provideSignatureHelp(document1, position) {
                            return _async_to_generator(function() {
                                return _ts_generator(this, function(_state) {
                                    return [
                                        2,
                                        null
                                    ];
                                });
                            })();
                        }
                    },
                    {
                        key: "findDocumentHighlights",
                        value: function findDocumentHighlights(document1, position) {
                            return _async_to_generator(function() {
                                return _ts_generator(this, function(_state) {
                                    return [
                                        2,
                                        []
                                    ];
                                });
                            })();
                        }
                    },
                    {
                        key: "optionsToFilterDiagnostics",
                        get: function get() {
                            var _this_globalOptions_errorCodesToIgnore, _this_globalOptions_errorCodesToTreatAsWarning, _this_globalOptions_errorCodesToTreatAsInfo, _this_globalOptions_errorMessagesToIgnore, _this_globalOptions_errorMessagesToTreatAsWarning, _this_globalOptions_errorMessagesToTreatAsInfo;
                            return {
                                errorCodesToIgnore: (_this_globalOptions_errorCodesToIgnore = this.globalOptions.errorCodesToIgnore) !== null && _this_globalOptions_errorCodesToIgnore !== void 0 ? _this_globalOptions_errorCodesToIgnore : [],
                                errorCodesToTreatAsWarning: (_this_globalOptions_errorCodesToTreatAsWarning = this.globalOptions.errorCodesToTreatAsWarning) !== null && _this_globalOptions_errorCodesToTreatAsWarning !== void 0 ? _this_globalOptions_errorCodesToTreatAsWarning : [],
                                errorCodesToTreatAsInfo: (_this_globalOptions_errorCodesToTreatAsInfo = this.globalOptions.errorCodesToTreatAsInfo) !== null && _this_globalOptions_errorCodesToTreatAsInfo !== void 0 ? _this_globalOptions_errorCodesToTreatAsInfo : [],
                                errorMessagesToIgnore: (_this_globalOptions_errorMessagesToIgnore = this.globalOptions.errorMessagesToIgnore) !== null && _this_globalOptions_errorMessagesToIgnore !== void 0 ? _this_globalOptions_errorMessagesToIgnore : [],
                                errorMessagesToTreatAsWarning: (_this_globalOptions_errorMessagesToTreatAsWarning = this.globalOptions.errorMessagesToTreatAsWarning) !== null && _this_globalOptions_errorMessagesToTreatAsWarning !== void 0 ? _this_globalOptions_errorMessagesToTreatAsWarning : [],
                                errorMessagesToTreatAsInfo: (_this_globalOptions_errorMessagesToTreatAsInfo = this.globalOptions.errorMessagesToTreatAsInfo) !== null && _this_globalOptions_errorMessagesToTreatAsInfo !== void 0 ? _this_globalOptions_errorMessagesToTreatAsInfo : []
                            };
                        }
                    }
                ]);
                return BaseService;
            }();
            // EXTERNAL MODULE: ../../node_modules/luaparse/luaparse.js
            var luaparse = __nested_webpack_require_2243179__(7438);
            // EXTERNAL MODULE: ../../node_modules/vscode-languageserver-protocol/lib/browser/main.js
            var main = __nested_webpack_require_2243179__(294);
            // EXTERNAL MODULE: ../../node_modules/ace-code/src/range.js
            var range = __nested_webpack_require_2243179__(3069);
            // EXTERNAL MODULE: ../../node_modules/ace-code/src/range_list.js
            var range_list = __nested_webpack_require_2243179__(9204);
            // EXTERNAL MODULE: ../../node_modules/ace-code/src/ace.js
            var ace = __nested_webpack_require_2243179__(8151);
            ; // CONCATENATED MODULE: ./type-converters/common-converters.ts
            var common_converters_CommonConverter;
            (function(CommonConverter1) {
                var normalizeRanges = function normalizeRanges(completions) {
                    return completions && completions.map(function(el) {
                        if (el["range"]) {
                            el["range"] = toRange(el["range"]);
                        }
                        return el;
                    });
                };
                var cleanHtml = function cleanHtml(html) {
                    return html.replace(/<a\s/, "<a target='_blank' ");
                };
                var toRange = function toRange(range) {
                    if (!range || !range.start || !range.end) {
                        return;
                    }
                    return ace.Range.fromPoints(range.start, range.end);
                };
                var convertKind = function convertKind(kind) {
                    switch(kind){
                        case "primitiveType":
                        case "keyword":
                            return main.CompletionItemKind.Keyword;
                        case "variable":
                        case "localVariable":
                            return main.CompletionItemKind.Variable;
                        case "memberVariable":
                        case "memberGetAccessor":
                        case "memberSetAccessor":
                            return main.CompletionItemKind.Field;
                        case "function":
                        case "memberFunction":
                        case "constructSignature":
                        case "callSignature":
                        case "indexSignature":
                            return main.CompletionItemKind.Function;
                        case "enum":
                            return main.CompletionItemKind.Enum;
                        case "module":
                            return main.CompletionItemKind.Module;
                        case "class":
                            return main.CompletionItemKind.Class;
                        case "interface":
                            return main.CompletionItemKind.Interface;
                        case "warning":
                            return main.CompletionItemKind.File;
                    }
                    return main.CompletionItemKind.Property;
                };
                var excludeByErrorMessage = function excludeByErrorMessage(diagnostics, errorMessagesToIgnore) {
                    var fieldName = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "message";
                    if (!errorMessagesToIgnore) return diagnostics;
                    return diagnostics.filter(function(el) {
                        return !checkValueAgainstRegexpArray(el[fieldName], errorMessagesToIgnore);
                    });
                };
                CommonConverter1.normalizeRanges = normalizeRanges;
                CommonConverter1.cleanHtml = cleanHtml;
                CommonConverter1.toRange = toRange;
                CommonConverter1.convertKind = convertKind;
                CommonConverter1.excludeByErrorMessage = excludeByErrorMessage;
            })(common_converters_CommonConverter || (common_converters_CommonConverter = {}));
            ; // CONCATENATED MODULE: ./type-converters/lsp-converters.ts
            ; // CONCATENATED MODULE: ./services/lua/lua-service.ts
            function _get_prototype_of(o) {
                _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
                    return o.__proto__ || Object.getPrototypeOf(o);
                };
                return _get_prototype_of(o);
            }
            function _set_prototype_of(o, p) {
                _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
                    o.__proto__ = p;
                    return o;
                };
                return _set_prototype_of(o, p);
            }
            var LuaService = /*#__PURE__*/ function(BaseService) {
                "use strict";
                _inherits(LuaService, BaseService);
                var _super = _create_super(LuaService);
                function LuaService(mode) {
                    lua_service_class_call_check(this, LuaService);
                    var _this;
                    _this = _super.call(this, mode);
                    lua_service_define_property(_assert_this_initialized(_this), "$service", void 0);
                    _this.$service = luaparse;
                    return _this;
                }
                lua_service_create_class(LuaService, [
                    {
                        key: "doValidation",
                        value: function doValidation(document1) {
                            var _this = this;
                            return lua_service_async_to_generator(function() {
                                var value, errors;
                                return lua_service_ts_generator(this, function(_state) {
                                    value = _this.getDocumentValue(document1.uri);
                                    if (!value) return [
                                        2,
                                        []
                                    ];
                                    errors = [];
                                    try {
                                        _this.$service.parse(value);
                                    } catch (e) {
                                        if (_instanceof1(e, _this.$service.SyntaxError)) {
                                            errors.push({
                                                range: {
                                                    start: {
                                                        line: e.line - 1,
                                                        character: e.column
                                                    },
                                                    end: {
                                                        line: e.line - 1,
                                                        character: e.column
                                                    }
                                                },
                                                message: e.message,
                                                severity: 1
                                            });
                                        }
                                    }
                                    return [
                                        2,
                                        filterDiagnostics(errors, _this.optionsToFilterDiagnostics)
                                    ];
                                });
                            })();
                        }
                    }
                ]);
                return LuaService;
            }(BaseService);
        })();
        /******/ return __webpack_exports__;
    /******/ }();
});


/***/ })

}]);
//# sourceMappingURL=bundle.8858.js.map