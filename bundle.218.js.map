{"version":3,"file":"bundle.218.js","mappings":";;;;;;AAAa;;AAEb,UAAU,mBAAO,CAAC,IAAW;AAC7B,mBAAmB,iDAA2C;;AAE9D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;;AAEA,aAAa,SAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD,mCAAmC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,CAAC;;;;;;;;AC5MY;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3Ea;;AAEb,UAAU,mBAAO,CAAC,IAAW;AAC7B,iBAAiB,+CAAmC;AACpD,mBAAmB,iDAA2C;AAC9D,YAAY,0CAAwB;AACpC,aAAa,2CAA0B;;AAEvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2FAA2F;AAC3F,WAAW,mBAAmB;AAC9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN,gCAAgC,kBAAkB;AAClD,MAAM;AACN,qBAAqB,iBAAiB;AACtC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC;AACjC,eAAe,QAAQ,sCAAsC,4CAA4C;AACzG;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iDAAiD,qCAAqC;AACtF,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ,6CAA6C,kCAAkC,yBAAyB;AAC/H,eAAe,QAAQ;AACvB,iBAAiB,QAAQ,eAAe,YAAY;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ,oCAAoC,kCAAkC,yBAAyB;AACtH,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,iBAAiB,QAAQ;AACzB;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yBAAyB;AACzD;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,iBAAiB,QAAQ;AACzB;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,uBAAuB;AACjE,SAAS;AACT;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,uBAAuB;AACjE,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA,oCAAoC,MAAM;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,UAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uDAAuD,YAAY;AACnE;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ,IAAI,YAAY;AACzC;AACA;AACA;AACA;AACA,sDAAsD,OAAO;AAC7D;AACA;AACA,wBAAwB;AACxB;AACA,gBAAgB;AAChB;;AAEA;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ,UAAU,YAAY;AAC7C,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;;AAEA;AACA;;AAEA,CAAC;;AAED,SAAgB;;;;;;;;AC3pBH;;AAEb;AACA,mCAAmC;AACnC,kCAAkC;;AAElC;AACA;AACA,oDAAoD;AACpD,wDAAwD;;AAExD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;AAGA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,SAAoB;;;;;;;;AChIP;;AAEb,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;;;;;;;;ACvBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,uBAAuB;AACvB;AACA,uBAAuB;;AAEvB;AACA,yBAAyB;AACzB;AACA,yBAAyB;;AAEzB;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,uBAAuB;;AAEvB;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,WAAW;AACtB,aAAa;AACb;AACA;AACA;AACA;;;AAGA,SAAa","sources":["webpack://ace-linters-root/./node_modules/ace-code/src/anchor.js","webpack://ace-linters-root/./node_modules/ace-code/src/apply_delta.js","webpack://ace-linters-root/./node_modules/ace-code/src/document.js","webpack://ace-linters-root/./node_modules/ace-code/src/lib/event_emitter.js","webpack://ace-linters-root/./node_modules/ace-code/src/lib/oop.js","webpack://ace-linters-root/./node_modules/ace-code/src/range.js"],"sourcesContent":["\"use strict\";\n\nvar oop = require(\"./lib/oop\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\n\n/**\n *\n * Defines a floating pointer in the document. Whenever text is inserted or deleted before the cursor, the position of the anchor is updated.\n *\n * @class Anchor\n **/\n\n/**\n * Creates a new `Anchor` and associates it with a document.\n *\n * @param {Document} doc The document to associate with the anchor\n * @param {Number} row The starting row position\n * @param {Number} column The starting column position\n *\n * @constructor\n **/\n\nvar Anchor = exports.Anchor = function(doc, row, column) {\n    this.$onChange = this.onChange.bind(this);\n    this.attach(doc);\n    \n    if (typeof column == \"undefined\")\n        this.setPosition(row.row, row.column);\n    else\n        this.setPosition(row, column);\n};\n\n(function() {\n\n    oop.implement(this, EventEmitter);\n\n    /**\n     * Returns an object identifying the `row` and `column` position of the current anchor.\n     * @returns {Ace.Point}\n     **/\n    this.getPosition = function() {\n        return this.$clipPositionToDocument(this.row, this.column);\n    };\n\n    /**\n     *\n     * Returns the current document.\n     * @returns {Document}\n     **/\n    this.getDocument = function() {\n        return this.document;\n    };\n\n    /**\n     * experimental: allows anchor to stick to the next on the left\n     */\n    this.$insertRight = false;\n    /**\n     * Fires whenever the anchor position changes.\n     *\n     * Both of these objects have a `row` and `column` property corresponding to the position.\n     *\n     * Events that can trigger this function include [[Anchor.setPosition `setPosition()`]].\n     *\n     * @event change\n     * @param {Object} e  An object containing information about the anchor position. It has two properties:\n     *  - `old`: An object describing the old Anchor position\n     *  - `value`: An object describing the new Anchor position\n     *\n     **/\n    /**\n     * Internal function called when `\"change\"` event fired.\n     * @param {Ace.Delta} delta\n     */\n    this.onChange = function(delta) {\n        if (delta.start.row == delta.end.row && delta.start.row != this.row)\n            return;\n\n        if (delta.start.row > this.row)\n            return;\n            \n        var point = $getTransformedPoint(delta, {row: this.row, column: this.column}, this.$insertRight);\n        this.setPosition(point.row, point.column, true);\n    };\n    \n    function $pointsInOrder(point1, point2, equalPointsInOrder) {\n        var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;\n        return (point1.row < point2.row) || (point1.row == point2.row && bColIsAfter);\n    }\n            \n    function $getTransformedPoint(delta, point, moveIfEqual) {\n        // Get delta info.\n        var deltaIsInsert = delta.action == \"insert\";\n        var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row    - delta.start.row);\n        var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);\n        var deltaStart = delta.start;\n        var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.\n        \n        // DELTA AFTER POINT: No change needed.\n        if ($pointsInOrder(point, deltaStart, moveIfEqual)) {\n            return {\n                row: point.row,\n                column: point.column\n            };\n        }\n        \n        // DELTA BEFORE POINT: Move point by delta shift.\n        if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {\n            return {\n                row: point.row + deltaRowShift,\n                column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)\n            };\n        }\n        \n        // DELTA ENVELOPS POINT (delete only): Move point to delta start.\n        // TODO warn if delta.action != \"remove\" ?\n        \n        return {\n            row: deltaStart.row,\n            column: deltaStart.column\n        };\n    }\n\n    /**\n     * Sets the anchor position to the specified row and column. If `noClip` is `true`, the position is not clipped.\n     * @param {Number} row The row index to move the anchor to\n     * @param {Number} column The column index to move the anchor to\n     * @param {Boolean} noClip Identifies if you want the position to be clipped\n     *\n     **/\n    this.setPosition = function(row, column, noClip) {\n        var pos;\n        if (noClip) {\n            pos = {\n                row: row,\n                column: column\n            };\n        } else {\n            pos = this.$clipPositionToDocument(row, column);\n        }\n\n        if (this.row == pos.row && this.column == pos.column)\n            return;\n\n        var old = {\n            row: this.row,\n            column: this.column\n        };\n\n        this.row = pos.row;\n        this.column = pos.column;\n        this._signal(\"change\", {\n            old: old,\n            value: pos\n        });\n    };\n\n    /**\n     * When called, the `\"change\"` event listener is removed.\n     *\n     **/\n    this.detach = function() {\n        this.document.off(\"change\", this.$onChange);\n    };\n\n    /**\n     * When called, the `\"change\"` event listener is appended.\n     * @param {Document} doc The document to associate with\n     *\n     **/\n    this.attach = function(doc) {\n        this.document = doc || this.document;\n        this.document.on(\"change\", this.$onChange);\n    };\n\n    /**\n     * Clips the anchor position to the specified row and column.\n     * @param {Number} row The row index to clip the anchor to\n     * @param {Number} column The column index to clip the anchor to\n     * @returns {Ace.Point}\n     *\n     **/\n    this.$clipPositionToDocument = function(row, column) {\n        var pos = {};\n\n        if (row >= this.document.getLength()) {\n            pos.row = Math.max(0, this.document.getLength() - 1);\n            pos.column = this.document.getLine(pos.row).length;\n        }\n        else if (row < 0) {\n            pos.row = 0;\n            pos.column = 0;\n        }\n        else {\n            pos.row = row;\n            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));\n        }\n\n        if (column < 0)\n            pos.column = 0;\n\n        return pos;\n    };\n\n}).call(Anchor.prototype);\n","\"use strict\";\n\nfunction throwDeltaError(delta, errorText){\n    console.log(\"Invalid Delta:\", delta);\n    throw \"Invalid Delta: \" + errorText;\n}\n\nfunction positionInDocument(docLines, position) {\n    return position.row    >= 0 && position.row    <  docLines.length &&\n           position.column >= 0 && position.column <= docLines[position.row].length;\n}\n\nfunction validateDelta(docLines, delta) {\n    // Validate action string.\n    if (delta.action != \"insert\" && delta.action != \"remove\")\n        throwDeltaError(delta, \"delta.action must be 'insert' or 'remove'\");\n    \n    // Validate lines type.\n    if (!(delta.lines instanceof Array))\n        throwDeltaError(delta, \"delta.lines must be an Array\");\n\n    // Validate range type.\n    if (!delta.start || !delta.end)\n       throwDeltaError(delta, \"delta.start/end must be an present\");\n\n    // Validate that the start point is contained in the document.\n    var start = delta.start;\n    if (!positionInDocument(docLines, delta.start))\n        throwDeltaError(delta, \"delta.start must be contained in document\");\n    \n    // Validate that the end point is contained in the document (remove deltas only).\n    var end = delta.end;\n    if (delta.action == \"remove\" && !positionInDocument(docLines, end))\n        throwDeltaError(delta, \"delta.end must contained in document for 'remove' actions\");\n    \n    // Validate that the .range size matches the .lines size.\n    var numRangeRows = end.row - start.row;\n    var numRangeLastLineChars = (end.column - (numRangeRows == 0 ? start.column : 0));\n    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars)\n        throwDeltaError(delta, \"delta.range must match delta lines\");\n}\n\nexports.applyDelta = function(docLines, delta, doNotValidate) {\n    // disabled validation since it breaks autocompletion popup\n    // if (!doNotValidate)\n    //    validateDelta(docLines, delta);\n    \n    var row = delta.start.row;\n    var startColumn = delta.start.column;\n    var line = docLines[row] || \"\";\n    switch (delta.action) {\n        case \"insert\":\n            var lines = delta.lines;\n            if (lines.length === 1) {\n                docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);\n            } else {\n                var args = [row, 1].concat(delta.lines);\n                docLines.splice.apply(docLines, args);\n                docLines[row] = line.substring(0, startColumn) + docLines[row];\n                docLines[row + delta.lines.length - 1] += line.substring(startColumn);\n            }\n            break;\n        case \"remove\":\n            var endColumn = delta.end.column;\n            var endRow = delta.end.row;\n            if (row === endRow) {\n                docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);\n            } else {\n                docLines.splice(\n                    row, endRow - row + 1,\n                    line.substring(0, startColumn) + docLines[endRow].substring(endColumn)\n                );\n            }\n            break;\n    }\n};\n","\"use strict\";\n\nvar oop = require(\"./lib/oop\");\nvar applyDelta = require(\"./apply_delta\").applyDelta;\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar Range = require(\"./range\").Range;\nvar Anchor = require(\"./anchor\").Anchor;\n\n/**\n * Contains the text of the document. Document can be attached to several [[EditSession `EditSession`]]s. \n * At its core, `Document`s are just an array of strings, with each row in the document matching up to the array index.\n *\n * @class Document\n **/\n\n/**\n *\n * Creates a new `Document`. If `text` is included, the `Document` contains those strings; otherwise, it's empty.\n * @param {String | String[]} textOrLines text The starting text\n * @constructor\n **/\n\nvar Document = function(textOrLines) {\n    this.$lines = [\"\"];\n\n    // There has to be one line at least in the document. If you pass an empty\n    // string to the insert function, nothing will happen. Workaround.\n    if (textOrLines.length === 0) {\n        this.$lines = [\"\"];\n    } else if (Array.isArray(textOrLines)) {\n        this.insertMergedLines({row: 0, column: 0}, textOrLines);\n    } else {\n        this.insert({row: 0, column:0}, textOrLines);\n    }\n};\n\n(function() {\n\n    oop.implement(this, EventEmitter);\n\n    /**\n     * Replaces all the lines in the current `Document` with the value of `text`.\n     *\n     * @param {String} text The text to use\n     **/\n    this.setValue = function(text) {\n        var len = this.getLength() - 1;\n        this.remove(new Range(0, 0, len, this.getLine(len).length));\n        this.insert({row: 0, column: 0}, text || \"\");\n    };\n\n    /**\n     * Returns all the lines in the document as a single string, joined by the new line character.\n     **/\n    this.getValue = function() {\n        return this.getAllLines().join(this.getNewLineCharacter());\n    };\n\n    /** \n     * Creates a new `Anchor` to define a floating point in the document.\n     * @param {Number} row The row number to use\n     * @param {Number} column The column number to use\n     *\n     **/\n    this.createAnchor = function(row, column) {\n        return new Anchor(this, row, column);\n    };\n\n    /** \n     * Splits a string of text on any newline (`\\n`) or carriage-return (`\\r`) characters.\n     *\n     * @method $split\n     * @param {String} text The text to work with\n     * @returns {String} A String array, with each index containing a piece of the original `text` string.\n     *\n     **/\n\n    // check for IE split bug\n    if (\"aaa\".split(/a/).length === 0) {\n        this.$split = function(text) {\n            return text.replace(/\\r\\n|\\r/g, \"\\n\").split(\"\\n\");\n        };\n    } else {\n        this.$split = function(text) {\n            return text.split(/\\r\\n|\\r|\\n/);\n        };\n    }\n\n\n    this.$detectNewLine = function(text) {\n        var match = text.match(/^.*?(\\r\\n|\\r|\\n)/m);\n        this.$autoNewLine = match ? match[1] : \"\\n\";\n        this._signal(\"changeNewLineMode\");\n    };\n\n    /**\n     * Returns the newline character that's being used, depending on the value of `newLineMode`. \n     * @returns {String} If `newLineMode == windows`, `\\r\\n` is returned.  \n     *  If `newLineMode == unix`, `\\n` is returned.  \n     *  If `newLineMode == auto`, the value of `autoNewLine` is returned.\n     *\n     **/\n    this.getNewLineCharacter = function() {\n        switch (this.$newLineMode) {\n          case \"windows\":\n            return \"\\r\\n\";\n          case \"unix\":\n            return \"\\n\";\n          default:\n            return this.$autoNewLine || \"\\n\";\n        }\n    };\n\n    this.$autoNewLine = \"\";\n    this.$newLineMode = \"auto\";\n    /**\n     * [Sets the new line mode.]{: #Document.setNewLineMode.desc}\n     * @param {String} newLineMode [The newline mode to use; can be either `windows`, `unix`, or `auto`]{: #Document.setNewLineMode.param}\n     *\n     **/\n    this.setNewLineMode = function(newLineMode) {\n        if (this.$newLineMode === newLineMode)\n            return;\n\n        this.$newLineMode = newLineMode;\n        this._signal(\"changeNewLineMode\");\n    };\n\n    /**\n     * [Returns the type of newlines being used; either `windows`, `unix`, or `auto`]{: #Document.getNewLineMode}\n     * @returns {String}\n     **/\n    this.getNewLineMode = function() {\n        return this.$newLineMode;\n    };\n\n    /**\n     * Returns `true` if `text` is a newline character (either `\\r\\n`, `\\r`, or `\\n`).\n     * @param {String} text The text to check\n     *\n     **/\n    this.isNewLine = function(text) {\n        return (text == \"\\r\\n\" || text == \"\\r\" || text == \"\\n\");\n    };\n\n    /**\n     * Returns a verbatim copy of the given line as it is in the document\n     * @param {Number} row The row index to retrieve\n     *\n     **/\n    this.getLine = function(row) {\n        return this.$lines[row] || \"\";\n    };\n\n    /**\n     * Returns an array of strings of the rows between `firstRow` and `lastRow`. This function is inclusive of `lastRow`.\n     * @param {Number} firstRow The first row index to retrieve\n     * @param {Number} lastRow The final row index to retrieve\n     *\n     **/\n    this.getLines = function(firstRow, lastRow) {\n        return this.$lines.slice(firstRow, lastRow + 1);\n    };\n\n    /**\n     * Returns all lines in the document as string array.\n     **/\n    this.getAllLines = function() {\n        return this.getLines(0, this.getLength());\n    };\n\n    /**\n     * Returns the number of rows in the document.\n     **/\n    this.getLength = function() {\n        return this.$lines.length;\n    };\n\n    /**\n     * Returns all the text within `range` as a single string.\n     * @param {Range} range The range to work with.\n     * \n     * @returns {String}\n     **/\n    this.getTextRange = function(range) {\n        return this.getLinesForRange(range).join(this.getNewLineCharacter());\n    };\n    \n    /**\n     * Returns all the text within `range` as an array of lines.\n     * @param {Range} range The range to work with.\n     * \n     * @returns {string[]}\n     **/\n    this.getLinesForRange = function(range) {\n        var lines;\n        if (range.start.row === range.end.row) {\n            // Handle a single-line range.\n            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];\n        } else {\n            // Handle a multi-line range.\n            lines = this.getLines(range.start.row, range.end.row);\n            lines[0] = (lines[0] || \"\").substring(range.start.column);\n            var l = lines.length - 1;\n            if (range.end.row - range.start.row == l)\n                lines[l] = lines[l].substring(0, range.end.column);\n        }\n        return lines;\n    };\n\n    // Deprecated methods retained for backwards compatibility.\n    this.insertLines = function(row, lines) {\n        console.warn(\"Use of document.insertLines is deprecated. Use the insertFullLines method instead.\");\n        return this.insertFullLines(row, lines);\n    };\n    this.removeLines = function(firstRow, lastRow) {\n        console.warn(\"Use of document.removeLines is deprecated. Use the removeFullLines method instead.\");\n        return this.removeFullLines(firstRow, lastRow);\n    };\n    this.insertNewLine = function(position) {\n        console.warn(\"Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.\");\n        return this.insertMergedLines(position, [\"\", \"\"]);\n    };\n\n    /**\n     * Inserts a block of `text` at the indicated `position`.\n     * @param {Object} position The position to start inserting at; it's an object that looks like `{ row: row, column: column}`\n     * @param {String} text A chunk of text to insert\n     * @returns {Object} The position ({row, column}) of the last line of `text`. If the length of `text` is 0, this function simply returns `position`. \n     *\n     **/\n    this.insert = function(position, text) {\n        // Only detect new lines if the document has no line break yet.\n        if (this.getLength() <= 1)\n            this.$detectNewLine(text);\n        \n        return this.insertMergedLines(position, this.$split(text));\n    };\n    \n    /**\n     * Inserts `text` into the `position` at the current row. This method also triggers the `\"change\"` event.\n     * \n     * This differs from the `insert` method in two ways:\n     *   1. This does NOT handle newline characters (single-line text only).\n     *   2. This is faster than the `insert` method for single-line text insertions.\n     * \n     * @param {Object} position The position to insert at; it's an object that looks like `{ row: row, column: column}`\n     * @param {String} text A chunk of text\n     * @returns {Object} Returns an object containing the final row and column, like this:  \n     *     ```\n     *     {row: endRow, column: 0}\n     *     ```\n     **/\n    this.insertInLine = function(position, text) {\n        var start = this.clippedPos(position.row, position.column);\n        var end = this.pos(position.row, position.column + text.length);\n        \n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"insert\",\n            lines: [text]\n        }, true);\n        \n        return this.clonePos(end);\n    };\n    \n    this.clippedPos = function(row, column) {\n        var length = this.getLength();\n        if (row === undefined) {\n            row = length;\n        } else if (row < 0) {\n            row = 0;\n        } else if (row >= length) {\n            row = length - 1;\n            column = undefined;\n        }\n        var line = this.getLine(row);\n        if (column == undefined)\n            column = line.length;\n        column = Math.min(Math.max(column, 0), line.length);\n        return {row: row, column: column};\n    };\n    \n    this.clonePos = function(pos) {\n        return {row: pos.row, column: pos.column};\n    };\n    \n    this.pos = function(row, column) {\n        return {row: row, column: column};\n    };\n    \n    this.$clipPosition = function(position) {\n        var length = this.getLength();\n        if (position.row >= length) {\n            position.row = Math.max(0, length - 1);\n            position.column = this.getLine(length - 1).length;\n        } else {\n            position.row = Math.max(0, position.row);\n            position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);\n        }\n        return position;\n    };\n\n    /**\n     * Fires whenever the document changes.\n     *\n     * Several methods trigger different `\"change\"` events. Below is a list of each action type, followed by each property that's also available:\n     *\n     *  * `\"insert\"`\n     *    * `range`: the [[Range]] of the change within the document\n     *    * `lines`: the lines being added\n     *  * `\"remove\"`\n     *    * `range`: the [[Range]] of the change within the document\n     *    * `lines`: the lines being removed\n     *\n     * @event change\n     * @param {Object} e Contains at least one property called `\"action\"`. `\"action\"` indicates the action that triggered the change. Each action also has a set of additional properties.\n     *\n     **/\n    \n    /**\n     * Inserts the elements in `lines` into the document as full lines (does not merge with existing line), starting at the row index given by `row`. This method also triggers the `\"change\"` event.\n     * @param {Number} row The index of the row to insert at\n     * @param {string[]} lines An array of strings\n     * @returns {Object} Contains the final row and column, like this:  \n     *   ```\n     *   {row: endRow, column: 0}\n     *   ```  \n     *   If `lines` is empty, this function returns an object containing the current row, and column, like this:  \n     *   ``` \n     *   {row: row, column: 0}\n     *   ```\n     *\n     **/\n    this.insertFullLines = function(row, lines) {\n        // Clip to document.\n        // Allow one past the document end.\n        row = Math.min(Math.max(row, 0), this.getLength());\n        \n        // Calculate insertion point.\n        var column = 0;\n        if (row < this.getLength()) {\n            // Insert before the specified row.\n            lines = lines.concat([\"\"]);\n            column = 0;\n        } else {\n            // Insert after the last row in the document.\n            lines = [\"\"].concat(lines);\n            row--;\n            column = this.$lines[row].length;\n        }\n        \n        // Insert.\n        this.insertMergedLines({row: row, column: column}, lines);\n    };\n\n    /**\n     * Inserts the elements in `lines` into the document, starting at the position index given by `row`. This method also triggers the `\"change\"` event.\n     * @param {Number} row The index of the row to insert at\n     * @param {string[]} lines An array of strings\n     * @returns {Object} Contains the final row and column, like this:  \n     *   ```\n     *   {row: endRow, column: 0}\n     *   ```  \n     *   If `lines` is empty, this function returns an object containing the current row, and column, like this:  \n     *   ``` \n     *   {row: row, column: 0}\n     *   ```\n     *\n     **/    \n    this.insertMergedLines = function(position, lines) {\n        var start = this.clippedPos(position.row, position.column);\n        var end = {\n            row: start.row + lines.length - 1,\n            column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length\n        };\n        \n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"insert\",\n            lines: lines\n        });\n        \n        return this.clonePos(end);\n    };\n\n    /**\n     * Removes the `range` from the document.\n     * @param {Range} range A specified Range to remove\n     * @returns {Object} Returns the new `start` property of the range, which contains `startRow` and `startColumn`. If `range` is empty, this function returns the unmodified value of `range.start`.\n     *\n     **/\n    this.remove = function(range) {\n        var start = this.clippedPos(range.start.row, range.start.column);\n        var end = this.clippedPos(range.end.row, range.end.column);\n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"remove\",\n            lines: this.getLinesForRange({start: start, end: end})\n        });\n        return this.clonePos(start);\n    };\n\n    /**\n     * Removes the specified columns from the `row`. This method also triggers a `\"change\"` event.\n     * @param {Number} row The row to remove from\n     * @param {Number} startColumn The column to start removing at \n     * @param {Number} endColumn The column to stop removing at\n     * @returns {Object} Returns an object containing `startRow` and `startColumn`, indicating the new row and column values.<br/>If `startColumn` is equal to `endColumn`, this function returns nothing.\n     *\n     **/\n    this.removeInLine = function(row, startColumn, endColumn) {\n        var start = this.clippedPos(row, startColumn);\n        var end = this.clippedPos(row, endColumn);\n        \n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"remove\",\n            lines: this.getLinesForRange({start: start, end: end})\n        }, true);\n        \n        return this.clonePos(start);\n    };\n\n    /**\n     * Removes a range of full lines. This method also triggers the `\"change\"` event.\n     * @param {Number} firstRow The first row to be removed\n     * @param {Number} lastRow The last row to be removed\n     * @returns {[String]} Returns all the removed lines.\n     *\n     **/\n    this.removeFullLines = function(firstRow, lastRow) {\n        // Clip to document.\n        firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);\n        lastRow  = Math.min(Math.max(0, lastRow ), this.getLength() - 1);\n        \n        // Calculate deletion range.\n        // Delete the ending new line unless we're at the end of the document.\n        // If we're at the end of the document, delete the starting new line.\n        var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;\n        var deleteLastNewLine  = lastRow  < this.getLength() - 1;\n        var startRow = ( deleteFirstNewLine ? firstRow - 1                  : firstRow                    );\n        var startCol = ( deleteFirstNewLine ? this.getLine(startRow).length : 0                           );\n        var endRow   = ( deleteLastNewLine  ? lastRow + 1                   : lastRow                     );\n        var endCol   = ( deleteLastNewLine  ? 0                             : this.getLine(endRow).length ); \n        var range = new Range(startRow, startCol, endRow, endCol);\n        \n        // Store delelted lines with bounding newlines ommitted (maintains previous behavior).\n        var deletedLines = this.$lines.slice(firstRow, lastRow + 1);\n        \n        this.applyDelta({\n            start: range.start,\n            end: range.end,\n            action: \"remove\",\n            lines: this.getLinesForRange(range)\n        });\n        \n        // Return the deleted lines.\n        return deletedLines;\n    };\n\n    /**\n     * Removes the new line between `row` and the row immediately following it. This method also triggers the `\"change\"` event.\n     * @param {Number} row The row to check\n     *\n     **/\n    this.removeNewLine = function(row) {\n        if (row < this.getLength() - 1 && row >= 0) {\n            this.applyDelta({\n                start: this.pos(row, this.getLine(row).length),\n                end: this.pos(row + 1, 0),\n                action: \"remove\",\n                lines: [\"\", \"\"]\n            });\n        }\n    };\n\n    /**\n     * Replaces a range in the document with the new `text`.\n     * @param {Range} range A specified Range to replace\n     * @param {String} text The new text to use as a replacement\n     * @returns {Object} Returns an object containing the final row and column, like this:\n     *     {row: endRow, column: 0}\n     * If the text and range are empty, this function returns an object containing the current `range.start` value.\n     * If the text is the exact same as what currently exists, this function returns an object containing the current `range.end` value.\n     *\n     **/\n    this.replace = function(range, text) {\n        if (!(range instanceof Range))\n            range = Range.fromPoints(range.start, range.end);\n        if (text.length === 0 && range.isEmpty())\n            return range.start;\n\n        // Shortcut: If the text we want to insert is the same as it is already\n        // in the document, we don't have to replace anything.\n        if (text == this.getTextRange(range))\n            return range.end;\n\n        this.remove(range);\n        var end;\n        if (text) {\n            end = this.insert(range.start, text);\n        }\n        else {\n            end = range.start;\n        }\n        \n        return end;\n    };\n\n    /**\n     * Applies all changes in `deltas` to the document.\n     * @param {Delta[]} deltas An array of delta objects (can include \"insert\" and \"remove\" actions)\n     **/\n    this.applyDeltas = function(deltas) {\n        for (var i=0; i<deltas.length; i++) {\n            this.applyDelta(deltas[i]);\n        }\n    };\n    \n    /**\n     * Reverts all changes in `deltas` from the document.\n     * @param {Delta[]} deltas An array of delta objects (can include \"insert\" and \"remove\" actions)\n     **/\n    this.revertDeltas = function(deltas) {\n        for (var i=deltas.length-1; i>=0; i--) {\n            this.revertDelta(deltas[i]);\n        }\n    };\n    \n    /**\n     * Applies `delta` to the document.\n     * @param {Object} delta A delta object (can include \"insert\" and \"remove\" actions)\n     **/\n    this.applyDelta = function(delta, doNotValidate) {\n        var isInsert = delta.action == \"insert\";\n        // An empty range is a NOOP.\n        if (isInsert ? delta.lines.length <= 1 && !delta.lines[0]\n            : !Range.comparePoints(delta.start, delta.end)) {\n            return;\n        }\n        \n        if (isInsert && delta.lines.length > 20000) {\n            this.$splitAndapplyLargeDelta(delta, 20000);\n        }\n        else {\n            applyDelta(this.$lines, delta, doNotValidate);\n            this._signal(\"change\", delta);\n        }\n    };\n    \n    this.$safeApplyDelta = function(delta) {\n        var docLength = this.$lines.length;\n        // verify that delta is in the document to prevent applyDelta from corrupting lines array \n        if (\n            delta.action == \"remove\" && delta.start.row < docLength && delta.end.row < docLength\n            || delta.action == \"insert\" && delta.start.row <= docLength\n        ) {\n            this.applyDelta(delta);\n        }\n    };\n    \n    this.$splitAndapplyLargeDelta = function(delta, MAX) {\n        // Split large insert deltas. This is necessary because:\n        //    1. We need to support splicing delta lines into the document via $lines.splice.apply(...)\n        //    2. fn.apply() doesn't work for a large number of params. The smallest threshold is on chrome 40 ~42000.\n        // we use 20000 to leave some space for actual stack\n        // \n        // To Do: Ideally we'd be consistent and also split 'delete' deltas. We don't do this now, because delete\n        //        delta handling is too slow. If we make delete delta handling faster we can split all large deltas\n        //        as shown in https://gist.github.com/aldendaniels/8367109#file-document-snippet-js\n        //        If we do this, update validateDelta() to limit the number of lines in a delete delta.\n        var lines = delta.lines;\n        var l = lines.length - MAX + 1;\n        var row = delta.start.row; \n        var column = delta.start.column;\n        for (var from = 0, to = 0; from < l; from = to) {\n            to += MAX - 1;\n            var chunk = lines.slice(from, to);\n            chunk.push(\"\");\n            this.applyDelta({\n                start: this.pos(row + from, column),\n                end: this.pos(row + to, column = 0),\n                action: delta.action,\n                lines: chunk\n            }, true);\n        }\n        // Update remaining delta.\n        delta.lines = lines.slice(from);\n        delta.start.row = row + from;\n        delta.start.column = column;\n        this.applyDelta(delta, true);\n    };\n    \n    /**\n     * Reverts `delta` from the document.\n     * @param {Object} delta A delta object (can include \"insert\" and \"remove\" actions)\n     **/\n    this.revertDelta = function(delta) {\n        this.$safeApplyDelta({\n            start: this.clonePos(delta.start),\n            end: this.clonePos(delta.end),\n            action: (delta.action == \"insert\" ? \"remove\" : \"insert\"),\n            lines: delta.lines.slice()\n        });\n    };\n    \n    /**\n     * Converts an index position in a document to a `{row, column}` object.\n     *\n     * Index refers to the \"absolute position\" of a character in the document. For example:\n     *\n     * ```javascript\n     * var x = 0; // 10 characters, plus one for newline\n     * var y = -1;\n     * ```\n     * \n     * Here, `y` is an index 15: 11 characters for the first row, and 5 characters until `y` in the second.\n     *\n     * @param {Number} index An index to convert\n     * @param {Number} startRow=0 The row from which to start the conversion\n     * @returns {Object} A `{row, column}` object of the `index` position\n     */\n    this.indexToPosition = function(index, startRow) {\n        var lines = this.$lines || this.getAllLines();\n        var newlineLength = this.getNewLineCharacter().length;\n        for (var i = startRow || 0, l = lines.length; i < l; i++) {\n            index -= lines[i].length + newlineLength;\n            if (index < 0)\n                return {row: i, column: index + lines[i].length + newlineLength};\n        }\n        return {row: l-1, column: index + lines[l-1].length + newlineLength};\n    };\n\n    /**\n     * Converts the `{row, column}` position in a document to the character's index.\n     *\n     * Index refers to the \"absolute position\" of a character in the document. For example:\n     *\n     * ```javascript\n     * var x = 0; // 10 characters, plus one for newline\n     * var y = -1;\n     * ```\n     * \n     * Here, `y` is an index 15: 11 characters for the first row, and 5 characters until `y` in the second.\n     *\n     * @param {Object} pos The `{row, column}` to convert\n     * @param {Number} startRow=0 The row from which to start the conversion\n     * @returns {Number} The index position in the document\n     */\n    this.positionToIndex = function(pos, startRow) {\n        var lines = this.$lines || this.getAllLines();\n        var newlineLength = this.getNewLineCharacter().length;\n        var index = 0;\n        var row = Math.min(pos.row, lines.length);\n        for (var i = startRow || 0; i < row; ++i)\n            index += lines[i].length + newlineLength;\n\n        return index + pos.column;\n    };\n\n}).call(Document.prototype);\n\nexports.Document = Document;\n","\"use strict\";\n\nvar EventEmitter = {};\nvar stopPropagation = function() { this.propagationStopped = true; };\nvar preventDefault = function() { this.defaultPrevented = true; };\n\nEventEmitter._emit =\nEventEmitter._dispatchEvent = function(eventName, e) {\n    this._eventRegistry || (this._eventRegistry = {});\n    this._defaultHandlers || (this._defaultHandlers = {});\n\n    var listeners = this._eventRegistry[eventName] || [];\n    var defaultHandler = this._defaultHandlers[eventName];\n    if (!listeners.length && !defaultHandler)\n        return;\n\n    if (typeof e != \"object\" || !e)\n        e = {};\n\n    if (!e.type)\n        e.type = eventName;\n    if (!e.stopPropagation)\n        e.stopPropagation = stopPropagation;\n    if (!e.preventDefault)\n        e.preventDefault = preventDefault;\n\n    listeners = listeners.slice();\n    for (var i=0; i<listeners.length; i++) {\n        listeners[i](e, this);\n        if (e.propagationStopped)\n            break;\n    }\n    \n    if (defaultHandler && !e.defaultPrevented)\n        return defaultHandler(e, this);\n};\n\n\nEventEmitter._signal = function(eventName, e) {\n    var listeners = (this._eventRegistry || {})[eventName];\n    if (!listeners)\n        return;\n    listeners = listeners.slice();\n    for (var i=0; i<listeners.length; i++)\n        listeners[i](e, this);\n};\n\nEventEmitter.once = function(eventName, callback) {\n    var _self = this;\n    this.on(eventName, function newCallback() {\n        _self.off(eventName, newCallback);\n        callback.apply(null, arguments);\n    });\n    if (!callback) {\n        /*global Promise*/\n        return new Promise(function(resolve) {\n            callback = resolve;\n        });\n    }\n};\n\n\nEventEmitter.setDefaultHandler = function(eventName, callback) {\n    var handlers = this._defaultHandlers;\n    if (!handlers)\n        handlers = this._defaultHandlers = {_disabled_: {}};\n    \n    if (handlers[eventName]) {\n        var old = handlers[eventName];\n        var disabled = handlers._disabled_[eventName];\n        if (!disabled)\n            handlers._disabled_[eventName] = disabled = [];\n        disabled.push(old);\n        var i = disabled.indexOf(callback);\n        if (i != -1) \n            disabled.splice(i, 1);\n    }\n    handlers[eventName] = callback;\n};\nEventEmitter.removeDefaultHandler = function(eventName, callback) {\n    var handlers = this._defaultHandlers;\n    if (!handlers)\n        return;\n    var disabled = handlers._disabled_[eventName];\n    \n    if (handlers[eventName] == callback) {\n        if (disabled)\n            this.setDefaultHandler(eventName, disabled.pop());\n    } else if (disabled) {\n        var i = disabled.indexOf(callback);\n        if (i != -1)\n            disabled.splice(i, 1);\n    }\n};\n\nEventEmitter.on =\nEventEmitter.addEventListener = function(eventName, callback, capturing) {\n    this._eventRegistry = this._eventRegistry || {};\n\n    var listeners = this._eventRegistry[eventName];\n    if (!listeners)\n        listeners = this._eventRegistry[eventName] = [];\n\n    if (listeners.indexOf(callback) == -1)\n        listeners[capturing ? \"unshift\" : \"push\"](callback);\n    return callback;\n};\n\nEventEmitter.off =\nEventEmitter.removeListener =\nEventEmitter.removeEventListener = function(eventName, callback) {\n    this._eventRegistry = this._eventRegistry || {};\n\n    var listeners = this._eventRegistry[eventName];\n    if (!listeners)\n        return;\n\n    var index = listeners.indexOf(callback);\n    if (index !== -1)\n        listeners.splice(index, 1);\n};\n\nEventEmitter.removeAllListeners = function(eventName) {\n    if (!eventName) this._eventRegistry = this._defaultHandlers = undefined;\n    if (this._eventRegistry) this._eventRegistry[eventName] = undefined;\n    if (this._defaultHandlers) this._defaultHandlers[eventName] = undefined;\n};\n\nexports.EventEmitter = EventEmitter;\n","\"use strict\";\n\nexports.inherits = function(ctor, superCtor) {\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n            value: ctor,\n            enumerable: false,\n            writable: true,\n            configurable: true\n        }\n    });\n};\n\nexports.mixin = function(obj, mixin) {\n    for (var key in mixin) {\n        obj[key] = mixin[key];\n    }\n    return obj;\n};\n\nexports.implement = function(proto, mixin) {\n    exports.mixin(proto, mixin);\n};\n","\"use strict\";\nvar comparePoints = function(p1, p2) {\n    return p1.row - p2.row || p1.column - p2.column;\n};\n/**\n * This object is used in various places to indicate a region within the editor. To better visualize how this works, imagine a rectangle. Each quadrant of the rectangle is analogous to a range, as ranges contain a starting row and starting column, and an ending row, and ending column.\n * @class Range\n **/\n\n/**\n * Creates a new `Range` object with the given starting and ending rows and columns.\n * @param {Number} startRow The starting row\n * @param {Number} startColumn The starting column\n * @param {Number} endRow The ending row\n * @param {Number} endColumn The ending column\n * @constructor\n **/\nvar Range = function(startRow, startColumn, endRow, endColumn) {\n    this.start = {\n        row: startRow,\n        column: startColumn\n    };\n\n    this.end = {\n        row: endRow,\n        column: endColumn\n    };\n};\n\n(function() {\n    /**\n     * Returns `true` if and only if the starting row and column, and ending row and column, are equivalent to those given by `range`.\n     * @param {Range} range A range to check against\n     * @return {Boolean}\n     **/\n    this.isEqual = function(range) {\n        return this.start.row === range.start.row &&\n            this.end.row === range.end.row &&\n            this.start.column === range.start.column &&\n            this.end.column === range.end.column;\n    };\n\n    /**\n     * Returns a string containing the range's row and column information, given like this:\n     * ```\n     *    [start.row/start.column] -> [end.row/end.column]\n     * ```\n     * @return {String}\n     **/\n    this.toString = function() {\n        return (\"Range: [\" + this.start.row + \"/\" + this.start.column +\n            \"] -> [\" + this.end.row + \"/\" + this.end.column + \"]\");\n    };\n\n    /**\n     * Returns `true` if the `row` and `column` provided are within the given range. This can better be expressed as returning `true` if:\n     * ```javascript\n     *    this.start.row <= row <= this.end.row &&\n     *    this.start.column <= column <= this.end.column\n     * ```\n     * @param {Number} row A row to check for\n     * @param {Number} column A column to check for\n     * @returns {Boolean}\n     * @related [[Range.compare]]\n     **/\n\n    this.contains = function(row, column) {\n        return this.compare(row, column) == 0;\n    };\n\n    /**\n     * Compares `this` range (A) with another range (B).\n     * @param {Range} range A range to compare with\n     * @related [[Range.compare]]\n     * @returns {Number} This method returns one of the following numbers:\n     * * `-2`: (B) is in front of (A), and doesn't intersect with (A)\n     * * `-1`: (B) begins before (A) but ends inside of (A)\n     * * `0`: (B) is completely inside of (A) OR (A) is completely inside of (B)\n     * * `+1`: (B) begins inside of (A) but ends outside of (A)\n     * * `+2`: (B) is after (A) and doesn't intersect with (A)\n     * * `42`: FTW state: (B) ends in (A) but starts outside of (A)\n     **/\n    this.compareRange = function(range) {\n        var cmp,\n            end = range.end,\n            start = range.start;\n\n        cmp = this.compare(end.row, end.column);\n        if (cmp == 1) {\n            cmp = this.compare(start.row, start.column);\n            if (cmp == 1) {\n                return 2;\n            } else if (cmp == 0) {\n                return 1;\n            } else {\n                return 0;\n            }\n        } else if (cmp == -1) {\n            return -2;\n        } else {\n            cmp = this.compare(start.row, start.column);\n            if (cmp == -1) {\n                return -1;\n            } else if (cmp == 1) {\n                return 42;\n            } else {\n                return 0;\n            }\n        }\n    };\n\n    /**\n     * Compares the row and column of `p` with the starting and ending [[Point]]'s of the calling range (by calling [[Range.compare]]).\n     * @param {Ace.Point} p A point to compare with\n     * @related [[Range.compare]]\n     * @returns {Number}\n     **/\n    this.comparePoint = function(p) {\n        return this.compare(p.row, p.column);\n    };\n\n    /**\n     * Checks the start and end [[Point]]'s of `range` and compares them to the calling range. Returns `true` if the `range` is contained within the caller's range.\n     * @param {Range} range A range to compare with\n     * @returns {Boolean}\n     * @related [[Range.comparePoint]]\n     **/\n    this.containsRange = function(range) {\n        return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;\n    };\n\n    /**\n     * Returns `true` if passed in `range` intersects with the one calling this method.\n     * @param {Range} range A range to compare with\n     * @returns {Boolean}\n     **/\n    this.intersects = function(range) {\n        var cmp = this.compareRange(range);\n        return (cmp == -1 || cmp == 0 || cmp == 1);\n    };\n\n    /**\n     * Returns `true` if the caller's ending row is the same as `row`, and if the caller's ending column is the same as `column`.\n     * @param {Number} row A row to compare with\n     * @param {Number} column A column to compare with\n     * @returns {Boolean}\n     **/\n    this.isEnd = function(row, column) {\n        return this.end.row == row && this.end.column == column;\n    };\n\n    /**\n     * Returns `true` if the caller's starting row is the same as `row`, and if the caller's starting column is the same as `column`.\n     * @param {Number} row A row to compare with\n     * @param {Number} column A column to compare with\n     * @returns {Boolean}\n     **/\n    this.isStart = function(row, column) {\n        return this.start.row == row && this.start.column == column;\n    };\n\n    /**\n     * Sets the starting row and column for the range.\n     * @param {Number|Ace.Point} row A row to set\n     * @param {Number} column A column to set\n     *\n     **/\n    this.setStart = function(row, column) {\n        if (typeof row == \"object\") {\n            this.start.column = row.column;\n            this.start.row = row.row;\n        } else {\n            this.start.row = row;\n            this.start.column = column;\n        }\n    };\n\n    /**\n     * Sets the starting row and column for the range.\n     * @param {Number|Ace.Point} row A row to set\n     * @param {Number} column A column to set\n     *\n     **/\n    this.setEnd = function(row, column) {\n        if (typeof row == \"object\") {\n            this.end.column = row.column;\n            this.end.row = row.row;\n        } else {\n            this.end.row = row;\n            this.end.column = column;\n        }\n    };\n\n    /**\n     * Returns `true` if the `row` and `column` are within the given range.\n     * @param {Number} row A row to compare with\n     * @param {Number} column A column to compare with\n     * @returns {Boolean}\n     * @related [[Range.compare]]\n     **/\n    this.inside = function(row, column) {\n        if (this.compare(row, column) == 0) {\n            if (this.isEnd(row, column) || this.isStart(row, column)) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    /**\n     * Returns `true` if the `row` and `column` are within the given range's starting [[Point]].\n     * @param {Number} row A row to compare with\n     * @param {Number} column A column to compare with\n     * @returns {Boolean}\n     * @related [[Range.compare]]\n     **/\n    this.insideStart = function(row, column) {\n        if (this.compare(row, column) == 0) {\n            if (this.isEnd(row, column)) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    /**\n     * Returns `true` if the `row` and `column` are within the given range's ending [[Point]].\n     * @param {Number} row A row to compare with\n     * @param {Number} column A column to compare with\n     * @returns {Boolean}\n     * @related [[Range.compare]]\n     *\n     **/\n    this.insideEnd = function(row, column) {\n        if (this.compare(row, column) == 0) {\n            if (this.isStart(row, column)) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    /**\n     * Compares the `row` and `column` with the starting and ending [[Point]]'s of the calling range.\n     * @param {Number} row A row to compare with\n     * @param {Number} column A column to compare with\n     * @returns {Number} This method returns one of the following numbers:\n     * * `1` if `row` is greater than the calling range\n     * * `-1` if `row` is less then the calling range\n     * * `0` otherwise\n     *\n     * If the starting row of the calling range is equal to `row`, and:\n     * * `column` is greater than or equal to the calling range's starting column, this returns `0`\n     * * Otherwise, it returns -1\n     *\n     * If the ending row of the calling range is equal to `row`, and:\n     * * `column` is less than or equal to the calling range's ending column, this returns `0`\n     * * Otherwise, it returns 1\n     **/\n    this.compare = function(row, column) {\n        if (!this.isMultiLine()) {\n            if (row === this.start.row) {\n                return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);\n            }\n        }\n\n        if (row < this.start.row)\n            return -1;\n\n        if (row > this.end.row)\n            return 1;\n\n        if (this.start.row === row)\n            return column >= this.start.column ? 0 : -1;\n\n        if (this.end.row === row)\n            return column <= this.end.column ? 0 : 1;\n\n        return 0;\n    };\n\n    /**\n     * Compares the `row` and `column` with the starting and ending [[Point]]'s of the calling range.\n     * @param {Number} row A row to compare with\n     * @param {Number} column A column to compare with\n     * @returns {Number} This method returns one of the following numbers:\n     * * `-1` if calling range's starting column and calling range's starting row are equal `row` and `column`\n     * * Otherwise, it returns the value after calling [[Range.compare `compare()`]].\n     **/\n    this.compareStart = function(row, column) {\n        if (this.start.row == row && this.start.column == column) {\n            return -1;\n        } else {\n            return this.compare(row, column);\n        }\n    };\n\n    /**\n     * Compares the `row` and `column` with the starting and ending [[Point]]'s of the calling range.\n     * @param {Number} row A row to compare with\n     * @param {Number} column A column to compare with\n     * @returns {Number} This method returns one of the following numbers:\n     * * `1` if calling range's ending column and calling range's ending row are equal `row` and `column`.\n     * * Otherwise, it returns the value after calling [[Range.compare `compare()`]].\n     */\n    this.compareEnd = function(row, column) {\n        if (this.end.row == row && this.end.column == column) {\n            return 1;\n        } else {\n            return this.compare(row, column);\n        }\n    };\n\n    /**\n     * Compares the `row` and `column` with the start and end [[Point]]'s of the calling range.\n     * @param {Number} row A row to compare with\n     * @param {Number} column A column to compare with\n     * @returns {Number} This method returns one of the following numbers:\n     * * `1` if the ending row of the calling range is equal to `row`, and the ending column of the calling range is equal to `column`\n     * * `-1` if the starting row of the calling range is equal to `row`, and the starting column of the calling range is equal to `column`\n     * * Otherwise, it returns the value after calling [[Range.compare `compare()`]].\n     **/\n    this.compareInside = function(row, column) {\n        if (this.end.row == row && this.end.column == column) {\n            return 1;\n        } else if (this.start.row == row && this.start.column == column) {\n            return -1;\n        } else {\n            return this.compare(row, column);\n        }\n    };\n\n    /**\n     * Returns the part of the current `Range` that occurs within the boundaries of `firstRow` and `lastRow` as a new `Range` object.\n     * @param {Number} firstRow The starting row\n     * @param {Number} lastRow The ending row\n     * @returns {Range}\n    **/\n    this.clipRows = function(firstRow, lastRow) {\n        if (this.end.row > lastRow)\n            var end = {row: lastRow + 1, column: 0};\n        else if (this.end.row < firstRow)\n            var end = {row: firstRow, column: 0};\n\n        if (this.start.row > lastRow)\n            var start = {row: lastRow + 1, column: 0};\n        else if (this.start.row < firstRow)\n            var start = {row: firstRow, column: 0};\n\n        return Range.fromPoints(start || this.start, end || this.end);\n    };\n\n    /**\n     * Changes the `row` and `column` for the calling range for both the starting and ending [[Point]]'s.\n     * @param {Number} row A new row to extend to\n     * @param {Number} column A new column to extend to\n     * @returns {Range} The original range with the new row\n    **/\n    this.extend = function(row, column) {\n        var cmp = this.compare(row, column);\n\n        if (cmp == 0)\n            return this;\n        else if (cmp == -1)\n            var start = {row: row, column: column};\n        else\n            var end = {row: row, column: column};\n\n        return Range.fromPoints(start || this.start, end || this.end);\n    };\n\n    /**\n     * Returns `true` if the calling range is empty (starting [[Point]] == ending [[Point]]).\n     * @returns {Boolean}\n     **/\n    this.isEmpty = function() {\n        return (this.start.row === this.end.row && this.start.column === this.end.column);\n    };\n\n    /**\n     * Returns `true` if the range spans across multiple lines.\n     * @returns {Boolean}\n    **/\n    this.isMultiLine = function() {\n        return (this.start.row !== this.end.row);\n    };\n\n    /**\n     * Returns a duplicate of the calling range.\n     * @returns {Range}\n    **/\n    this.clone = function() {\n        return Range.fromPoints(this.start, this.end);\n    };\n\n    /**\n     * Returns a range containing the starting and ending rows of the original range, but with a column value of `0`.\n     * @returns {Range}\n    **/\n    this.collapseRows = function() {\n        if (this.end.column == 0)\n            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row-1), 0);\n        else\n            return new Range(this.start.row, 0, this.end.row, 0);\n    };\n\n    /**\n     * Given the current `Range`, this function converts those starting and ending [[Point]]'s into screen positions, and then returns a new `Range` object.\n     * @param {EditSession} session The `EditSession` to retrieve coordinates from\n     * @returns {Range}\n    **/\n    this.toScreenRange = function(session) {\n        var screenPosStart = session.documentToScreenPosition(this.start);\n        var screenPosEnd = session.documentToScreenPosition(this.end);\n\n        return new Range(\n            screenPosStart.row, screenPosStart.column,\n            screenPosEnd.row, screenPosEnd.column\n        );\n    };\n\n    /**\n     * Shift the calling range by `row` and `column` values.\n     * @param {Number} row\n     * @param {Number} column\n     * @experimental\n     */\n    this.moveBy = function(row, column) {\n        this.start.row += row;\n        this.start.column += column;\n        this.end.row += row;\n        this.end.column += column;\n    };\n\n}).call(Range.prototype);\n\n/**\n * Creates and returns a new `Range` based on the `start` [[Point]] and `end` [[Point]] of the given parameters.\n * @param {Point} start A starting point to use\n * @param {Point} end An ending point to use\n * @returns {Range}\n**/\nRange.fromPoints = function(start, end) {\n    return new Range(start.row, start.column, end.row, end.column);\n};\nRange.comparePoints = comparePoints;\n\n/**\n * Compares `p1` and `p2` [[Point]]'s, useful for sorting\n * @param {Ace.Point} p1\n * @param {Ace.Point} p2\n * @returns {Number}\n */\nRange.comparePoints = function(p1, p2) {\n    return p1.row - p2.row || p1.column - p2.column;\n};\n\n\nexports.Range = Range;\n"],"names":[],"sourceRoot":""}