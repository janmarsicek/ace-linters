(self["webpackChunkace_linters_root"] = self["webpackChunkace_linters_root"] || []).push([[2154],{

/***/ 62154:
/***/ (function(module) {

function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
(function webpackUniversalModuleDefinition(root, factory) {
    if (true) module.exports = factory();
    else { var i, a; }
})(this, ()=>{
    return /******/ (()=>{
        /******/ var __webpack_modules__ = {
            /***/ 1696: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_810__)=>{
                "use strict";
                /* provided dependency */ var process = __nested_webpack_require_810__(4406);
                /* provided dependency */ var console = __nested_webpack_require_810__(3716);
                // Currently in sync with Node.js lib/assert.js
                // https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b
                // Originally from narwhal.js (http://narwhaljs.org)
                // Copyright (c) 2009 Thomas Robinson <280north.com>
                //
                // Permission is hereby granted, free of charge, to any person obtaining a copy
                // of this software and associated documentation files (the 'Software'), to
                // deal in the Software without restriction, including without limitation the
                // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
                // sell copies of the Software, and to permit persons to whom the Software is
                // furnished to do so, subject to the following conditions:
                //
                // The above copyright notice and this permission notice shall be included in
                // all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                // AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
                // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                var _require = __nested_webpack_require_810__(7515), _require$codes = _require.codes, ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE, ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
                var AssertionError = __nested_webpack_require_810__(4082);
                var _require2 = __nested_webpack_require_810__(3335), inspect = _require2.inspect;
                var _require$types = __nested_webpack_require_810__(3335).types, isPromise = _require$types.isPromise, isRegExp = _require$types.isRegExp;
                var objectAssign = Object.assign ? Object.assign : __nested_webpack_require_810__(4956).assign;
                var objectIs = Object.is ? Object.is : __nested_webpack_require_810__(4679);
                var errorCache = new Map();
                var isDeepEqual;
                var isDeepStrictEqual;
                var parseExpressionAt;
                var findNodeAround;
                var decoder;
                function lazyLoadComparison() {
                    var comparison = __nested_webpack_require_810__(6796);
                    isDeepEqual = comparison.isDeepEqual;
                    isDeepStrictEqual = comparison.isDeepStrictEqual;
                } // Escape control characters but not \n and \t to keep the line breaks and
                // indentation intact.
                // eslint-disable-next-line no-control-regex
                var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
                var meta = /* unused pure expression or super */ null && 0;
                var escapeFn = function escapeFn(str) {
                    return meta[str.charCodeAt(0)];
                };
                var warned = false; // The assert module provides functions that throw
                // AssertionError's when particular conditions are not met. The
                // assert module must conform to the following interface.
                var assert = module1.exports = ok;
                var NO_EXCEPTION_SENTINEL = {}; // All of the following functions must throw an AssertionError
                // when a corresponding condition is not met, with a message that
                // may be undefined if not provided. All assertion methods provide
                // both the actual and expected values to the assertion error for
                // display purposes.
                function innerFail(obj) {
                    if (obj.message instanceof Error) throw obj.message;
                    throw new AssertionError(obj);
                }
                function fail(actual, expected, message, operator, stackStartFn) {
                    var argsLen = arguments.length;
                    var internalMessage;
                    if (argsLen === 0) {
                        internalMessage = 'Failed';
                    } else if (argsLen === 1) {
                        message = actual;
                        actual = undefined;
                    } else {
                        if (warned === false) {
                            warned = true;
                            var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
                            warn('assert.fail() with more than one argument is deprecated. ' + 'Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094');
                        }
                        if (argsLen === 2) operator = '!=';
                    }
                    if (message instanceof Error) throw message;
                    var errArgs = {
                        actual: actual,
                        expected: expected,
                        operator: operator === undefined ? 'fail' : operator,
                        stackStartFn: stackStartFn || fail
                    };
                    if (message !== undefined) {
                        errArgs.message = message;
                    }
                    var err = new AssertionError(errArgs);
                    if (internalMessage) {
                        err.message = internalMessage;
                        err.generatedMessage = true;
                    }
                    throw err;
                }
                assert.fail = fail; // The AssertionError is defined in internal/error.
                assert.AssertionError = AssertionError;
                function innerOk(fn, argLen, value, message) {
                    if (!value) {
                        var generatedMessage = false;
                        if (argLen === 0) {
                            generatedMessage = true;
                            message = 'No value argument passed to `assert.ok()`';
                        } else if (message instanceof Error) {
                            throw message;
                        }
                        var err = new AssertionError({
                            actual: value,
                            expected: true,
                            message: message,
                            operator: '==',
                            stackStartFn: fn
                        });
                        err.generatedMessage = generatedMessage;
                        throw err;
                    }
                } // Pure assertion tests whether a value is truthy, as determined
                // by !!value.
                function ok() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    innerOk.apply(void 0, [
                        ok,
                        args.length
                    ].concat(args));
                }
                assert.ok = ok; // The equality assertion tests shallow, coercive equality with ==.
                /* eslint-disable no-restricted-properties */ assert.equal = function equal(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    } // eslint-disable-next-line eqeqeq
                    if (actual != expected) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: '==',
                            stackStartFn: equal
                        });
                    }
                }; // The non-equality assertion tests for whether two objects are not
                // equal with !=.
                assert.notEqual = function notEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    } // eslint-disable-next-line eqeqeq
                    if (actual == expected) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: '!=',
                            stackStartFn: notEqual
                        });
                    }
                }; // The equivalence assertion tests a deep equality relation.
                assert.deepEqual = function deepEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (!isDeepEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'deepEqual',
                            stackStartFn: deepEqual
                        });
                    }
                }; // The non-equivalence assertion tests for any deep inequality.
                assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (isDeepEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'notDeepEqual',
                            stackStartFn: notDeepEqual
                        });
                    }
                };
                /* eslint-enable */ assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (!isDeepStrictEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'deepStrictEqual',
                            stackStartFn: deepStrictEqual
                        });
                    }
                };
                assert.notDeepStrictEqual = notDeepStrictEqual;
                function notDeepStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (isDeepStrictEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'notDeepStrictEqual',
                            stackStartFn: notDeepStrictEqual
                        });
                    }
                }
                assert.strictEqual = function strictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (!objectIs(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'strictEqual',
                            stackStartFn: strictEqual
                        });
                    }
                };
                assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (objectIs(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'notStrictEqual',
                            stackStartFn: notStrictEqual
                        });
                    }
                };
                var Comparison = function Comparison(obj, keys, actual) {
                    var _this = this;
                    _classCallCheck(this, Comparison);
                    keys.forEach(function(key) {
                        if (key in obj) {
                            if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && obj[key].test(actual[key])) {
                                _this[key] = actual[key];
                            } else {
                                _this[key] = obj[key];
                            }
                        }
                    });
                };
                function compareExceptionKey(actual, expected, key, message, keys, fn) {
                    if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
                        if (!message) {
                            // Create placeholder objects to create a nice output.
                            var a = new Comparison(actual, keys);
                            var b = new Comparison(expected, keys, actual);
                            var err = new AssertionError({
                                actual: a,
                                expected: b,
                                operator: 'deepStrictEqual',
                                stackStartFn: fn
                            });
                            err.actual = actual;
                            err.expected = expected;
                            err.operator = fn.name;
                            throw err;
                        }
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: fn.name,
                            stackStartFn: fn
                        });
                    }
                }
                function expectedException(actual, expected, msg, fn) {
                    if (typeof expected !== 'function') {
                        if (isRegExp(expected)) return expected.test(actual); // assert.doesNotThrow does not accept objects.
                        if (arguments.length === 2) {
                            throw new ERR_INVALID_ARG_TYPE('expected', [
                                'Function',
                                'RegExp'
                            ], expected);
                        } // Handle primitives properly.
                        if (_typeof(actual) !== 'object' || actual === null) {
                            var err = new AssertionError({
                                actual: actual,
                                expected: expected,
                                message: msg,
                                operator: 'deepStrictEqual',
                                stackStartFn: fn
                            });
                            err.operator = fn.name;
                            throw err;
                        }
                        var keys = Object.keys(expected); // Special handle errors to make sure the name and the message are compared
                        // as well.
                        if (expected instanceof Error) {
                            keys.push('name', 'message');
                        } else if (keys.length === 0) {
                            throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');
                        }
                        if (isDeepEqual === undefined) lazyLoadComparison();
                        keys.forEach(function(key) {
                            if (typeof actual[key] === 'string' && isRegExp(expected[key]) && expected[key].test(actual[key])) {
                                return;
                            }
                            compareExceptionKey(actual, expected, key, msg, keys, fn);
                        });
                        return true;
                    } // Guard instanceof against arrow functions as they don't have a prototype.
                    if (expected.prototype !== undefined && actual instanceof expected) {
                        return true;
                    }
                    if (Error.isPrototypeOf(expected)) {
                        return false;
                    }
                    return expected.call({}, actual) === true;
                }
                function getActual(fn) {
                    if (typeof fn !== 'function') {
                        throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);
                    }
                    try {
                        fn();
                    } catch (e) {
                        return e;
                    }
                    return NO_EXCEPTION_SENTINEL;
                }
                function checkIsPromise(obj) {
                    // Accept native ES6 promises and promises that are implemented in a similar
                    // way. Do not accept thenables that use a function as `obj` and that have no
                    // `catch` handler.
                    // TODO: thenables are checked up until they have the correct methods,
                    // but according to documentation, the `then` method should receive
                    // the `fulfill` and `reject` arguments as well or it may be never resolved.
                    return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';
                }
                function waitForActual(promiseFn) {
                    return Promise.resolve().then(function() {
                        var resultPromise;
                        if (typeof promiseFn === 'function') {
                            // Return a rejected promise if `promiseFn` throws synchronously.
                            resultPromise = promiseFn(); // Fail in case no promise is returned.
                            if (!checkIsPromise(resultPromise)) {
                                throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);
                            }
                        } else if (checkIsPromise(promiseFn)) {
                            resultPromise = promiseFn;
                        } else {
                            throw new ERR_INVALID_ARG_TYPE('promiseFn', [
                                'Function',
                                'Promise'
                            ], promiseFn);
                        }
                        return Promise.resolve().then(function() {
                            return resultPromise;
                        }).then(function() {
                            return NO_EXCEPTION_SENTINEL;
                        }).catch(function(e) {
                            return e;
                        });
                    });
                }
                function expectsError(stackStartFn, actual, error, message) {
                    if (typeof error === 'string') {
                        if (arguments.length === 4) {
                            throw new ERR_INVALID_ARG_TYPE('error', [
                                'Object',
                                'Error',
                                'Function',
                                'RegExp'
                            ], error);
                        }
                        if (_typeof(actual) === 'object' && actual !== null) {
                            if (actual.message === error) {
                                throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error message \"".concat(actual.message, "\" is identical to the message."));
                            }
                        } else if (actual === error) {
                            throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error \"".concat(actual, "\" is identical to the message."));
                        }
                        message = error;
                        error = undefined;
                    } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') {
                        throw new ERR_INVALID_ARG_TYPE('error', [
                            'Object',
                            'Error',
                            'Function',
                            'RegExp'
                        ], error);
                    }
                    if (actual === NO_EXCEPTION_SENTINEL) {
                        var details = '';
                        if (error && error.name) {
                            details += " (".concat(error.name, ")");
                        }
                        details += message ? ": ".concat(message) : '.';
                        var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';
                        innerFail({
                            actual: undefined,
                            expected: error,
                            operator: stackStartFn.name,
                            message: "Missing expected ".concat(fnType).concat(details),
                            stackStartFn: stackStartFn
                        });
                    }
                    if (error && !expectedException(actual, error, message, stackStartFn)) {
                        throw actual;
                    }
                }
                function expectsNoError(stackStartFn, actual, error, message) {
                    if (actual === NO_EXCEPTION_SENTINEL) return;
                    if (typeof error === 'string') {
                        message = error;
                        error = undefined;
                    }
                    if (!error || expectedException(actual, error)) {
                        var details = message ? ": ".concat(message) : '.';
                        var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';
                        innerFail({
                            actual: actual,
                            expected: error,
                            operator: stackStartFn.name,
                            message: "Got unwanted ".concat(fnType).concat(details, "\n") + "Actual message: \"".concat(actual && actual.message, "\""),
                            stackStartFn: stackStartFn
                        });
                    }
                    throw actual;
                }
                assert.throws = function throws(promiseFn) {
                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                        args[_key2 - 1] = arguments[_key2];
                    }
                    expectsError.apply(void 0, [
                        throws,
                        getActual(promiseFn)
                    ].concat(args));
                };
                assert.rejects = function rejects(promiseFn) {
                    for(var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++){
                        args[_key3 - 1] = arguments[_key3];
                    }
                    return waitForActual(promiseFn).then(function(result) {
                        return expectsError.apply(void 0, [
                            rejects,
                            result
                        ].concat(args));
                    });
                };
                assert.doesNotThrow = function doesNotThrow(fn) {
                    for(var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++){
                        args[_key4 - 1] = arguments[_key4];
                    }
                    expectsNoError.apply(void 0, [
                        doesNotThrow,
                        getActual(fn)
                    ].concat(args));
                };
                assert.doesNotReject = function doesNotReject(fn) {
                    for(var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++){
                        args[_key5 - 1] = arguments[_key5];
                    }
                    return waitForActual(fn).then(function(result) {
                        return expectsNoError.apply(void 0, [
                            doesNotReject,
                            result
                        ].concat(args));
                    });
                };
                assert.ifError = function ifError(err) {
                    if (err !== null && err !== undefined) {
                        var message = 'ifError got unwanted exception: ';
                        if (_typeof(err) === 'object' && typeof err.message === 'string') {
                            if (err.message.length === 0 && err.constructor) {
                                message += err.constructor.name;
                            } else {
                                message += err.message;
                            }
                        } else {
                            message += inspect(err);
                        }
                        var newErr = new AssertionError({
                            actual: err,
                            expected: null,
                            operator: 'ifError',
                            message: message,
                            stackStartFn: ifError
                        }); // Make sure we actually have a stack trace!
                        var origStack = err.stack;
                        if (typeof origStack === 'string') {
                            // This will remove any duplicated frames from the error frames taken
                            // from within `ifError` and add the original error frames to the newly
                            // created ones.
                            var tmp2 = origStack.split('\n');
                            tmp2.shift(); // Filter all frames existing in err.stack.
                            var tmp1 = newErr.stack.split('\n');
                            for(var i = 0; i < tmp2.length; i++){
                                // Find the first occurrence of the frame.
                                var pos = tmp1.indexOf(tmp2[i]);
                                if (pos !== -1) {
                                    // Only keep new frames.
                                    tmp1 = tmp1.slice(0, pos);
                                    break;
                                }
                            }
                            newErr.stack = "".concat(tmp1.join('\n'), "\n").concat(tmp2.join('\n'));
                        }
                        throw newErr;
                    }
                }; // Expose a strict only variant of assert
                function strict() {
                    for(var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++){
                        args[_key6] = arguments[_key6];
                    }
                    innerOk.apply(void 0, [
                        strict,
                        args.length
                    ].concat(args));
                }
                assert.strict = objectAssign(strict, assert, {
                    equal: assert.strictEqual,
                    deepEqual: assert.deepStrictEqual,
                    notEqual: assert.notStrictEqual,
                    notDeepEqual: assert.notDeepStrictEqual
                });
                assert.strict.strict = assert.strict;
            /***/ },
            /***/ 4082: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_32028__)=>{
                "use strict";
                /* provided dependency */ var process = __nested_webpack_require_32028__(4406);
                // Currently in sync with Node.js lib/internal/assert/assertion_error.js
                // https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c
                function _objectSpread(target) {
                    for(var i = 1; i < arguments.length; i++){
                        var source = arguments[i] != null ? arguments[i] : {};
                        var ownKeys = Object.keys(source);
                        if (typeof Object.getOwnPropertySymbols === 'function') {
                            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                            }));
                        }
                        ownKeys.forEach(function(key) {
                            _defineProperty(target, key, source[key]);
                        });
                    }
                    return target;
                }
                function _defineProperty(obj, key, value) {
                    if (key in obj) {
                        Object.defineProperty(obj, key, {
                            value: value,
                            enumerable: true,
                            configurable: true,
                            writable: true
                        });
                    } else {
                        obj[key] = value;
                    }
                    return obj;
                }
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                function _defineProperties(target, props) {
                    for(var i = 0; i < props.length; i++){
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    return Constructor;
                }
                function _possibleConstructorReturn(self, call) {
                    if (call && (_typeof(call) === "object" || typeof call === "function")) {
                        return call;
                    }
                    return _assertThisInitialized(self);
                }
                function _assertThisInitialized(self) {
                    if (self === void 0) {
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    }
                    return self;
                }
                function _inherits(subClass, superClass) {
                    if (typeof superClass !== "function" && superClass !== null) {
                        throw new TypeError("Super expression must either be null or a function");
                    }
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            writable: true,
                            configurable: true
                        }
                    });
                    if (superClass) _setPrototypeOf(subClass, superClass);
                }
                function _wrapNativeSuper(Class) {
                    var _cache = typeof Map === "function" ? new Map() : undefined;
                    _wrapNativeSuper = function _wrapNativeSuper(Class) {
                        if (Class === null || !_isNativeFunction(Class)) return Class;
                        if (typeof Class !== "function") {
                            throw new TypeError("Super expression must either be null or a function");
                        }
                        if (typeof _cache !== "undefined") {
                            if (_cache.has(Class)) return _cache.get(Class);
                            _cache.set(Class, Wrapper);
                        }
                        function Wrapper() {
                            return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                        }
                        Wrapper.prototype = Object.create(Class.prototype, {
                            constructor: {
                                value: Wrapper,
                                enumerable: false,
                                writable: true,
                                configurable: true
                            }
                        });
                        return _setPrototypeOf(Wrapper, Class);
                    };
                    return _wrapNativeSuper(Class);
                }
                function isNativeReflectConstruct() {
                    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if (typeof Proxy === "function") return true;
                    try {
                        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
                        return true;
                    } catch (e) {
                        return false;
                    }
                }
                function _construct(Parent, args, Class) {
                    if (isNativeReflectConstruct()) {
                        _construct = Reflect.construct;
                    } else {
                        _construct = function _construct(Parent, args, Class) {
                            var a = [
                                null
                            ];
                            a.push.apply(a, args);
                            var Constructor = Function.bind.apply(Parent, a);
                            var instance = new Constructor();
                            if (Class) _setPrototypeOf(instance, Class.prototype);
                            return instance;
                        };
                    }
                    return _construct.apply(null, arguments);
                }
                function _isNativeFunction(fn) {
                    return Function.toString.call(fn).indexOf("[native code]") !== -1;
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                        o.__proto__ = p;
                        return o;
                    };
                    return _setPrototypeOf(o, p);
                }
                function _getPrototypeOf(o) {
                    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                        return o.__proto__ || Object.getPrototypeOf(o);
                    };
                    return _getPrototypeOf(o);
                }
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                var _require = __nested_webpack_require_32028__(3335), inspect = _require.inspect;
                var _require2 = __nested_webpack_require_32028__(7515), ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
                function endsWith(str, search, this_len) {
                    if (this_len === undefined || this_len > str.length) {
                        this_len = str.length;
                    }
                    return str.substring(this_len - search.length, this_len) === search;
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
                function repeat(str, count) {
                    count = Math.floor(count);
                    if (str.length == 0 || count == 0) return '';
                    var maxCount = str.length * count;
                    count = Math.floor(Math.log(count) / Math.log(2));
                    while(count){
                        str += str;
                        count--;
                    }
                    str += str.substring(0, maxCount - str.length);
                    return str;
                }
                var blue = '';
                var green = '';
                var red = '';
                var white = '';
                var kReadableOperator = {
                    deepStrictEqual: 'Expected values to be strictly deep-equal:',
                    strictEqual: 'Expected values to be strictly equal:',
                    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
                    deepEqual: 'Expected values to be loosely deep-equal:',
                    equal: 'Expected values to be loosely equal:',
                    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
                    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
                    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
                    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
                    notEqual: 'Expected "actual" to be loosely unequal to:',
                    notIdentical: 'Values identical but not reference-equal:'
                }; // Comparing short primitives should just show === / !== instead of using the
                // diff.
                var kMaxShortLength = 10;
                function copyError(source) {
                    var keys = Object.keys(source);
                    var target = Object.create(Object.getPrototypeOf(source));
                    keys.forEach(function(key) {
                        target[key] = source[key];
                    });
                    Object.defineProperty(target, 'message', {
                        value: source.message
                    });
                    return target;
                }
                function inspectValue(val) {
                    // The util.inspect default values could be changed. This makes sure the
                    // error messages contain the necessary information nevertheless.
                    return inspect(val, {
                        compact: false,
                        customInspect: false,
                        depth: 1000,
                        maxArrayLength: Infinity,
                        // Assert compares only enumerable properties (with a few exceptions).
                        showHidden: false,
                        // Having a long line as error is better than wrapping the line for
                        // comparison for now.
                        // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
                        // have meta information about the inspected properties (i.e., know where
                        // in what line the property starts and ends).
                        breakLength: Infinity,
                        // Assert does not detect proxies currently.
                        showProxy: false,
                        sorted: true,
                        // Inspect getters as we also check them when comparing entries.
                        getters: true
                    });
                }
                function createErrDiff(actual, expected, operator) {
                    var other = '';
                    var res = '';
                    var lastPos = 0;
                    var end = '';
                    var skipped = false;
                    var actualInspected = inspectValue(actual);
                    var actualLines = actualInspected.split('\n');
                    var expectedLines = inspectValue(expected).split('\n');
                    var i = 0;
                    var indicator = ''; // In case both values are objects explicitly mark them as not reference equal
                    // for the `strictEqual` operator.
                    if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) {
                        operator = 'strictEqualObject';
                    } // If "actual" and "expected" fit on a single line and they are not strictly
                    // equal, check further special handling.
                    if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
                        var inputLength = actualLines[0].length + expectedLines[0].length; // If the character length of "actual" and "expected" together is less than
                        // kMaxShortLength and if neither is an object and at least one of them is
                        // not `zero`, use the strict equal comparison to visualize the output.
                        if (inputLength <= kMaxShortLength) {
                            if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) {
                                // -0 === +0
                                return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
                            }
                        } else if (operator !== 'strictEqualObject') {
                            // If the stderr is a tty and the input length is lower than the current
                            // columns per line, add a mismatch indicator below the output. If it is
                            // not a tty, use a default value of 80 characters.
                            var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
                            if (inputLength < maxLength) {
                                while(actualLines[0][i] === expectedLines[0][i]){
                                    i++;
                                } // Ignore the first characters.
                                if (i > 2) {
                                    // Add position indicator for the first mismatch in case it is a
                                    // single line and the input length is less than the column length.
                                    indicator = "\n  ".concat(repeat(' ', i), "^");
                                    i = 0;
                                }
                            }
                        }
                    } // Remove all ending lines that match (this optimizes the output for
                    // readability by reducing the number of total changed lines).
                    var a = actualLines[actualLines.length - 1];
                    var b = expectedLines[expectedLines.length - 1];
                    while(a === b){
                        if (i++ < 2) {
                            end = "\n  ".concat(a).concat(end);
                        } else {
                            other = a;
                        }
                        actualLines.pop();
                        expectedLines.pop();
                        if (actualLines.length === 0 || expectedLines.length === 0) break;
                        a = actualLines[actualLines.length - 1];
                        b = expectedLines[expectedLines.length - 1];
                    }
                    var maxLines = Math.max(actualLines.length, expectedLines.length); // Strict equal with identical objects that are not identical by reference.
                    // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })
                    if (maxLines === 0) {
                        // We have to get the result again. The lines were all removed before.
                        var _actualLines = actualInspected.split('\n'); // Only remove lines in case it makes sense to collapse those.
                        // TODO: Accept env to always show the full error.
                        if (_actualLines.length > 30) {
                            _actualLines[26] = "".concat(blue, "...").concat(white);
                            while(_actualLines.length > 27){
                                _actualLines.pop();
                            }
                        }
                        return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join('\n'), "\n");
                    }
                    if (i > 3) {
                        end = "\n".concat(blue, "...").concat(white).concat(end);
                        skipped = true;
                    }
                    if (other !== '') {
                        end = "\n  ".concat(other).concat(end);
                        other = '';
                    }
                    var printedLines = 0;
                    var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
                    var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
                    for(i = 0; i < maxLines; i++){
                        // Only extra expected lines exist
                        var cur = i - lastPos;
                        if (actualLines.length < i + 1) {
                            // If the last diverging line is more than one line above and the
                            // current line is at least line three, add some of the former lines and
                            // also add dots to indicate skipped entries.
                            if (cur > 1 && i > 2) {
                                if (cur > 4) {
                                    res += "\n".concat(blue, "...").concat(white);
                                    skipped = true;
                                } else if (cur > 3) {
                                    res += "\n  ".concat(expectedLines[i - 2]);
                                    printedLines++;
                                }
                                res += "\n  ".concat(expectedLines[i - 1]);
                                printedLines++;
                            } // Mark the current line as the last diverging one.
                            lastPos = i; // Add the expected line to the cache.
                            other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
                            printedLines++; // Only extra actual lines exist
                        } else if (expectedLines.length < i + 1) {
                            // If the last diverging line is more than one line above and the
                            // current line is at least line three, add some of the former lines and
                            // also add dots to indicate skipped entries.
                            if (cur > 1 && i > 2) {
                                if (cur > 4) {
                                    res += "\n".concat(blue, "...").concat(white);
                                    skipped = true;
                                } else if (cur > 3) {
                                    res += "\n  ".concat(actualLines[i - 2]);
                                    printedLines++;
                                }
                                res += "\n  ".concat(actualLines[i - 1]);
                                printedLines++;
                            } // Mark the current line as the last diverging one.
                            lastPos = i; // Add the actual line to the result.
                            res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
                            printedLines++; // Lines diverge
                        } else {
                            var expectedLine = expectedLines[i];
                            var actualLine = actualLines[i]; // If the lines diverge, specifically check for lines that only diverge by
                            // a trailing comma. In that case it is actually identical and we should
                            // mark it as such.
                            var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine); // If the expected line has a trailing comma but is otherwise identical,
                            // add a comma at the end of the actual line. Otherwise the output could
                            // look weird as in:
                            //
                            //   [
                            //     1         // No comma at the end!
                            // +   2
                            //   ]
                            //
                            if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {
                                divergingLines = false;
                                actualLine += ',';
                            }
                            if (divergingLines) {
                                // If the last diverging line is more than one line above and the
                                // current line is at least line three, add some of the former lines and
                                // also add dots to indicate skipped entries.
                                if (cur > 1 && i > 2) {
                                    if (cur > 4) {
                                        res += "\n".concat(blue, "...").concat(white);
                                        skipped = true;
                                    } else if (cur > 3) {
                                        res += "\n  ".concat(actualLines[i - 2]);
                                        printedLines++;
                                    }
                                    res += "\n  ".concat(actualLines[i - 1]);
                                    printedLines++;
                                } // Mark the current line as the last diverging one.
                                lastPos = i; // Add the actual line to the result and cache the expected diverging
                                // line so consecutive diverging lines show up as +++--- and not +-+-+-.
                                res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
                                other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
                                printedLines += 2; // Lines are identical
                            } else {
                                // Add all cached information to the result before adding other things
                                // and reset the cache.
                                res += other;
                                other = ''; // If the last diverging line is exactly one line above or if it is the
                                // very first line, add the line to the result.
                                if (cur === 1 || i === 0) {
                                    res += "\n  ".concat(actualLine);
                                    printedLines++;
                                }
                            }
                        } // Inspected object to big (Show ~20 rows max)
                        if (printedLines > 20 && i < maxLines - 2) {
                            return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
                        }
                    }
                    return "".concat(msg).concat(skipped ? skippedMsg : '', "\n").concat(res).concat(other).concat(end).concat(indicator);
                }
                var AssertionError = /*#__PURE__*/ function(_Error) {
                    _inherits(AssertionError, _Error);
                    function AssertionError(options) {
                        var _this;
                        _classCallCheck(this, AssertionError);
                        if (_typeof(options) !== 'object' || options === null) {
                            throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
                        }
                        var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
                        var actual = options.actual, expected = options.expected;
                        var limit = Error.stackTraceLimit;
                        Error.stackTraceLimit = 0;
                        if (message != null) {
                            _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, String(message)));
                        } else {
                            if (process.stderr && process.stderr.isTTY) {
                                // Reset on each call to make sure we handle dynamically set environment
                                // variables correct.
                                if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
                                    blue = "\x1B[34m";
                                    green = "\x1B[32m";
                                    white = "\x1B[39m";
                                    red = "\x1B[31m";
                                } else {
                                    blue = '';
                                    green = '';
                                    white = '';
                                    red = '';
                                }
                            } // Prevent the error stack from being visible by duplicating the error
                            // in a very close way to the original in case both sides are actually
                            // instances of Error.
                            if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {
                                actual = copyError(actual);
                                expected = copyError(expected);
                            }
                            if (operator === 'deepStrictEqual' || operator === 'strictEqual') {
                                _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, createErrDiff(actual, expected, operator)));
                            } else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {
                                // In case the objects are equal but the operator requires unequal, show
                                // the first object and say A equals B
                                var base = kReadableOperator[operator];
                                var res = inspectValue(actual).split('\n'); // In case "actual" is an object, it should not be reference equal.
                                if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) {
                                    base = kReadableOperator.notStrictEqualObject;
                                } // Only remove lines in case it makes sense to collapse those.
                                // TODO: Accept env to always show the full error.
                                if (res.length > 30) {
                                    res[26] = "".concat(blue, "...").concat(white);
                                    while(res.length > 27){
                                        res.pop();
                                    }
                                } // Only print a single input.
                                if (res.length === 1) {
                                    _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, " ").concat(res[0])));
                                } else {
                                    _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, "\n\n").concat(res.join('\n'), "\n")));
                                }
                            } else {
                                var _res = inspectValue(actual);
                                var other = '';
                                var knownOperators = kReadableOperator[operator];
                                if (operator === 'notDeepEqual' || operator === 'notEqual') {
                                    _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
                                    if (_res.length > 1024) {
                                        _res = "".concat(_res.slice(0, 1021), "...");
                                    }
                                } else {
                                    other = "".concat(inspectValue(expected));
                                    if (_res.length > 512) {
                                        _res = "".concat(_res.slice(0, 509), "...");
                                    }
                                    if (other.length > 512) {
                                        other = "".concat(other.slice(0, 509), "...");
                                    }
                                    if (operator === 'deepEqual' || operator === 'equal') {
                                        _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
                                    } else {
                                        other = " ".concat(operator, " ").concat(other);
                                    }
                                }
                                _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(_res).concat(other)));
                            }
                        }
                        Error.stackTraceLimit = limit;
                        _this.generatedMessage = !message;
                        Object.defineProperty(_assertThisInitialized(_this), 'name', {
                            value: 'AssertionError [ERR_ASSERTION]',
                            enumerable: false,
                            writable: true,
                            configurable: true
                        });
                        _this.code = 'ERR_ASSERTION';
                        _this.actual = actual;
                        _this.expected = expected;
                        _this.operator = operator;
                        if (Error.captureStackTrace) {
                            // eslint-disable-next-line no-restricted-syntax
                            Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
                        } // Create error message including the error code in the name.
                        _this.stack; // Reset the name.
                        _this.name = 'AssertionError';
                        return _possibleConstructorReturn(_this);
                    }
                    _createClass(AssertionError, [
                        {
                            key: "toString",
                            value: function toString() {
                                return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
                            }
                        },
                        {
                            key: inspect.custom,
                            value: function value(recurseTimes, ctx) {
                                // This limits the `actual` and `expected` property default inspection to
                                // the minimum depth. Otherwise those values would be too verbose compared
                                // to the actual error message which contains a combined view of these two
                                // input values.
                                return inspect(this, _objectSpread({}, ctx, {
                                    customInspect: false,
                                    depth: 0
                                }));
                            }
                        }
                    ]);
                    return AssertionError;
                }(_wrapNativeSuper(Error));
                module1.exports = AssertionError;
            /***/ },
            /***/ 7515: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_65617__)=>{
                "use strict";
                // Currently in sync with Node.js lib/internal/errors.js
                // https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f
                /* eslint node-core/documented-errors: "error" */ /* eslint node-core/alphabetize-errors: "error" */ /* eslint node-core/prefer-util-format-errors: "error" */ // The whole point behind this internal module is to allow Node.js to no
                // longer be forced to treat every error message change as a semver-major
                // change. The NodeError classes here all expose a `code` property whose
                // value statically and permanently identifies the error. While the error
                // message may change, the code should not.
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                function _possibleConstructorReturn(self, call) {
                    if (call && (_typeof(call) === "object" || typeof call === "function")) {
                        return call;
                    }
                    return _assertThisInitialized(self);
                }
                function _assertThisInitialized(self) {
                    if (self === void 0) {
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    }
                    return self;
                }
                function _getPrototypeOf(o) {
                    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                        return o.__proto__ || Object.getPrototypeOf(o);
                    };
                    return _getPrototypeOf(o);
                }
                function _inherits(subClass, superClass) {
                    if (typeof superClass !== "function" && superClass !== null) {
                        throw new TypeError("Super expression must either be null or a function");
                    }
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            writable: true,
                            configurable: true
                        }
                    });
                    if (superClass) _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                        o.__proto__ = p;
                        return o;
                    };
                    return _setPrototypeOf(o, p);
                }
                var codes = {}; // Lazy loaded
                var assert;
                var util;
                function createErrorType(code, message, Base) {
                    if (!Base) {
                        Base = Error;
                    }
                    function getMessage(arg1, arg2, arg3) {
                        if (typeof message === 'string') {
                            return message;
                        } else {
                            return message(arg1, arg2, arg3);
                        }
                    }
                    var NodeError = /*#__PURE__*/ function(_Base) {
                        _inherits(NodeError, _Base);
                        function NodeError(arg1, arg2, arg3) {
                            var _this;
                            _classCallCheck(this, NodeError);
                            _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError).call(this, getMessage(arg1, arg2, arg3)));
                            _this.code = code;
                            return _this;
                        }
                        return NodeError;
                    }(Base);
                    codes[code] = NodeError;
                } // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
                function oneOf(expected, thing) {
                    if (Array.isArray(expected)) {
                        var len = expected.length;
                        expected = expected.map(function(i) {
                            return String(i);
                        });
                        if (len > 2) {
                            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
                        } else if (len === 2) {
                            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
                        } else {
                            return "of ".concat(thing, " ").concat(expected[0]);
                        }
                    } else {
                        return "of ".concat(thing, " ").concat(String(expected));
                    }
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
                function startsWith(str, search, pos) {
                    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
                function endsWith(str, search, this_len) {
                    if (this_len === undefined || this_len > str.length) {
                        this_len = str.length;
                    }
                    return str.substring(this_len - search.length, this_len) === search;
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
                function includes(str, search, start) {
                    if (typeof start !== 'number') {
                        start = 0;
                    }
                    if (start + search.length > str.length) {
                        return false;
                    } else {
                        return str.indexOf(search, start) !== -1;
                    }
                }
                createErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The "%s" argument is ambiguous. %s', TypeError);
                createErrorType('ERR_INVALID_ARG_TYPE', function(name, expected, actual) {
                    if (assert === undefined) assert = __nested_webpack_require_65617__(1696);
                    assert(typeof name === 'string', "'name' must be a string"); // determiner: 'must be' or 'must not be'
                    var determiner;
                    if (typeof expected === 'string' && startsWith(expected, 'not ')) {
                        determiner = 'must not be';
                        expected = expected.replace(/^not /, '');
                    } else {
                        determiner = 'must be';
                    }
                    var msg;
                    if (endsWith(name, ' argument')) {
                        // For cases like 'first argument'
                        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
                    } else {
                        var type = includes(name, '.') ? 'property' : 'argument';
                        msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
                    } // TODO(BridgeAR): Improve the output by showing `null` and similar.
                    msg += ". Received type ".concat(_typeof(actual));
                    return msg;
                }, TypeError);
                createErrorType('ERR_INVALID_ARG_VALUE', function(name, value) {
                    var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';
                    if (util === undefined) util = __nested_webpack_require_65617__(3335);
                    var inspected = util.inspect(value);
                    if (inspected.length > 128) {
                        inspected = "".concat(inspected.slice(0, 128), "...");
                    }
                    return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
                }, TypeError, RangeError);
                createErrorType('ERR_INVALID_RETURN_VALUE', function(input, name, value) {
                    var type;
                    if (value && value.constructor && value.constructor.name) {
                        type = "instance of ".concat(value.constructor.name);
                    } else {
                        type = "type ".concat(_typeof(value));
                    }
                    return "Expected ".concat(input, " to be returned from the \"").concat(name, "\"") + " function but got ".concat(type, ".");
                }, TypeError);
                createErrorType('ERR_MISSING_ARGS', function() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    if (assert === undefined) assert = __nested_webpack_require_65617__(1696);
                    assert(args.length > 0, 'At least one arg needs to be specified');
                    var msg = 'The ';
                    var len = args.length;
                    args = args.map(function(a) {
                        return "\"".concat(a, "\"");
                    });
                    switch(len){
                        case 1:
                            msg += "".concat(args[0], " argument");
                            break;
                        case 2:
                            msg += "".concat(args[0], " and ").concat(args[1], " arguments");
                            break;
                        default:
                            msg += args.slice(0, len - 1).join(', ');
                            msg += ", and ".concat(args[len - 1], " arguments");
                            break;
                    }
                    return "".concat(msg, " must be specified");
                }, TypeError);
                module1.exports.codes = codes;
            /***/ },
            /***/ 6796: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_76678__)=>{
                "use strict";
                // Currently in sync with Node.js lib/internal/util/comparisons.js
                // https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
                function _slicedToArray(arr, i) {
                    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
                }
                function _nonIterableRest() {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
                function _iterableToArrayLimit(arr, i) {
                    var _arr = [];
                    var _n = true;
                    var _d = false;
                    var _e = undefined;
                    try {
                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){
                            _arr.push(_s.value);
                            if (i && _arr.length === i) break;
                        }
                    } catch (err) {
                        _d = true;
                        _e = err;
                    } finally{
                        try {
                            if (!_n && _i["return"] != null) _i["return"]();
                        } finally{
                            if (_d) throw _e;
                        }
                    }
                    return _arr;
                }
                function _arrayWithHoles(arr) {
                    if (Array.isArray(arr)) return arr;
                }
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                var regexFlagsSupported = /a/g.flags !== undefined;
                var arrayFromSet = function arrayFromSet(set) {
                    var array = [];
                    set.forEach(function(value) {
                        return array.push(value);
                    });
                    return array;
                };
                var arrayFromMap = function arrayFromMap(map) {
                    var array = [];
                    map.forEach(function(value, key) {
                        return array.push([
                            key,
                            value
                        ]);
                    });
                    return array;
                };
                var objectIs = Object.is ? Object.is : __nested_webpack_require_76678__(4679);
                var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
                    return [];
                };
                var numberIsNaN = Number.isNaN ? Number.isNaN : __nested_webpack_require_76678__(4782);
                function uncurryThis(f) {
                    return f.call.bind(f);
                }
                var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
                var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
                var objectToString = uncurryThis(Object.prototype.toString);
                var _require$types = __nested_webpack_require_76678__(3335).types, isAnyArrayBuffer = _require$types.isAnyArrayBuffer, isArrayBufferView = _require$types.isArrayBufferView, isDate = _require$types.isDate, isMap = _require$types.isMap, isRegExp = _require$types.isRegExp, isSet = _require$types.isSet, isNativeError = _require$types.isNativeError, isBoxedPrimitive = _require$types.isBoxedPrimitive, isNumberObject = _require$types.isNumberObject, isStringObject = _require$types.isStringObject, isBooleanObject = _require$types.isBooleanObject, isBigIntObject = _require$types.isBigIntObject, isSymbolObject = _require$types.isSymbolObject, isFloat32Array = _require$types.isFloat32Array, isFloat64Array = _require$types.isFloat64Array;
                function isNonIndex(key) {
                    if (key.length === 0 || key.length > 10) return true;
                    for(var i = 0; i < key.length; i++){
                        var code = key.charCodeAt(i);
                        if (code < 48 || code > 57) return true;
                    } // The maximum size for an array is 2 ** 32 -1.
                    return key.length === 10 && key >= Math.pow(2, 32);
                }
                function getOwnNonIndexProperties(value) {
                    return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
                } // Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
                // original notice:
                /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */ function compare(a, b) {
                    if (a === b) {
                        return 0;
                    }
                    var x = a.length;
                    var y = b.length;
                    for(var i = 0, len = Math.min(x, y); i < len; ++i){
                        if (a[i] !== b[i]) {
                            x = a[i];
                            y = b[i];
                            break;
                        }
                    }
                    if (x < y) {
                        return -1;
                    }
                    if (y < x) {
                        return 1;
                    }
                    return 0;
                }
                var ONLY_ENUMERABLE = undefined;
                var kStrict = true;
                var kLoose = false;
                var kNoIterator = 0;
                var kIsArray = 1;
                var kIsSet = 2;
                var kIsMap = 3; // Check if they have the same source and flags
                function areSimilarRegExps(a, b) {
                    return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
                }
                function areSimilarFloatArrays(a, b) {
                    if (a.byteLength !== b.byteLength) {
                        return false;
                    }
                    for(var offset = 0; offset < a.byteLength; offset++){
                        if (a[offset] !== b[offset]) {
                            return false;
                        }
                    }
                    return true;
                }
                function areSimilarTypedArrays(a, b) {
                    if (a.byteLength !== b.byteLength) {
                        return false;
                    }
                    return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
                }
                function areEqualArrayBuffers(buf1, buf2) {
                    return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
                }
                function isEqualBoxedPrimitive(val1, val2) {
                    if (isNumberObject(val1)) {
                        return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
                    }
                    if (isStringObject(val1)) {
                        return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
                    }
                    if (isBooleanObject(val1)) {
                        return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
                    }
                    if (isBigIntObject(val1)) {
                        return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
                    }
                    return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
                } // Notes: Type tags are historical [[Class]] properties that can be set by
                // FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
                // and retrieved using Object.prototype.toString.call(obj) in JS
                // See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
                // for a list of tags pre-defined in the spec.
                // There are some unspecified tags in the wild too (e.g. typed array tags).
                // Since tags can be altered, they only serve fast failures
                //
                // Typed arrays and buffers are checked by comparing the content in their
                // underlying ArrayBuffer. This optimization requires that it's
                // reasonable to interpret their underlying memory in the same way,
                // which is checked by comparing their type tags.
                // (e.g. a Uint8Array and a Uint16Array with the same memory content
                // could still be different because they will be interpreted differently).
                //
                // For strict comparison, objects should have
                // a) The same built-in type tags
                // b) The same prototypes.
                function innerDeepEqual(val1, val2, strict, memos) {
                    // All identical values are equivalent, as determined by ===.
                    if (val1 === val2) {
                        if (val1 !== 0) return true;
                        return strict ? objectIs(val1, val2) : true;
                    } // Check more closely if val1 and val2 are equal.
                    if (strict) {
                        if (_typeof(val1) !== 'object') {
                            return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);
                        }
                        if (_typeof(val2) !== 'object' || val1 === null || val2 === null) {
                            return false;
                        }
                        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
                            return false;
                        }
                    } else {
                        if (val1 === null || _typeof(val1) !== 'object') {
                            if (val2 === null || _typeof(val2) !== 'object') {
                                // eslint-disable-next-line eqeqeq
                                return val1 == val2;
                            }
                            return false;
                        }
                        if (val2 === null || _typeof(val2) !== 'object') {
                            return false;
                        }
                    }
                    var val1Tag = objectToString(val1);
                    var val2Tag = objectToString(val2);
                    if (val1Tag !== val2Tag) {
                        return false;
                    }
                    if (Array.isArray(val1)) {
                        // Check for sparse arrays and general fast path
                        if (val1.length !== val2.length) {
                            return false;
                        }
                        var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
                        var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
                        if (keys1.length !== keys2.length) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
                    } // [browserify] This triggers on certain types in IE (Map/Set) so we don't
                    // wan't to early return out of the rest of the checks. However we can check
                    // if the second value is one of these values and the first isn't.
                    if (val1Tag === '[object Object]') {
                        // return keyCheck(val1, val2, strict, memos, kNoIterator);
                        if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
                            return false;
                        }
                    }
                    if (isDate(val1)) {
                        if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
                            return false;
                        }
                    } else if (isRegExp(val1)) {
                        if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
                            return false;
                        }
                    } else if (isNativeError(val1) || val1 instanceof Error) {
                        // Do not compare the stack as it might differ even though the error itself
                        // is otherwise identical.
                        if (val1.message !== val2.message || val1.name !== val2.name) {
                            return false;
                        }
                    } else if (isArrayBufferView(val1)) {
                        if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
                            if (!areSimilarFloatArrays(val1, val2)) {
                                return false;
                            }
                        } else if (!areSimilarTypedArrays(val1, val2)) {
                            return false;
                        } // Buffer.compare returns true, so val1.length === val2.length. If they both
                        // only contain numeric keys, we don't need to exam further than checking
                        // the symbols.
                        var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
                        var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
                        if (_keys.length !== _keys2.length) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
                    } else if (isSet(val1)) {
                        if (!isSet(val2) || val1.size !== val2.size) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kIsSet);
                    } else if (isMap(val1)) {
                        if (!isMap(val2) || val1.size !== val2.size) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kIsMap);
                    } else if (isAnyArrayBuffer(val1)) {
                        if (!areEqualArrayBuffers(val1, val2)) {
                            return false;
                        }
                    } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
                        return false;
                    }
                    return keyCheck(val1, val2, strict, memos, kNoIterator);
                }
                function getEnumerables(val, keys) {
                    return keys.filter(function(k) {
                        return propertyIsEnumerable(val, k);
                    });
                }
                function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
                    // For all remaining Object pairs, including Array, objects and Maps,
                    // equivalence is determined by having:
                    // a) The same number of owned enumerable properties
                    // b) The same set of keys/indexes (although not necessarily the same order)
                    // c) Equivalent values for every corresponding key/index
                    // d) For Sets and Maps, equal contents
                    // Note: this accounts for both named and indexed properties on Arrays.
                    if (arguments.length === 5) {
                        aKeys = Object.keys(val1);
                        var bKeys = Object.keys(val2); // The pair must have the same number of owned properties.
                        if (aKeys.length !== bKeys.length) {
                            return false;
                        }
                    } // Cheap key test
                    var i = 0;
                    for(; i < aKeys.length; i++){
                        if (!hasOwnProperty(val2, aKeys[i])) {
                            return false;
                        }
                    }
                    if (strict && arguments.length === 5) {
                        var symbolKeysA = objectGetOwnPropertySymbols(val1);
                        if (symbolKeysA.length !== 0) {
                            var count = 0;
                            for(i = 0; i < symbolKeysA.length; i++){
                                var key = symbolKeysA[i];
                                if (propertyIsEnumerable(val1, key)) {
                                    if (!propertyIsEnumerable(val2, key)) {
                                        return false;
                                    }
                                    aKeys.push(key);
                                    count++;
                                } else if (propertyIsEnumerable(val2, key)) {
                                    return false;
                                }
                            }
                            var symbolKeysB = objectGetOwnPropertySymbols(val2);
                            if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
                                return false;
                            }
                        } else {
                            var _symbolKeysB = objectGetOwnPropertySymbols(val2);
                            if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
                                return false;
                            }
                        }
                    }
                    if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
                        return true;
                    } // Use memos to handle cycles.
                    if (memos === undefined) {
                        memos = {
                            val1: new Map(),
                            val2: new Map(),
                            position: 0
                        };
                    } else {
                        // We prevent up to two map.has(x) calls by directly retrieving the value
                        // and checking for undefined. The map can only contain numbers, so it is
                        // safe to check for undefined only.
                        var val2MemoA = memos.val1.get(val1);
                        if (val2MemoA !== undefined) {
                            var val2MemoB = memos.val2.get(val2);
                            if (val2MemoB !== undefined) {
                                return val2MemoA === val2MemoB;
                            }
                        }
                        memos.position++;
                    }
                    memos.val1.set(val1, memos.position);
                    memos.val2.set(val2, memos.position);
                    var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
                    memos.val1.delete(val1);
                    memos.val2.delete(val2);
                    return areEq;
                }
                function setHasEqualElement(set, val1, strict, memo) {
                    // Go looking.
                    var setValues = arrayFromSet(set);
                    for(var i = 0; i < setValues.length; i++){
                        var val2 = setValues[i];
                        if (innerDeepEqual(val1, val2, strict, memo)) {
                            // Remove the matching element to make sure we do not check that again.
                            set.delete(val2);
                            return true;
                        }
                    }
                    return false;
                } // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
                // Sadly it is not possible to detect corresponding values properly in case the
                // type is a string, number, bigint or boolean. The reason is that those values
                // can match lots of different string values (e.g., 1n == '+00001').
                function findLooseMatchingPrimitives(prim) {
                    switch(_typeof(prim)){
                        case 'undefined':
                            return null;
                        case 'object':
                            // Only pass in null as object!
                            return undefined;
                        case 'symbol':
                            return false;
                        case 'string':
                            prim = +prim;
                        // Loose equal entries exist only if the string is possible to convert to
                        // a regular number and not NaN.
                        // Fall through
                        case 'number':
                            if (numberIsNaN(prim)) {
                                return false;
                            }
                    }
                    return true;
                }
                function setMightHaveLoosePrim(a, b, prim) {
                    var altValue = findLooseMatchingPrimitives(prim);
                    if (altValue != null) return altValue;
                    return b.has(altValue) && !a.has(altValue);
                }
                function mapMightHaveLoosePrim(a, b, prim, item, memo) {
                    var altValue = findLooseMatchingPrimitives(prim);
                    if (altValue != null) {
                        return altValue;
                    }
                    var curB = b.get(altValue);
                    if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
                        return false;
                    }
                    return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
                }
                function setEquiv(a, b, strict, memo) {
                    // This is a lazily initiated Set of entries which have to be compared
                    // pairwise.
                    var set = null;
                    var aValues = arrayFromSet(a);
                    for(var i = 0; i < aValues.length; i++){
                        var val = aValues[i]; // Note: Checking for the objects first improves the performance for object
                        // heavy sets but it is a minor slow down for primitives. As they are fast
                        // to check this improves the worst case scenario instead.
                        if (_typeof(val) === 'object' && val !== null) {
                            if (set === null) {
                                set = new Set();
                            } // If the specified value doesn't exist in the second set its an not null
                            // object (or non strict only: a not matching primitive) we'll need to go
                            // hunting for something thats deep-(strict-)equal to it. To make this
                            // O(n log n) complexity we have to copy these values in a new set first.
                            set.add(val);
                        } else if (!b.has(val)) {
                            if (strict) return false; // Fast path to detect missing string, symbol, undefined and null values.
                            if (!setMightHaveLoosePrim(a, b, val)) {
                                return false;
                            }
                            if (set === null) {
                                set = new Set();
                            }
                            set.add(val);
                        }
                    }
                    if (set !== null) {
                        var bValues = arrayFromSet(b);
                        for(var _i = 0; _i < bValues.length; _i++){
                            var _val = bValues[_i]; // We have to check if a primitive value is already
                            // matching and only if it's not, go hunting for it.
                            if (_typeof(_val) === 'object' && _val !== null) {
                                if (!setHasEqualElement(set, _val, strict, memo)) return false;
                            } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
                                return false;
                            }
                        }
                        return set.size === 0;
                    }
                    return true;
                }
                function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
                    // To be able to handle cases like:
                    //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
                    // ... we need to consider *all* matching keys, not just the first we find.
                    var setValues = arrayFromSet(set);
                    for(var i = 0; i < setValues.length; i++){
                        var key2 = setValues[i];
                        if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
                            set.delete(key2);
                            return true;
                        }
                    }
                    return false;
                }
                function mapEquiv(a, b, strict, memo) {
                    var set = null;
                    var aEntries = arrayFromMap(a);
                    for(var i = 0; i < aEntries.length; i++){
                        var _aEntries$i = _slicedToArray(aEntries[i], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
                        if (_typeof(key) === 'object' && key !== null) {
                            if (set === null) {
                                set = new Set();
                            }
                            set.add(key);
                        } else {
                            // By directly retrieving the value we prevent another b.has(key) check in
                            // almost all possible cases.
                            var item2 = b.get(key);
                            if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
                                if (strict) return false; // Fast path to detect missing string, symbol, undefined and null
                                // keys.
                                if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;
                                if (set === null) {
                                    set = new Set();
                                }
                                set.add(key);
                            }
                        }
                    }
                    if (set !== null) {
                        var bEntries = arrayFromMap(b);
                        for(var _i2 = 0; _i2 < bEntries.length; _i2++){
                            var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), key = _bEntries$_i[0], item = _bEntries$_i[1];
                            if (_typeof(key) === 'object' && key !== null) {
                                if (!mapHasEqualEntry(set, a, key, item, strict, memo)) return false;
                            } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) {
                                return false;
                            }
                        }
                        return set.size === 0;
                    }
                    return true;
                }
                function objEquiv(a, b, strict, keys, memos, iterationType) {
                    // Sets and maps don't have their entries accessible via normal object
                    // properties.
                    var i = 0;
                    if (iterationType === kIsSet) {
                        if (!setEquiv(a, b, strict, memos)) {
                            return false;
                        }
                    } else if (iterationType === kIsMap) {
                        if (!mapEquiv(a, b, strict, memos)) {
                            return false;
                        }
                    } else if (iterationType === kIsArray) {
                        for(; i < a.length; i++){
                            if (hasOwnProperty(a, i)) {
                                if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
                                    return false;
                                }
                            } else if (hasOwnProperty(b, i)) {
                                return false;
                            } else {
                                // Array is sparse.
                                var keysA = Object.keys(a);
                                for(; i < keysA.length; i++){
                                    var key = keysA[i];
                                    if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
                                        return false;
                                    }
                                }
                                if (keysA.length !== Object.keys(b).length) {
                                    return false;
                                }
                                return true;
                            }
                        }
                    } // The pair must have equivalent values for every corresponding key.
                    // Possibly expensive deep test:
                    for(i = 0; i < keys.length; i++){
                        var _key = keys[i];
                        if (!innerDeepEqual(a[_key], b[_key], strict, memos)) {
                            return false;
                        }
                    }
                    return true;
                }
                function isDeepEqual(val1, val2) {
                    return innerDeepEqual(val1, val2, kLoose);
                }
                function isDeepStrictEqual(val1, val2) {
                    return innerDeepEqual(val1, val2, kStrict);
                }
                module1.exports = {
                    isDeepEqual: isDeepEqual,
                    isDeepStrictEqual: isDeepStrictEqual
                };
            /***/ },
            /***/ 2680: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_108232__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_108232__(7286);
                var callBind = __nested_webpack_require_108232__(9429);
                var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));
                module1.exports = function callBoundIntrinsic(name, allowMissing) {
                    var intrinsic = GetIntrinsic(name, !!allowMissing);
                    if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
                        return callBind(intrinsic);
                    }
                    return intrinsic;
                };
            /***/ },
            /***/ 9429: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_108960__)=>{
                "use strict";
                var bind = __nested_webpack_require_108960__(4090);
                var GetIntrinsic = __nested_webpack_require_108960__(7286);
                var $apply = GetIntrinsic('%Function.prototype.apply%');
                var $call = GetIntrinsic('%Function.prototype.call%');
                var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);
                var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
                var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
                var $max = GetIntrinsic('%Math.max%');
                if ($defineProperty) {
                    try {
                        $defineProperty({}, 'a', {
                            value: 1
                        });
                    } catch (e) {
                        // IE 8 has a broken defineProperty
                        $defineProperty = null;
                    }
                }
                module1.exports = function callBind(originalFunction) {
                    var func = $reflectApply(bind, $call, arguments);
                    if ($gOPD && $defineProperty) {
                        var desc = $gOPD(func, 'length');
                        if (desc.configurable) {
                            // original length, plus the receiver, minus any additional arguments (after the receiver)
                            $defineProperty(func, 'length', {
                                value: 1 + $max(0, originalFunction.length - (arguments.length - 1))
                            });
                        }
                    }
                    return func;
                };
                var applyBind = function applyBind() {
                    return $reflectApply(bind, $apply, arguments);
                };
                if ($defineProperty) {
                    $defineProperty(module1.exports, 'apply', {
                        value: applyBind
                    });
                } else {
                    module1.exports.apply = applyBind;
                }
            /***/ },
            /***/ 3716: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_111174__)=>{
                /*global window, global*/ var util = __nested_webpack_require_111174__(3335);
                var assert = __nested_webpack_require_111174__(1696);
                function now() {
                    return new Date().getTime();
                }
                var slice = Array.prototype.slice;
                var console;
                var times = {};
                if (typeof __nested_webpack_require_111174__.g !== "undefined" && __nested_webpack_require_111174__.g.console) {
                    console = __nested_webpack_require_111174__.g.console;
                } else if (typeof window !== "undefined" && window.console) {
                    console = window.console;
                } else {
                    console = {};
                }
                var functions = [
                    [
                        log,
                        "log"
                    ],
                    [
                        info,
                        "info"
                    ],
                    [
                        warn,
                        "warn"
                    ],
                    [
                        error,
                        "error"
                    ],
                    [
                        time,
                        "time"
                    ],
                    [
                        timeEnd,
                        "timeEnd"
                    ],
                    [
                        trace,
                        "trace"
                    ],
                    [
                        dir,
                        "dir"
                    ],
                    [
                        consoleAssert,
                        "assert"
                    ]
                ];
                for(var i = 0; i < functions.length; i++){
                    var tuple = functions[i];
                    var f = tuple[0];
                    var name = tuple[1];
                    if (!console[name]) {
                        console[name] = f;
                    }
                }
                module1.exports = console;
                function log() {}
                function info() {
                    console.log.apply(console, arguments);
                }
                function warn() {
                    console.log.apply(console, arguments);
                }
                function error() {
                    console.warn.apply(console, arguments);
                }
                function time(label) {
                    times[label] = now();
                }
                function timeEnd(label) {
                    var time = times[label];
                    if (!time) {
                        throw new Error("No such label: " + label);
                    }
                    delete times[label];
                    var duration = now() - time;
                    console.log(label + ": " + duration + "ms");
                }
                function trace() {
                    var err = new Error();
                    err.name = "Trace";
                    err.message = util.format.apply(null, arguments);
                    console.error(err.stack);
                }
                function dir(object) {
                    console.log(util.inspect(object) + "\n");
                }
                function consoleAssert(expression) {
                    if (!expression) {
                        var arr = slice.call(arguments, 1);
                        assert.ok(false, util.format.apply(null, arr));
                    }
                }
            /***/ },
            /***/ 4926: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_114857__)=>{
                "use strict";
                var keys = __nested_webpack_require_114857__(3464);
                var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';
                var toStr = Object.prototype.toString;
                var concat = Array.prototype.concat;
                var origDefineProperty = Object.defineProperty;
                var isFunction = function(fn) {
                    return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
                };
                var hasPropertyDescriptors = __nested_webpack_require_114857__(1181)();
                var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;
                var defineProperty = function(object, name, value, predicate) {
                    if (name in object) {
                        if (predicate === true) {
                            if (object[name] === value) {
                                return;
                            }
                        } else if (!isFunction(predicate) || !predicate()) {
                            return;
                        }
                    }
                    if (supportsDescriptors) {
                        origDefineProperty(object, name, {
                            configurable: true,
                            enumerable: false,
                            value: value,
                            writable: true
                        });
                    } else {
                        object[name] = value; // eslint-disable-line no-param-reassign
                    }
                };
                var defineProperties = function(object, map) {
                    var predicates = arguments.length > 2 ? arguments[2] : {};
                    var props = keys(map);
                    if (hasSymbols) {
                        props = concat.call(props, Object.getOwnPropertySymbols(map));
                    }
                    for(var i = 0; i < props.length; i += 1){
                        defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
                    }
                };
                defineProperties.supportsDescriptors = !!supportsDescriptors;
                module1.exports = defineProperties;
            /***/ },
            /***/ 4956: /***/ (module1)=>{
                "use strict";
                /**
 * Code refactored from Mozilla Developer Network:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 */ function assign(target, firstSource) {
                    if (target === undefined || target === null) {
                        throw new TypeError('Cannot convert first argument to object');
                    }
                    var to = Object(target);
                    for(var i = 1; i < arguments.length; i++){
                        var nextSource = arguments[i];
                        if (nextSource === undefined || nextSource === null) {
                            continue;
                        }
                        var keysArray = Object.keys(Object(nextSource));
                        for(var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++){
                            var nextKey = keysArray[nextIndex];
                            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                            if (desc !== undefined && desc.enumerable) {
                                to[nextKey] = nextSource[nextKey];
                            }
                        }
                    }
                    return to;
                }
                function polyfill() {
                    if (!Object.assign) {
                        Object.defineProperty(Object, 'assign', {
                            enumerable: false,
                            configurable: true,
                            writable: true,
                            value: assign
                        });
                    }
                }
                module1.exports = {
                    assign: assign,
                    polyfill: polyfill
                };
            /***/ },
            /***/ 3243: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_119153__)=>{
                "use strict";
                var isCallable = __nested_webpack_require_119153__(9680);
                var toStr = Object.prototype.toString;
                var hasOwnProperty = Object.prototype.hasOwnProperty;
                var forEachArray = function forEachArray(array, iterator, receiver) {
                    for(var i = 0, len = array.length; i < len; i++){
                        if (hasOwnProperty.call(array, i)) {
                            if (receiver == null) {
                                iterator(array[i], i, array);
                            } else {
                                iterator.call(receiver, array[i], i, array);
                            }
                        }
                    }
                };
                var forEachString = function forEachString(string, iterator, receiver) {
                    for(var i = 0, len = string.length; i < len; i++){
                        // no such thing as a sparse string.
                        if (receiver == null) {
                            iterator(string.charAt(i), i, string);
                        } else {
                            iterator.call(receiver, string.charAt(i), i, string);
                        }
                    }
                };
                var forEachObject = function forEachObject(object, iterator, receiver) {
                    for(var k in object){
                        if (hasOwnProperty.call(object, k)) {
                            if (receiver == null) {
                                iterator(object[k], k, object);
                            } else {
                                iterator.call(receiver, object[k], k, object);
                            }
                        }
                    }
                };
                var forEach = function forEach(list, iterator, thisArg) {
                    if (!isCallable(iterator)) {
                        throw new TypeError('iterator must be a function');
                    }
                    var receiver;
                    if (arguments.length >= 3) {
                        receiver = thisArg;
                    }
                    if (toStr.call(list) === '[object Array]') {
                        forEachArray(list, iterator, receiver);
                    } else if (typeof list === 'string') {
                        forEachString(list, iterator, receiver);
                    } else {
                        forEachObject(list, iterator, receiver);
                    }
                };
                module1.exports = forEach;
            /***/ },
            /***/ 7795: /***/ (module1)=>{
                "use strict";
                /* eslint no-invalid-this: 1 */ var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
                var slice = Array.prototype.slice;
                var toStr = Object.prototype.toString;
                var funcType = '[object Function]';
                module1.exports = function bind(that) {
                    var target = this;
                    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
                        throw new TypeError(ERROR_MESSAGE + target);
                    }
                    var args = slice.call(arguments, 1);
                    var bound;
                    var binder = function() {
                        if (this instanceof bound) {
                            var result = target.apply(this, args.concat(slice.call(arguments)));
                            if (Object(result) === result) {
                                return result;
                            }
                            return this;
                        } else {
                            return target.apply(that, args.concat(slice.call(arguments)));
                        }
                    };
                    var boundLength = Math.max(0, target.length - args.length);
                    var boundArgs = [];
                    for(var i = 0; i < boundLength; i++){
                        boundArgs.push('$' + i);
                    }
                    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);
                    if (target.prototype) {
                        var Empty = function Empty() {};
                        Empty.prototype = target.prototype;
                        bound.prototype = new Empty();
                        Empty.prototype = null;
                    }
                    return bound;
                };
            /***/ },
            /***/ 4090: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_123879__)=>{
                "use strict";
                var implementation = __nested_webpack_require_123879__(7795);
                module1.exports = Function.prototype.bind || implementation;
            /***/ },
            /***/ 7286: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_124161__)=>{
                "use strict";
                var undefined1;
                var $SyntaxError = SyntaxError;
                var $Function = Function;
                var $TypeError = TypeError;
                // eslint-disable-next-line consistent-return
                var getEvalledConstructor = function(expressionSyntax) {
                    try {
                        return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
                    } catch (e) {}
                };
                var $gOPD = Object.getOwnPropertyDescriptor;
                if ($gOPD) {
                    try {
                        $gOPD({}, '');
                    } catch (e) {
                        $gOPD = null; // this is IE 8, which has a broken gOPD
                    }
                }
                var throwTypeError = function() {
                    throw new $TypeError();
                };
                var ThrowTypeError = $gOPD ? function() {
                    try {
                        // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
                        arguments.callee; // IE 8 does not throw here
                        return throwTypeError;
                    } catch (calleeThrows) {
                        try {
                            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
                            return $gOPD(arguments, 'callee').get;
                        } catch (gOPDthrows) {
                            return throwTypeError;
                        }
                    }
                }() : throwTypeError;
                var hasSymbols = __nested_webpack_require_124161__(2636)();
                var hasProto = __nested_webpack_require_124161__(8486)();
                var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
                    return x.__proto__;
                } // eslint-disable-line no-proto
                 : null);
                var needsEval = {};
                var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined1 : getProto(Uint8Array);
                var INTRINSICS = {
                    '%AggregateError%': typeof AggregateError === 'undefined' ? undefined1 : AggregateError,
                    '%Array%': Array,
                    '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined1 : ArrayBuffer,
                    '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined1,
                    '%AsyncFromSyncIteratorPrototype%': undefined1,
                    '%AsyncFunction%': needsEval,
                    '%AsyncGenerator%': needsEval,
                    '%AsyncGeneratorFunction%': needsEval,
                    '%AsyncIteratorPrototype%': needsEval,
                    '%Atomics%': typeof Atomics === 'undefined' ? undefined1 : Atomics,
                    '%BigInt%': typeof BigInt === 'undefined' ? undefined1 : BigInt,
                    '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined1 : BigInt64Array,
                    '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined1 : BigUint64Array,
                    '%Boolean%': Boolean,
                    '%DataView%': typeof DataView === 'undefined' ? undefined1 : DataView,
                    '%Date%': Date,
                    '%decodeURI%': decodeURI,
                    '%decodeURIComponent%': decodeURIComponent,
                    '%encodeURI%': encodeURI,
                    '%encodeURIComponent%': encodeURIComponent,
                    '%Error%': Error,
                    '%eval%': eval,
                    '%EvalError%': EvalError,
                    '%Float32Array%': typeof Float32Array === 'undefined' ? undefined1 : Float32Array,
                    '%Float64Array%': typeof Float64Array === 'undefined' ? undefined1 : Float64Array,
                    '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined1 : FinalizationRegistry,
                    '%Function%': $Function,
                    '%GeneratorFunction%': needsEval,
                    '%Int8Array%': typeof Int8Array === 'undefined' ? undefined1 : Int8Array,
                    '%Int16Array%': typeof Int16Array === 'undefined' ? undefined1 : Int16Array,
                    '%Int32Array%': typeof Int32Array === 'undefined' ? undefined1 : Int32Array,
                    '%isFinite%': isFinite,
                    '%isNaN%': isNaN,
                    '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined1,
                    '%JSON%': typeof JSON === 'object' ? JSON : undefined1,
                    '%Map%': typeof Map === 'undefined' ? undefined1 : Map,
                    '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined1 : getProto(new Map()[Symbol.iterator]()),
                    '%Math%': Math,
                    '%Number%': Number,
                    '%Object%': Object,
                    '%parseFloat%': parseFloat,
                    '%parseInt%': parseInt,
                    '%Promise%': typeof Promise === 'undefined' ? undefined1 : Promise,
                    '%Proxy%': typeof Proxy === 'undefined' ? undefined1 : Proxy,
                    '%RangeError%': RangeError,
                    '%ReferenceError%': ReferenceError,
                    '%Reflect%': typeof Reflect === 'undefined' ? undefined1 : Reflect,
                    '%RegExp%': RegExp,
                    '%Set%': typeof Set === 'undefined' ? undefined1 : Set,
                    '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined1 : getProto(new Set()[Symbol.iterator]()),
                    '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined1 : SharedArrayBuffer,
                    '%String%': String,
                    '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined1,
                    '%Symbol%': hasSymbols ? Symbol : undefined1,
                    '%SyntaxError%': $SyntaxError,
                    '%ThrowTypeError%': ThrowTypeError,
                    '%TypedArray%': TypedArray,
                    '%TypeError%': $TypeError,
                    '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined1 : Uint8Array,
                    '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined1 : Uint8ClampedArray,
                    '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined1 : Uint16Array,
                    '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined1 : Uint32Array,
                    '%URIError%': URIError,
                    '%WeakMap%': typeof WeakMap === 'undefined' ? undefined1 : WeakMap,
                    '%WeakRef%': typeof WeakRef === 'undefined' ? undefined1 : WeakRef,
                    '%WeakSet%': typeof WeakSet === 'undefined' ? undefined1 : WeakSet
                };
                if (getProto) {
                    try {
                        null.error; // eslint-disable-line no-unused-expressions
                    } catch (e) {
                        // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
                        var errorProto = getProto(getProto(e));
                        INTRINSICS['%Error.prototype%'] = errorProto;
                    }
                }
                var doEval = function doEval(name) {
                    var value;
                    if (name === '%AsyncFunction%') {
                        value = getEvalledConstructor('async function () {}');
                    } else if (name === '%GeneratorFunction%') {
                        value = getEvalledConstructor('function* () {}');
                    } else if (name === '%AsyncGeneratorFunction%') {
                        value = getEvalledConstructor('async function* () {}');
                    } else if (name === '%AsyncGenerator%') {
                        var fn = doEval('%AsyncGeneratorFunction%');
                        if (fn) {
                            value = fn.prototype;
                        }
                    } else if (name === '%AsyncIteratorPrototype%') {
                        var gen = doEval('%AsyncGenerator%');
                        if (gen && getProto) {
                            value = getProto(gen.prototype);
                        }
                    }
                    INTRINSICS[name] = value;
                    return value;
                };
                var LEGACY_ALIASES = {
                    '%ArrayBufferPrototype%': [
                        'ArrayBuffer',
                        'prototype'
                    ],
                    '%ArrayPrototype%': [
                        'Array',
                        'prototype'
                    ],
                    '%ArrayProto_entries%': [
                        'Array',
                        'prototype',
                        'entries'
                    ],
                    '%ArrayProto_forEach%': [
                        'Array',
                        'prototype',
                        'forEach'
                    ],
                    '%ArrayProto_keys%': [
                        'Array',
                        'prototype',
                        'keys'
                    ],
                    '%ArrayProto_values%': [
                        'Array',
                        'prototype',
                        'values'
                    ],
                    '%AsyncFunctionPrototype%': [
                        'AsyncFunction',
                        'prototype'
                    ],
                    '%AsyncGenerator%': [
                        'AsyncGeneratorFunction',
                        'prototype'
                    ],
                    '%AsyncGeneratorPrototype%': [
                        'AsyncGeneratorFunction',
                        'prototype',
                        'prototype'
                    ],
                    '%BooleanPrototype%': [
                        'Boolean',
                        'prototype'
                    ],
                    '%DataViewPrototype%': [
                        'DataView',
                        'prototype'
                    ],
                    '%DatePrototype%': [
                        'Date',
                        'prototype'
                    ],
                    '%ErrorPrototype%': [
                        'Error',
                        'prototype'
                    ],
                    '%EvalErrorPrototype%': [
                        'EvalError',
                        'prototype'
                    ],
                    '%Float32ArrayPrototype%': [
                        'Float32Array',
                        'prototype'
                    ],
                    '%Float64ArrayPrototype%': [
                        'Float64Array',
                        'prototype'
                    ],
                    '%FunctionPrototype%': [
                        'Function',
                        'prototype'
                    ],
                    '%Generator%': [
                        'GeneratorFunction',
                        'prototype'
                    ],
                    '%GeneratorPrototype%': [
                        'GeneratorFunction',
                        'prototype',
                        'prototype'
                    ],
                    '%Int8ArrayPrototype%': [
                        'Int8Array',
                        'prototype'
                    ],
                    '%Int16ArrayPrototype%': [
                        'Int16Array',
                        'prototype'
                    ],
                    '%Int32ArrayPrototype%': [
                        'Int32Array',
                        'prototype'
                    ],
                    '%JSONParse%': [
                        'JSON',
                        'parse'
                    ],
                    '%JSONStringify%': [
                        'JSON',
                        'stringify'
                    ],
                    '%MapPrototype%': [
                        'Map',
                        'prototype'
                    ],
                    '%NumberPrototype%': [
                        'Number',
                        'prototype'
                    ],
                    '%ObjectPrototype%': [
                        'Object',
                        'prototype'
                    ],
                    '%ObjProto_toString%': [
                        'Object',
                        'prototype',
                        'toString'
                    ],
                    '%ObjProto_valueOf%': [
                        'Object',
                        'prototype',
                        'valueOf'
                    ],
                    '%PromisePrototype%': [
                        'Promise',
                        'prototype'
                    ],
                    '%PromiseProto_then%': [
                        'Promise',
                        'prototype',
                        'then'
                    ],
                    '%Promise_all%': [
                        'Promise',
                        'all'
                    ],
                    '%Promise_reject%': [
                        'Promise',
                        'reject'
                    ],
                    '%Promise_resolve%': [
                        'Promise',
                        'resolve'
                    ],
                    '%RangeErrorPrototype%': [
                        'RangeError',
                        'prototype'
                    ],
                    '%ReferenceErrorPrototype%': [
                        'ReferenceError',
                        'prototype'
                    ],
                    '%RegExpPrototype%': [
                        'RegExp',
                        'prototype'
                    ],
                    '%SetPrototype%': [
                        'Set',
                        'prototype'
                    ],
                    '%SharedArrayBufferPrototype%': [
                        'SharedArrayBuffer',
                        'prototype'
                    ],
                    '%StringPrototype%': [
                        'String',
                        'prototype'
                    ],
                    '%SymbolPrototype%': [
                        'Symbol',
                        'prototype'
                    ],
                    '%SyntaxErrorPrototype%': [
                        'SyntaxError',
                        'prototype'
                    ],
                    '%TypedArrayPrototype%': [
                        'TypedArray',
                        'prototype'
                    ],
                    '%TypeErrorPrototype%': [
                        'TypeError',
                        'prototype'
                    ],
                    '%Uint8ArrayPrototype%': [
                        'Uint8Array',
                        'prototype'
                    ],
                    '%Uint8ClampedArrayPrototype%': [
                        'Uint8ClampedArray',
                        'prototype'
                    ],
                    '%Uint16ArrayPrototype%': [
                        'Uint16Array',
                        'prototype'
                    ],
                    '%Uint32ArrayPrototype%': [
                        'Uint32Array',
                        'prototype'
                    ],
                    '%URIErrorPrototype%': [
                        'URIError',
                        'prototype'
                    ],
                    '%WeakMapPrototype%': [
                        'WeakMap',
                        'prototype'
                    ],
                    '%WeakSetPrototype%': [
                        'WeakSet',
                        'prototype'
                    ]
                };
                var bind = __nested_webpack_require_124161__(4090);
                var hasOwn = __nested_webpack_require_124161__(3198);
                var $concat = bind.call(Function.call, Array.prototype.concat);
                var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
                var $replace = bind.call(Function.call, String.prototype.replace);
                var $strSlice = bind.call(Function.call, String.prototype.slice);
                var $exec = bind.call(Function.call, RegExp.prototype.exec);
                /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */ var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
                var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */ 
                var stringToPath = function stringToPath(string) {
                    var first = $strSlice(string, 0, 1);
                    var last = $strSlice(string, -1);
                    if (first === '%' && last !== '%') {
                        throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
                    } else if (last === '%' && first !== '%') {
                        throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
                    }
                    var result = [];
                    $replace(string, rePropName, function(match, number, quote, subString) {
                        result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
                    });
                    return result;
                };
                /* end adaptation */ var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
                    var intrinsicName = name;
                    var alias;
                    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
                        alias = LEGACY_ALIASES[intrinsicName];
                        intrinsicName = '%' + alias[0] + '%';
                    }
                    if (hasOwn(INTRINSICS, intrinsicName)) {
                        var value = INTRINSICS[intrinsicName];
                        if (value === needsEval) {
                            value = doEval(intrinsicName);
                        }
                        if (typeof value === 'undefined' && !allowMissing) {
                            throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
                        }
                        return {
                            alias: alias,
                            name: intrinsicName,
                            value: value
                        };
                    }
                    throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
                };
                module1.exports = function GetIntrinsic(name, allowMissing) {
                    if (typeof name !== 'string' || name.length === 0) {
                        throw new $TypeError('intrinsic name must be a non-empty string');
                    }
                    if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
                        throw new $TypeError('"allowMissing" argument must be a boolean');
                    }
                    if ($exec(/^%?[^%]*%?$/, name) === null) {
                        throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
                    }
                    var parts = stringToPath(name);
                    var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
                    var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
                    var intrinsicRealName = intrinsic.name;
                    var value = intrinsic.value;
                    var skipFurtherCaching = false;
                    var alias = intrinsic.alias;
                    if (alias) {
                        intrinsicBaseName = alias[0];
                        $spliceApply(parts, $concat([
                            0,
                            1
                        ], alias));
                    }
                    for(var i = 1, isOwn = true; i < parts.length; i += 1){
                        var part = parts[i];
                        var first = $strSlice(part, 0, 1);
                        var last = $strSlice(part, -1);
                        if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
                            throw new $SyntaxError('property names with quotes must have matching quotes');
                        }
                        if (part === 'constructor' || !isOwn) {
                            skipFurtherCaching = true;
                        }
                        intrinsicBaseName += '.' + part;
                        intrinsicRealName = '%' + intrinsicBaseName + '%';
                        if (hasOwn(INTRINSICS, intrinsicRealName)) {
                            value = INTRINSICS[intrinsicRealName];
                        } else if (value != null) {
                            if (!(part in value)) {
                                if (!allowMissing) {
                                    throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
                                }
                                return void undefined1;
                            }
                            if ($gOPD && i + 1 >= parts.length) {
                                var desc = $gOPD(value, part);
                                isOwn = !!desc;
                                // By convention, when a data property is converted to an accessor
                                // property to emulate a data property that does not suffer from
                                // the override mistake, that accessor's getter is marked with
                                // an `originalValue` property. Here, when we detect this, we
                                // uphold the illusion by pretending to see that original data
                                // property, i.e., returning the value rather than the getter
                                // itself.
                                if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
                                    value = desc.get;
                                } else {
                                    value = value[part];
                                }
                            } else {
                                isOwn = hasOwn(value, part);
                                value = value[part];
                            }
                            if (isOwn && !skipFurtherCaching) {
                                INTRINSICS[intrinsicRealName] = value;
                            }
                        }
                    }
                    return value;
                };
            /***/ },
            /***/ 326: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_147628__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_147628__(7286);
                var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
                if ($gOPD) {
                    try {
                        $gOPD([], 'length');
                    } catch (e) {
                        // IE 8 has a broken gOPD
                        $gOPD = null;
                    }
                }
                module1.exports = $gOPD;
            /***/ },
            /***/ 1181: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_148219__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_148219__(7286);
                var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
                var hasPropertyDescriptors = function hasPropertyDescriptors() {
                    if ($defineProperty) {
                        try {
                            $defineProperty({}, 'a', {
                                value: 1
                            });
                            return true;
                        } catch (e) {
                            // IE 8 has a broken defineProperty
                            return false;
                        }
                    }
                    return false;
                };
                hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
                    // node v0.6 has a bug where array lengths can be Set but not Defined
                    if (!hasPropertyDescriptors()) {
                        return null;
                    }
                    try {
                        return $defineProperty([], 'length', {
                            value: 1
                        }).length !== 1;
                    } catch (e) {
                        // In Firefox 4-22, defining length on an array throws an exception.
                        return true;
                    }
                };
                module1.exports = hasPropertyDescriptors;
            /***/ },
            /***/ 8486: /***/ (module1)=>{
                "use strict";
                var test = {
                    foo: {}
                };
                var $Object = Object;
                module1.exports = function hasProto() {
                    return ({
                        __proto__: test
                    }).foo === test.foo && !(({
                        __proto__: null
                    }) instanceof $Object);
                };
            /***/ },
            /***/ 2636: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_150294__)=>{
                "use strict";
                var origSymbol = typeof Symbol !== 'undefined' && Symbol;
                var hasSymbolSham = __nested_webpack_require_150294__(6679);
                module1.exports = function hasNativeSymbols() {
                    if (typeof origSymbol !== 'function') {
                        return false;
                    }
                    if (typeof Symbol !== 'function') {
                        return false;
                    }
                    if (typeof origSymbol('foo') !== 'symbol') {
                        return false;
                    }
                    if (typeof Symbol('bar') !== 'symbol') {
                        return false;
                    }
                    return hasSymbolSham();
                };
            /***/ },
            /***/ 6679: /***/ (module1)=>{
                "use strict";
                /* eslint complexity: [2, 18], max-statements: [2, 33] */ module1.exports = function hasSymbols() {
                    if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
                        return false;
                    }
                    if (typeof Symbol.iterator === 'symbol') {
                        return true;
                    }
                    var obj = {};
                    var sym = Symbol('test');
                    var symObj = Object(sym);
                    if (typeof sym === 'string') {
                        return false;
                    }
                    if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
                        return false;
                    }
                    if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
                        return false;
                    }
                    // temp disabled per https://github.com/ljharb/object.assign/issues/17
                    // if (sym instanceof Symbol) { return false; }
                    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
                    // if (!(symObj instanceof Symbol)) { return false; }
                    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
                    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
                    var symVal = 42;
                    obj[sym] = symVal;
                    for(sym in obj){
                        return false;
                    } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
                    if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
                        return false;
                    }
                    if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
                        return false;
                    }
                    var syms = Object.getOwnPropertySymbols(obj);
                    if (syms.length !== 1 || syms[0] !== sym) {
                        return false;
                    }
                    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
                        return false;
                    }
                    if (typeof Object.getOwnPropertyDescriptor === 'function') {
                        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
                        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
                            return false;
                        }
                    }
                    return true;
                };
            /***/ },
            /***/ 7226: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_154053__)=>{
                "use strict";
                var hasSymbols = __nested_webpack_require_154053__(6679);
                module1.exports = function hasToStringTagShams() {
                    return hasSymbols() && !!Symbol.toStringTag;
                };
            /***/ },
            /***/ 3198: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_154405__)=>{
                "use strict";
                var bind = __nested_webpack_require_154405__(4090);
                module1.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
            /***/ },
            /***/ 1285: /***/ (module1)=>{
                if (typeof Object.create === 'function') {
                    // implementation from standard node.js 'util' module
                    module1.exports = function inherits(ctor, superCtor) {
                        if (superCtor) {
                            ctor.super_ = superCtor;
                            ctor.prototype = Object.create(superCtor.prototype, {
                                constructor: {
                                    value: ctor,
                                    enumerable: false,
                                    writable: true,
                                    configurable: true
                                }
                            });
                        }
                    };
                } else {
                    // old school shim for old browsers
                    module1.exports = function inherits(ctor, superCtor) {
                        if (superCtor) {
                            ctor.super_ = superCtor;
                            var TempCtor = function() {};
                            TempCtor.prototype = superCtor.prototype;
                            ctor.prototype = new TempCtor();
                            ctor.prototype.constructor = ctor;
                        }
                    };
                }
            /***/ },
            /***/ 2635: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_156083__)=>{
                "use strict";
                var hasToStringTag = __nested_webpack_require_156083__(7226)();
                var callBound = __nested_webpack_require_156083__(2680);
                var $toString = callBound('Object.prototype.toString');
                var isStandardArguments = function isArguments(value) {
                    if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
                        return false;
                    }
                    return $toString(value) === '[object Arguments]';
                };
                var isLegacyArguments = function isArguments(value) {
                    if (isStandardArguments(value)) {
                        return true;
                    }
                    return value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && $toString(value) !== '[object Array]' && $toString(value.callee) === '[object Function]';
                };
                var supportsStandardArguments = function() {
                    return isStandardArguments(arguments);
                }();
                isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests
                module1.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
            /***/ },
            /***/ 9680: /***/ (module1)=>{
                "use strict";
                var fnToStr = Function.prototype.toString;
                var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
                var badArrayLike;
                var isCallableMarker;
                if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
                    try {
                        badArrayLike = Object.defineProperty({}, 'length', {
                            get: function() {
                                throw isCallableMarker;
                            }
                        });
                        isCallableMarker = {};
                        // eslint-disable-next-line no-throw-literal
                        reflectApply(function() {
                            throw 42;
                        }, null, badArrayLike);
                    } catch (_) {
                        if (_ !== isCallableMarker) {
                            reflectApply = null;
                        }
                    }
                } else {
                    reflectApply = null;
                }
                var constructorRegex = /^\s*class\b/;
                var isES6ClassFn = function isES6ClassFunction(value) {
                    try {
                        var fnStr = fnToStr.call(value);
                        return constructorRegex.test(fnStr);
                    } catch (e) {
                        return false; // not a function
                    }
                };
                var tryFunctionObject = function tryFunctionToStr(value) {
                    try {
                        if (isES6ClassFn(value)) {
                            return false;
                        }
                        fnToStr.call(value);
                        return true;
                    } catch (e) {
                        return false;
                    }
                };
                var toStr = Object.prototype.toString;
                var objectClass = '[object Object]';
                var fnClass = '[object Function]';
                var genClass = '[object GeneratorFunction]';
                var ddaClass = '[object HTMLAllCollection]'; // IE 11
                var ddaClass2 = '[object HTML document.all class]';
                var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
                var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`
                var isIE68 = !(0 in [
                    , 
                ]); // eslint-disable-line no-sparse-arrays, comma-spacing
                var isDDA = function isDocumentDotAll() {
                    return false;
                };
                if (typeof document === 'object') {
                    // Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
                    var all = document.all;
                    if (toStr.call(all) === toStr.call(document.all)) {
                        isDDA = function isDocumentDotAll(value) {
                            /* globals document: false */ // in IE 6-8, typeof document.all is "object" and it's truthy
                            if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
                                try {
                                    var str = toStr.call(value);
                                    return (str === ddaClass || str === ddaClass2 || str === ddaClass3 // opera 12.16
                                     || str === objectClass // IE 6-8
                                    ) && value('') == null; // eslint-disable-line eqeqeq
                                } catch (e) {}
                            }
                            return false;
                        };
                    }
                }
                module1.exports = reflectApply ? function isCallable(value) {
                    if (isDDA(value)) {
                        return true;
                    }
                    if (!value) {
                        return false;
                    }
                    if (typeof value !== 'function' && typeof value !== 'object') {
                        return false;
                    }
                    try {
                        reflectApply(value, null, badArrayLike);
                    } catch (e) {
                        if (e !== isCallableMarker) {
                            return false;
                        }
                    }
                    return !isES6ClassFn(value) && tryFunctionObject(value);
                } : function isCallable(value) {
                    if (isDDA(value)) {
                        return true;
                    }
                    if (!value) {
                        return false;
                    }
                    if (typeof value !== 'function' && typeof value !== 'object') {
                        return false;
                    }
                    if (hasToStringTag) {
                        return tryFunctionObject(value);
                    }
                    if (isES6ClassFn(value)) {
                        return false;
                    }
                    var strClass = toStr.call(value);
                    if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
                        return false;
                    }
                    return tryFunctionObject(value);
                };
            /***/ },
            /***/ 3138: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_163143__)=>{
                "use strict";
                var toStr = Object.prototype.toString;
                var fnToStr = Function.prototype.toString;
                var isFnRegex = /^\s*(?:function)?\*/;
                var hasToStringTag = __nested_webpack_require_163143__(7226)();
                var getProto = Object.getPrototypeOf;
                var getGeneratorFunc = function() {
                    if (!hasToStringTag) {
                        return false;
                    }
                    try {
                        return Function('return function*() {}')();
                    } catch (e) {}
                };
                var GeneratorFunction;
                module1.exports = function isGeneratorFunction(fn) {
                    if (typeof fn !== 'function') {
                        return false;
                    }
                    if (isFnRegex.test(fnToStr.call(fn))) {
                        return true;
                    }
                    if (!hasToStringTag) {
                        var str = toStr.call(fn);
                        return str === '[object GeneratorFunction]';
                    }
                    if (!getProto) {
                        return false;
                    }
                    if (typeof GeneratorFunction === 'undefined') {
                        var generatorFunc = getGeneratorFunc();
                        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
                    }
                    return getProto(fn) === GeneratorFunction;
                };
            /***/ },
            /***/ 7053: /***/ (module1)=>{
                "use strict";
                /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ module1.exports = function isNaN1(value) {
                    return value !== value;
                };
            /***/ },
            /***/ 4782: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_165112__)=>{
                "use strict";
                var callBind = __nested_webpack_require_165112__(9429);
                var define1 = __nested_webpack_require_165112__(4926);
                var implementation = __nested_webpack_require_165112__(7053);
                var getPolyfill = __nested_webpack_require_165112__(755);
                var shim = __nested_webpack_require_165112__(5346);
                var polyfill = callBind(getPolyfill(), Number);
                /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ define1(polyfill, {
                    getPolyfill: getPolyfill,
                    implementation: implementation,
                    shim: shim
                });
                module1.exports = polyfill;
            /***/ },
            /***/ 755: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_165909__)=>{
                "use strict";
                var implementation = __nested_webpack_require_165909__(7053);
                module1.exports = function getPolyfill() {
                    if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {
                        return Number.isNaN;
                    }
                    return implementation;
                };
            /***/ },
            /***/ 5346: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_166385__)=>{
                "use strict";
                var define1 = __nested_webpack_require_166385__(4926);
                var getPolyfill = __nested_webpack_require_166385__(755);
                /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ module1.exports = function shimNumberIsNaN() {
                    var polyfill = getPolyfill();
                    define1(Number, {
                        isNaN: polyfill
                    }, {
                        isNaN: function testIsNaN() {
                            return Number.isNaN !== polyfill;
                        }
                    });
                    return polyfill;
                };
            /***/ },
            /***/ 198: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_167151__)=>{
                "use strict";
                var whichTypedArray = __nested_webpack_require_167151__(2094);
                module1.exports = function isTypedArray(value) {
                    return !!whichTypedArray(value);
                };
            /***/ },
            /***/ 8169: /***/ (module1)=>{
                "use strict";
                var numberIsNaN = function(value) {
                    return value !== value;
                };
                module1.exports = function is(a, b) {
                    if (a === 0 && b === 0) {
                        return 1 / a === 1 / b;
                    }
                    if (a === b) {
                        return true;
                    }
                    if (numberIsNaN(a) && numberIsNaN(b)) {
                        return true;
                    }
                    return false;
                };
            /***/ },
            /***/ 4679: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_168139__)=>{
                "use strict";
                var define1 = __nested_webpack_require_168139__(4926);
                var callBind = __nested_webpack_require_168139__(9429);
                var implementation = __nested_webpack_require_168139__(8169);
                var getPolyfill = __nested_webpack_require_168139__(8070);
                var shim = __nested_webpack_require_168139__(191);
                var polyfill = callBind(getPolyfill(), Object);
                define1(polyfill, {
                    getPolyfill: getPolyfill,
                    implementation: implementation,
                    shim: shim
                });
                module1.exports = polyfill;
            /***/ },
            /***/ 8070: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_168866__)=>{
                "use strict";
                var implementation = __nested_webpack_require_168866__(8169);
                module1.exports = function getPolyfill() {
                    return typeof Object.is === 'function' ? Object.is : implementation;
                };
            /***/ },
            /***/ 191: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_169237__)=>{
                "use strict";
                var getPolyfill = __nested_webpack_require_169237__(8070);
                var define1 = __nested_webpack_require_169237__(4926);
                module1.exports = function shimObjectIs() {
                    var polyfill = getPolyfill();
                    define1(Object, {
                        is: polyfill
                    }, {
                        is: function testObjectIs() {
                            return Object.is !== polyfill;
                        }
                    });
                    return polyfill;
                };
            /***/ },
            /***/ 5691: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_169925__)=>{
                "use strict";
                var keysShim;
                if (!Object.keys) {
                    // modified from https://github.com/es-shims/es5-shim
                    var has = Object.prototype.hasOwnProperty;
                    var toStr = Object.prototype.toString;
                    var isArgs = __nested_webpack_require_169925__(801); // eslint-disable-line global-require
                    var isEnumerable = Object.prototype.propertyIsEnumerable;
                    var hasDontEnumBug = !isEnumerable.call({
                        toString: null
                    }, 'toString');
                    var hasProtoEnumBug = isEnumerable.call(function() {}, 'prototype');
                    var dontEnums = [
                        'toString',
                        'toLocaleString',
                        'valueOf',
                        'hasOwnProperty',
                        'isPrototypeOf',
                        'propertyIsEnumerable',
                        'constructor'
                    ];
                    var equalsConstructorPrototype = function(o) {
                        var ctor = o.constructor;
                        return ctor && ctor.prototype === o;
                    };
                    var excludedKeys = {
                        $applicationCache: true,
                        $console: true,
                        $external: true,
                        $frame: true,
                        $frameElement: true,
                        $frames: true,
                        $innerHeight: true,
                        $innerWidth: true,
                        $onmozfullscreenchange: true,
                        $onmozfullscreenerror: true,
                        $outerHeight: true,
                        $outerWidth: true,
                        $pageXOffset: true,
                        $pageYOffset: true,
                        $parent: true,
                        $scrollLeft: true,
                        $scrollTop: true,
                        $scrollX: true,
                        $scrollY: true,
                        $self: true,
                        $webkitIndexedDB: true,
                        $webkitStorageInfo: true,
                        $window: true
                    };
                    var hasAutomationEqualityBug = function() {
                        /* global window */ if (typeof window === 'undefined') {
                            return false;
                        }
                        for(var k in window){
                            try {
                                if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
                                    try {
                                        equalsConstructorPrototype(window[k]);
                                    } catch (e) {
                                        return true;
                                    }
                                }
                            } catch (e) {
                                return true;
                            }
                        }
                        return false;
                    }();
                    var equalsConstructorPrototypeIfNotBuggy = function(o) {
                        /* global window */ if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
                            return equalsConstructorPrototype(o);
                        }
                        try {
                            return equalsConstructorPrototype(o);
                        } catch (e) {
                            return false;
                        }
                    };
                    keysShim = function keys(object) {
                        var isObject = object !== null && typeof object === 'object';
                        var isFunction = toStr.call(object) === '[object Function]';
                        var isArguments = isArgs(object);
                        var isString = isObject && toStr.call(object) === '[object String]';
                        var theKeys = [];
                        if (!isObject && !isFunction && !isArguments) {
                            throw new TypeError('Object.keys called on a non-object');
                        }
                        var skipProto = hasProtoEnumBug && isFunction;
                        if (isString && object.length > 0 && !has.call(object, 0)) {
                            for(var i = 0; i < object.length; ++i){
                                theKeys.push(String(i));
                            }
                        }
                        if (isArguments && object.length > 0) {
                            for(var j = 0; j < object.length; ++j){
                                theKeys.push(String(j));
                            }
                        } else {
                            for(var name in object){
                                if (!(skipProto && name === 'prototype') && has.call(object, name)) {
                                    theKeys.push(String(name));
                                }
                            }
                        }
                        if (hasDontEnumBug) {
                            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
                            for(var k = 0; k < dontEnums.length; ++k){
                                if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
                                    theKeys.push(dontEnums[k]);
                                }
                            }
                        }
                        return theKeys;
                    };
                }
                module1.exports = keysShim;
            /***/ },
            /***/ 3464: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_175894__)=>{
                "use strict";
                var slice = Array.prototype.slice;
                var isArgs = __nested_webpack_require_175894__(801);
                var origKeys = Object.keys;
                var keysShim = origKeys ? function keys(o) {
                    return origKeys(o);
                } : __nested_webpack_require_175894__(5691);
                var originalKeys = Object.keys;
                keysShim.shim = function shimObjectKeys() {
                    if (Object.keys) {
                        var keysWorksWithArguments = function() {
                            // Safari 5.0 bug
                            var args = Object.keys(arguments);
                            return args && args.length === arguments.length;
                        }(1, 2);
                        if (!keysWorksWithArguments) {
                            Object.keys = function keys(object) {
                                if (isArgs(object)) {
                                    return originalKeys(slice.call(object));
                                }
                                return originalKeys(object);
                            };
                        }
                    } else {
                        Object.keys = keysShim;
                    }
                    return Object.keys || keysShim;
                };
                module1.exports = keysShim;
            /***/ },
            /***/ 801: /***/ (module1)=>{
                "use strict";
                var toStr = Object.prototype.toString;
                module1.exports = function isArguments(value) {
                    var str = toStr.call(value);
                    var isArgs = str === '[object Arguments]';
                    if (!isArgs) {
                        isArgs = str !== '[object Array]' && value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
                    }
                    return isArgs;
                };
            /***/ },
            /***/ 4406: /***/ (module1)=>{
                // shim for using process in browser
                var process = module1.exports = {};
                // cached from whatever global is present so that test runners that stub it
                // don't break things.  But we need to wrap it in a try catch in case it is
                // wrapped in strict mode code which doesn't define any globals.  It's inside a
                // function because try/catches deoptimize in certain engines.
                var cachedSetTimeout;
                var cachedClearTimeout;
                function defaultSetTimout() {
                    throw new Error('setTimeout has not been defined');
                }
                function defaultClearTimeout() {
                    throw new Error('clearTimeout has not been defined');
                }
                (function() {
                    try {
                        if (typeof setTimeout === 'function') {
                            cachedSetTimeout = setTimeout;
                        } else {
                            cachedSetTimeout = defaultSetTimout;
                        }
                    } catch (e) {
                        cachedSetTimeout = defaultSetTimout;
                    }
                    try {
                        if (typeof clearTimeout === 'function') {
                            cachedClearTimeout = clearTimeout;
                        } else {
                            cachedClearTimeout = defaultClearTimeout;
                        }
                    } catch (e) {
                        cachedClearTimeout = defaultClearTimeout;
                    }
                })();
                function runTimeout(fun) {
                    if (cachedSetTimeout === setTimeout) {
                        //normal enviroments in sane situations
                        return setTimeout(fun, 0);
                    }
                    // if setTimeout wasn't available but was latter defined
                    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                        cachedSetTimeout = setTimeout;
                        return setTimeout(fun, 0);
                    }
                    try {
                        // when when somebody has screwed with setTimeout but no I.E. maddness
                        return cachedSetTimeout(fun, 0);
                    } catch (e) {
                        try {
                            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                            return cachedSetTimeout.call(null, fun, 0);
                        } catch (e) {
                            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                            return cachedSetTimeout.call(this, fun, 0);
                        }
                    }
                }
                function runClearTimeout(marker) {
                    if (cachedClearTimeout === clearTimeout) {
                        //normal enviroments in sane situations
                        return clearTimeout(marker);
                    }
                    // if clearTimeout wasn't available but was latter defined
                    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                        cachedClearTimeout = clearTimeout;
                        return clearTimeout(marker);
                    }
                    try {
                        // when when somebody has screwed with setTimeout but no I.E. maddness
                        return cachedClearTimeout(marker);
                    } catch (e) {
                        try {
                            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                            return cachedClearTimeout.call(null, marker);
                        } catch (e) {
                            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                            return cachedClearTimeout.call(this, marker);
                        }
                    }
                }
                var queue = [];
                var draining = false;
                var currentQueue;
                var queueIndex = -1;
                function cleanUpNextTick() {
                    if (!draining || !currentQueue) {
                        return;
                    }
                    draining = false;
                    if (currentQueue.length) {
                        queue = currentQueue.concat(queue);
                    } else {
                        queueIndex = -1;
                    }
                    if (queue.length) {
                        drainQueue();
                    }
                }
                function drainQueue() {
                    if (draining) {
                        return;
                    }
                    var timeout = runTimeout(cleanUpNextTick);
                    draining = true;
                    var len = queue.length;
                    while(len){
                        currentQueue = queue;
                        queue = [];
                        while(++queueIndex < len){
                            if (currentQueue) {
                                currentQueue[queueIndex].run();
                            }
                        }
                        queueIndex = -1;
                        len = queue.length;
                    }
                    currentQueue = null;
                    draining = false;
                    runClearTimeout(timeout);
                }
                process.nextTick = function(fun) {
                    var args = new Array(arguments.length - 1);
                    if (arguments.length > 1) {
                        for(var i = 1; i < arguments.length; i++){
                            args[i - 1] = arguments[i];
                        }
                    }
                    queue.push(new Item(fun, args));
                    if (queue.length === 1 && !draining) {
                        runTimeout(drainQueue);
                    }
                };
                // v8 likes predictible objects
                function Item(fun, array) {
                    this.fun = fun;
                    this.array = array;
                }
                Item.prototype.run = function() {
                    this.fun.apply(null, this.array);
                };
                process.title = 'browser';
                process.browser = true;
                process.env = {};
                process.argv = [];
                process.version = ''; // empty string to avoid regexp issues
                process.versions = {};
                function noop() {}
                process.on = noop;
                process.addListener = noop;
                process.once = noop;
                process.off = noop;
                process.removeListener = noop;
                process.removeAllListeners = noop;
                process.emit = noop;
                process.prependListener = noop;
                process.prependOnceListener = noop;
                process.listeners = function(name) {
                    return [];
                };
                process.binding = function(name) {
                    throw new Error('process.binding is not supported');
                };
                process.cwd = function() {
                    return '/';
                };
                process.chdir = function(dir) {
                    throw new Error('process.chdir is not supported');
                };
                process.umask = function() {
                    return 0;
                };
            /***/ },
            /***/ 4487: /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_186269__)=>{
                "use strict";
                /* harmony export */ __nested_webpack_require_186269__.d(__nested_webpack_exports__, {
                    /* harmony export */ BaseService: ()=>/* binding */ BaseService
                });
                /* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_186269__(6297);
                /* harmony import */ var vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_186269__(4881);
                function _define_property(obj, key, value) {
                    if (key in obj) {
                        Object.defineProperty(obj, key, {
                            value: value,
                            enumerable: true,
                            configurable: true,
                            writable: true
                        });
                    } else {
                        obj[key] = value;
                    }
                    return obj;
                }
                class BaseService {
                    addDocument(document1) {
                        this.documents[document1.uri] = vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_0__ /* .TextDocument */ .n.create(document1.uri, document1.languageId, document1.version, document1.text);
                    //TODO:
                    /*if (options)
            this.setSessionOptions(sessionID, options);*/ }
                    getDocument(uri) {
                        return this.documents[uri];
                    }
                    removeDocument(document1) {
                        delete this.documents[document1.uri];
                        if (this.options[document1.uri]) {
                            delete this.options[document1.uri];
                        }
                    }
                    getDocumentValue(uri) {
                        var _this_getDocument;
                        return (_this_getDocument = this.getDocument(uri)) === null || _this_getDocument === void 0 ? void 0 : _this_getDocument.getText();
                    }
                    setValue(identifier, value) {
                        let document1 = this.getDocument(identifier.uri);
                        if (document1) {
                            document1 = vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_0__ /* .TextDocument */ .n.create(document1.uri, document1.languageId, document1.version, value);
                            this.documents[document1.uri] = document1;
                        }
                    }
                    setGlobalOptions(options) {
                        this.globalOptions = options !== null && options !== void 0 ? options : {};
                    }
                    setOptions(sessionID, options, merge = false) {
                        this.options[sessionID] = merge ? (0, _utils__WEBPACK_IMPORTED_MODULE_1__ /* .mergeObjects */ .PM)(options, this.options[sessionID]) : options;
                    }
                    getOption(sessionID, optionName) {
                        if (this.options[sessionID] && this.options[sessionID][optionName]) {
                            return this.options[sessionID][optionName];
                        } else {
                            return this.globalOptions[optionName];
                        }
                    }
                    applyDeltas(identifier, deltas) {
                        let document1 = this.getDocument(identifier.uri);
                        if (document1) vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_0__ /* .TextDocument */ .n.update(document1, deltas, identifier.version);
                    }
                    async doComplete(document1, position) {
                        return null;
                    }
                    async doHover(document1, position) {
                        return null;
                    }
                    async doResolve(item) {
                        return null;
                    }
                    async doValidation(document1) {
                        return [];
                    }
                    format(document1, range, options) {
                        return Promise.resolve([]);
                    }
                    async provideSignatureHelp(document1, position) {
                        return null;
                    }
                    async findDocumentHighlights(document1, position) {
                        return [];
                    }
                    get optionsToFilterDiagnostics() {
                        var _this_globalOptions_errorCodesToIgnore, _this_globalOptions_errorCodesToTreatAsWarning, _this_globalOptions_errorCodesToTreatAsInfo, _this_globalOptions_errorMessagesToIgnore, _this_globalOptions_errorMessagesToTreatAsWarning, _this_globalOptions_errorMessagesToTreatAsInfo;
                        return {
                            errorCodesToIgnore: (_this_globalOptions_errorCodesToIgnore = this.globalOptions.errorCodesToIgnore) !== null && _this_globalOptions_errorCodesToIgnore !== void 0 ? _this_globalOptions_errorCodesToIgnore : [],
                            errorCodesToTreatAsWarning: (_this_globalOptions_errorCodesToTreatAsWarning = this.globalOptions.errorCodesToTreatAsWarning) !== null && _this_globalOptions_errorCodesToTreatAsWarning !== void 0 ? _this_globalOptions_errorCodesToTreatAsWarning : [],
                            errorCodesToTreatAsInfo: (_this_globalOptions_errorCodesToTreatAsInfo = this.globalOptions.errorCodesToTreatAsInfo) !== null && _this_globalOptions_errorCodesToTreatAsInfo !== void 0 ? _this_globalOptions_errorCodesToTreatAsInfo : [],
                            errorMessagesToIgnore: (_this_globalOptions_errorMessagesToIgnore = this.globalOptions.errorMessagesToIgnore) !== null && _this_globalOptions_errorMessagesToIgnore !== void 0 ? _this_globalOptions_errorMessagesToIgnore : [],
                            errorMessagesToTreatAsWarning: (_this_globalOptions_errorMessagesToTreatAsWarning = this.globalOptions.errorMessagesToTreatAsWarning) !== null && _this_globalOptions_errorMessagesToTreatAsWarning !== void 0 ? _this_globalOptions_errorMessagesToTreatAsWarning : [],
                            errorMessagesToTreatAsInfo: (_this_globalOptions_errorMessagesToTreatAsInfo = this.globalOptions.errorMessagesToTreatAsInfo) !== null && _this_globalOptions_errorMessagesToTreatAsInfo !== void 0 ? _this_globalOptions_errorMessagesToTreatAsInfo : []
                        };
                    }
                    constructor(mode){
                        _define_property(this, "mode", void 0);
                        _define_property(this, "documents", {});
                        _define_property(this, "options", {});
                        _define_property(this, "globalOptions", {});
                        _define_property(this, "serviceData", void 0);
                        _define_property(this, "serviceCapabilities", {});
                        this.mode = mode;
                    }
                }
            /***/ },
            /***/ 6297: /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_193451__)=>{
                "use strict";
                /* harmony export */ __nested_webpack_require_193451__.d(__nested_webpack_exports__, {
                    /* harmony export */ PM: ()=>/* binding */ mergeObjects
                });
                /* unused harmony exports notEmpty, mergeRanges, checkValueAgainstRegexpArray */ function mergeObjects(obj1, obj2) {
                    if (!obj1) return obj2;
                    if (!obj2) return obj1;
                    const mergedObjects = {
                        ...obj2,
                        ...obj1
                    }; // Give priority to obj1 values by spreading obj2 first, then obj1
                    for (const key of Object.keys(mergedObjects)){
                        if (obj1[key] && obj2[key]) {
                            if (Array.isArray(obj1[key])) {
                                mergedObjects[key] = obj1[key].concat(obj2[key]);
                            } else if (Array.isArray(obj2[key])) {
                                mergedObjects[key] = obj2[key].concat(obj1[key]);
                            } else if (typeof obj1[key] === 'object' && typeof obj2[key] === 'object') {
                                mergedObjects[key] = mergeObjects(obj1[key], obj2[key]);
                            }
                        }
                    }
                    return mergedObjects;
                }
                function notEmpty(value) {
                    return value !== null && value !== undefined;
                }
                //taken with small changes from ace-code
                function mergeRanges(ranges) {
                    var list = ranges;
                    list = list.sort(function(a, b) {
                        return comparePoints(a.start, b.start);
                    });
                    var next = list[0], range;
                    for(var i = 1; i < list.length; i++){
                        range = next;
                        next = list[i];
                        var cmp = comparePoints(range.end, next.start);
                        if (cmp < 0) continue;
                        if (cmp == 0 && !range.isEmpty() && !next.isEmpty()) continue;
                        if (comparePoints(range.end, next.end) < 0) {
                            range.end.row = next.end.row;
                            range.end.column = next.end.column;
                        }
                        list.splice(i, 1);
                        next = range;
                        i--;
                    }
                    return list;
                }
                function comparePoints(p1, p2) {
                    return p1.row - p2.row || p1.column - p2.column;
                }
                function checkValueAgainstRegexpArray(value, regexpArray) {
                    if (!regexpArray) {
                        return false;
                    }
                    for(let i = 0; i < regexpArray.length; i++){
                        if (regexpArray[i].test(value)) {
                            return true;
                        }
                    }
                    return false;
                }
            /***/ },
            /***/ 82: /***/ (module1)=>{
                module1.exports = function isBuffer(arg) {
                    return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
                };
            /***/ },
            /***/ 4895: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_197018__)=>{
                "use strict";
                // Currently in sync with Node.js lib/internal/util/types.js
                // https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
                var isArgumentsObject = __nested_webpack_require_197018__(2635);
                var isGeneratorFunction = __nested_webpack_require_197018__(3138);
                var whichTypedArray = __nested_webpack_require_197018__(2094);
                var isTypedArray = __nested_webpack_require_197018__(198);
                function uncurryThis(f) {
                    return f.call.bind(f);
                }
                var BigIntSupported = typeof BigInt !== 'undefined';
                var SymbolSupported = typeof Symbol !== 'undefined';
                var ObjectToString = uncurryThis(Object.prototype.toString);
                var numberValue = uncurryThis(Number.prototype.valueOf);
                var stringValue = uncurryThis(String.prototype.valueOf);
                var booleanValue = uncurryThis(Boolean.prototype.valueOf);
                if (BigIntSupported) {
                    var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
                }
                if (SymbolSupported) {
                    var symbolValue = uncurryThis(Symbol.prototype.valueOf);
                }
                function checkBoxedPrimitive(value, prototypeValueOf) {
                    if (typeof value !== 'object') {
                        return false;
                    }
                    try {
                        prototypeValueOf(value);
                        return true;
                    } catch (e) {
                        return false;
                    }
                }
                exports1.isArgumentsObject = isArgumentsObject;
                exports1.isGeneratorFunction = isGeneratorFunction;
                exports1.isTypedArray = isTypedArray;
                // Taken from here and modified for better browser support
                // https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
                function isPromise(input) {
                    return typeof Promise !== 'undefined' && input instanceof Promise || input !== null && typeof input === 'object' && typeof input.then === 'function' && typeof input.catch === 'function';
                }
                exports1.isPromise = isPromise;
                function isArrayBufferView(value) {
                    if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
                        return ArrayBuffer.isView(value);
                    }
                    return isTypedArray(value) || isDataView(value);
                }
                exports1.isArrayBufferView = isArrayBufferView;
                function isUint8Array(value) {
                    return whichTypedArray(value) === 'Uint8Array';
                }
                exports1.isUint8Array = isUint8Array;
                function isUint8ClampedArray(value) {
                    return whichTypedArray(value) === 'Uint8ClampedArray';
                }
                exports1.isUint8ClampedArray = isUint8ClampedArray;
                function isUint16Array(value) {
                    return whichTypedArray(value) === 'Uint16Array';
                }
                exports1.isUint16Array = isUint16Array;
                function isUint32Array(value) {
                    return whichTypedArray(value) === 'Uint32Array';
                }
                exports1.isUint32Array = isUint32Array;
                function isInt8Array(value) {
                    return whichTypedArray(value) === 'Int8Array';
                }
                exports1.isInt8Array = isInt8Array;
                function isInt16Array(value) {
                    return whichTypedArray(value) === 'Int16Array';
                }
                exports1.isInt16Array = isInt16Array;
                function isInt32Array(value) {
                    return whichTypedArray(value) === 'Int32Array';
                }
                exports1.isInt32Array = isInt32Array;
                function isFloat32Array(value) {
                    return whichTypedArray(value) === 'Float32Array';
                }
                exports1.isFloat32Array = isFloat32Array;
                function isFloat64Array(value) {
                    return whichTypedArray(value) === 'Float64Array';
                }
                exports1.isFloat64Array = isFloat64Array;
                function isBigInt64Array(value) {
                    return whichTypedArray(value) === 'BigInt64Array';
                }
                exports1.isBigInt64Array = isBigInt64Array;
                function isBigUint64Array(value) {
                    return whichTypedArray(value) === 'BigUint64Array';
                }
                exports1.isBigUint64Array = isBigUint64Array;
                function isMapToString(value) {
                    return ObjectToString(value) === '[object Map]';
                }
                isMapToString.working = typeof Map !== 'undefined' && isMapToString(new Map());
                function isMap(value) {
                    if (typeof Map === 'undefined') {
                        return false;
                    }
                    return isMapToString.working ? isMapToString(value) : value instanceof Map;
                }
                exports1.isMap = isMap;
                function isSetToString(value) {
                    return ObjectToString(value) === '[object Set]';
                }
                isSetToString.working = typeof Set !== 'undefined' && isSetToString(new Set());
                function isSet(value) {
                    if (typeof Set === 'undefined') {
                        return false;
                    }
                    return isSetToString.working ? isSetToString(value) : value instanceof Set;
                }
                exports1.isSet = isSet;
                function isWeakMapToString(value) {
                    return ObjectToString(value) === '[object WeakMap]';
                }
                isWeakMapToString.working = typeof WeakMap !== 'undefined' && isWeakMapToString(new WeakMap());
                function isWeakMap(value) {
                    if (typeof WeakMap === 'undefined') {
                        return false;
                    }
                    return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
                }
                exports1.isWeakMap = isWeakMap;
                function isWeakSetToString(value) {
                    return ObjectToString(value) === '[object WeakSet]';
                }
                isWeakSetToString.working = typeof WeakSet !== 'undefined' && isWeakSetToString(new WeakSet());
                function isWeakSet(value) {
                    return isWeakSetToString(value);
                }
                exports1.isWeakSet = isWeakSet;
                function isArrayBufferToString(value) {
                    return ObjectToString(value) === '[object ArrayBuffer]';
                }
                isArrayBufferToString.working = typeof ArrayBuffer !== 'undefined' && isArrayBufferToString(new ArrayBuffer());
                function isArrayBuffer(value) {
                    if (typeof ArrayBuffer === 'undefined') {
                        return false;
                    }
                    return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
                }
                exports1.isArrayBuffer = isArrayBuffer;
                function isDataViewToString(value) {
                    return ObjectToString(value) === '[object DataView]';
                }
                isDataViewToString.working = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined' && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
                function isDataView(value) {
                    if (typeof DataView === 'undefined') {
                        return false;
                    }
                    return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
                }
                exports1.isDataView = isDataView;
                // Store a copy of SharedArrayBuffer in case it's deleted elsewhere
                var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
                function isSharedArrayBufferToString(value) {
                    return ObjectToString(value) === '[object SharedArrayBuffer]';
                }
                function isSharedArrayBuffer(value) {
                    if (typeof SharedArrayBufferCopy === 'undefined') {
                        return false;
                    }
                    if (typeof isSharedArrayBufferToString.working === 'undefined') {
                        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
                    }
                    return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
                }
                exports1.isSharedArrayBuffer = isSharedArrayBuffer;
                function isAsyncFunction(value) {
                    return ObjectToString(value) === '[object AsyncFunction]';
                }
                exports1.isAsyncFunction = isAsyncFunction;
                function isMapIterator(value) {
                    return ObjectToString(value) === '[object Map Iterator]';
                }
                exports1.isMapIterator = isMapIterator;
                function isSetIterator(value) {
                    return ObjectToString(value) === '[object Set Iterator]';
                }
                exports1.isSetIterator = isSetIterator;
                function isGeneratorObject(value) {
                    return ObjectToString(value) === '[object Generator]';
                }
                exports1.isGeneratorObject = isGeneratorObject;
                function isWebAssemblyCompiledModule(value) {
                    return ObjectToString(value) === '[object WebAssembly.Module]';
                }
                exports1.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
                function isNumberObject(value) {
                    return checkBoxedPrimitive(value, numberValue);
                }
                exports1.isNumberObject = isNumberObject;
                function isStringObject(value) {
                    return checkBoxedPrimitive(value, stringValue);
                }
                exports1.isStringObject = isStringObject;
                function isBooleanObject(value) {
                    return checkBoxedPrimitive(value, booleanValue);
                }
                exports1.isBooleanObject = isBooleanObject;
                function isBigIntObject(value) {
                    return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
                }
                exports1.isBigIntObject = isBigIntObject;
                function isSymbolObject(value) {
                    return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
                }
                exports1.isSymbolObject = isSymbolObject;
                function isBoxedPrimitive(value) {
                    return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
                }
                exports1.isBoxedPrimitive = isBoxedPrimitive;
                function isAnyArrayBuffer(value) {
                    return typeof Uint8Array !== 'undefined' && (isArrayBuffer(value) || isSharedArrayBuffer(value));
                }
                exports1.isAnyArrayBuffer = isAnyArrayBuffer;
                [
                    'isProxy',
                    'isExternal',
                    'isModuleNamespaceObject'
                ].forEach(function(method) {
                    Object.defineProperty(exports1, method, {
                        enumerable: false,
                        value: function() {
                            throw new Error(method + ' is not supported in userland');
                        }
                    });
                });
            /***/ },
            /***/ 3335: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_209494__)=>{
                /* provided dependency */ var process = __nested_webpack_require_209494__(4406);
                /* provided dependency */ var console = __nested_webpack_require_209494__(3716);
                // Copyright Joyent, Inc. and other Node contributors.
                //
                // Permission is hereby granted, free of charge, to any person obtaining a
                // copy of this software and associated documentation files (the
                // "Software"), to deal in the Software without restriction, including
                // without limitation the rights to use, copy, modify, merge, publish,
                // distribute, sublicense, and/or sell copies of the Software, and to permit
                // persons to whom the Software is furnished to do so, subject to the
                // following conditions:
                //
                // The above copyright notice and this permission notice shall be included
                // in all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
                // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
                // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
                // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
                // USE OR OTHER DEALINGS IN THE SOFTWARE.
                var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
                    var keys = Object.keys(obj);
                    var descriptors = {};
                    for(var i = 0; i < keys.length; i++){
                        descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
                    }
                    return descriptors;
                };
                var formatRegExp = /%[sdj%]/g;
                exports1.format = function(f) {
                    if (!isString(f)) {
                        var objects = [];
                        for(var i = 0; i < arguments.length; i++){
                            objects.push(inspect(arguments[i]));
                        }
                        return objects.join(' ');
                    }
                    var i = 1;
                    var args = arguments;
                    var len = args.length;
                    var str = String(f).replace(formatRegExp, function(x) {
                        if (x === '%%') return '%';
                        if (i >= len) return x;
                        switch(x){
                            case '%s':
                                return String(args[i++]);
                            case '%d':
                                return Number(args[i++]);
                            case '%j':
                                try {
                                    return JSON.stringify(args[i++]);
                                } catch (_) {
                                    return '[Circular]';
                                }
                            default:
                                return x;
                        }
                    });
                    for(var x = args[i]; i < len; x = args[++i]){
                        if (isNull(x) || !isObject(x)) {
                            str += ' ' + x;
                        } else {
                            str += ' ' + inspect(x);
                        }
                    }
                    return str;
                };
                // Mark that a method should not be used.
                // Returns a modified function which warns once by default.
                // If --no-deprecation is set, then it is a no-op.
                exports1.deprecate = function(fn, msg) {
                    if (typeof process !== 'undefined' && process.noDeprecation === true) {
                        return fn;
                    }
                    // Allow for deprecating things in the process of starting up.
                    if (typeof process === 'undefined') {
                        return function() {
                            return exports1.deprecate(fn, msg).apply(this, arguments);
                        };
                    }
                    var warned = false;
                    function deprecated() {
                        if (!warned) {
                            if (process.throwDeprecation) {
                                throw new Error(msg);
                            } else if (process.traceDeprecation) {
                                console.trace(msg);
                            } else {
                                console.error(msg);
                            }
                            warned = true;
                        }
                        return fn.apply(this, arguments);
                    }
                    return deprecated;
                };
                var debugs = {};
                var debugEnvRegex = /^$/;
                if (process.env.NODE_DEBUG) {
                    var debugEnv = process.env.NODE_DEBUG;
                    debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&').replace(/\*/g, '.*').replace(/,/g, '$|^').toUpperCase();
                    debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
                }
                exports1.debuglog = function(set) {
                    set = set.toUpperCase();
                    if (!debugs[set]) {
                        if (debugEnvRegex.test(set)) {
                            var pid = process.pid;
                            debugs[set] = function() {
                                var msg = exports1.format.apply(exports1, arguments);
                                console.error('%s %d: %s', set, pid, msg);
                            };
                        } else {
                            debugs[set] = function() {};
                        }
                    }
                    return debugs[set];
                };
                /**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */ /* legacy: obj, showHidden, depth, colors*/ function inspect(obj, opts) {
                    // default options
                    var ctx = {
                        seen: [],
                        stylize: stylizeNoColor
                    };
                    // legacy...
                    if (arguments.length >= 3) ctx.depth = arguments[2];
                    if (arguments.length >= 4) ctx.colors = arguments[3];
                    if (isBoolean(opts)) {
                        // legacy...
                        ctx.showHidden = opts;
                    } else if (opts) {
                        // got an "options" object
                        exports1._extend(ctx, opts);
                    }
                    // set default options
                    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
                    if (isUndefined(ctx.depth)) ctx.depth = 2;
                    if (isUndefined(ctx.colors)) ctx.colors = false;
                    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
                    if (ctx.colors) ctx.stylize = stylizeWithColor;
                    return formatValue(ctx, obj, ctx.depth);
                }
                exports1.inspect = inspect;
                // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
                inspect.colors = {
                    'bold': [
                        1,
                        22
                    ],
                    'italic': [
                        3,
                        23
                    ],
                    'underline': [
                        4,
                        24
                    ],
                    'inverse': [
                        7,
                        27
                    ],
                    'white': [
                        37,
                        39
                    ],
                    'grey': [
                        90,
                        39
                    ],
                    'black': [
                        30,
                        39
                    ],
                    'blue': [
                        34,
                        39
                    ],
                    'cyan': [
                        36,
                        39
                    ],
                    'green': [
                        32,
                        39
                    ],
                    'magenta': [
                        35,
                        39
                    ],
                    'red': [
                        31,
                        39
                    ],
                    'yellow': [
                        33,
                        39
                    ]
                };
                // Don't use 'blue' not visible on cmd.exe
                inspect.styles = {
                    'special': 'cyan',
                    'number': 'yellow',
                    'boolean': 'yellow',
                    'undefined': 'grey',
                    'null': 'bold',
                    'string': 'green',
                    'date': 'magenta',
                    // "name": intentionally not styling
                    'regexp': 'red'
                };
                function stylizeWithColor(str, styleType) {
                    var style = inspect.styles[styleType];
                    if (style) {
                        return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
                    } else {
                        return str;
                    }
                }
                function stylizeNoColor(str, styleType) {
                    return str;
                }
                function arrayToHash(array) {
                    var hash = {};
                    array.forEach(function(val, idx) {
                        hash[val] = true;
                    });
                    return hash;
                }
                function formatValue(ctx, value, recurseTimes) {
                    // Provide a hook for user-specified inspect functions.
                    // Check that value is an object with an inspect function on it
                    if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
                    value.inspect !== exports1.inspect && // Also filter out any prototype objects using the circular check.
                    !(value.constructor && value.constructor.prototype === value)) {
                        var ret = value.inspect(recurseTimes, ctx);
                        if (!isString(ret)) {
                            ret = formatValue(ctx, ret, recurseTimes);
                        }
                        return ret;
                    }
                    // Primitive types cannot have properties
                    var primitive = formatPrimitive(ctx, value);
                    if (primitive) {
                        return primitive;
                    }
                    // Look up the keys of the object.
                    var keys = Object.keys(value);
                    var visibleKeys = arrayToHash(keys);
                    if (ctx.showHidden) {
                        keys = Object.getOwnPropertyNames(value);
                    }
                    // IE doesn't make error fields non-enumerable
                    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
                    if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
                        return formatError(value);
                    }
                    // Some type of object without properties can be shortcutted.
                    if (keys.length === 0) {
                        if (isFunction(value)) {
                            var name = value.name ? ': ' + value.name : '';
                            return ctx.stylize('[Function' + name + ']', 'special');
                        }
                        if (isRegExp(value)) {
                            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                        }
                        if (isDate(value)) {
                            return ctx.stylize(Date.prototype.toString.call(value), 'date');
                        }
                        if (isError(value)) {
                            return formatError(value);
                        }
                    }
                    var base = '', array = false, braces = [
                        '{',
                        '}'
                    ];
                    // Make Array say that they are Array
                    if (isArray(value)) {
                        array = true;
                        braces = [
                            '[',
                            ']'
                        ];
                    }
                    // Make functions say that they are functions
                    if (isFunction(value)) {
                        var n = value.name ? ': ' + value.name : '';
                        base = ' [Function' + n + ']';
                    }
                    // Make RegExps say that they are RegExps
                    if (isRegExp(value)) {
                        base = ' ' + RegExp.prototype.toString.call(value);
                    }
                    // Make dates with properties first say the date
                    if (isDate(value)) {
                        base = ' ' + Date.prototype.toUTCString.call(value);
                    }
                    // Make error with message first say the error
                    if (isError(value)) {
                        base = ' ' + formatError(value);
                    }
                    if (keys.length === 0 && (!array || value.length == 0)) {
                        return braces[0] + base + braces[1];
                    }
                    if (recurseTimes < 0) {
                        if (isRegExp(value)) {
                            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                        } else {
                            return ctx.stylize('[Object]', 'special');
                        }
                    }
                    ctx.seen.push(value);
                    var output;
                    if (array) {
                        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
                    } else {
                        output = keys.map(function(key) {
                            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                        });
                    }
                    ctx.seen.pop();
                    return reduceToSingleString(output, base, braces);
                }
                function formatPrimitive(ctx, value) {
                    if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
                    if (isString(value)) {
                        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
                        return ctx.stylize(simple, 'string');
                    }
                    if (isNumber(value)) return ctx.stylize('' + value, 'number');
                    if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
                    // For some reason typeof null is "object", so special case here.
                    if (isNull(value)) return ctx.stylize('null', 'null');
                }
                function formatError(value) {
                    return '[' + Error.prototype.toString.call(value) + ']';
                }
                function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                    var output = [];
                    for(var i = 0, l = value.length; i < l; ++i){
                        if (hasOwnProperty(value, String(i))) {
                            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
                        } else {
                            output.push('');
                        }
                    }
                    keys.forEach(function(key) {
                        if (!key.match(/^\d+$/)) {
                            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
                        }
                    });
                    return output;
                }
                function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                    var name, str, desc;
                    desc = Object.getOwnPropertyDescriptor(value, key) || {
                        value: value[key]
                    };
                    if (desc.get) {
                        if (desc.set) {
                            str = ctx.stylize('[Getter/Setter]', 'special');
                        } else {
                            str = ctx.stylize('[Getter]', 'special');
                        }
                    } else {
                        if (desc.set) {
                            str = ctx.stylize('[Setter]', 'special');
                        }
                    }
                    if (!hasOwnProperty(visibleKeys, key)) {
                        name = '[' + key + ']';
                    }
                    if (!str) {
                        if (ctx.seen.indexOf(desc.value) < 0) {
                            if (isNull(recurseTimes)) {
                                str = formatValue(ctx, desc.value, null);
                            } else {
                                str = formatValue(ctx, desc.value, recurseTimes - 1);
                            }
                            if (str.indexOf('\n') > -1) {
                                if (array) {
                                    str = str.split('\n').map(function(line) {
                                        return '  ' + line;
                                    }).join('\n').slice(2);
                                } else {
                                    str = '\n' + str.split('\n').map(function(line) {
                                        return '   ' + line;
                                    }).join('\n');
                                }
                            }
                        } else {
                            str = ctx.stylize('[Circular]', 'special');
                        }
                    }
                    if (isUndefined(name)) {
                        if (array && key.match(/^\d+$/)) {
                            return str;
                        }
                        name = JSON.stringify('' + key);
                        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                            name = name.slice(1, -1);
                            name = ctx.stylize(name, 'name');
                        } else {
                            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                            name = ctx.stylize(name, 'string');
                        }
                    }
                    return name + ': ' + str;
                }
                function reduceToSingleString(output, base, braces) {
                    var numLinesEst = 0;
                    var length = output.reduce(function(prev, cur) {
                        numLinesEst++;
                        if (cur.indexOf('\n') >= 0) numLinesEst++;
                        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
                    }, 0);
                    if (length > 60) {
                        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
                    }
                    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
                }
                // NOTE: These type checking functions intentionally don't use `instanceof`
                // because it is fragile and can be easily faked with `Object.create()`.
                exports1.types = __nested_webpack_require_209494__(4895);
                function isArray(ar) {
                    return Array.isArray(ar);
                }
                exports1.isArray = isArray;
                function isBoolean(arg) {
                    return typeof arg === 'boolean';
                }
                exports1.isBoolean = isBoolean;
                function isNull(arg) {
                    return arg === null;
                }
                exports1.isNull = isNull;
                function isNullOrUndefined(arg) {
                    return arg == null;
                }
                exports1.isNullOrUndefined = isNullOrUndefined;
                function isNumber(arg) {
                    return typeof arg === 'number';
                }
                exports1.isNumber = isNumber;
                function isString(arg) {
                    return typeof arg === 'string';
                }
                exports1.isString = isString;
                function isSymbol(arg) {
                    return typeof arg === 'symbol';
                }
                exports1.isSymbol = isSymbol;
                function isUndefined(arg) {
                    return arg === void 0;
                }
                exports1.isUndefined = isUndefined;
                function isRegExp(re) {
                    return isObject(re) && objectToString(re) === '[object RegExp]';
                }
                exports1.isRegExp = isRegExp;
                exports1.types.isRegExp = isRegExp;
                function isObject(arg) {
                    return typeof arg === 'object' && arg !== null;
                }
                exports1.isObject = isObject;
                function isDate(d) {
                    return isObject(d) && objectToString(d) === '[object Date]';
                }
                exports1.isDate = isDate;
                exports1.types.isDate = isDate;
                function isError(e) {
                    return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
                }
                exports1.isError = isError;
                exports1.types.isNativeError = isError;
                function isFunction(arg) {
                    return typeof arg === 'function';
                }
                exports1.isFunction = isFunction;
                function isPrimitive(arg) {
                    return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
                    typeof arg === 'undefined';
                }
                exports1.isPrimitive = isPrimitive;
                exports1.isBuffer = __nested_webpack_require_209494__(82);
                function objectToString(o) {
                    return Object.prototype.toString.call(o);
                }
                function pad(n) {
                    return n < 10 ? '0' + n.toString(10) : n.toString(10);
                }
                var months = [
                    'Jan',
                    'Feb',
                    'Mar',
                    'Apr',
                    'May',
                    'Jun',
                    'Jul',
                    'Aug',
                    'Sep',
                    'Oct',
                    'Nov',
                    'Dec'
                ];
                // 26 Feb 16:19:34
                function timestamp() {
                    var d = new Date();
                    var time = [
                        pad(d.getHours()),
                        pad(d.getMinutes()),
                        pad(d.getSeconds())
                    ].join(':');
                    return [
                        d.getDate(),
                        months[d.getMonth()],
                        time
                    ].join(' ');
                }
                // log is just a thin wrapper to console.log that prepends a timestamp
                exports1.log = function() {
                    console.log('%s - %s', timestamp(), exports1.format.apply(exports1, arguments));
                };
                /**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */ exports1.inherits = __nested_webpack_require_209494__(1285);
                exports1._extend = function(origin, add) {
                    // Don't do anything if add isn't an object
                    if (!add || !isObject(add)) return origin;
                    var keys = Object.keys(add);
                    var i = keys.length;
                    while(i--){
                        origin[keys[i]] = add[keys[i]];
                    }
                    return origin;
                };
                function hasOwnProperty(obj, prop) {
                    return Object.prototype.hasOwnProperty.call(obj, prop);
                }
                var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;
                exports1.promisify = function promisify(original) {
                    if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');
                    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
                        var fn = original[kCustomPromisifiedSymbol];
                        if (typeof fn !== 'function') {
                            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                        }
                        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                            value: fn,
                            enumerable: false,
                            writable: false,
                            configurable: true
                        });
                        return fn;
                    }
                    function fn() {
                        var promiseResolve, promiseReject;
                        var promise = new Promise(function(resolve, reject) {
                            promiseResolve = resolve;
                            promiseReject = reject;
                        });
                        var args = [];
                        for(var i = 0; i < arguments.length; i++){
                            args.push(arguments[i]);
                        }
                        args.push(function(err, value) {
                            if (err) {
                                promiseReject(err);
                            } else {
                                promiseResolve(value);
                            }
                        });
                        try {
                            original.apply(this, args);
                        } catch (err) {
                            promiseReject(err);
                        }
                        return promise;
                    }
                    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
                    if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                        value: fn,
                        enumerable: false,
                        writable: false,
                        configurable: true
                    });
                    return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
                };
                exports1.promisify.custom = kCustomPromisifiedSymbol;
                function callbackifyOnRejected(reason, cb) {
                    // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
                    // Because `null` is a special error value in callbacks which means "no error
                    // occurred", we error-wrap so the callback consumer can distinguish between
                    // "the promise rejected with null" or "the promise fulfilled with undefined".
                    if (!reason) {
                        var newReason = new Error('Promise was rejected with a falsy value');
                        newReason.reason = reason;
                        reason = newReason;
                    }
                    return cb(reason);
                }
                function callbackify(original) {
                    if (typeof original !== 'function') {
                        throw new TypeError('The "original" argument must be of type Function');
                    }
                    // We DO NOT return the promise as it gives the user a false sense that
                    // the promise is actually somehow related to the callback's execution
                    // and that the callback throwing will reject the promise.
                    function callbackified() {
                        var args = [];
                        for(var i = 0; i < arguments.length; i++){
                            args.push(arguments[i]);
                        }
                        var maybeCb = args.pop();
                        if (typeof maybeCb !== 'function') {
                            throw new TypeError('The last argument must be of type Function');
                        }
                        var self = this;
                        var cb = function() {
                            return maybeCb.apply(self, arguments);
                        };
                        // In true node style we process the callback on `nextTick` with all the
                        // implications (stack, `uncaughtException`, `async_hooks`)
                        original.apply(this, args).then(function(ret) {
                            process.nextTick(cb.bind(null, null, ret));
                        }, function(rej) {
                            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
                        });
                    }
                    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
                    Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
                    return callbackified;
                }
                exports1.callbackify = callbackify;
            /***/ },
            /***/ 1200: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_241090__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */ module1.exports = __nested_webpack_require_241090__(5953);
            /***/ },
            /***/ 5953: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_241649__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createMessageConnection = exports1.BrowserMessageWriter = exports1.BrowserMessageReader = void 0;
                const ril_1 = __nested_webpack_require_241649__(3632);
                // Install the browser runtime abstract.
                ril_1.default.install();
                const api_1 = __nested_webpack_require_241649__(5247);
                __exportStar(__nested_webpack_require_241649__(5247), exports1);
                class BrowserMessageReader extends api_1.AbstractMessageReader {
                    listen(callback) {
                        return this._onData.event(callback);
                    }
                    constructor(port){
                        super();
                        this._onData = new api_1.Emitter();
                        this._messageListener = (event)=>{
                            this._onData.fire(event.data);
                        };
                        port.addEventListener('error', (event)=>this.fireError(event));
                        port.onmessage = this._messageListener;
                    }
                }
                exports1.BrowserMessageReader = BrowserMessageReader;
                class BrowserMessageWriter extends api_1.AbstractMessageWriter {
                    write(msg) {
                        try {
                            this.port.postMessage(msg);
                            return Promise.resolve();
                        } catch (error) {
                            this.handleError(error, msg);
                            return Promise.reject(error);
                        }
                    }
                    handleError(error, msg) {
                        this.errorCount++;
                        this.fireError(error, msg, this.errorCount);
                    }
                    end() {}
                    constructor(port){
                        super();
                        this.port = port;
                        this.errorCount = 0;
                        port.addEventListener('error', (event)=>this.fireError(event));
                    }
                }
                exports1.BrowserMessageWriter = BrowserMessageWriter;
                function createMessageConnection(reader, writer, logger, options) {
                    if (logger === undefined) {
                        logger = api_1.NullLogger;
                    }
                    if (api_1.ConnectionStrategy.is(options)) {
                        options = {
                            connectionStrategy: options
                        };
                    }
                    return (0, api_1.createMessageConnection)(reader, writer, logger, options);
                }
                exports1.createMessageConnection = createMessageConnection;
            /***/ },
            /***/ 3632: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_246064__)=>{
                "use strict";
                /* provided dependency */ var console = __nested_webpack_require_246064__(3716);
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                const api_1 = __nested_webpack_require_246064__(5247);
                class MessageBuffer extends api_1.AbstractMessageBuffer {
                    emptyBuffer() {
                        return MessageBuffer.emptyBuffer;
                    }
                    fromString(value, _encoding) {
                        return new TextEncoder().encode(value);
                    }
                    toString(value, encoding) {
                        if (encoding === 'ascii') {
                            return this.asciiDecoder.decode(value);
                        } else {
                            return new TextDecoder(encoding).decode(value);
                        }
                    }
                    asNative(buffer, length) {
                        if (length === undefined) {
                            return buffer;
                        } else {
                            return buffer.slice(0, length);
                        }
                    }
                    allocNative(length) {
                        return new Uint8Array(length);
                    }
                    constructor(encoding = 'utf-8'){
                        super(encoding);
                        this.asciiDecoder = new TextDecoder('ascii');
                    }
                }
                MessageBuffer.emptyBuffer = new Uint8Array(0);
                class ReadableStreamWrapper {
                    onClose(listener) {
                        this.socket.addEventListener('close', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('close', listener));
                    }
                    onError(listener) {
                        this.socket.addEventListener('error', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('error', listener));
                    }
                    onEnd(listener) {
                        this.socket.addEventListener('end', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('end', listener));
                    }
                    onData(listener) {
                        return this._onData.event(listener);
                    }
                    constructor(socket){
                        this.socket = socket;
                        this._onData = new api_1.Emitter();
                        this._messageListener = (event)=>{
                            const blob = event.data;
                            blob.arrayBuffer().then((buffer)=>{
                                this._onData.fire(new Uint8Array(buffer));
                            }, ()=>{
                                (0, api_1.RAL)().console.error(`Converting blob to array buffer failed.`);
                            });
                        };
                        this.socket.addEventListener('message', this._messageListener);
                    }
                }
                class WritableStreamWrapper {
                    onClose(listener) {
                        this.socket.addEventListener('close', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('close', listener));
                    }
                    onError(listener) {
                        this.socket.addEventListener('error', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('error', listener));
                    }
                    onEnd(listener) {
                        this.socket.addEventListener('end', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('end', listener));
                    }
                    write(data, encoding) {
                        if (typeof data === 'string') {
                            if (encoding !== undefined && encoding !== 'utf-8') {
                                throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);
                            }
                            this.socket.send(data);
                        } else {
                            this.socket.send(data);
                        }
                        return Promise.resolve();
                    }
                    end() {
                        this.socket.close();
                    }
                    constructor(socket){
                        this.socket = socket;
                    }
                }
                const _textEncoder = new TextEncoder();
                const _ril = Object.freeze({
                    messageBuffer: Object.freeze({
                        create: (encoding)=>new MessageBuffer(encoding)
                    }),
                    applicationJson: Object.freeze({
                        encoder: Object.freeze({
                            name: 'application/json',
                            encode: (msg, options)=>{
                                if (options.charset !== 'utf-8') {
                                    throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);
                                }
                                return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, undefined, 0)));
                            }
                        }),
                        decoder: Object.freeze({
                            name: 'application/json',
                            decode: (buffer, options)=>{
                                if (!(buffer instanceof Uint8Array)) {
                                    throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
                                }
                                return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
                            }
                        })
                    }),
                    stream: Object.freeze({
                        asReadableStream: (socket)=>new ReadableStreamWrapper(socket),
                        asWritableStream: (socket)=>new WritableStreamWrapper(socket)
                    }),
                    console: console,
                    timer: Object.freeze({
                        setTimeout (callback, ms, ...args) {
                            const handle = setTimeout(callback, ms, ...args);
                            return {
                                dispose: ()=>clearTimeout(handle)
                            };
                        },
                        setImmediate (callback, ...args) {
                            const handle = setTimeout(callback, 0, ...args);
                            return {
                                dispose: ()=>clearTimeout(handle)
                            };
                        },
                        setInterval (callback, ms, ...args) {
                            const handle = setInterval(callback, ms, ...args);
                            return {
                                dispose: ()=>clearInterval(handle)
                            };
                        }
                    })
                });
                function RIL() {
                    return _ril;
                }
                (function(RIL) {
                    function install() {
                        api_1.RAL.install(_ril);
                    }
                    RIL.install = install;
                })(RIL || (RIL = {}));
                exports1["default"] = RIL;
            /***/ },
            /***/ 5247: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_254443__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ /// <reference path="../../typings/thenable.d.ts" />
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ProgressType = exports1.ProgressToken = exports1.createMessageConnection = exports1.NullLogger = exports1.ConnectionOptions = exports1.ConnectionStrategy = exports1.AbstractMessageBuffer = exports1.WriteableStreamMessageWriter = exports1.AbstractMessageWriter = exports1.MessageWriter = exports1.ReadableStreamMessageReader = exports1.AbstractMessageReader = exports1.MessageReader = exports1.SharedArrayReceiverStrategy = exports1.SharedArraySenderStrategy = exports1.CancellationToken = exports1.CancellationTokenSource = exports1.Emitter = exports1.Event = exports1.Disposable = exports1.LRUCache = exports1.Touch = exports1.LinkedMap = exports1.ParameterStructures = exports1.NotificationType9 = exports1.NotificationType8 = exports1.NotificationType7 = exports1.NotificationType6 = exports1.NotificationType5 = exports1.NotificationType4 = exports1.NotificationType3 = exports1.NotificationType2 = exports1.NotificationType1 = exports1.NotificationType0 = exports1.NotificationType = exports1.ErrorCodes = exports1.ResponseError = exports1.RequestType9 = exports1.RequestType8 = exports1.RequestType7 = exports1.RequestType6 = exports1.RequestType5 = exports1.RequestType4 = exports1.RequestType3 = exports1.RequestType2 = exports1.RequestType1 = exports1.RequestType0 = exports1.RequestType = exports1.Message = exports1.RAL = void 0;
                exports1.MessageStrategy = exports1.CancellationStrategy = exports1.CancellationSenderStrategy = exports1.CancellationReceiverStrategy = exports1.ConnectionError = exports1.ConnectionErrors = exports1.LogTraceNotification = exports1.SetTraceNotification = exports1.TraceFormat = exports1.TraceValues = exports1.Trace = void 0;
                const messages_1 = __nested_webpack_require_254443__(9141);
                Object.defineProperty(exports1, "Message", {
                    enumerable: true,
                    get: function() {
                        return messages_1.Message;
                    }
                });
                Object.defineProperty(exports1, "RequestType", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType;
                    }
                });
                Object.defineProperty(exports1, "RequestType0", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType0;
                    }
                });
                Object.defineProperty(exports1, "RequestType1", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType1;
                    }
                });
                Object.defineProperty(exports1, "RequestType2", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType2;
                    }
                });
                Object.defineProperty(exports1, "RequestType3", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType3;
                    }
                });
                Object.defineProperty(exports1, "RequestType4", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType4;
                    }
                });
                Object.defineProperty(exports1, "RequestType5", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType5;
                    }
                });
                Object.defineProperty(exports1, "RequestType6", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType6;
                    }
                });
                Object.defineProperty(exports1, "RequestType7", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType7;
                    }
                });
                Object.defineProperty(exports1, "RequestType8", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType8;
                    }
                });
                Object.defineProperty(exports1, "RequestType9", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType9;
                    }
                });
                Object.defineProperty(exports1, "ResponseError", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ResponseError;
                    }
                });
                Object.defineProperty(exports1, "ErrorCodes", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ErrorCodes;
                    }
                });
                Object.defineProperty(exports1, "NotificationType", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType;
                    }
                });
                Object.defineProperty(exports1, "NotificationType0", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType0;
                    }
                });
                Object.defineProperty(exports1, "NotificationType1", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType1;
                    }
                });
                Object.defineProperty(exports1, "NotificationType2", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType2;
                    }
                });
                Object.defineProperty(exports1, "NotificationType3", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType3;
                    }
                });
                Object.defineProperty(exports1, "NotificationType4", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType4;
                    }
                });
                Object.defineProperty(exports1, "NotificationType5", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType5;
                    }
                });
                Object.defineProperty(exports1, "NotificationType6", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType6;
                    }
                });
                Object.defineProperty(exports1, "NotificationType7", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType7;
                    }
                });
                Object.defineProperty(exports1, "NotificationType8", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType8;
                    }
                });
                Object.defineProperty(exports1, "NotificationType9", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType9;
                    }
                });
                Object.defineProperty(exports1, "ParameterStructures", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ParameterStructures;
                    }
                });
                const linkedMap_1 = __nested_webpack_require_254443__(7040);
                Object.defineProperty(exports1, "LinkedMap", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.LinkedMap;
                    }
                });
                Object.defineProperty(exports1, "LRUCache", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.LRUCache;
                    }
                });
                Object.defineProperty(exports1, "Touch", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.Touch;
                    }
                });
                const disposable_1 = __nested_webpack_require_254443__(8437);
                Object.defineProperty(exports1, "Disposable", {
                    enumerable: true,
                    get: function() {
                        return disposable_1.Disposable;
                    }
                });
                const events_1 = __nested_webpack_require_254443__(5165);
                Object.defineProperty(exports1, "Event", {
                    enumerable: true,
                    get: function() {
                        return events_1.Event;
                    }
                });
                Object.defineProperty(exports1, "Emitter", {
                    enumerable: true,
                    get: function() {
                        return events_1.Emitter;
                    }
                });
                const cancellation_1 = __nested_webpack_require_254443__(415);
                Object.defineProperty(exports1, "CancellationTokenSource", {
                    enumerable: true,
                    get: function() {
                        return cancellation_1.CancellationTokenSource;
                    }
                });
                Object.defineProperty(exports1, "CancellationToken", {
                    enumerable: true,
                    get: function() {
                        return cancellation_1.CancellationToken;
                    }
                });
                const sharedArrayCancellation_1 = __nested_webpack_require_254443__(178);
                Object.defineProperty(exports1, "SharedArraySenderStrategy", {
                    enumerable: true,
                    get: function() {
                        return sharedArrayCancellation_1.SharedArraySenderStrategy;
                    }
                });
                Object.defineProperty(exports1, "SharedArrayReceiverStrategy", {
                    enumerable: true,
                    get: function() {
                        return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
                    }
                });
                const messageReader_1 = __nested_webpack_require_254443__(451);
                Object.defineProperty(exports1, "MessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.MessageReader;
                    }
                });
                Object.defineProperty(exports1, "AbstractMessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.AbstractMessageReader;
                    }
                });
                Object.defineProperty(exports1, "ReadableStreamMessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.ReadableStreamMessageReader;
                    }
                });
                const messageWriter_1 = __nested_webpack_require_254443__(1251);
                Object.defineProperty(exports1, "MessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.MessageWriter;
                    }
                });
                Object.defineProperty(exports1, "AbstractMessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.AbstractMessageWriter;
                    }
                });
                Object.defineProperty(exports1, "WriteableStreamMessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.WriteableStreamMessageWriter;
                    }
                });
                const messageBuffer_1 = __nested_webpack_require_254443__(8652);
                Object.defineProperty(exports1, "AbstractMessageBuffer", {
                    enumerable: true,
                    get: function() {
                        return messageBuffer_1.AbstractMessageBuffer;
                    }
                });
                const connection_1 = __nested_webpack_require_254443__(1908);
                Object.defineProperty(exports1, "ConnectionStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionStrategy;
                    }
                });
                Object.defineProperty(exports1, "ConnectionOptions", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionOptions;
                    }
                });
                Object.defineProperty(exports1, "NullLogger", {
                    enumerable: true,
                    get: function() {
                        return connection_1.NullLogger;
                    }
                });
                Object.defineProperty(exports1, "createMessageConnection", {
                    enumerable: true,
                    get: function() {
                        return connection_1.createMessageConnection;
                    }
                });
                Object.defineProperty(exports1, "ProgressToken", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ProgressToken;
                    }
                });
                Object.defineProperty(exports1, "ProgressType", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ProgressType;
                    }
                });
                Object.defineProperty(exports1, "Trace", {
                    enumerable: true,
                    get: function() {
                        return connection_1.Trace;
                    }
                });
                Object.defineProperty(exports1, "TraceValues", {
                    enumerable: true,
                    get: function() {
                        return connection_1.TraceValues;
                    }
                });
                Object.defineProperty(exports1, "TraceFormat", {
                    enumerable: true,
                    get: function() {
                        return connection_1.TraceFormat;
                    }
                });
                Object.defineProperty(exports1, "SetTraceNotification", {
                    enumerable: true,
                    get: function() {
                        return connection_1.SetTraceNotification;
                    }
                });
                Object.defineProperty(exports1, "LogTraceNotification", {
                    enumerable: true,
                    get: function() {
                        return connection_1.LogTraceNotification;
                    }
                });
                Object.defineProperty(exports1, "ConnectionErrors", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionErrors;
                    }
                });
                Object.defineProperty(exports1, "ConnectionError", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionError;
                    }
                });
                Object.defineProperty(exports1, "CancellationReceiverStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationReceiverStrategy;
                    }
                });
                Object.defineProperty(exports1, "CancellationSenderStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationSenderStrategy;
                    }
                });
                Object.defineProperty(exports1, "CancellationStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationStrategy;
                    }
                });
                Object.defineProperty(exports1, "MessageStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.MessageStrategy;
                    }
                });
                const ral_1 = __nested_webpack_require_254443__(5706);
                exports1.RAL = ral_1.default;
            /***/ },
            /***/ 415: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_272504__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.CancellationTokenSource = exports1.CancellationToken = void 0;
                const ral_1 = __nested_webpack_require_272504__(5706);
                const Is = __nested_webpack_require_272504__(8811);
                const events_1 = __nested_webpack_require_272504__(5165);
                var CancellationToken;
                (function(CancellationToken) {
                    CancellationToken.None = Object.freeze({
                        isCancellationRequested: false,
                        onCancellationRequested: events_1.Event.None
                    });
                    CancellationToken.Cancelled = Object.freeze({
                        isCancellationRequested: true,
                        onCancellationRequested: events_1.Event.None
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate === CancellationToken.None || candidate === CancellationToken.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
                    }
                    CancellationToken.is = is;
                })(CancellationToken = exports1.CancellationToken || (exports1.CancellationToken = {}));
                const shortcutEvent = Object.freeze(function(callback, context) {
                    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
                    return {
                        dispose () {
                            handle.dispose();
                        }
                    };
                });
                class MutableToken {
                    cancel() {
                        if (!this._isCancelled) {
                            this._isCancelled = true;
                            if (this._emitter) {
                                this._emitter.fire(undefined);
                                this.dispose();
                            }
                        }
                    }
                    get isCancellationRequested() {
                        return this._isCancelled;
                    }
                    get onCancellationRequested() {
                        if (this._isCancelled) {
                            return shortcutEvent;
                        }
                        if (!this._emitter) {
                            this._emitter = new events_1.Emitter();
                        }
                        return this._emitter.event;
                    }
                    dispose() {
                        if (this._emitter) {
                            this._emitter.dispose();
                            this._emitter = undefined;
                        }
                    }
                    constructor(){
                        this._isCancelled = false;
                    }
                }
                class CancellationTokenSource {
                    get token() {
                        if (!this._token) {
                            // be lazy and create the token only when
                            // actually needed
                            this._token = new MutableToken();
                        }
                        return this._token;
                    }
                    cancel() {
                        if (!this._token) {
                            // save an object by returning the default
                            // cancelled token when cancellation happens
                            // before someone asks for the token
                            this._token = CancellationToken.Cancelled;
                        } else {
                            this._token.cancel();
                        }
                    }
                    dispose() {
                        if (!this._token) {
                            // ensure to initialize with an empty token if we had none
                            this._token = CancellationToken.None;
                        } else if (this._token instanceof MutableToken) {
                            // actually dispose
                            this._token.dispose();
                        }
                    }
                }
                exports1.CancellationTokenSource = CancellationTokenSource;
            /***/ },
            /***/ 1908: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_277438__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createMessageConnection = exports1.ConnectionOptions = exports1.MessageStrategy = exports1.CancellationStrategy = exports1.CancellationSenderStrategy = exports1.CancellationReceiverStrategy = exports1.RequestCancellationReceiverStrategy = exports1.IdCancellationReceiverStrategy = exports1.ConnectionStrategy = exports1.ConnectionError = exports1.ConnectionErrors = exports1.LogTraceNotification = exports1.SetTraceNotification = exports1.TraceFormat = exports1.TraceValues = exports1.Trace = exports1.NullLogger = exports1.ProgressType = exports1.ProgressToken = void 0;
                const ral_1 = __nested_webpack_require_277438__(5706);
                const Is = __nested_webpack_require_277438__(8811);
                const messages_1 = __nested_webpack_require_277438__(9141);
                const linkedMap_1 = __nested_webpack_require_277438__(7040);
                const events_1 = __nested_webpack_require_277438__(5165);
                const cancellation_1 = __nested_webpack_require_277438__(415);
                var CancelNotification;
                (function(CancelNotification) {
                    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
                })(CancelNotification || (CancelNotification = {}));
                var ProgressToken;
                (function(ProgressToken) {
                    function is(value) {
                        return typeof value === 'string' || typeof value === 'number';
                    }
                    ProgressToken.is = is;
                })(ProgressToken = exports1.ProgressToken || (exports1.ProgressToken = {}));
                var ProgressNotification;
                (function(ProgressNotification) {
                    ProgressNotification.type = new messages_1.NotificationType('$/progress');
                })(ProgressNotification || (ProgressNotification = {}));
                class ProgressType {
                    constructor(){}
                }
                exports1.ProgressType = ProgressType;
                var StarRequestHandler;
                (function(StarRequestHandler) {
                    function is(value) {
                        return Is.func(value);
                    }
                    StarRequestHandler.is = is;
                })(StarRequestHandler || (StarRequestHandler = {}));
                exports1.NullLogger = Object.freeze({
                    error: ()=>{},
                    warn: ()=>{},
                    info: ()=>{},
                    log: ()=>{}
                });
                var Trace;
                (function(Trace) {
                    Trace[Trace["Off"] = 0] = "Off";
                    Trace[Trace["Messages"] = 1] = "Messages";
                    Trace[Trace["Compact"] = 2] = "Compact";
                    Trace[Trace["Verbose"] = 3] = "Verbose";
                })(Trace = exports1.Trace || (exports1.Trace = {}));
                var TraceValues;
                (function(TraceValues) {
                    /**
     * Turn tracing off.
     */ TraceValues.Off = 'off';
                    /**
     * Trace messages only.
     */ TraceValues.Messages = 'messages';
                    /**
     * Compact message tracing.
     */ TraceValues.Compact = 'compact';
                    /**
     * Verbose message tracing.
     */ TraceValues.Verbose = 'verbose';
                })(TraceValues = exports1.TraceValues || (exports1.TraceValues = {}));
                (function(Trace) {
                    function fromString(value) {
                        if (!Is.string(value)) {
                            return Trace.Off;
                        }
                        value = value.toLowerCase();
                        switch(value){
                            case 'off':
                                return Trace.Off;
                            case 'messages':
                                return Trace.Messages;
                            case 'compact':
                                return Trace.Compact;
                            case 'verbose':
                                return Trace.Verbose;
                            default:
                                return Trace.Off;
                        }
                    }
                    Trace.fromString = fromString;
                    function toString(value) {
                        switch(value){
                            case Trace.Off:
                                return 'off';
                            case Trace.Messages:
                                return 'messages';
                            case Trace.Compact:
                                return 'compact';
                            case Trace.Verbose:
                                return 'verbose';
                            default:
                                return 'off';
                        }
                    }
                    Trace.toString = toString;
                })(Trace = exports1.Trace || (exports1.Trace = {}));
                var TraceFormat;
                (function(TraceFormat) {
                    TraceFormat["Text"] = "text";
                    TraceFormat["JSON"] = "json";
                })(TraceFormat = exports1.TraceFormat || (exports1.TraceFormat = {}));
                (function(TraceFormat) {
                    function fromString(value) {
                        if (!Is.string(value)) {
                            return TraceFormat.Text;
                        }
                        value = value.toLowerCase();
                        if (value === 'json') {
                            return TraceFormat.JSON;
                        } else {
                            return TraceFormat.Text;
                        }
                    }
                    TraceFormat.fromString = fromString;
                })(TraceFormat = exports1.TraceFormat || (exports1.TraceFormat = {}));
                var SetTraceNotification;
                (function(SetTraceNotification) {
                    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');
                })(SetTraceNotification = exports1.SetTraceNotification || (exports1.SetTraceNotification = {}));
                var LogTraceNotification;
                (function(LogTraceNotification) {
                    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');
                })(LogTraceNotification = exports1.LogTraceNotification || (exports1.LogTraceNotification = {}));
                var ConnectionErrors;
                (function(ConnectionErrors) {
                    /**
     * The connection is closed.
     */ ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
                    /**
     * The connection got disposed.
     */ ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
                    /**
     * The connection is already in listening mode.
     */ ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
                })(ConnectionErrors = exports1.ConnectionErrors || (exports1.ConnectionErrors = {}));
                class ConnectionError extends Error {
                    constructor(code, message){
                        super(message);
                        this.code = code;
                        Object.setPrototypeOf(this, ConnectionError.prototype);
                    }
                }
                exports1.ConnectionError = ConnectionError;
                var ConnectionStrategy;
                (function(ConnectionStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.cancelUndispatched);
                    }
                    ConnectionStrategy.is = is;
                })(ConnectionStrategy = exports1.ConnectionStrategy || (exports1.ConnectionStrategy = {}));
                var IdCancellationReceiverStrategy;
                (function(IdCancellationReceiverStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate.kind === undefined || candidate.kind === 'id') && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
                    }
                    IdCancellationReceiverStrategy.is = is;
                })(IdCancellationReceiverStrategy = exports1.IdCancellationReceiverStrategy || (exports1.IdCancellationReceiverStrategy = {}));
                var RequestCancellationReceiverStrategy;
                (function(RequestCancellationReceiverStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && candidate.kind === 'request' && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
                    }
                    RequestCancellationReceiverStrategy.is = is;
                })(RequestCancellationReceiverStrategy = exports1.RequestCancellationReceiverStrategy || (exports1.RequestCancellationReceiverStrategy = {}));
                var CancellationReceiverStrategy;
                (function(CancellationReceiverStrategy) {
                    CancellationReceiverStrategy.Message = Object.freeze({
                        createCancellationTokenSource (_) {
                            return new cancellation_1.CancellationTokenSource();
                        }
                    });
                    function is(value) {
                        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
                    }
                    CancellationReceiverStrategy.is = is;
                })(CancellationReceiverStrategy = exports1.CancellationReceiverStrategy || (exports1.CancellationReceiverStrategy = {}));
                var CancellationSenderStrategy;
                (function(CancellationSenderStrategy) {
                    CancellationSenderStrategy.Message = Object.freeze({
                        sendCancellation (conn, id) {
                            return conn.sendNotification(CancelNotification.type, {
                                id
                            });
                        },
                        cleanup (_) {}
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
                    }
                    CancellationSenderStrategy.is = is;
                })(CancellationSenderStrategy = exports1.CancellationSenderStrategy || (exports1.CancellationSenderStrategy = {}));
                var CancellationStrategy;
                (function(CancellationStrategy) {
                    CancellationStrategy.Message = Object.freeze({
                        receiver: CancellationReceiverStrategy.Message,
                        sender: CancellationSenderStrategy.Message
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
                    }
                    CancellationStrategy.is = is;
                })(CancellationStrategy = exports1.CancellationStrategy || (exports1.CancellationStrategy = {}));
                var MessageStrategy;
                (function(MessageStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.handleMessage);
                    }
                    MessageStrategy.is = is;
                })(MessageStrategy = exports1.MessageStrategy || (exports1.MessageStrategy = {}));
                var ConnectionOptions;
                (function(ConnectionOptions) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
                    }
                    ConnectionOptions.is = is;
                })(ConnectionOptions = exports1.ConnectionOptions || (exports1.ConnectionOptions = {}));
                var ConnectionState;
                (function(ConnectionState) {
                    ConnectionState[ConnectionState["New"] = 1] = "New";
                    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
                    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
                    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
                })(ConnectionState || (ConnectionState = {}));
                function createMessageConnection(messageReader, messageWriter, _logger, options) {
                    const logger = _logger !== undefined ? _logger : exports1.NullLogger;
                    let sequenceNumber = 0;
                    let notificationSequenceNumber = 0;
                    let unknownResponseSequenceNumber = 0;
                    const version = '2.0';
                    let starRequestHandler = undefined;
                    const requestHandlers = new Map();
                    let starNotificationHandler = undefined;
                    const notificationHandlers = new Map();
                    const progressHandlers = new Map();
                    let timer;
                    let messageQueue = new linkedMap_1.LinkedMap();
                    let responsePromises = new Map();
                    let knownCanceledRequests = new Set();
                    let requestTokens = new Map();
                    let trace = Trace.Off;
                    let traceFormat = TraceFormat.Text;
                    let tracer;
                    let state = ConnectionState.New;
                    const errorEmitter = new events_1.Emitter();
                    const closeEmitter = new events_1.Emitter();
                    const unhandledNotificationEmitter = new events_1.Emitter();
                    const unhandledProgressEmitter = new events_1.Emitter();
                    const disposeEmitter = new events_1.Emitter();
                    const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
                    function createRequestQueueKey(id) {
                        if (id === null) {
                            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
                        }
                        return 'req-' + id.toString();
                    }
                    function createResponseQueueKey(id) {
                        if (id === null) {
                            return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();
                        } else {
                            return 'res-' + id.toString();
                        }
                    }
                    function createNotificationQueueKey() {
                        return 'not-' + (++notificationSequenceNumber).toString();
                    }
                    function addMessageToQueue(queue, message) {
                        if (messages_1.Message.isRequest(message)) {
                            queue.set(createRequestQueueKey(message.id), message);
                        } else if (messages_1.Message.isResponse(message)) {
                            queue.set(createResponseQueueKey(message.id), message);
                        } else {
                            queue.set(createNotificationQueueKey(), message);
                        }
                    }
                    function cancelUndispatched(_message) {
                        return undefined;
                    }
                    function isListening() {
                        return state === ConnectionState.Listening;
                    }
                    function isClosed() {
                        return state === ConnectionState.Closed;
                    }
                    function isDisposed() {
                        return state === ConnectionState.Disposed;
                    }
                    function closeHandler() {
                        if (state === ConnectionState.New || state === ConnectionState.Listening) {
                            state = ConnectionState.Closed;
                            closeEmitter.fire(undefined);
                        }
                    // If the connection is disposed don't sent close events.
                    }
                    function readErrorHandler(error) {
                        errorEmitter.fire([
                            error,
                            undefined,
                            undefined
                        ]);
                    }
                    function writeErrorHandler(data) {
                        errorEmitter.fire(data);
                    }
                    messageReader.onClose(closeHandler);
                    messageReader.onError(readErrorHandler);
                    messageWriter.onClose(closeHandler);
                    messageWriter.onError(writeErrorHandler);
                    function triggerMessageQueue() {
                        if (timer || messageQueue.size === 0) {
                            return;
                        }
                        timer = (0, ral_1.default)().timer.setImmediate(()=>{
                            timer = undefined;
                            processMessageQueue();
                        });
                    }
                    function handleMessage(message) {
                        if (messages_1.Message.isRequest(message)) {
                            handleRequest(message);
                        } else if (messages_1.Message.isNotification(message)) {
                            handleNotification(message);
                        } else if (messages_1.Message.isResponse(message)) {
                            handleResponse(message);
                        } else {
                            handleInvalidMessage(message);
                        }
                    }
                    function processMessageQueue() {
                        if (messageQueue.size === 0) {
                            return;
                        }
                        const message = messageQueue.shift();
                        try {
                            var _options;
                            const messageStrategy = (_options = options) === null || _options === void 0 ? void 0 : _options.messageStrategy;
                            if (MessageStrategy.is(messageStrategy)) {
                                messageStrategy.handleMessage(message, handleMessage);
                            } else {
                                handleMessage(message);
                            }
                        } finally{
                            triggerMessageQueue();
                        }
                    }
                    const callback = (message)=>{
                        try {
                            // We have received a cancellation message. Check if the message is still in the queue
                            // and cancel it if allowed to do so.
                            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
                                const cancelId = message.params.id;
                                const key = createRequestQueueKey(cancelId);
                                const toCancel = messageQueue.get(key);
                                if (messages_1.Message.isRequest(toCancel)) {
                                    var _options;
                                    const strategy = (_options = options) === null || _options === void 0 ? void 0 : _options.connectionStrategy;
                                    const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                                    if (response && (response.error !== undefined || response.result !== undefined)) {
                                        messageQueue.delete(key);
                                        requestTokens.delete(cancelId);
                                        response.id = toCancel.id;
                                        traceSendingResponse(response, message.method, Date.now());
                                        messageWriter.write(response).catch(()=>logger.error(`Sending response for canceled message failed.`));
                                        return;
                                    }
                                }
                                const cancellationToken = requestTokens.get(cancelId);
                                // The request is already running. Cancel the token
                                if (cancellationToken !== undefined) {
                                    cancellationToken.cancel();
                                    traceReceivedNotification(message);
                                    return;
                                } else {
                                    // Remember the cancel but still queue the message to
                                    // clean up state in process message.
                                    knownCanceledRequests.add(cancelId);
                                }
                            }
                            addMessageToQueue(messageQueue, message);
                        } finally{
                            triggerMessageQueue();
                        }
                    };
                    function handleRequest(requestMessage) {
                        if (isDisposed()) {
                            // we return here silently since we fired an event when the
                            // connection got disposed.
                            return;
                        }
                        function reply(resultOrError, method, startTime) {
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id
                            };
                            if (resultOrError instanceof messages_1.ResponseError) {
                                message.error = resultOrError.toJson();
                            } else {
                                message.result = resultOrError === undefined ? null : resultOrError;
                            }
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        function replyError(error, method, startTime) {
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id,
                                error: error.toJson()
                            };
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        function replySuccess(result, method, startTime) {
                            // The JSON RPC defines that a response must either have a result or an error
                            // So we can't treat undefined as a valid response result.
                            if (result === undefined) {
                                result = null;
                            }
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id,
                                result: result
                            };
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        traceReceivedRequest(requestMessage);
                        const element = requestHandlers.get(requestMessage.method);
                        let type;
                        let requestHandler;
                        if (element) {
                            type = element.type;
                            requestHandler = element.handler;
                        }
                        const startTime = Date.now();
                        if (requestHandler || starRequestHandler) {
                            var _requestMessage_id;
                            const tokenKey = (_requestMessage_id = requestMessage.id) !== null && _requestMessage_id !== void 0 ? _requestMessage_id : String(Date.now()); //
                            const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
                            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
                                cancellationSource.cancel();
                            }
                            if (requestMessage.id !== null) {
                                requestTokens.set(tokenKey, cancellationSource);
                            }
                            try {
                                let handlerResult;
                                if (requestHandler) {
                                    if (requestMessage.params === undefined) {
                                        if (type !== undefined && type.numberOfParams !== 0) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(cancellationSource.token);
                                    } else if (Array.isArray(requestMessage.params)) {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                                    } else {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                                    }
                                } else if (starRequestHandler) {
                                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                                }
                                const promise = handlerResult;
                                if (!handlerResult) {
                                    requestTokens.delete(tokenKey);
                                    replySuccess(handlerResult, requestMessage.method, startTime);
                                } else if (promise.then) {
                                    promise.then((resultOrError)=>{
                                        requestTokens.delete(tokenKey);
                                        reply(resultOrError, requestMessage.method, startTime);
                                    }, (error)=>{
                                        requestTokens.delete(tokenKey);
                                        if (error instanceof messages_1.ResponseError) {
                                            replyError(error, requestMessage.method, startTime);
                                        } else if (error && Is.string(error.message)) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                                        } else {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                                        }
                                    });
                                } else {
                                    requestTokens.delete(tokenKey);
                                    reply(handlerResult, requestMessage.method, startTime);
                                }
                            } catch (error) {
                                requestTokens.delete(tokenKey);
                                if (error instanceof messages_1.ResponseError) {
                                    reply(error, requestMessage.method, startTime);
                                } else if (error && Is.string(error.message)) {
                                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                                } else {
                                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                                }
                            }
                        } else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
                        }
                    }
                    function handleResponse(responseMessage) {
                        if (isDisposed()) {
                            // See handle request.
                            return;
                        }
                        if (responseMessage.id === null) {
                            if (responseMessage.error) {
                                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
                            } else {
                                logger.error(`Received response message without id. No further error information provided.`);
                            }
                        } else {
                            const key = responseMessage.id;
                            const responsePromise = responsePromises.get(key);
                            traceReceivedResponse(responseMessage, responsePromise);
                            if (responsePromise !== undefined) {
                                responsePromises.delete(key);
                                try {
                                    if (responseMessage.error) {
                                        const error = responseMessage.error;
                                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                                    } else if (responseMessage.result !== undefined) {
                                        responsePromise.resolve(responseMessage.result);
                                    } else {
                                        throw new Error('Should never happen.');
                                    }
                                } catch (error) {
                                    if (error.message) {
                                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                                    } else {
                                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                                    }
                                }
                            }
                        }
                    }
                    function handleNotification(message) {
                        if (isDisposed()) {
                            // See handle request.
                            return;
                        }
                        let type = undefined;
                        let notificationHandler;
                        if (message.method === CancelNotification.type.method) {
                            const cancelId = message.params.id;
                            knownCanceledRequests.delete(cancelId);
                            traceReceivedNotification(message);
                            return;
                        } else {
                            const element = notificationHandlers.get(message.method);
                            if (element) {
                                notificationHandler = element.handler;
                                type = element.type;
                            }
                        }
                        if (notificationHandler || starNotificationHandler) {
                            try {
                                traceReceivedNotification(message);
                                if (notificationHandler) {
                                    if (message.params === undefined) {
                                        if (type !== undefined) {
                                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                                            }
                                        }
                                        notificationHandler();
                                    } else if (Array.isArray(message.params)) {
                                        // There are JSON-RPC libraries that send progress message as positional params although
                                        // specified as named. So convert them if this is the case.
                                        const params = message.params;
                                        if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                                            notificationHandler({
                                                token: params[0],
                                                value: params[1]
                                            });
                                        } else {
                                            if (type !== undefined) {
                                                if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                                                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                                                }
                                                if (type.numberOfParams !== message.params.length) {
                                                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                                                }
                                            }
                                            notificationHandler(...params);
                                        }
                                    } else {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                                        }
                                        notificationHandler(message.params);
                                    }
                                } else if (starNotificationHandler) {
                                    starNotificationHandler(message.method, message.params);
                                }
                            } catch (error) {
                                if (error.message) {
                                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
                                } else {
                                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
                                }
                            }
                        } else {
                            unhandledNotificationEmitter.fire(message);
                        }
                    }
                    function handleInvalidMessage(message) {
                        if (!message) {
                            logger.error('Received empty message.');
                            return;
                        }
                        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
                        // Test whether we find an id to reject the promise
                        const responseMessage = message;
                        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
                            const key = responseMessage.id;
                            const responseHandler = responsePromises.get(key);
                            if (responseHandler) {
                                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
                            }
                        }
                    }
                    function stringifyTrace(params) {
                        if (params === undefined || params === null) {
                            return undefined;
                        }
                        switch(trace){
                            case Trace.Verbose:
                                return JSON.stringify(params, null, 4);
                            case Trace.Compact:
                                return JSON.stringify(params);
                            default:
                                return undefined;
                        }
                    }
                    function traceSendingRequest(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                                data = `Params: ${stringifyTrace(message.params)}\n\n`;
                            }
                            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
                        } else {
                            logLSPMessage('send-request', message);
                        }
                    }
                    function traceSendingNotification(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.params) {
                                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                                } else {
                                    data = 'No parameters provided.\n\n';
                                }
                            }
                            tracer.log(`Sending notification '${message.method}'.`, data);
                        } else {
                            logLSPMessage('send-notification', message);
                        }
                    }
                    function traceSendingResponse(message, method, startTime) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.error && message.error.data) {
                                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                                } else {
                                    if (message.result) {
                                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                                    } else if (message.error === undefined) {
                                        data = 'No result returned.\n\n';
                                    }
                                }
                            }
                            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
                        } else {
                            logLSPMessage('send-response', message);
                        }
                    }
                    function traceReceivedRequest(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                                data = `Params: ${stringifyTrace(message.params)}\n\n`;
                            }
                            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
                        } else {
                            logLSPMessage('receive-request', message);
                        }
                    }
                    function traceReceivedNotification(message) {
                        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.params) {
                                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                                } else {
                                    data = 'No parameters provided.\n\n';
                                }
                            }
                            tracer.log(`Received notification '${message.method}'.`, data);
                        } else {
                            logLSPMessage('receive-notification', message);
                        }
                    }
                    function traceReceivedResponse(message, responsePromise) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.error && message.error.data) {
                                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                                } else {
                                    if (message.result) {
                                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                                    } else if (message.error === undefined) {
                                        data = 'No result returned.\n\n';
                                    }
                                }
                            }
                            if (responsePromise) {
                                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
                                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
                            } else {
                                tracer.log(`Received response ${message.id} without active response promise.`, data);
                            }
                        } else {
                            logLSPMessage('receive-response', message);
                        }
                    }
                    function logLSPMessage(type, message) {
                        if (!tracer || trace === Trace.Off) {
                            return;
                        }
                        const lspMessage = {
                            isLSPMessage: true,
                            type,
                            message,
                            timestamp: Date.now()
                        };
                        tracer.log(lspMessage);
                    }
                    function throwIfClosedOrDisposed() {
                        if (isClosed()) {
                            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
                        }
                        if (isDisposed()) {
                            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
                        }
                    }
                    function throwIfListening() {
                        if (isListening()) {
                            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
                        }
                    }
                    function throwIfNotListening() {
                        if (!isListening()) {
                            throw new Error('Call listen() first.');
                        }
                    }
                    function undefinedToNull(param) {
                        if (param === undefined) {
                            return null;
                        } else {
                            return param;
                        }
                    }
                    function nullToUndefined(param) {
                        if (param === null) {
                            return undefined;
                        } else {
                            return param;
                        }
                    }
                    function isNamedParam(param) {
                        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';
                    }
                    function computeSingleParam(parameterStructures, param) {
                        switch(parameterStructures){
                            case messages_1.ParameterStructures.auto:
                                if (isNamedParam(param)) {
                                    return nullToUndefined(param);
                                } else {
                                    return [
                                        undefinedToNull(param)
                                    ];
                                }
                            case messages_1.ParameterStructures.byName:
                                if (!isNamedParam(param)) {
                                    throw new Error(`Received parameters by name but param is not an object literal.`);
                                }
                                return nullToUndefined(param);
                            case messages_1.ParameterStructures.byPosition:
                                return [
                                    undefinedToNull(param)
                                ];
                            default:
                                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
                        }
                    }
                    function computeMessageParams(type, params) {
                        let result;
                        const numberOfParams = type.numberOfParams;
                        switch(numberOfParams){
                            case 0:
                                result = undefined;
                                break;
                            case 1:
                                result = computeSingleParam(type.parameterStructures, params[0]);
                                break;
                            default:
                                result = [];
                                for(let i = 0; i < params.length && i < numberOfParams; i++){
                                    result.push(undefinedToNull(params[i]));
                                }
                                if (params.length < numberOfParams) {
                                    for(let i = params.length; i < numberOfParams; i++){
                                        result.push(null);
                                    }
                                }
                                break;
                        }
                        return result;
                    }
                    const connection = {
                        sendNotification: (type, ...args)=>{
                            throwIfClosedOrDisposed();
                            let method;
                            let messageParams;
                            if (Is.string(type)) {
                                method = type;
                                const first = args[0];
                                let paramStart = 0;
                                let parameterStructures = messages_1.ParameterStructures.auto;
                                if (messages_1.ParameterStructures.is(first)) {
                                    paramStart = 1;
                                    parameterStructures = first;
                                }
                                let paramEnd = args.length;
                                const numberOfParams = paramEnd - paramStart;
                                switch(numberOfParams){
                                    case 0:
                                        messageParams = undefined;
                                        break;
                                    case 1:
                                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                                        break;
                                    default:
                                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                                        }
                                        messageParams = args.slice(paramStart, paramEnd).map((value)=>undefinedToNull(value));
                                        break;
                                }
                            } else {
                                const params = args;
                                method = type.method;
                                messageParams = computeMessageParams(type, params);
                            }
                            const notificationMessage = {
                                jsonrpc: version,
                                method: method,
                                params: messageParams
                            };
                            traceSendingNotification(notificationMessage);
                            return messageWriter.write(notificationMessage).catch((error)=>{
                                logger.error(`Sending notification failed.`);
                                throw error;
                            });
                        },
                        onNotification: (type, handler)=>{
                            throwIfClosedOrDisposed();
                            let method;
                            if (Is.func(type)) {
                                starNotificationHandler = type;
                            } else if (handler) {
                                if (Is.string(type)) {
                                    method = type;
                                    notificationHandlers.set(type, {
                                        type: undefined,
                                        handler
                                    });
                                } else {
                                    method = type.method;
                                    notificationHandlers.set(type.method, {
                                        type,
                                        handler
                                    });
                                }
                            }
                            return {
                                dispose: ()=>{
                                    if (method !== undefined) {
                                        notificationHandlers.delete(method);
                                    } else {
                                        starNotificationHandler = undefined;
                                    }
                                }
                            };
                        },
                        onProgress: (_type, token, handler)=>{
                            if (progressHandlers.has(token)) {
                                throw new Error(`Progress handler for token ${token} already registered`);
                            }
                            progressHandlers.set(token, handler);
                            return {
                                dispose: ()=>{
                                    progressHandlers.delete(token);
                                }
                            };
                        },
                        sendProgress: (_type, token, value)=>{
                            // This should not await but simple return to ensure that we don't have another
                            // async scheduling. Otherwise one send could overtake another send.
                            return connection.sendNotification(ProgressNotification.type, {
                                token,
                                value
                            });
                        },
                        onUnhandledProgress: unhandledProgressEmitter.event,
                        sendRequest: (type, ...args)=>{
                            throwIfClosedOrDisposed();
                            throwIfNotListening();
                            let method;
                            let messageParams;
                            let token = undefined;
                            if (Is.string(type)) {
                                method = type;
                                const first = args[0];
                                const last = args[args.length - 1];
                                let paramStart = 0;
                                let parameterStructures = messages_1.ParameterStructures.auto;
                                if (messages_1.ParameterStructures.is(first)) {
                                    paramStart = 1;
                                    parameterStructures = first;
                                }
                                let paramEnd = args.length;
                                if (cancellation_1.CancellationToken.is(last)) {
                                    paramEnd = paramEnd - 1;
                                    token = last;
                                }
                                const numberOfParams = paramEnd - paramStart;
                                switch(numberOfParams){
                                    case 0:
                                        messageParams = undefined;
                                        break;
                                    case 1:
                                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                                        break;
                                    default:
                                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                                        }
                                        messageParams = args.slice(paramStart, paramEnd).map((value)=>undefinedToNull(value));
                                        break;
                                }
                            } else {
                                const params = args;
                                method = type.method;
                                messageParams = computeMessageParams(type, params);
                                const numberOfParams = type.numberOfParams;
                                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
                            }
                            const id = sequenceNumber++;
                            let disposable;
                            if (token) {
                                disposable = token.onCancellationRequested(()=>{
                                    const p = cancellationStrategy.sender.sendCancellation(connection, id);
                                    if (p === undefined) {
                                        logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                                        return Promise.resolve();
                                    } else {
                                        return p.catch(()=>{
                                            logger.log(`Sending cancellation messages for id ${id} failed`);
                                        });
                                    }
                                });
                            }
                            const requestMessage = {
                                jsonrpc: version,
                                id: id,
                                method: method,
                                params: messageParams
                            };
                            traceSendingRequest(requestMessage);
                            if (typeof cancellationStrategy.sender.enableCancellation === 'function') {
                                cancellationStrategy.sender.enableCancellation(requestMessage);
                            }
                            return new Promise(async (resolve, reject)=>{
                                const resolveWithCleanup = (r)=>{
                                    var _disposable;
                                    resolve(r);
                                    cancellationStrategy.sender.cleanup(id);
                                    (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable.dispose();
                                };
                                const rejectWithCleanup = (r)=>{
                                    var _disposable;
                                    reject(r);
                                    cancellationStrategy.sender.cleanup(id);
                                    (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable.dispose();
                                };
                                const responsePromise = {
                                    method: method,
                                    timerStart: Date.now(),
                                    resolve: resolveWithCleanup,
                                    reject: rejectWithCleanup
                                };
                                try {
                                    await messageWriter.write(requestMessage);
                                    responsePromises.set(id, responsePromise);
                                } catch (error) {
                                    logger.error(`Sending request failed.`);
                                    // Writing the message failed. So we need to reject the promise.
                                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : 'Unknown reason'));
                                    throw error;
                                }
                            });
                        },
                        onRequest: (type, handler)=>{
                            throwIfClosedOrDisposed();
                            let method = null;
                            if (StarRequestHandler.is(type)) {
                                method = undefined;
                                starRequestHandler = type;
                            } else if (Is.string(type)) {
                                method = null;
                                if (handler !== undefined) {
                                    method = type;
                                    requestHandlers.set(type, {
                                        handler: handler,
                                        type: undefined
                                    });
                                }
                            } else {
                                if (handler !== undefined) {
                                    method = type.method;
                                    requestHandlers.set(type.method, {
                                        type,
                                        handler
                                    });
                                }
                            }
                            return {
                                dispose: ()=>{
                                    if (method === null) {
                                        return;
                                    }
                                    if (method !== undefined) {
                                        requestHandlers.delete(method);
                                    } else {
                                        starRequestHandler = undefined;
                                    }
                                }
                            };
                        },
                        hasPendingResponse: ()=>{
                            return responsePromises.size > 0;
                        },
                        trace: async (_value, _tracer, sendNotificationOrTraceOptions)=>{
                            let _sendNotification = false;
                            let _traceFormat = TraceFormat.Text;
                            if (sendNotificationOrTraceOptions !== undefined) {
                                if (Is.boolean(sendNotificationOrTraceOptions)) {
                                    _sendNotification = sendNotificationOrTraceOptions;
                                } else {
                                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                                }
                            }
                            trace = _value;
                            traceFormat = _traceFormat;
                            if (trace === Trace.Off) {
                                tracer = undefined;
                            } else {
                                tracer = _tracer;
                            }
                            if (_sendNotification && !isClosed() && !isDisposed()) {
                                await connection.sendNotification(SetTraceNotification.type, {
                                    value: Trace.toString(_value)
                                });
                            }
                        },
                        onError: errorEmitter.event,
                        onClose: closeEmitter.event,
                        onUnhandledNotification: unhandledNotificationEmitter.event,
                        onDispose: disposeEmitter.event,
                        end: ()=>{
                            messageWriter.end();
                        },
                        dispose: ()=>{
                            if (isDisposed()) {
                                return;
                            }
                            state = ConnectionState.Disposed;
                            disposeEmitter.fire(undefined);
                            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, 'Pending response rejected since connection got disposed');
                            for (const promise of responsePromises.values()){
                                promise.reject(error);
                            }
                            responsePromises = new Map();
                            requestTokens = new Map();
                            knownCanceledRequests = new Set();
                            messageQueue = new linkedMap_1.LinkedMap();
                            // Test for backwards compatibility
                            if (Is.func(messageWriter.dispose)) {
                                messageWriter.dispose();
                            }
                            if (Is.func(messageReader.dispose)) {
                                messageReader.dispose();
                            }
                        },
                        listen: ()=>{
                            throwIfClosedOrDisposed();
                            throwIfListening();
                            state = ConnectionState.Listening;
                            messageReader.listen(callback);
                        },
                        inspect: ()=>{
                            // eslint-disable-next-line no-console
                            (0, ral_1.default)().console.log('inspect');
                        }
                    };
                    connection.onNotification(LogTraceNotification.type, (params)=>{
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
                        tracer.log(params.message, verbose ? params.verbose : undefined);
                    });
                    connection.onNotification(ProgressNotification.type, (params)=>{
                        const handler = progressHandlers.get(params.token);
                        if (handler) {
                            handler(params.value);
                        } else {
                            unhandledProgressEmitter.fire(params);
                        }
                    });
                    return connection;
                }
                exports1.createMessageConnection = createMessageConnection;
            /***/ },
            /***/ 8437: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Disposable = void 0;
                var Disposable;
                (function(Disposable) {
                    function create(func) {
                        return {
                            dispose: func
                        };
                    }
                    Disposable.create = create;
                })(Disposable = exports1.Disposable || (exports1.Disposable = {}));
            /***/ },
            /***/ 5165: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_348529__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Emitter = exports1.Event = void 0;
                const ral_1 = __nested_webpack_require_348529__(5706);
                var Event1;
                (function(Event1) {
                    const _disposable = {
                        dispose () {}
                    };
                    Event1.None = function() {
                        return _disposable;
                    };
                })(Event1 = exports1.Event || (exports1.Event = {}));
                class CallbackList {
                    add(callback, context = null, bucket) {
                        if (!this._callbacks) {
                            this._callbacks = [];
                            this._contexts = [];
                        }
                        this._callbacks.push(callback);
                        this._contexts.push(context);
                        if (Array.isArray(bucket)) {
                            bucket.push({
                                dispose: ()=>this.remove(callback, context)
                            });
                        }
                    }
                    remove(callback, context = null) {
                        if (!this._callbacks) {
                            return;
                        }
                        let foundCallbackWithDifferentContext = false;
                        for(let i = 0, len = this._callbacks.length; i < len; i++){
                            if (this._callbacks[i] === callback) {
                                if (this._contexts[i] === context) {
                                    // callback & context match => remove it
                                    this._callbacks.splice(i, 1);
                                    this._contexts.splice(i, 1);
                                    return;
                                } else {
                                    foundCallbackWithDifferentContext = true;
                                }
                            }
                        }
                        if (foundCallbackWithDifferentContext) {
                            throw new Error('When adding a listener with a context, you should remove it with the same context');
                        }
                    }
                    invoke(...args) {
                        if (!this._callbacks) {
                            return [];
                        }
                        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
                        for(let i = 0, len = callbacks.length; i < len; i++){
                            try {
                                ret.push(callbacks[i].apply(contexts[i], args));
                            } catch (e) {
                                // eslint-disable-next-line no-console
                                (0, ral_1.default)().console.error(e);
                            }
                        }
                        return ret;
                    }
                    isEmpty() {
                        return !this._callbacks || this._callbacks.length === 0;
                    }
                    dispose() {
                        this._callbacks = undefined;
                        this._contexts = undefined;
                    }
                }
                class Emitter {
                    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */ get event() {
                        if (!this._event) {
                            this._event = (listener, thisArgs, disposables)=>{
                                if (!this._callbacks) {
                                    this._callbacks = new CallbackList();
                                }
                                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                                    this._options.onFirstListenerAdd(this);
                                }
                                this._callbacks.add(listener, thisArgs);
                                const result = {
                                    dispose: ()=>{
                                        if (!this._callbacks) {
                                            // disposable is disposed after emitter is disposed.
                                            return;
                                        }
                                        this._callbacks.remove(listener, thisArgs);
                                        result.dispose = Emitter._noop;
                                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                                            this._options.onLastListenerRemove(this);
                                        }
                                    }
                                };
                                if (Array.isArray(disposables)) {
                                    disposables.push(result);
                                }
                                return result;
                            };
                        }
                        return this._event;
                    }
                    /**
     * To be kept private to fire an event to
     * subscribers
     */ fire(event) {
                        if (this._callbacks) {
                            this._callbacks.invoke.call(this._callbacks, event);
                        }
                    }
                    dispose() {
                        if (this._callbacks) {
                            this._callbacks.dispose();
                            this._callbacks = undefined;
                        }
                    }
                    constructor(_options){
                        this._options = _options;
                    }
                }
                exports1.Emitter = Emitter;
                Emitter._noop = function() {};
            /***/ },
            /***/ 8811: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.stringArray = exports1.array = exports1.func = exports1.error = exports1.number = exports1.string = exports1.boolean = void 0;
                function boolean(value) {
                    return value === true || value === false;
                }
                exports1.boolean = boolean;
                function string(value) {
                    return typeof value === 'string' || value instanceof String;
                }
                exports1.string = string;
                function number(value) {
                    return typeof value === 'number' || value instanceof Number;
                }
                exports1.number = number;
                function error(value) {
                    return value instanceof Error;
                }
                exports1.error = error;
                function func(value) {
                    return typeof value === 'function';
                }
                exports1.func = func;
                function array(value) {
                    return Array.isArray(value);
                }
                exports1.array = array;
                function stringArray(value) {
                    return array(value) && value.every((elem)=>string(elem));
                }
                exports1.stringArray = stringArray;
            /***/ },
            /***/ 7040: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ var _a;
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LRUCache = exports1.LinkedMap = exports1.Touch = void 0;
                var Touch;
                (function(Touch) {
                    Touch.None = 0;
                    Touch.First = 1;
                    Touch.AsOld = Touch.First;
                    Touch.Last = 2;
                    Touch.AsNew = Touch.Last;
                })(Touch = exports1.Touch || (exports1.Touch = {}));
                class LinkedMap {
                    clear() {
                        this._map.clear();
                        this._head = undefined;
                        this._tail = undefined;
                        this._size = 0;
                        this._state++;
                    }
                    isEmpty() {
                        return !this._head && !this._tail;
                    }
                    get size() {
                        return this._size;
                    }
                    get first() {
                        var _this__head;
                        return (_this__head = this._head) === null || _this__head === void 0 ? void 0 : _this__head.value;
                    }
                    get last() {
                        var _this__tail;
                        return (_this__tail = this._tail) === null || _this__tail === void 0 ? void 0 : _this__tail.value;
                    }
                    has(key) {
                        return this._map.has(key);
                    }
                    get(key, touch = Touch.None) {
                        const item = this._map.get(key);
                        if (!item) {
                            return undefined;
                        }
                        if (touch !== Touch.None) {
                            this.touch(item, touch);
                        }
                        return item.value;
                    }
                    set(key, value, touch = Touch.None) {
                        let item = this._map.get(key);
                        if (item) {
                            item.value = value;
                            if (touch !== Touch.None) {
                                this.touch(item, touch);
                            }
                        } else {
                            item = {
                                key,
                                value,
                                next: undefined,
                                previous: undefined
                            };
                            switch(touch){
                                case Touch.None:
                                    this.addItemLast(item);
                                    break;
                                case Touch.First:
                                    this.addItemFirst(item);
                                    break;
                                case Touch.Last:
                                    this.addItemLast(item);
                                    break;
                                default:
                                    this.addItemLast(item);
                                    break;
                            }
                            this._map.set(key, item);
                            this._size++;
                        }
                        return this;
                    }
                    delete(key) {
                        return !!this.remove(key);
                    }
                    remove(key) {
                        const item = this._map.get(key);
                        if (!item) {
                            return undefined;
                        }
                        this._map.delete(key);
                        this.removeItem(item);
                        this._size--;
                        return item.value;
                    }
                    shift() {
                        if (!this._head && !this._tail) {
                            return undefined;
                        }
                        if (!this._head || !this._tail) {
                            throw new Error('Invalid list');
                        }
                        const item = this._head;
                        this._map.delete(item.key);
                        this.removeItem(item);
                        this._size--;
                        return item.value;
                    }
                    forEach(callbackfn, thisArg) {
                        const state = this._state;
                        let current = this._head;
                        while(current){
                            if (thisArg) {
                                callbackfn.bind(thisArg)(current.value, current.key, this);
                            } else {
                                callbackfn(current.value, current.key, this);
                            }
                            if (this._state !== state) {
                                throw new Error(`LinkedMap got modified during iteration.`);
                            }
                            current = current.next;
                        }
                    }
                    keys() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: current.key,
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    values() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: current.value,
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    entries() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: [
                                            current.key,
                                            current.value
                                        ],
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
                        return this.entries();
                    }
                    trimOld(newSize) {
                        if (newSize >= this.size) {
                            return;
                        }
                        if (newSize === 0) {
                            this.clear();
                            return;
                        }
                        let current = this._head;
                        let currentSize = this.size;
                        while(current && currentSize > newSize){
                            this._map.delete(current.key);
                            current = current.next;
                            currentSize--;
                        }
                        this._head = current;
                        this._size = currentSize;
                        if (current) {
                            current.previous = undefined;
                        }
                        this._state++;
                    }
                    addItemFirst(item) {
                        // First time Insert
                        if (!this._head && !this._tail) {
                            this._tail = item;
                        } else if (!this._head) {
                            throw new Error('Invalid list');
                        } else {
                            item.next = this._head;
                            this._head.previous = item;
                        }
                        this._head = item;
                        this._state++;
                    }
                    addItemLast(item) {
                        // First time Insert
                        if (!this._head && !this._tail) {
                            this._head = item;
                        } else if (!this._tail) {
                            throw new Error('Invalid list');
                        } else {
                            item.previous = this._tail;
                            this._tail.next = item;
                        }
                        this._tail = item;
                        this._state++;
                    }
                    removeItem(item) {
                        if (item === this._head && item === this._tail) {
                            this._head = undefined;
                            this._tail = undefined;
                        } else if (item === this._head) {
                            // This can only happened if size === 1 which is handle
                            // by the case above.
                            if (!item.next) {
                                throw new Error('Invalid list');
                            }
                            item.next.previous = undefined;
                            this._head = item.next;
                        } else if (item === this._tail) {
                            // This can only happened if size === 1 which is handle
                            // by the case above.
                            if (!item.previous) {
                                throw new Error('Invalid list');
                            }
                            item.previous.next = undefined;
                            this._tail = item.previous;
                        } else {
                            const next = item.next;
                            const previous = item.previous;
                            if (!next || !previous) {
                                throw new Error('Invalid list');
                            }
                            next.previous = previous;
                            previous.next = next;
                        }
                        item.next = undefined;
                        item.previous = undefined;
                        this._state++;
                    }
                    touch(item, touch) {
                        if (!this._head || !this._tail) {
                            throw new Error('Invalid list');
                        }
                        if (touch !== Touch.First && touch !== Touch.Last) {
                            return;
                        }
                        if (touch === Touch.First) {
                            if (item === this._head) {
                                return;
                            }
                            const next = item.next;
                            const previous = item.previous;
                            // Unlink the item
                            if (item === this._tail) {
                                // previous must be defined since item was not head but is tail
                                // So there are more than on item in the map
                                previous.next = undefined;
                                this._tail = previous;
                            } else {
                                // Both next and previous are not undefined since item was neither head nor tail.
                                next.previous = previous;
                                previous.next = next;
                            }
                            // Insert the node at head
                            item.previous = undefined;
                            item.next = this._head;
                            this._head.previous = item;
                            this._head = item;
                            this._state++;
                        } else if (touch === Touch.Last) {
                            if (item === this._tail) {
                                return;
                            }
                            const next = item.next;
                            const previous = item.previous;
                            // Unlink the item.
                            if (item === this._head) {
                                // next must be defined since item was not tail but is head
                                // So there are more than on item in the map
                                next.previous = undefined;
                                this._head = next;
                            } else {
                                // Both next and previous are not undefined since item was neither head nor tail.
                                next.previous = previous;
                                previous.next = next;
                            }
                            item.next = undefined;
                            item.previous = this._tail;
                            this._tail.next = item;
                            this._tail = item;
                            this._state++;
                        }
                    }
                    toJSON() {
                        const data = [];
                        this.forEach((value, key)=>{
                            data.push([
                                key,
                                value
                            ]);
                        });
                        return data;
                    }
                    fromJSON(data) {
                        this.clear();
                        for (const [key, value] of data){
                            this.set(key, value);
                        }
                    }
                    constructor(){
                        this[_a] = 'LinkedMap';
                        this._map = new Map();
                        this._head = undefined;
                        this._tail = undefined;
                        this._size = 0;
                        this._state = 0;
                    }
                }
                exports1.LinkedMap = LinkedMap;
                class LRUCache extends LinkedMap {
                    get limit() {
                        return this._limit;
                    }
                    set limit(limit) {
                        this._limit = limit;
                        this.checkTrim();
                    }
                    get ratio() {
                        return this._ratio;
                    }
                    set ratio(ratio) {
                        this._ratio = Math.min(Math.max(0, ratio), 1);
                        this.checkTrim();
                    }
                    get(key, touch = Touch.AsNew) {
                        return super.get(key, touch);
                    }
                    peek(key) {
                        return super.get(key, Touch.None);
                    }
                    set(key, value) {
                        super.set(key, value, Touch.Last);
                        this.checkTrim();
                        return this;
                    }
                    checkTrim() {
                        if (this.size > this._limit) {
                            this.trimOld(Math.round(this._limit * this._ratio));
                        }
                    }
                    constructor(limit, ratio = 1){
                        super();
                        this._limit = limit;
                        this._ratio = Math.min(Math.max(0, ratio), 1);
                    }
                }
                exports1.LRUCache = LRUCache;
            /***/ },
            /***/ 8652: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.AbstractMessageBuffer = void 0;
                const CR = 13;
                const LF = 10;
                const CRLF = '\r\n';
                class AbstractMessageBuffer {
                    get encoding() {
                        return this._encoding;
                    }
                    append(chunk) {
                        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;
                        this._chunks.push(toAppend);
                        this._totalLength += toAppend.byteLength;
                    }
                    tryReadHeaders(lowerCaseKeys = false) {
                        if (this._chunks.length === 0) {
                            return undefined;
                        }
                        let state = 0;
                        let chunkIndex = 0;
                        let offset = 0;
                        let chunkBytesRead = 0;
                        row: while(chunkIndex < this._chunks.length){
                            const chunk = this._chunks[chunkIndex];
                            offset = 0;
                            column: while(offset < chunk.length){
                                const value = chunk[offset];
                                switch(value){
                                    case CR:
                                        switch(state){
                                            case 0:
                                                state = 1;
                                                break;
                                            case 2:
                                                state = 3;
                                                break;
                                            default:
                                                state = 0;
                                        }
                                        break;
                                    case LF:
                                        switch(state){
                                            case 1:
                                                state = 2;
                                                break;
                                            case 3:
                                                state = 4;
                                                offset++;
                                                break row;
                                            default:
                                                state = 0;
                                        }
                                        break;
                                    default:
                                        state = 0;
                                }
                                offset++;
                            }
                            chunkBytesRead += chunk.byteLength;
                            chunkIndex++;
                        }
                        if (state !== 4) {
                            return undefined;
                        }
                        // The buffer contains the two CRLF at the end. So we will
                        // have two empty lines after the split at the end as well.
                        const buffer = this._read(chunkBytesRead + offset);
                        const result = new Map();
                        const headers = this.toString(buffer, 'ascii').split(CRLF);
                        if (headers.length < 2) {
                            return result;
                        }
                        for(let i = 0; i < headers.length - 2; i++){
                            const header = headers[i];
                            const index = header.indexOf(':');
                            if (index === -1) {
                                throw new Error('Message header must separate key and value using :');
                            }
                            const key = header.substr(0, index);
                            const value = header.substr(index + 1).trim();
                            result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
                        }
                        return result;
                    }
                    tryReadBody(length) {
                        if (this._totalLength < length) {
                            return undefined;
                        }
                        return this._read(length);
                    }
                    get numberOfBytes() {
                        return this._totalLength;
                    }
                    _read(byteCount) {
                        if (byteCount === 0) {
                            return this.emptyBuffer();
                        }
                        if (byteCount > this._totalLength) {
                            throw new Error(`Cannot read so many bytes!`);
                        }
                        if (this._chunks[0].byteLength === byteCount) {
                            // super fast path, precisely first chunk must be returned
                            const chunk = this._chunks[0];
                            this._chunks.shift();
                            this._totalLength -= byteCount;
                            return this.asNative(chunk);
                        }
                        if (this._chunks[0].byteLength > byteCount) {
                            // fast path, the reading is entirely within the first chunk
                            const chunk = this._chunks[0];
                            const result = this.asNative(chunk, byteCount);
                            this._chunks[0] = chunk.slice(byteCount);
                            this._totalLength -= byteCount;
                            return result;
                        }
                        const result = this.allocNative(byteCount);
                        let resultOffset = 0;
                        let chunkIndex = 0;
                        while(byteCount > 0){
                            const chunk = this._chunks[chunkIndex];
                            if (chunk.byteLength > byteCount) {
                                // this chunk will survive
                                const chunkPart = chunk.slice(0, byteCount);
                                result.set(chunkPart, resultOffset);
                                resultOffset += byteCount;
                                this._chunks[chunkIndex] = chunk.slice(byteCount);
                                this._totalLength -= byteCount;
                                byteCount -= byteCount;
                            } else {
                                // this chunk will be entirely read
                                result.set(chunk, resultOffset);
                                resultOffset += chunk.byteLength;
                                this._chunks.shift();
                                this._totalLength -= chunk.byteLength;
                                byteCount -= chunk.byteLength;
                            }
                        }
                        return result;
                    }
                    constructor(encoding = 'utf-8'){
                        this._encoding = encoding;
                        this._chunks = [];
                        this._totalLength = 0;
                    }
                }
                exports1.AbstractMessageBuffer = AbstractMessageBuffer;
            /***/ },
            /***/ 451: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_384225__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ReadableStreamMessageReader = exports1.AbstractMessageReader = exports1.MessageReader = void 0;
                const ral_1 = __nested_webpack_require_384225__(5706);
                const Is = __nested_webpack_require_384225__(8811);
                const events_1 = __nested_webpack_require_384225__(5165);
                const semaphore_1 = __nested_webpack_require_384225__(2339);
                var MessageReader;
                (function(MessageReader) {
                    function is(value) {
                        let candidate = value;
                        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
                    }
                    MessageReader.is = is;
                })(MessageReader = exports1.MessageReader || (exports1.MessageReader = {}));
                class AbstractMessageReader {
                    dispose() {
                        this.errorEmitter.dispose();
                        this.closeEmitter.dispose();
                    }
                    get onError() {
                        return this.errorEmitter.event;
                    }
                    fireError(error) {
                        this.errorEmitter.fire(this.asError(error));
                    }
                    get onClose() {
                        return this.closeEmitter.event;
                    }
                    fireClose() {
                        this.closeEmitter.fire(undefined);
                    }
                    get onPartialMessage() {
                        return this.partialMessageEmitter.event;
                    }
                    firePartialMessage(info) {
                        this.partialMessageEmitter.fire(info);
                    }
                    asError(error) {
                        if (error instanceof Error) {
                            return error;
                        } else {
                            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
                        }
                    }
                    constructor(){
                        this.errorEmitter = new events_1.Emitter();
                        this.closeEmitter = new events_1.Emitter();
                        this.partialMessageEmitter = new events_1.Emitter();
                    }
                }
                exports1.AbstractMessageReader = AbstractMessageReader;
                var ResolvedMessageReaderOptions;
                (function(ResolvedMessageReaderOptions) {
                    function fromOptions(options) {
                        let charset;
                        let result;
                        let contentDecoder;
                        const contentDecoders = new Map();
                        let contentTypeDecoder;
                        const contentTypeDecoders = new Map();
                        if (options === undefined || typeof options === 'string') {
                            charset = options !== null && options !== void 0 ? options : 'utf-8';
                        } else {
                            var _options_charset;
                            charset = (_options_charset = options.charset) !== null && _options_charset !== void 0 ? _options_charset : 'utf-8';
                            if (options.contentDecoder !== undefined) {
                                contentDecoder = options.contentDecoder;
                                contentDecoders.set(contentDecoder.name, contentDecoder);
                            }
                            if (options.contentDecoders !== undefined) {
                                for (const decoder of options.contentDecoders){
                                    contentDecoders.set(decoder.name, decoder);
                                }
                            }
                            if (options.contentTypeDecoder !== undefined) {
                                contentTypeDecoder = options.contentTypeDecoder;
                                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
                            }
                            if (options.contentTypeDecoders !== undefined) {
                                for (const decoder of options.contentTypeDecoders){
                                    contentTypeDecoders.set(decoder.name, decoder);
                                }
                            }
                        }
                        if (contentTypeDecoder === undefined) {
                            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
                            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
                        }
                        return {
                            charset,
                            contentDecoder,
                            contentDecoders,
                            contentTypeDecoder,
                            contentTypeDecoders
                        };
                    }
                    ResolvedMessageReaderOptions.fromOptions = fromOptions;
                })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
                class ReadableStreamMessageReader extends AbstractMessageReader {
                    set partialMessageTimeout(timeout) {
                        this._partialMessageTimeout = timeout;
                    }
                    get partialMessageTimeout() {
                        return this._partialMessageTimeout;
                    }
                    listen(callback) {
                        this.nextMessageLength = -1;
                        this.messageToken = 0;
                        this.partialMessageTimer = undefined;
                        this.callback = callback;
                        const result = this.readable.onData((data)=>{
                            this.onData(data);
                        });
                        this.readable.onError((error)=>this.fireError(error));
                        this.readable.onClose(()=>this.fireClose());
                        return result;
                    }
                    onData(data) {
                        this.buffer.append(data);
                        while(true){
                            if (this.nextMessageLength === -1) {
                                const headers = this.buffer.tryReadHeaders(true);
                                if (!headers) {
                                    return;
                                }
                                const contentLength = headers.get('content-length');
                                if (!contentLength) {
                                    this.fireError(new Error('Header must provide a Content-Length property.'));
                                    return;
                                }
                                const length = parseInt(contentLength);
                                if (isNaN(length)) {
                                    this.fireError(new Error('Content-Length value must be a number.'));
                                    return;
                                }
                                this.nextMessageLength = length;
                            }
                            const body = this.buffer.tryReadBody(this.nextMessageLength);
                            if (body === undefined) {
                                /** We haven't received the full message yet. */ this.setPartialMessageTimer();
                                return;
                            }
                            this.clearPartialMessageTimer();
                            this.nextMessageLength = -1;
                            // Make sure that we convert one received message after the
                            // other. Otherwise it could happen that a decoding of a second
                            // smaller message finished before the decoding of a first larger
                            // message and then we would deliver the second message first.
                            this.readSemaphore.lock(async ()=>{
                                const bytes = this.options.contentDecoder !== undefined ? await this.options.contentDecoder.decode(body) : body;
                                const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
                                this.callback(message);
                            }).catch((error)=>{
                                this.fireError(error);
                            });
                        }
                    }
                    clearPartialMessageTimer() {
                        if (this.partialMessageTimer) {
                            this.partialMessageTimer.dispose();
                            this.partialMessageTimer = undefined;
                        }
                    }
                    setPartialMessageTimer() {
                        this.clearPartialMessageTimer();
                        if (this._partialMessageTimeout <= 0) {
                            return;
                        }
                        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout)=>{
                            this.partialMessageTimer = undefined;
                            if (token === this.messageToken) {
                                this.firePartialMessage({
                                    messageToken: token,
                                    waitingTime: timeout
                                });
                                this.setPartialMessageTimer();
                            }
                        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
                    }
                    constructor(readable, options){
                        super();
                        this.readable = readable;
                        this.options = ResolvedMessageReaderOptions.fromOptions(options);
                        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
                        this._partialMessageTimeout = 10000;
                        this.nextMessageLength = -1;
                        this.messageToken = 0;
                        this.readSemaphore = new semaphore_1.Semaphore(1);
                    }
                }
                exports1.ReadableStreamMessageReader = ReadableStreamMessageReader;
            /***/ },
            /***/ 1251: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_395487__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WriteableStreamMessageWriter = exports1.AbstractMessageWriter = exports1.MessageWriter = void 0;
                const ral_1 = __nested_webpack_require_395487__(5706);
                const Is = __nested_webpack_require_395487__(8811);
                const semaphore_1 = __nested_webpack_require_395487__(2339);
                const events_1 = __nested_webpack_require_395487__(5165);
                const ContentLength = 'Content-Length: ';
                const CRLF = '\r\n';
                var MessageWriter;
                (function(MessageWriter) {
                    function is(value) {
                        let candidate = value;
                        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
                    }
                    MessageWriter.is = is;
                })(MessageWriter = exports1.MessageWriter || (exports1.MessageWriter = {}));
                class AbstractMessageWriter {
                    dispose() {
                        this.errorEmitter.dispose();
                        this.closeEmitter.dispose();
                    }
                    get onError() {
                        return this.errorEmitter.event;
                    }
                    fireError(error, message, count) {
                        this.errorEmitter.fire([
                            this.asError(error),
                            message,
                            count
                        ]);
                    }
                    get onClose() {
                        return this.closeEmitter.event;
                    }
                    fireClose() {
                        this.closeEmitter.fire(undefined);
                    }
                    asError(error) {
                        if (error instanceof Error) {
                            return error;
                        } else {
                            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
                        }
                    }
                    constructor(){
                        this.errorEmitter = new events_1.Emitter();
                        this.closeEmitter = new events_1.Emitter();
                    }
                }
                exports1.AbstractMessageWriter = AbstractMessageWriter;
                var ResolvedMessageWriterOptions;
                (function(ResolvedMessageWriterOptions) {
                    function fromOptions(options) {
                        if (options === undefined || typeof options === 'string') {
                            return {
                                charset: options !== null && options !== void 0 ? options : 'utf-8',
                                contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder
                            };
                        } else {
                            var _options_charset, _options_contentTypeEncoder;
                            return {
                                charset: (_options_charset = options.charset) !== null && _options_charset !== void 0 ? _options_charset : 'utf-8',
                                contentEncoder: options.contentEncoder,
                                contentTypeEncoder: (_options_contentTypeEncoder = options.contentTypeEncoder) !== null && _options_contentTypeEncoder !== void 0 ? _options_contentTypeEncoder : (0, ral_1.default)().applicationJson.encoder
                            };
                        }
                    }
                    ResolvedMessageWriterOptions.fromOptions = fromOptions;
                })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
                class WriteableStreamMessageWriter extends AbstractMessageWriter {
                    async write(msg) {
                        return this.writeSemaphore.lock(async ()=>{
                            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer)=>{
                                if (this.options.contentEncoder !== undefined) {
                                    return this.options.contentEncoder.encode(buffer);
                                } else {
                                    return buffer;
                                }
                            });
                            return payload.then((buffer)=>{
                                const headers = [];
                                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
                                headers.push(CRLF);
                                return this.doWrite(msg, headers, buffer);
                            }, (error)=>{
                                this.fireError(error);
                                throw error;
                            });
                        });
                    }
                    async doWrite(msg, headers, data) {
                        try {
                            await this.writable.write(headers.join(''), 'ascii');
                            return this.writable.write(data);
                        } catch (error) {
                            this.handleError(error, msg);
                            return Promise.reject(error);
                        }
                    }
                    handleError(error, msg) {
                        this.errorCount++;
                        this.fireError(error, msg, this.errorCount);
                    }
                    end() {
                        this.writable.end();
                    }
                    constructor(writable, options){
                        super();
                        this.writable = writable;
                        this.options = ResolvedMessageWriterOptions.fromOptions(options);
                        this.errorCount = 0;
                        this.writeSemaphore = new semaphore_1.Semaphore(1);
                        this.writable.onError((error)=>this.fireError(error));
                        this.writable.onClose(()=>this.fireClose());
                    }
                }
                exports1.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
            /***/ },
            /***/ 9141: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_402373__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Message = exports1.NotificationType9 = exports1.NotificationType8 = exports1.NotificationType7 = exports1.NotificationType6 = exports1.NotificationType5 = exports1.NotificationType4 = exports1.NotificationType3 = exports1.NotificationType2 = exports1.NotificationType1 = exports1.NotificationType0 = exports1.NotificationType = exports1.RequestType9 = exports1.RequestType8 = exports1.RequestType7 = exports1.RequestType6 = exports1.RequestType5 = exports1.RequestType4 = exports1.RequestType3 = exports1.RequestType2 = exports1.RequestType1 = exports1.RequestType = exports1.RequestType0 = exports1.AbstractMessageSignature = exports1.ParameterStructures = exports1.ResponseError = exports1.ErrorCodes = void 0;
                const is = __nested_webpack_require_402373__(8811);
                /**
 * Predefined error codes.
 */ var ErrorCodes;
                (function(ErrorCodes) {
                    // Defined by JSON RPC
                    ErrorCodes.ParseError = -32700;
                    ErrorCodes.InvalidRequest = -32600;
                    ErrorCodes.MethodNotFound = -32601;
                    ErrorCodes.InvalidParams = -32602;
                    ErrorCodes.InternalError = -32603;
                    /**
     * This is the start range of JSON RPC reserved error codes.
     * It doesn't denote a real error code. No application error codes should
     * be defined between the start and end range. For backwards
     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
     * are left in the range.
     *
     * @since 3.16.0
    */ ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;
                    /** @deprecated use  jsonrpcReservedErrorRangeStart */ ErrorCodes.serverErrorStart = -32099;
                    /**
     * An error occurred when write a message to the transport layer.
     */ ErrorCodes.MessageWriteError = -32099;
                    /**
     * An error occurred when reading a message from the transport layer.
     */ ErrorCodes.MessageReadError = -32098;
                    /**
     * The connection got disposed or lost and all pending responses got
     * rejected.
     */ ErrorCodes.PendingResponseRejected = -32097;
                    /**
     * The connection is inactive and a use of it failed.
     */ ErrorCodes.ConnectionInactive = -32096;
                    /**
     * Error code indicating that a server received a notification or
     * request before the server has received the `initialize` request.
     */ ErrorCodes.ServerNotInitialized = -32002;
                    ErrorCodes.UnknownErrorCode = -32001;
                    /**
     * This is the end range of JSON RPC reserved error codes.
     * It doesn't denote a real error code.
     *
     * @since 3.16.0
    */ ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;
                    /** @deprecated use  jsonrpcReservedErrorRangeEnd */ ErrorCodes.serverErrorEnd = -32000;
                })(ErrorCodes = exports1.ErrorCodes || (exports1.ErrorCodes = {}));
                /**
 * An error object return in a response in case a request
 * has failed.
 */ class ResponseError extends Error {
                    toJson() {
                        const result = {
                            code: this.code,
                            message: this.message
                        };
                        if (this.data !== undefined) {
                            result.data = this.data;
                        }
                        return result;
                    }
                    constructor(code, message, data){
                        super(message);
                        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
                        this.data = data;
                        Object.setPrototypeOf(this, ResponseError.prototype);
                    }
                }
                exports1.ResponseError = ResponseError;
                class ParameterStructures {
                    static is(value) {
                        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
                    }
                    toString() {
                        return this.kind;
                    }
                    constructor(kind){
                        this.kind = kind;
                    }
                }
                exports1.ParameterStructures = ParameterStructures;
                /**
 * The parameter structure is automatically inferred on the number of parameters
 * and the parameter type in case of a single param.
 */ ParameterStructures.auto = new ParameterStructures('auto');
                /**
 * Forces `byPosition` parameter structure. This is useful if you have a single
 * parameter which has a literal type.
 */ ParameterStructures.byPosition = new ParameterStructures('byPosition');
                /**
 * Forces `byName` parameter structure. This is only useful when having a single
 * parameter. The library will report errors if used with a different number of
 * parameters.
 */ ParameterStructures.byName = new ParameterStructures('byName');
                /**
 * An abstract implementation of a MessageType.
 */ class AbstractMessageSignature {
                    get parameterStructures() {
                        return ParameterStructures.auto;
                    }
                    constructor(method, numberOfParams){
                        this.method = method;
                        this.numberOfParams = numberOfParams;
                    }
                }
                exports1.AbstractMessageSignature = AbstractMessageSignature;
                /**
 * Classes to type request response pairs
 */ class RequestType0 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 0);
                    }
                }
                exports1.RequestType0 = RequestType0;
                class RequestType extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.RequestType = RequestType;
                class RequestType1 extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.RequestType1 = RequestType1;
                class RequestType2 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 2);
                    }
                }
                exports1.RequestType2 = RequestType2;
                class RequestType3 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 3);
                    }
                }
                exports1.RequestType3 = RequestType3;
                class RequestType4 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 4);
                    }
                }
                exports1.RequestType4 = RequestType4;
                class RequestType5 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 5);
                    }
                }
                exports1.RequestType5 = RequestType5;
                class RequestType6 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 6);
                    }
                }
                exports1.RequestType6 = RequestType6;
                class RequestType7 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 7);
                    }
                }
                exports1.RequestType7 = RequestType7;
                class RequestType8 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 8);
                    }
                }
                exports1.RequestType8 = RequestType8;
                class RequestType9 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 9);
                    }
                }
                exports1.RequestType9 = RequestType9;
                class NotificationType extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.NotificationType = NotificationType;
                class NotificationType0 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 0);
                    }
                }
                exports1.NotificationType0 = NotificationType0;
                class NotificationType1 extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.NotificationType1 = NotificationType1;
                class NotificationType2 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 2);
                    }
                }
                exports1.NotificationType2 = NotificationType2;
                class NotificationType3 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 3);
                    }
                }
                exports1.NotificationType3 = NotificationType3;
                class NotificationType4 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 4);
                    }
                }
                exports1.NotificationType4 = NotificationType4;
                class NotificationType5 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 5);
                    }
                }
                exports1.NotificationType5 = NotificationType5;
                class NotificationType6 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 6);
                    }
                }
                exports1.NotificationType6 = NotificationType6;
                class NotificationType7 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 7);
                    }
                }
                exports1.NotificationType7 = NotificationType7;
                class NotificationType8 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 8);
                    }
                }
                exports1.NotificationType8 = NotificationType8;
                class NotificationType9 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 9);
                    }
                }
                exports1.NotificationType9 = NotificationType9;
                var Message;
                (function(Message) {
                    /**
     * Tests if the given message is a request message
     */ function isRequest(message) {
                        const candidate = message;
                        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
                    }
                    Message.isRequest = isRequest;
                    /**
     * Tests if the given message is a notification message
     */ function isNotification(message) {
                        const candidate = message;
                        return candidate && is.string(candidate.method) && message.id === void 0;
                    }
                    Message.isNotification = isNotification;
                    /**
     * Tests if the given message is a response message
     */ function isResponse(message) {
                        const candidate = message;
                        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
                    }
                    Message.isResponse = isResponse;
                })(Message = exports1.Message || (exports1.Message = {}));
            /***/ },
            /***/ 5706: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                let _ral;
                function RAL() {
                    if (_ral === undefined) {
                        throw new Error(`No runtime abstraction layer installed`);
                    }
                    return _ral;
                }
                (function(RAL) {
                    function install(ral) {
                        if (ral === undefined) {
                            throw new Error(`No runtime abstraction layer provided`);
                        }
                        _ral = ral;
                    }
                    RAL.install = install;
                })(RAL || (RAL = {}));
                exports1["default"] = RAL;
            /***/ },
            /***/ 2339: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_417881__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Semaphore = void 0;
                const ral_1 = __nested_webpack_require_417881__(5706);
                class Semaphore {
                    lock(thunk) {
                        return new Promise((resolve, reject)=>{
                            this._waiting.push({
                                thunk,
                                resolve,
                                reject
                            });
                            this.runNext();
                        });
                    }
                    get active() {
                        return this._active;
                    }
                    runNext() {
                        if (this._waiting.length === 0 || this._active === this._capacity) {
                            return;
                        }
                        (0, ral_1.default)().timer.setImmediate(()=>this.doRunNext());
                    }
                    doRunNext() {
                        if (this._waiting.length === 0 || this._active === this._capacity) {
                            return;
                        }
                        const next = this._waiting.shift();
                        this._active++;
                        if (this._active > this._capacity) {
                            throw new Error(`To many thunks active`);
                        }
                        try {
                            const result = next.thunk();
                            if (result instanceof Promise) {
                                result.then((value)=>{
                                    this._active--;
                                    next.resolve(value);
                                    this.runNext();
                                }, (err)=>{
                                    this._active--;
                                    next.reject(err);
                                    this.runNext();
                                });
                            } else {
                                this._active--;
                                next.resolve(result);
                                this.runNext();
                            }
                        } catch (err) {
                            this._active--;
                            next.reject(err);
                            this.runNext();
                        }
                    }
                    constructor(capacity = 1){
                        if (capacity <= 0) {
                            throw new Error('Capacity must be greater than 0');
                        }
                        this._capacity = capacity;
                        this._active = 0;
                        this._waiting = [];
                    }
                }
                exports1.Semaphore = Semaphore;
            /***/ },
            /***/ 178: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_421323__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.SharedArrayReceiverStrategy = exports1.SharedArraySenderStrategy = void 0;
                const cancellation_1 = __nested_webpack_require_421323__(415);
                var CancellationState;
                (function(CancellationState) {
                    CancellationState.Continue = 0;
                    CancellationState.Cancelled = 1;
                })(CancellationState || (CancellationState = {}));
                class SharedArraySenderStrategy {
                    enableCancellation(request) {
                        if (request.id === null) {
                            return;
                        }
                        const buffer = new SharedArrayBuffer(4);
                        const data = new Int32Array(buffer, 0, 1);
                        data[0] = CancellationState.Continue;
                        this.buffers.set(request.id, buffer);
                        request.$cancellationData = buffer;
                    }
                    async sendCancellation(_conn, id) {
                        const buffer = this.buffers.get(id);
                        if (buffer === undefined) {
                            return;
                        }
                        const data = new Int32Array(buffer, 0, 1);
                        Atomics.store(data, 0, CancellationState.Cancelled);
                    }
                    cleanup(id) {
                        this.buffers.delete(id);
                    }
                    dispose() {
                        this.buffers.clear();
                    }
                    constructor(){
                        this.buffers = new Map();
                    }
                }
                exports1.SharedArraySenderStrategy = SharedArraySenderStrategy;
                class SharedArrayBufferCancellationToken {
                    get isCancellationRequested() {
                        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
                    }
                    get onCancellationRequested() {
                        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
                    }
                    constructor(buffer){
                        this.data = new Int32Array(buffer, 0, 1);
                    }
                }
                class SharedArrayBufferCancellationTokenSource {
                    cancel() {}
                    dispose() {}
                    constructor(buffer){
                        this.token = new SharedArrayBufferCancellationToken(buffer);
                    }
                }
                class SharedArrayReceiverStrategy {
                    createCancellationTokenSource(request) {
                        const buffer = request.$cancellationData;
                        if (buffer === undefined) {
                            return new cancellation_1.CancellationTokenSource();
                        }
                        return new SharedArrayBufferCancellationTokenSource(buffer);
                    }
                    constructor(){
                        this.kind = 'request';
                    }
                }
                exports1.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
            /***/ },
            /***/ 1789: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_425219__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */ module1.exports = __nested_webpack_require_425219__(294);
            /***/ },
            /***/ 294: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_425776__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createProtocolConnection = void 0;
                const browser_1 = __nested_webpack_require_425776__(1200);
                __exportStar(__nested_webpack_require_425776__(1200), exports1);
                __exportStar(__nested_webpack_require_425776__(9372), exports1);
                function createProtocolConnection(reader, writer, logger, options) {
                    return (0, browser_1.createMessageConnection)(reader, writer, logger, options);
                }
                exports1.createProtocolConnection = createProtocolConnection;
            /***/ },
            /***/ 9372: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_427965__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LSPErrorCodes = exports1.createProtocolConnection = void 0;
                __exportStar(__nested_webpack_require_427965__(5953), exports1);
                __exportStar(__nested_webpack_require_427965__(4767), exports1);
                __exportStar(__nested_webpack_require_427965__(8599), exports1);
                __exportStar(__nested_webpack_require_427965__(6525), exports1);
                var connection_1 = __nested_webpack_require_427965__(2798);
                Object.defineProperty(exports1, "createProtocolConnection", {
                    enumerable: true,
                    get: function() {
                        return connection_1.createProtocolConnection;
                    }
                });
                var LSPErrorCodes;
                (function(LSPErrorCodes) {
                    /**
    * This is the start range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */ LSPErrorCodes.lspReservedErrorRangeStart = -32899;
                    /**
     * A request failed but it was syntactically correct, e.g the
     * method name was known and the parameters were valid. The error
     * message should contain human readable information about why
     * the request failed.
     *
     * @since 3.17.0
     */ LSPErrorCodes.RequestFailed = -32803;
                    /**
     * The server cancelled the request. This error code should
     * only be used for requests that explicitly support being
     * server cancellable.
     *
     * @since 3.17.0
     */ LSPErrorCodes.ServerCancelled = -32802;
                    /**
     * The server detected that the content of a document got
     * modified outside normal conditions. A server should
     * NOT send this error code if it detects a content change
     * in it unprocessed messages. The result even computed
     * on an older state might still be useful for the client.
     *
     * If a client decides that a result is not of any use anymore
     * the client should cancel the request.
     */ LSPErrorCodes.ContentModified = -32801;
                    /**
     * The client has canceled a request and a server as detected
     * the cancel.
     */ LSPErrorCodes.RequestCancelled = -32800;
                    /**
    * This is the end range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */ LSPErrorCodes.lspReservedErrorRangeEnd = -32800;
                })(LSPErrorCodes = exports1.LSPErrorCodes || (exports1.LSPErrorCodes = {}));
            /***/ },
            /***/ 2798: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_432116__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createProtocolConnection = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_432116__(5953);
                function createProtocolConnection(input, output, logger, options) {
                    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
                        options = {
                            connectionStrategy: options
                        };
                    }
                    return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
                }
                exports1.createProtocolConnection = createProtocolConnection;
            /***/ },
            /***/ 8599: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_433353__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ProtocolNotificationType = exports1.ProtocolNotificationType0 = exports1.ProtocolRequestType = exports1.ProtocolRequestType0 = exports1.RegistrationType = exports1.MessageDirection = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_433353__(5953);
                var MessageDirection;
                (function(MessageDirection) {
                    MessageDirection["clientToServer"] = "clientToServer";
                    MessageDirection["serverToClient"] = "serverToClient";
                    MessageDirection["both"] = "both";
                })(MessageDirection = exports1.MessageDirection || (exports1.MessageDirection = {}));
                class RegistrationType {
                    constructor(method){
                        this.method = method;
                    }
                }
                exports1.RegistrationType = RegistrationType;
                class ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {
                    constructor(method){
                        super(method);
                    }
                }
                exports1.ProtocolRequestType0 = ProtocolRequestType0;
                class ProtocolRequestType extends vscode_jsonrpc_1.RequestType {
                    constructor(method){
                        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
                    }
                }
                exports1.ProtocolRequestType = ProtocolRequestType;
                class ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {
                    constructor(method){
                        super(method);
                    }
                }
                exports1.ProtocolNotificationType0 = ProtocolNotificationType0;
                class ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {
                    constructor(method){
                        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
                    }
                }
                exports1.ProtocolNotificationType = ProtocolNotificationType;
            /***/ },
            /***/ 4434: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_436079__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.CallHierarchyOutgoingCallsRequest = exports1.CallHierarchyIncomingCallsRequest = exports1.CallHierarchyPrepareRequest = void 0;
                const messages_1 = __nested_webpack_require_436079__(8599);
                /**
 * A request to result a `CallHierarchyItem` in a document at a given position.
 * Can be used as an input to an incoming or outgoing call hierarchy.
 *
 * @since 3.16.0
 */ var CallHierarchyPrepareRequest;
                (function(CallHierarchyPrepareRequest) {
                    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';
                    CallHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);
                })(CallHierarchyPrepareRequest = exports1.CallHierarchyPrepareRequest || (exports1.CallHierarchyPrepareRequest = {}));
                /**
 * A request to resolve the incoming calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */ var CallHierarchyIncomingCallsRequest;
                (function(CallHierarchyIncomingCallsRequest) {
                    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';
                    CallHierarchyIncomingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);
                })(CallHierarchyIncomingCallsRequest = exports1.CallHierarchyIncomingCallsRequest || (exports1.CallHierarchyIncomingCallsRequest = {}));
                /**
 * A request to resolve the outgoing calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */ var CallHierarchyOutgoingCallsRequest;
                (function(CallHierarchyOutgoingCallsRequest) {
                    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';
                    CallHierarchyOutgoingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);
                })(CallHierarchyOutgoingCallsRequest = exports1.CallHierarchyOutgoingCallsRequest || (exports1.CallHierarchyOutgoingCallsRequest = {}));
            /***/ },
            /***/ 7908: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_439110__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ColorPresentationRequest = exports1.DocumentColorRequest = void 0;
                const messages_1 = __nested_webpack_require_439110__(8599);
                /**
 * A request to list all color symbols found in a given text document. The request's
 * parameter is of type {@link DocumentColorParams} the
 * response is of type {@link ColorInformation ColorInformation[]} or a Thenable
 * that resolves to such.
 */ var DocumentColorRequest;
                (function(DocumentColorRequest) {
                    DocumentColorRequest.method = 'textDocument/documentColor';
                    DocumentColorRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);
                })(DocumentColorRequest = exports1.DocumentColorRequest || (exports1.DocumentColorRequest = {}));
                /**
 * A request to list all presentation for a color. The request's
 * parameter is of type {@link ColorPresentationParams} the
 * response is of type {@link ColorInformation ColorInformation[]} or a Thenable
 * that resolves to such.
 */ var ColorPresentationRequest;
                (function(ColorPresentationRequest) {
                    ColorPresentationRequest.method = 'textDocument/colorPresentation';
                    ColorPresentationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ColorPresentationRequest.type = new messages_1.ProtocolRequestType(ColorPresentationRequest.method);
                })(ColorPresentationRequest = exports1.ColorPresentationRequest || (exports1.ColorPresentationRequest = {}));
            /***/ },
            /***/ 5442: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_441413__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ConfigurationRequest = void 0;
                const messages_1 = __nested_webpack_require_441413__(8599);
                //---- Get Configuration request ----
                /**
 * The 'workspace/configuration' request is sent from the server to the client to fetch a certain
 * configuration setting.
 *
 * This pull model replaces the old push model were the client signaled configuration change via an
 * event. If the server still needs to react to configuration changes (since the server caches the
 * result of `workspace/configuration` requests) the server should register for an empty configuration
 * change event and empty the cache if such an event is received.
 */ var ConfigurationRequest;
                (function(ConfigurationRequest) {
                    ConfigurationRequest.method = 'workspace/configuration';
                    ConfigurationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ConfigurationRequest.type = new messages_1.ProtocolRequestType(ConfigurationRequest.method);
                })(ConfigurationRequest = exports1.ConfigurationRequest || (exports1.ConfigurationRequest = {}));
            /***/ },
            /***/ 7210: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_443195__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DeclarationRequest = void 0;
                const messages_1 = __nested_webpack_require_443195__(8599);
                // @ts-ignore: to avoid inlining LocationLink as dynamic import
                let __noDynamicImport;
                /**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositionParams]
 * (#TextDocumentPositionParams) the response is of type {@link Declaration}
 * or a typed array of {@link DeclarationLink} or a Thenable that resolves
 * to such.
 */ var DeclarationRequest;
                (function(DeclarationRequest) {
                    DeclarationRequest.method = 'textDocument/declaration';
                    DeclarationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);
                })(DeclarationRequest = exports1.DeclarationRequest || (exports1.DeclarationRequest = {}));
            /***/ },
            /***/ 5692: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_444860__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DiagnosticRefreshRequest = exports1.WorkspaceDiagnosticRequest = exports1.DocumentDiagnosticRequest = exports1.DocumentDiagnosticReportKind = exports1.DiagnosticServerCancellationData = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_444860__(5953);
                const Is = __nested_webpack_require_444860__(2523);
                const messages_1 = __nested_webpack_require_444860__(8599);
                /**
 * @since 3.17.0
 */ var DiagnosticServerCancellationData;
                (function(DiagnosticServerCancellationData) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.boolean(candidate.retriggerRequest);
                    }
                    DiagnosticServerCancellationData.is = is;
                })(DiagnosticServerCancellationData = exports1.DiagnosticServerCancellationData || (exports1.DiagnosticServerCancellationData = {}));
                /**
 * The document diagnostic report kinds.
 *
 * @since 3.17.0
 */ var DocumentDiagnosticReportKind;
                (function(DocumentDiagnosticReportKind) {
                    /**
     * A diagnostic report with a full
     * set of problems.
     */ DocumentDiagnosticReportKind.Full = 'full';
                    /**
     * A report indicating that the last
     * returned report is still accurate.
     */ DocumentDiagnosticReportKind.Unchanged = 'unchanged';
                })(DocumentDiagnosticReportKind = exports1.DocumentDiagnosticReportKind || (exports1.DocumentDiagnosticReportKind = {}));
                /**
 * The document diagnostic request definition.
 *
 * @since 3.17.0
 */ var DocumentDiagnosticRequest;
                (function(DocumentDiagnosticRequest) {
                    DocumentDiagnosticRequest.method = 'textDocument/diagnostic';
                    DocumentDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentDiagnosticRequest.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest.method);
                    DocumentDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
                })(DocumentDiagnosticRequest = exports1.DocumentDiagnosticRequest || (exports1.DocumentDiagnosticRequest = {}));
                /**
 * The workspace diagnostic request definition.
 *
 * @since 3.17.0
 */ var WorkspaceDiagnosticRequest;
                (function(WorkspaceDiagnosticRequest) {
                    WorkspaceDiagnosticRequest.method = 'workspace/diagnostic';
                    WorkspaceDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkspaceDiagnosticRequest.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest.method);
                    WorkspaceDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
                })(WorkspaceDiagnosticRequest = exports1.WorkspaceDiagnosticRequest || (exports1.WorkspaceDiagnosticRequest = {}));
                /**
 * The diagnostic refresh request definition.
 *
 * @since 3.17.0
 */ var DiagnosticRefreshRequest;
                (function(DiagnosticRefreshRequest) {
                    DiagnosticRefreshRequest.method = `workspace/diagnostic/refresh`;
                    DiagnosticRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    DiagnosticRefreshRequest.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest.method);
                })(DiagnosticRefreshRequest = exports1.DiagnosticRefreshRequest || (exports1.DiagnosticRefreshRequest = {}));
            /***/ },
            /***/ 6190: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_449104__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WillDeleteFilesRequest = exports1.DidDeleteFilesNotification = exports1.DidRenameFilesNotification = exports1.WillRenameFilesRequest = exports1.DidCreateFilesNotification = exports1.WillCreateFilesRequest = exports1.FileOperationPatternKind = void 0;
                const messages_1 = __nested_webpack_require_449104__(8599);
                /**
 * A pattern kind describing if a glob pattern matches a file a folder or
 * both.
 *
 * @since 3.16.0
 */ var FileOperationPatternKind;
                (function(FileOperationPatternKind) {
                    /**
     * The pattern matches a file only.
     */ FileOperationPatternKind.file = 'file';
                    /**
     * The pattern matches a folder only.
     */ FileOperationPatternKind.folder = 'folder';
                })(FileOperationPatternKind = exports1.FileOperationPatternKind || (exports1.FileOperationPatternKind = {}));
                /**
 * The will create files request is sent from the client to the server before files are actually
 * created as long as the creation is triggered from within the client.
 *
 * The request can return a `WorkspaceEdit` which will be applied to workspace before the
 * files are created. Hence the `WorkspaceEdit` can not manipulate the content of the file
 * to be created.
 *
 * @since 3.16.0
 */ var WillCreateFilesRequest;
                (function(WillCreateFilesRequest) {
                    WillCreateFilesRequest.method = 'workspace/willCreateFiles';
                    WillCreateFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillCreateFilesRequest.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest.method);
                })(WillCreateFilesRequest = exports1.WillCreateFilesRequest || (exports1.WillCreateFilesRequest = {}));
                /**
 * The did create files notification is sent from the client to the server when
 * files were created from within the client.
 *
 * @since 3.16.0
 */ var DidCreateFilesNotification;
                (function(DidCreateFilesNotification) {
                    DidCreateFilesNotification.method = 'workspace/didCreateFiles';
                    DidCreateFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidCreateFilesNotification.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification.method);
                })(DidCreateFilesNotification = exports1.DidCreateFilesNotification || (exports1.DidCreateFilesNotification = {}));
                /**
 * The will rename files request is sent from the client to the server before files are actually
 * renamed as long as the rename is triggered from within the client.
 *
 * @since 3.16.0
 */ var WillRenameFilesRequest;
                (function(WillRenameFilesRequest) {
                    WillRenameFilesRequest.method = 'workspace/willRenameFiles';
                    WillRenameFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillRenameFilesRequest.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest.method);
                })(WillRenameFilesRequest = exports1.WillRenameFilesRequest || (exports1.WillRenameFilesRequest = {}));
                /**
 * The did rename files notification is sent from the client to the server when
 * files were renamed from within the client.
 *
 * @since 3.16.0
 */ var DidRenameFilesNotification;
                (function(DidRenameFilesNotification) {
                    DidRenameFilesNotification.method = 'workspace/didRenameFiles';
                    DidRenameFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidRenameFilesNotification.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification.method);
                })(DidRenameFilesNotification = exports1.DidRenameFilesNotification || (exports1.DidRenameFilesNotification = {}));
                /**
 * The will delete files request is sent from the client to the server before files are actually
 * deleted as long as the deletion is triggered from within the client.
 *
 * @since 3.16.0
 */ var DidDeleteFilesNotification;
                (function(DidDeleteFilesNotification) {
                    DidDeleteFilesNotification.method = 'workspace/didDeleteFiles';
                    DidDeleteFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidDeleteFilesNotification.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification.method);
                })(DidDeleteFilesNotification = exports1.DidDeleteFilesNotification || (exports1.DidDeleteFilesNotification = {}));
                /**
 * The did delete files notification is sent from the client to the server when
 * files were deleted from within the client.
 *
 * @since 3.16.0
 */ var WillDeleteFilesRequest;
                (function(WillDeleteFilesRequest) {
                    WillDeleteFilesRequest.method = 'workspace/willDeleteFiles';
                    WillDeleteFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillDeleteFilesRequest.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest.method);
                })(WillDeleteFilesRequest = exports1.WillDeleteFilesRequest || (exports1.WillDeleteFilesRequest = {}));
            /***/ },
            /***/ 7029: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_455109__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.FoldingRangeRequest = void 0;
                const messages_1 = __nested_webpack_require_455109__(8599);
                /**
 * A request to provide folding ranges in a document. The request's
 * parameter is of type {@link FoldingRangeParams}, the
 * response is of type {@link FoldingRangeList} or a Thenable
 * that resolves to such.
 */ var FoldingRangeRequest;
                (function(FoldingRangeRequest) {
                    FoldingRangeRequest.method = 'textDocument/foldingRange';
                    FoldingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);
                })(FoldingRangeRequest = exports1.FoldingRangeRequest || (exports1.FoldingRangeRequest = {}));
            /***/ },
            /***/ 9380: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_456548__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ImplementationRequest = void 0;
                const messages_1 = __nested_webpack_require_456548__(8599);
                // @ts-ignore: to avoid inlining LocationLink as dynamic import
                let __noDynamicImport;
                /**
 * A request to resolve the implementation locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositionParams]
 * (#TextDocumentPositionParams) the response is of type {@link Definition} or a
 * Thenable that resolves to such.
 */ var ImplementationRequest;
                (function(ImplementationRequest) {
                    ImplementationRequest.method = 'textDocument/implementation';
                    ImplementationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);
                })(ImplementationRequest = exports1.ImplementationRequest || (exports1.ImplementationRequest = {}));
            /***/ },
            /***/ 6315: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_458197__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.InlayHintRefreshRequest = exports1.InlayHintResolveRequest = exports1.InlayHintRequest = void 0;
                const messages_1 = __nested_webpack_require_458197__(8599);
                /**
 * A request to provide inlay hints in a document. The request's parameter is of
 * type {@link InlayHintsParams}, the response is of type
 * {@link InlayHint InlayHint[]} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */ var InlayHintRequest;
                (function(InlayHintRequest) {
                    InlayHintRequest.method = 'textDocument/inlayHint';
                    InlayHintRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlayHintRequest.type = new messages_1.ProtocolRequestType(InlayHintRequest.method);
                })(InlayHintRequest = exports1.InlayHintRequest || (exports1.InlayHintRequest = {}));
                /**
 * A request to resolve additional properties for an inlay hint.
 * The request's parameter is of type {@link InlayHint}, the response is
 * of type {@link InlayHint} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */ var InlayHintResolveRequest;
                (function(InlayHintResolveRequest) {
                    InlayHintResolveRequest.method = 'inlayHint/resolve';
                    InlayHintResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlayHintResolveRequest.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest.method);
                })(InlayHintResolveRequest = exports1.InlayHintResolveRequest || (exports1.InlayHintResolveRequest = {}));
                /**
 * @since 3.17.0
 */ var InlayHintRefreshRequest;
                (function(InlayHintRefreshRequest) {
                    InlayHintRefreshRequest.method = `workspace/inlayHint/refresh`;
                    InlayHintRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    InlayHintRefreshRequest.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest.method);
                })(InlayHintRefreshRequest = exports1.InlayHintRefreshRequest || (exports1.InlayHintRefreshRequest = {}));
            /***/ },
            /***/ 7425: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_461000__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.InlineValueRefreshRequest = exports1.InlineValueRequest = void 0;
                const messages_1 = __nested_webpack_require_461000__(8599);
                /**
 * A request to provide inline values in a document. The request's parameter is of
 * type {@link InlineValueParams}, the response is of type
 * {@link InlineValue InlineValue[]} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */ var InlineValueRequest;
                (function(InlineValueRequest) {
                    InlineValueRequest.method = 'textDocument/inlineValue';
                    InlineValueRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlineValueRequest.type = new messages_1.ProtocolRequestType(InlineValueRequest.method);
                })(InlineValueRequest = exports1.InlineValueRequest || (exports1.InlineValueRequest = {}));
                /**
 * @since 3.17.0
 */ var InlineValueRefreshRequest;
                (function(InlineValueRefreshRequest) {
                    InlineValueRefreshRequest.method = `workspace/inlineValue/refresh`;
                    InlineValueRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    InlineValueRefreshRequest.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest.method);
                })(InlineValueRefreshRequest = exports1.InlineValueRefreshRequest || (exports1.InlineValueRefreshRequest = {}));
            /***/ },
            /***/ 6525: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_463066__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WorkspaceSymbolRequest = exports1.CodeActionResolveRequest = exports1.CodeActionRequest = exports1.DocumentSymbolRequest = exports1.DocumentHighlightRequest = exports1.ReferencesRequest = exports1.DefinitionRequest = exports1.SignatureHelpRequest = exports1.SignatureHelpTriggerKind = exports1.HoverRequest = exports1.CompletionResolveRequest = exports1.CompletionRequest = exports1.CompletionTriggerKind = exports1.PublishDiagnosticsNotification = exports1.WatchKind = exports1.RelativePattern = exports1.FileChangeType = exports1.DidChangeWatchedFilesNotification = exports1.WillSaveTextDocumentWaitUntilRequest = exports1.WillSaveTextDocumentNotification = exports1.TextDocumentSaveReason = exports1.DidSaveTextDocumentNotification = exports1.DidCloseTextDocumentNotification = exports1.DidChangeTextDocumentNotification = exports1.TextDocumentContentChangeEvent = exports1.DidOpenTextDocumentNotification = exports1.TextDocumentSyncKind = exports1.TelemetryEventNotification = exports1.LogMessageNotification = exports1.ShowMessageRequest = exports1.ShowMessageNotification = exports1.MessageType = exports1.DidChangeConfigurationNotification = exports1.ExitNotification = exports1.ShutdownRequest = exports1.InitializedNotification = exports1.InitializeErrorCodes = exports1.InitializeRequest = exports1.WorkDoneProgressOptions = exports1.TextDocumentRegistrationOptions = exports1.StaticRegistrationOptions = exports1.PositionEncodingKind = exports1.FailureHandlingKind = exports1.ResourceOperationKind = exports1.UnregistrationRequest = exports1.RegistrationRequest = exports1.DocumentSelector = exports1.NotebookCellTextDocumentFilter = exports1.NotebookDocumentFilter = exports1.TextDocumentFilter = void 0;
                exports1.TypeHierarchySubtypesRequest = exports1.TypeHierarchyPrepareRequest = exports1.MonikerRequest = exports1.MonikerKind = exports1.UniquenessLevel = exports1.WillDeleteFilesRequest = exports1.DidDeleteFilesNotification = exports1.WillRenameFilesRequest = exports1.DidRenameFilesNotification = exports1.WillCreateFilesRequest = exports1.DidCreateFilesNotification = exports1.FileOperationPatternKind = exports1.LinkedEditingRangeRequest = exports1.ShowDocumentRequest = exports1.SemanticTokensRegistrationType = exports1.SemanticTokensRefreshRequest = exports1.SemanticTokensRangeRequest = exports1.SemanticTokensDeltaRequest = exports1.SemanticTokensRequest = exports1.TokenFormat = exports1.CallHierarchyPrepareRequest = exports1.CallHierarchyOutgoingCallsRequest = exports1.CallHierarchyIncomingCallsRequest = exports1.WorkDoneProgressCancelNotification = exports1.WorkDoneProgressCreateRequest = exports1.WorkDoneProgress = exports1.SelectionRangeRequest = exports1.DeclarationRequest = exports1.FoldingRangeRequest = exports1.ColorPresentationRequest = exports1.DocumentColorRequest = exports1.ConfigurationRequest = exports1.DidChangeWorkspaceFoldersNotification = exports1.WorkspaceFoldersRequest = exports1.TypeDefinitionRequest = exports1.ImplementationRequest = exports1.ApplyWorkspaceEditRequest = exports1.ExecuteCommandRequest = exports1.PrepareRenameRequest = exports1.RenameRequest = exports1.PrepareSupportDefaultBehavior = exports1.DocumentOnTypeFormattingRequest = exports1.DocumentRangeFormattingRequest = exports1.DocumentFormattingRequest = exports1.DocumentLinkResolveRequest = exports1.DocumentLinkRequest = exports1.CodeLensRefreshRequest = exports1.CodeLensResolveRequest = exports1.CodeLensRequest = exports1.WorkspaceSymbolResolveRequest = void 0;
                exports1.DidCloseNotebookDocumentNotification = exports1.DidSaveNotebookDocumentNotification = exports1.DidChangeNotebookDocumentNotification = exports1.NotebookCellArrayChange = exports1.DidOpenNotebookDocumentNotification = exports1.NotebookDocumentSyncRegistrationType = exports1.NotebookDocument = exports1.NotebookCell = exports1.ExecutionSummary = exports1.NotebookCellKind = exports1.DiagnosticRefreshRequest = exports1.WorkspaceDiagnosticRequest = exports1.DocumentDiagnosticRequest = exports1.DocumentDiagnosticReportKind = exports1.DiagnosticServerCancellationData = exports1.InlayHintRefreshRequest = exports1.InlayHintResolveRequest = exports1.InlayHintRequest = exports1.InlineValueRefreshRequest = exports1.InlineValueRequest = exports1.TypeHierarchySupertypesRequest = void 0;
                const messages_1 = __nested_webpack_require_463066__(8599);
                const vscode_languageserver_types_1 = __nested_webpack_require_463066__(4767);
                const Is = __nested_webpack_require_463066__(2523);
                const protocol_implementation_1 = __nested_webpack_require_463066__(9380);
                Object.defineProperty(exports1, "ImplementationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_implementation_1.ImplementationRequest;
                    }
                });
                const protocol_typeDefinition_1 = __nested_webpack_require_463066__(8642);
                Object.defineProperty(exports1, "TypeDefinitionRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeDefinition_1.TypeDefinitionRequest;
                    }
                });
                const protocol_workspaceFolder_1 = __nested_webpack_require_463066__(3402);
                Object.defineProperty(exports1, "WorkspaceFoldersRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
                    }
                });
                Object.defineProperty(exports1, "DidChangeWorkspaceFoldersNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
                    }
                });
                const protocol_configuration_1 = __nested_webpack_require_463066__(5442);
                Object.defineProperty(exports1, "ConfigurationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_configuration_1.ConfigurationRequest;
                    }
                });
                const protocol_colorProvider_1 = __nested_webpack_require_463066__(7908);
                Object.defineProperty(exports1, "DocumentColorRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_colorProvider_1.DocumentColorRequest;
                    }
                });
                Object.defineProperty(exports1, "ColorPresentationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_colorProvider_1.ColorPresentationRequest;
                    }
                });
                const protocol_foldingRange_1 = __nested_webpack_require_463066__(7029);
                Object.defineProperty(exports1, "FoldingRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_foldingRange_1.FoldingRangeRequest;
                    }
                });
                const protocol_declaration_1 = __nested_webpack_require_463066__(7210);
                Object.defineProperty(exports1, "DeclarationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_declaration_1.DeclarationRequest;
                    }
                });
                const protocol_selectionRange_1 = __nested_webpack_require_463066__(2392);
                Object.defineProperty(exports1, "SelectionRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_selectionRange_1.SelectionRangeRequest;
                    }
                });
                const protocol_progress_1 = __nested_webpack_require_463066__(7895);
                Object.defineProperty(exports1, "WorkDoneProgress", {
                    enumerable: true,
                    get: function() {
                        return protocol_progress_1.WorkDoneProgress;
                    }
                });
                Object.defineProperty(exports1, "WorkDoneProgressCreateRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_progress_1.WorkDoneProgressCreateRequest;
                    }
                });
                Object.defineProperty(exports1, "WorkDoneProgressCancelNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_progress_1.WorkDoneProgressCancelNotification;
                    }
                });
                const protocol_callHierarchy_1 = __nested_webpack_require_463066__(4434);
                Object.defineProperty(exports1, "CallHierarchyIncomingCallsRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
                    }
                });
                Object.defineProperty(exports1, "CallHierarchyOutgoingCallsRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
                    }
                });
                Object.defineProperty(exports1, "CallHierarchyPrepareRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
                    }
                });
                const protocol_semanticTokens_1 = __nested_webpack_require_463066__(8489);
                Object.defineProperty(exports1, "TokenFormat", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.TokenFormat;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensDeltaRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRangeRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRegistrationType", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRegistrationType;
                    }
                });
                const protocol_showDocument_1 = __nested_webpack_require_463066__(1541);
                Object.defineProperty(exports1, "ShowDocumentRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_showDocument_1.ShowDocumentRequest;
                    }
                });
                const protocol_linkedEditingRange_1 = __nested_webpack_require_463066__(527);
                Object.defineProperty(exports1, "LinkedEditingRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
                    }
                });
                const protocol_fileOperations_1 = __nested_webpack_require_463066__(6190);
                Object.defineProperty(exports1, "FileOperationPatternKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.FileOperationPatternKind;
                    }
                });
                Object.defineProperty(exports1, "DidCreateFilesNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.DidCreateFilesNotification;
                    }
                });
                Object.defineProperty(exports1, "WillCreateFilesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.WillCreateFilesRequest;
                    }
                });
                Object.defineProperty(exports1, "DidRenameFilesNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.DidRenameFilesNotification;
                    }
                });
                Object.defineProperty(exports1, "WillRenameFilesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.WillRenameFilesRequest;
                    }
                });
                Object.defineProperty(exports1, "DidDeleteFilesNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.DidDeleteFilesNotification;
                    }
                });
                Object.defineProperty(exports1, "WillDeleteFilesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.WillDeleteFilesRequest;
                    }
                });
                const protocol_moniker_1 = __nested_webpack_require_463066__(1964);
                Object.defineProperty(exports1, "UniquenessLevel", {
                    enumerable: true,
                    get: function() {
                        return protocol_moniker_1.UniquenessLevel;
                    }
                });
                Object.defineProperty(exports1, "MonikerKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_moniker_1.MonikerKind;
                    }
                });
                Object.defineProperty(exports1, "MonikerRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_moniker_1.MonikerRequest;
                    }
                });
                const protocol_typeHierarchy_1 = __nested_webpack_require_463066__(5318);
                Object.defineProperty(exports1, "TypeHierarchyPrepareRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
                    }
                });
                Object.defineProperty(exports1, "TypeHierarchySubtypesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
                    }
                });
                Object.defineProperty(exports1, "TypeHierarchySupertypesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
                    }
                });
                const protocol_inlineValue_1 = __nested_webpack_require_463066__(7425);
                Object.defineProperty(exports1, "InlineValueRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlineValue_1.InlineValueRequest;
                    }
                });
                Object.defineProperty(exports1, "InlineValueRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlineValue_1.InlineValueRefreshRequest;
                    }
                });
                const protocol_inlayHint_1 = __nested_webpack_require_463066__(6315);
                Object.defineProperty(exports1, "InlayHintRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlayHint_1.InlayHintRequest;
                    }
                });
                Object.defineProperty(exports1, "InlayHintResolveRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlayHint_1.InlayHintResolveRequest;
                    }
                });
                Object.defineProperty(exports1, "InlayHintRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlayHint_1.InlayHintRefreshRequest;
                    }
                });
                const protocol_diagnostic_1 = __nested_webpack_require_463066__(5692);
                Object.defineProperty(exports1, "DiagnosticServerCancellationData", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DiagnosticServerCancellationData;
                    }
                });
                Object.defineProperty(exports1, "DocumentDiagnosticReportKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DocumentDiagnosticReportKind;
                    }
                });
                Object.defineProperty(exports1, "DocumentDiagnosticRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DocumentDiagnosticRequest;
                    }
                });
                Object.defineProperty(exports1, "WorkspaceDiagnosticRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
                    }
                });
                Object.defineProperty(exports1, "DiagnosticRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DiagnosticRefreshRequest;
                    }
                });
                const protocol_notebook_1 = __nested_webpack_require_463066__(4460);
                Object.defineProperty(exports1, "NotebookCellKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookCellKind;
                    }
                });
                Object.defineProperty(exports1, "ExecutionSummary", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.ExecutionSummary;
                    }
                });
                Object.defineProperty(exports1, "NotebookCell", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookCell;
                    }
                });
                Object.defineProperty(exports1, "NotebookDocument", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookDocument;
                    }
                });
                Object.defineProperty(exports1, "NotebookDocumentSyncRegistrationType", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
                    }
                });
                Object.defineProperty(exports1, "DidOpenNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidOpenNotebookDocumentNotification;
                    }
                });
                Object.defineProperty(exports1, "NotebookCellArrayChange", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookCellArrayChange;
                    }
                });
                Object.defineProperty(exports1, "DidChangeNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidChangeNotebookDocumentNotification;
                    }
                });
                Object.defineProperty(exports1, "DidSaveNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidSaveNotebookDocumentNotification;
                    }
                });
                Object.defineProperty(exports1, "DidCloseNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidCloseNotebookDocumentNotification;
                    }
                });
                // @ts-ignore: to avoid inlining LocationLink as dynamic import
                let __noDynamicImport;
                /**
 * The TextDocumentFilter namespace provides helper functions to work with
 * {@link TextDocumentFilter} literals.
 *
 * @since 3.17.0
 */ var TextDocumentFilter;
                (function(TextDocumentFilter) {
                    function is(value) {
                        const candidate = value;
                        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
                    }
                    TextDocumentFilter.is = is;
                })(TextDocumentFilter = exports1.TextDocumentFilter || (exports1.TextDocumentFilter = {}));
                /**
 * The NotebookDocumentFilter namespace provides helper functions to work with
 * {@link NotebookDocumentFilter} literals.
 *
 * @since 3.17.0
 */ var NotebookDocumentFilter;
                (function(NotebookDocumentFilter) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
                    }
                    NotebookDocumentFilter.is = is;
                })(NotebookDocumentFilter = exports1.NotebookDocumentFilter || (exports1.NotebookDocumentFilter = {}));
                /**
 * The NotebookCellTextDocumentFilter namespace provides helper functions to work with
 * {@link NotebookCellTextDocumentFilter} literals.
 *
 * @since 3.17.0
 */ var NotebookCellTextDocumentFilter;
                (function(NotebookCellTextDocumentFilter) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === undefined || Is.string(candidate.language));
                    }
                    NotebookCellTextDocumentFilter.is = is;
                })(NotebookCellTextDocumentFilter = exports1.NotebookCellTextDocumentFilter || (exports1.NotebookCellTextDocumentFilter = {}));
                /**
 * The DocumentSelector namespace provides helper functions to work with
 * {@link DocumentSelector}s.
 */ var DocumentSelector;
                (function(DocumentSelector) {
                    function is(value) {
                        if (!Array.isArray(value)) {
                            return false;
                        }
                        for (let elem of value){
                            if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
                                return false;
                            }
                        }
                        return true;
                    }
                    DocumentSelector.is = is;
                })(DocumentSelector = exports1.DocumentSelector || (exports1.DocumentSelector = {}));
                /**
 * The `client/registerCapability` request is sent from the server to the client to register a new capability
 * handler on the client side.
 */ var RegistrationRequest;
                (function(RegistrationRequest) {
                    RegistrationRequest.method = 'client/registerCapability';
                    RegistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    RegistrationRequest.type = new messages_1.ProtocolRequestType(RegistrationRequest.method);
                })(RegistrationRequest = exports1.RegistrationRequest || (exports1.RegistrationRequest = {}));
                /**
 * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
 * handler on the client side.
 */ var UnregistrationRequest;
                (function(UnregistrationRequest) {
                    UnregistrationRequest.method = 'client/unregisterCapability';
                    UnregistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    UnregistrationRequest.type = new messages_1.ProtocolRequestType(UnregistrationRequest.method);
                })(UnregistrationRequest = exports1.UnregistrationRequest || (exports1.UnregistrationRequest = {}));
                var ResourceOperationKind;
                (function(ResourceOperationKind) {
                    /**
     * Supports creating new files and folders.
     */ ResourceOperationKind.Create = 'create';
                    /**
     * Supports renaming existing files and folders.
     */ ResourceOperationKind.Rename = 'rename';
                    /**
     * Supports deleting existing files and folders.
     */ ResourceOperationKind.Delete = 'delete';
                })(ResourceOperationKind = exports1.ResourceOperationKind || (exports1.ResourceOperationKind = {}));
                var FailureHandlingKind;
                (function(FailureHandlingKind) {
                    /**
     * Applying the workspace change is simply aborted if one of the changes provided
     * fails. All operations executed before the failing operation stay executed.
     */ FailureHandlingKind.Abort = 'abort';
                    /**
     * All operations are executed transactional. That means they either all
     * succeed or no changes at all are applied to the workspace.
     */ FailureHandlingKind.Transactional = 'transactional';
                    /**
     * If the workspace edit contains only textual file changes they are executed transactional.
     * If resource changes (create, rename or delete file) are part of the change the failure
     * handling strategy is abort.
     */ FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';
                    /**
     * The client tries to undo the operations already executed. But there is no
     * guarantee that this is succeeding.
     */ FailureHandlingKind.Undo = 'undo';
                })(FailureHandlingKind = exports1.FailureHandlingKind || (exports1.FailureHandlingKind = {}));
                /**
 * A set of predefined position encoding kinds.
 *
 * @since 3.17.0
 */ var PositionEncodingKind;
                (function(PositionEncodingKind) {
                    /**
     * Character offsets count UTF-8 code units (e.g. bytes).
     */ PositionEncodingKind.UTF8 = 'utf-8';
                    /**
     * Character offsets count UTF-16 code units.
     *
     * This is the default and must always be supported
     * by servers
     */ PositionEncodingKind.UTF16 = 'utf-16';
                    /**
     * Character offsets count UTF-32 code units.
     *
     * Implementation note: these are the same as Unicode codepoints,
     * so this `PositionEncodingKind` may also be used for an
     * encoding-agnostic representation of character offsets.
     */ PositionEncodingKind.UTF32 = 'utf-32';
                })(PositionEncodingKind = exports1.PositionEncodingKind || (exports1.PositionEncodingKind = {}));
                /**
 * The StaticRegistrationOptions namespace provides helper functions to work with
 * {@link StaticRegistrationOptions} literals.
 */ var StaticRegistrationOptions;
                (function(StaticRegistrationOptions) {
                    function hasId(value) {
                        const candidate = value;
                        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
                    }
                    StaticRegistrationOptions.hasId = hasId;
                })(StaticRegistrationOptions = exports1.StaticRegistrationOptions || (exports1.StaticRegistrationOptions = {}));
                /**
 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
 * {@link TextDocumentRegistrationOptions} literals.
 */ var TextDocumentRegistrationOptions;
                (function(TextDocumentRegistrationOptions) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
                    }
                    TextDocumentRegistrationOptions.is = is;
                })(TextDocumentRegistrationOptions = exports1.TextDocumentRegistrationOptions || (exports1.TextDocumentRegistrationOptions = {}));
                /**
 * The WorkDoneProgressOptions namespace provides helper functions to work with
 * {@link WorkDoneProgressOptions} literals.
 */ var WorkDoneProgressOptions;
                (function(WorkDoneProgressOptions) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));
                    }
                    WorkDoneProgressOptions.is = is;
                    function hasWorkDoneProgress(value) {
                        const candidate = value;
                        return candidate && Is.boolean(candidate.workDoneProgress);
                    }
                    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;
                })(WorkDoneProgressOptions = exports1.WorkDoneProgressOptions || (exports1.WorkDoneProgressOptions = {}));
                /**
 * The initialize request is sent from the client to the server.
 * It is sent once as the request after starting up the server.
 * The requests parameter is of type {@link InitializeParams}
 * the response if of type {@link InitializeResult} of a Thenable that
 * resolves to such.
 */ var InitializeRequest;
                (function(InitializeRequest) {
                    InitializeRequest.method = 'initialize';
                    InitializeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InitializeRequest.type = new messages_1.ProtocolRequestType(InitializeRequest.method);
                })(InitializeRequest = exports1.InitializeRequest || (exports1.InitializeRequest = {}));
                /**
 * Known error codes for an `InitializeErrorCodes`;
 */ var InitializeErrorCodes;
                (function(InitializeErrorCodes) {
                    /**
     * If the protocol version provided by the client can't be handled by the server.
     *
     * @deprecated This initialize error got replaced by client capabilities. There is
     * no version handshake in version 3.0x
     */ InitializeErrorCodes.unknownProtocolVersion = 1;
                })(InitializeErrorCodes = exports1.InitializeErrorCodes || (exports1.InitializeErrorCodes = {}));
                /**
 * The initialized notification is sent from the client to the
 * server after the client is fully initialized and the server
 * is allowed to send requests from the server to the client.
 */ var InitializedNotification;
                (function(InitializedNotification) {
                    InitializedNotification.method = 'initialized';
                    InitializedNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    InitializedNotification.type = new messages_1.ProtocolNotificationType(InitializedNotification.method);
                })(InitializedNotification = exports1.InitializedNotification || (exports1.InitializedNotification = {}));
                //---- Shutdown Method ----
                /**
 * A shutdown request is sent from the client to the server.
 * It is sent once when the client decides to shutdown the
 * server. The only notification that is sent after a shutdown request
 * is the exit event.
 */ var ShutdownRequest;
                (function(ShutdownRequest) {
                    ShutdownRequest.method = 'shutdown';
                    ShutdownRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ShutdownRequest.type = new messages_1.ProtocolRequestType0(ShutdownRequest.method);
                })(ShutdownRequest = exports1.ShutdownRequest || (exports1.ShutdownRequest = {}));
                //---- Exit Notification ----
                /**
 * The exit event is sent from the client to the server to
 * ask the server to exit its process.
 */ var ExitNotification;
                (function(ExitNotification) {
                    ExitNotification.method = 'exit';
                    ExitNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    ExitNotification.type = new messages_1.ProtocolNotificationType0(ExitNotification.method);
                })(ExitNotification = exports1.ExitNotification || (exports1.ExitNotification = {}));
                /**
 * The configuration change notification is sent from the client to the server
 * when the client's configuration has changed. The notification contains
 * the changed configuration as defined by the language client.
 */ var DidChangeConfigurationNotification;
                (function(DidChangeConfigurationNotification) {
                    DidChangeConfigurationNotification.method = 'workspace/didChangeConfiguration';
                    DidChangeConfigurationNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification.method);
                })(DidChangeConfigurationNotification = exports1.DidChangeConfigurationNotification || (exports1.DidChangeConfigurationNotification = {}));
                //---- Message show and log notifications ----
                /**
 * The message type
 */ var MessageType;
                (function(MessageType) {
                    /**
     * An error message.
     */ MessageType.Error = 1;
                    /**
     * A warning message.
     */ MessageType.Warning = 2;
                    /**
     * An information message.
     */ MessageType.Info = 3;
                    /**
     * A log message.
     */ MessageType.Log = 4;
                })(MessageType = exports1.MessageType || (exports1.MessageType = {}));
                /**
 * The show message notification is sent from a server to a client to ask
 * the client to display a particular message in the user interface.
 */ var ShowMessageNotification;
                (function(ShowMessageNotification) {
                    ShowMessageNotification.method = 'window/showMessage';
                    ShowMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    ShowMessageNotification.type = new messages_1.ProtocolNotificationType(ShowMessageNotification.method);
                })(ShowMessageNotification = exports1.ShowMessageNotification || (exports1.ShowMessageNotification = {}));
                /**
 * The show message request is sent from the server to the client to show a message
 * and a set of options actions to the user.
 */ var ShowMessageRequest;
                (function(ShowMessageRequest) {
                    ShowMessageRequest.method = 'window/showMessageRequest';
                    ShowMessageRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ShowMessageRequest.type = new messages_1.ProtocolRequestType(ShowMessageRequest.method);
                })(ShowMessageRequest = exports1.ShowMessageRequest || (exports1.ShowMessageRequest = {}));
                /**
 * The log message notification is sent from the server to the client to ask
 * the client to log a particular message.
 */ var LogMessageNotification;
                (function(LogMessageNotification) {
                    LogMessageNotification.method = 'window/logMessage';
                    LogMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    LogMessageNotification.type = new messages_1.ProtocolNotificationType(LogMessageNotification.method);
                })(LogMessageNotification = exports1.LogMessageNotification || (exports1.LogMessageNotification = {}));
                //---- Telemetry notification
                /**
 * The telemetry event notification is sent from the server to the client to ask
 * the client to log telemetry data.
 */ var TelemetryEventNotification;
                (function(TelemetryEventNotification) {
                    TelemetryEventNotification.method = 'telemetry/event';
                    TelemetryEventNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification.method);
                })(TelemetryEventNotification = exports1.TelemetryEventNotification || (exports1.TelemetryEventNotification = {}));
                /**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */ var TextDocumentSyncKind;
                (function(TextDocumentSyncKind) {
                    /**
     * Documents should not be synced at all.
     */ TextDocumentSyncKind.None = 0;
                    /**
     * Documents are synced by always sending the full content
     * of the document.
     */ TextDocumentSyncKind.Full = 1;
                    /**
     * Documents are synced by sending the full content on open.
     * After that only incremental updates to the document are
     * send.
     */ TextDocumentSyncKind.Incremental = 2;
                })(TextDocumentSyncKind = exports1.TextDocumentSyncKind || (exports1.TextDocumentSyncKind = {}));
                /**
 * The document open notification is sent from the client to the server to signal
 * newly opened text documents. The document's truth is now managed by the client
 * and the server must not try to read the document's truth using the document's
 * uri. Open in this sense means it is managed by the client. It doesn't necessarily
 * mean that its content is presented in an editor. An open notification must not
 * be sent more than once without a corresponding close notification send before.
 * This means open and close notification must be balanced and the max open count
 * is one.
 */ var DidOpenTextDocumentNotification;
                (function(DidOpenTextDocumentNotification) {
                    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';
                    DidOpenTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);
                })(DidOpenTextDocumentNotification = exports1.DidOpenTextDocumentNotification || (exports1.DidOpenTextDocumentNotification = {}));
                var TextDocumentContentChangeEvent;
                (function(TextDocumentContentChangeEvent) {
                    /**
     * Checks whether the information describes a delta event.
     */ function isIncremental(event) {
                        let candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range !== undefined && (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
                    }
                    TextDocumentContentChangeEvent.isIncremental = isIncremental;
                    /**
     * Checks whether the information describes a full replacement event.
     */ function isFull(event) {
                        let candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
                    }
                    TextDocumentContentChangeEvent.isFull = isFull;
                })(TextDocumentContentChangeEvent = exports1.TextDocumentContentChangeEvent || (exports1.TextDocumentContentChangeEvent = {}));
                /**
 * The document change notification is sent from the client to the server to signal
 * changes to a text document.
 */ var DidChangeTextDocumentNotification;
                (function(DidChangeTextDocumentNotification) {
                    DidChangeTextDocumentNotification.method = 'textDocument/didChange';
                    DidChangeTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);
                })(DidChangeTextDocumentNotification = exports1.DidChangeTextDocumentNotification || (exports1.DidChangeTextDocumentNotification = {}));
                /**
 * The document close notification is sent from the client to the server when
 * the document got closed in the client. The document's truth now exists where
 * the document's uri points to (e.g. if the document's uri is a file uri the
 * truth now exists on disk). As with the open notification the close notification
 * is about managing the document's content. Receiving a close notification
 * doesn't mean that the document was open in an editor before. A close
 * notification requires a previous open notification to be sent.
 */ var DidCloseTextDocumentNotification;
                (function(DidCloseTextDocumentNotification) {
                    DidCloseTextDocumentNotification.method = 'textDocument/didClose';
                    DidCloseTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);
                })(DidCloseTextDocumentNotification = exports1.DidCloseTextDocumentNotification || (exports1.DidCloseTextDocumentNotification = {}));
                /**
 * The document save notification is sent from the client to the server when
 * the document got saved in the client.
 */ var DidSaveTextDocumentNotification;
                (function(DidSaveTextDocumentNotification) {
                    DidSaveTextDocumentNotification.method = 'textDocument/didSave';
                    DidSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);
                })(DidSaveTextDocumentNotification = exports1.DidSaveTextDocumentNotification || (exports1.DidSaveTextDocumentNotification = {}));
                /**
 * Represents reasons why a text document is saved.
 */ var TextDocumentSaveReason;
                (function(TextDocumentSaveReason) {
                    /**
     * Manually triggered, e.g. by the user pressing save, by starting debugging,
     * or by an API call.
     */ TextDocumentSaveReason.Manual = 1;
                    /**
     * Automatic after a delay.
     */ TextDocumentSaveReason.AfterDelay = 2;
                    /**
     * When the editor lost focus.
     */ TextDocumentSaveReason.FocusOut = 3;
                })(TextDocumentSaveReason = exports1.TextDocumentSaveReason || (exports1.TextDocumentSaveReason = {}));
                /**
 * A document will save notification is sent from the client to the server before
 * the document is actually saved.
 */ var WillSaveTextDocumentNotification;
                (function(WillSaveTextDocumentNotification) {
                    WillSaveTextDocumentNotification.method = 'textDocument/willSave';
                    WillSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);
                })(WillSaveTextDocumentNotification = exports1.WillSaveTextDocumentNotification || (exports1.WillSaveTextDocumentNotification = {}));
                /**
 * A document will save request is sent from the client to the server before
 * the document is actually saved. The request can return an array of TextEdits
 * which will be applied to the text document before it is saved. Please note that
 * clients might drop results if computing the text edits took too long or if a
 * server constantly fails on this request. This is done to keep the save fast and
 * reliable.
 */ var WillSaveTextDocumentWaitUntilRequest;
                (function(WillSaveTextDocumentWaitUntilRequest) {
                    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';
                    WillSaveTextDocumentWaitUntilRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);
                })(WillSaveTextDocumentWaitUntilRequest = exports1.WillSaveTextDocumentWaitUntilRequest || (exports1.WillSaveTextDocumentWaitUntilRequest = {}));
                /**
 * The watched files notification is sent from the client to the server when
 * the client detects changes to file watched by the language client.
 */ var DidChangeWatchedFilesNotification;
                (function(DidChangeWatchedFilesNotification) {
                    DidChangeWatchedFilesNotification.method = 'workspace/didChangeWatchedFiles';
                    DidChangeWatchedFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification.method);
                })(DidChangeWatchedFilesNotification = exports1.DidChangeWatchedFilesNotification || (exports1.DidChangeWatchedFilesNotification = {}));
                /**
 * The file event type
 */ var FileChangeType;
                (function(FileChangeType) {
                    /**
     * The file got created.
     */ FileChangeType.Created = 1;
                    /**
     * The file got changed.
     */ FileChangeType.Changed = 2;
                    /**
     * The file got deleted.
     */ FileChangeType.Deleted = 3;
                })(FileChangeType = exports1.FileChangeType || (exports1.FileChangeType = {}));
                var RelativePattern;
                (function(RelativePattern) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
                    }
                    RelativePattern.is = is;
                })(RelativePattern = exports1.RelativePattern || (exports1.RelativePattern = {}));
                var WatchKind;
                (function(WatchKind) {
                    /**
     * Interested in create events.
     */ WatchKind.Create = 1;
                    /**
     * Interested in change events
     */ WatchKind.Change = 2;
                    /**
     * Interested in delete events
     */ WatchKind.Delete = 4;
                })(WatchKind = exports1.WatchKind || (exports1.WatchKind = {}));
                /**
 * Diagnostics notification are sent from the server to the client to signal
 * results of validation runs.
 */ var PublishDiagnosticsNotification;
                (function(PublishDiagnosticsNotification) {
                    PublishDiagnosticsNotification.method = 'textDocument/publishDiagnostics';
                    PublishDiagnosticsNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification.method);
                })(PublishDiagnosticsNotification = exports1.PublishDiagnosticsNotification || (exports1.PublishDiagnosticsNotification = {}));
                /**
 * How a completion was triggered
 */ var CompletionTriggerKind;
                (function(CompletionTriggerKind) {
                    /**
     * Completion was triggered by typing an identifier (24x7 code
     * complete), manual invocation (e.g Ctrl+Space) or via API.
     */ CompletionTriggerKind.Invoked = 1;
                    /**
     * Completion was triggered by a trigger character specified by
     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
     */ CompletionTriggerKind.TriggerCharacter = 2;
                    /**
     * Completion was re-triggered as current completion list is incomplete
     */ CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
                })(CompletionTriggerKind = exports1.CompletionTriggerKind || (exports1.CompletionTriggerKind = {}));
                /**
 * Request to request completion at a given text document position. The request's
 * parameter is of type {@link TextDocumentPosition} the response
 * is of type {@link CompletionItem CompletionItem[]} or {@link CompletionList}
 * or a Thenable that resolves to such.
 *
 * The request can delay the computation of the {@link CompletionItem.detail `detail`}
 * and {@link CompletionItem.documentation `documentation`} properties to the `completionItem/resolve`
 * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
 * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
 */ var CompletionRequest;
                (function(CompletionRequest) {
                    CompletionRequest.method = 'textDocument/completion';
                    CompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);
                })(CompletionRequest = exports1.CompletionRequest || (exports1.CompletionRequest = {}));
                /**
 * Request to resolve additional information for a given completion item.The request's
 * parameter is of type {@link CompletionItem} the response
 * is of type {@link CompletionItem} or a Thenable that resolves to such.
 */ var CompletionResolveRequest;
                (function(CompletionResolveRequest) {
                    CompletionResolveRequest.method = 'completionItem/resolve';
                    CompletionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);
                })(CompletionResolveRequest = exports1.CompletionResolveRequest || (exports1.CompletionResolveRequest = {}));
                /**
 * Request to request hover information at a given text document position. The request's
 * parameter is of type {@link TextDocumentPosition} the response is of
 * type {@link Hover} or a Thenable that resolves to such.
 */ var HoverRequest;
                (function(HoverRequest) {
                    HoverRequest.method = 'textDocument/hover';
                    HoverRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);
                })(HoverRequest = exports1.HoverRequest || (exports1.HoverRequest = {}));
                /**
 * How a signature help was triggered.
 *
 * @since 3.15.0
 */ var SignatureHelpTriggerKind;
                (function(SignatureHelpTriggerKind) {
                    /**
     * Signature help was invoked manually by the user or by a command.
     */ SignatureHelpTriggerKind.Invoked = 1;
                    /**
     * Signature help was triggered by a trigger character.
     */ SignatureHelpTriggerKind.TriggerCharacter = 2;
                    /**
     * Signature help was triggered by the cursor moving or by the document content changing.
     */ SignatureHelpTriggerKind.ContentChange = 3;
                })(SignatureHelpTriggerKind = exports1.SignatureHelpTriggerKind || (exports1.SignatureHelpTriggerKind = {}));
                var SignatureHelpRequest;
                (function(SignatureHelpRequest) {
                    SignatureHelpRequest.method = 'textDocument/signatureHelp';
                    SignatureHelpRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);
                })(SignatureHelpRequest = exports1.SignatureHelpRequest || (exports1.SignatureHelpRequest = {}));
                /**
 * A request to resolve the definition location of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the response is of either type {@link Definition}
 * or a typed array of {@link DefinitionLink} or a Thenable that resolves
 * to such.
 */ var DefinitionRequest;
                (function(DefinitionRequest) {
                    DefinitionRequest.method = 'textDocument/definition';
                    DefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);
                })(DefinitionRequest = exports1.DefinitionRequest || (exports1.DefinitionRequest = {}));
                /**
 * A request to resolve project-wide references for the symbol denoted
 * by the given text document position. The request's parameter is of
 * type {@link ReferenceParams} the response is of type
 * {@link Location Location[]} or a Thenable that resolves to such.
 */ var ReferencesRequest;
                (function(ReferencesRequest) {
                    ReferencesRequest.method = 'textDocument/references';
                    ReferencesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);
                })(ReferencesRequest = exports1.ReferencesRequest || (exports1.ReferencesRequest = {}));
                /**
 * Request to resolve a {@link DocumentHighlight} for a given
 * text document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the request response is of type [DocumentHighlight[]]
 * (#DocumentHighlight) or a Thenable that resolves to such.
 */ var DocumentHighlightRequest;
                (function(DocumentHighlightRequest) {
                    DocumentHighlightRequest.method = 'textDocument/documentHighlight';
                    DocumentHighlightRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);
                })(DocumentHighlightRequest = exports1.DocumentHighlightRequest || (exports1.DocumentHighlightRequest = {}));
                /**
 * A request to list all symbols found in a given text document. The request's
 * parameter is of type {@link TextDocumentIdentifier} the
 * response is of type {@link SymbolInformation SymbolInformation[]} or a Thenable
 * that resolves to such.
 */ var DocumentSymbolRequest;
                (function(DocumentSymbolRequest) {
                    DocumentSymbolRequest.method = 'textDocument/documentSymbol';
                    DocumentSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);
                })(DocumentSymbolRequest = exports1.DocumentSymbolRequest || (exports1.DocumentSymbolRequest = {}));
                /**
 * A request to provide commands for the given text document and range.
 */ var CodeActionRequest;
                (function(CodeActionRequest) {
                    CodeActionRequest.method = 'textDocument/codeAction';
                    CodeActionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);
                })(CodeActionRequest = exports1.CodeActionRequest || (exports1.CodeActionRequest = {}));
                /**
 * Request to resolve additional information for a given code action.The request's
 * parameter is of type {@link CodeAction} the response
 * is of type {@link CodeAction} or a Thenable that resolves to such.
 */ var CodeActionResolveRequest;
                (function(CodeActionResolveRequest) {
                    CodeActionResolveRequest.method = 'codeAction/resolve';
                    CodeActionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeActionResolveRequest.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest.method);
                })(CodeActionResolveRequest = exports1.CodeActionResolveRequest || (exports1.CodeActionResolveRequest = {}));
                /**
 * A request to list project-wide symbols matching the query string given
 * by the {@link WorkspaceSymbolParams}. The response is
 * of type {@link SymbolInformation SymbolInformation[]} or a Thenable that
 * resolves to such.
 *
 * @since 3.17.0 - support for WorkspaceSymbol in the returned data. Clients
 *  need to advertise support for WorkspaceSymbols via the client capability
 *  `workspace.symbol.resolveSupport`.
 *
 */ var WorkspaceSymbolRequest;
                (function(WorkspaceSymbolRequest) {
                    WorkspaceSymbolRequest.method = 'workspace/symbol';
                    WorkspaceSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);
                })(WorkspaceSymbolRequest = exports1.WorkspaceSymbolRequest || (exports1.WorkspaceSymbolRequest = {}));
                /**
 * A request to resolve the range inside the workspace
 * symbol's location.
 *
 * @since 3.17.0
 */ var WorkspaceSymbolResolveRequest;
                (function(WorkspaceSymbolResolveRequest) {
                    WorkspaceSymbolResolveRequest.method = 'workspaceSymbol/resolve';
                    WorkspaceSymbolResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkspaceSymbolResolveRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest.method);
                })(WorkspaceSymbolResolveRequest = exports1.WorkspaceSymbolResolveRequest || (exports1.WorkspaceSymbolResolveRequest = {}));
                /**
 * A request to provide code lens for the given text document.
 */ var CodeLensRequest;
                (function(CodeLensRequest) {
                    CodeLensRequest.method = 'textDocument/codeLens';
                    CodeLensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeLensRequest.type = new messages_1.ProtocolRequestType(CodeLensRequest.method);
                })(CodeLensRequest = exports1.CodeLensRequest || (exports1.CodeLensRequest = {}));
                /**
 * A request to resolve a command for a given code lens.
 */ var CodeLensResolveRequest;
                (function(CodeLensResolveRequest) {
                    CodeLensResolveRequest.method = 'codeLens/resolve';
                    CodeLensResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest.method);
                })(CodeLensResolveRequest = exports1.CodeLensResolveRequest || (exports1.CodeLensResolveRequest = {}));
                /**
 * A request to refresh all code actions
 *
 * @since 3.16.0
 */ var CodeLensRefreshRequest;
                (function(CodeLensRefreshRequest) {
                    CodeLensRefreshRequest.method = `workspace/codeLens/refresh`;
                    CodeLensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    CodeLensRefreshRequest.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest.method);
                })(CodeLensRefreshRequest = exports1.CodeLensRefreshRequest || (exports1.CodeLensRefreshRequest = {}));
                /**
 * A request to provide document links
 */ var DocumentLinkRequest;
                (function(DocumentLinkRequest) {
                    DocumentLinkRequest.method = 'textDocument/documentLink';
                    DocumentLinkRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);
                })(DocumentLinkRequest = exports1.DocumentLinkRequest || (exports1.DocumentLinkRequest = {}));
                /**
 * Request to resolve additional information for a given document link. The request's
 * parameter is of type {@link DocumentLink} the response
 * is of type {@link DocumentLink} or a Thenable that resolves to such.
 */ var DocumentLinkResolveRequest;
                (function(DocumentLinkResolveRequest) {
                    DocumentLinkResolveRequest.method = 'documentLink/resolve';
                    DocumentLinkResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest.method);
                })(DocumentLinkResolveRequest = exports1.DocumentLinkResolveRequest || (exports1.DocumentLinkResolveRequest = {}));
                /**
 * A request to to format a whole document.
 */ var DocumentFormattingRequest;
                (function(DocumentFormattingRequest) {
                    DocumentFormattingRequest.method = 'textDocument/formatting';
                    DocumentFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);
                })(DocumentFormattingRequest = exports1.DocumentFormattingRequest || (exports1.DocumentFormattingRequest = {}));
                /**
 * A request to to format a range in a document.
 */ var DocumentRangeFormattingRequest;
                (function(DocumentRangeFormattingRequest) {
                    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';
                    DocumentRangeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);
                })(DocumentRangeFormattingRequest = exports1.DocumentRangeFormattingRequest || (exports1.DocumentRangeFormattingRequest = {}));
                /**
 * A request to format a document on type.
 */ var DocumentOnTypeFormattingRequest;
                (function(DocumentOnTypeFormattingRequest) {
                    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';
                    DocumentOnTypeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);
                })(DocumentOnTypeFormattingRequest = exports1.DocumentOnTypeFormattingRequest || (exports1.DocumentOnTypeFormattingRequest = {}));
                //---- Rename ----------------------------------------------
                var PrepareSupportDefaultBehavior;
                (function(PrepareSupportDefaultBehavior) {
                    /**
     * The client's default behavior is to select the identifier
     * according the to language's syntax rule.
     */ PrepareSupportDefaultBehavior.Identifier = 1;
                })(PrepareSupportDefaultBehavior = exports1.PrepareSupportDefaultBehavior || (exports1.PrepareSupportDefaultBehavior = {}));
                /**
 * A request to rename a symbol.
 */ var RenameRequest;
                (function(RenameRequest) {
                    RenameRequest.method = 'textDocument/rename';
                    RenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);
                })(RenameRequest = exports1.RenameRequest || (exports1.RenameRequest = {}));
                /**
 * A request to test and perform the setup necessary for a rename.
 *
 * @since 3.16 - support for default behavior
 */ var PrepareRenameRequest;
                (function(PrepareRenameRequest) {
                    PrepareRenameRequest.method = 'textDocument/prepareRename';
                    PrepareRenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);
                })(PrepareRenameRequest = exports1.PrepareRenameRequest || (exports1.PrepareRenameRequest = {}));
                /**
 * A request send from the client to the server to execute a command. The request might return
 * a workspace edit which the client will apply to the workspace.
 */ var ExecuteCommandRequest;
                (function(ExecuteCommandRequest) {
                    ExecuteCommandRequest.method = 'workspace/executeCommand';
                    ExecuteCommandRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest.method);
                })(ExecuteCommandRequest = exports1.ExecuteCommandRequest || (exports1.ExecuteCommandRequest = {}));
                /**
 * A request sent from the server to the client to modified certain resources.
 */ var ApplyWorkspaceEditRequest;
                (function(ApplyWorkspaceEditRequest) {
                    ApplyWorkspaceEditRequest.method = 'workspace/applyEdit';
                    ApplyWorkspaceEditRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');
                })(ApplyWorkspaceEditRequest = exports1.ApplyWorkspaceEditRequest || (exports1.ApplyWorkspaceEditRequest = {}));
            /***/ },
            /***/ 527: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_532180__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LinkedEditingRangeRequest = void 0;
                const messages_1 = __nested_webpack_require_532180__(8599);
                /**
 * A request to provide ranges that can be edited together.
 *
 * @since 3.16.0
 */ var LinkedEditingRangeRequest;
                (function(LinkedEditingRangeRequest) {
                    LinkedEditingRangeRequest.method = 'textDocument/linkedEditingRange';
                    LinkedEditingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    LinkedEditingRangeRequest.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest.method);
                })(LinkedEditingRangeRequest = exports1.LinkedEditingRangeRequest || (exports1.LinkedEditingRangeRequest = {}));
            /***/ },
            /***/ 1964: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_533553__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.MonikerRequest = exports1.MonikerKind = exports1.UniquenessLevel = void 0;
                const messages_1 = __nested_webpack_require_533553__(8599);
                /**
 * Moniker uniqueness level to define scope of the moniker.
 *
 * @since 3.16.0
 */ var UniquenessLevel;
                (function(UniquenessLevel) {
                    /**
     * The moniker is only unique inside a document
     */ UniquenessLevel.document = 'document';
                    /**
     * The moniker is unique inside a project for which a dump got created
     */ UniquenessLevel.project = 'project';
                    /**
     * The moniker is unique inside the group to which a project belongs
     */ UniquenessLevel.group = 'group';
                    /**
     * The moniker is unique inside the moniker scheme.
     */ UniquenessLevel.scheme = 'scheme';
                    /**
     * The moniker is globally unique
     */ UniquenessLevel.global = 'global';
                })(UniquenessLevel = exports1.UniquenessLevel || (exports1.UniquenessLevel = {}));
                /**
 * The moniker kind.
 *
 * @since 3.16.0
 */ var MonikerKind;
                (function(MonikerKind) {
                    /**
     * The moniker represent a symbol that is imported into a project
     */ MonikerKind.$import = 'import';
                    /**
     * The moniker represents a symbol that is exported from a project
     */ MonikerKind.$export = 'export';
                    /**
     * The moniker represents a symbol that is local to a project (e.g. a local
     * variable of a function, a class not visible outside the project, ...)
     */ MonikerKind.local = 'local';
                })(MonikerKind = exports1.MonikerKind || (exports1.MonikerKind = {}));
                /**
 * A request to get the moniker of a symbol at a given text document position.
 * The request parameter is of type {@link TextDocumentPositionParams}.
 * The response is of type {@link Moniker Moniker[]} or `null`.
 */ var MonikerRequest;
                (function(MonikerRequest) {
                    MonikerRequest.method = 'textDocument/moniker';
                    MonikerRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    MonikerRequest.type = new messages_1.ProtocolRequestType(MonikerRequest.method);
                })(MonikerRequest = exports1.MonikerRequest || (exports1.MonikerRequest = {}));
            /***/ },
            /***/ 4460: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_536587__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DidCloseNotebookDocumentNotification = exports1.DidSaveNotebookDocumentNotification = exports1.DidChangeNotebookDocumentNotification = exports1.NotebookCellArrayChange = exports1.DidOpenNotebookDocumentNotification = exports1.NotebookDocumentSyncRegistrationType = exports1.NotebookDocument = exports1.NotebookCell = exports1.ExecutionSummary = exports1.NotebookCellKind = void 0;
                const vscode_languageserver_types_1 = __nested_webpack_require_536587__(4767);
                const Is = __nested_webpack_require_536587__(2523);
                const messages_1 = __nested_webpack_require_536587__(8599);
                /**
 * A notebook cell kind.
 *
 * @since 3.17.0
 */ var NotebookCellKind;
                (function(NotebookCellKind) {
                    /**
     * A markup-cell is formatted source that is used for display.
     */ NotebookCellKind.Markup = 1;
                    /**
     * A code-cell is source code.
     */ NotebookCellKind.Code = 2;
                    function is(value) {
                        return value === 1 || value === 2;
                    }
                    NotebookCellKind.is = is;
                })(NotebookCellKind = exports1.NotebookCellKind || (exports1.NotebookCellKind = {}));
                var ExecutionSummary;
                (function(ExecutionSummary) {
                    function create(executionOrder, success) {
                        const result = {
                            executionOrder
                        };
                        if (success === true || success === false) {
                            result.success = success;
                        }
                        return result;
                    }
                    ExecutionSummary.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === undefined || Is.boolean(candidate.success));
                    }
                    ExecutionSummary.is = is;
                    function equals(one, other) {
                        if (one === other) {
                            return true;
                        }
                        if (one === null || one === undefined || other === null || other === undefined) {
                            return false;
                        }
                        return one.executionOrder === other.executionOrder && one.success === other.success;
                    }
                    ExecutionSummary.equals = equals;
                })(ExecutionSummary = exports1.ExecutionSummary || (exports1.ExecutionSummary = {}));
                var NotebookCell;
                (function(NotebookCell) {
                    function create(kind, document1) {
                        return {
                            kind,
                            document: document1
                        };
                    }
                    NotebookCell.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === undefined || Is.objectLiteral(candidate.metadata));
                    }
                    NotebookCell.is = is;
                    function diff(one, two) {
                        const result = new Set();
                        if (one.document !== two.document) {
                            result.add('document');
                        }
                        if (one.kind !== two.kind) {
                            result.add('kind');
                        }
                        if (one.executionSummary !== two.executionSummary) {
                            result.add('executionSummary');
                        }
                        if ((one.metadata !== undefined || two.metadata !== undefined) && !equalsMetadata(one.metadata, two.metadata)) {
                            result.add('metadata');
                        }
                        if ((one.executionSummary !== undefined || two.executionSummary !== undefined) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
                            result.add('executionSummary');
                        }
                        return result;
                    }
                    NotebookCell.diff = diff;
                    function equalsMetadata(one, other) {
                        if (one === other) {
                            return true;
                        }
                        if (one === null || one === undefined || other === null || other === undefined) {
                            return false;
                        }
                        if (typeof one !== typeof other) {
                            return false;
                        }
                        if (typeof one !== 'object') {
                            return false;
                        }
                        const oneArray = Array.isArray(one);
                        const otherArray = Array.isArray(other);
                        if (oneArray !== otherArray) {
                            return false;
                        }
                        if (oneArray && otherArray) {
                            if (one.length !== other.length) {
                                return false;
                            }
                            for(let i = 0; i < one.length; i++){
                                if (!equalsMetadata(one[i], other[i])) {
                                    return false;
                                }
                            }
                        }
                        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
                            const oneKeys = Object.keys(one);
                            const otherKeys = Object.keys(other);
                            if (oneKeys.length !== otherKeys.length) {
                                return false;
                            }
                            oneKeys.sort();
                            otherKeys.sort();
                            if (!equalsMetadata(oneKeys, otherKeys)) {
                                return false;
                            }
                            for(let i = 0; i < oneKeys.length; i++){
                                const prop = oneKeys[i];
                                if (!equalsMetadata(one[prop], other[prop])) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                })(NotebookCell = exports1.NotebookCell || (exports1.NotebookCell = {}));
                var NotebookDocument;
                (function(NotebookDocument) {
                    function create(uri, notebookType, version, cells) {
                        return {
                            uri,
                            notebookType,
                            version,
                            cells
                        };
                    }
                    NotebookDocument.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
                    }
                    NotebookDocument.is = is;
                })(NotebookDocument = exports1.NotebookDocument || (exports1.NotebookDocument = {}));
                var NotebookDocumentSyncRegistrationType;
                (function(NotebookDocumentSyncRegistrationType) {
                    NotebookDocumentSyncRegistrationType.method = 'notebookDocument/sync';
                    NotebookDocumentSyncRegistrationType.messageDirection = messages_1.MessageDirection.clientToServer;
                    NotebookDocumentSyncRegistrationType.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType.method);
                })(NotebookDocumentSyncRegistrationType = exports1.NotebookDocumentSyncRegistrationType || (exports1.NotebookDocumentSyncRegistrationType = {}));
                /**
 * A notification sent when a notebook opens.
 *
 * @since 3.17.0
 */ var DidOpenNotebookDocumentNotification;
                (function(DidOpenNotebookDocumentNotification) {
                    DidOpenNotebookDocumentNotification.method = 'notebookDocument/didOpen';
                    DidOpenNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidOpenNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification.method);
                    DidOpenNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidOpenNotebookDocumentNotification = exports1.DidOpenNotebookDocumentNotification || (exports1.DidOpenNotebookDocumentNotification = {}));
                var NotebookCellArrayChange;
                (function(NotebookCellArrayChange) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === undefined || Is.typedArray(candidate.cells, NotebookCell.is));
                    }
                    NotebookCellArrayChange.is = is;
                    function create(start, deleteCount, cells) {
                        const result = {
                            start,
                            deleteCount
                        };
                        if (cells !== undefined) {
                            result.cells = cells;
                        }
                        return result;
                    }
                    NotebookCellArrayChange.create = create;
                })(NotebookCellArrayChange = exports1.NotebookCellArrayChange || (exports1.NotebookCellArrayChange = {}));
                var DidChangeNotebookDocumentNotification;
                (function(DidChangeNotebookDocumentNotification) {
                    DidChangeNotebookDocumentNotification.method = 'notebookDocument/didChange';
                    DidChangeNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification.method);
                    DidChangeNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidChangeNotebookDocumentNotification = exports1.DidChangeNotebookDocumentNotification || (exports1.DidChangeNotebookDocumentNotification = {}));
                /**
 * A notification sent when a notebook document is saved.
 *
 * @since 3.17.0
 */ var DidSaveNotebookDocumentNotification;
                (function(DidSaveNotebookDocumentNotification) {
                    DidSaveNotebookDocumentNotification.method = 'notebookDocument/didSave';
                    DidSaveNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidSaveNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification.method);
                    DidSaveNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidSaveNotebookDocumentNotification = exports1.DidSaveNotebookDocumentNotification || (exports1.DidSaveNotebookDocumentNotification = {}));
                /**
 * A notification sent when a notebook closes.
 *
 * @since 3.17.0
 */ var DidCloseNotebookDocumentNotification;
                (function(DidCloseNotebookDocumentNotification) {
                    DidCloseNotebookDocumentNotification.method = 'notebookDocument/didClose';
                    DidCloseNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidCloseNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification.method);
                    DidCloseNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidCloseNotebookDocumentNotification = exports1.DidCloseNotebookDocumentNotification || (exports1.DidCloseNotebookDocumentNotification = {}));
            /***/ },
            /***/ 7895: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_550164__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WorkDoneProgressCancelNotification = exports1.WorkDoneProgressCreateRequest = exports1.WorkDoneProgress = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_550164__(5953);
                const messages_1 = __nested_webpack_require_550164__(8599);
                var WorkDoneProgress;
                (function(WorkDoneProgress) {
                    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();
                    function is(value) {
                        return value === WorkDoneProgress.type;
                    }
                    WorkDoneProgress.is = is;
                })(WorkDoneProgress = exports1.WorkDoneProgress || (exports1.WorkDoneProgress = {}));
                /**
 * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress
 * reporting from the server.
 */ var WorkDoneProgressCreateRequest;
                (function(WorkDoneProgressCreateRequest) {
                    WorkDoneProgressCreateRequest.method = 'window/workDoneProgress/create';
                    WorkDoneProgressCreateRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest.method);
                })(WorkDoneProgressCreateRequest = exports1.WorkDoneProgressCreateRequest || (exports1.WorkDoneProgressCreateRequest = {}));
                /**
 * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
 * initiated on the server side.
 */ var WorkDoneProgressCancelNotification;
                (function(WorkDoneProgressCancelNotification) {
                    WorkDoneProgressCancelNotification.method = 'window/workDoneProgress/cancel';
                    WorkDoneProgressCancelNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification.method);
                })(WorkDoneProgressCancelNotification = exports1.WorkDoneProgressCancelNotification || (exports1.WorkDoneProgressCancelNotification = {}));
            /***/ },
            /***/ 2392: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_553005__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.SelectionRangeRequest = void 0;
                const messages_1 = __nested_webpack_require_553005__(8599);
                /**
 * A request to provide selection ranges in a document. The request's
 * parameter is of type {@link SelectionRangeParams}, the
 * response is of type {@link SelectionRange SelectionRange[]} or a Thenable
 * that resolves to such.
 */ var SelectionRangeRequest;
                (function(SelectionRangeRequest) {
                    SelectionRangeRequest.method = 'textDocument/selectionRange';
                    SelectionRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);
                })(SelectionRangeRequest = exports1.SelectionRangeRequest || (exports1.SelectionRangeRequest = {}));
            /***/ },
            /***/ 8489: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_554485__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.SemanticTokensRefreshRequest = exports1.SemanticTokensRangeRequest = exports1.SemanticTokensDeltaRequest = exports1.SemanticTokensRequest = exports1.SemanticTokensRegistrationType = exports1.TokenFormat = void 0;
                const messages_1 = __nested_webpack_require_554485__(8599);
                //------- 'textDocument/semanticTokens' -----
                var TokenFormat;
                (function(TokenFormat) {
                    TokenFormat.Relative = 'relative';
                })(TokenFormat = exports1.TokenFormat || (exports1.TokenFormat = {}));
                var SemanticTokensRegistrationType;
                (function(SemanticTokensRegistrationType) {
                    SemanticTokensRegistrationType.method = 'textDocument/semanticTokens';
                    SemanticTokensRegistrationType.type = new messages_1.RegistrationType(SemanticTokensRegistrationType.method);
                })(SemanticTokensRegistrationType = exports1.SemanticTokensRegistrationType || (exports1.SemanticTokensRegistrationType = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensRequest;
                (function(SemanticTokensRequest) {
                    SemanticTokensRequest.method = 'textDocument/semanticTokens/full';
                    SemanticTokensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);
                    SemanticTokensRequest.registrationMethod = SemanticTokensRegistrationType.method;
                })(SemanticTokensRequest = exports1.SemanticTokensRequest || (exports1.SemanticTokensRequest = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensDeltaRequest;
                (function(SemanticTokensDeltaRequest) {
                    SemanticTokensDeltaRequest.method = 'textDocument/semanticTokens/full/delta';
                    SemanticTokensDeltaRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensDeltaRequest.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest.method);
                    SemanticTokensDeltaRequest.registrationMethod = SemanticTokensRegistrationType.method;
                })(SemanticTokensDeltaRequest = exports1.SemanticTokensDeltaRequest || (exports1.SemanticTokensDeltaRequest = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensRangeRequest;
                (function(SemanticTokensRangeRequest) {
                    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';
                    SemanticTokensRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);
                    SemanticTokensRangeRequest.registrationMethod = SemanticTokensRegistrationType.method;
                })(SemanticTokensRangeRequest = exports1.SemanticTokensRangeRequest || (exports1.SemanticTokensRangeRequest = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensRefreshRequest;
                (function(SemanticTokensRefreshRequest) {
                    SemanticTokensRefreshRequest.method = `workspace/semanticTokens/refresh`;
                    SemanticTokensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    SemanticTokensRefreshRequest.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest.method);
                })(SemanticTokensRefreshRequest = exports1.SemanticTokensRefreshRequest || (exports1.SemanticTokensRefreshRequest = {}));
            /***/ },
            /***/ 1541: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_558796__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ShowDocumentRequest = void 0;
                const messages_1 = __nested_webpack_require_558796__(8599);
                /**
 * A request to show a document. This request might open an
 * external program depending on the value of the URI to open.
 * For example a request to open `https://code.visualstudio.com/`
 * will very likely open the URI in a WEB browser.
 *
 * @since 3.16.0
*/ var ShowDocumentRequest;
                (function(ShowDocumentRequest) {
                    ShowDocumentRequest.method = 'window/showDocument';
                    ShowDocumentRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ShowDocumentRequest.type = new messages_1.ProtocolRequestType(ShowDocumentRequest.method);
                })(ShowDocumentRequest = exports1.ShowDocumentRequest || (exports1.ShowDocumentRequest = {}));
            /***/ },
            /***/ 8642: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_560274__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.TypeDefinitionRequest = void 0;
                const messages_1 = __nested_webpack_require_560274__(8599);
                // @ts-ignore: to avoid inlining LocatioLink as dynamic import
                let __noDynamicImport;
                /**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositionParams]
 * (#TextDocumentPositionParams) the response is of type {@link Definition} or a
 * Thenable that resolves to such.
 */ var TypeDefinitionRequest;
                (function(TypeDefinitionRequest) {
                    TypeDefinitionRequest.method = 'textDocument/typeDefinition';
                    TypeDefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);
                })(TypeDefinitionRequest = exports1.TypeDefinitionRequest || (exports1.TypeDefinitionRequest = {}));
            /***/ },
            /***/ 5318: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_561923__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.TypeHierarchySubtypesRequest = exports1.TypeHierarchySupertypesRequest = exports1.TypeHierarchyPrepareRequest = void 0;
                const messages_1 = __nested_webpack_require_561923__(8599);
                /**
 * A request to result a `TypeHierarchyItem` in a document at a given position.
 * Can be used as an input to a subtypes or supertypes type hierarchy.
 *
 * @since 3.17.0
 */ var TypeHierarchyPrepareRequest;
                (function(TypeHierarchyPrepareRequest) {
                    TypeHierarchyPrepareRequest.method = 'textDocument/prepareTypeHierarchy';
                    TypeHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest.method);
                })(TypeHierarchyPrepareRequest = exports1.TypeHierarchyPrepareRequest || (exports1.TypeHierarchyPrepareRequest = {}));
                /**
 * A request to resolve the supertypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */ var TypeHierarchySupertypesRequest;
                (function(TypeHierarchySupertypesRequest) {
                    TypeHierarchySupertypesRequest.method = 'typeHierarchy/supertypes';
                    TypeHierarchySupertypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeHierarchySupertypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest.method);
                })(TypeHierarchySupertypesRequest = exports1.TypeHierarchySupertypesRequest || (exports1.TypeHierarchySupertypesRequest = {}));
                /**
 * A request to resolve the subtypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */ var TypeHierarchySubtypesRequest;
                (function(TypeHierarchySubtypesRequest) {
                    TypeHierarchySubtypesRequest.method = 'typeHierarchy/subtypes';
                    TypeHierarchySubtypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeHierarchySubtypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest.method);
                })(TypeHierarchySubtypesRequest = exports1.TypeHierarchySubtypesRequest || (exports1.TypeHierarchySubtypesRequest = {}));
            /***/ },
            /***/ 3402: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_564857__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DidChangeWorkspaceFoldersNotification = exports1.WorkspaceFoldersRequest = void 0;
                const messages_1 = __nested_webpack_require_564857__(8599);
                /**
 * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
 */ var WorkspaceFoldersRequest;
                (function(WorkspaceFoldersRequest) {
                    WorkspaceFoldersRequest.method = 'workspace/workspaceFolders';
                    WorkspaceFoldersRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest.method);
                })(WorkspaceFoldersRequest = exports1.WorkspaceFoldersRequest || (exports1.WorkspaceFoldersRequest = {}));
                /**
 * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
 * folder configuration changes.
 */ var DidChangeWorkspaceFoldersNotification;
                (function(DidChangeWorkspaceFoldersNotification) {
                    DidChangeWorkspaceFoldersNotification.method = 'workspace/didChangeWorkspaceFolders';
                    DidChangeWorkspaceFoldersNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification.method);
                })(DidChangeWorkspaceFoldersNotification = exports1.DidChangeWorkspaceFoldersNotification || (exports1.DidChangeWorkspaceFoldersNotification = {}));
            /***/ },
            /***/ 2523: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.objectLiteral = exports1.typedArray = exports1.stringArray = exports1.array = exports1.func = exports1.error = exports1.number = exports1.string = exports1.boolean = void 0;
                function boolean(value) {
                    return value === true || value === false;
                }
                exports1.boolean = boolean;
                function string(value) {
                    return typeof value === 'string' || value instanceof String;
                }
                exports1.string = string;
                function number(value) {
                    return typeof value === 'number' || value instanceof Number;
                }
                exports1.number = number;
                function error(value) {
                    return value instanceof Error;
                }
                exports1.error = error;
                function func(value) {
                    return typeof value === 'function';
                }
                exports1.func = func;
                function array(value) {
                    return Array.isArray(value);
                }
                exports1.array = array;
                function stringArray(value) {
                    return array(value) && value.every((elem)=>string(elem));
                }
                exports1.stringArray = stringArray;
                function typedArray(value, check) {
                    return Array.isArray(value) && value.every(check);
                }
                exports1.typedArray = typedArray;
                function objectLiteral(value) {
                    // Strictly speaking class instances pass this check as well. Since the LSP
                    // doesn't use classes we ignore this for now. If we do we need to add something
                    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
                    return value !== null && typeof value === 'object';
                }
                exports1.objectLiteral = objectLiteral;
            /***/ },
            /***/ 4881: /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_569752__)=>{
                "use strict";
                /* harmony export */ __nested_webpack_require_569752__.d(__nested_webpack_exports__, {
                    /* harmony export */ n: ()=>/* binding */ TextDocument
                });
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __spreadArray =  false || function(to, from, pack) {
                    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
                        if (ar || !(i in from)) {
                            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                            ar[i] = from[i];
                        }
                    }
                    return to.concat(ar || Array.prototype.slice.call(from));
                };
                var FullTextDocument = /** @class */ function() {
                    function FullTextDocument(uri, languageId, version, content) {
                        this._uri = uri;
                        this._languageId = languageId;
                        this._version = version;
                        this._content = content;
                        this._lineOffsets = undefined;
                    }
                    Object.defineProperty(FullTextDocument.prototype, "uri", {
                        get: function() {
                            return this._uri;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(FullTextDocument.prototype, "languageId", {
                        get: function() {
                            return this._languageId;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(FullTextDocument.prototype, "version", {
                        get: function() {
                            return this._version;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    FullTextDocument.prototype.getText = function(range) {
                        if (range) {
                            var start = this.offsetAt(range.start);
                            var end = this.offsetAt(range.end);
                            return this._content.substring(start, end);
                        }
                        return this._content;
                    };
                    FullTextDocument.prototype.update = function(changes, version) {
                        for(var _i = 0, changes_1 = changes; _i < changes_1.length; _i++){
                            var change = changes_1[_i];
                            if (FullTextDocument.isIncremental(change)) {
                                // makes sure start is before end
                                var range = getWellformedRange(change.range);
                                // update content
                                var startOffset = this.offsetAt(range.start);
                                var endOffset = this.offsetAt(range.end);
                                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
                                // update the offsets
                                var startLine = Math.max(range.start.line, 0);
                                var endLine = Math.max(range.end.line, 0);
                                var lineOffsets = this._lineOffsets;
                                var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
                                if (endLine - startLine === addedLineOffsets.length) {
                                    for(var i = 0, len = addedLineOffsets.length; i < len; i++){
                                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];
                                    }
                                } else {
                                    if (addedLineOffsets.length < 10000) {
                                        lineOffsets.splice.apply(lineOffsets, __spreadArray([
                                            startLine + 1,
                                            endLine - startLine
                                        ], addedLineOffsets, false));
                                    } else {
                                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
                                    }
                                }
                                var diff = change.text.length - (endOffset - startOffset);
                                if (diff !== 0) {
                                    for(var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++){
                                        lineOffsets[i] = lineOffsets[i] + diff;
                                    }
                                }
                            } else if (FullTextDocument.isFull(change)) {
                                this._content = change.text;
                                this._lineOffsets = undefined;
                            } else {
                                throw new Error('Unknown change event received');
                            }
                        }
                        this._version = version;
                    };
                    FullTextDocument.prototype.getLineOffsets = function() {
                        if (this._lineOffsets === undefined) {
                            this._lineOffsets = computeLineOffsets(this._content, true);
                        }
                        return this._lineOffsets;
                    };
                    FullTextDocument.prototype.positionAt = function(offset) {
                        offset = Math.max(Math.min(offset, this._content.length), 0);
                        var lineOffsets = this.getLineOffsets();
                        var low = 0, high = lineOffsets.length;
                        if (high === 0) {
                            return {
                                line: 0,
                                character: offset
                            };
                        }
                        while(low < high){
                            var mid = Math.floor((low + high) / 2);
                            if (lineOffsets[mid] > offset) {
                                high = mid;
                            } else {
                                low = mid + 1;
                            }
                        }
                        // low is the least x for which the line offset is larger than the current offset
                        // or array.length if no line offset is larger than the current offset
                        var line = low - 1;
                        return {
                            line: line,
                            character: offset - lineOffsets[line]
                        };
                    };
                    FullTextDocument.prototype.offsetAt = function(position) {
                        var lineOffsets = this.getLineOffsets();
                        if (position.line >= lineOffsets.length) {
                            return this._content.length;
                        } else if (position.line < 0) {
                            return 0;
                        }
                        var lineOffset = lineOffsets[position.line];
                        var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
                        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
                    };
                    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
                        get: function() {
                            return this.getLineOffsets().length;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    FullTextDocument.isIncremental = function(event) {
                        var candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range !== undefined && (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
                    };
                    FullTextDocument.isFull = function(event) {
                        var candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
                    };
                    return FullTextDocument;
                }();
                var TextDocument;
                (function(TextDocument) {
                    /**
     * Creates a new text document.
     *
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param version The document's initial version number.
     * @param content The document's content.
     */ function create(uri, languageId, version, content) {
                        return new FullTextDocument(uri, languageId, version, content);
                    }
                    TextDocument.create = create;
                    /**
     * Updates a TextDocument by modifying its content.
     *
     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.
     * @param changes the changes to apply to the document.
     * @param version the changes version for the document.
     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.
     *
     */ function update(document1, changes, version) {
                        if (document1 instanceof FullTextDocument) {
                            document1.update(changes, version);
                            return document1;
                        } else {
                            throw new Error('TextDocument.update: document must be created by TextDocument.create');
                        }
                    }
                    TextDocument.update = update;
                    function applyEdits(document1, edits) {
                        var text = document1.getText();
                        var sortedEdits = mergeSort(edits.map(getWellformedEdit), function(a, b) {
                            var diff = a.range.start.line - b.range.start.line;
                            if (diff === 0) {
                                return a.range.start.character - b.range.start.character;
                            }
                            return diff;
                        });
                        var lastModifiedOffset = 0;
                        var spans = [];
                        for(var _i = 0, sortedEdits_1 = sortedEdits; _i < sortedEdits_1.length; _i++){
                            var e = sortedEdits_1[_i];
                            var startOffset = document1.offsetAt(e.range.start);
                            if (startOffset < lastModifiedOffset) {
                                throw new Error('Overlapping edit');
                            } else if (startOffset > lastModifiedOffset) {
                                spans.push(text.substring(lastModifiedOffset, startOffset));
                            }
                            if (e.newText.length) {
                                spans.push(e.newText);
                            }
                            lastModifiedOffset = document1.offsetAt(e.range.end);
                        }
                        spans.push(text.substr(lastModifiedOffset));
                        return spans.join('');
                    }
                    TextDocument.applyEdits = applyEdits;
                })(TextDocument || (TextDocument = {}));
                function mergeSort(data, compare) {
                    if (data.length <= 1) {
                        // sorted
                        return data;
                    }
                    var p = data.length / 2 | 0;
                    var left = data.slice(0, p);
                    var right = data.slice(p);
                    mergeSort(left, compare);
                    mergeSort(right, compare);
                    var leftIdx = 0;
                    var rightIdx = 0;
                    var i = 0;
                    while(leftIdx < left.length && rightIdx < right.length){
                        var ret = compare(left[leftIdx], right[rightIdx]);
                        if (ret <= 0) {
                            // smaller_equal -> take left to preserve order
                            data[i++] = left[leftIdx++];
                        } else {
                            // greater -> take right
                            data[i++] = right[rightIdx++];
                        }
                    }
                    while(leftIdx < left.length){
                        data[i++] = left[leftIdx++];
                    }
                    while(rightIdx < right.length){
                        data[i++] = right[rightIdx++];
                    }
                    return data;
                }
                function computeLineOffsets(text, isAtLineStart, textOffset) {
                    if (textOffset === void 0) {
                        textOffset = 0;
                    }
                    var result = isAtLineStart ? [
                        textOffset
                    ] : [];
                    for(var i = 0; i < text.length; i++){
                        var ch = text.charCodeAt(i);
                        if (ch === 13 /* CharCode.CarriageReturn */  || ch === 10 /* CharCode.LineFeed */ ) {
                            if (ch === 13 /* CharCode.CarriageReturn */  && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */ ) {
                                i++;
                            }
                            result.push(textOffset + i + 1);
                        }
                    }
                    return result;
                }
                function getWellformedRange(range) {
                    var start = range.start;
                    var end = range.end;
                    if (start.line > end.line || start.line === end.line && start.character > end.character) {
                        return {
                            start: end,
                            end: start
                        };
                    }
                    return range;
                }
                function getWellformedEdit(textEdit) {
                    var range = getWellformedRange(textEdit.range);
                    if (range !== textEdit.range) {
                        return {
                            newText: textEdit.newText,
                            range: range
                        };
                    }
                    return textEdit;
                }
            /***/ },
            /***/ 4767: /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_585576__)=>{
                "use strict";
                __nested_webpack_require_585576__.r(__nested_webpack_exports__);
                /* harmony export */ __nested_webpack_require_585576__.d(__nested_webpack_exports__, {
                    /* harmony export */ AnnotatedTextEdit: ()=>/* binding */ AnnotatedTextEdit,
                    /* harmony export */ ChangeAnnotation: ()=>/* binding */ ChangeAnnotation,
                    /* harmony export */ ChangeAnnotationIdentifier: ()=>/* binding */ ChangeAnnotationIdentifier,
                    /* harmony export */ CodeAction: ()=>/* binding */ CodeAction,
                    /* harmony export */ CodeActionContext: ()=>/* binding */ CodeActionContext,
                    /* harmony export */ CodeActionKind: ()=>/* binding */ CodeActionKind,
                    /* harmony export */ CodeActionTriggerKind: ()=>/* binding */ CodeActionTriggerKind,
                    /* harmony export */ CodeDescription: ()=>/* binding */ CodeDescription,
                    /* harmony export */ CodeLens: ()=>/* binding */ CodeLens,
                    /* harmony export */ Color: ()=>/* binding */ Color,
                    /* harmony export */ ColorInformation: ()=>/* binding */ ColorInformation,
                    /* harmony export */ ColorPresentation: ()=>/* binding */ ColorPresentation,
                    /* harmony export */ Command: ()=>/* binding */ Command,
                    /* harmony export */ CompletionItem: ()=>/* binding */ CompletionItem,
                    /* harmony export */ CompletionItemKind: ()=>/* binding */ CompletionItemKind,
                    /* harmony export */ CompletionItemLabelDetails: ()=>/* binding */ CompletionItemLabelDetails,
                    /* harmony export */ CompletionItemTag: ()=>/* binding */ CompletionItemTag,
                    /* harmony export */ CompletionList: ()=>/* binding */ CompletionList,
                    /* harmony export */ CreateFile: ()=>/* binding */ CreateFile,
                    /* harmony export */ DeleteFile: ()=>/* binding */ DeleteFile,
                    /* harmony export */ Diagnostic: ()=>/* binding */ Diagnostic,
                    /* harmony export */ DiagnosticRelatedInformation: ()=>/* binding */ DiagnosticRelatedInformation,
                    /* harmony export */ DiagnosticSeverity: ()=>/* binding */ DiagnosticSeverity,
                    /* harmony export */ DiagnosticTag: ()=>/* binding */ DiagnosticTag,
                    /* harmony export */ DocumentHighlight: ()=>/* binding */ DocumentHighlight,
                    /* harmony export */ DocumentHighlightKind: ()=>/* binding */ DocumentHighlightKind,
                    /* harmony export */ DocumentLink: ()=>/* binding */ DocumentLink,
                    /* harmony export */ DocumentSymbol: ()=>/* binding */ DocumentSymbol,
                    /* harmony export */ DocumentUri: ()=>/* binding */ DocumentUri,
                    /* harmony export */ EOL: ()=>/* binding */ EOL,
                    /* harmony export */ FoldingRange: ()=>/* binding */ FoldingRange,
                    /* harmony export */ FoldingRangeKind: ()=>/* binding */ FoldingRangeKind,
                    /* harmony export */ FormattingOptions: ()=>/* binding */ FormattingOptions,
                    /* harmony export */ Hover: ()=>/* binding */ Hover,
                    /* harmony export */ InlayHint: ()=>/* binding */ InlayHint,
                    /* harmony export */ InlayHintKind: ()=>/* binding */ InlayHintKind,
                    /* harmony export */ InlayHintLabelPart: ()=>/* binding */ InlayHintLabelPart,
                    /* harmony export */ InlineValueContext: ()=>/* binding */ InlineValueContext,
                    /* harmony export */ InlineValueEvaluatableExpression: ()=>/* binding */ InlineValueEvaluatableExpression,
                    /* harmony export */ InlineValueText: ()=>/* binding */ InlineValueText,
                    /* harmony export */ InlineValueVariableLookup: ()=>/* binding */ InlineValueVariableLookup,
                    /* harmony export */ InsertReplaceEdit: ()=>/* binding */ InsertReplaceEdit,
                    /* harmony export */ InsertTextFormat: ()=>/* binding */ InsertTextFormat,
                    /* harmony export */ InsertTextMode: ()=>/* binding */ InsertTextMode,
                    /* harmony export */ Location: ()=>/* binding */ Location,
                    /* harmony export */ LocationLink: ()=>/* binding */ LocationLink,
                    /* harmony export */ MarkedString: ()=>/* binding */ MarkedString,
                    /* harmony export */ MarkupContent: ()=>/* binding */ MarkupContent,
                    /* harmony export */ MarkupKind: ()=>/* binding */ MarkupKind,
                    /* harmony export */ OptionalVersionedTextDocumentIdentifier: ()=>/* binding */ OptionalVersionedTextDocumentIdentifier,
                    /* harmony export */ ParameterInformation: ()=>/* binding */ ParameterInformation,
                    /* harmony export */ Position: ()=>/* binding */ Position,
                    /* harmony export */ Range: ()=>/* binding */ Range,
                    /* harmony export */ RenameFile: ()=>/* binding */ RenameFile,
                    /* harmony export */ SelectionRange: ()=>/* binding */ SelectionRange,
                    /* harmony export */ SemanticTokenModifiers: ()=>/* binding */ SemanticTokenModifiers,
                    /* harmony export */ SemanticTokenTypes: ()=>/* binding */ SemanticTokenTypes,
                    /* harmony export */ SemanticTokens: ()=>/* binding */ SemanticTokens,
                    /* harmony export */ SignatureInformation: ()=>/* binding */ SignatureInformation,
                    /* harmony export */ SymbolInformation: ()=>/* binding */ SymbolInformation,
                    /* harmony export */ SymbolKind: ()=>/* binding */ SymbolKind,
                    /* harmony export */ SymbolTag: ()=>/* binding */ SymbolTag,
                    /* harmony export */ TextDocument: ()=>/* binding */ TextDocument,
                    /* harmony export */ TextDocumentEdit: ()=>/* binding */ TextDocumentEdit,
                    /* harmony export */ TextDocumentIdentifier: ()=>/* binding */ TextDocumentIdentifier,
                    /* harmony export */ TextDocumentItem: ()=>/* binding */ TextDocumentItem,
                    /* harmony export */ TextEdit: ()=>/* binding */ TextEdit,
                    /* harmony export */ URI: ()=>/* binding */ URI,
                    /* harmony export */ VersionedTextDocumentIdentifier: ()=>/* binding */ VersionedTextDocumentIdentifier,
                    /* harmony export */ WorkspaceChange: ()=>/* binding */ WorkspaceChange,
                    /* harmony export */ WorkspaceEdit: ()=>/* binding */ WorkspaceEdit,
                    /* harmony export */ WorkspaceFolder: ()=>/* binding */ WorkspaceFolder,
                    /* harmony export */ WorkspaceSymbol: ()=>/* binding */ WorkspaceSymbol,
                    /* harmony export */ integer: ()=>/* binding */ integer,
                    /* harmony export */ uinteger: ()=>/* binding */ uinteger
                });
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var DocumentUri;
                (function(DocumentUri) {
                    function is(value) {
                        return typeof value === 'string';
                    }
                    DocumentUri.is = is;
                })(DocumentUri || (DocumentUri = {}));
                var URI;
                (function(URI) {
                    function is(value) {
                        return typeof value === 'string';
                    }
                    URI.is = is;
                })(URI || (URI = {}));
                var integer;
                (function(integer) {
                    integer.MIN_VALUE = -2147483648;
                    integer.MAX_VALUE = 2147483647;
                    function is(value) {
                        return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;
                    }
                    integer.is = is;
                })(integer || (integer = {}));
                var uinteger;
                (function(uinteger) {
                    uinteger.MIN_VALUE = 0;
                    uinteger.MAX_VALUE = 2147483647;
                    function is(value) {
                        return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;
                    }
                    uinteger.is = is;
                })(uinteger || (uinteger = {}));
                /**
 * The Position namespace provides helper functions to work with
 * {@link Position} literals.
 */ var Position;
                (function(Position) {
                    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */ function create(line, character) {
                        if (line === Number.MAX_VALUE) {
                            line = uinteger.MAX_VALUE;
                        }
                        if (character === Number.MAX_VALUE) {
                            character = uinteger.MAX_VALUE;
                        }
                        return {
                            line: line,
                            character: character
                        };
                    }
                    Position.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Position} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
                    }
                    Position.is = is;
                })(Position || (Position = {}));
                /**
 * The Range namespace provides helper functions to work with
 * {@link Range} literals.
 */ var Range;
                (function(Range) {
                    function create(one, two, three, four) {
                        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
                            return {
                                start: Position.create(one, two),
                                end: Position.create(three, four)
                            };
                        } else if (Position.is(one) && Position.is(two)) {
                            return {
                                start: one,
                                end: two
                            };
                        } else {
                            throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
                        }
                    }
                    Range.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Range} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
                    }
                    Range.is = is;
                })(Range || (Range = {}));
                /**
 * The Location namespace provides helper functions to work with
 * {@link Location} literals.
 */ var Location;
                (function(Location) {
                    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */ function create(uri, range) {
                        return {
                            uri: uri,
                            range: range
                        };
                    }
                    Location.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Location} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
                    }
                    Location.is = is;
                })(Location || (Location = {}));
                /**
 * The LocationLink namespace provides helper functions to work with
 * {@link LocationLink} literals.
 */ var LocationLink;
                (function(LocationLink) {
                    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */ function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
                        return {
                            targetUri: targetUri,
                            targetRange: targetRange,
                            targetSelectionRange: targetSelectionRange,
                            originSelectionRange: originSelectionRange
                        };
                    }
                    LocationLink.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link LocationLink} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
                    }
                    LocationLink.is = is;
                })(LocationLink || (LocationLink = {}));
                /**
 * The Color namespace provides helper functions to work with
 * {@link Color} literals.
 */ var Color;
                (function(Color) {
                    /**
     * Creates a new Color literal.
     */ function create(red, green, blue, alpha) {
                        return {
                            red: red,
                            green: green,
                            blue: blue,
                            alpha: alpha
                        };
                    }
                    Color.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Color} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
                    }
                    Color.is = is;
                })(Color || (Color = {}));
                /**
 * The ColorInformation namespace provides helper functions to work with
 * {@link ColorInformation} literals.
 */ var ColorInformation;
                (function(ColorInformation) {
                    /**
     * Creates a new ColorInformation literal.
     */ function create(range, color) {
                        return {
                            range: range,
                            color: color
                        };
                    }
                    ColorInformation.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
                    }
                    ColorInformation.is = is;
                })(ColorInformation || (ColorInformation = {}));
                /**
 * The Color namespace provides helper functions to work with
 * {@link ColorPresentation} literals.
 */ var ColorPresentation;
                (function(ColorPresentation) {
                    /**
     * Creates a new ColorInformation literal.
     */ function create(label, textEdit, additionalTextEdits) {
                        return {
                            label: label,
                            textEdit: textEdit,
                            additionalTextEdits: additionalTextEdits
                        };
                    }
                    ColorPresentation.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
                    }
                    ColorPresentation.is = is;
                })(ColorPresentation || (ColorPresentation = {}));
                /**
 * A set of predefined range kinds.
 */ var FoldingRangeKind;
                (function(FoldingRangeKind) {
                    /**
     * Folding range for a comment
     */ FoldingRangeKind.Comment = 'comment';
                    /**
     * Folding range for an import or include
     */ FoldingRangeKind.Imports = 'imports';
                    /**
     * Folding range for a region (e.g. `#region`)
     */ FoldingRangeKind.Region = 'region';
                })(FoldingRangeKind || (FoldingRangeKind = {}));
                /**
 * The folding range namespace provides helper functions to work with
 * {@link FoldingRange} literals.
 */ var FoldingRange;
                (function(FoldingRange) {
                    /**
     * Creates a new FoldingRange literal.
     */ function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
                        var result = {
                            startLine: startLine,
                            endLine: endLine
                        };
                        if (Is.defined(startCharacter)) {
                            result.startCharacter = startCharacter;
                        }
                        if (Is.defined(endCharacter)) {
                            result.endCharacter = endCharacter;
                        }
                        if (Is.defined(kind)) {
                            result.kind = kind;
                        }
                        if (Is.defined(collapsedText)) {
                            result.collapsedText = collapsedText;
                        }
                        return result;
                    }
                    FoldingRange.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link FoldingRange} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
                    }
                    FoldingRange.is = is;
                })(FoldingRange || (FoldingRange = {}));
                /**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * {@link DiagnosticRelatedInformation} literals.
 */ var DiagnosticRelatedInformation;
                (function(DiagnosticRelatedInformation) {
                    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */ function create(location, message) {
                        return {
                            location: location,
                            message: message
                        };
                    }
                    DiagnosticRelatedInformation.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
                    }
                    DiagnosticRelatedInformation.is = is;
                })(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
                /**
 * The diagnostic's severity.
 */ var DiagnosticSeverity;
                (function(DiagnosticSeverity) {
                    /**
     * Reports an error.
     */ DiagnosticSeverity.Error = 1;
                    /**
     * Reports a warning.
     */ DiagnosticSeverity.Warning = 2;
                    /**
     * Reports an information.
     */ DiagnosticSeverity.Information = 3;
                    /**
     * Reports a hint.
     */ DiagnosticSeverity.Hint = 4;
                })(DiagnosticSeverity || (DiagnosticSeverity = {}));
                /**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */ var DiagnosticTag;
                (function(DiagnosticTag) {
                    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */ DiagnosticTag.Unnecessary = 1;
                    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */ DiagnosticTag.Deprecated = 2;
                })(DiagnosticTag || (DiagnosticTag = {}));
                /**
 * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
 *
 * @since 3.16.0
 */ var CodeDescription;
                (function(CodeDescription) {
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.href);
                    }
                    CodeDescription.is = is;
                })(CodeDescription || (CodeDescription = {}));
                /**
 * The Diagnostic namespace provides helper functions to work with
 * {@link Diagnostic} literals.
 */ var Diagnostic;
                (function(Diagnostic) {
                    /**
     * Creates a new Diagnostic literal.
     */ function create(range, message, severity, code, source, relatedInformation) {
                        var result = {
                            range: range,
                            message: message
                        };
                        if (Is.defined(severity)) {
                            result.severity = severity;
                        }
                        if (Is.defined(code)) {
                            result.code = code;
                        }
                        if (Is.defined(source)) {
                            result.source = source;
                        }
                        if (Is.defined(relatedInformation)) {
                            result.relatedInformation = relatedInformation;
                        }
                        return result;
                    }
                    Diagnostic.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Diagnostic} interface.
     */ function is(value) {
                        var _a;
                        var candidate = value;
                        return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
                    }
                    Diagnostic.is = is;
                })(Diagnostic || (Diagnostic = {}));
                /**
 * The Command namespace provides helper functions to work with
 * {@link Command} literals.
 */ var Command;
                (function(Command) {
                    /**
     * Creates a new Command literal.
     */ function create(title, command) {
                        var args = [];
                        for(var _i = 2; _i < arguments.length; _i++){
                            args[_i - 2] = arguments[_i];
                        }
                        var result = {
                            title: title,
                            command: command
                        };
                        if (Is.defined(args) && args.length > 0) {
                            result.arguments = args;
                        }
                        return result;
                    }
                    Command.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Command} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
                    }
                    Command.is = is;
                })(Command || (Command = {}));
                /**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */ var TextEdit;
                (function(TextEdit) {
                    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */ function replace(range, newText) {
                        return {
                            range: range,
                            newText: newText
                        };
                    }
                    TextEdit.replace = replace;
                    /**
     * Creates an insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */ function insert(position, newText) {
                        return {
                            range: {
                                start: position,
                                end: position
                            },
                            newText: newText
                        };
                    }
                    TextEdit.insert = insert;
                    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */ function del(range) {
                        return {
                            range: range,
                            newText: ''
                        };
                    }
                    TextEdit.del = del;
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
                    }
                    TextEdit.is = is;
                })(TextEdit || (TextEdit = {}));
                var ChangeAnnotation;
                (function(ChangeAnnotation) {
                    function create(label, needsConfirmation, description) {
                        var result = {
                            label: label
                        };
                        if (needsConfirmation !== undefined) {
                            result.needsConfirmation = needsConfirmation;
                        }
                        if (description !== undefined) {
                            result.description = description;
                        }
                        return result;
                    }
                    ChangeAnnotation.create = create;
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) && (Is.string(candidate.description) || candidate.description === undefined);
                    }
                    ChangeAnnotation.is = is;
                })(ChangeAnnotation || (ChangeAnnotation = {}));
                var ChangeAnnotationIdentifier;
                (function(ChangeAnnotationIdentifier) {
                    function is(value) {
                        var candidate = value;
                        return Is.string(candidate);
                    }
                    ChangeAnnotationIdentifier.is = is;
                })(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
                var AnnotatedTextEdit;
                (function(AnnotatedTextEdit) {
                    /**
     * Creates an annotated replace text edit.
     *
     * @param range The range of text to be replaced.
     * @param newText The new text.
     * @param annotation The annotation.
     */ function replace(range, newText, annotation) {
                        return {
                            range: range,
                            newText: newText,
                            annotationId: annotation
                        };
                    }
                    AnnotatedTextEdit.replace = replace;
                    /**
     * Creates an annotated insert text edit.
     *
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     * @param annotation The annotation.
     */ function insert(position, newText, annotation) {
                        return {
                            range: {
                                start: position,
                                end: position
                            },
                            newText: newText,
                            annotationId: annotation
                        };
                    }
                    AnnotatedTextEdit.insert = insert;
                    /**
     * Creates an annotated delete text edit.
     *
     * @param range The range of text to be deleted.
     * @param annotation The annotation.
     */ function del(range, annotation) {
                        return {
                            range: range,
                            newText: '',
                            annotationId: annotation
                        };
                    }
                    AnnotatedTextEdit.del = del;
                    function is(value) {
                        var candidate = value;
                        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    AnnotatedTextEdit.is = is;
                })(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
                /**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */ var TextDocumentEdit;
                (function(TextDocumentEdit) {
                    /**
     * Creates a new `TextDocumentEdit`
     */ function create(textDocument, edits) {
                        return {
                            textDocument: textDocument,
                            edits: edits
                        };
                    }
                    TextDocumentEdit.create = create;
                    function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
                    }
                    TextDocumentEdit.is = is;
                })(TextDocumentEdit || (TextDocumentEdit = {}));
                var CreateFile;
                (function(CreateFile) {
                    function create(uri, options, annotation) {
                        var result = {
                            kind: 'create',
                            uri: uri
                        };
                        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
                            result.options = options;
                        }
                        if (annotation !== undefined) {
                            result.annotationId = annotation;
                        }
                        return result;
                    }
                    CreateFile.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    CreateFile.is = is;
                })(CreateFile || (CreateFile = {}));
                var RenameFile;
                (function(RenameFile) {
                    function create(oldUri, newUri, options, annotation) {
                        var result = {
                            kind: 'rename',
                            oldUri: oldUri,
                            newUri: newUri
                        };
                        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
                            result.options = options;
                        }
                        if (annotation !== undefined) {
                            result.annotationId = annotation;
                        }
                        return result;
                    }
                    RenameFile.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    RenameFile.is = is;
                })(RenameFile || (RenameFile = {}));
                var DeleteFile;
                (function(DeleteFile) {
                    function create(uri, options, annotation) {
                        var result = {
                            kind: 'delete',
                            uri: uri
                        };
                        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
                            result.options = options;
                        }
                        if (annotation !== undefined) {
                            result.annotationId = annotation;
                        }
                        return result;
                    }
                    DeleteFile.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    DeleteFile.is = is;
                })(DeleteFile || (DeleteFile = {}));
                var WorkspaceEdit;
                (function(WorkspaceEdit) {
                    function is(value) {
                        var candidate = value;
                        return candidate && (candidate.changes !== undefined || candidate.documentChanges !== undefined) && (candidate.documentChanges === undefined || candidate.documentChanges.every(function(change) {
                            if (Is.string(change.kind)) {
                                return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                            } else {
                                return TextDocumentEdit.is(change);
                            }
                        }));
                    }
                    WorkspaceEdit.is = is;
                })(WorkspaceEdit || (WorkspaceEdit = {}));
                var TextEditChangeImpl = /** @class */ function() {
                    function TextEditChangeImpl(edits, changeAnnotations) {
                        this.edits = edits;
                        this.changeAnnotations = changeAnnotations;
                    }
                    TextEditChangeImpl.prototype.insert = function(position, newText, annotation) {
                        var edit;
                        var id;
                        if (annotation === undefined) {
                            edit = TextEdit.insert(position, newText);
                        } else if (ChangeAnnotationIdentifier.is(annotation)) {
                            id = annotation;
                            edit = AnnotatedTextEdit.insert(position, newText, annotation);
                        } else {
                            this.assertChangeAnnotations(this.changeAnnotations);
                            id = this.changeAnnotations.manage(annotation);
                            edit = AnnotatedTextEdit.insert(position, newText, id);
                        }
                        this.edits.push(edit);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    TextEditChangeImpl.prototype.replace = function(range, newText, annotation) {
                        var edit;
                        var id;
                        if (annotation === undefined) {
                            edit = TextEdit.replace(range, newText);
                        } else if (ChangeAnnotationIdentifier.is(annotation)) {
                            id = annotation;
                            edit = AnnotatedTextEdit.replace(range, newText, annotation);
                        } else {
                            this.assertChangeAnnotations(this.changeAnnotations);
                            id = this.changeAnnotations.manage(annotation);
                            edit = AnnotatedTextEdit.replace(range, newText, id);
                        }
                        this.edits.push(edit);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    TextEditChangeImpl.prototype.delete = function(range, annotation) {
                        var edit;
                        var id;
                        if (annotation === undefined) {
                            edit = TextEdit.del(range);
                        } else if (ChangeAnnotationIdentifier.is(annotation)) {
                            id = annotation;
                            edit = AnnotatedTextEdit.del(range, annotation);
                        } else {
                            this.assertChangeAnnotations(this.changeAnnotations);
                            id = this.changeAnnotations.manage(annotation);
                            edit = AnnotatedTextEdit.del(range, id);
                        }
                        this.edits.push(edit);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    TextEditChangeImpl.prototype.add = function(edit) {
                        this.edits.push(edit);
                    };
                    TextEditChangeImpl.prototype.all = function() {
                        return this.edits;
                    };
                    TextEditChangeImpl.prototype.clear = function() {
                        this.edits.splice(0, this.edits.length);
                    };
                    TextEditChangeImpl.prototype.assertChangeAnnotations = function(value) {
                        if (value === undefined) {
                            throw new Error("Text edit change is not configured to manage change annotations.");
                        }
                    };
                    return TextEditChangeImpl;
                }();
                /**
 * A helper class
 */ var ChangeAnnotations = /** @class */ function() {
                    function ChangeAnnotations(annotations) {
                        this._annotations = annotations === undefined ? Object.create(null) : annotations;
                        this._counter = 0;
                        this._size = 0;
                    }
                    ChangeAnnotations.prototype.all = function() {
                        return this._annotations;
                    };
                    Object.defineProperty(ChangeAnnotations.prototype, "size", {
                        get: function() {
                            return this._size;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    ChangeAnnotations.prototype.manage = function(idOrAnnotation, annotation) {
                        var id;
                        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
                            id = idOrAnnotation;
                        } else {
                            id = this.nextId();
                            annotation = idOrAnnotation;
                        }
                        if (this._annotations[id] !== undefined) {
                            throw new Error("Id ".concat(id, " is already in use."));
                        }
                        if (annotation === undefined) {
                            throw new Error("No annotation provided for id ".concat(id));
                        }
                        this._annotations[id] = annotation;
                        this._size++;
                        return id;
                    };
                    ChangeAnnotations.prototype.nextId = function() {
                        this._counter++;
                        return this._counter.toString();
                    };
                    return ChangeAnnotations;
                }();
                /**
 * A workspace change helps constructing changes to a workspace.
 */ var WorkspaceChange = /** @class */ function() {
                    function WorkspaceChange(workspaceEdit) {
                        var _this = this;
                        this._textEditChanges = Object.create(null);
                        if (workspaceEdit !== undefined) {
                            this._workspaceEdit = workspaceEdit;
                            if (workspaceEdit.documentChanges) {
                                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                                workspaceEdit.documentChanges.forEach(function(change) {
                                    if (TextDocumentEdit.is(change)) {
                                        var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                                        _this._textEditChanges[change.textDocument.uri] = textEditChange;
                                    }
                                });
                            } else if (workspaceEdit.changes) {
                                Object.keys(workspaceEdit.changes).forEach(function(key) {
                                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                                    _this._textEditChanges[key] = textEditChange;
                                });
                            }
                        } else {
                            this._workspaceEdit = {};
                        }
                    }
                    Object.defineProperty(WorkspaceChange.prototype, "edit", {
                        /**
         * Returns the underlying {@link WorkspaceEdit} literal
         * use to be returned from a workspace edit operation like rename.
         */ get: function() {
                            this.initDocumentChanges();
                            if (this._changeAnnotations !== undefined) {
                                if (this._changeAnnotations.size === 0) {
                                    this._workspaceEdit.changeAnnotations = undefined;
                                } else {
                                    this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                                }
                            }
                            return this._workspaceEdit;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    WorkspaceChange.prototype.getTextEditChange = function(key) {
                        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
                            this.initDocumentChanges();
                            if (this._workspaceEdit.documentChanges === undefined) {
                                throw new Error('Workspace edit is not configured for document changes.');
                            }
                            var textDocument = {
                                uri: key.uri,
                                version: key.version
                            };
                            var result = this._textEditChanges[textDocument.uri];
                            if (!result) {
                                var edits = [];
                                var textDocumentEdit = {
                                    textDocument: textDocument,
                                    edits: edits
                                };
                                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                                this._textEditChanges[textDocument.uri] = result;
                            }
                            return result;
                        } else {
                            this.initChanges();
                            if (this._workspaceEdit.changes === undefined) {
                                throw new Error('Workspace edit is not configured for normal text edit changes.');
                            }
                            var result = this._textEditChanges[key];
                            if (!result) {
                                var edits = [];
                                this._workspaceEdit.changes[key] = edits;
                                result = new TextEditChangeImpl(edits);
                                this._textEditChanges[key] = result;
                            }
                            return result;
                        }
                    };
                    WorkspaceChange.prototype.initDocumentChanges = function() {
                        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
                            this._changeAnnotations = new ChangeAnnotations();
                            this._workspaceEdit.documentChanges = [];
                            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                        }
                    };
                    WorkspaceChange.prototype.initChanges = function() {
                        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
                            this._workspaceEdit.changes = Object.create(null);
                        }
                    };
                    WorkspaceChange.prototype.createFile = function(uri, optionsOrAnnotation, options) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error('Workspace edit is not configured for document changes.');
                        }
                        var annotation;
                        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                            annotation = optionsOrAnnotation;
                        } else {
                            options = optionsOrAnnotation;
                        }
                        var operation;
                        var id;
                        if (annotation === undefined) {
                            operation = CreateFile.create(uri, options);
                        } else {
                            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                            operation = CreateFile.create(uri, options, id);
                        }
                        this._workspaceEdit.documentChanges.push(operation);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    WorkspaceChange.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error('Workspace edit is not configured for document changes.');
                        }
                        var annotation;
                        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                            annotation = optionsOrAnnotation;
                        } else {
                            options = optionsOrAnnotation;
                        }
                        var operation;
                        var id;
                        if (annotation === undefined) {
                            operation = RenameFile.create(oldUri, newUri, options);
                        } else {
                            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                            operation = RenameFile.create(oldUri, newUri, options, id);
                        }
                        this._workspaceEdit.documentChanges.push(operation);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    WorkspaceChange.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error('Workspace edit is not configured for document changes.');
                        }
                        var annotation;
                        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                            annotation = optionsOrAnnotation;
                        } else {
                            options = optionsOrAnnotation;
                        }
                        var operation;
                        var id;
                        if (annotation === undefined) {
                            operation = DeleteFile.create(uri, options);
                        } else {
                            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                            operation = DeleteFile.create(uri, options, id);
                        }
                        this._workspaceEdit.documentChanges.push(operation);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    return WorkspaceChange;
                }();
                /**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * {@link TextDocumentIdentifier} literals.
 */ var TextDocumentIdentifier;
                (function(TextDocumentIdentifier) {
                    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */ function create(uri) {
                        return {
                            uri: uri
                        };
                    }
                    TextDocumentIdentifier.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri);
                    }
                    TextDocumentIdentifier.is = is;
                })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
                /**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link VersionedTextDocumentIdentifier} literals.
 */ var VersionedTextDocumentIdentifier;
                (function(VersionedTextDocumentIdentifier) {
                    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */ function create(uri, version) {
                        return {
                            uri: uri,
                            version: version
                        };
                    }
                    VersionedTextDocumentIdentifier.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
                    }
                    VersionedTextDocumentIdentifier.is = is;
                })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
                /**
 * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link OptionalVersionedTextDocumentIdentifier} literals.
 */ var OptionalVersionedTextDocumentIdentifier;
                (function(OptionalVersionedTextDocumentIdentifier) {
                    /**
     * Creates a new OptionalVersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */ function create(uri, version) {
                        return {
                            uri: uri,
                            version: version
                        };
                    }
                    OptionalVersionedTextDocumentIdentifier.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
                    }
                    OptionalVersionedTextDocumentIdentifier.is = is;
                })(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
                /**
 * The TextDocumentItem namespace provides helper functions to work with
 * {@link TextDocumentItem} literals.
 */ var TextDocumentItem;
                (function(TextDocumentItem) {
                    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */ function create(uri, languageId, version, text) {
                        return {
                            uri: uri,
                            languageId: languageId,
                            version: version,
                            text: text
                        };
                    }
                    TextDocumentItem.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
                    }
                    TextDocumentItem.is = is;
                })(TextDocumentItem || (TextDocumentItem = {}));
                /**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */ var MarkupKind;
                (function(MarkupKind) {
                    /**
     * Plain text is supported as a content format
     */ MarkupKind.PlainText = 'plaintext';
                    /**
     * Markdown is supported as a content format
     */ MarkupKind.Markdown = 'markdown';
                    /**
     * Checks whether the given value is a value of the {@link MarkupKind} type.
     */ function is(value) {
                        var candidate = value;
                        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
                    }
                    MarkupKind.is = is;
                })(MarkupKind || (MarkupKind = {}));
                var MarkupContent;
                (function(MarkupContent) {
                    /**
     * Checks whether the given value conforms to the {@link MarkupContent} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
                    }
                    MarkupContent.is = is;
                })(MarkupContent || (MarkupContent = {}));
                /**
 * The kind of a completion entry.
 */ var CompletionItemKind;
                (function(CompletionItemKind) {
                    CompletionItemKind.Text = 1;
                    CompletionItemKind.Method = 2;
                    CompletionItemKind.Function = 3;
                    CompletionItemKind.Constructor = 4;
                    CompletionItemKind.Field = 5;
                    CompletionItemKind.Variable = 6;
                    CompletionItemKind.Class = 7;
                    CompletionItemKind.Interface = 8;
                    CompletionItemKind.Module = 9;
                    CompletionItemKind.Property = 10;
                    CompletionItemKind.Unit = 11;
                    CompletionItemKind.Value = 12;
                    CompletionItemKind.Enum = 13;
                    CompletionItemKind.Keyword = 14;
                    CompletionItemKind.Snippet = 15;
                    CompletionItemKind.Color = 16;
                    CompletionItemKind.File = 17;
                    CompletionItemKind.Reference = 18;
                    CompletionItemKind.Folder = 19;
                    CompletionItemKind.EnumMember = 20;
                    CompletionItemKind.Constant = 21;
                    CompletionItemKind.Struct = 22;
                    CompletionItemKind.Event = 23;
                    CompletionItemKind.Operator = 24;
                    CompletionItemKind.TypeParameter = 25;
                })(CompletionItemKind || (CompletionItemKind = {}));
                /**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */ var InsertTextFormat;
                (function(InsertTextFormat) {
                    /**
     * The primary text to be inserted is treated as a plain string.
     */ InsertTextFormat.PlainText = 1;
                    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
     */ InsertTextFormat.Snippet = 2;
                })(InsertTextFormat || (InsertTextFormat = {}));
                /**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */ var CompletionItemTag;
                (function(CompletionItemTag) {
                    /**
     * Render a completion as obsolete, usually using a strike-out.
     */ CompletionItemTag.Deprecated = 1;
                })(CompletionItemTag || (CompletionItemTag = {}));
                /**
 * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
 *
 * @since 3.16.0
 */ var InsertReplaceEdit;
                (function(InsertReplaceEdit) {
                    /**
     * Creates a new insert / replace edit
     */ function create(newText, insert, replace) {
                        return {
                            newText: newText,
                            insert: insert,
                            replace: replace
                        };
                    }
                    InsertReplaceEdit.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.
     */ function is(value) {
                        var candidate = value;
                        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
                    }
                    InsertReplaceEdit.is = is;
                })(InsertReplaceEdit || (InsertReplaceEdit = {}));
                /**
 * How whitespace and indentation is handled during completion
 * item insertion.
 *
 * @since 3.16.0
 */ var InsertTextMode;
                (function(InsertTextMode) {
                    /**
     * The insertion or replace strings is taken as it is. If the
     * value is multi line the lines below the cursor will be
     * inserted using the indentation defined in the string value.
     * The client will not apply any kind of adjustments to the
     * string.
     */ InsertTextMode.asIs = 1;
                    /**
     * The editor adjusts leading whitespace of new lines so that
     * they match the indentation up to the cursor of the line for
     * which the item is accepted.
     *
     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
     * multi line completion item is indented using 2 tabs and all
     * following lines inserted will be indented using 2 tabs as well.
     */ InsertTextMode.adjustIndentation = 2;
                })(InsertTextMode || (InsertTextMode = {}));
                var CompletionItemLabelDetails;
                (function(CompletionItemLabelDetails) {
                    function is(value) {
                        var candidate = value;
                        return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) && (Is.string(candidate.description) || candidate.description === undefined);
                    }
                    CompletionItemLabelDetails.is = is;
                })(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
                /**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */ var CompletionItem;
                (function(CompletionItem) {
                    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */ function create(label) {
                        return {
                            label: label
                        };
                    }
                    CompletionItem.create = create;
                })(CompletionItem || (CompletionItem = {}));
                /**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */ var CompletionList;
                (function(CompletionList) {
                    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */ function create(items, isIncomplete) {
                        return {
                            items: items ? items : [],
                            isIncomplete: !!isIncomplete
                        };
                    }
                    CompletionList.create = create;
                })(CompletionList || (CompletionList = {}));
                var MarkedString;
                (function(MarkedString) {
                    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */ function fromPlainText(plainText) {
                        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
                    }
                    MarkedString.fromPlainText = fromPlainText;
                    /**
     * Checks whether the given value conforms to the {@link MarkedString} type.
     */ function is(value) {
                        var candidate = value;
                        return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
                    }
                    MarkedString.is = is;
                })(MarkedString || (MarkedString = {}));
                var Hover;
                (function(Hover) {
                    /**
     * Checks whether the given value conforms to the {@link Hover} interface.
     */ function is(value) {
                        var candidate = value;
                        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));
                    }
                    Hover.is = is;
                })(Hover || (Hover = {}));
                /**
 * The ParameterInformation namespace provides helper functions to work with
 * {@link ParameterInformation} literals.
 */ var ParameterInformation;
                (function(ParameterInformation) {
                    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */ function create(label, documentation) {
                        return documentation ? {
                            label: label,
                            documentation: documentation
                        } : {
                            label: label
                        };
                    }
                    ParameterInformation.create = create;
                })(ParameterInformation || (ParameterInformation = {}));
                /**
 * The SignatureInformation namespace provides helper functions to work with
 * {@link SignatureInformation} literals.
 */ var SignatureInformation;
                (function(SignatureInformation) {
                    function create(label, documentation) {
                        var parameters = [];
                        for(var _i = 2; _i < arguments.length; _i++){
                            parameters[_i - 2] = arguments[_i];
                        }
                        var result = {
                            label: label
                        };
                        if (Is.defined(documentation)) {
                            result.documentation = documentation;
                        }
                        if (Is.defined(parameters)) {
                            result.parameters = parameters;
                        } else {
                            result.parameters = [];
                        }
                        return result;
                    }
                    SignatureInformation.create = create;
                })(SignatureInformation || (SignatureInformation = {}));
                /**
 * A document highlight kind.
 */ var DocumentHighlightKind;
                (function(DocumentHighlightKind) {
                    /**
     * A textual occurrence.
     */ DocumentHighlightKind.Text = 1;
                    /**
     * Read-access of a symbol, like reading a variable.
     */ DocumentHighlightKind.Read = 2;
                    /**
     * Write-access of a symbol, like writing to a variable.
     */ DocumentHighlightKind.Write = 3;
                })(DocumentHighlightKind || (DocumentHighlightKind = {}));
                /**
 * DocumentHighlight namespace to provide helper functions to work with
 * {@link DocumentHighlight} literals.
 */ var DocumentHighlight;
                (function(DocumentHighlight) {
                    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     * @param kind The highlight kind
     */ function create(range, kind) {
                        var result = {
                            range: range
                        };
                        if (Is.number(kind)) {
                            result.kind = kind;
                        }
                        return result;
                    }
                    DocumentHighlight.create = create;
                })(DocumentHighlight || (DocumentHighlight = {}));
                /**
 * A symbol kind.
 */ var SymbolKind;
                (function(SymbolKind) {
                    SymbolKind.File = 1;
                    SymbolKind.Module = 2;
                    SymbolKind.Namespace = 3;
                    SymbolKind.Package = 4;
                    SymbolKind.Class = 5;
                    SymbolKind.Method = 6;
                    SymbolKind.Property = 7;
                    SymbolKind.Field = 8;
                    SymbolKind.Constructor = 9;
                    SymbolKind.Enum = 10;
                    SymbolKind.Interface = 11;
                    SymbolKind.Function = 12;
                    SymbolKind.Variable = 13;
                    SymbolKind.Constant = 14;
                    SymbolKind.String = 15;
                    SymbolKind.Number = 16;
                    SymbolKind.Boolean = 17;
                    SymbolKind.Array = 18;
                    SymbolKind.Object = 19;
                    SymbolKind.Key = 20;
                    SymbolKind.Null = 21;
                    SymbolKind.EnumMember = 22;
                    SymbolKind.Struct = 23;
                    SymbolKind.Event = 24;
                    SymbolKind.Operator = 25;
                    SymbolKind.TypeParameter = 26;
                })(SymbolKind || (SymbolKind = {}));
                /**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 *
 * @since 3.16
 */ var SymbolTag;
                (function(SymbolTag) {
                    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */ SymbolTag.Deprecated = 1;
                })(SymbolTag || (SymbolTag = {}));
                var SymbolInformation;
                (function(SymbolInformation) {
                    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol.
     * @param containerName The name of the symbol containing the symbol.
     */ function create(name, kind, range, uri, containerName) {
                        var result = {
                            name: name,
                            kind: kind,
                            location: {
                                uri: uri,
                                range: range
                            }
                        };
                        if (containerName) {
                            result.containerName = containerName;
                        }
                        return result;
                    }
                    SymbolInformation.create = create;
                })(SymbolInformation || (SymbolInformation = {}));
                var WorkspaceSymbol;
                (function(WorkspaceSymbol) {
                    /**
     * Create a new workspace symbol.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param uri The resource of the location of the symbol.
     * @param range An options range of the location.
     * @returns A WorkspaceSymbol.
     */ function create(name, kind, uri, range) {
                        return range !== undefined ? {
                            name: name,
                            kind: kind,
                            location: {
                                uri: uri,
                                range: range
                            }
                        } : {
                            name: name,
                            kind: kind,
                            location: {
                                uri: uri
                            }
                        };
                    }
                    WorkspaceSymbol.create = create;
                })(WorkspaceSymbol || (WorkspaceSymbol = {}));
                var DocumentSymbol;
                (function(DocumentSymbol) {
                    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */ function create(name, detail, kind, range, selectionRange, children) {
                        var result = {
                            name: name,
                            detail: detail,
                            kind: kind,
                            range: range,
                            selectionRange: selectionRange
                        };
                        if (children !== undefined) {
                            result.children = children;
                        }
                        return result;
                    }
                    DocumentSymbol.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.
     */ function is(value) {
                        var candidate = value;
                        return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === undefined || Is.string(candidate.detail)) && (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) && (candidate.children === undefined || Array.isArray(candidate.children)) && (candidate.tags === undefined || Array.isArray(candidate.tags));
                    }
                    DocumentSymbol.is = is;
                })(DocumentSymbol || (DocumentSymbol = {}));
                /**
 * A set of predefined code action kinds
 */ var CodeActionKind;
                (function(CodeActionKind) {
                    /**
     * Empty kind.
     */ CodeActionKind.Empty = '';
                    /**
     * Base kind for quickfix actions: 'quickfix'
     */ CodeActionKind.QuickFix = 'quickfix';
                    /**
     * Base kind for refactoring actions: 'refactor'
     */ CodeActionKind.Refactor = 'refactor';
                    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */ CodeActionKind.RefactorExtract = 'refactor.extract';
                    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */ CodeActionKind.RefactorInline = 'refactor.inline';
                    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */ CodeActionKind.RefactorRewrite = 'refactor.rewrite';
                    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */ CodeActionKind.Source = 'source';
                    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */ CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
                    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */ CodeActionKind.SourceFixAll = 'source.fixAll';
                })(CodeActionKind || (CodeActionKind = {}));
                /**
 * The reason why code actions were requested.
 *
 * @since 3.17.0
 */ var CodeActionTriggerKind;
                (function(CodeActionTriggerKind) {
                    /**
     * Code actions were explicitly requested by the user or by an extension.
     */ CodeActionTriggerKind.Invoked = 1;
                    /**
     * Code actions were requested automatically.
     *
     * This typically happens when current selection in a file changes, but can
     * also be triggered when file content changes.
     */ CodeActionTriggerKind.Automatic = 2;
                })(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
                /**
 * The CodeActionContext namespace provides helper functions to work with
 * {@link CodeActionContext} literals.
 */ var CodeActionContext;
                (function(CodeActionContext) {
                    /**
     * Creates a new CodeActionContext literal.
     */ function create(diagnostics, only, triggerKind) {
                        var result = {
                            diagnostics: diagnostics
                        };
                        if (only !== undefined && only !== null) {
                            result.only = only;
                        }
                        if (triggerKind !== undefined && triggerKind !== null) {
                            result.triggerKind = triggerKind;
                        }
                        return result;
                    }
                    CodeActionContext.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link CodeActionContext} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
                    }
                    CodeActionContext.is = is;
                })(CodeActionContext || (CodeActionContext = {}));
                var CodeAction;
                (function(CodeAction) {
                    function create(title, kindOrCommandOrEdit, kind) {
                        var result = {
                            title: title
                        };
                        var checkKind = true;
                        if (typeof kindOrCommandOrEdit === 'string') {
                            checkKind = false;
                            result.kind = kindOrCommandOrEdit;
                        } else if (Command.is(kindOrCommandOrEdit)) {
                            result.command = kindOrCommandOrEdit;
                        } else {
                            result.edit = kindOrCommandOrEdit;
                        }
                        if (checkKind && kind !== undefined) {
                            result.kind = kind;
                        }
                        return result;
                    }
                    CodeAction.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate && Is.string(candidate.title) && (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === undefined || Is.string(candidate.kind)) && (candidate.edit !== undefined || candidate.command !== undefined) && (candidate.command === undefined || Command.is(candidate.command)) && (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) && (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
                    }
                    CodeAction.is = is;
                })(CodeAction || (CodeAction = {}));
                /**
 * The CodeLens namespace provides helper functions to work with
 * {@link CodeLens} literals.
 */ var CodeLens;
                (function(CodeLens) {
                    /**
     * Creates a new CodeLens literal.
     */ function create(range, data) {
                        var result = {
                            range: range
                        };
                        if (Is.defined(data)) {
                            result.data = data;
                        }
                        return result;
                    }
                    CodeLens.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link CodeLens} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
                    }
                    CodeLens.is = is;
                })(CodeLens || (CodeLens = {}));
                /**
 * The FormattingOptions namespace provides helper functions to work with
 * {@link FormattingOptions} literals.
 */ var FormattingOptions;
                (function(FormattingOptions) {
                    /**
     * Creates a new FormattingOptions literal.
     */ function create(tabSize, insertSpaces) {
                        return {
                            tabSize: tabSize,
                            insertSpaces: insertSpaces
                        };
                    }
                    FormattingOptions.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link FormattingOptions} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
                    }
                    FormattingOptions.is = is;
                })(FormattingOptions || (FormattingOptions = {}));
                /**
 * The DocumentLink namespace provides helper functions to work with
 * {@link DocumentLink} literals.
 */ var DocumentLink;
                (function(DocumentLink) {
                    /**
     * Creates a new DocumentLink literal.
     */ function create(range, target, data) {
                        return {
                            range: range,
                            target: target,
                            data: data
                        };
                    }
                    DocumentLink.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link DocumentLink} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
                    }
                    DocumentLink.is = is;
                })(DocumentLink || (DocumentLink = {}));
                /**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */ var SelectionRange;
                (function(SelectionRange) {
                    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */ function create(range, parent) {
                        return {
                            range: range,
                            parent: parent
                        };
                    }
                    SelectionRange.create = create;
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
                    }
                    SelectionRange.is = is;
                })(SelectionRange || (SelectionRange = {}));
                /**
 * A set of predefined token types. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */ var SemanticTokenTypes;
                (function(SemanticTokenTypes) {
                    SemanticTokenTypes["namespace"] = "namespace";
                    /**
     * Represents a generic type. Acts as a fallback for types which can't be mapped to
     * a specific type like class or enum.
     */ SemanticTokenTypes["type"] = "type";
                    SemanticTokenTypes["class"] = "class";
                    SemanticTokenTypes["enum"] = "enum";
                    SemanticTokenTypes["interface"] = "interface";
                    SemanticTokenTypes["struct"] = "struct";
                    SemanticTokenTypes["typeParameter"] = "typeParameter";
                    SemanticTokenTypes["parameter"] = "parameter";
                    SemanticTokenTypes["variable"] = "variable";
                    SemanticTokenTypes["property"] = "property";
                    SemanticTokenTypes["enumMember"] = "enumMember";
                    SemanticTokenTypes["event"] = "event";
                    SemanticTokenTypes["function"] = "function";
                    SemanticTokenTypes["method"] = "method";
                    SemanticTokenTypes["macro"] = "macro";
                    SemanticTokenTypes["keyword"] = "keyword";
                    SemanticTokenTypes["modifier"] = "modifier";
                    SemanticTokenTypes["comment"] = "comment";
                    SemanticTokenTypes["string"] = "string";
                    SemanticTokenTypes["number"] = "number";
                    SemanticTokenTypes["regexp"] = "regexp";
                    SemanticTokenTypes["operator"] = "operator";
                    /**
     * @since 3.17.0
     */ SemanticTokenTypes["decorator"] = "decorator";
                })(SemanticTokenTypes || (SemanticTokenTypes = {}));
                /**
 * A set of predefined token modifiers. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */ var SemanticTokenModifiers;
                (function(SemanticTokenModifiers) {
                    SemanticTokenModifiers["declaration"] = "declaration";
                    SemanticTokenModifiers["definition"] = "definition";
                    SemanticTokenModifiers["readonly"] = "readonly";
                    SemanticTokenModifiers["static"] = "static";
                    SemanticTokenModifiers["deprecated"] = "deprecated";
                    SemanticTokenModifiers["abstract"] = "abstract";
                    SemanticTokenModifiers["async"] = "async";
                    SemanticTokenModifiers["modification"] = "modification";
                    SemanticTokenModifiers["documentation"] = "documentation";
                    SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";
                })(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokens;
                (function(SemanticTokens) {
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
                    }
                    SemanticTokens.is = is;
                })(SemanticTokens || (SemanticTokens = {}));
                /**
 * The InlineValueText namespace provides functions to deal with InlineValueTexts.
 *
 * @since 3.17.0
 */ var InlineValueText;
                (function(InlineValueText) {
                    /**
     * Creates a new InlineValueText literal.
     */ function create(range, text) {
                        return {
                            range: range,
                            text: text
                        };
                    }
                    InlineValueText.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
                    }
                    InlineValueText.is = is;
                })(InlineValueText || (InlineValueText = {}));
                /**
 * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.
 *
 * @since 3.17.0
 */ var InlineValueVariableLookup;
                (function(InlineValueVariableLookup) {
                    /**
     * Creates a new InlineValueText literal.
     */ function create(range, variableName, caseSensitiveLookup) {
                        return {
                            range: range,
                            variableName: variableName,
                            caseSensitiveLookup: caseSensitiveLookup
                        };
                    }
                    InlineValueVariableLookup.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === undefined);
                    }
                    InlineValueVariableLookup.is = is;
                })(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
                /**
 * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.
 *
 * @since 3.17.0
 */ var InlineValueEvaluatableExpression;
                (function(InlineValueEvaluatableExpression) {
                    /**
     * Creates a new InlineValueEvaluatableExpression literal.
     */ function create(range, expression) {
                        return {
                            range: range,
                            expression: expression
                        };
                    }
                    InlineValueEvaluatableExpression.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === undefined);
                    }
                    InlineValueEvaluatableExpression.is = is;
                })(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
                /**
 * The InlineValueContext namespace provides helper functions to work with
 * {@link InlineValueContext} literals.
 *
 * @since 3.17.0
 */ var InlineValueContext;
                (function(InlineValueContext) {
                    /**
     * Creates a new InlineValueContext literal.
     */ function create(frameId, stoppedLocation) {
                        return {
                            frameId: frameId,
                            stoppedLocation: stoppedLocation
                        };
                    }
                    InlineValueContext.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link InlineValueContext} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Range.is(value.stoppedLocation);
                    }
                    InlineValueContext.is = is;
                })(InlineValueContext || (InlineValueContext = {}));
                /**
 * Inlay hint kinds.
 *
 * @since 3.17.0
 */ var InlayHintKind;
                (function(InlayHintKind) {
                    /**
     * An inlay hint that for a type annotation.
     */ InlayHintKind.Type = 1;
                    /**
     * An inlay hint that is for a parameter.
     */ InlayHintKind.Parameter = 2;
                    function is(value) {
                        return value === 1 || value === 2;
                    }
                    InlayHintKind.is = is;
                })(InlayHintKind || (InlayHintKind = {}));
                var InlayHintLabelPart;
                (function(InlayHintLabelPart) {
                    function create(value) {
                        return {
                            value: value
                        };
                    }
                    InlayHintLabelPart.create = create;
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === undefined || Location.is(candidate.location)) && (candidate.command === undefined || Command.is(candidate.command));
                    }
                    InlayHintLabelPart.is = is;
                })(InlayHintLabelPart || (InlayHintLabelPart = {}));
                var InlayHint;
                (function(InlayHint) {
                    function create(position, label, kind) {
                        var result = {
                            position: position,
                            label: label
                        };
                        if (kind !== undefined) {
                            result.kind = kind;
                        }
                        return result;
                    }
                    InlayHint.create = create;
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === undefined || InlayHintKind.is(candidate.kind)) && candidate.textEdits === undefined || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));
                    }
                    InlayHint.is = is;
                })(InlayHint || (InlayHint = {}));
                var WorkspaceFolder;
                (function(WorkspaceFolder) {
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
                    }
                    WorkspaceFolder.is = is;
                })(WorkspaceFolder || (WorkspaceFolder = {}));
                var EOL = [
                    '\n',
                    '\r\n',
                    '\r'
                ];
                /**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */ var TextDocument;
                (function(TextDocument) {
                    /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId The document's language Id.
     * @param version The document's version.
     * @param content The document's content.
     */ function create(uri, languageId, version, content) {
                        return new FullTextDocument(uri, languageId, version, content);
                    }
                    TextDocument.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link ITextDocument} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
                    }
                    TextDocument.is = is;
                    function applyEdits(document1, edits) {
                        var text = document1.getText();
                        var sortedEdits = mergeSort(edits, function(a, b) {
                            var diff = a.range.start.line - b.range.start.line;
                            if (diff === 0) {
                                return a.range.start.character - b.range.start.character;
                            }
                            return diff;
                        });
                        var lastModifiedOffset = text.length;
                        for(var i = sortedEdits.length - 1; i >= 0; i--){
                            var e = sortedEdits[i];
                            var startOffset = document1.offsetAt(e.range.start);
                            var endOffset = document1.offsetAt(e.range.end);
                            if (endOffset <= lastModifiedOffset) {
                                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
                            } else {
                                throw new Error('Overlapping edit');
                            }
                            lastModifiedOffset = startOffset;
                        }
                        return text;
                    }
                    TextDocument.applyEdits = applyEdits;
                    function mergeSort(data, compare) {
                        if (data.length <= 1) {
                            // sorted
                            return data;
                        }
                        var p = data.length / 2 | 0;
                        var left = data.slice(0, p);
                        var right = data.slice(p);
                        mergeSort(left, compare);
                        mergeSort(right, compare);
                        var leftIdx = 0;
                        var rightIdx = 0;
                        var i = 0;
                        while(leftIdx < left.length && rightIdx < right.length){
                            var ret = compare(left[leftIdx], right[rightIdx]);
                            if (ret <= 0) {
                                // smaller_equal -> take left to preserve order
                                data[i++] = left[leftIdx++];
                            } else {
                                // greater -> take right
                                data[i++] = right[rightIdx++];
                            }
                        }
                        while(leftIdx < left.length){
                            data[i++] = left[leftIdx++];
                        }
                        while(rightIdx < right.length){
                            data[i++] = right[rightIdx++];
                        }
                        return data;
                    }
                })(TextDocument || (TextDocument = {}));
                /**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */ var FullTextDocument = /** @class */ function() {
                    function FullTextDocument(uri, languageId, version, content) {
                        this._uri = uri;
                        this._languageId = languageId;
                        this._version = version;
                        this._content = content;
                        this._lineOffsets = undefined;
                    }
                    Object.defineProperty(FullTextDocument.prototype, "uri", {
                        get: function() {
                            return this._uri;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(FullTextDocument.prototype, "languageId", {
                        get: function() {
                            return this._languageId;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(FullTextDocument.prototype, "version", {
                        get: function() {
                            return this._version;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    FullTextDocument.prototype.getText = function(range) {
                        if (range) {
                            var start = this.offsetAt(range.start);
                            var end = this.offsetAt(range.end);
                            return this._content.substring(start, end);
                        }
                        return this._content;
                    };
                    FullTextDocument.prototype.update = function(event, version) {
                        this._content = event.text;
                        this._version = version;
                        this._lineOffsets = undefined;
                    };
                    FullTextDocument.prototype.getLineOffsets = function() {
                        if (this._lineOffsets === undefined) {
                            var lineOffsets = [];
                            var text = this._content;
                            var isLineStart = true;
                            for(var i = 0; i < text.length; i++){
                                if (isLineStart) {
                                    lineOffsets.push(i);
                                    isLineStart = false;
                                }
                                var ch = text.charAt(i);
                                isLineStart = ch === '\r' || ch === '\n';
                                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                                    i++;
                                }
                            }
                            if (isLineStart && text.length > 0) {
                                lineOffsets.push(text.length);
                            }
                            this._lineOffsets = lineOffsets;
                        }
                        return this._lineOffsets;
                    };
                    FullTextDocument.prototype.positionAt = function(offset) {
                        offset = Math.max(Math.min(offset, this._content.length), 0);
                        var lineOffsets = this.getLineOffsets();
                        var low = 0, high = lineOffsets.length;
                        if (high === 0) {
                            return Position.create(0, offset);
                        }
                        while(low < high){
                            var mid = Math.floor((low + high) / 2);
                            if (lineOffsets[mid] > offset) {
                                high = mid;
                            } else {
                                low = mid + 1;
                            }
                        }
                        // low is the least x for which the line offset is larger than the current offset
                        // or array.length if no line offset is larger than the current offset
                        var line = low - 1;
                        return Position.create(line, offset - lineOffsets[line]);
                    };
                    FullTextDocument.prototype.offsetAt = function(position) {
                        var lineOffsets = this.getLineOffsets();
                        if (position.line >= lineOffsets.length) {
                            return this._content.length;
                        } else if (position.line < 0) {
                            return 0;
                        }
                        var lineOffset = lineOffsets[position.line];
                        var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
                        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
                    };
                    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
                        get: function() {
                            return this.getLineOffsets().length;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    return FullTextDocument;
                }();
                var Is;
                (function(Is) {
                    var toString = Object.prototype.toString;
                    function defined(value) {
                        return typeof value !== 'undefined';
                    }
                    Is.defined = defined;
                    function undefined1(value) {
                        return typeof value === 'undefined';
                    }
                    Is.undefined = undefined1;
                    function boolean(value) {
                        return value === true || value === false;
                    }
                    Is.boolean = boolean;
                    function string(value) {
                        return toString.call(value) === '[object String]';
                    }
                    Is.string = string;
                    function number(value) {
                        return toString.call(value) === '[object Number]';
                    }
                    Is.number = number;
                    function numberRange(value, min, max) {
                        return toString.call(value) === '[object Number]' && min <= value && value <= max;
                    }
                    Is.numberRange = numberRange;
                    function integer(value) {
                        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;
                    }
                    Is.integer = integer;
                    function uinteger(value) {
                        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;
                    }
                    Is.uinteger = uinteger;
                    function func(value) {
                        return toString.call(value) === '[object Function]';
                    }
                    Is.func = func;
                    function objectLiteral(value) {
                        // Strictly speaking class instances pass this check as well. Since the LSP
                        // doesn't use classes we ignore this for now. If we do we need to add something
                        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
                        return value !== null && typeof value === 'object';
                    }
                    Is.objectLiteral = objectLiteral;
                    function typedArray(value, check) {
                        return Array.isArray(value) && value.every(check);
                    }
                    Is.typedArray = typedArray;
                })(Is || (Is = {}));
            /***/ },
            /***/ 2032: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_696626__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createMessageConnection = exports1.BrowserMessageWriter = exports1.BrowserMessageReader = void 0;
                const ril_1 = __nested_webpack_require_696626__(2812);
                // Install the browser runtime abstract.
                ril_1.default.install();
                const api_1 = __nested_webpack_require_696626__(8223);
                __exportStar(__nested_webpack_require_696626__(8223), exports1);
                class BrowserMessageReader extends api_1.AbstractMessageReader {
                    listen(callback) {
                        return this._onData.event(callback);
                    }
                    constructor(context){
                        super();
                        this._onData = new api_1.Emitter();
                        this._messageListener = (event)=>{
                            this._onData.fire(event.data);
                        };
                        context.addEventListener('error', (event)=>this.fireError(event));
                        context.onmessage = this._messageListener;
                    }
                }
                exports1.BrowserMessageReader = BrowserMessageReader;
                class BrowserMessageWriter extends api_1.AbstractMessageWriter {
                    write(msg) {
                        try {
                            this.context.postMessage(msg);
                            return Promise.resolve();
                        } catch (error) {
                            this.handleError(error, msg);
                            return Promise.reject(error);
                        }
                    }
                    handleError(error, msg) {
                        this.errorCount++;
                        this.fireError(error, msg, this.errorCount);
                    }
                    end() {}
                    constructor(context){
                        super();
                        this.context = context;
                        this.errorCount = 0;
                        context.addEventListener('error', (event)=>this.fireError(event));
                    }
                }
                exports1.BrowserMessageWriter = BrowserMessageWriter;
                function createMessageConnection(reader, writer, logger, options) {
                    if (logger === undefined) {
                        logger = api_1.NullLogger;
                    }
                    if (api_1.ConnectionStrategy.is(options)) {
                        options = {
                            connectionStrategy: options
                        };
                    }
                    return (0, api_1.createMessageConnection)(reader, writer, logger, options);
                }
                exports1.createMessageConnection = createMessageConnection;
            //# sourceMappingURL=main.js.map
            /***/ },
            /***/ 2812: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_701110__)=>{
                "use strict";
                /* provided dependency */ var console = __nested_webpack_require_701110__(3716);
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                const ral_1 = __nested_webpack_require_701110__(5406);
                const disposable_1 = __nested_webpack_require_701110__(4250);
                const events_1 = __nested_webpack_require_701110__(7257);
                const messageBuffer_1 = __nested_webpack_require_701110__(5947);
                class MessageBuffer extends messageBuffer_1.AbstractMessageBuffer {
                    emptyBuffer() {
                        return MessageBuffer.emptyBuffer;
                    }
                    fromString(value, _encoding) {
                        return new TextEncoder().encode(value);
                    }
                    toString(value, encoding) {
                        if (encoding === 'ascii') {
                            return this.asciiDecoder.decode(value);
                        } else {
                            return new TextDecoder(encoding).decode(value);
                        }
                    }
                    asNative(buffer, length) {
                        if (length === undefined) {
                            return buffer;
                        } else {
                            return buffer.slice(0, length);
                        }
                    }
                    allocNative(length) {
                        return new Uint8Array(length);
                    }
                    constructor(encoding = 'utf-8'){
                        super(encoding);
                        this.asciiDecoder = new TextDecoder('ascii');
                    }
                }
                MessageBuffer.emptyBuffer = new Uint8Array(0);
                class ReadableStreamWrapper {
                    onClose(listener) {
                        this.socket.addEventListener('close', listener);
                        return disposable_1.Disposable.create(()=>this.socket.removeEventListener('close', listener));
                    }
                    onError(listener) {
                        this.socket.addEventListener('error', listener);
                        return disposable_1.Disposable.create(()=>this.socket.removeEventListener('error', listener));
                    }
                    onEnd(listener) {
                        this.socket.addEventListener('end', listener);
                        return disposable_1.Disposable.create(()=>this.socket.removeEventListener('end', listener));
                    }
                    onData(listener) {
                        return this._onData.event(listener);
                    }
                    constructor(socket){
                        this.socket = socket;
                        this._onData = new events_1.Emitter();
                        this._messageListener = (event)=>{
                            const blob = event.data;
                            blob.arrayBuffer().then((buffer)=>{
                                this._onData.fire(new Uint8Array(buffer));
                            }, ()=>{
                                (0, ral_1.default)().console.error(`Converting blob to array buffer failed.`);
                            });
                        };
                        this.socket.addEventListener('message', this._messageListener);
                    }
                }
                class WritableStreamWrapper {
                    onClose(listener) {
                        this.socket.addEventListener('close', listener);
                        return disposable_1.Disposable.create(()=>this.socket.removeEventListener('close', listener));
                    }
                    onError(listener) {
                        this.socket.addEventListener('error', listener);
                        return disposable_1.Disposable.create(()=>this.socket.removeEventListener('error', listener));
                    }
                    onEnd(listener) {
                        this.socket.addEventListener('end', listener);
                        return disposable_1.Disposable.create(()=>this.socket.removeEventListener('end', listener));
                    }
                    write(data, encoding) {
                        if (typeof data === 'string') {
                            if (encoding !== undefined && encoding !== 'utf-8') {
                                throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);
                            }
                            this.socket.send(data);
                        } else {
                            this.socket.send(data);
                        }
                        return Promise.resolve();
                    }
                    end() {
                        this.socket.close();
                    }
                    constructor(socket){
                        this.socket = socket;
                    }
                }
                const _textEncoder = new TextEncoder();
                const _ril = Object.freeze({
                    messageBuffer: Object.freeze({
                        create: (encoding)=>new MessageBuffer(encoding)
                    }),
                    applicationJson: Object.freeze({
                        encoder: Object.freeze({
                            name: 'application/json',
                            encode: (msg, options)=>{
                                if (options.charset !== 'utf-8') {
                                    throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);
                                }
                                return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, undefined, 0)));
                            }
                        }),
                        decoder: Object.freeze({
                            name: 'application/json',
                            decode: (buffer, options)=>{
                                if (!(buffer instanceof Uint8Array)) {
                                    throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
                                }
                                return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
                            }
                        })
                    }),
                    stream: Object.freeze({
                        asReadableStream: (socket)=>new ReadableStreamWrapper(socket),
                        asWritableStream: (socket)=>new WritableStreamWrapper(socket)
                    }),
                    console: console,
                    timer: Object.freeze({
                        setTimeout (callback, ms, ...args) {
                            const handle = setTimeout(callback, ms, ...args);
                            return {
                                dispose: ()=>clearTimeout(handle)
                            };
                        },
                        setImmediate (callback, ...args) {
                            const handle = setTimeout(callback, 0, ...args);
                            return {
                                dispose: ()=>clearTimeout(handle)
                            };
                        },
                        setInterval (callback, ms, ...args) {
                            const handle = setInterval(callback, ms, ...args);
                            return {
                                dispose: ()=>clearInterval(handle)
                            };
                        }
                    })
                });
                function RIL() {
                    return _ril;
                }
                (function(RIL) {
                    function install() {
                        ral_1.default.install(_ril);
                    }
                    RIL.install = install;
                })(RIL || (RIL = {}));
                exports1["default"] = RIL;
            //# sourceMappingURL=ril.js.map
            /***/ },
            /***/ 8223: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_709787__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ /// <reference path="../../typings/thenable.d.ts" />
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.TraceFormat = exports1.TraceValues = exports1.Trace = exports1.ProgressType = exports1.ProgressToken = exports1.createMessageConnection = exports1.NullLogger = exports1.ConnectionOptions = exports1.ConnectionStrategy = exports1.WriteableStreamMessageWriter = exports1.AbstractMessageWriter = exports1.MessageWriter = exports1.ReadableStreamMessageReader = exports1.AbstractMessageReader = exports1.MessageReader = exports1.CancellationToken = exports1.CancellationTokenSource = exports1.Emitter = exports1.Event = exports1.Disposable = exports1.LRUCache = exports1.Touch = exports1.LinkedMap = exports1.ParameterStructures = exports1.NotificationType9 = exports1.NotificationType8 = exports1.NotificationType7 = exports1.NotificationType6 = exports1.NotificationType5 = exports1.NotificationType4 = exports1.NotificationType3 = exports1.NotificationType2 = exports1.NotificationType1 = exports1.NotificationType0 = exports1.NotificationType = exports1.ErrorCodes = exports1.ResponseError = exports1.RequestType9 = exports1.RequestType8 = exports1.RequestType7 = exports1.RequestType6 = exports1.RequestType5 = exports1.RequestType4 = exports1.RequestType3 = exports1.RequestType2 = exports1.RequestType1 = exports1.RequestType0 = exports1.RequestType = exports1.Message = exports1.RAL = void 0;
                exports1.CancellationStrategy = exports1.CancellationSenderStrategy = exports1.CancellationReceiverStrategy = exports1.ConnectionError = exports1.ConnectionErrors = exports1.LogTraceNotification = exports1.SetTraceNotification = void 0;
                const messages_1 = __nested_webpack_require_709787__(5613);
                Object.defineProperty(exports1, "Message", {
                    enumerable: true,
                    get: function() {
                        return messages_1.Message;
                    }
                });
                Object.defineProperty(exports1, "RequestType", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType;
                    }
                });
                Object.defineProperty(exports1, "RequestType0", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType0;
                    }
                });
                Object.defineProperty(exports1, "RequestType1", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType1;
                    }
                });
                Object.defineProperty(exports1, "RequestType2", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType2;
                    }
                });
                Object.defineProperty(exports1, "RequestType3", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType3;
                    }
                });
                Object.defineProperty(exports1, "RequestType4", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType4;
                    }
                });
                Object.defineProperty(exports1, "RequestType5", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType5;
                    }
                });
                Object.defineProperty(exports1, "RequestType6", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType6;
                    }
                });
                Object.defineProperty(exports1, "RequestType7", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType7;
                    }
                });
                Object.defineProperty(exports1, "RequestType8", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType8;
                    }
                });
                Object.defineProperty(exports1, "RequestType9", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType9;
                    }
                });
                Object.defineProperty(exports1, "ResponseError", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ResponseError;
                    }
                });
                Object.defineProperty(exports1, "ErrorCodes", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ErrorCodes;
                    }
                });
                Object.defineProperty(exports1, "NotificationType", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType;
                    }
                });
                Object.defineProperty(exports1, "NotificationType0", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType0;
                    }
                });
                Object.defineProperty(exports1, "NotificationType1", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType1;
                    }
                });
                Object.defineProperty(exports1, "NotificationType2", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType2;
                    }
                });
                Object.defineProperty(exports1, "NotificationType3", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType3;
                    }
                });
                Object.defineProperty(exports1, "NotificationType4", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType4;
                    }
                });
                Object.defineProperty(exports1, "NotificationType5", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType5;
                    }
                });
                Object.defineProperty(exports1, "NotificationType6", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType6;
                    }
                });
                Object.defineProperty(exports1, "NotificationType7", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType7;
                    }
                });
                Object.defineProperty(exports1, "NotificationType8", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType8;
                    }
                });
                Object.defineProperty(exports1, "NotificationType9", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType9;
                    }
                });
                Object.defineProperty(exports1, "ParameterStructures", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ParameterStructures;
                    }
                });
                const linkedMap_1 = __nested_webpack_require_709787__(1414);
                Object.defineProperty(exports1, "LinkedMap", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.LinkedMap;
                    }
                });
                Object.defineProperty(exports1, "LRUCache", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.LRUCache;
                    }
                });
                Object.defineProperty(exports1, "Touch", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.Touch;
                    }
                });
                const disposable_1 = __nested_webpack_require_709787__(4250);
                Object.defineProperty(exports1, "Disposable", {
                    enumerable: true,
                    get: function() {
                        return disposable_1.Disposable;
                    }
                });
                const events_1 = __nested_webpack_require_709787__(7257);
                Object.defineProperty(exports1, "Event", {
                    enumerable: true,
                    get: function() {
                        return events_1.Event;
                    }
                });
                Object.defineProperty(exports1, "Emitter", {
                    enumerable: true,
                    get: function() {
                        return events_1.Emitter;
                    }
                });
                const cancellation_1 = __nested_webpack_require_709787__(1072);
                Object.defineProperty(exports1, "CancellationTokenSource", {
                    enumerable: true,
                    get: function() {
                        return cancellation_1.CancellationTokenSource;
                    }
                });
                Object.defineProperty(exports1, "CancellationToken", {
                    enumerable: true,
                    get: function() {
                        return cancellation_1.CancellationToken;
                    }
                });
                const messageReader_1 = __nested_webpack_require_709787__(207);
                Object.defineProperty(exports1, "MessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.MessageReader;
                    }
                });
                Object.defineProperty(exports1, "AbstractMessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.AbstractMessageReader;
                    }
                });
                Object.defineProperty(exports1, "ReadableStreamMessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.ReadableStreamMessageReader;
                    }
                });
                const messageWriter_1 = __nested_webpack_require_709787__(6214);
                Object.defineProperty(exports1, "MessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.MessageWriter;
                    }
                });
                Object.defineProperty(exports1, "AbstractMessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.AbstractMessageWriter;
                    }
                });
                Object.defineProperty(exports1, "WriteableStreamMessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.WriteableStreamMessageWriter;
                    }
                });
                const connection_1 = __nested_webpack_require_709787__(7075);
                Object.defineProperty(exports1, "ConnectionStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionStrategy;
                    }
                });
                Object.defineProperty(exports1, "ConnectionOptions", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionOptions;
                    }
                });
                Object.defineProperty(exports1, "NullLogger", {
                    enumerable: true,
                    get: function() {
                        return connection_1.NullLogger;
                    }
                });
                Object.defineProperty(exports1, "createMessageConnection", {
                    enumerable: true,
                    get: function() {
                        return connection_1.createMessageConnection;
                    }
                });
                Object.defineProperty(exports1, "ProgressToken", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ProgressToken;
                    }
                });
                Object.defineProperty(exports1, "ProgressType", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ProgressType;
                    }
                });
                Object.defineProperty(exports1, "Trace", {
                    enumerable: true,
                    get: function() {
                        return connection_1.Trace;
                    }
                });
                Object.defineProperty(exports1, "TraceValues", {
                    enumerable: true,
                    get: function() {
                        return connection_1.TraceValues;
                    }
                });
                Object.defineProperty(exports1, "TraceFormat", {
                    enumerable: true,
                    get: function() {
                        return connection_1.TraceFormat;
                    }
                });
                Object.defineProperty(exports1, "SetTraceNotification", {
                    enumerable: true,
                    get: function() {
                        return connection_1.SetTraceNotification;
                    }
                });
                Object.defineProperty(exports1, "LogTraceNotification", {
                    enumerable: true,
                    get: function() {
                        return connection_1.LogTraceNotification;
                    }
                });
                Object.defineProperty(exports1, "ConnectionErrors", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionErrors;
                    }
                });
                Object.defineProperty(exports1, "ConnectionError", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionError;
                    }
                });
                Object.defineProperty(exports1, "CancellationReceiverStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationReceiverStrategy;
                    }
                });
                Object.defineProperty(exports1, "CancellationSenderStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationSenderStrategy;
                    }
                });
                Object.defineProperty(exports1, "CancellationStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationStrategy;
                    }
                });
                const ral_1 = __nested_webpack_require_709787__(5406);
                exports1.RAL = ral_1.default;
            //# sourceMappingURL=api.js.map
            /***/ },
            /***/ 1072: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_726538__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.CancellationTokenSource = exports1.CancellationToken = void 0;
                const ral_1 = __nested_webpack_require_726538__(5406);
                const Is = __nested_webpack_require_726538__(1278);
                const events_1 = __nested_webpack_require_726538__(7257);
                var CancellationToken;
                (function(CancellationToken) {
                    CancellationToken.None = Object.freeze({
                        isCancellationRequested: false,
                        onCancellationRequested: events_1.Event.None
                    });
                    CancellationToken.Cancelled = Object.freeze({
                        isCancellationRequested: true,
                        onCancellationRequested: events_1.Event.None
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate === CancellationToken.None || candidate === CancellationToken.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
                    }
                    CancellationToken.is = is;
                })(CancellationToken = exports1.CancellationToken || (exports1.CancellationToken = {}));
                const shortcutEvent = Object.freeze(function(callback, context) {
                    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
                    return {
                        dispose () {
                            handle.dispose();
                        }
                    };
                });
                class MutableToken {
                    cancel() {
                        if (!this._isCancelled) {
                            this._isCancelled = true;
                            if (this._emitter) {
                                this._emitter.fire(undefined);
                                this.dispose();
                            }
                        }
                    }
                    get isCancellationRequested() {
                        return this._isCancelled;
                    }
                    get onCancellationRequested() {
                        if (this._isCancelled) {
                            return shortcutEvent;
                        }
                        if (!this._emitter) {
                            this._emitter = new events_1.Emitter();
                        }
                        return this._emitter.event;
                    }
                    dispose() {
                        if (this._emitter) {
                            this._emitter.dispose();
                            this._emitter = undefined;
                        }
                    }
                    constructor(){
                        this._isCancelled = false;
                    }
                }
                class CancellationTokenSource {
                    get token() {
                        if (!this._token) {
                            // be lazy and create the token only when
                            // actually needed
                            this._token = new MutableToken();
                        }
                        return this._token;
                    }
                    cancel() {
                        if (!this._token) {
                            // save an object by returning the default
                            // cancelled token when cancellation happens
                            // before someone asks for the token
                            this._token = CancellationToken.Cancelled;
                        } else {
                            this._token.cancel();
                        }
                    }
                    dispose() {
                        if (!this._token) {
                            // ensure to initialize with an empty token if we had none
                            this._token = CancellationToken.None;
                        } else if (this._token instanceof MutableToken) {
                            // actually dispose
                            this._token.dispose();
                        }
                    }
                }
                exports1.CancellationTokenSource = CancellationTokenSource;
            //# sourceMappingURL=cancellation.js.map
            /***/ },
            /***/ 7075: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_731525__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createMessageConnection = exports1.ConnectionOptions = exports1.CancellationStrategy = exports1.CancellationSenderStrategy = exports1.CancellationReceiverStrategy = exports1.ConnectionStrategy = exports1.ConnectionError = exports1.ConnectionErrors = exports1.LogTraceNotification = exports1.SetTraceNotification = exports1.TraceFormat = exports1.TraceValues = exports1.Trace = exports1.NullLogger = exports1.ProgressType = exports1.ProgressToken = void 0;
                const ral_1 = __nested_webpack_require_731525__(5406);
                const Is = __nested_webpack_require_731525__(1278);
                const messages_1 = __nested_webpack_require_731525__(5613);
                const linkedMap_1 = __nested_webpack_require_731525__(1414);
                const events_1 = __nested_webpack_require_731525__(7257);
                const cancellation_1 = __nested_webpack_require_731525__(1072);
                var CancelNotification;
                (function(CancelNotification) {
                    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
                })(CancelNotification || (CancelNotification = {}));
                var ProgressToken;
                (function(ProgressToken) {
                    function is(value) {
                        return typeof value === 'string' || typeof value === 'number';
                    }
                    ProgressToken.is = is;
                })(ProgressToken = exports1.ProgressToken || (exports1.ProgressToken = {}));
                var ProgressNotification;
                (function(ProgressNotification) {
                    ProgressNotification.type = new messages_1.NotificationType('$/progress');
                })(ProgressNotification || (ProgressNotification = {}));
                class ProgressType {
                    constructor(){}
                }
                exports1.ProgressType = ProgressType;
                var StarRequestHandler;
                (function(StarRequestHandler) {
                    function is(value) {
                        return Is.func(value);
                    }
                    StarRequestHandler.is = is;
                })(StarRequestHandler || (StarRequestHandler = {}));
                exports1.NullLogger = Object.freeze({
                    error: ()=>{},
                    warn: ()=>{},
                    info: ()=>{},
                    log: ()=>{}
                });
                var Trace;
                (function(Trace) {
                    Trace[Trace["Off"] = 0] = "Off";
                    Trace[Trace["Messages"] = 1] = "Messages";
                    Trace[Trace["Compact"] = 2] = "Compact";
                    Trace[Trace["Verbose"] = 3] = "Verbose";
                })(Trace = exports1.Trace || (exports1.Trace = {}));
                var TraceValues;
                (function(TraceValues) {
                    /**
     * Turn tracing off.
     */ TraceValues.Off = 'off';
                    /**
     * Trace messages only.
     */ TraceValues.Messages = 'messages';
                    /**
     * Compact message tracing.
     */ TraceValues.Compact = 'compact';
                    /**
     * Verbose message tracing.
     */ TraceValues.Verbose = 'verbose';
                })(TraceValues = exports1.TraceValues || (exports1.TraceValues = {}));
                (function(Trace) {
                    function fromString(value) {
                        if (!Is.string(value)) {
                            return Trace.Off;
                        }
                        value = value.toLowerCase();
                        switch(value){
                            case 'off':
                                return Trace.Off;
                            case 'messages':
                                return Trace.Messages;
                            case 'compact':
                                return Trace.Compact;
                            case 'verbose':
                                return Trace.Verbose;
                            default:
                                return Trace.Off;
                        }
                    }
                    Trace.fromString = fromString;
                    function toString(value) {
                        switch(value){
                            case Trace.Off:
                                return 'off';
                            case Trace.Messages:
                                return 'messages';
                            case Trace.Compact:
                                return 'compact';
                            case Trace.Verbose:
                                return 'verbose';
                            default:
                                return 'off';
                        }
                    }
                    Trace.toString = toString;
                })(Trace = exports1.Trace || (exports1.Trace = {}));
                var TraceFormat;
                (function(TraceFormat) {
                    TraceFormat["Text"] = "text";
                    TraceFormat["JSON"] = "json";
                })(TraceFormat = exports1.TraceFormat || (exports1.TraceFormat = {}));
                (function(TraceFormat) {
                    function fromString(value) {
                        if (!Is.string(value)) {
                            return TraceFormat.Text;
                        }
                        value = value.toLowerCase();
                        if (value === 'json') {
                            return TraceFormat.JSON;
                        } else {
                            return TraceFormat.Text;
                        }
                    }
                    TraceFormat.fromString = fromString;
                })(TraceFormat = exports1.TraceFormat || (exports1.TraceFormat = {}));
                var SetTraceNotification;
                (function(SetTraceNotification) {
                    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');
                })(SetTraceNotification = exports1.SetTraceNotification || (exports1.SetTraceNotification = {}));
                var LogTraceNotification;
                (function(LogTraceNotification) {
                    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');
                })(LogTraceNotification = exports1.LogTraceNotification || (exports1.LogTraceNotification = {}));
                var ConnectionErrors;
                (function(ConnectionErrors) {
                    /**
     * The connection is closed.
     */ ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
                    /**
     * The connection got disposed.
     */ ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
                    /**
     * The connection is already in listening mode.
     */ ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
                })(ConnectionErrors = exports1.ConnectionErrors || (exports1.ConnectionErrors = {}));
                class ConnectionError extends Error {
                    constructor(code, message){
                        super(message);
                        this.code = code;
                        Object.setPrototypeOf(this, ConnectionError.prototype);
                    }
                }
                exports1.ConnectionError = ConnectionError;
                var ConnectionStrategy;
                (function(ConnectionStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.cancelUndispatched);
                    }
                    ConnectionStrategy.is = is;
                })(ConnectionStrategy = exports1.ConnectionStrategy || (exports1.ConnectionStrategy = {}));
                var CancellationReceiverStrategy;
                (function(CancellationReceiverStrategy) {
                    CancellationReceiverStrategy.Message = Object.freeze({
                        createCancellationTokenSource (_) {
                            return new cancellation_1.CancellationTokenSource();
                        }
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.createCancellationTokenSource);
                    }
                    CancellationReceiverStrategy.is = is;
                })(CancellationReceiverStrategy = exports1.CancellationReceiverStrategy || (exports1.CancellationReceiverStrategy = {}));
                var CancellationSenderStrategy;
                (function(CancellationSenderStrategy) {
                    CancellationSenderStrategy.Message = Object.freeze({
                        sendCancellation (conn, id) {
                            return conn.sendNotification(CancelNotification.type, {
                                id
                            });
                        },
                        cleanup (_) {}
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
                    }
                    CancellationSenderStrategy.is = is;
                })(CancellationSenderStrategy = exports1.CancellationSenderStrategy || (exports1.CancellationSenderStrategy = {}));
                var CancellationStrategy;
                (function(CancellationStrategy) {
                    CancellationStrategy.Message = Object.freeze({
                        receiver: CancellationReceiverStrategy.Message,
                        sender: CancellationSenderStrategy.Message
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
                    }
                    CancellationStrategy.is = is;
                })(CancellationStrategy = exports1.CancellationStrategy || (exports1.CancellationStrategy = {}));
                var ConnectionOptions;
                (function(ConnectionOptions) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));
                    }
                    ConnectionOptions.is = is;
                })(ConnectionOptions = exports1.ConnectionOptions || (exports1.ConnectionOptions = {}));
                var ConnectionState;
                (function(ConnectionState) {
                    ConnectionState[ConnectionState["New"] = 1] = "New";
                    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
                    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
                    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
                })(ConnectionState || (ConnectionState = {}));
                function createMessageConnection(messageReader, messageWriter, _logger, options) {
                    const logger = _logger !== undefined ? _logger : exports1.NullLogger;
                    let sequenceNumber = 0;
                    let notificationSequenceNumber = 0;
                    let unknownResponseSequenceNumber = 0;
                    const version = '2.0';
                    let starRequestHandler = undefined;
                    const requestHandlers = new Map();
                    let starNotificationHandler = undefined;
                    const notificationHandlers = new Map();
                    const progressHandlers = new Map();
                    let timer;
                    let messageQueue = new linkedMap_1.LinkedMap();
                    let responsePromises = new Map();
                    let knownCanceledRequests = new Set();
                    let requestTokens = new Map();
                    let trace = Trace.Off;
                    let traceFormat = TraceFormat.Text;
                    let tracer;
                    let state = ConnectionState.New;
                    const errorEmitter = new events_1.Emitter();
                    const closeEmitter = new events_1.Emitter();
                    const unhandledNotificationEmitter = new events_1.Emitter();
                    const unhandledProgressEmitter = new events_1.Emitter();
                    const disposeEmitter = new events_1.Emitter();
                    const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
                    function createRequestQueueKey(id) {
                        if (id === null) {
                            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
                        }
                        return 'req-' + id.toString();
                    }
                    function createResponseQueueKey(id) {
                        if (id === null) {
                            return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();
                        } else {
                            return 'res-' + id.toString();
                        }
                    }
                    function createNotificationQueueKey() {
                        return 'not-' + (++notificationSequenceNumber).toString();
                    }
                    function addMessageToQueue(queue, message) {
                        if (messages_1.Message.isRequest(message)) {
                            queue.set(createRequestQueueKey(message.id), message);
                        } else if (messages_1.Message.isResponse(message)) {
                            queue.set(createResponseQueueKey(message.id), message);
                        } else {
                            queue.set(createNotificationQueueKey(), message);
                        }
                    }
                    function cancelUndispatched(_message) {
                        return undefined;
                    }
                    function isListening() {
                        return state === ConnectionState.Listening;
                    }
                    function isClosed() {
                        return state === ConnectionState.Closed;
                    }
                    function isDisposed() {
                        return state === ConnectionState.Disposed;
                    }
                    function closeHandler() {
                        if (state === ConnectionState.New || state === ConnectionState.Listening) {
                            state = ConnectionState.Closed;
                            closeEmitter.fire(undefined);
                        }
                    // If the connection is disposed don't sent close events.
                    }
                    function readErrorHandler(error) {
                        errorEmitter.fire([
                            error,
                            undefined,
                            undefined
                        ]);
                    }
                    function writeErrorHandler(data) {
                        errorEmitter.fire(data);
                    }
                    messageReader.onClose(closeHandler);
                    messageReader.onError(readErrorHandler);
                    messageWriter.onClose(closeHandler);
                    messageWriter.onError(writeErrorHandler);
                    function triggerMessageQueue() {
                        if (timer || messageQueue.size === 0) {
                            return;
                        }
                        timer = (0, ral_1.default)().timer.setImmediate(()=>{
                            timer = undefined;
                            processMessageQueue();
                        });
                    }
                    function processMessageQueue() {
                        if (messageQueue.size === 0) {
                            return;
                        }
                        const message = messageQueue.shift();
                        try {
                            if (messages_1.Message.isRequest(message)) {
                                handleRequest(message);
                            } else if (messages_1.Message.isNotification(message)) {
                                handleNotification(message);
                            } else if (messages_1.Message.isResponse(message)) {
                                handleResponse(message);
                            } else {
                                handleInvalidMessage(message);
                            }
                        } finally{
                            triggerMessageQueue();
                        }
                    }
                    const callback = (message)=>{
                        try {
                            // We have received a cancellation message. Check if the message is still in the queue
                            // and cancel it if allowed to do so.
                            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
                                const cancelId = message.params.id;
                                const key = createRequestQueueKey(cancelId);
                                const toCancel = messageQueue.get(key);
                                if (messages_1.Message.isRequest(toCancel)) {
                                    var _options;
                                    const strategy = (_options = options) === null || _options === void 0 ? void 0 : _options.connectionStrategy;
                                    const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                                    if (response && (response.error !== undefined || response.result !== undefined)) {
                                        messageQueue.delete(key);
                                        requestTokens.delete(cancelId);
                                        response.id = toCancel.id;
                                        traceSendingResponse(response, message.method, Date.now());
                                        messageWriter.write(response).catch(()=>logger.error(`Sending response for canceled message failed.`));
                                        return;
                                    }
                                }
                                const cancellationToken = requestTokens.get(cancelId);
                                // The request is already running. Cancel the token
                                if (cancellationToken !== undefined) {
                                    cancellationToken.cancel();
                                    traceReceivedNotification(message);
                                    return;
                                } else {
                                    // Remember the cancel but still queue the message to
                                    // clean up state in process message.
                                    knownCanceledRequests.add(cancelId);
                                }
                            }
                            addMessageToQueue(messageQueue, message);
                        } finally{
                            triggerMessageQueue();
                        }
                    };
                    function handleRequest(requestMessage) {
                        if (isDisposed()) {
                            // we return here silently since we fired an event when the
                            // connection got disposed.
                            return;
                        }
                        function reply(resultOrError, method, startTime) {
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id
                            };
                            if (resultOrError instanceof messages_1.ResponseError) {
                                message.error = resultOrError.toJson();
                            } else {
                                message.result = resultOrError === undefined ? null : resultOrError;
                            }
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        function replyError(error, method, startTime) {
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id,
                                error: error.toJson()
                            };
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        function replySuccess(result, method, startTime) {
                            // The JSON RPC defines that a response must either have a result or an error
                            // So we can't treat undefined as a valid response result.
                            if (result === undefined) {
                                result = null;
                            }
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id,
                                result: result
                            };
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        traceReceivedRequest(requestMessage);
                        const element = requestHandlers.get(requestMessage.method);
                        let type;
                        let requestHandler;
                        if (element) {
                            type = element.type;
                            requestHandler = element.handler;
                        }
                        const startTime = Date.now();
                        if (requestHandler || starRequestHandler) {
                            var _requestMessage_id;
                            const tokenKey = (_requestMessage_id = requestMessage.id) !== null && _requestMessage_id !== void 0 ? _requestMessage_id : String(Date.now()); //
                            const cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);
                            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
                                cancellationSource.cancel();
                            }
                            if (requestMessage.id !== null) {
                                requestTokens.set(tokenKey, cancellationSource);
                            }
                            try {
                                let handlerResult;
                                if (requestHandler) {
                                    if (requestMessage.params === undefined) {
                                        if (type !== undefined && type.numberOfParams !== 0) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(cancellationSource.token);
                                    } else if (Array.isArray(requestMessage.params)) {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                                    } else {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                                    }
                                } else if (starRequestHandler) {
                                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                                }
                                const promise = handlerResult;
                                if (!handlerResult) {
                                    requestTokens.delete(tokenKey);
                                    replySuccess(handlerResult, requestMessage.method, startTime);
                                } else if (promise.then) {
                                    promise.then((resultOrError)=>{
                                        requestTokens.delete(tokenKey);
                                        reply(resultOrError, requestMessage.method, startTime);
                                    }, (error)=>{
                                        requestTokens.delete(tokenKey);
                                        if (error instanceof messages_1.ResponseError) {
                                            replyError(error, requestMessage.method, startTime);
                                        } else if (error && Is.string(error.message)) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                                        } else {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                                        }
                                    });
                                } else {
                                    requestTokens.delete(tokenKey);
                                    reply(handlerResult, requestMessage.method, startTime);
                                }
                            } catch (error) {
                                requestTokens.delete(tokenKey);
                                if (error instanceof messages_1.ResponseError) {
                                    reply(error, requestMessage.method, startTime);
                                } else if (error && Is.string(error.message)) {
                                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                                } else {
                                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                                }
                            }
                        } else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
                        }
                    }
                    function handleResponse(responseMessage) {
                        if (isDisposed()) {
                            // See handle request.
                            return;
                        }
                        if (responseMessage.id === null) {
                            if (responseMessage.error) {
                                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
                            } else {
                                logger.error(`Received response message without id. No further error information provided.`);
                            }
                        } else {
                            const key = responseMessage.id;
                            const responsePromise = responsePromises.get(key);
                            traceReceivedResponse(responseMessage, responsePromise);
                            if (responsePromise !== undefined) {
                                responsePromises.delete(key);
                                try {
                                    if (responseMessage.error) {
                                        const error = responseMessage.error;
                                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                                    } else if (responseMessage.result !== undefined) {
                                        responsePromise.resolve(responseMessage.result);
                                    } else {
                                        throw new Error('Should never happen.');
                                    }
                                } catch (error) {
                                    if (error.message) {
                                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                                    } else {
                                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                                    }
                                }
                            }
                        }
                    }
                    function handleNotification(message) {
                        if (isDisposed()) {
                            // See handle request.
                            return;
                        }
                        let type = undefined;
                        let notificationHandler;
                        if (message.method === CancelNotification.type.method) {
                            const cancelId = message.params.id;
                            knownCanceledRequests.delete(cancelId);
                            traceReceivedNotification(message);
                            return;
                        } else {
                            const element = notificationHandlers.get(message.method);
                            if (element) {
                                notificationHandler = element.handler;
                                type = element.type;
                            }
                        }
                        if (notificationHandler || starNotificationHandler) {
                            try {
                                traceReceivedNotification(message);
                                if (notificationHandler) {
                                    if (message.params === undefined) {
                                        if (type !== undefined) {
                                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                                            }
                                        }
                                        notificationHandler();
                                    } else if (Array.isArray(message.params)) {
                                        // There are JSON-RPC libraries that send progress message as positional params although
                                        // specified as named. So convert them if this is the case.
                                        const params = message.params;
                                        if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                                            notificationHandler({
                                                token: params[0],
                                                value: params[1]
                                            });
                                        } else {
                                            if (type !== undefined) {
                                                if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                                                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                                                }
                                                if (type.numberOfParams !== message.params.length) {
                                                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                                                }
                                            }
                                            notificationHandler(...params);
                                        }
                                    } else {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                                        }
                                        notificationHandler(message.params);
                                    }
                                } else if (starNotificationHandler) {
                                    starNotificationHandler(message.method, message.params);
                                }
                            } catch (error) {
                                if (error.message) {
                                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
                                } else {
                                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
                                }
                            }
                        } else {
                            unhandledNotificationEmitter.fire(message);
                        }
                    }
                    function handleInvalidMessage(message) {
                        if (!message) {
                            logger.error('Received empty message.');
                            return;
                        }
                        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
                        // Test whether we find an id to reject the promise
                        const responseMessage = message;
                        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
                            const key = responseMessage.id;
                            const responseHandler = responsePromises.get(key);
                            if (responseHandler) {
                                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
                            }
                        }
                    }
                    function stringifyTrace(params) {
                        if (params === undefined || params === null) {
                            return undefined;
                        }
                        switch(trace){
                            case Trace.Verbose:
                                return JSON.stringify(params, null, 4);
                            case Trace.Compact:
                                return JSON.stringify(params);
                            default:
                                return undefined;
                        }
                    }
                    function traceSendingRequest(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                                data = `Params: ${stringifyTrace(message.params)}\n\n`;
                            }
                            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
                        } else {
                            logLSPMessage('send-request', message);
                        }
                    }
                    function traceSendingNotification(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.params) {
                                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                                } else {
                                    data = 'No parameters provided.\n\n';
                                }
                            }
                            tracer.log(`Sending notification '${message.method}'.`, data);
                        } else {
                            logLSPMessage('send-notification', message);
                        }
                    }
                    function traceSendingResponse(message, method, startTime) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.error && message.error.data) {
                                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                                } else {
                                    if (message.result) {
                                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                                    } else if (message.error === undefined) {
                                        data = 'No result returned.\n\n';
                                    }
                                }
                            }
                            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
                        } else {
                            logLSPMessage('send-response', message);
                        }
                    }
                    function traceReceivedRequest(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                                data = `Params: ${stringifyTrace(message.params)}\n\n`;
                            }
                            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
                        } else {
                            logLSPMessage('receive-request', message);
                        }
                    }
                    function traceReceivedNotification(message) {
                        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.params) {
                                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                                } else {
                                    data = 'No parameters provided.\n\n';
                                }
                            }
                            tracer.log(`Received notification '${message.method}'.`, data);
                        } else {
                            logLSPMessage('receive-notification', message);
                        }
                    }
                    function traceReceivedResponse(message, responsePromise) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.error && message.error.data) {
                                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                                } else {
                                    if (message.result) {
                                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                                    } else if (message.error === undefined) {
                                        data = 'No result returned.\n\n';
                                    }
                                }
                            }
                            if (responsePromise) {
                                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
                                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
                            } else {
                                tracer.log(`Received response ${message.id} without active response promise.`, data);
                            }
                        } else {
                            logLSPMessage('receive-response', message);
                        }
                    }
                    function logLSPMessage(type, message) {
                        if (!tracer || trace === Trace.Off) {
                            return;
                        }
                        const lspMessage = {
                            isLSPMessage: true,
                            type,
                            message,
                            timestamp: Date.now()
                        };
                        tracer.log(lspMessage);
                    }
                    function throwIfClosedOrDisposed() {
                        if (isClosed()) {
                            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
                        }
                        if (isDisposed()) {
                            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
                        }
                    }
                    function throwIfListening() {
                        if (isListening()) {
                            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
                        }
                    }
                    function throwIfNotListening() {
                        if (!isListening()) {
                            throw new Error('Call listen() first.');
                        }
                    }
                    function undefinedToNull(param) {
                        if (param === undefined) {
                            return null;
                        } else {
                            return param;
                        }
                    }
                    function nullToUndefined(param) {
                        if (param === null) {
                            return undefined;
                        } else {
                            return param;
                        }
                    }
                    function isNamedParam(param) {
                        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';
                    }
                    function computeSingleParam(parameterStructures, param) {
                        switch(parameterStructures){
                            case messages_1.ParameterStructures.auto:
                                if (isNamedParam(param)) {
                                    return nullToUndefined(param);
                                } else {
                                    return [
                                        undefinedToNull(param)
                                    ];
                                }
                            case messages_1.ParameterStructures.byName:
                                if (!isNamedParam(param)) {
                                    throw new Error(`Received parameters by name but param is not an object literal.`);
                                }
                                return nullToUndefined(param);
                            case messages_1.ParameterStructures.byPosition:
                                return [
                                    undefinedToNull(param)
                                ];
                            default:
                                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
                        }
                    }
                    function computeMessageParams(type, params) {
                        let result;
                        const numberOfParams = type.numberOfParams;
                        switch(numberOfParams){
                            case 0:
                                result = undefined;
                                break;
                            case 1:
                                result = computeSingleParam(type.parameterStructures, params[0]);
                                break;
                            default:
                                result = [];
                                for(let i = 0; i < params.length && i < numberOfParams; i++){
                                    result.push(undefinedToNull(params[i]));
                                }
                                if (params.length < numberOfParams) {
                                    for(let i = params.length; i < numberOfParams; i++){
                                        result.push(null);
                                    }
                                }
                                break;
                        }
                        return result;
                    }
                    const connection = {
                        sendNotification: (type, ...args)=>{
                            throwIfClosedOrDisposed();
                            let method;
                            let messageParams;
                            if (Is.string(type)) {
                                method = type;
                                const first = args[0];
                                let paramStart = 0;
                                let parameterStructures = messages_1.ParameterStructures.auto;
                                if (messages_1.ParameterStructures.is(first)) {
                                    paramStart = 1;
                                    parameterStructures = first;
                                }
                                let paramEnd = args.length;
                                const numberOfParams = paramEnd - paramStart;
                                switch(numberOfParams){
                                    case 0:
                                        messageParams = undefined;
                                        break;
                                    case 1:
                                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                                        break;
                                    default:
                                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                                        }
                                        messageParams = args.slice(paramStart, paramEnd).map((value)=>undefinedToNull(value));
                                        break;
                                }
                            } else {
                                const params = args;
                                method = type.method;
                                messageParams = computeMessageParams(type, params);
                            }
                            const notificationMessage = {
                                jsonrpc: version,
                                method: method,
                                params: messageParams
                            };
                            traceSendingNotification(notificationMessage);
                            return messageWriter.write(notificationMessage).catch(()=>logger.error(`Sending notification failed.`));
                        },
                        onNotification: (type, handler)=>{
                            throwIfClosedOrDisposed();
                            let method;
                            if (Is.func(type)) {
                                starNotificationHandler = type;
                            } else if (handler) {
                                if (Is.string(type)) {
                                    method = type;
                                    notificationHandlers.set(type, {
                                        type: undefined,
                                        handler
                                    });
                                } else {
                                    method = type.method;
                                    notificationHandlers.set(type.method, {
                                        type,
                                        handler
                                    });
                                }
                            }
                            return {
                                dispose: ()=>{
                                    if (method !== undefined) {
                                        notificationHandlers.delete(method);
                                    } else {
                                        starNotificationHandler = undefined;
                                    }
                                }
                            };
                        },
                        onProgress: (_type, token, handler)=>{
                            if (progressHandlers.has(token)) {
                                throw new Error(`Progress handler for token ${token} already registered`);
                            }
                            progressHandlers.set(token, handler);
                            return {
                                dispose: ()=>{
                                    progressHandlers.delete(token);
                                }
                            };
                        },
                        sendProgress: (_type, token, value)=>{
                            return connection.sendNotification(ProgressNotification.type, {
                                token,
                                value
                            });
                        },
                        onUnhandledProgress: unhandledProgressEmitter.event,
                        sendRequest: (type, ...args)=>{
                            throwIfClosedOrDisposed();
                            throwIfNotListening();
                            let method;
                            let messageParams;
                            let token = undefined;
                            if (Is.string(type)) {
                                method = type;
                                const first = args[0];
                                const last = args[args.length - 1];
                                let paramStart = 0;
                                let parameterStructures = messages_1.ParameterStructures.auto;
                                if (messages_1.ParameterStructures.is(first)) {
                                    paramStart = 1;
                                    parameterStructures = first;
                                }
                                let paramEnd = args.length;
                                if (cancellation_1.CancellationToken.is(last)) {
                                    paramEnd = paramEnd - 1;
                                    token = last;
                                }
                                const numberOfParams = paramEnd - paramStart;
                                switch(numberOfParams){
                                    case 0:
                                        messageParams = undefined;
                                        break;
                                    case 1:
                                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                                        break;
                                    default:
                                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                                        }
                                        messageParams = args.slice(paramStart, paramEnd).map((value)=>undefinedToNull(value));
                                        break;
                                }
                            } else {
                                const params = args;
                                method = type.method;
                                messageParams = computeMessageParams(type, params);
                                const numberOfParams = type.numberOfParams;
                                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
                            }
                            const id = sequenceNumber++;
                            let disposable;
                            if (token) {
                                disposable = token.onCancellationRequested(()=>{
                                    const p = cancellationStrategy.sender.sendCancellation(connection, id);
                                    if (p === undefined) {
                                        logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                                        return Promise.resolve();
                                    } else {
                                        return p.catch(()=>{
                                            logger.log(`Sending cancellation messages for id ${id} failed`);
                                        });
                                    }
                                });
                            }
                            const result = new Promise((resolve, reject)=>{
                                const requestMessage = {
                                    jsonrpc: version,
                                    id: id,
                                    method: method,
                                    params: messageParams
                                };
                                const resolveWithCleanup = (r)=>{
                                    var _disposable;
                                    resolve(r);
                                    cancellationStrategy.sender.cleanup(id);
                                    (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable.dispose();
                                };
                                const rejectWithCleanup = (r)=>{
                                    var _disposable;
                                    reject(r);
                                    cancellationStrategy.sender.cleanup(id);
                                    (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable.dispose();
                                };
                                let responsePromise = {
                                    method: method,
                                    timerStart: Date.now(),
                                    resolve: resolveWithCleanup,
                                    reject: rejectWithCleanup
                                };
                                traceSendingRequest(requestMessage);
                                try {
                                    messageWriter.write(requestMessage).catch(()=>logger.error(`Sending request failed.`));
                                } catch (e) {
                                    // Writing the message failed. So we need to reject the promise.
                                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : 'Unknown reason'));
                                    responsePromise = null;
                                }
                                if (responsePromise) {
                                    responsePromises.set(id, responsePromise);
                                }
                            });
                            return result;
                        },
                        onRequest: (type, handler)=>{
                            throwIfClosedOrDisposed();
                            let method = null;
                            if (StarRequestHandler.is(type)) {
                                method = undefined;
                                starRequestHandler = type;
                            } else if (Is.string(type)) {
                                method = null;
                                if (handler !== undefined) {
                                    method = type;
                                    requestHandlers.set(type, {
                                        handler: handler,
                                        type: undefined
                                    });
                                }
                            } else {
                                if (handler !== undefined) {
                                    method = type.method;
                                    requestHandlers.set(type.method, {
                                        type,
                                        handler
                                    });
                                }
                            }
                            return {
                                dispose: ()=>{
                                    if (method === null) {
                                        return;
                                    }
                                    if (method !== undefined) {
                                        requestHandlers.delete(method);
                                    } else {
                                        starRequestHandler = undefined;
                                    }
                                }
                            };
                        },
                        hasPendingResponse: ()=>{
                            return responsePromises.size > 0;
                        },
                        trace: async (_value, _tracer, sendNotificationOrTraceOptions)=>{
                            let _sendNotification = false;
                            let _traceFormat = TraceFormat.Text;
                            if (sendNotificationOrTraceOptions !== undefined) {
                                if (Is.boolean(sendNotificationOrTraceOptions)) {
                                    _sendNotification = sendNotificationOrTraceOptions;
                                } else {
                                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                                }
                            }
                            trace = _value;
                            traceFormat = _traceFormat;
                            if (trace === Trace.Off) {
                                tracer = undefined;
                            } else {
                                tracer = _tracer;
                            }
                            if (_sendNotification && !isClosed() && !isDisposed()) {
                                await connection.sendNotification(SetTraceNotification.type, {
                                    value: Trace.toString(_value)
                                });
                            }
                        },
                        onError: errorEmitter.event,
                        onClose: closeEmitter.event,
                        onUnhandledNotification: unhandledNotificationEmitter.event,
                        onDispose: disposeEmitter.event,
                        end: ()=>{
                            messageWriter.end();
                        },
                        dispose: ()=>{
                            if (isDisposed()) {
                                return;
                            }
                            state = ConnectionState.Disposed;
                            disposeEmitter.fire(undefined);
                            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, 'Pending response rejected since connection got disposed');
                            for (const promise of responsePromises.values()){
                                promise.reject(error);
                            }
                            responsePromises = new Map();
                            requestTokens = new Map();
                            knownCanceledRequests = new Set();
                            messageQueue = new linkedMap_1.LinkedMap();
                            // Test for backwards compatibility
                            if (Is.func(messageWriter.dispose)) {
                                messageWriter.dispose();
                            }
                            if (Is.func(messageReader.dispose)) {
                                messageReader.dispose();
                            }
                        },
                        listen: ()=>{
                            throwIfClosedOrDisposed();
                            throwIfListening();
                            state = ConnectionState.Listening;
                            messageReader.listen(callback);
                        },
                        inspect: ()=>{
                            // eslint-disable-next-line no-console
                            (0, ral_1.default)().console.log('inspect');
                        }
                    };
                    connection.onNotification(LogTraceNotification.type, (params)=>{
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
                        tracer.log(params.message, verbose ? params.verbose : undefined);
                    });
                    connection.onNotification(ProgressNotification.type, (params)=>{
                        const handler = progressHandlers.get(params.token);
                        if (handler) {
                            handler(params.value);
                        } else {
                            unhandledProgressEmitter.fire(params);
                        }
                    });
                    return connection;
                }
                exports1.createMessageConnection = createMessageConnection;
            //# sourceMappingURL=connection.js.map
            /***/ },
            /***/ 4250: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Disposable = void 0;
                var Disposable;
                (function(Disposable) {
                    function create(func) {
                        return {
                            dispose: func
                        };
                    }
                    Disposable.create = create;
                })(Disposable = exports1.Disposable || (exports1.Disposable = {}));
            //# sourceMappingURL=disposable.js.map
            /***/ },
            /***/ 7257: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_799785__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Emitter = exports1.Event = void 0;
                const ral_1 = __nested_webpack_require_799785__(5406);
                var Event1;
                (function(Event1) {
                    const _disposable = {
                        dispose () {}
                    };
                    Event1.None = function() {
                        return _disposable;
                    };
                })(Event1 = exports1.Event || (exports1.Event = {}));
                class CallbackList {
                    add(callback, context = null, bucket) {
                        if (!this._callbacks) {
                            this._callbacks = [];
                            this._contexts = [];
                        }
                        this._callbacks.push(callback);
                        this._contexts.push(context);
                        if (Array.isArray(bucket)) {
                            bucket.push({
                                dispose: ()=>this.remove(callback, context)
                            });
                        }
                    }
                    remove(callback, context = null) {
                        if (!this._callbacks) {
                            return;
                        }
                        let foundCallbackWithDifferentContext = false;
                        for(let i = 0, len = this._callbacks.length; i < len; i++){
                            if (this._callbacks[i] === callback) {
                                if (this._contexts[i] === context) {
                                    // callback & context match => remove it
                                    this._callbacks.splice(i, 1);
                                    this._contexts.splice(i, 1);
                                    return;
                                } else {
                                    foundCallbackWithDifferentContext = true;
                                }
                            }
                        }
                        if (foundCallbackWithDifferentContext) {
                            throw new Error('When adding a listener with a context, you should remove it with the same context');
                        }
                    }
                    invoke(...args) {
                        if (!this._callbacks) {
                            return [];
                        }
                        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
                        for(let i = 0, len = callbacks.length; i < len; i++){
                            try {
                                ret.push(callbacks[i].apply(contexts[i], args));
                            } catch (e) {
                                // eslint-disable-next-line no-console
                                (0, ral_1.default)().console.error(e);
                            }
                        }
                        return ret;
                    }
                    isEmpty() {
                        return !this._callbacks || this._callbacks.length === 0;
                    }
                    dispose() {
                        this._callbacks = undefined;
                        this._contexts = undefined;
                    }
                }
                class Emitter {
                    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */ get event() {
                        if (!this._event) {
                            this._event = (listener, thisArgs, disposables)=>{
                                if (!this._callbacks) {
                                    this._callbacks = new CallbackList();
                                }
                                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                                    this._options.onFirstListenerAdd(this);
                                }
                                this._callbacks.add(listener, thisArgs);
                                const result = {
                                    dispose: ()=>{
                                        if (!this._callbacks) {
                                            // disposable is disposed after emitter is disposed.
                                            return;
                                        }
                                        this._callbacks.remove(listener, thisArgs);
                                        result.dispose = Emitter._noop;
                                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                                            this._options.onLastListenerRemove(this);
                                        }
                                    }
                                };
                                if (Array.isArray(disposables)) {
                                    disposables.push(result);
                                }
                                return result;
                            };
                        }
                        return this._event;
                    }
                    /**
     * To be kept private to fire an event to
     * subscribers
     */ fire(event) {
                        if (this._callbacks) {
                            this._callbacks.invoke.call(this._callbacks, event);
                        }
                    }
                    dispose() {
                        if (this._callbacks) {
                            this._callbacks.dispose();
                            this._callbacks = undefined;
                        }
                    }
                    constructor(_options){
                        this._options = _options;
                    }
                }
                exports1.Emitter = Emitter;
                Emitter._noop = function() {};
            //# sourceMappingURL=events.js.map
            /***/ },
            /***/ 1278: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.stringArray = exports1.array = exports1.func = exports1.error = exports1.number = exports1.string = exports1.boolean = void 0;
                function boolean(value) {
                    return value === true || value === false;
                }
                exports1.boolean = boolean;
                function string(value) {
                    return typeof value === 'string' || value instanceof String;
                }
                exports1.string = string;
                function number(value) {
                    return typeof value === 'number' || value instanceof Number;
                }
                exports1.number = number;
                function error(value) {
                    return value instanceof Error;
                }
                exports1.error = error;
                function func(value) {
                    return typeof value === 'function';
                }
                exports1.func = func;
                function array(value) {
                    return Array.isArray(value);
                }
                exports1.array = array;
                function stringArray(value) {
                    return array(value) && value.every((elem)=>string(elem));
                }
                exports1.stringArray = stringArray;
            //# sourceMappingURL=is.js.map
            /***/ },
            /***/ 1414: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ var _a;
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LRUCache = exports1.LinkedMap = exports1.Touch = void 0;
                var Touch;
                (function(Touch) {
                    Touch.None = 0;
                    Touch.First = 1;
                    Touch.AsOld = Touch.First;
                    Touch.Last = 2;
                    Touch.AsNew = Touch.Last;
                })(Touch = exports1.Touch || (exports1.Touch = {}));
                class LinkedMap {
                    clear() {
                        this._map.clear();
                        this._head = undefined;
                        this._tail = undefined;
                        this._size = 0;
                        this._state++;
                    }
                    isEmpty() {
                        return !this._head && !this._tail;
                    }
                    get size() {
                        return this._size;
                    }
                    get first() {
                        var _this__head;
                        return (_this__head = this._head) === null || _this__head === void 0 ? void 0 : _this__head.value;
                    }
                    get last() {
                        var _this__tail;
                        return (_this__tail = this._tail) === null || _this__tail === void 0 ? void 0 : _this__tail.value;
                    }
                    has(key) {
                        return this._map.has(key);
                    }
                    get(key, touch = Touch.None) {
                        const item = this._map.get(key);
                        if (!item) {
                            return undefined;
                        }
                        if (touch !== Touch.None) {
                            this.touch(item, touch);
                        }
                        return item.value;
                    }
                    set(key, value, touch = Touch.None) {
                        let item = this._map.get(key);
                        if (item) {
                            item.value = value;
                            if (touch !== Touch.None) {
                                this.touch(item, touch);
                            }
                        } else {
                            item = {
                                key,
                                value,
                                next: undefined,
                                previous: undefined
                            };
                            switch(touch){
                                case Touch.None:
                                    this.addItemLast(item);
                                    break;
                                case Touch.First:
                                    this.addItemFirst(item);
                                    break;
                                case Touch.Last:
                                    this.addItemLast(item);
                                    break;
                                default:
                                    this.addItemLast(item);
                                    break;
                            }
                            this._map.set(key, item);
                            this._size++;
                        }
                        return this;
                    }
                    delete(key) {
                        return !!this.remove(key);
                    }
                    remove(key) {
                        const item = this._map.get(key);
                        if (!item) {
                            return undefined;
                        }
                        this._map.delete(key);
                        this.removeItem(item);
                        this._size--;
                        return item.value;
                    }
                    shift() {
                        if (!this._head && !this._tail) {
                            return undefined;
                        }
                        if (!this._head || !this._tail) {
                            throw new Error('Invalid list');
                        }
                        const item = this._head;
                        this._map.delete(item.key);
                        this.removeItem(item);
                        this._size--;
                        return item.value;
                    }
                    forEach(callbackfn, thisArg) {
                        const state = this._state;
                        let current = this._head;
                        while(current){
                            if (thisArg) {
                                callbackfn.bind(thisArg)(current.value, current.key, this);
                            } else {
                                callbackfn(current.value, current.key, this);
                            }
                            if (this._state !== state) {
                                throw new Error(`LinkedMap got modified during iteration.`);
                            }
                            current = current.next;
                        }
                    }
                    keys() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: current.key,
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    values() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: current.value,
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    entries() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: [
                                            current.key,
                                            current.value
                                        ],
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
                        return this.entries();
                    }
                    trimOld(newSize) {
                        if (newSize >= this.size) {
                            return;
                        }
                        if (newSize === 0) {
                            this.clear();
                            return;
                        }
                        let current = this._head;
                        let currentSize = this.size;
                        while(current && currentSize > newSize){
                            this._map.delete(current.key);
                            current = current.next;
                            currentSize--;
                        }
                        this._head = current;
                        this._size = currentSize;
                        if (current) {
                            current.previous = undefined;
                        }
                        this._state++;
                    }
                    addItemFirst(item) {
                        // First time Insert
                        if (!this._head && !this._tail) {
                            this._tail = item;
                        } else if (!this._head) {
                            throw new Error('Invalid list');
                        } else {
                            item.next = this._head;
                            this._head.previous = item;
                        }
                        this._head = item;
                        this._state++;
                    }
                    addItemLast(item) {
                        // First time Insert
                        if (!this._head && !this._tail) {
                            this._head = item;
                        } else if (!this._tail) {
                            throw new Error('Invalid list');
                        } else {
                            item.previous = this._tail;
                            this._tail.next = item;
                        }
                        this._tail = item;
                        this._state++;
                    }
                    removeItem(item) {
                        if (item === this._head && item === this._tail) {
                            this._head = undefined;
                            this._tail = undefined;
                        } else if (item === this._head) {
                            // This can only happened if size === 1 which is handle
                            // by the case above.
                            if (!item.next) {
                                throw new Error('Invalid list');
                            }
                            item.next.previous = undefined;
                            this._head = item.next;
                        } else if (item === this._tail) {
                            // This can only happened if size === 1 which is handle
                            // by the case above.
                            if (!item.previous) {
                                throw new Error('Invalid list');
                            }
                            item.previous.next = undefined;
                            this._tail = item.previous;
                        } else {
                            const next = item.next;
                            const previous = item.previous;
                            if (!next || !previous) {
                                throw new Error('Invalid list');
                            }
                            next.previous = previous;
                            previous.next = next;
                        }
                        item.next = undefined;
                        item.previous = undefined;
                        this._state++;
                    }
                    touch(item, touch) {
                        if (!this._head || !this._tail) {
                            throw new Error('Invalid list');
                        }
                        if (touch !== Touch.First && touch !== Touch.Last) {
                            return;
                        }
                        if (touch === Touch.First) {
                            if (item === this._head) {
                                return;
                            }
                            const next = item.next;
                            const previous = item.previous;
                            // Unlink the item
                            if (item === this._tail) {
                                // previous must be defined since item was not head but is tail
                                // So there are more than on item in the map
                                previous.next = undefined;
                                this._tail = previous;
                            } else {
                                // Both next and previous are not undefined since item was neither head nor tail.
                                next.previous = previous;
                                previous.next = next;
                            }
                            // Insert the node at head
                            item.previous = undefined;
                            item.next = this._head;
                            this._head.previous = item;
                            this._head = item;
                            this._state++;
                        } else if (touch === Touch.Last) {
                            if (item === this._tail) {
                                return;
                            }
                            const next = item.next;
                            const previous = item.previous;
                            // Unlink the item.
                            if (item === this._head) {
                                // next must be defined since item was not tail but is head
                                // So there are more than on item in the map
                                next.previous = undefined;
                                this._head = next;
                            } else {
                                // Both next and previous are not undefined since item was neither head nor tail.
                                next.previous = previous;
                                previous.next = next;
                            }
                            item.next = undefined;
                            item.previous = this._tail;
                            this._tail.next = item;
                            this._tail = item;
                            this._state++;
                        }
                    }
                    toJSON() {
                        const data = [];
                        this.forEach((value, key)=>{
                            data.push([
                                key,
                                value
                            ]);
                        });
                        return data;
                    }
                    fromJSON(data) {
                        this.clear();
                        for (const [key, value] of data){
                            this.set(key, value);
                        }
                    }
                    constructor(){
                        this[_a] = 'LinkedMap';
                        this._map = new Map();
                        this._head = undefined;
                        this._tail = undefined;
                        this._size = 0;
                        this._state = 0;
                    }
                }
                exports1.LinkedMap = LinkedMap;
                class LRUCache extends LinkedMap {
                    get limit() {
                        return this._limit;
                    }
                    set limit(limit) {
                        this._limit = limit;
                        this.checkTrim();
                    }
                    get ratio() {
                        return this._ratio;
                    }
                    set ratio(ratio) {
                        this._ratio = Math.min(Math.max(0, ratio), 1);
                        this.checkTrim();
                    }
                    get(key, touch = Touch.AsNew) {
                        return super.get(key, touch);
                    }
                    peek(key) {
                        return super.get(key, Touch.None);
                    }
                    set(key, value) {
                        super.set(key, value, Touch.Last);
                        this.checkTrim();
                        return this;
                    }
                    checkTrim() {
                        if (this.size > this._limit) {
                            this.trimOld(Math.round(this._limit * this._ratio));
                        }
                    }
                    constructor(limit, ratio = 1){
                        super();
                        this._limit = limit;
                        this._ratio = Math.min(Math.max(0, ratio), 1);
                    }
                }
                exports1.LRUCache = LRUCache;
            //# sourceMappingURL=linkedMap.js.map
            /***/ },
            /***/ 5947: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.AbstractMessageBuffer = void 0;
                const CR = 13;
                const LF = 10;
                const CRLF = '\r\n';
                class AbstractMessageBuffer {
                    get encoding() {
                        return this._encoding;
                    }
                    append(chunk) {
                        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;
                        this._chunks.push(toAppend);
                        this._totalLength += toAppend.byteLength;
                    }
                    tryReadHeaders() {
                        if (this._chunks.length === 0) {
                            return undefined;
                        }
                        let state = 0;
                        let chunkIndex = 0;
                        let offset = 0;
                        let chunkBytesRead = 0;
                        row: while(chunkIndex < this._chunks.length){
                            const chunk = this._chunks[chunkIndex];
                            offset = 0;
                            column: while(offset < chunk.length){
                                const value = chunk[offset];
                                switch(value){
                                    case CR:
                                        switch(state){
                                            case 0:
                                                state = 1;
                                                break;
                                            case 2:
                                                state = 3;
                                                break;
                                            default:
                                                state = 0;
                                        }
                                        break;
                                    case LF:
                                        switch(state){
                                            case 1:
                                                state = 2;
                                                break;
                                            case 3:
                                                state = 4;
                                                offset++;
                                                break row;
                                            default:
                                                state = 0;
                                        }
                                        break;
                                    default:
                                        state = 0;
                                }
                                offset++;
                            }
                            chunkBytesRead += chunk.byteLength;
                            chunkIndex++;
                        }
                        if (state !== 4) {
                            return undefined;
                        }
                        // The buffer contains the two CRLF at the end. So we will
                        // have two empty lines after the split at the end as well.
                        const buffer = this._read(chunkBytesRead + offset);
                        const result = new Map();
                        const headers = this.toString(buffer, 'ascii').split(CRLF);
                        if (headers.length < 2) {
                            return result;
                        }
                        for(let i = 0; i < headers.length - 2; i++){
                            const header = headers[i];
                            const index = header.indexOf(':');
                            if (index === -1) {
                                throw new Error('Message header must separate key and value using :');
                            }
                            const key = header.substr(0, index);
                            const value = header.substr(index + 1).trim();
                            result.set(key, value);
                        }
                        return result;
                    }
                    tryReadBody(length) {
                        if (this._totalLength < length) {
                            return undefined;
                        }
                        return this._read(length);
                    }
                    get numberOfBytes() {
                        return this._totalLength;
                    }
                    _read(byteCount) {
                        if (byteCount === 0) {
                            return this.emptyBuffer();
                        }
                        if (byteCount > this._totalLength) {
                            throw new Error(`Cannot read so many bytes!`);
                        }
                        if (this._chunks[0].byteLength === byteCount) {
                            // super fast path, precisely first chunk must be returned
                            const chunk = this._chunks[0];
                            this._chunks.shift();
                            this._totalLength -= byteCount;
                            return this.asNative(chunk);
                        }
                        if (this._chunks[0].byteLength > byteCount) {
                            // fast path, the reading is entirely within the first chunk
                            const chunk = this._chunks[0];
                            const result = this.asNative(chunk, byteCount);
                            this._chunks[0] = chunk.slice(byteCount);
                            this._totalLength -= byteCount;
                            return result;
                        }
                        const result = this.allocNative(byteCount);
                        let resultOffset = 0;
                        let chunkIndex = 0;
                        while(byteCount > 0){
                            const chunk = this._chunks[chunkIndex];
                            if (chunk.byteLength > byteCount) {
                                // this chunk will survive
                                const chunkPart = chunk.slice(0, byteCount);
                                result.set(chunkPart, resultOffset);
                                resultOffset += byteCount;
                                this._chunks[chunkIndex] = chunk.slice(byteCount);
                                this._totalLength -= byteCount;
                                byteCount -= byteCount;
                            } else {
                                // this chunk will be entirely read
                                result.set(chunk, resultOffset);
                                resultOffset += chunk.byteLength;
                                this._chunks.shift();
                                this._totalLength -= chunk.byteLength;
                                byteCount -= chunk.byteLength;
                            }
                        }
                        return result;
                    }
                    constructor(encoding = 'utf-8'){
                        this._encoding = encoding;
                        this._chunks = [];
                        this._totalLength = 0;
                    }
                }
                exports1.AbstractMessageBuffer = AbstractMessageBuffer;
            //# sourceMappingURL=messageBuffer.js.map
            /***/ },
            /***/ 207: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_835618__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ReadableStreamMessageReader = exports1.AbstractMessageReader = exports1.MessageReader = void 0;
                const ral_1 = __nested_webpack_require_835618__(5406);
                const Is = __nested_webpack_require_835618__(1278);
                const events_1 = __nested_webpack_require_835618__(7257);
                var MessageReader;
                (function(MessageReader) {
                    function is(value) {
                        let candidate = value;
                        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
                    }
                    MessageReader.is = is;
                })(MessageReader = exports1.MessageReader || (exports1.MessageReader = {}));
                class AbstractMessageReader {
                    dispose() {
                        this.errorEmitter.dispose();
                        this.closeEmitter.dispose();
                    }
                    get onError() {
                        return this.errorEmitter.event;
                    }
                    fireError(error) {
                        this.errorEmitter.fire(this.asError(error));
                    }
                    get onClose() {
                        return this.closeEmitter.event;
                    }
                    fireClose() {
                        this.closeEmitter.fire(undefined);
                    }
                    get onPartialMessage() {
                        return this.partialMessageEmitter.event;
                    }
                    firePartialMessage(info) {
                        this.partialMessageEmitter.fire(info);
                    }
                    asError(error) {
                        if (error instanceof Error) {
                            return error;
                        } else {
                            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
                        }
                    }
                    constructor(){
                        this.errorEmitter = new events_1.Emitter();
                        this.closeEmitter = new events_1.Emitter();
                        this.partialMessageEmitter = new events_1.Emitter();
                    }
                }
                exports1.AbstractMessageReader = AbstractMessageReader;
                var ResolvedMessageReaderOptions;
                (function(ResolvedMessageReaderOptions) {
                    function fromOptions(options) {
                        let charset;
                        let result;
                        let contentDecoder;
                        const contentDecoders = new Map();
                        let contentTypeDecoder;
                        const contentTypeDecoders = new Map();
                        if (options === undefined || typeof options === 'string') {
                            charset = options !== null && options !== void 0 ? options : 'utf-8';
                        } else {
                            var _options_charset;
                            charset = (_options_charset = options.charset) !== null && _options_charset !== void 0 ? _options_charset : 'utf-8';
                            if (options.contentDecoder !== undefined) {
                                contentDecoder = options.contentDecoder;
                                contentDecoders.set(contentDecoder.name, contentDecoder);
                            }
                            if (options.contentDecoders !== undefined) {
                                for (const decoder of options.contentDecoders){
                                    contentDecoders.set(decoder.name, decoder);
                                }
                            }
                            if (options.contentTypeDecoder !== undefined) {
                                contentTypeDecoder = options.contentTypeDecoder;
                                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
                            }
                            if (options.contentTypeDecoders !== undefined) {
                                for (const decoder of options.contentTypeDecoders){
                                    contentTypeDecoders.set(decoder.name, decoder);
                                }
                            }
                        }
                        if (contentTypeDecoder === undefined) {
                            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
                            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
                        }
                        return {
                            charset,
                            contentDecoder,
                            contentDecoders,
                            contentTypeDecoder,
                            contentTypeDecoders
                        };
                    }
                    ResolvedMessageReaderOptions.fromOptions = fromOptions;
                })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
                class ReadableStreamMessageReader extends AbstractMessageReader {
                    set partialMessageTimeout(timeout) {
                        this._partialMessageTimeout = timeout;
                    }
                    get partialMessageTimeout() {
                        return this._partialMessageTimeout;
                    }
                    listen(callback) {
                        this.nextMessageLength = -1;
                        this.messageToken = 0;
                        this.partialMessageTimer = undefined;
                        this.callback = callback;
                        const result = this.readable.onData((data)=>{
                            this.onData(data);
                        });
                        this.readable.onError((error)=>this.fireError(error));
                        this.readable.onClose(()=>this.fireClose());
                        return result;
                    }
                    onData(data) {
                        this.buffer.append(data);
                        while(true){
                            if (this.nextMessageLength === -1) {
                                const headers = this.buffer.tryReadHeaders();
                                if (!headers) {
                                    return;
                                }
                                const contentLength = headers.get('Content-Length');
                                if (!contentLength) {
                                    throw new Error('Header must provide a Content-Length property.');
                                }
                                const length = parseInt(contentLength);
                                if (isNaN(length)) {
                                    throw new Error('Content-Length value must be a number.');
                                }
                                this.nextMessageLength = length;
                            }
                            const body = this.buffer.tryReadBody(this.nextMessageLength);
                            if (body === undefined) {
                                /** We haven't received the full message yet. */ this.setPartialMessageTimer();
                                return;
                            }
                            this.clearPartialMessageTimer();
                            this.nextMessageLength = -1;
                            let p;
                            if (this.options.contentDecoder !== undefined) {
                                p = this.options.contentDecoder.decode(body);
                            } else {
                                p = Promise.resolve(body);
                            }
                            p.then((value)=>{
                                this.options.contentTypeDecoder.decode(value, this.options).then((msg)=>{
                                    this.callback(msg);
                                }, (error)=>{
                                    this.fireError(error);
                                });
                            }, (error)=>{
                                this.fireError(error);
                            });
                        }
                    }
                    clearPartialMessageTimer() {
                        if (this.partialMessageTimer) {
                            this.partialMessageTimer.dispose();
                            this.partialMessageTimer = undefined;
                        }
                    }
                    setPartialMessageTimer() {
                        this.clearPartialMessageTimer();
                        if (this._partialMessageTimeout <= 0) {
                            return;
                        }
                        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout)=>{
                            this.partialMessageTimer = undefined;
                            if (token === this.messageToken) {
                                this.firePartialMessage({
                                    messageToken: token,
                                    waitingTime: timeout
                                });
                                this.setPartialMessageTimer();
                            }
                        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
                    }
                    constructor(readable, options){
                        super();
                        this.readable = readable;
                        this.options = ResolvedMessageReaderOptions.fromOptions(options);
                        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
                        this._partialMessageTimeout = 10000;
                        this.nextMessageLength = -1;
                        this.messageToken = 0;
                    }
                }
                exports1.ReadableStreamMessageReader = ReadableStreamMessageReader;
            //# sourceMappingURL=messageReader.js.map
            /***/ },
            /***/ 6214: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_846598__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WriteableStreamMessageWriter = exports1.AbstractMessageWriter = exports1.MessageWriter = void 0;
                const ral_1 = __nested_webpack_require_846598__(5406);
                const Is = __nested_webpack_require_846598__(1278);
                const semaphore_1 = __nested_webpack_require_846598__(4197);
                const events_1 = __nested_webpack_require_846598__(7257);
                const ContentLength = 'Content-Length: ';
                const CRLF = '\r\n';
                var MessageWriter;
                (function(MessageWriter) {
                    function is(value) {
                        let candidate = value;
                        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
                    }
                    MessageWriter.is = is;
                })(MessageWriter = exports1.MessageWriter || (exports1.MessageWriter = {}));
                class AbstractMessageWriter {
                    dispose() {
                        this.errorEmitter.dispose();
                        this.closeEmitter.dispose();
                    }
                    get onError() {
                        return this.errorEmitter.event;
                    }
                    fireError(error, message, count) {
                        this.errorEmitter.fire([
                            this.asError(error),
                            message,
                            count
                        ]);
                    }
                    get onClose() {
                        return this.closeEmitter.event;
                    }
                    fireClose() {
                        this.closeEmitter.fire(undefined);
                    }
                    asError(error) {
                        if (error instanceof Error) {
                            return error;
                        } else {
                            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
                        }
                    }
                    constructor(){
                        this.errorEmitter = new events_1.Emitter();
                        this.closeEmitter = new events_1.Emitter();
                    }
                }
                exports1.AbstractMessageWriter = AbstractMessageWriter;
                var ResolvedMessageWriterOptions;
                (function(ResolvedMessageWriterOptions) {
                    function fromOptions(options) {
                        if (options === undefined || typeof options === 'string') {
                            return {
                                charset: options !== null && options !== void 0 ? options : 'utf-8',
                                contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder
                            };
                        } else {
                            var _options_charset, _options_contentTypeEncoder;
                            return {
                                charset: (_options_charset = options.charset) !== null && _options_charset !== void 0 ? _options_charset : 'utf-8',
                                contentEncoder: options.contentEncoder,
                                contentTypeEncoder: (_options_contentTypeEncoder = options.contentTypeEncoder) !== null && _options_contentTypeEncoder !== void 0 ? _options_contentTypeEncoder : (0, ral_1.default)().applicationJson.encoder
                            };
                        }
                    }
                    ResolvedMessageWriterOptions.fromOptions = fromOptions;
                })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
                class WriteableStreamMessageWriter extends AbstractMessageWriter {
                    async write(msg) {
                        return this.writeSemaphore.lock(async ()=>{
                            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer)=>{
                                if (this.options.contentEncoder !== undefined) {
                                    return this.options.contentEncoder.encode(buffer);
                                } else {
                                    return buffer;
                                }
                            });
                            return payload.then((buffer)=>{
                                const headers = [];
                                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
                                headers.push(CRLF);
                                return this.doWrite(msg, headers, buffer);
                            }, (error)=>{
                                this.fireError(error);
                                throw error;
                            });
                        });
                    }
                    async doWrite(msg, headers, data) {
                        try {
                            await this.writable.write(headers.join(''), 'ascii');
                            return this.writable.write(data);
                        } catch (error) {
                            this.handleError(error, msg);
                            return Promise.reject(error);
                        }
                    }
                    handleError(error, msg) {
                        this.errorCount++;
                        this.fireError(error, msg, this.errorCount);
                    }
                    end() {
                        this.writable.end();
                    }
                    constructor(writable, options){
                        super();
                        this.writable = writable;
                        this.options = ResolvedMessageWriterOptions.fromOptions(options);
                        this.errorCount = 0;
                        this.writeSemaphore = new semaphore_1.Semaphore(1);
                        this.writable.onError((error)=>this.fireError(error));
                        this.writable.onClose(()=>this.fireClose());
                    }
                }
                exports1.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
            //# sourceMappingURL=messageWriter.js.map
            /***/ },
            /***/ 5613: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_853538__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Message = exports1.NotificationType9 = exports1.NotificationType8 = exports1.NotificationType7 = exports1.NotificationType6 = exports1.NotificationType5 = exports1.NotificationType4 = exports1.NotificationType3 = exports1.NotificationType2 = exports1.NotificationType1 = exports1.NotificationType0 = exports1.NotificationType = exports1.RequestType9 = exports1.RequestType8 = exports1.RequestType7 = exports1.RequestType6 = exports1.RequestType5 = exports1.RequestType4 = exports1.RequestType3 = exports1.RequestType2 = exports1.RequestType1 = exports1.RequestType = exports1.RequestType0 = exports1.AbstractMessageSignature = exports1.ParameterStructures = exports1.ResponseError = exports1.ErrorCodes = void 0;
                const is = __nested_webpack_require_853538__(1278);
                /**
 * Predefined error codes.
 */ var ErrorCodes;
                (function(ErrorCodes) {
                    // Defined by JSON RPC
                    ErrorCodes.ParseError = -32700;
                    ErrorCodes.InvalidRequest = -32600;
                    ErrorCodes.MethodNotFound = -32601;
                    ErrorCodes.InvalidParams = -32602;
                    ErrorCodes.InternalError = -32603;
                    /**
     * This is the start range of JSON RPC reserved error codes.
     * It doesn't denote a real error code. No application error codes should
     * be defined between the start and end range. For backwards
     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
     * are left in the range.
     *
     * @since 3.16.0
    */ ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;
                    /** @deprecated use  jsonrpcReservedErrorRangeStart */ ErrorCodes.serverErrorStart = -32099;
                    /**
     * An error occurred when write a message to the transport layer.
     */ ErrorCodes.MessageWriteError = -32099;
                    /**
     * An error occurred when reading a message from the transport layer.
     */ ErrorCodes.MessageReadError = -32098;
                    /**
     * The connection got disposed or lost and all pending responses got
     * rejected.
     */ ErrorCodes.PendingResponseRejected = -32097;
                    /**
     * The connection is inactive and a use of it failed.
     */ ErrorCodes.ConnectionInactive = -32096;
                    /**
     * Error code indicating that a server received a notification or
     * request before the server has received the `initialize` request.
     */ ErrorCodes.ServerNotInitialized = -32002;
                    ErrorCodes.UnknownErrorCode = -32001;
                    /**
     * This is the end range of JSON RPC reserved error codes.
     * It doesn't denote a real error code.
     *
     * @since 3.16.0
    */ ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;
                    /** @deprecated use  jsonrpcReservedErrorRangeEnd */ ErrorCodes.serverErrorEnd = -32000;
                })(ErrorCodes = exports1.ErrorCodes || (exports1.ErrorCodes = {}));
                /**
 * An error object return in a response in case a request
 * has failed.
 */ class ResponseError extends Error {
                    toJson() {
                        const result = {
                            code: this.code,
                            message: this.message
                        };
                        if (this.data !== undefined) {
                            result.data = this.data;
                        }
                        return result;
                    }
                    constructor(code, message, data){
                        super(message);
                        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
                        this.data = data;
                        Object.setPrototypeOf(this, ResponseError.prototype);
                    }
                }
                exports1.ResponseError = ResponseError;
                class ParameterStructures {
                    static is(value) {
                        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
                    }
                    toString() {
                        return this.kind;
                    }
                    constructor(kind){
                        this.kind = kind;
                    }
                }
                exports1.ParameterStructures = ParameterStructures;
                /**
 * The parameter structure is automatically inferred on the number of parameters
 * and the parameter type in case of a single param.
 */ ParameterStructures.auto = new ParameterStructures('auto');
                /**
 * Forces `byPosition` parameter structure. This is useful if you have a single
 * parameter which has a literal type.
 */ ParameterStructures.byPosition = new ParameterStructures('byPosition');
                /**
 * Forces `byName` parameter structure. This is only useful when having a single
 * parameter. The library will report errors if used with a different number of
 * parameters.
 */ ParameterStructures.byName = new ParameterStructures('byName');
                /**
 * An abstract implementation of a MessageType.
 */ class AbstractMessageSignature {
                    get parameterStructures() {
                        return ParameterStructures.auto;
                    }
                    constructor(method, numberOfParams){
                        this.method = method;
                        this.numberOfParams = numberOfParams;
                    }
                }
                exports1.AbstractMessageSignature = AbstractMessageSignature;
                /**
 * Classes to type request response pairs
 */ class RequestType0 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 0);
                    }
                }
                exports1.RequestType0 = RequestType0;
                class RequestType extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.RequestType = RequestType;
                class RequestType1 extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.RequestType1 = RequestType1;
                class RequestType2 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 2);
                    }
                }
                exports1.RequestType2 = RequestType2;
                class RequestType3 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 3);
                    }
                }
                exports1.RequestType3 = RequestType3;
                class RequestType4 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 4);
                    }
                }
                exports1.RequestType4 = RequestType4;
                class RequestType5 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 5);
                    }
                }
                exports1.RequestType5 = RequestType5;
                class RequestType6 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 6);
                    }
                }
                exports1.RequestType6 = RequestType6;
                class RequestType7 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 7);
                    }
                }
                exports1.RequestType7 = RequestType7;
                class RequestType8 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 8);
                    }
                }
                exports1.RequestType8 = RequestType8;
                class RequestType9 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 9);
                    }
                }
                exports1.RequestType9 = RequestType9;
                class NotificationType extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.NotificationType = NotificationType;
                class NotificationType0 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 0);
                    }
                }
                exports1.NotificationType0 = NotificationType0;
                class NotificationType1 extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.NotificationType1 = NotificationType1;
                class NotificationType2 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 2);
                    }
                }
                exports1.NotificationType2 = NotificationType2;
                class NotificationType3 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 3);
                    }
                }
                exports1.NotificationType3 = NotificationType3;
                class NotificationType4 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 4);
                    }
                }
                exports1.NotificationType4 = NotificationType4;
                class NotificationType5 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 5);
                    }
                }
                exports1.NotificationType5 = NotificationType5;
                class NotificationType6 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 6);
                    }
                }
                exports1.NotificationType6 = NotificationType6;
                class NotificationType7 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 7);
                    }
                }
                exports1.NotificationType7 = NotificationType7;
                class NotificationType8 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 8);
                    }
                }
                exports1.NotificationType8 = NotificationType8;
                class NotificationType9 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 9);
                    }
                }
                exports1.NotificationType9 = NotificationType9;
                var Message;
                (function(Message) {
                    /**
     * Tests if the given message is a request message
     */ function isRequest(message) {
                        const candidate = message;
                        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
                    }
                    Message.isRequest = isRequest;
                    /**
     * Tests if the given message is a notification message
     */ function isNotification(message) {
                        const candidate = message;
                        return candidate && is.string(candidate.method) && message.id === void 0;
                    }
                    Message.isNotification = isNotification;
                    /**
     * Tests if the given message is a response message
     */ function isResponse(message) {
                        const candidate = message;
                        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
                    }
                    Message.isResponse = isResponse;
                })(Message = exports1.Message || (exports1.Message = {}));
            //# sourceMappingURL=messages.js.map
            /***/ },
            /***/ 5406: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                let _ral;
                function RAL() {
                    if (_ral === undefined) {
                        throw new Error(`No runtime abstraction layer installed`);
                    }
                    return _ral;
                }
                (function(RAL) {
                    function install(ral) {
                        if (ral === undefined) {
                            throw new Error(`No runtime abstraction layer provided`);
                        }
                        _ral = ral;
                    }
                    RAL.install = install;
                })(RAL || (RAL = {}));
                exports1["default"] = RAL;
            //# sourceMappingURL=ral.js.map
            /***/ },
            /***/ 4197: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_869139__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Semaphore = void 0;
                const ral_1 = __nested_webpack_require_869139__(5406);
                class Semaphore {
                    lock(thunk) {
                        return new Promise((resolve, reject)=>{
                            this._waiting.push({
                                thunk,
                                resolve,
                                reject
                            });
                            this.runNext();
                        });
                    }
                    get active() {
                        return this._active;
                    }
                    runNext() {
                        if (this._waiting.length === 0 || this._active === this._capacity) {
                            return;
                        }
                        (0, ral_1.default)().timer.setImmediate(()=>this.doRunNext());
                    }
                    doRunNext() {
                        if (this._waiting.length === 0 || this._active === this._capacity) {
                            return;
                        }
                        const next = this._waiting.shift();
                        this._active++;
                        if (this._active > this._capacity) {
                            throw new Error(`To many thunks active`);
                        }
                        try {
                            const result = next.thunk();
                            if (result instanceof Promise) {
                                result.then((value)=>{
                                    this._active--;
                                    next.resolve(value);
                                    this.runNext();
                                }, (err)=>{
                                    this._active--;
                                    next.reject(err);
                                    this.runNext();
                                });
                            } else {
                                this._active--;
                                next.resolve(result);
                                this.runNext();
                            }
                        } catch (err) {
                            this._active--;
                            next.reject(err);
                            this.runNext();
                        }
                    }
                    constructor(capacity = 1){
                        if (capacity <= 0) {
                            throw new Error('Capacity must be greater than 0');
                        }
                        this._capacity = capacity;
                        this._active = 0;
                        this._waiting = [];
                    }
                }
                exports1.Semaphore = Semaphore;
            //# sourceMappingURL=semaphore.js.map
            /***/ },
            /***/ 2094: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_872632__)=>{
                "use strict";
                var forEach = __nested_webpack_require_872632__(3243);
                var availableTypedArrays = __nested_webpack_require_872632__(2191);
                var callBind = __nested_webpack_require_872632__(9429);
                var callBound = __nested_webpack_require_872632__(2680);
                var gOPD = __nested_webpack_require_872632__(326);
                var $toString = callBound('Object.prototype.toString');
                var hasToStringTag = __nested_webpack_require_872632__(7226)();
                var g = typeof globalThis === 'undefined' ? __nested_webpack_require_872632__.g : globalThis;
                var typedArrays = availableTypedArrays();
                var $slice = callBound('String.prototype.slice');
                var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
                var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
                    for(var i = 0; i < array.length; i += 1){
                        if (array[i] === value) {
                            return i;
                        }
                    }
                    return -1;
                };
                var cache = {
                    __proto__: null
                };
                if (hasToStringTag && gOPD && getPrototypeOf) {
                    forEach(typedArrays, function(typedArray) {
                        var arr = new g[typedArray]();
                        if (Symbol.toStringTag in arr) {
                            var proto = getPrototypeOf(arr);
                            var descriptor = gOPD(proto, Symbol.toStringTag);
                            if (!descriptor) {
                                var superProto = getPrototypeOf(proto);
                                descriptor = gOPD(superProto, Symbol.toStringTag);
                            }
                            cache['$' + typedArray] = callBind(descriptor.get);
                        }
                    });
                } else {
                    forEach(typedArrays, function(typedArray) {
                        var arr = new g[typedArray]();
                        cache['$' + typedArray] = callBind(arr.slice);
                    });
                }
                var tryTypedArrays = function tryAllTypedArrays(value) {
                    var found = false;
                    forEach(cache, function(getter, typedArray) {
                        if (!found) {
                            try {
                                if ('$' + getter(value) === typedArray) {
                                    found = $slice(typedArray, 1);
                                }
                            } catch (e) {}
                        }
                    });
                    return found;
                };
                var trySlices = function tryAllSlices(value) {
                    var found = false;
                    forEach(cache, function(getter, name) {
                        if (!found) {
                            try {
                                getter(value);
                                found = $slice(name, 1);
                            } catch (e) {}
                        }
                    });
                    return found;
                };
                module1.exports = function whichTypedArray(value) {
                    if (!value || typeof value !== 'object') {
                        return false;
                    }
                    if (!hasToStringTag) {
                        var tag = $slice($toString(value), 8, -1);
                        if ($indexOf(typedArrays, tag) > -1) {
                            return tag;
                        }
                        if (tag !== 'Object') {
                            return false;
                        }
                        // node < 0.6 hits here on real Typed Arrays
                        return trySlices(value);
                    }
                    if (!gOPD) {
                        return null;
                    } // unknown engine
                    return tryTypedArrays(value);
                };
            /***/ },
            /***/ 2191: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_876879__)=>{
                "use strict";
                var possibleNames = [
                    'BigInt64Array',
                    'BigUint64Array',
                    'Float32Array',
                    'Float64Array',
                    'Int16Array',
                    'Int32Array',
                    'Int8Array',
                    'Uint16Array',
                    'Uint32Array',
                    'Uint8Array',
                    'Uint8ClampedArray'
                ];
                var g = typeof globalThis === 'undefined' ? __nested_webpack_require_876879__.g : globalThis;
                module1.exports = function availableTypedArrays() {
                    var out = [];
                    for(var i = 0; i < possibleNames.length; i++){
                        if (typeof g[possibleNames[i]] === 'function') {
                            out[out.length] = possibleNames[i];
                        }
                    }
                    return out;
                };
            /***/ }
        };
        /************************************************************************/ /******/ // The module cache
        /******/ var __webpack_module_cache__ = {};
        /******/ /******/ // The require function
        /******/ function __nested_webpack_require_878145__(moduleId) {
            /******/ // Check if module is in cache
            /******/ var cachedModule = __webpack_module_cache__[moduleId];
            /******/ if (cachedModule !== undefined) {
                /******/ return cachedModule.exports;
            /******/ }
            /******/ // Create a new module (and put it into the cache)
            /******/ var module1 = __webpack_module_cache__[moduleId] = {
                /******/ // no module.id needed
                /******/ // no module.loaded needed
                /******/ exports: {}
            };
            /******/ /******/ // Execute the module function
            /******/ __webpack_modules__[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_878145__);
            /******/ /******/ // Return the exports of the module
            /******/ return module1.exports;
        /******/ }
        /******/ /************************************************************************/ /******/ /* webpack/runtime/define property getters */ /******/ (()=>{
            /******/ // define getter functions for harmony exports
            /******/ __nested_webpack_require_878145__.d = (exports1, definition)=>{
                /******/ for(var key in definition){
                    /******/ if (__nested_webpack_require_878145__.o(definition, key) && !__nested_webpack_require_878145__.o(exports1, key)) {
                        /******/ Object.defineProperty(exports1, key, {
                            enumerable: true,
                            get: definition[key]
                        });
                    /******/ }
                /******/ }
            /******/ };
        /******/ })();
        /******/ /******/ /* webpack/runtime/global */ /******/ (()=>{
            /******/ __nested_webpack_require_878145__.g = function() {
                /******/ if (typeof globalThis === 'object') return globalThis;
                /******/ try {
                    /******/ return this || new Function('return this')();
                /******/ } catch (e) {
                    /******/ if (typeof window === 'object') return window;
                /******/ }
            /******/ }();
        /******/ })();
        /******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ (()=>{
            /******/ __nested_webpack_require_878145__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
        /******/ })();
        /******/ /******/ /* webpack/runtime/make namespace object */ /******/ (()=>{
            /******/ // define __esModule on exports
            /******/ __nested_webpack_require_878145__.r = (exports1)=>{
                /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
                    /******/ Object.defineProperty(exports1, Symbol.toStringTag, {
                        value: 'Module'
                    });
                /******/ }
                /******/ Object.defineProperty(exports1, '__esModule', {
                    value: true
                });
            /******/ };
        /******/ })();
        /******/ /************************************************************************/ var __nested_webpack_exports__ = {};
        // This entry need to be wrapped in an IIFE because it need to be in strict mode.
        (()=>{
            "use strict";
            // ESM COMPAT FLAG
            __nested_webpack_require_878145__.r(__nested_webpack_exports__);
            // EXPORTS
            __nested_webpack_require_878145__.d(__nested_webpack_exports__, {
                LanguageClient: ()=>/* binding */ LanguageClient
            });
            // EXTERNAL MODULE: ../../node_modules/vscode-ws-jsonrpc/node_modules/vscode-jsonrpc/lib/browser/main.js
            var main = __nested_webpack_require_878145__(2032);
            // EXTERNAL MODULE: ../../node_modules/vscode-ws-jsonrpc/node_modules/vscode-jsonrpc/lib/common/messages.js
            var messages = __nested_webpack_require_878145__(5613);
            ; // CONCATENATED MODULE: ../../node_modules/vscode-ws-jsonrpc/lib/disposable.js
            /* --------------------------------------------------------------------------------------------
 * Copyright (c) 2018-2022 TypeFox GmbH (http://www.typefox.io). All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ class DisposableCollection {
                dispose() {
                    while(this.disposables.length !== 0){
                        this.disposables.pop().dispose();
                    }
                }
                push(disposable) {
                    const disposables = this.disposables;
                    disposables.push(disposable);
                    return {
                        dispose () {
                            const index = disposables.indexOf(disposable);
                            if (index !== -1) {
                                disposables.splice(index, 1);
                            }
                        }
                    };
                }
                constructor(){
                    _define_property(this, "disposables", []);
                }
            }
            //# sourceMappingURL=disposable.js.map
            // EXTERNAL MODULE: ../../node_modules/vscode-ws-jsonrpc/node_modules/vscode-jsonrpc/lib/common/messageReader.js
            var messageReader = __nested_webpack_require_878145__(207);
            ; // CONCATENATED MODULE: ../../node_modules/vscode-ws-jsonrpc/lib/socket/reader.js
            /* --------------------------------------------------------------------------------------------
 * Copyright (c) 2018-2022 TypeFox GmbH (http://www.typefox.io). All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ class WebSocketMessageReader extends messageReader.AbstractMessageReader {
                listen(callback) {
                    if (this.state === 'initial') {
                        this.state = 'listening';
                        this.callback = callback;
                        while(this.events.length !== 0){
                            const event = this.events.pop();
                            if (event.message) {
                                this.readMessage(event.message);
                            } else if (event.error) {
                                this.fireError(event.error);
                            } else {
                                this.fireClose();
                            }
                        }
                    }
                    return {
                        dispose: ()=>{
                            if (this.callback === callback) {
                                this.callback = undefined;
                            }
                        }
                    };
                }
                readMessage(message) {
                    if (this.state === 'initial') {
                        this.events.splice(0, 0, {
                            message
                        });
                    } else if (this.state === 'listening') {
                        try {
                            const data = JSON.parse(message);
                            this.callback(data);
                        } catch (err) {
                            const error = {
                                name: '' + 400,
                                message: `Error during message parsing, reason = ${typeof err === 'object' ? err.message : 'unknown'}`
                            };
                            this.fireError(error);
                        }
                    }
                }
                fireError(error) {
                    if (this.state === 'initial') {
                        this.events.splice(0, 0, {
                            error
                        });
                    } else if (this.state === 'listening') {
                        super.fireError(error);
                    }
                }
                fireClose() {
                    if (this.state === 'initial') {
                        this.events.splice(0, 0, {});
                    } else if (this.state === 'listening') {
                        super.fireClose();
                    }
                    this.state = 'closed';
                }
                constructor(socket){
                    super();
                    _define_property(this, "socket", void 0);
                    _define_property(this, "state", 'initial');
                    _define_property(this, "callback", void 0);
                    _define_property(this, "events", []);
                    this.socket = socket;
                    this.socket.onMessage((message)=>this.readMessage(message));
                    this.socket.onError((error)=>this.fireError(error));
                    this.socket.onClose((code, reason)=>{
                        if (code !== 1000) {
                            const error = {
                                name: '' + code,
                                message: `Error during socket reconnect: code = ${code}, reason = ${reason}`
                            };
                            this.fireError(error);
                        }
                        this.fireClose();
                    });
                }
            }
            //# sourceMappingURL=reader.js.map
            // EXTERNAL MODULE: ../../node_modules/vscode-ws-jsonrpc/node_modules/vscode-jsonrpc/lib/common/messageWriter.js
            var messageWriter = __nested_webpack_require_878145__(6214);
            ; // CONCATENATED MODULE: ../../node_modules/vscode-ws-jsonrpc/lib/socket/writer.js
            /* --------------------------------------------------------------------------------------------
 * Copyright (c) 2018-2022 TypeFox GmbH (http://www.typefox.io). All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ class WebSocketMessageWriter extends messageWriter.AbstractMessageWriter {
                end() {}
                async write(msg) {
                    try {
                        const content = JSON.stringify(msg);
                        this.socket.send(content);
                    } catch (e) {
                        this.errorCount++;
                        this.fireError(e, msg, this.errorCount);
                    }
                }
                constructor(socket){
                    super();
                    _define_property(this, "socket", void 0);
                    _define_property(this, "errorCount", 0);
                    this.socket = socket;
                }
            }
            //# sourceMappingURL=writer.js.map
            ; // CONCATENATED MODULE: ../../node_modules/vscode-ws-jsonrpc/lib/socket/connection.js
            /* --------------------------------------------------------------------------------------------
 * Copyright (c) 2018-2022 TypeFox GmbH (http://www.typefox.io). All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ function createWebSocketConnection(socket, logger) {
                const messageReader = new WebSocketMessageReader(socket);
                const messageWriter = new WebSocketMessageWriter(socket);
                const connection = (0, main.createMessageConnection)(messageReader, messageWriter, logger);
                connection.onClose(()=>connection.dispose());
                return connection;
            }
            //# sourceMappingURL=connection.js.map
            ; // CONCATENATED MODULE: ../../node_modules/vscode-ws-jsonrpc/lib/socket/index.js
            /* --------------------------------------------------------------------------------------------
 * Copyright (c) 2018-2022 TypeFox GmbH (http://www.typefox.io). All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ //# sourceMappingURL=index.js.map
            ; // CONCATENATED MODULE: ../../node_modules/vscode-ws-jsonrpc/lib/logger.js
            /* provided dependency */ var console = __nested_webpack_require_878145__(3716);
            class ConsoleLogger {
                error(message) {
                    console.error(message);
                }
                warn(message) {
                    console.warn(message);
                }
                info(message) {
                    console.info(message);
                }
                log(message) {
                    console.log(message);
                }
                debug(message) {
                    console.debug(message);
                }
            }
            //# sourceMappingURL=logger.js.map
            ; // CONCATENATED MODULE: ../../node_modules/vscode-ws-jsonrpc/lib/connection.js
            /* --------------------------------------------------------------------------------------------
 * Copyright (c) 2018-2022 TypeFox GmbH (http://www.typefox.io). All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ function listen(options) {
                const { webSocket, onConnection } = options;
                const logger = options.logger || new ConsoleLogger();
                webSocket.onopen = ()=>{
                    const socket = toSocket(webSocket);
                    const connection = createWebSocketConnection(socket, logger);
                    onConnection(connection);
                };
            }
            function toSocket(webSocket) {
                return {
                    send: (content)=>webSocket.send(content),
                    onMessage: (cb)=>{
                        webSocket.onmessage = (event)=>cb(event.data);
                    },
                    onError: (cb)=>{
                        webSocket.onerror = (event)=>{
                            if ('message' in event) {
                                cb(event.message);
                            }
                        };
                    },
                    onClose: (cb)=>{
                        webSocket.onclose = (event)=>cb(event.code, event.reason);
                    },
                    dispose: ()=>webSocket.close()
                };
            }
            //# sourceMappingURL=connection.js.map
            ; // CONCATENATED MODULE: ../../node_modules/vscode-ws-jsonrpc/lib/index.js
            /* --------------------------------------------------------------------------------------------
 * Copyright (c) 2018-2022 TypeFox GmbH (http://www.typefox.io). All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ //# sourceMappingURL=index.js.map
            // EXTERNAL MODULE: ../../node_modules/vscode-languageserver-protocol/lib/browser/main.js
            var browser_main = __nested_webpack_require_878145__(294);
            // EXTERNAL MODULE: ../../node_modules/vscode-languageserver-protocol/browser.js
            var browser = __nested_webpack_require_878145__(1789);
            // EXTERNAL MODULE: ./src/services/base-service.ts
            var base_service = __nested_webpack_require_878145__(4487);
            ; // CONCATENATED MODULE: ./src/message-types.ts
            function _define_property1(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                } else {
                    obj[key] = value;
                }
                return obj;
            }
            class BaseMessage {
                constructor(sessionId){
                    _define_property1(this, "sessionId", void 0);
                    this.sessionId = sessionId;
                }
            }
            class InitMessage extends /* unused pure expression or super */ (null && 0) {
                constructor(sessionId, value, version, mode, options){
                    super(sessionId);
                    _define_property1(this, "type", MessageType.init);
                    _define_property1(this, "mode", void 0);
                    _define_property1(this, "options", void 0);
                    _define_property1(this, "value", void 0);
                    _define_property1(this, "version", void 0);
                    this.version = version;
                    this.options = options;
                    this.mode = mode;
                    this.value = value;
                }
            }
            class FormatMessage extends /* unused pure expression or super */ (null && 0) {
                constructor(sessionId, value, format){
                    super(sessionId);
                    _define_property1(this, "type", MessageType.format);
                    _define_property1(this, "value", void 0);
                    _define_property1(this, "format", void 0);
                    this.value = value;
                    this.format = format;
                }
            }
            class CompleteMessage extends /* unused pure expression or super */ (null && 0) {
                constructor(sessionId, value){
                    super(sessionId);
                    _define_property1(this, "type", MessageType.complete);
                    _define_property1(this, "value", void 0);
                    this.value = value;
                }
            }
            class ResolveCompletionMessage extends /* unused pure expression or super */ (null && 0) {
                constructor(sessionId, value){
                    super(sessionId);
                    _define_property1(this, "type", MessageType.resolveCompletion);
                    _define_property1(this, "value", void 0);
                    this.value = value;
                }
            }
            class HoverMessage extends /* unused pure expression or super */ (null && 0) {
                constructor(sessionId, value){
                    super(sessionId);
                    _define_property1(this, "type", MessageType.hover);
                    _define_property1(this, "value", void 0);
                    this.value = value;
                }
            }
            class ValidateMessage extends /* unused pure expression or super */ (null && 0) {
                constructor(sessionId){
                    super(sessionId);
                    _define_property1(this, "type", MessageType.validate);
                }
            }
            class ChangeMessage extends /* unused pure expression or super */ (null && 0) {
                constructor(sessionId, value, version){
                    super(sessionId);
                    _define_property1(this, "type", MessageType.change);
                    _define_property1(this, "value", void 0);
                    _define_property1(this, "version", void 0);
                    this.value = value;
                    this.version = version;
                }
            }
            class DeltasMessage extends /* unused pure expression or super */ (null && 0) {
                constructor(sessionId, value, version){
                    super(sessionId);
                    _define_property1(this, "type", MessageType.applyDelta);
                    _define_property1(this, "value", void 0);
                    _define_property1(this, "version", void 0);
                    this.value = value;
                    this.version = version;
                }
            }
            class ChangeModeMessage extends /* unused pure expression or super */ (null && 0) {
                constructor(sessionId, value, mode){
                    super(sessionId);
                    _define_property1(this, "type", MessageType.changeMode);
                    _define_property1(this, "mode", void 0);
                    _define_property1(this, "value", void 0);
                    this.value = value;
                    this.mode = mode;
                }
            }
            class ChangeOptionsMessage extends /* unused pure expression or super */ (null && 0) {
                constructor(sessionId, options, merge = false){
                    super(sessionId);
                    _define_property1(this, "type", MessageType.changeOptions);
                    _define_property1(this, "options", void 0);
                    _define_property1(this, "merge", void 0);
                    this.options = options;
                    this.merge = merge;
                }
            }
            class DisposeMessage extends /* unused pure expression or super */ (null && 0) {
                constructor(sessionId){
                    super(sessionId);
                    _define_property1(this, "type", MessageType.dispose);
                }
            }
            class GlobalOptionsMessage {
                constructor(serviceName, options, merge){
                    _define_property1(this, "type", MessageType.globalOptions);
                    _define_property1(this, "serviceName", void 0);
                    _define_property1(this, "options", void 0);
                    _define_property1(this, "merge", void 0);
                    this.serviceName = serviceName;
                    this.options = options;
                    this.merge = merge;
                }
            }
            class ConfigureFeaturesMessage {
                constructor(serviceName, options){
                    _define_property1(this, "type", MessageType.configureFeatures);
                    _define_property1(this, "serviceName", void 0);
                    _define_property1(this, "options", void 0);
                    this.serviceName = serviceName;
                    this.options = options;
                }
            }
            class SignatureHelpMessage extends /* unused pure expression or super */ (null && 0) {
                constructor(sessionId, value){
                    super(sessionId);
                    _define_property1(this, "type", MessageType.signatureHelp);
                    _define_property1(this, "value", void 0);
                    this.value = value;
                }
            }
            class DocumentHighlightMessage extends /* unused pure expression or super */ (null && 0) {
                constructor(sessionId, value){
                    super(sessionId);
                    _define_property1(this, "type", MessageType.documentHighlight);
                    _define_property1(this, "value", void 0);
                    this.value = value;
                }
            }
            var MessageType;
            (function(MessageType) {
                MessageType[MessageType["init"] = 0] = "init";
                MessageType[MessageType["format"] = 1] = "format";
                MessageType[MessageType["complete"] = 2] = "complete";
                MessageType[MessageType["resolveCompletion"] = 3] = "resolveCompletion";
                MessageType[MessageType["change"] = 4] = "change";
                MessageType[MessageType["hover"] = 5] = "hover";
                MessageType[MessageType["validate"] = 6] = "validate";
                MessageType[MessageType["applyDelta"] = 7] = "applyDelta";
                MessageType[MessageType["changeMode"] = 8] = "changeMode";
                MessageType[MessageType["changeOptions"] = 9] = "changeOptions";
                MessageType[MessageType["dispose"] = 10] = "dispose";
                MessageType[MessageType["globalOptions"] = 11] = "globalOptions";
                MessageType[MessageType["configureFeatures"] = 12] = "configureFeatures";
                MessageType[MessageType["signatureHelp"] = 13] = "signatureHelp";
                MessageType[MessageType["documentHighlight"] = 14] = "documentHighlight";
            })(MessageType || (MessageType = {}));
            ; // CONCATENATED MODULE: ./src/services/language-client.ts
            /* provided dependency */ var language_client_console = __nested_webpack_require_878145__(3716);
            function language_client_define_property(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                } else {
                    obj[key] = value;
                }
                return obj;
            }
            class LanguageClient extends base_service.BaseService {
                $connectSocket(initializationOptions) {
                    if (this.socket.readyState === WebSocket.OPEN) {
                        listen({
                            webSocket: this.socket,
                            onConnection: (connection)=>{
                                this.$connect(connection, initializationOptions);
                            }
                        });
                        this.socket.dispatchEvent(new Event('open'));
                    } else {
                        listen({
                            webSocket: this.socket,
                            onConnection: (connection)=>{
                                this.$connect(connection, initializationOptions);
                            }
                        });
                    }
                }
                $connectWorker(worker, initializationOptions) {
                    const connection = (0, browser.createProtocolConnection)(new browser.BrowserMessageReader(worker), new browser.BrowserMessageWriter(worker));
                    this.$connect(connection, initializationOptions);
                }
                $connect(connection, initializationOptions) {
                    connection.listen();
                    this.isConnected = true;
                    this.connection = connection;
                    this.sendInitialize(initializationOptions);
                    this.connection.onNotification('textDocument/publishDiagnostics', (result)=>{
                        let postMessage = {
                            "type": MessageType.validate,
                            "sessionId": result.uri.replace(/^file:\/{2,3}/, ""),
                            "value": result.diagnostics
                        };
                        this.ctx.postMessage(postMessage);
                    });
                    this.connection.onNotification('window/showMessage', (params)=>{
                        this.showLog(params);
                    });
                    this.connection.onNotification('window/logMessage', (params)=>{
                        this.showLog(params);
                    });
                    this.connection.onNotification('$/logTrace', (params)=>{
                        this.showTrace(params);
                    });
                    this.connection.onRequest('window/showMessageRequest', (params)=>{
                        this.showLog(params);
                    });
                    this.connection.onRequest('workspace/configuration', (params)=>{
                        language_client_console.log(params);
                    });
                    this.connection.onRequest('client/registerCapability', (params)=>{
                        language_client_console.log(params);
                    });
                    this.connection.onError((e)=>{
                        throw e;
                    });
                    this.connection.onClose(()=>{
                        this.isConnected = false;
                    });
                }
                showLog(params) {
                    switch(params.type){
                        case 1:
                            language_client_console.error(params.message);
                            break;
                        case 2:
                            language_client_console.warn(params.message);
                            break;
                        case 3:
                            language_client_console.info(params.message);
                            break;
                        case 4:
                        default:
                            language_client_console.log(params.message);
                            break;
                    }
                }
                showTrace(params) {
                    language_client_console.log(params.message);
                    if (params.verbose) {
                        language_client_console.log(params.verbose);
                    }
                }
                addDocument(document1) {
                    super.addDocument(document1);
                    const textDocumentMessage = {
                        textDocument: document1
                    };
                    this.enqueueIfNotConnected(()=>this.connection.sendNotification('textDocument/didOpen', textDocumentMessage));
                }
                enqueueIfNotConnected(callback) {
                    if (!this.isConnected) {
                        this.requestsQueue.push(callback);
                    } else {
                        callback();
                    }
                }
                removeDocument(document1) {
                    super.removeDocument(document1);
                    this.enqueueIfNotConnected(()=>this.connection.sendNotification('textDocument/didClose', {
                            textDocument: {
                                uri: document1.uri
                            }
                        }));
                }
                /*
        close() {
            if (this.connection) {
                this.connection.dispose();
            }
            if (this.socket)
                this.socket.close();
        }
    */ sendInitialize(initializationOptions) {
                    if (!this.isConnected) {
                        return;
                    }
                    const message = {
                        capabilities: this.clientCapabilities,
                        initializationOptions: initializationOptions,
                        processId: null,
                        rootUri: "",
                        workspaceFolders: null
                    };
                    this.connection.sendRequest("initialize", message).then((params)=>{
                        this.isInitialized = true;
                        this.serviceCapabilities = params.capabilities;
                        this.connection.sendNotification('initialized', {}).then(()=>{
                            this.connection.sendNotification('workspace/didChangeConfiguration', {
                                settings: {}
                            });
                            this.requestsQueue.forEach((requestCallback)=>requestCallback());
                            this.requestsQueue = [];
                        });
                    });
                }
                applyDeltas(identifier, deltas) {
                    super.applyDeltas(identifier, deltas);
                    if (!this.isConnected) {
                        return;
                    }
                    if (!(this.serviceCapabilities && this.serviceCapabilities.textDocumentSync !== browser_main.TextDocumentSyncKind.Incremental)) {
                        return this.setValue(identifier, this.getDocument(identifier.uri).getText());
                    }
                    const textDocumentChange = {
                        textDocument: {
                            uri: identifier.uri,
                            version: identifier.version
                        },
                        contentChanges: deltas
                    };
                    this.connection.sendNotification('textDocument/didChange', textDocumentChange);
                }
                setValue(identifier, value) {
                    super.setValue(identifier, value);
                    if (!this.isConnected) {
                        return;
                    }
                    const textDocumentChange = {
                        textDocument: {
                            uri: identifier.uri,
                            version: identifier.version
                        },
                        contentChanges: [
                            {
                                text: value
                            }
                        ]
                    };
                    this.connection.sendNotification('textDocument/didChange', textDocumentChange);
                }
                async doHover(document1, position) {
                    var _this_serviceCapabilities;
                    if (!this.isInitialized) {
                        return null;
                    }
                    if (!((_this_serviceCapabilities = this.serviceCapabilities) === null || _this_serviceCapabilities === void 0 ? void 0 : _this_serviceCapabilities.hoverProvider)) {
                        return null;
                    }
                    let options = {
                        textDocument: {
                            uri: document1.uri
                        },
                        position: position
                    };
                    return this.connection.sendRequest('textDocument/hover', options);
                }
                async doComplete(document1, position) {
                    var _this_serviceCapabilities;
                    if (!this.isInitialized) {
                        return null;
                    }
                    if (!((_this_serviceCapabilities = this.serviceCapabilities) === null || _this_serviceCapabilities === void 0 ? void 0 : _this_serviceCapabilities.completionProvider)) {
                        return null;
                    }
                    let options = {
                        textDocument: {
                            uri: document1.uri
                        },
                        position: position
                    };
                    return this.connection.sendRequest('textDocument/completion', options);
                }
                async doResolve(item) {
                    var _this_serviceCapabilities_completionProvider, _this_serviceCapabilities;
                    if (!this.isInitialized) return null;
                    if (!((_this_serviceCapabilities = this.serviceCapabilities) === null || _this_serviceCapabilities === void 0 ? void 0 : (_this_serviceCapabilities_completionProvider = _this_serviceCapabilities.completionProvider) === null || _this_serviceCapabilities_completionProvider === void 0 ? void 0 : _this_serviceCapabilities_completionProvider.resolveProvider)) return null;
                    return this.connection.sendRequest('completionItem/resolve', item["item"]);
                }
                async doValidation(document1) {
                    //TODO: textDocument/diagnostic capability
                    return [];
                }
                async format(document1, range, format) {
                    if (!this.isInitialized) {
                        return [];
                    }
                    if (!(this.serviceCapabilities && (this.serviceCapabilities.documentRangeFormattingProvider || this.serviceCapabilities.documentFormattingProvider))) {
                        return [];
                    }
                    if (!this.serviceCapabilities.documentRangeFormattingProvider) {
                        let options = {
                            textDocument: {
                                uri: document1.uri
                            },
                            options: format
                        };
                        return this.connection.sendRequest('textDocument/formatting', options);
                    } else {
                        let options = {
                            textDocument: {
                                uri: document1.uri
                            },
                            options: format,
                            range: range
                        };
                        return this.connection.sendRequest('textDocument/rangeFormatting', options);
                    }
                }
                setGlobalOptions(options) {
                    super.setGlobalOptions(options);
                    if (!this.isConnected) {
                        this.requestsQueue.push(()=>this.setGlobalOptions(options));
                        return;
                    }
                    const configChanges = {
                        settings: options
                    };
                    this.connection.sendNotification('workspace/didChangeConfiguration', configChanges);
                }
                async findDocumentHighlights(document1, position) {
                    var _this_serviceCapabilities;
                    if (!this.isInitialized) return [];
                    if (!((_this_serviceCapabilities = this.serviceCapabilities) === null || _this_serviceCapabilities === void 0 ? void 0 : _this_serviceCapabilities.documentHighlightProvider)) return [];
                    let options = {
                        textDocument: {
                            uri: document1.uri
                        },
                        position: position
                    };
                    return this.connection.sendRequest('textDocument/documentHighlight', options);
                }
                async provideSignatureHelp(document1, position) {
                    var _this_serviceCapabilities;
                    if (!this.isInitialized) return null;
                    if (!((_this_serviceCapabilities = this.serviceCapabilities) === null || _this_serviceCapabilities === void 0 ? void 0 : _this_serviceCapabilities.signatureHelpProvider)) return null;
                    let options = {
                        textDocument: {
                            uri: document1.uri
                        },
                        position: position
                    };
                    return this.connection.sendRequest('textDocument/signatureHelp', options);
                }
                constructor(serverData, ctx){
                    super(serverData.modes);
                    language_client_define_property(this, "$service", void 0);
                    language_client_define_property(this, "isConnected", false);
                    language_client_define_property(this, "isInitialized", false);
                    language_client_define_property(this, "socket", void 0);
                    language_client_define_property(this, "connection", void 0);
                    language_client_define_property(this, "requestsQueue", []);
                    language_client_define_property(this, "clientCapabilities", {
                        textDocument: {
                            hover: {
                                dynamicRegistration: true,
                                contentFormat: [
                                    'markdown',
                                    'plaintext'
                                ]
                            },
                            synchronization: {
                                dynamicRegistration: true,
                                willSave: false,
                                didSave: false,
                                willSaveWaitUntil: false
                            },
                            formatting: {
                                dynamicRegistration: true
                            },
                            completion: {
                                dynamicRegistration: true,
                                completionItem: {
                                    snippetSupport: true,
                                    commitCharactersSupport: false,
                                    documentationFormat: [
                                        'markdown',
                                        'plaintext'
                                    ],
                                    deprecatedSupport: false,
                                    preselectSupport: false
                                },
                                contextSupport: false
                            },
                            signatureHelp: {
                                signatureInformation: {
                                    documentationFormat: [
                                        'markdown',
                                        'plaintext'
                                    ],
                                    activeParameterSupport: true
                                }
                            },
                            documentHighlight: {
                                dynamicRegistration: true
                            }
                        },
                        workspace: {
                            didChangeConfiguration: {
                                dynamicRegistration: true
                            }
                        }
                    });
                    language_client_define_property(this, "ctx", void 0);
                    this.ctx = ctx;
                    switch(serverData.type){
                        case "webworker":
                            if ('worker' in serverData) {
                                this.$connectWorker(serverData.worker, serverData.initializationOptions);
                            } else {
                                throw new Error("No worker provided");
                            }
                            break;
                        case "socket":
                            if ('socket' in serverData) {
                                this.socket = serverData.socket;
                                this.$connectSocket(serverData.initializationOptions);
                            } else {
                                throw new Error("No socketUrl provided");
                            }
                            break;
                        default:
                            throw new Error("Unknown server type: " + serverData.type);
                    }
                }
            }
        })();
        /******/ return __nested_webpack_exports__;
    /******/ })();
});


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNsQixLQUFLOzRCQUNELElBQUksWUFBWTRvRCxZQUFZO2dDQUN4QixJQUFJLENBQUMvQixjQUFjLENBQUMrQixXQUFXOUIsTUFBTSxFQUFFOEIsV0FBV3JDLHFCQUFxQjs0QkFDM0UsT0FBTztnQ0FDSCxNQUFNLElBQUlsMUQsTUFBTTs0QkFDcEI7NEJBQ0E7d0JBQ0osS0FBSzs0QkFDRCxJQUFJLFlBQVl1M0QsWUFBWTtnQ0FDeEIsSUFBSSxDQUFDaC9CLE1BQU0sR0FBR2cvQixXQUFXaC9CLE1BQU07Z0NBQy9CLElBQUksQ0FBQzA4QixjQUFjLENBQUNzQyxXQUFXckMscUJBQXFCOzRCQUN4RCxPQUFPO2dDQUNILE1BQU0sSUFBSWwxRCxNQUFNOzRCQUNwQjs0QkFDQTt3QkFDSjs0QkFDSSxNQUFNLElBQUlBLE1BQU0sMEJBQTBCdTNELFdBQVc1b0QsSUFBSTtvQkFDakU7Z0JBQ0o7WUFDSjtRQUVBO1FBRUEsTUFBTSxHQUFJLE9BQU9vYSwwQkFBbUJBO0lBQ3BDLE1BQU0sR0FBRztBQUVUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNlLWxpbnRlcnMtcm9vdC8uL3BhY2thZ2VzL2FjZS1saW50ZXJzL2J1aWxkL2xhbmd1YWdlLWNsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gZmFjdG9yeSgpO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkodGhpcywgKCkgPT4ge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyAxNjk2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIHByb3ZpZGVkIGRlcGVuZGVuY3kgKi8gdmFyIHByb2Nlc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0MDYpO1xuLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgY29uc29sZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzcxNik7XG4vLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2Fzc2VydC5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8yYTUxYWU0MjRhNTEzZWM5YTZhYTM0NjZiYWEwY2MxZDU1ZGQ0ZjNiXG4vLyBPcmlnaW5hbGx5IGZyb20gbmFyd2hhbC5qcyAoaHR0cDovL25hcndoYWxqcy5vcmcpXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDkgVGhvbWFzIFJvYmluc29uIDwyODBub3J0aC5jb20+XG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgJ1NvZnR3YXJlJyksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuLy8gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuLy8gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NTE1KSxcbiAgICBfcmVxdWlyZSRjb2RlcyA9IF9yZXF1aXJlLmNvZGVzLFxuICAgIEVSUl9BTUJJR1VPVVNfQVJHVU1FTlQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfQU1CSUdVT1VTX0FSR1VNRU5ULFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX0lOVkFMSURfQVJHX1ZBTFVFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1ZBTFVFLFxuICAgIEVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSxcbiAgICBFUlJfTUlTU0lOR19BUkdTID0gX3JlcXVpcmUkY29kZXMuRVJSX01JU1NJTkdfQVJHUztcblxudmFyIEFzc2VydGlvbkVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MDgyKTtcblxudmFyIF9yZXF1aXJlMiA9IF9fd2VicGFja19yZXF1aXJlX18oMzMzNSksXG4gICAgaW5zcGVjdCA9IF9yZXF1aXJlMi5pbnNwZWN0O1xuXG52YXIgX3JlcXVpcmUkdHlwZXMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygzMzM1KS50eXBlcyksXG4gICAgaXNQcm9taXNlID0gX3JlcXVpcmUkdHlwZXMuaXNQcm9taXNlLFxuICAgIGlzUmVnRXhwID0gX3JlcXVpcmUkdHlwZXMuaXNSZWdFeHA7XG5cbnZhciBvYmplY3RBc3NpZ24gPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbiA6IChfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5NTYpLmFzc2lnbik7XG52YXIgb2JqZWN0SXMgPSBPYmplY3QuaXMgPyBPYmplY3QuaXMgOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2NzkpO1xudmFyIGVycm9yQ2FjaGUgPSBuZXcgTWFwKCk7XG52YXIgaXNEZWVwRXF1YWw7XG52YXIgaXNEZWVwU3RyaWN0RXF1YWw7XG52YXIgcGFyc2VFeHByZXNzaW9uQXQ7XG52YXIgZmluZE5vZGVBcm91bmQ7XG52YXIgZGVjb2RlcjtcblxuZnVuY3Rpb24gbGF6eUxvYWRDb21wYXJpc29uKCkge1xuICB2YXIgY29tcGFyaXNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNjc5Nik7XG5cbiAgaXNEZWVwRXF1YWwgPSBjb21wYXJpc29uLmlzRGVlcEVxdWFsO1xuICBpc0RlZXBTdHJpY3RFcXVhbCA9IGNvbXBhcmlzb24uaXNEZWVwU3RyaWN0RXF1YWw7XG59IC8vIEVzY2FwZSBjb250cm9sIGNoYXJhY3RlcnMgYnV0IG5vdCBcXG4gYW5kIFxcdCB0byBrZWVwIHRoZSBsaW5lIGJyZWFrcyBhbmRcbi8vIGluZGVudGF0aW9uIGludGFjdC5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG5cblxudmFyIGVzY2FwZVNlcXVlbmNlc1JlZ0V4cCA9IC9bXFx4MDAtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZdL2c7XG52YXIgbWV0YSA9ICgvKiB1bnVzZWQgcHVyZSBleHByZXNzaW9uIG9yIHN1cGVyICovIG51bGwgJiYgKFtcIlxcXFx1MDAwMFwiLCBcIlxcXFx1MDAwMVwiLCBcIlxcXFx1MDAwMlwiLCBcIlxcXFx1MDAwM1wiLCBcIlxcXFx1MDAwNFwiLCBcIlxcXFx1MDAwNVwiLCBcIlxcXFx1MDAwNlwiLCBcIlxcXFx1MDAwN1wiLCAnXFxcXGInLCAnJywgJycsIFwiXFxcXHUwMDBiXCIsICdcXFxcZicsICcnLCBcIlxcXFx1MDAwZVwiLCBcIlxcXFx1MDAwZlwiLCBcIlxcXFx1MDAxMFwiLCBcIlxcXFx1MDAxMVwiLCBcIlxcXFx1MDAxMlwiLCBcIlxcXFx1MDAxM1wiLCBcIlxcXFx1MDAxNFwiLCBcIlxcXFx1MDAxNVwiLCBcIlxcXFx1MDAxNlwiLCBcIlxcXFx1MDAxN1wiLCBcIlxcXFx1MDAxOFwiLCBcIlxcXFx1MDAxOVwiLCBcIlxcXFx1MDAxYVwiLCBcIlxcXFx1MDAxYlwiLCBcIlxcXFx1MDAxY1wiLCBcIlxcXFx1MDAxZFwiLCBcIlxcXFx1MDAxZVwiLCBcIlxcXFx1MDAxZlwiXSkpO1xuXG52YXIgZXNjYXBlRm4gPSBmdW5jdGlvbiBlc2NhcGVGbihzdHIpIHtcbiAgcmV0dXJuIG1ldGFbc3RyLmNoYXJDb2RlQXQoMCldO1xufTtcblxudmFyIHdhcm5lZCA9IGZhbHNlOyAvLyBUaGUgYXNzZXJ0IG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgdGhhdCB0aHJvd1xuLy8gQXNzZXJ0aW9uRXJyb3IncyB3aGVuIHBhcnRpY3VsYXIgY29uZGl0aW9ucyBhcmUgbm90IG1ldC4gVGhlXG4vLyBhc3NlcnQgbW9kdWxlIG11c3QgY29uZm9ybSB0byB0aGUgZm9sbG93aW5nIGludGVyZmFjZS5cblxudmFyIGFzc2VydCA9IG1vZHVsZS5leHBvcnRzID0gb2s7XG52YXIgTk9fRVhDRVBUSU9OX1NFTlRJTkVMID0ge307IC8vIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuIEFsbCBhc3NlcnRpb24gbWV0aG9kcyBwcm92aWRlXG4vLyBib3RoIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHZhbHVlcyB0byB0aGUgYXNzZXJ0aW9uIGVycm9yIGZvclxuLy8gZGlzcGxheSBwdXJwb3Nlcy5cblxuZnVuY3Rpb24gaW5uZXJGYWlsKG9iaikge1xuICBpZiAob2JqLm1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgb2JqLm1lc3NhZ2U7XG4gIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihvYmopO1xufVxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0Rm4pIHtcbiAgdmFyIGFyZ3NMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW50ZXJuYWxNZXNzYWdlO1xuXG4gIGlmIChhcmdzTGVuID09PSAwKSB7XG4gICAgaW50ZXJuYWxNZXNzYWdlID0gJ0ZhaWxlZCc7XG4gIH0gZWxzZSBpZiAoYXJnc0xlbiA9PT0gMSkge1xuICAgIG1lc3NhZ2UgPSBhY3R1YWw7XG4gICAgYWN0dWFsID0gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIGlmICh3YXJuZWQgPT09IGZhbHNlKSB7XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgdmFyIHdhcm4gPSBwcm9jZXNzLmVtaXRXYXJuaW5nID8gcHJvY2Vzcy5lbWl0V2FybmluZyA6IGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO1xuICAgICAgd2FybignYXNzZXJ0LmZhaWwoKSB3aXRoIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQgaXMgZGVwcmVjYXRlZC4gJyArICdQbGVhc2UgdXNlIGFzc2VydC5zdHJpY3RFcXVhbCgpIGluc3RlYWQgb3Igb25seSBwYXNzIGEgbWVzc2FnZS4nLCAnRGVwcmVjYXRpb25XYXJuaW5nJywgJ0RFUDAwOTQnKTtcbiAgICB9XG5cbiAgICBpZiAoYXJnc0xlbiA9PT0gMikgb3BlcmF0b3IgPSAnIT0nO1xuICB9XG5cbiAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgbWVzc2FnZTtcbiAgdmFyIGVyckFyZ3MgPSB7XG4gICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgIG9wZXJhdG9yOiBvcGVyYXRvciA9PT0gdW5kZWZpbmVkID8gJ2ZhaWwnIDogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZuOiBzdGFja1N0YXJ0Rm4gfHwgZmFpbFxuICB9O1xuXG4gIGlmIChtZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlcnJBcmdzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9XG5cbiAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcihlcnJBcmdzKTtcblxuICBpZiAoaW50ZXJuYWxNZXNzYWdlKSB7XG4gICAgZXJyLm1lc3NhZ2UgPSBpbnRlcm5hbE1lc3NhZ2U7XG4gICAgZXJyLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG5cbiAgdGhyb3cgZXJyO1xufVxuXG5hc3NlcnQuZmFpbCA9IGZhaWw7IC8vIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGludGVybmFsL2Vycm9yLlxuXG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IgPSBBc3NlcnRpb25FcnJvcjtcblxuZnVuY3Rpb24gaW5uZXJPayhmbiwgYXJnTGVuLCB2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgdmFyIGdlbmVyYXRlZE1lc3NhZ2UgPSBmYWxzZTtcblxuICAgIGlmIChhcmdMZW4gPT09IDApIHtcbiAgICAgIGdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICAgICAgbWVzc2FnZSA9ICdObyB2YWx1ZSBhcmd1bWVudCBwYXNzZWQgdG8gYGFzc2VydC5vaygpYCc7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IG1lc3NhZ2U7XG4gICAgfVxuXG4gICAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgICBhY3R1YWw6IHZhbHVlLFxuICAgICAgZXhwZWN0ZWQ6IHRydWUsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICc9PScsXG4gICAgICBzdGFja1N0YXJ0Rm46IGZuXG4gICAgfSk7XG4gICAgZXJyLmdlbmVyYXRlZE1lc3NhZ2UgPSBnZW5lcmF0ZWRNZXNzYWdlO1xuICAgIHRocm93IGVycjtcbiAgfVxufSAvLyBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIXZhbHVlLlxuXG5cbmZ1bmN0aW9uIG9rKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaW5uZXJPay5hcHBseSh2b2lkIDAsIFtvaywgYXJncy5sZW5ndGhdLmNvbmNhdChhcmdzKSk7XG59XG5cbmFzc2VydC5vayA9IG9rOyAvLyBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGggPT0uXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllcyAqL1xuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cblxuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnPT0nLFxuICAgICAgc3RhY2tTdGFydEZuOiBlcXVhbFxuICAgIH0pO1xuICB9XG59OyAvLyBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90XG4vLyBlcXVhbCB3aXRoICE9LlxuXG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblxuXG4gIGlmIChhY3R1YWwgPT0gZXhwZWN0ZWQpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICchPScsXG4gICAgICBzdGFja1N0YXJ0Rm46IG5vdEVxdWFsXG4gICAgfSk7XG4gIH1cbn07IC8vIFRoZSBlcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgYSBkZWVwIGVxdWFsaXR5IHJlbGF0aW9uLlxuXG5cbmFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG5cbiAgaWYgKCFpc0RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ2RlZXBFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IGRlZXBFcXVhbFxuICAgIH0pO1xuICB9XG59OyAvLyBUaGUgbm9uLWVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBmb3IgYW55IGRlZXAgaW5lcXVhbGl0eS5cblxuXG5hc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gbm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xuXG4gIGlmIChpc0RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ25vdERlZXBFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IG5vdERlZXBFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuLyogZXNsaW50LWVuYWJsZSAqL1xuXG5cbmFzc2VydC5kZWVwU3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBkZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG5cbiAgaWYgKCFpc0RlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ2RlZXBTdHJpY3RFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IGRlZXBTdHJpY3RFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuXG5hc3NlcnQubm90RGVlcFN0cmljdEVxdWFsID0gbm90RGVlcFN0cmljdEVxdWFsO1xuXG5mdW5jdGlvbiBub3REZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG5cbiAgaWYgKGlzRGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnbm90RGVlcFN0cmljdEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogbm90RGVlcFN0cmljdEVxdWFsXG4gICAgfSk7XG4gIH1cbn1cblxuYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoIW9iamVjdElzKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnc3RyaWN0RXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBzdHJpY3RFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmIChvYmplY3RJcyhhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ25vdFN0cmljdEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogbm90U3RyaWN0RXF1YWxcbiAgICB9KTtcbiAgfVxufTtcblxudmFyIENvbXBhcmlzb24gPSBmdW5jdGlvbiBDb21wYXJpc29uKG9iaiwga2V5cywgYWN0dWFsKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbXBhcmlzb24pO1xuXG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChhY3R1YWwgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgYWN0dWFsW2tleV0gPT09ICdzdHJpbmcnICYmIGlzUmVnRXhwKG9ialtrZXldKSAmJiBvYmpba2V5XS50ZXN0KGFjdHVhbFtrZXldKSkge1xuICAgICAgICBfdGhpc1trZXldID0gYWN0dWFsW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpc1trZXldID0gb2JqW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGNvbXBhcmVFeGNlcHRpb25LZXkoYWN0dWFsLCBleHBlY3RlZCwga2V5LCBtZXNzYWdlLCBrZXlzLCBmbikge1xuICBpZiAoIShrZXkgaW4gYWN0dWFsKSB8fCAhaXNEZWVwU3RyaWN0RXF1YWwoYWN0dWFsW2tleV0sIGV4cGVjdGVkW2tleV0pKSB7XG4gICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAvLyBDcmVhdGUgcGxhY2Vob2xkZXIgb2JqZWN0cyB0byBjcmVhdGUgYSBuaWNlIG91dHB1dC5cbiAgICAgIHZhciBhID0gbmV3IENvbXBhcmlzb24oYWN0dWFsLCBrZXlzKTtcbiAgICAgIHZhciBiID0gbmV3IENvbXBhcmlzb24oZXhwZWN0ZWQsIGtleXMsIGFjdHVhbCk7XG4gICAgICB2YXIgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICAgICAgYWN0dWFsOiBhLFxuICAgICAgICBleHBlY3RlZDogYixcbiAgICAgICAgb3BlcmF0b3I6ICdkZWVwU3RyaWN0RXF1YWwnLFxuICAgICAgICBzdGFja1N0YXJ0Rm46IGZuXG4gICAgICB9KTtcbiAgICAgIGVyci5hY3R1YWwgPSBhY3R1YWw7XG4gICAgICBlcnIuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgICAgIGVyci5vcGVyYXRvciA9IGZuLm5hbWU7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiBmbi5uYW1lLFxuICAgICAgc3RhY2tTdGFydEZuOiBmblxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQsIG1zZywgZm4pIHtcbiAgaWYgKHR5cGVvZiBleHBlY3RlZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChpc1JlZ0V4cChleHBlY3RlZCkpIHJldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCk7IC8vIGFzc2VydC5kb2VzTm90VGhyb3cgZG9lcyBub3QgYWNjZXB0IG9iamVjdHMuXG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdleHBlY3RlZCcsIFsnRnVuY3Rpb24nLCAnUmVnRXhwJ10sIGV4cGVjdGVkKTtcbiAgICB9IC8vIEhhbmRsZSBwcmltaXRpdmVzIHByb3Blcmx5LlxuXG5cbiAgICBpZiAoX3R5cGVvZihhY3R1YWwpICE9PSAnb2JqZWN0JyB8fCBhY3R1YWwgPT09IG51bGwpIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgICBtZXNzYWdlOiBtc2csXG4gICAgICAgIG9wZXJhdG9yOiAnZGVlcFN0cmljdEVxdWFsJyxcbiAgICAgICAgc3RhY2tTdGFydEZuOiBmblxuICAgICAgfSk7XG4gICAgICBlcnIub3BlcmF0b3IgPSBmbi5uYW1lO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXhwZWN0ZWQpOyAvLyBTcGVjaWFsIGhhbmRsZSBlcnJvcnMgdG8gbWFrZSBzdXJlIHRoZSBuYW1lIGFuZCB0aGUgbWVzc2FnZSBhcmUgY29tcGFyZWRcbiAgICAvLyBhcyB3ZWxsLlxuXG4gICAgaWYgKGV4cGVjdGVkIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGtleXMucHVzaCgnbmFtZScsICdtZXNzYWdlJyk7XG4gICAgfSBlbHNlIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19WQUxVRSgnZXJyb3InLCBleHBlY3RlZCwgJ21heSBub3QgYmUgYW4gZW1wdHkgb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGFjdHVhbFtrZXldID09PSAnc3RyaW5nJyAmJiBpc1JlZ0V4cChleHBlY3RlZFtrZXldKSAmJiBleHBlY3RlZFtrZXldLnRlc3QoYWN0dWFsW2tleV0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29tcGFyZUV4Y2VwdGlvbktleShhY3R1YWwsIGV4cGVjdGVkLCBrZXksIG1zZywga2V5cywgZm4pO1xuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIEd1YXJkIGluc3RhbmNlb2YgYWdhaW5zdCBhcnJvdyBmdW5jdGlvbnMgYXMgdGhleSBkb24ndCBoYXZlIGEgcHJvdG90eXBlLlxuXG5cbiAgaWYgKGV4cGVjdGVkLnByb3RvdHlwZSAhPT0gdW5kZWZpbmVkICYmIGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoRXJyb3IuaXNQcm90b3R5cGVPZihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0dWFsKGZuKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2ZuJywgJ0Z1bmN0aW9uJywgZm4pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBmbigpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cblxuICByZXR1cm4gTk9fRVhDRVBUSU9OX1NFTlRJTkVMO1xufVxuXG5mdW5jdGlvbiBjaGVja0lzUHJvbWlzZShvYmopIHtcbiAgLy8gQWNjZXB0IG5hdGl2ZSBFUzYgcHJvbWlzZXMgYW5kIHByb21pc2VzIHRoYXQgYXJlIGltcGxlbWVudGVkIGluIGEgc2ltaWxhclxuICAvLyB3YXkuIERvIG5vdCBhY2NlcHQgdGhlbmFibGVzIHRoYXQgdXNlIGEgZnVuY3Rpb24gYXMgYG9iamAgYW5kIHRoYXQgaGF2ZSBub1xuICAvLyBgY2F0Y2hgIGhhbmRsZXIuXG4gIC8vIFRPRE86IHRoZW5hYmxlcyBhcmUgY2hlY2tlZCB1cCB1bnRpbCB0aGV5IGhhdmUgdGhlIGNvcnJlY3QgbWV0aG9kcyxcbiAgLy8gYnV0IGFjY29yZGluZyB0byBkb2N1bWVudGF0aW9uLCB0aGUgYHRoZW5gIG1ldGhvZCBzaG91bGQgcmVjZWl2ZVxuICAvLyB0aGUgYGZ1bGZpbGxgIGFuZCBgcmVqZWN0YCBhcmd1bWVudHMgYXMgd2VsbCBvciBpdCBtYXkgYmUgbmV2ZXIgcmVzb2x2ZWQuXG4gIHJldHVybiBpc1Byb21pc2Uob2JqKSB8fCBvYmogIT09IG51bGwgJiYgX3R5cGVvZihvYmopID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqLnRoZW4gPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5jYXRjaCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gd2FpdEZvckFjdHVhbChwcm9taXNlRm4pIHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHRQcm9taXNlO1xuXG4gICAgaWYgKHR5cGVvZiBwcm9taXNlRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFJldHVybiBhIHJlamVjdGVkIHByb21pc2UgaWYgYHByb21pc2VGbmAgdGhyb3dzIHN5bmNocm9ub3VzbHkuXG4gICAgICByZXN1bHRQcm9taXNlID0gcHJvbWlzZUZuKCk7IC8vIEZhaWwgaW4gY2FzZSBubyBwcm9taXNlIGlzIHJldHVybmVkLlxuXG4gICAgICBpZiAoIWNoZWNrSXNQcm9taXNlKHJlc3VsdFByb21pc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUoJ2luc3RhbmNlIG9mIFByb21pc2UnLCAncHJvbWlzZUZuJywgcmVzdWx0UHJvbWlzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaGVja0lzUHJvbWlzZShwcm9taXNlRm4pKSB7XG4gICAgICByZXN1bHRQcm9taXNlID0gcHJvbWlzZUZuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ3Byb21pc2VGbicsIFsnRnVuY3Rpb24nLCAnUHJvbWlzZSddLCBwcm9taXNlRm4pO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZXN1bHRQcm9taXNlO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIE5PX0VYQ0VQVElPTl9TRU5USU5FTDtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIGU7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBleHBlY3RzRXJyb3Ioc3RhY2tTdGFydEZuLCBhY3R1YWwsIGVycm9yLCBtZXNzYWdlKSB7XG4gIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZXJyb3InLCBbJ09iamVjdCcsICdFcnJvcicsICdGdW5jdGlvbicsICdSZWdFeHAnXSwgZXJyb3IpO1xuICAgIH1cblxuICAgIGlmIChfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGFjdHVhbC5tZXNzYWdlID09PSBlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRVJSX0FNQklHVU9VU19BUkdVTUVOVCgnZXJyb3IvbWVzc2FnZScsIFwiVGhlIGVycm9yIG1lc3NhZ2UgXFxcIlwiLmNvbmNhdChhY3R1YWwubWVzc2FnZSwgXCJcXFwiIGlzIGlkZW50aWNhbCB0byB0aGUgbWVzc2FnZS5cIikpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYWN0dWFsID09PSBlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVSUl9BTUJJR1VPVVNfQVJHVU1FTlQoJ2Vycm9yL21lc3NhZ2UnLCBcIlRoZSBlcnJvciBcXFwiXCIuY29uY2F0KGFjdHVhbCwgXCJcXFwiIGlzIGlkZW50aWNhbCB0byB0aGUgbWVzc2FnZS5cIikpO1xuICAgIH1cblxuICAgIG1lc3NhZ2UgPSBlcnJvcjtcbiAgICBlcnJvciA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmIChlcnJvciAhPSBudWxsICYmIF90eXBlb2YoZXJyb3IpICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgZXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2Vycm9yJywgWydPYmplY3QnLCAnRXJyb3InLCAnRnVuY3Rpb24nLCAnUmVnRXhwJ10sIGVycm9yKTtcbiAgfVxuXG4gIGlmIChhY3R1YWwgPT09IE5PX0VYQ0VQVElPTl9TRU5USU5FTCkge1xuICAgIHZhciBkZXRhaWxzID0gJyc7XG5cbiAgICBpZiAoZXJyb3IgJiYgZXJyb3IubmFtZSkge1xuICAgICAgZGV0YWlscyArPSBcIiAoXCIuY29uY2F0KGVycm9yLm5hbWUsIFwiKVwiKTtcbiAgICB9XG5cbiAgICBkZXRhaWxzICs9IG1lc3NhZ2UgPyBcIjogXCIuY29uY2F0KG1lc3NhZ2UpIDogJy4nO1xuICAgIHZhciBmblR5cGUgPSBzdGFja1N0YXJ0Rm4ubmFtZSA9PT0gJ3JlamVjdHMnID8gJ3JlamVjdGlvbicgOiAnZXhjZXB0aW9uJztcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiB1bmRlZmluZWQsXG4gICAgICBleHBlY3RlZDogZXJyb3IsXG4gICAgICBvcGVyYXRvcjogc3RhY2tTdGFydEZuLm5hbWUsXG4gICAgICBtZXNzYWdlOiBcIk1pc3NpbmcgZXhwZWN0ZWQgXCIuY29uY2F0KGZuVHlwZSkuY29uY2F0KGRldGFpbHMpLFxuICAgICAgc3RhY2tTdGFydEZuOiBzdGFja1N0YXJ0Rm5cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChlcnJvciAmJiAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBlcnJvciwgbWVzc2FnZSwgc3RhY2tTdGFydEZuKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHBlY3RzTm9FcnJvcihzdGFja1N0YXJ0Rm4sIGFjdHVhbCwgZXJyb3IsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gTk9fRVhDRVBUSU9OX1NFTlRJTkVMKSByZXR1cm47XG5cbiAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlID0gZXJyb3I7XG4gICAgZXJyb3IgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoIWVycm9yIHx8IGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXJyb3IpKSB7XG4gICAgdmFyIGRldGFpbHMgPSBtZXNzYWdlID8gXCI6IFwiLmNvbmNhdChtZXNzYWdlKSA6ICcuJztcbiAgICB2YXIgZm5UeXBlID0gc3RhY2tTdGFydEZuLm5hbWUgPT09ICdkb2VzTm90UmVqZWN0JyA/ICdyZWplY3Rpb24nIDogJ2V4Y2VwdGlvbic7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGVycm9yLFxuICAgICAgb3BlcmF0b3I6IHN0YWNrU3RhcnRGbi5uYW1lLFxuICAgICAgbWVzc2FnZTogXCJHb3QgdW53YW50ZWQgXCIuY29uY2F0KGZuVHlwZSkuY29uY2F0KGRldGFpbHMsIFwiXFxuXCIpICsgXCJBY3R1YWwgbWVzc2FnZTogXFxcIlwiLmNvbmNhdChhY3R1YWwgJiYgYWN0dWFsLm1lc3NhZ2UsIFwiXFxcIlwiKSxcbiAgICAgIHN0YWNrU3RhcnRGbjogc3RhY2tTdGFydEZuXG4gICAgfSk7XG4gIH1cblxuICB0aHJvdyBhY3R1YWw7XG59XG5cbmFzc2VydC50aHJvd3MgPSBmdW5jdGlvbiB0aHJvd3MocHJvbWlzZUZuKSB7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuXG4gIGV4cGVjdHNFcnJvci5hcHBseSh2b2lkIDAsIFt0aHJvd3MsIGdldEFjdHVhbChwcm9taXNlRm4pXS5jb25jYXQoYXJncykpO1xufTtcblxuYXNzZXJ0LnJlamVjdHMgPSBmdW5jdGlvbiByZWplY3RzKHByb21pc2VGbikge1xuICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMgPiAxID8gX2xlbjMgLSAxIDogMCksIF9rZXkzID0gMTsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgIGFyZ3NbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gIH1cblxuICByZXR1cm4gd2FpdEZvckFjdHVhbChwcm9taXNlRm4pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiBleHBlY3RzRXJyb3IuYXBwbHkodm9pZCAwLCBbcmVqZWN0cywgcmVzdWx0XS5jb25jYXQoYXJncykpO1xuICB9KTtcbn07XG5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbiBkb2VzTm90VGhyb3coZm4pIHtcbiAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40ID4gMSA/IF9sZW40IC0gMSA6IDApLCBfa2V5NCA9IDE7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICBhcmdzW19rZXk0IC0gMV0gPSBhcmd1bWVudHNbX2tleTRdO1xuICB9XG5cbiAgZXhwZWN0c05vRXJyb3IuYXBwbHkodm9pZCAwLCBbZG9lc05vdFRocm93LCBnZXRBY3R1YWwoZm4pXS5jb25jYXQoYXJncykpO1xufTtcblxuYXNzZXJ0LmRvZXNOb3RSZWplY3QgPSBmdW5jdGlvbiBkb2VzTm90UmVqZWN0KGZuKSB7XG4gIGZvciAodmFyIF9sZW41ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNSA+IDEgPyBfbGVuNSAtIDEgOiAwKSwgX2tleTUgPSAxOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgYXJnc1tfa2V5NSAtIDFdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgfVxuXG4gIHJldHVybiB3YWl0Rm9yQWN0dWFsKGZuKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXR1cm4gZXhwZWN0c05vRXJyb3IuYXBwbHkodm9pZCAwLCBbZG9lc05vdFJlamVjdCwgcmVzdWx0XS5jb25jYXQoYXJncykpO1xuICB9KTtcbn07XG5cbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24gaWZFcnJvcihlcnIpIHtcbiAgaWYgKGVyciAhPT0gbnVsbCAmJiBlcnIgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBtZXNzYWdlID0gJ2lmRXJyb3IgZ290IHVud2FudGVkIGV4Y2VwdGlvbjogJztcblxuICAgIGlmIChfdHlwZW9mKGVycikgPT09ICdvYmplY3QnICYmIHR5cGVvZiBlcnIubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChlcnIubWVzc2FnZS5sZW5ndGggPT09IDAgJiYgZXJyLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gZXJyLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlICs9IGVyci5tZXNzYWdlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlICs9IGluc3BlY3QoZXJyKTtcbiAgICB9XG5cbiAgICB2YXIgbmV3RXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICAgIGFjdHVhbDogZXJyLFxuICAgICAgZXhwZWN0ZWQ6IG51bGwsXG4gICAgICBvcGVyYXRvcjogJ2lmRXJyb3InLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIHN0YWNrU3RhcnRGbjogaWZFcnJvclxuICAgIH0pOyAvLyBNYWtlIHN1cmUgd2UgYWN0dWFsbHkgaGF2ZSBhIHN0YWNrIHRyYWNlIVxuXG4gICAgdmFyIG9yaWdTdGFjayA9IGVyci5zdGFjaztcblxuICAgIGlmICh0eXBlb2Ygb3JpZ1N0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyB3aWxsIHJlbW92ZSBhbnkgZHVwbGljYXRlZCBmcmFtZXMgZnJvbSB0aGUgZXJyb3IgZnJhbWVzIHRha2VuXG4gICAgICAvLyBmcm9tIHdpdGhpbiBgaWZFcnJvcmAgYW5kIGFkZCB0aGUgb3JpZ2luYWwgZXJyb3IgZnJhbWVzIHRvIHRoZSBuZXdseVxuICAgICAgLy8gY3JlYXRlZCBvbmVzLlxuICAgICAgdmFyIHRtcDIgPSBvcmlnU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdG1wMi5zaGlmdCgpOyAvLyBGaWx0ZXIgYWxsIGZyYW1lcyBleGlzdGluZyBpbiBlcnIuc3RhY2suXG5cbiAgICAgIHZhciB0bXAxID0gbmV3RXJyLnN0YWNrLnNwbGl0KCdcXG4nKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0bXAyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgdGhlIGZyYW1lLlxuICAgICAgICB2YXIgcG9zID0gdG1wMS5pbmRleE9mKHRtcDJbaV0pO1xuXG4gICAgICAgIGlmIChwb3MgIT09IC0xKSB7XG4gICAgICAgICAgLy8gT25seSBrZWVwIG5ldyBmcmFtZXMuXG4gICAgICAgICAgdG1wMSA9IHRtcDEuc2xpY2UoMCwgcG9zKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXdFcnIuc3RhY2sgPSBcIlwiLmNvbmNhdCh0bXAxLmpvaW4oJ1xcbicpLCBcIlxcblwiKS5jb25jYXQodG1wMi5qb2luKCdcXG4nKSk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3RXJyO1xuICB9XG59OyAvLyBFeHBvc2UgYSBzdHJpY3Qgb25seSB2YXJpYW50IG9mIGFzc2VydFxuXG5cbmZ1bmN0aW9uIHN0cmljdCgpIHtcbiAgZm9yICh2YXIgX2xlbjYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42KSwgX2tleTYgPSAwOyBfa2V5NiA8IF9sZW42OyBfa2V5NisrKSB7XG4gICAgYXJnc1tfa2V5Nl0gPSBhcmd1bWVudHNbX2tleTZdO1xuICB9XG5cbiAgaW5uZXJPay5hcHBseSh2b2lkIDAsIFtzdHJpY3QsIGFyZ3MubGVuZ3RoXS5jb25jYXQoYXJncykpO1xufVxuXG5hc3NlcnQuc3RyaWN0ID0gb2JqZWN0QXNzaWduKHN0cmljdCwgYXNzZXJ0LCB7XG4gIGVxdWFsOiBhc3NlcnQuc3RyaWN0RXF1YWwsXG4gIGRlZXBFcXVhbDogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCxcbiAgbm90RXF1YWw6IGFzc2VydC5ub3RTdHJpY3RFcXVhbCxcbiAgbm90RGVlcEVxdWFsOiBhc3NlcnQubm90RGVlcFN0cmljdEVxdWFsXG59KTtcbmFzc2VydC5zdHJpY3Quc3RyaWN0ID0gYXNzZXJ0LnN0cmljdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIDQwODI6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgcHJvY2VzcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDQwNik7XG4vLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL2Fzc2VydC9hc3NlcnRpb25fZXJyb3IuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMDgxNzg0MGY3NzUwMzIxNjlkZGQ3MGM4NWFjMDU5ZjE4ZmZjYzgxY1xuXG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJykgeyBvd25LZXlzID0gb3duS2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgc3ltKS5lbnVtZXJhYmxlOyB9KSk7IH0gb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7IF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhX2lzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7IGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHsgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7IF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpOyB9IGZ1bmN0aW9uIFdyYXBwZXIoKSB7IHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7IH0gV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogV3JhcHBlciwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7IH07IHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTsgfVxuXG5mdW5jdGlvbiBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IGlmIChpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkgeyBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7IH0gZWxzZSB7IF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgdmFyIGEgPSBbbnVsbF07IGEucHVzaC5hcHBseShhLCBhcmdzKTsgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpOyB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTsgaWYgKENsYXNzKSBfc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7IHJldHVybiBpbnN0YW5jZTsgfTsgfSByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7IHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzMzUpLFxuICAgIGluc3BlY3QgPSBfcmVxdWlyZS5pbnNwZWN0O1xuXG52YXIgX3JlcXVpcmUyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NTE1KSxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlMi5jb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRTsgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2VuZHNXaXRoXG5cblxuZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzZWFyY2gsIHRoaXNfbGVuKSB7XG4gIGlmICh0aGlzX2xlbiA9PT0gdW5kZWZpbmVkIHx8IHRoaXNfbGVuID4gc3RyLmxlbmd0aCkge1xuICAgIHRoaXNfbGVuID0gc3RyLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBzdHIuc3Vic3RyaW5nKHRoaXNfbGVuIC0gc2VhcmNoLmxlbmd0aCwgdGhpc19sZW4pID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9yZXBlYXRcblxuXG5mdW5jdGlvbiByZXBlYXQoc3RyLCBjb3VudCkge1xuICBjb3VudCA9IE1hdGguZmxvb3IoY291bnQpO1xuICBpZiAoc3RyLmxlbmd0aCA9PSAwIHx8IGNvdW50ID09IDApIHJldHVybiAnJztcbiAgdmFyIG1heENvdW50ID0gc3RyLmxlbmd0aCAqIGNvdW50O1xuICBjb3VudCA9IE1hdGguZmxvb3IoTWF0aC5sb2coY291bnQpIC8gTWF0aC5sb2coMikpO1xuXG4gIHdoaWxlIChjb3VudCkge1xuICAgIHN0ciArPSBzdHI7XG4gICAgY291bnQtLTtcbiAgfVxuXG4gIHN0ciArPSBzdHIuc3Vic3RyaW5nKDAsIG1heENvdW50IC0gc3RyLmxlbmd0aCk7XG4gIHJldHVybiBzdHI7XG59XG5cbnZhciBibHVlID0gJyc7XG52YXIgZ3JlZW4gPSAnJztcbnZhciByZWQgPSAnJztcbnZhciB3aGl0ZSA9ICcnO1xudmFyIGtSZWFkYWJsZU9wZXJhdG9yID0ge1xuICBkZWVwU3RyaWN0RXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgc3RyaWN0bHkgZGVlcC1lcXVhbDonLFxuICBzdHJpY3RFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBzdHJpY3RseSBlcXVhbDonLFxuICBzdHJpY3RFcXVhbE9iamVjdDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgdG8gYmUgcmVmZXJlbmNlLWVxdWFsIHRvIFwiZXhwZWN0ZWRcIjonLFxuICBkZWVwRXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgbG9vc2VseSBkZWVwLWVxdWFsOicsXG4gIGVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIGxvb3NlbHkgZXF1YWw6JyxcbiAgbm90RGVlcFN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiBub3QgdG8gYmUgc3RyaWN0bHkgZGVlcC1lcXVhbCB0bzonLFxuICBub3RTdHJpY3RFcXVhbDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgdG8gYmUgc3RyaWN0bHkgdW5lcXVhbCB0bzonLFxuICBub3RTdHJpY3RFcXVhbE9iamVjdDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgbm90IHRvIGJlIHJlZmVyZW5jZS1lcXVhbCB0byBcImV4cGVjdGVkXCI6JyxcbiAgbm90RGVlcEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiBub3QgdG8gYmUgbG9vc2VseSBkZWVwLWVxdWFsIHRvOicsXG4gIG5vdEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSBsb29zZWx5IHVuZXF1YWwgdG86JyxcbiAgbm90SWRlbnRpY2FsOiAnVmFsdWVzIGlkZW50aWNhbCBidXQgbm90IHJlZmVyZW5jZS1lcXVhbDonXG59OyAvLyBDb21wYXJpbmcgc2hvcnQgcHJpbWl0aXZlcyBzaG91bGQganVzdCBzaG93ID09PSAvICE9PSBpbnN0ZWFkIG9mIHVzaW5nIHRoZVxuLy8gZGlmZi5cblxudmFyIGtNYXhTaG9ydExlbmd0aCA9IDEwO1xuXG5mdW5jdGlvbiBjb3B5RXJyb3Ioc291cmNlKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIHRhcmdldCA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHNvdXJjZSkpO1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCAnbWVzc2FnZScsIHtcbiAgICB2YWx1ZTogc291cmNlLm1lc3NhZ2VcbiAgfSk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIGluc3BlY3RWYWx1ZSh2YWwpIHtcbiAgLy8gVGhlIHV0aWwuaW5zcGVjdCBkZWZhdWx0IHZhbHVlcyBjb3VsZCBiZSBjaGFuZ2VkLiBUaGlzIG1ha2VzIHN1cmUgdGhlXG4gIC8vIGVycm9yIG1lc3NhZ2VzIGNvbnRhaW4gdGhlIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbiBuZXZlcnRoZWxlc3MuXG4gIHJldHVybiBpbnNwZWN0KHZhbCwge1xuICAgIGNvbXBhY3Q6IGZhbHNlLFxuICAgIGN1c3RvbUluc3BlY3Q6IGZhbHNlLFxuICAgIGRlcHRoOiAxMDAwLFxuICAgIG1heEFycmF5TGVuZ3RoOiBJbmZpbml0eSxcbiAgICAvLyBBc3NlcnQgY29tcGFyZXMgb25seSBlbnVtZXJhYmxlIHByb3BlcnRpZXMgKHdpdGggYSBmZXcgZXhjZXB0aW9ucykuXG4gICAgc2hvd0hpZGRlbjogZmFsc2UsXG4gICAgLy8gSGF2aW5nIGEgbG9uZyBsaW5lIGFzIGVycm9yIGlzIGJldHRlciB0aGFuIHdyYXBwaW5nIHRoZSBsaW5lIGZvclxuICAgIC8vIGNvbXBhcmlzb24gZm9yIG5vdy5cbiAgICAvLyBUT0RPKEJyaWRnZUFSKTogYGJyZWFrTGVuZ3RoYCBzaG91bGQgYmUgbGltaXRlZCBhcyBzb29uIGFzIHNvb24gYXMgd2VcbiAgICAvLyBoYXZlIG1ldGEgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGluc3BlY3RlZCBwcm9wZXJ0aWVzIChpLmUuLCBrbm93IHdoZXJlXG4gICAgLy8gaW4gd2hhdCBsaW5lIHRoZSBwcm9wZXJ0eSBzdGFydHMgYW5kIGVuZHMpLlxuICAgIGJyZWFrTGVuZ3RoOiBJbmZpbml0eSxcbiAgICAvLyBBc3NlcnQgZG9lcyBub3QgZGV0ZWN0IHByb3hpZXMgY3VycmVudGx5LlxuICAgIHNob3dQcm94eTogZmFsc2UsXG4gICAgc29ydGVkOiB0cnVlLFxuICAgIC8vIEluc3BlY3QgZ2V0dGVycyBhcyB3ZSBhbHNvIGNoZWNrIHRoZW0gd2hlbiBjb21wYXJpbmcgZW50cmllcy5cbiAgICBnZXR0ZXJzOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFcnJEaWZmKGFjdHVhbCwgZXhwZWN0ZWQsIG9wZXJhdG9yKSB7XG4gIHZhciBvdGhlciA9ICcnO1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBsYXN0UG9zID0gMDtcbiAgdmFyIGVuZCA9ICcnO1xuICB2YXIgc2tpcHBlZCA9IGZhbHNlO1xuICB2YXIgYWN0dWFsSW5zcGVjdGVkID0gaW5zcGVjdFZhbHVlKGFjdHVhbCk7XG4gIHZhciBhY3R1YWxMaW5lcyA9IGFjdHVhbEluc3BlY3RlZC5zcGxpdCgnXFxuJyk7XG4gIHZhciBleHBlY3RlZExpbmVzID0gaW5zcGVjdFZhbHVlKGV4cGVjdGVkKS5zcGxpdCgnXFxuJyk7XG4gIHZhciBpID0gMDtcbiAgdmFyIGluZGljYXRvciA9ICcnOyAvLyBJbiBjYXNlIGJvdGggdmFsdWVzIGFyZSBvYmplY3RzIGV4cGxpY2l0bHkgbWFyayB0aGVtIGFzIG5vdCByZWZlcmVuY2UgZXF1YWxcbiAgLy8gZm9yIHRoZSBgc3RyaWN0RXF1YWxgIG9wZXJhdG9yLlxuXG4gIGlmIChvcGVyYXRvciA9PT0gJ3N0cmljdEVxdWFsJyAmJiBfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmIF90eXBlb2YoZXhwZWN0ZWQpID09PSAnb2JqZWN0JyAmJiBhY3R1YWwgIT09IG51bGwgJiYgZXhwZWN0ZWQgIT09IG51bGwpIHtcbiAgICBvcGVyYXRvciA9ICdzdHJpY3RFcXVhbE9iamVjdCc7XG4gIH0gLy8gSWYgXCJhY3R1YWxcIiBhbmQgXCJleHBlY3RlZFwiIGZpdCBvbiBhIHNpbmdsZSBsaW5lIGFuZCB0aGV5IGFyZSBub3Qgc3RyaWN0bHlcbiAgLy8gZXF1YWwsIGNoZWNrIGZ1cnRoZXIgc3BlY2lhbCBoYW5kbGluZy5cblxuXG4gIGlmIChhY3R1YWxMaW5lcy5sZW5ndGggPT09IDEgJiYgZXhwZWN0ZWRMaW5lcy5sZW5ndGggPT09IDEgJiYgYWN0dWFsTGluZXNbMF0gIT09IGV4cGVjdGVkTGluZXNbMF0pIHtcbiAgICB2YXIgaW5wdXRMZW5ndGggPSBhY3R1YWxMaW5lc1swXS5sZW5ndGggKyBleHBlY3RlZExpbmVzWzBdLmxlbmd0aDsgLy8gSWYgdGhlIGNoYXJhY3RlciBsZW5ndGggb2YgXCJhY3R1YWxcIiBhbmQgXCJleHBlY3RlZFwiIHRvZ2V0aGVyIGlzIGxlc3MgdGhhblxuICAgIC8vIGtNYXhTaG9ydExlbmd0aCBhbmQgaWYgbmVpdGhlciBpcyBhbiBvYmplY3QgYW5kIGF0IGxlYXN0IG9uZSBvZiB0aGVtIGlzXG4gICAgLy8gbm90IGB6ZXJvYCwgdXNlIHRoZSBzdHJpY3QgZXF1YWwgY29tcGFyaXNvbiB0byB2aXN1YWxpemUgdGhlIG91dHB1dC5cblxuICAgIGlmIChpbnB1dExlbmd0aCA8PSBrTWF4U2hvcnRMZW5ndGgpIHtcbiAgICAgIGlmICgoX3R5cGVvZihhY3R1YWwpICE9PSAnb2JqZWN0JyB8fCBhY3R1YWwgPT09IG51bGwpICYmIChfdHlwZW9mKGV4cGVjdGVkKSAhPT0gJ29iamVjdCcgfHwgZXhwZWN0ZWQgPT09IG51bGwpICYmIChhY3R1YWwgIT09IDAgfHwgZXhwZWN0ZWQgIT09IDApKSB7XG4gICAgICAgIC8vIC0wID09PSArMFxuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoa1JlYWRhYmxlT3BlcmF0b3Jbb3BlcmF0b3JdLCBcIlxcblxcblwiKSArIFwiXCIuY29uY2F0KGFjdHVhbExpbmVzWzBdLCBcIiAhPT0gXCIpLmNvbmNhdChleHBlY3RlZExpbmVzWzBdLCBcIlxcblwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wZXJhdG9yICE9PSAnc3RyaWN0RXF1YWxPYmplY3QnKSB7XG4gICAgICAvLyBJZiB0aGUgc3RkZXJyIGlzIGEgdHR5IGFuZCB0aGUgaW5wdXQgbGVuZ3RoIGlzIGxvd2VyIHRoYW4gdGhlIGN1cnJlbnRcbiAgICAgIC8vIGNvbHVtbnMgcGVyIGxpbmUsIGFkZCBhIG1pc21hdGNoIGluZGljYXRvciBiZWxvdyB0aGUgb3V0cHV0LiBJZiBpdCBpc1xuICAgICAgLy8gbm90IGEgdHR5LCB1c2UgYSBkZWZhdWx0IHZhbHVlIG9mIDgwIGNoYXJhY3RlcnMuXG4gICAgICB2YXIgbWF4TGVuZ3RoID0gcHJvY2Vzcy5zdGRlcnIgJiYgcHJvY2Vzcy5zdGRlcnIuaXNUVFkgPyBwcm9jZXNzLnN0ZGVyci5jb2x1bW5zIDogODA7XG5cbiAgICAgIGlmIChpbnB1dExlbmd0aCA8IG1heExlbmd0aCkge1xuICAgICAgICB3aGlsZSAoYWN0dWFsTGluZXNbMF1baV0gPT09IGV4cGVjdGVkTGluZXNbMF1baV0pIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH0gLy8gSWdub3JlIHRoZSBmaXJzdCBjaGFyYWN0ZXJzLlxuXG5cbiAgICAgICAgaWYgKGkgPiAyKSB7XG4gICAgICAgICAgLy8gQWRkIHBvc2l0aW9uIGluZGljYXRvciBmb3IgdGhlIGZpcnN0IG1pc21hdGNoIGluIGNhc2UgaXQgaXMgYVxuICAgICAgICAgIC8vIHNpbmdsZSBsaW5lIGFuZCB0aGUgaW5wdXQgbGVuZ3RoIGlzIGxlc3MgdGhhbiB0aGUgY29sdW1uIGxlbmd0aC5cbiAgICAgICAgICBpbmRpY2F0b3IgPSBcIlxcbiAgXCIuY29uY2F0KHJlcGVhdCgnICcsIGkpLCBcIl5cIik7XG4gICAgICAgICAgaSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gUmVtb3ZlIGFsbCBlbmRpbmcgbGluZXMgdGhhdCBtYXRjaCAodGhpcyBvcHRpbWl6ZXMgdGhlIG91dHB1dCBmb3JcbiAgLy8gcmVhZGFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIG51bWJlciBvZiB0b3RhbCBjaGFuZ2VkIGxpbmVzKS5cblxuXG4gIHZhciBhID0gYWN0dWFsTGluZXNbYWN0dWFsTGluZXMubGVuZ3RoIC0gMV07XG4gIHZhciBiID0gZXhwZWN0ZWRMaW5lc1tleHBlY3RlZExpbmVzLmxlbmd0aCAtIDFdO1xuXG4gIHdoaWxlIChhID09PSBiKSB7XG4gICAgaWYgKGkrKyA8IDIpIHtcbiAgICAgIGVuZCA9IFwiXFxuICBcIi5jb25jYXQoYSkuY29uY2F0KGVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG90aGVyID0gYTtcbiAgICB9XG5cbiAgICBhY3R1YWxMaW5lcy5wb3AoKTtcbiAgICBleHBlY3RlZExpbmVzLnBvcCgpO1xuICAgIGlmIChhY3R1YWxMaW5lcy5sZW5ndGggPT09IDAgfHwgZXhwZWN0ZWRMaW5lcy5sZW5ndGggPT09IDApIGJyZWFrO1xuICAgIGEgPSBhY3R1YWxMaW5lc1thY3R1YWxMaW5lcy5sZW5ndGggLSAxXTtcbiAgICBiID0gZXhwZWN0ZWRMaW5lc1tleHBlY3RlZExpbmVzLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgdmFyIG1heExpbmVzID0gTWF0aC5tYXgoYWN0dWFsTGluZXMubGVuZ3RoLCBleHBlY3RlZExpbmVzLmxlbmd0aCk7IC8vIFN0cmljdCBlcXVhbCB3aXRoIGlkZW50aWNhbCBvYmplY3RzIHRoYXQgYXJlIG5vdCBpZGVudGljYWwgYnkgcmVmZXJlbmNlLlxuICAvLyBFLmcuLCBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHsgYTogU3ltYm9sKCkgfSwgeyBhOiBTeW1ib2woKSB9KVxuXG4gIGlmIChtYXhMaW5lcyA9PT0gMCkge1xuICAgIC8vIFdlIGhhdmUgdG8gZ2V0IHRoZSByZXN1bHQgYWdhaW4uIFRoZSBsaW5lcyB3ZXJlIGFsbCByZW1vdmVkIGJlZm9yZS5cbiAgICB2YXIgX2FjdHVhbExpbmVzID0gYWN0dWFsSW5zcGVjdGVkLnNwbGl0KCdcXG4nKTsgLy8gT25seSByZW1vdmUgbGluZXMgaW4gY2FzZSBpdCBtYWtlcyBzZW5zZSB0byBjb2xsYXBzZSB0aG9zZS5cbiAgICAvLyBUT0RPOiBBY2NlcHQgZW52IHRvIGFsd2F5cyBzaG93IHRoZSBmdWxsIGVycm9yLlxuXG5cbiAgICBpZiAoX2FjdHVhbExpbmVzLmxlbmd0aCA+IDMwKSB7XG4gICAgICBfYWN0dWFsTGluZXNbMjZdID0gXCJcIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcblxuICAgICAgd2hpbGUgKF9hY3R1YWxMaW5lcy5sZW5ndGggPiAyNykge1xuICAgICAgICBfYWN0dWFsTGluZXMucG9wKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGtSZWFkYWJsZU9wZXJhdG9yLm5vdElkZW50aWNhbCwgXCJcXG5cXG5cIikuY29uY2F0KF9hY3R1YWxMaW5lcy5qb2luKCdcXG4nKSwgXCJcXG5cIik7XG4gIH1cblxuICBpZiAoaSA+IDMpIHtcbiAgICBlbmQgPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpLmNvbmNhdChlbmQpO1xuICAgIHNraXBwZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKG90aGVyICE9PSAnJykge1xuICAgIGVuZCA9IFwiXFxuICBcIi5jb25jYXQob3RoZXIpLmNvbmNhdChlbmQpO1xuICAgIG90aGVyID0gJyc7XG4gIH1cblxuICB2YXIgcHJpbnRlZExpbmVzID0gMDtcbiAgdmFyIG1zZyA9IGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXSArIFwiXFxuXCIuY29uY2F0KGdyZWVuLCBcIisgYWN0dWFsXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChyZWQsIFwiLSBleHBlY3RlZFwiKS5jb25jYXQod2hpdGUpO1xuICB2YXIgc2tpcHBlZE1zZyA9IFwiIFwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUsIFwiIExpbmVzIHNraXBwZWRcIik7XG5cbiAgZm9yIChpID0gMDsgaSA8IG1heExpbmVzOyBpKyspIHtcbiAgICAvLyBPbmx5IGV4dHJhIGV4cGVjdGVkIGxpbmVzIGV4aXN0XG4gICAgdmFyIGN1ciA9IGkgLSBsYXN0UG9zO1xuXG4gICAgaWYgKGFjdHVhbExpbmVzLmxlbmd0aCA8IGkgKyAxKSB7XG4gICAgICAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBtb3JlIHRoYW4gb25lIGxpbmUgYWJvdmUgYW5kIHRoZVxuICAgICAgLy8gY3VycmVudCBsaW5lIGlzIGF0IGxlYXN0IGxpbmUgdGhyZWUsIGFkZCBzb21lIG9mIHRoZSBmb3JtZXIgbGluZXMgYW5kXG4gICAgICAvLyBhbHNvIGFkZCBkb3RzIHRvIGluZGljYXRlIHNraXBwZWQgZW50cmllcy5cbiAgICAgIGlmIChjdXIgPiAxICYmIGkgPiAyKSB7XG4gICAgICAgIGlmIChjdXIgPiA0KSB7XG4gICAgICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG4gICAgICAgICAgc2tpcHBlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VyID4gMykge1xuICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGV4cGVjdGVkTGluZXNbaSAtIDJdKTtcbiAgICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGV4cGVjdGVkTGluZXNbaSAtIDFdKTtcbiAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICB9IC8vIE1hcmsgdGhlIGN1cnJlbnQgbGluZSBhcyB0aGUgbGFzdCBkaXZlcmdpbmcgb25lLlxuXG5cbiAgICAgIGxhc3RQb3MgPSBpOyAvLyBBZGQgdGhlIGV4cGVjdGVkIGxpbmUgdG8gdGhlIGNhY2hlLlxuXG4gICAgICBvdGhlciArPSBcIlxcblwiLmNvbmNhdChyZWQsIFwiLVwiKS5jb25jYXQod2hpdGUsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRMaW5lc1tpXSk7XG4gICAgICBwcmludGVkTGluZXMrKzsgLy8gT25seSBleHRyYSBhY3R1YWwgbGluZXMgZXhpc3RcbiAgICB9IGVsc2UgaWYgKGV4cGVjdGVkTGluZXMubGVuZ3RoIDwgaSArIDEpIHtcbiAgICAgIC8vIElmIHRoZSBsYXN0IGRpdmVyZ2luZyBsaW5lIGlzIG1vcmUgdGhhbiBvbmUgbGluZSBhYm92ZSBhbmQgdGhlXG4gICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYXQgbGVhc3QgbGluZSB0aHJlZSwgYWRkIHNvbWUgb2YgdGhlIGZvcm1lciBsaW5lcyBhbmRcbiAgICAgIC8vIGFsc28gYWRkIGRvdHMgdG8gaW5kaWNhdGUgc2tpcHBlZCBlbnRyaWVzLlxuICAgICAgaWYgKGN1ciA+IDEgJiYgaSA+IDIpIHtcbiAgICAgICAgaWYgKGN1ciA+IDQpIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG5cIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcbiAgICAgICAgICBza2lwcGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXIgPiAzKSB7XG4gICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDJdKTtcbiAgICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmVzW2kgLSAxXSk7XG4gICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgfSAvLyBNYXJrIHRoZSBjdXJyZW50IGxpbmUgYXMgdGhlIGxhc3QgZGl2ZXJnaW5nIG9uZS5cblxuXG4gICAgICBsYXN0UG9zID0gaTsgLy8gQWRkIHRoZSBhY3R1YWwgbGluZSB0byB0aGUgcmVzdWx0LlxuXG4gICAgICByZXMgKz0gXCJcXG5cIi5jb25jYXQoZ3JlZW4sIFwiK1wiKS5jb25jYXQod2hpdGUsIFwiIFwiKS5jb25jYXQoYWN0dWFsTGluZXNbaV0pO1xuICAgICAgcHJpbnRlZExpbmVzKys7IC8vIExpbmVzIGRpdmVyZ2VcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGV4cGVjdGVkTGluZSA9IGV4cGVjdGVkTGluZXNbaV07XG4gICAgICB2YXIgYWN0dWFsTGluZSA9IGFjdHVhbExpbmVzW2ldOyAvLyBJZiB0aGUgbGluZXMgZGl2ZXJnZSwgc3BlY2lmaWNhbGx5IGNoZWNrIGZvciBsaW5lcyB0aGF0IG9ubHkgZGl2ZXJnZSBieVxuICAgICAgLy8gYSB0cmFpbGluZyBjb21tYS4gSW4gdGhhdCBjYXNlIGl0IGlzIGFjdHVhbGx5IGlkZW50aWNhbCBhbmQgd2Ugc2hvdWxkXG4gICAgICAvLyBtYXJrIGl0IGFzIHN1Y2guXG5cbiAgICAgIHZhciBkaXZlcmdpbmdMaW5lcyA9IGFjdHVhbExpbmUgIT09IGV4cGVjdGVkTGluZSAmJiAoIWVuZHNXaXRoKGFjdHVhbExpbmUsICcsJykgfHwgYWN0dWFsTGluZS5zbGljZSgwLCAtMSkgIT09IGV4cGVjdGVkTGluZSk7IC8vIElmIHRoZSBleHBlY3RlZCBsaW5lIGhhcyBhIHRyYWlsaW5nIGNvbW1hIGJ1dCBpcyBvdGhlcndpc2UgaWRlbnRpY2FsLFxuICAgICAgLy8gYWRkIGEgY29tbWEgYXQgdGhlIGVuZCBvZiB0aGUgYWN0dWFsIGxpbmUuIE90aGVyd2lzZSB0aGUgb3V0cHV0IGNvdWxkXG4gICAgICAvLyBsb29rIHdlaXJkIGFzIGluOlxuICAgICAgLy9cbiAgICAgIC8vICAgW1xuICAgICAgLy8gICAgIDEgICAgICAgICAvLyBObyBjb21tYSBhdCB0aGUgZW5kIVxuICAgICAgLy8gKyAgIDJcbiAgICAgIC8vICAgXVxuICAgICAgLy9cblxuICAgICAgaWYgKGRpdmVyZ2luZ0xpbmVzICYmIGVuZHNXaXRoKGV4cGVjdGVkTGluZSwgJywnKSAmJiBleHBlY3RlZExpbmUuc2xpY2UoMCwgLTEpID09PSBhY3R1YWxMaW5lKSB7XG4gICAgICAgIGRpdmVyZ2luZ0xpbmVzID0gZmFsc2U7XG4gICAgICAgIGFjdHVhbExpbmUgKz0gJywnO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGl2ZXJnaW5nTGluZXMpIHtcbiAgICAgICAgLy8gSWYgdGhlIGxhc3QgZGl2ZXJnaW5nIGxpbmUgaXMgbW9yZSB0aGFuIG9uZSBsaW5lIGFib3ZlIGFuZCB0aGVcbiAgICAgICAgLy8gY3VycmVudCBsaW5lIGlzIGF0IGxlYXN0IGxpbmUgdGhyZWUsIGFkZCBzb21lIG9mIHRoZSBmb3JtZXIgbGluZXMgYW5kXG4gICAgICAgIC8vIGFsc28gYWRkIGRvdHMgdG8gaW5kaWNhdGUgc2tpcHBlZCBlbnRyaWVzLlxuICAgICAgICBpZiAoY3VyID4gMSAmJiBpID4gMikge1xuICAgICAgICAgIGlmIChjdXIgPiA0KSB7XG4gICAgICAgICAgICByZXMgKz0gXCJcXG5cIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcbiAgICAgICAgICAgIHNraXBwZWQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3VyID4gMykge1xuICAgICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDJdKTtcbiAgICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmVzW2kgLSAxXSk7XG4gICAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICAgIH0gLy8gTWFyayB0aGUgY3VycmVudCBsaW5lIGFzIHRoZSBsYXN0IGRpdmVyZ2luZyBvbmUuXG5cblxuICAgICAgICBsYXN0UG9zID0gaTsgLy8gQWRkIHRoZSBhY3R1YWwgbGluZSB0byB0aGUgcmVzdWx0IGFuZCBjYWNoZSB0aGUgZXhwZWN0ZWQgZGl2ZXJnaW5nXG4gICAgICAgIC8vIGxpbmUgc28gY29uc2VjdXRpdmUgZGl2ZXJnaW5nIGxpbmVzIHNob3cgdXAgYXMgKysrLS0tIGFuZCBub3QgKy0rLSstLlxuXG4gICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChncmVlbiwgXCIrXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChhY3R1YWxMaW5lKTtcbiAgICAgICAgb3RoZXIgKz0gXCJcXG5cIi5jb25jYXQocmVkLCBcIi1cIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkTGluZSk7XG4gICAgICAgIHByaW50ZWRMaW5lcyArPSAyOyAvLyBMaW5lcyBhcmUgaWRlbnRpY2FsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBZGQgYWxsIGNhY2hlZCBpbmZvcm1hdGlvbiB0byB0aGUgcmVzdWx0IGJlZm9yZSBhZGRpbmcgb3RoZXIgdGhpbmdzXG4gICAgICAgIC8vIGFuZCByZXNldCB0aGUgY2FjaGUuXG4gICAgICAgIHJlcyArPSBvdGhlcjtcbiAgICAgICAgb3RoZXIgPSAnJzsgLy8gSWYgdGhlIGxhc3QgZGl2ZXJnaW5nIGxpbmUgaXMgZXhhY3RseSBvbmUgbGluZSBhYm92ZSBvciBpZiBpdCBpcyB0aGVcbiAgICAgICAgLy8gdmVyeSBmaXJzdCBsaW5lLCBhZGQgdGhlIGxpbmUgdG8gdGhlIHJlc3VsdC5cblxuICAgICAgICBpZiAoY3VyID09PSAxIHx8IGkgPT09IDApIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lKTtcbiAgICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gSW5zcGVjdGVkIG9iamVjdCB0byBiaWcgKFNob3cgfjIwIHJvd3MgbWF4KVxuXG5cbiAgICBpZiAocHJpbnRlZExpbmVzID4gMjAgJiYgaSA8IG1heExpbmVzIC0gMikge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KG1zZykuY29uY2F0KHNraXBwZWRNc2csIFwiXFxuXCIpLmNvbmNhdChyZXMsIFwiXFxuXCIpLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpLmNvbmNhdChvdGhlciwgXCJcXG5cIikgKyBcIlwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBcIlwiLmNvbmNhdChtc2cpLmNvbmNhdChza2lwcGVkID8gc2tpcHBlZE1zZyA6ICcnLCBcIlxcblwiKS5jb25jYXQocmVzKS5jb25jYXQob3RoZXIpLmNvbmNhdChlbmQpLmNvbmNhdChpbmRpY2F0b3IpO1xufVxuXG52YXIgQXNzZXJ0aW9uRXJyb3IgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHMoQXNzZXJ0aW9uRXJyb3IsIF9FcnJvcik7XG5cbiAgZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBc3NlcnRpb25FcnJvcik7XG5cbiAgICBpZiAoX3R5cGVvZihvcHRpb25zKSAhPT0gJ29iamVjdCcgfHwgb3B0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdvcHRpb25zJywgJ09iamVjdCcsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciBtZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlLFxuICAgICAgICBvcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3IsXG4gICAgICAgIHN0YWNrU3RhcnRGbiA9IG9wdGlvbnMuc3RhY2tTdGFydEZuO1xuICAgIHZhciBhY3R1YWwgPSBvcHRpb25zLmFjdHVhbCxcbiAgICAgICAgZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xuICAgIHZhciBsaW1pdCA9IEVycm9yLnN0YWNrVHJhY2VMaW1pdDtcbiAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSAwO1xuXG4gICAgaWYgKG1lc3NhZ2UgIT0gbnVsbCkge1xuICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgU3RyaW5nKG1lc3NhZ2UpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLnN0ZGVyciAmJiBwcm9jZXNzLnN0ZGVyci5pc1RUWSkge1xuICAgICAgICAvLyBSZXNldCBvbiBlYWNoIGNhbGwgdG8gbWFrZSBzdXJlIHdlIGhhbmRsZSBkeW5hbWljYWxseSBzZXQgZW52aXJvbm1lbnRcbiAgICAgICAgLy8gdmFyaWFibGVzIGNvcnJlY3QuXG4gICAgICAgIGlmIChwcm9jZXNzLnN0ZGVyciAmJiBwcm9jZXNzLnN0ZGVyci5nZXRDb2xvckRlcHRoICYmIHByb2Nlc3Muc3RkZXJyLmdldENvbG9yRGVwdGgoKSAhPT0gMSkge1xuICAgICAgICAgIGJsdWUgPSBcIlxceDFCWzM0bVwiO1xuICAgICAgICAgIGdyZWVuID0gXCJcXHgxQlszMm1cIjtcbiAgICAgICAgICB3aGl0ZSA9IFwiXFx4MUJbMzltXCI7XG4gICAgICAgICAgcmVkID0gXCJcXHgxQlszMW1cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBibHVlID0gJyc7XG4gICAgICAgICAgZ3JlZW4gPSAnJztcbiAgICAgICAgICB3aGl0ZSA9ICcnO1xuICAgICAgICAgIHJlZCA9ICcnO1xuICAgICAgICB9XG4gICAgICB9IC8vIFByZXZlbnQgdGhlIGVycm9yIHN0YWNrIGZyb20gYmVpbmcgdmlzaWJsZSBieSBkdXBsaWNhdGluZyB0aGUgZXJyb3JcbiAgICAgIC8vIGluIGEgdmVyeSBjbG9zZSB3YXkgdG8gdGhlIG9yaWdpbmFsIGluIGNhc2UgYm90aCBzaWRlcyBhcmUgYWN0dWFsbHlcbiAgICAgIC8vIGluc3RhbmNlcyBvZiBFcnJvci5cblxuXG4gICAgICBpZiAoX3R5cGVvZihhY3R1YWwpID09PSAnb2JqZWN0JyAmJiBhY3R1YWwgIT09IG51bGwgJiYgX3R5cGVvZihleHBlY3RlZCkgPT09ICdvYmplY3QnICYmIGV4cGVjdGVkICE9PSBudWxsICYmICdzdGFjaycgaW4gYWN0dWFsICYmIGFjdHVhbCBpbnN0YW5jZW9mIEVycm9yICYmICdzdGFjaycgaW4gZXhwZWN0ZWQgJiYgZXhwZWN0ZWQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBhY3R1YWwgPSBjb3B5RXJyb3IoYWN0dWFsKTtcbiAgICAgICAgZXhwZWN0ZWQgPSBjb3B5RXJyb3IoZXhwZWN0ZWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3BlcmF0b3IgPT09ICdkZWVwU3RyaWN0RXF1YWwnIHx8IG9wZXJhdG9yID09PSAnc3RyaWN0RXF1YWwnKSB7XG4gICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIGNyZWF0ZUVyckRpZmYoYWN0dWFsLCBleHBlY3RlZCwgb3BlcmF0b3IpKSk7XG4gICAgICB9IGVsc2UgaWYgKG9wZXJhdG9yID09PSAnbm90RGVlcFN0cmljdEVxdWFsJyB8fCBvcGVyYXRvciA9PT0gJ25vdFN0cmljdEVxdWFsJykge1xuICAgICAgICAvLyBJbiBjYXNlIHRoZSBvYmplY3RzIGFyZSBlcXVhbCBidXQgdGhlIG9wZXJhdG9yIHJlcXVpcmVzIHVuZXF1YWwsIHNob3dcbiAgICAgICAgLy8gdGhlIGZpcnN0IG9iamVjdCBhbmQgc2F5IEEgZXF1YWxzIEJcbiAgICAgICAgdmFyIGJhc2UgPSBrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl07XG4gICAgICAgIHZhciByZXMgPSBpbnNwZWN0VmFsdWUoYWN0dWFsKS5zcGxpdCgnXFxuJyk7IC8vIEluIGNhc2UgXCJhY3R1YWxcIiBpcyBhbiBvYmplY3QsIGl0IHNob3VsZCBub3QgYmUgcmVmZXJlbmNlIGVxdWFsLlxuXG4gICAgICAgIGlmIChvcGVyYXRvciA9PT0gJ25vdFN0cmljdEVxdWFsJyAmJiBfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCkge1xuICAgICAgICAgIGJhc2UgPSBrUmVhZGFibGVPcGVyYXRvci5ub3RTdHJpY3RFcXVhbE9iamVjdDtcbiAgICAgICAgfSAvLyBPbmx5IHJlbW92ZSBsaW5lcyBpbiBjYXNlIGl0IG1ha2VzIHNlbnNlIHRvIGNvbGxhcHNlIHRob3NlLlxuICAgICAgICAvLyBUT0RPOiBBY2NlcHQgZW52IHRvIGFsd2F5cyBzaG93IHRoZSBmdWxsIGVycm9yLlxuXG5cbiAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAzMCkge1xuICAgICAgICAgIHJlc1syNl0gPSBcIlwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuXG4gICAgICAgICAgd2hpbGUgKHJlcy5sZW5ndGggPiAyNykge1xuICAgICAgICAgICAgcmVzLnBvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBPbmx5IHByaW50IGEgc2luZ2xlIGlucHV0LlxuXG5cbiAgICAgICAgaWYgKHJlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBc3NlcnRpb25FcnJvcikuY2FsbCh0aGlzLCBcIlwiLmNvbmNhdChiYXNlLCBcIiBcIikuY29uY2F0KHJlc1swXSkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBc3NlcnRpb25FcnJvcikuY2FsbCh0aGlzLCBcIlwiLmNvbmNhdChiYXNlLCBcIlxcblxcblwiKS5jb25jYXQocmVzLmpvaW4oJ1xcbicpLCBcIlxcblwiKSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3JlcyA9IGluc3BlY3RWYWx1ZShhY3R1YWwpO1xuXG4gICAgICAgIHZhciBvdGhlciA9ICcnO1xuICAgICAgICB2YXIga25vd25PcGVyYXRvcnMgPSBrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl07XG5cbiAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnbm90RGVlcEVxdWFsJyB8fCBvcGVyYXRvciA9PT0gJ25vdEVxdWFsJykge1xuICAgICAgICAgIF9yZXMgPSBcIlwiLmNvbmNhdChrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl0sIFwiXFxuXFxuXCIpLmNvbmNhdChfcmVzKTtcblxuICAgICAgICAgIGlmIChfcmVzLmxlbmd0aCA+IDEwMjQpIHtcbiAgICAgICAgICAgIF9yZXMgPSBcIlwiLmNvbmNhdChfcmVzLnNsaWNlKDAsIDEwMjEpLCBcIi4uLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3RoZXIgPSBcIlwiLmNvbmNhdChpbnNwZWN0VmFsdWUoZXhwZWN0ZWQpKTtcblxuICAgICAgICAgIGlmIChfcmVzLmxlbmd0aCA+IDUxMikge1xuICAgICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KF9yZXMuc2xpY2UoMCwgNTA5KSwgXCIuLi5cIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG90aGVyLmxlbmd0aCA+IDUxMikge1xuICAgICAgICAgICAgb3RoZXIgPSBcIlwiLmNvbmNhdChvdGhlci5zbGljZSgwLCA1MDkpLCBcIi4uLlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3BlcmF0b3IgPT09ICdkZWVwRXF1YWwnIHx8IG9wZXJhdG9yID09PSAnZXF1YWwnKSB7XG4gICAgICAgICAgICBfcmVzID0gXCJcIi5jb25jYXQoa25vd25PcGVyYXRvcnMsIFwiXFxuXFxuXCIpLmNvbmNhdChfcmVzLCBcIlxcblxcbnNob3VsZCBlcXVhbFxcblxcblwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3RoZXIgPSBcIiBcIi5jb25jYXQob3BlcmF0b3IsIFwiIFwiKS5jb25jYXQob3RoZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIFwiXCIuY29uY2F0KF9yZXMpLmNvbmNhdChvdGhlcikpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBsaW1pdDtcbiAgICBfdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gIW1lc3NhZ2U7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnQXNzZXJ0aW9uRXJyb3IgW0VSUl9BU1NFUlRJT05dJyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBfdGhpcy5jb2RlID0gJ0VSUl9BU1NFUlRJT04nO1xuICAgIF90aGlzLmFjdHVhbCA9IGFjdHVhbDtcbiAgICBfdGhpcy5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICAgIF90aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG5cbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIHN0YWNrU3RhcnRGbik7XG4gICAgfSAvLyBDcmVhdGUgZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIGVycm9yIGNvZGUgaW4gdGhlIG5hbWUuXG5cblxuICAgIF90aGlzLnN0YWNrOyAvLyBSZXNldCB0aGUgbmFtZS5cblxuICAgIF90aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQXNzZXJ0aW9uRXJyb3IsIFt7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMubmFtZSwgXCIgW1wiKS5jb25jYXQodGhpcy5jb2RlLCBcIl06IFwiKS5jb25jYXQodGhpcy5tZXNzYWdlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IGluc3BlY3QuY3VzdG9tLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShyZWN1cnNlVGltZXMsIGN0eCkge1xuICAgICAgLy8gVGhpcyBsaW1pdHMgdGhlIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgIHByb3BlcnR5IGRlZmF1bHQgaW5zcGVjdGlvbiB0b1xuICAgICAgLy8gdGhlIG1pbmltdW0gZGVwdGguIE90aGVyd2lzZSB0aG9zZSB2YWx1ZXMgd291bGQgYmUgdG9vIHZlcmJvc2UgY29tcGFyZWRcbiAgICAgIC8vIHRvIHRoZSBhY3R1YWwgZXJyb3IgbWVzc2FnZSB3aGljaCBjb250YWlucyBhIGNvbWJpbmVkIHZpZXcgb2YgdGhlc2UgdHdvXG4gICAgICAvLyBpbnB1dCB2YWx1ZXMuXG4gICAgICByZXR1cm4gaW5zcGVjdCh0aGlzLCBfb2JqZWN0U3ByZWFkKHt9LCBjdHgsIHtcbiAgICAgICAgY3VzdG9tSW5zcGVjdDogZmFsc2UsXG4gICAgICAgIGRlcHRoOiAwXG4gICAgICB9KSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFzc2VydGlvbkVycm9yO1xufShfd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXNzZXJ0aW9uRXJyb3I7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NTE1OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvaW50ZXJuYWwvZXJyb3JzLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzNiMDQ0OTYyYzQ4ZmUzMTM5MDU4NzdhOTZiNWQwODk0YTU0MDRmNmZcblxuLyogZXNsaW50IG5vZGUtY29yZS9kb2N1bWVudGVkLWVycm9yczogXCJlcnJvclwiICovXG5cbi8qIGVzbGludCBub2RlLWNvcmUvYWxwaGFiZXRpemUtZXJyb3JzOiBcImVycm9yXCIgKi9cblxuLyogZXNsaW50IG5vZGUtY29yZS9wcmVmZXItdXRpbC1mb3JtYXQtZXJyb3JzOiBcImVycm9yXCIgKi9cbiAvLyBUaGUgd2hvbGUgcG9pbnQgYmVoaW5kIHRoaXMgaW50ZXJuYWwgbW9kdWxlIGlzIHRvIGFsbG93IE5vZGUuanMgdG8gbm9cbi8vIGxvbmdlciBiZSBmb3JjZWQgdG8gdHJlYXQgZXZlcnkgZXJyb3IgbWVzc2FnZSBjaGFuZ2UgYXMgYSBzZW12ZXItbWFqb3Jcbi8vIGNoYW5nZS4gVGhlIE5vZGVFcnJvciBjbGFzc2VzIGhlcmUgYWxsIGV4cG9zZSBhIGBjb2RlYCBwcm9wZXJ0eSB3aG9zZVxuLy8gdmFsdWUgc3RhdGljYWxseSBhbmQgcGVybWFuZW50bHkgaWRlbnRpZmllcyB0aGUgZXJyb3IuIFdoaWxlIHRoZSBlcnJvclxuLy8gbWVzc2FnZSBtYXkgY2hhbmdlLCB0aGUgY29kZSBzaG91bGQgbm90LlxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbnZhciBjb2RlcyA9IHt9OyAvLyBMYXp5IGxvYWRlZFxuXG52YXIgYXNzZXJ0O1xudmFyIHV0aWw7XG5cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yVHlwZShjb2RlLCBtZXNzYWdlLCBCYXNlKSB7XG4gIGlmICghQmFzZSkge1xuICAgIEJhc2UgPSBFcnJvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9XG4gIH1cblxuICB2YXIgTm9kZUVycm9yID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0Jhc2UpIHtcbiAgICBfaW5oZXJpdHMoTm9kZUVycm9yLCBfQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBOb2RlRXJyb3IoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZUVycm9yKTtcblxuICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoTm9kZUVycm9yKS5jYWxsKHRoaXMsIGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykpKTtcbiAgICAgIF90aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBOb2RlRXJyb3I7XG4gIH0oQmFzZSk7XG5cbiAgY29kZXNbY29kZV0gPSBOb2RlRXJyb3I7XG59IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3YxMC44LjAvbGliL2ludGVybmFsL2Vycm9ycy5qc1xuXG5cbmZ1bmN0aW9uIG9uZU9mKGV4cGVjdGVkLCB0aGluZykge1xuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3RlZCkpIHtcbiAgICB2YXIgbGVuID0gZXhwZWN0ZWQubGVuZ3RoO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGkpO1xuICAgIH0pO1xuXG4gICAgaWYgKGxlbiA+IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWQuc2xpY2UoMCwgbGVuIC0gMSkuam9pbignLCAnKSwgXCIsIG9yIFwiKSArIGV4cGVjdGVkW2xlbiAtIDFdO1xuICAgIH0gZWxzZSBpZiAobGVuID09PSAyKSB7XG4gICAgICByZXR1cm4gXCJvbmUgb2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkWzBdLCBcIiBvciBcIikuY29uY2F0KGV4cGVjdGVkWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwib2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkWzBdKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwib2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KFN0cmluZyhleHBlY3RlZCkpO1xuICB9XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9zdGFydHNXaXRoXG5cblxuZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHNlYXJjaCwgcG9zKSB7XG4gIHJldHVybiBzdHIuc3Vic3RyKCFwb3MgfHwgcG9zIDwgMCA/IDAgOiArcG9zLCBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZW5kc1dpdGhcblxuXG5mdW5jdGlvbiBlbmRzV2l0aChzdHIsIHNlYXJjaCwgdGhpc19sZW4pIHtcbiAgaWYgKHRoaXNfbGVuID09PSB1bmRlZmluZWQgfHwgdGhpc19sZW4gPiBzdHIubGVuZ3RoKSB7XG4gICAgdGhpc19sZW4gPSBzdHIubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcodGhpc19sZW4gLSBzZWFyY2gubGVuZ3RoLCB0aGlzX2xlbikgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2luY2x1ZGVzXG5cblxuZnVuY3Rpb24gaW5jbHVkZXMoc3RyLCBzZWFyY2gsIHN0YXJ0KSB7XG4gIGlmICh0eXBlb2Ygc3RhcnQgIT09ICdudW1iZXInKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG5cbiAgaWYgKHN0YXJ0ICsgc2VhcmNoLmxlbmd0aCA+IHN0ci5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKHNlYXJjaCwgc3RhcnQpICE9PSAtMTtcbiAgfVxufVxuXG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9BTUJJR1VPVVNfQVJHVU1FTlQnLCAnVGhlIFwiJXNcIiBhcmd1bWVudCBpcyBhbWJpZ3VvdXMuICVzJywgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLCBmdW5jdGlvbiAobmFtZSwgZXhwZWN0ZWQsIGFjdHVhbCkge1xuICBpZiAoYXNzZXJ0ID09PSB1bmRlZmluZWQpIGFzc2VydCA9IF9fd2VicGFja19yZXF1aXJlX18oMTY5Nik7XG4gIGFzc2VydCh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycsIFwiJ25hbWUnIG11c3QgYmUgYSBzdHJpbmdcIik7IC8vIGRldGVybWluZXI6ICdtdXN0IGJlJyBvciAnbXVzdCBub3QgYmUnXG5cbiAgdmFyIGRldGVybWluZXI7XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycgJiYgc3RhcnRzV2l0aChleHBlY3RlZCwgJ25vdCAnKSkge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBub3QgYmUnO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQucmVwbGFjZSgvXm5vdCAvLCAnJyk7XG4gIH0gZWxzZSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IGJlJztcbiAgfVxuXG4gIHZhciBtc2c7XG5cbiAgaWYgKGVuZHNXaXRoKG5hbWUsICcgYXJndW1lbnQnKSkge1xuICAgIC8vIEZvciBjYXNlcyBsaWtlICdmaXJzdCBhcmd1bWVudCdcbiAgICBtc2cgPSBcIlRoZSBcIi5jb25jYXQobmFtZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdHlwZSA9IGluY2x1ZGVzKG5hbWUsICcuJykgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50JztcbiAgICBtc2cgPSBcIlRoZSBcXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIiBcIikuY29uY2F0KHR5cGUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH0gLy8gVE9ETyhCcmlkZ2VBUik6IEltcHJvdmUgdGhlIG91dHB1dCBieSBzaG93aW5nIGBudWxsYCBhbmQgc2ltaWxhci5cblxuXG4gIG1zZyArPSBcIi4gUmVjZWl2ZWQgdHlwZSBcIi5jb25jYXQoX3R5cGVvZihhY3R1YWwpKTtcbiAgcmV0dXJuIG1zZztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX0FSR19WQUxVRScsIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICB2YXIgcmVhc29uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnaXMgaW52YWxpZCc7XG4gIGlmICh1dGlsID09PSB1bmRlZmluZWQpIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzMzUpO1xuICB2YXIgaW5zcGVjdGVkID0gdXRpbC5pbnNwZWN0KHZhbHVlKTtcblxuICBpZiAoaW5zcGVjdGVkLmxlbmd0aCA+IDEyOCkge1xuICAgIGluc3BlY3RlZCA9IFwiXCIuY29uY2F0KGluc3BlY3RlZC5zbGljZSgwLCAxMjgpLCBcIi4uLlwiKTtcbiAgfVxuXG4gIHJldHVybiBcIlRoZSBhcmd1bWVudCAnXCIuY29uY2F0KG5hbWUsIFwiJyBcIikuY29uY2F0KHJlYXNvbiwgXCIuIFJlY2VpdmVkIFwiKS5jb25jYXQoaW5zcGVjdGVkKTtcbn0sIFR5cGVFcnJvciwgUmFuZ2VFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX1JFVFVSTl9WQUxVRScsIGZ1bmN0aW9uIChpbnB1dCwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIHR5cGU7XG5cbiAgaWYgKHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICB0eXBlID0gXCJpbnN0YW5jZSBvZiBcIi5jb25jYXQodmFsdWUuY29uc3RydWN0b3IubmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgdHlwZSA9IFwidHlwZSBcIi5jb25jYXQoX3R5cGVvZih2YWx1ZSkpO1xuICB9XG5cbiAgcmV0dXJuIFwiRXhwZWN0ZWQgXCIuY29uY2F0KGlucHV0LCBcIiB0byBiZSByZXR1cm5lZCBmcm9tIHRoZSBcXFwiXCIpLmNvbmNhdChuYW1lLCBcIlxcXCJcIikgKyBcIiBmdW5jdGlvbiBidXQgZ290IFwiLmNvbmNhdCh0eXBlLCBcIi5cIik7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfTUlTU0lOR19BUkdTJywgZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKGFzc2VydCA9PT0gdW5kZWZpbmVkKSBhc3NlcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2OTYpO1xuICBhc3NlcnQoYXJncy5sZW5ndGggPiAwLCAnQXQgbGVhc3Qgb25lIGFyZyBuZWVkcyB0byBiZSBzcGVjaWZpZWQnKTtcbiAgdmFyIG1zZyA9ICdUaGUgJztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICBhcmdzID0gYXJncy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gXCJcXFwiXCIuY29uY2F0KGEsIFwiXFxcIlwiKTtcbiAgfSk7XG5cbiAgc3dpdGNoIChsZW4pIHtcbiAgICBjYXNlIDE6XG4gICAgICBtc2cgKz0gXCJcIi5jb25jYXQoYXJnc1swXSwgXCIgYXJndW1lbnRcIik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMjpcbiAgICAgIG1zZyArPSBcIlwiLmNvbmNhdChhcmdzWzBdLCBcIiBhbmQgXCIpLmNvbmNhdChhcmdzWzFdLCBcIiBhcmd1bWVudHNcIik7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBtc2cgKz0gYXJncy5zbGljZSgwLCBsZW4gLSAxKS5qb2luKCcsICcpO1xuICAgICAgbXNnICs9IFwiLCBhbmQgXCIuY29uY2F0KGFyZ3NbbGVuIC0gMV0sIFwiIGFyZ3VtZW50c1wiKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIFwiXCIuY29uY2F0KG1zZywgXCIgbXVzdCBiZSBzcGVjaWZpZWRcIik7XG59LCBUeXBlRXJyb3IpO1xubW9kdWxlLmV4cG9ydHMuY29kZXMgPSBjb2RlcztcblxuLyoqKi8gfSksXG5cbi8qKiovIDY3OTY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC91dGlsL2NvbXBhcmlzb25zLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzExMmNjN2MyNzU1MTI1NGFhMmIxNzA5OGZiNzc0ODY3ZjA1ZWQwZDlcblxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxudmFyIHJlZ2V4RmxhZ3NTdXBwb3J0ZWQgPSAvYS9nLmZsYWdzICE9PSB1bmRlZmluZWQ7XG5cbnZhciBhcnJheUZyb21TZXQgPSBmdW5jdGlvbiBhcnJheUZyb21TZXQoc2V0KSB7XG4gIHZhciBhcnJheSA9IFtdO1xuICBzZXQuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gYXJyYXkucHVzaCh2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gYXJyYXk7XG59O1xuXG52YXIgYXJyYXlGcm9tTWFwID0gZnVuY3Rpb24gYXJyYXlGcm9tTWFwKG1hcCkge1xuICB2YXIgYXJyYXkgPSBbXTtcbiAgbWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICByZXR1cm4gYXJyYXkucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9KTtcbiAgcmV0dXJuIGFycmF5O1xufTtcblxudmFyIG9iamVjdElzID0gT2JqZWN0LmlzID8gT2JqZWN0LmlzIDogX193ZWJwYWNrX3JlcXVpcmVfXyg0Njc5KTtcbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFtdO1xufTtcbnZhciBudW1iZXJJc05hTiA9IE51bWJlci5pc05hTiA/IE51bWJlci5pc05hTiA6IF9fd2VicGFja19yZXF1aXJlX18oNDc4Mik7XG5cbmZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgcmV0dXJuIGYuY2FsbC5iaW5kKGYpO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUpO1xudmFyIG9iamVjdFRvU3RyaW5nID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG5cbnZhciBfcmVxdWlyZSR0eXBlcyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDMzMzUpLnR5cGVzKSxcbiAgICBpc0FueUFycmF5QnVmZmVyID0gX3JlcXVpcmUkdHlwZXMuaXNBbnlBcnJheUJ1ZmZlcixcbiAgICBpc0FycmF5QnVmZmVyVmlldyA9IF9yZXF1aXJlJHR5cGVzLmlzQXJyYXlCdWZmZXJWaWV3LFxuICAgIGlzRGF0ZSA9IF9yZXF1aXJlJHR5cGVzLmlzRGF0ZSxcbiAgICBpc01hcCA9IF9yZXF1aXJlJHR5cGVzLmlzTWFwLFxuICAgIGlzUmVnRXhwID0gX3JlcXVpcmUkdHlwZXMuaXNSZWdFeHAsXG4gICAgaXNTZXQgPSBfcmVxdWlyZSR0eXBlcy5pc1NldCxcbiAgICBpc05hdGl2ZUVycm9yID0gX3JlcXVpcmUkdHlwZXMuaXNOYXRpdmVFcnJvcixcbiAgICBpc0JveGVkUHJpbWl0aXZlID0gX3JlcXVpcmUkdHlwZXMuaXNCb3hlZFByaW1pdGl2ZSxcbiAgICBpc051bWJlck9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzTnVtYmVyT2JqZWN0LFxuICAgIGlzU3RyaW5nT2JqZWN0ID0gX3JlcXVpcmUkdHlwZXMuaXNTdHJpbmdPYmplY3QsXG4gICAgaXNCb29sZWFuT2JqZWN0ID0gX3JlcXVpcmUkdHlwZXMuaXNCb29sZWFuT2JqZWN0LFxuICAgIGlzQmlnSW50T2JqZWN0ID0gX3JlcXVpcmUkdHlwZXMuaXNCaWdJbnRPYmplY3QsXG4gICAgaXNTeW1ib2xPYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc1N5bWJvbE9iamVjdCxcbiAgICBpc0Zsb2F0MzJBcnJheSA9IF9yZXF1aXJlJHR5cGVzLmlzRmxvYXQzMkFycmF5LFxuICAgIGlzRmxvYXQ2NEFycmF5ID0gX3JlcXVpcmUkdHlwZXMuaXNGbG9hdDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGlzTm9uSW5kZXgoa2V5KSB7XG4gIGlmIChrZXkubGVuZ3RoID09PSAwIHx8IGtleS5sZW5ndGggPiAxMCkgcmV0dXJuIHRydWU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29kZSA9IGtleS5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlIDwgNDggfHwgY29kZSA+IDU3KSByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBUaGUgbWF4aW11bSBzaXplIGZvciBhbiBhcnJheSBpcyAyICoqIDMyIC0xLlxuXG5cbiAgcmV0dXJuIGtleS5sZW5ndGggPT09IDEwICYmIGtleSA+PSBNYXRoLnBvdygyLCAzMik7XG59XG5cbmZ1bmN0aW9uIGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLmZpbHRlcihpc05vbkluZGV4KS5jb25jYXQob2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbHVlKS5maWx0ZXIoT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5iaW5kKHZhbHVlKSkpO1xufSAvLyBUYWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2Jsb2IvNjgwZTllNWU0ODhmMjJhYWMyNzU5OWE1N2RjODQ0YTYzMTU5MjhkZC9pbmRleC5qc1xuLy8gb3JpZ2luYWwgbm90aWNlOlxuXG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cblxuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgeCA9IGEubGVuZ3RoO1xuICB2YXIgeSA9IGIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldO1xuICAgICAgeSA9IGJbaV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBpZiAoeSA8IHgpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG52YXIgT05MWV9FTlVNRVJBQkxFID0gdW5kZWZpbmVkO1xudmFyIGtTdHJpY3QgPSB0cnVlO1xudmFyIGtMb29zZSA9IGZhbHNlO1xudmFyIGtOb0l0ZXJhdG9yID0gMDtcbnZhciBrSXNBcnJheSA9IDE7XG52YXIga0lzU2V0ID0gMjtcbnZhciBrSXNNYXAgPSAzOyAvLyBDaGVjayBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgc291cmNlIGFuZCBmbGFnc1xuXG5mdW5jdGlvbiBhcmVTaW1pbGFyUmVnRXhwcyhhLCBiKSB7XG4gIHJldHVybiByZWdleEZsYWdzU3VwcG9ydGVkID8gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3MgOiBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSkgPT09IFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChiKTtcbn1cblxuZnVuY3Rpb24gYXJlU2ltaWxhckZsb2F0QXJyYXlzKGEsIGIpIHtcbiAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgYS5ieXRlTGVuZ3RoOyBvZmZzZXQrKykge1xuICAgIGlmIChhW29mZnNldF0gIT09IGJbb2Zmc2V0XSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBhcmVTaW1pbGFyVHlwZWRBcnJheXMoYSwgYikge1xuICBpZiAoYS5ieXRlTGVuZ3RoICE9PSBiLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gY29tcGFyZShuZXcgVWludDhBcnJheShhLmJ1ZmZlciwgYS5ieXRlT2Zmc2V0LCBhLmJ5dGVMZW5ndGgpLCBuZXcgVWludDhBcnJheShiLmJ1ZmZlciwgYi5ieXRlT2Zmc2V0LCBiLmJ5dGVMZW5ndGgpKSA9PT0gMDtcbn1cblxuZnVuY3Rpb24gYXJlRXF1YWxBcnJheUJ1ZmZlcnMoYnVmMSwgYnVmMikge1xuICByZXR1cm4gYnVmMS5ieXRlTGVuZ3RoID09PSBidWYyLmJ5dGVMZW5ndGggJiYgY29tcGFyZShuZXcgVWludDhBcnJheShidWYxKSwgbmV3IFVpbnQ4QXJyYXkoYnVmMikpID09PSAwO1xufVxuXG5mdW5jdGlvbiBpc0VxdWFsQm94ZWRQcmltaXRpdmUodmFsMSwgdmFsMikge1xuICBpZiAoaXNOdW1iZXJPYmplY3QodmFsMSkpIHtcbiAgICByZXR1cm4gaXNOdW1iZXJPYmplY3QodmFsMikgJiYgb2JqZWN0SXMoTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSksIE51bWJlci5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpKTtcbiAgfVxuXG4gIGlmIChpc1N0cmluZ09iamVjdCh2YWwxKSkge1xuICAgIHJldHVybiBpc1N0cmluZ09iamVjdCh2YWwyKSAmJiBTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSA9PT0gU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMik7XG4gIH1cblxuICBpZiAoaXNCb29sZWFuT2JqZWN0KHZhbDEpKSB7XG4gICAgcmV0dXJuIGlzQm9vbGVhbk9iamVjdCh2YWwyKSAmJiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSkgPT09IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKTtcbiAgfVxuXG4gIGlmIChpc0JpZ0ludE9iamVjdCh2YWwxKSkge1xuICAgIHJldHVybiBpc0JpZ0ludE9iamVjdCh2YWwyKSAmJiBCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSA9PT0gQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMik7XG4gIH1cblxuICByZXR1cm4gaXNTeW1ib2xPYmplY3QodmFsMikgJiYgU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSkgPT09IFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpO1xufSAvLyBOb3RlczogVHlwZSB0YWdzIGFyZSBoaXN0b3JpY2FsIFtbQ2xhc3NdXSBwcm9wZXJ0aWVzIHRoYXQgY2FuIGJlIHNldCBieVxuLy8gRnVuY3Rpb25UZW1wbGF0ZTo6U2V0Q2xhc3NOYW1lKCkgaW4gQysrIG9yIFN5bWJvbC50b1N0cmluZ1RhZyBpbiBKU1xuLy8gYW5kIHJldHJpZXZlZCB1c2luZyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSBpbiBKU1xuLy8gU2VlIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmdcbi8vIGZvciBhIGxpc3Qgb2YgdGFncyBwcmUtZGVmaW5lZCBpbiB0aGUgc3BlYy5cbi8vIFRoZXJlIGFyZSBzb21lIHVuc3BlY2lmaWVkIHRhZ3MgaW4gdGhlIHdpbGQgdG9vIChlLmcuIHR5cGVkIGFycmF5IHRhZ3MpLlxuLy8gU2luY2UgdGFncyBjYW4gYmUgYWx0ZXJlZCwgdGhleSBvbmx5IHNlcnZlIGZhc3QgZmFpbHVyZXNcbi8vXG4vLyBUeXBlZCBhcnJheXMgYW5kIGJ1ZmZlcnMgYXJlIGNoZWNrZWQgYnkgY29tcGFyaW5nIHRoZSBjb250ZW50IGluIHRoZWlyXG4vLyB1bmRlcmx5aW5nIEFycmF5QnVmZmVyLiBUaGlzIG9wdGltaXphdGlvbiByZXF1aXJlcyB0aGF0IGl0J3Ncbi8vIHJlYXNvbmFibGUgdG8gaW50ZXJwcmV0IHRoZWlyIHVuZGVybHlpbmcgbWVtb3J5IGluIHRoZSBzYW1lIHdheSxcbi8vIHdoaWNoIGlzIGNoZWNrZWQgYnkgY29tcGFyaW5nIHRoZWlyIHR5cGUgdGFncy5cbi8vIChlLmcuIGEgVWludDhBcnJheSBhbmQgYSBVaW50MTZBcnJheSB3aXRoIHRoZSBzYW1lIG1lbW9yeSBjb250ZW50XG4vLyBjb3VsZCBzdGlsbCBiZSBkaWZmZXJlbnQgYmVjYXVzZSB0aGV5IHdpbGwgYmUgaW50ZXJwcmV0ZWQgZGlmZmVyZW50bHkpLlxuLy9cbi8vIEZvciBzdHJpY3QgY29tcGFyaXNvbiwgb2JqZWN0cyBzaG91bGQgaGF2ZVxuLy8gYSkgVGhlIHNhbWUgYnVpbHQtaW4gdHlwZSB0YWdzXG4vLyBiKSBUaGUgc2FtZSBwcm90b3R5cGVzLlxuXG5cbmZ1bmN0aW9uIGlubmVyRGVlcEVxdWFsKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MpIHtcbiAgLy8gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAodmFsMSA9PT0gdmFsMikge1xuICAgIGlmICh2YWwxICE9PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gc3RyaWN0ID8gb2JqZWN0SXModmFsMSwgdmFsMikgOiB0cnVlO1xuICB9IC8vIENoZWNrIG1vcmUgY2xvc2VseSBpZiB2YWwxIGFuZCB2YWwyIGFyZSBlcXVhbC5cblxuXG4gIGlmIChzdHJpY3QpIHtcbiAgICBpZiAoX3R5cGVvZih2YWwxKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsMSA9PT0gJ251bWJlcicgJiYgbnVtYmVySXNOYU4odmFsMSkgJiYgbnVtYmVySXNOYU4odmFsMik7XG4gICAgfVxuXG4gICAgaWYgKF90eXBlb2YodmFsMikgIT09ICdvYmplY3QnIHx8IHZhbDEgPT09IG51bGwgfHwgdmFsMiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsMSkgIT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWwyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsMSA9PT0gbnVsbCB8fCBfdHlwZW9mKHZhbDEpICE9PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHZhbDIgPT09IG51bGwgfHwgX3R5cGVvZih2YWwyKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgICByZXR1cm4gdmFsMSA9PSB2YWwyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHZhbDIgPT09IG51bGwgfHwgX3R5cGVvZih2YWwyKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB2YXIgdmFsMVRhZyA9IG9iamVjdFRvU3RyaW5nKHZhbDEpO1xuICB2YXIgdmFsMlRhZyA9IG9iamVjdFRvU3RyaW5nKHZhbDIpO1xuXG4gIGlmICh2YWwxVGFnICE9PSB2YWwyVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsMSkpIHtcbiAgICAvLyBDaGVjayBmb3Igc3BhcnNlIGFycmF5cyBhbmQgZ2VuZXJhbCBmYXN0IHBhdGhcbiAgICBpZiAodmFsMS5sZW5ndGggIT09IHZhbDIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGtleXMxID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbDEsIE9OTFlfRU5VTUVSQUJMRSk7XG4gICAgdmFyIGtleXMyID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbDIsIE9OTFlfRU5VTUVSQUJMRSk7XG5cbiAgICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywga0lzQXJyYXksIGtleXMxKTtcbiAgfSAvLyBbYnJvd3NlcmlmeV0gVGhpcyB0cmlnZ2VycyBvbiBjZXJ0YWluIHR5cGVzIGluIElFIChNYXAvU2V0KSBzbyB3ZSBkb24ndFxuICAvLyB3YW4ndCB0byBlYXJseSByZXR1cm4gb3V0IG9mIHRoZSByZXN0IG9mIHRoZSBjaGVja3MuIEhvd2V2ZXIgd2UgY2FuIGNoZWNrXG4gIC8vIGlmIHRoZSBzZWNvbmQgdmFsdWUgaXMgb25lIG9mIHRoZXNlIHZhbHVlcyBhbmQgdGhlIGZpcnN0IGlzbid0LlxuXG5cbiAgaWYgKHZhbDFUYWcgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgLy8gcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtOb0l0ZXJhdG9yKTtcbiAgICBpZiAoIWlzTWFwKHZhbDEpICYmIGlzTWFwKHZhbDIpIHx8ICFpc1NldCh2YWwxKSAmJiBpc1NldCh2YWwyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc0RhdGUodmFsMSkpIHtcbiAgICBpZiAoIWlzRGF0ZSh2YWwyKSB8fCBEYXRlLnByb3RvdHlwZS5nZXRUaW1lLmNhbGwodmFsMSkgIT09IERhdGUucHJvdG90eXBlLmdldFRpbWUuY2FsbCh2YWwyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1JlZ0V4cCh2YWwxKSkge1xuICAgIGlmICghaXNSZWdFeHAodmFsMikgfHwgIWFyZVNpbWlsYXJSZWdFeHBzKHZhbDEsIHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzTmF0aXZlRXJyb3IodmFsMSkgfHwgdmFsMSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgLy8gRG8gbm90IGNvbXBhcmUgdGhlIHN0YWNrIGFzIGl0IG1pZ2h0IGRpZmZlciBldmVuIHRob3VnaCB0aGUgZXJyb3IgaXRzZWxmXG4gICAgLy8gaXMgb3RoZXJ3aXNlIGlkZW50aWNhbC5cbiAgICBpZiAodmFsMS5tZXNzYWdlICE9PSB2YWwyLm1lc3NhZ2UgfHwgdmFsMS5uYW1lICE9PSB2YWwyLm5hbWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlclZpZXcodmFsMSkpIHtcbiAgICBpZiAoIXN0cmljdCAmJiAoaXNGbG9hdDMyQXJyYXkodmFsMSkgfHwgaXNGbG9hdDY0QXJyYXkodmFsMSkpKSB7XG4gICAgICBpZiAoIWFyZVNpbWlsYXJGbG9hdEFycmF5cyh2YWwxLCB2YWwyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYXJlU2ltaWxhclR5cGVkQXJyYXlzKHZhbDEsIHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBCdWZmZXIuY29tcGFyZSByZXR1cm5zIHRydWUsIHNvIHZhbDEubGVuZ3RoID09PSB2YWwyLmxlbmd0aC4gSWYgdGhleSBib3RoXG4gICAgLy8gb25seSBjb250YWluIG51bWVyaWMga2V5cywgd2UgZG9uJ3QgbmVlZCB0byBleGFtIGZ1cnRoZXIgdGhhbiBjaGVja2luZ1xuICAgIC8vIHRoZSBzeW1ib2xzLlxuXG5cbiAgICB2YXIgX2tleXMgPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsMSwgT05MWV9FTlVNRVJBQkxFKTtcblxuICAgIHZhciBfa2V5czIgPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsMiwgT05MWV9FTlVNRVJBQkxFKTtcblxuICAgIGlmIChfa2V5cy5sZW5ndGggIT09IF9rZXlzMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywga05vSXRlcmF0b3IsIF9rZXlzKTtcbiAgfSBlbHNlIGlmIChpc1NldCh2YWwxKSkge1xuICAgIGlmICghaXNTZXQodmFsMikgfHwgdmFsMS5zaXplICE9PSB2YWwyLnNpemUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywga0lzU2V0KTtcbiAgfSBlbHNlIGlmIChpc01hcCh2YWwxKSkge1xuICAgIGlmICghaXNNYXAodmFsMikgfHwgdmFsMS5zaXplICE9PSB2YWwyLnNpemUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywga0lzTWFwKTtcbiAgfSBlbHNlIGlmIChpc0FueUFycmF5QnVmZmVyKHZhbDEpKSB7XG4gICAgaWYgKCFhcmVFcXVhbEFycmF5QnVmZmVycyh2YWwxLCB2YWwyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0JveGVkUHJpbWl0aXZlKHZhbDEpICYmICFpc0VxdWFsQm94ZWRQcmltaXRpdmUodmFsMSwgdmFsMikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywga05vSXRlcmF0b3IpO1xufVxuXG5mdW5jdGlvbiBnZXRFbnVtZXJhYmxlcyh2YWwsIGtleXMpIHtcbiAgcmV0dXJuIGtleXMuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbCwgayk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBpdGVyYXRpb25UeXBlLCBhS2V5cykge1xuICAvLyBGb3IgYWxsIHJlbWFpbmluZyBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSwgb2JqZWN0cyBhbmQgTWFwcyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSBoYXZpbmc6XG4gIC8vIGEpIFRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBlbnVtZXJhYmxlIHByb3BlcnRpZXNcbiAgLy8gYikgVGhlIHNhbWUgc2V0IG9mIGtleXMvaW5kZXhlcyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKVxuICAvLyBjKSBFcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXkvaW5kZXhcbiAgLy8gZCkgRm9yIFNldHMgYW5kIE1hcHMsIGVxdWFsIGNvbnRlbnRzXG4gIC8vIE5vdGU6IHRoaXMgYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA1KSB7XG4gICAgYUtleXMgPSBPYmplY3Qua2V5cyh2YWwxKTtcbiAgICB2YXIgYktleXMgPSBPYmplY3Qua2V5cyh2YWwyKTsgLy8gVGhlIHBhaXIgbXVzdCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzLlxuXG4gICAgaWYgKGFLZXlzLmxlbmd0aCAhPT0gYktleXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IC8vIENoZWFwIGtleSB0ZXN0XG5cblxuICB2YXIgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBhS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaGFzT3duUHJvcGVydHkodmFsMiwgYUtleXNbaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0cmljdCAmJiBhcmd1bWVudHMubGVuZ3RoID09PSA1KSB7XG4gICAgdmFyIHN5bWJvbEtleXNBID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbDEpO1xuXG4gICAgaWYgKHN5bWJvbEtleXNBLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdmFyIGNvdW50ID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHN5bWJvbEtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBzeW1ib2xLZXlzQVtpXTtcblxuICAgICAgICBpZiAocHJvcGVydHlJc0VudW1lcmFibGUodmFsMSwga2V5KSkge1xuICAgICAgICAgIGlmICghcHJvcGVydHlJc0VudW1lcmFibGUodmFsMiwga2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICBjb3VudCsrO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbDIsIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHN5bWJvbEtleXNCID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbDIpO1xuXG4gICAgICBpZiAoc3ltYm9sS2V5c0EubGVuZ3RoICE9PSBzeW1ib2xLZXlzQi5sZW5ndGggJiYgZ2V0RW51bWVyYWJsZXModmFsMiwgc3ltYm9sS2V5c0IpLmxlbmd0aCAhPT0gY291bnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3N5bWJvbEtleXNCID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbDIpO1xuXG4gICAgICBpZiAoX3N5bWJvbEtleXNCLmxlbmd0aCAhPT0gMCAmJiBnZXRFbnVtZXJhYmxlcyh2YWwyLCBfc3ltYm9sS2V5c0IpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGFLZXlzLmxlbmd0aCA9PT0gMCAmJiAoaXRlcmF0aW9uVHlwZSA9PT0ga05vSXRlcmF0b3IgfHwgaXRlcmF0aW9uVHlwZSA9PT0ga0lzQXJyYXkgJiYgdmFsMS5sZW5ndGggPT09IDAgfHwgdmFsMS5zaXplID09PSAwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIFVzZSBtZW1vcyB0byBoYW5kbGUgY3ljbGVzLlxuXG5cbiAgaWYgKG1lbW9zID09PSB1bmRlZmluZWQpIHtcbiAgICBtZW1vcyA9IHtcbiAgICAgIHZhbDE6IG5ldyBNYXAoKSxcbiAgICAgIHZhbDI6IG5ldyBNYXAoKSxcbiAgICAgIHBvc2l0aW9uOiAwXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBwcmV2ZW50IHVwIHRvIHR3byBtYXAuaGFzKHgpIGNhbGxzIGJ5IGRpcmVjdGx5IHJldHJpZXZpbmcgdGhlIHZhbHVlXG4gICAgLy8gYW5kIGNoZWNraW5nIGZvciB1bmRlZmluZWQuIFRoZSBtYXAgY2FuIG9ubHkgY29udGFpbiBudW1iZXJzLCBzbyBpdCBpc1xuICAgIC8vIHNhZmUgdG8gY2hlY2sgZm9yIHVuZGVmaW5lZCBvbmx5LlxuICAgIHZhciB2YWwyTWVtb0EgPSBtZW1vcy52YWwxLmdldCh2YWwxKTtcblxuICAgIGlmICh2YWwyTWVtb0EgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHZhbDJNZW1vQiA9IG1lbW9zLnZhbDIuZ2V0KHZhbDIpO1xuXG4gICAgICBpZiAodmFsMk1lbW9CICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbDJNZW1vQSA9PT0gdmFsMk1lbW9CO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1lbW9zLnBvc2l0aW9uKys7XG4gIH1cblxuICBtZW1vcy52YWwxLnNldCh2YWwxLCBtZW1vcy5wb3NpdGlvbik7XG4gIG1lbW9zLnZhbDIuc2V0KHZhbDIsIG1lbW9zLnBvc2l0aW9uKTtcbiAgdmFyIGFyZUVxID0gb2JqRXF1aXYodmFsMSwgdmFsMiwgc3RyaWN0LCBhS2V5cywgbWVtb3MsIGl0ZXJhdGlvblR5cGUpO1xuICBtZW1vcy52YWwxLmRlbGV0ZSh2YWwxKTtcbiAgbWVtb3MudmFsMi5kZWxldGUodmFsMik7XG4gIHJldHVybiBhcmVFcTtcbn1cblxuZnVuY3Rpb24gc2V0SGFzRXF1YWxFbGVtZW50KHNldCwgdmFsMSwgc3RyaWN0LCBtZW1vKSB7XG4gIC8vIEdvIGxvb2tpbmcuXG4gIHZhciBzZXRWYWx1ZXMgPSBhcnJheUZyb21TZXQoc2V0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNldFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB2YWwyID0gc2V0VmFsdWVzW2ldO1xuXG4gICAgaWYgKGlubmVyRGVlcEVxdWFsKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtbykpIHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgbWF0Y2hpbmcgZWxlbWVudCB0byBtYWtlIHN1cmUgd2UgZG8gbm90IGNoZWNrIHRoYXQgYWdhaW4uXG4gICAgICBzZXQuZGVsZXRlKHZhbDIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufSAvLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9FcXVhbGl0eV9jb21wYXJpc29uc19hbmRfc2FtZW5lc3MjTG9vc2VfZXF1YWxpdHlfdXNpbmdcbi8vIFNhZGx5IGl0IGlzIG5vdCBwb3NzaWJsZSB0byBkZXRlY3QgY29ycmVzcG9uZGluZyB2YWx1ZXMgcHJvcGVybHkgaW4gY2FzZSB0aGVcbi8vIHR5cGUgaXMgYSBzdHJpbmcsIG51bWJlciwgYmlnaW50IG9yIGJvb2xlYW4uIFRoZSByZWFzb24gaXMgdGhhdCB0aG9zZSB2YWx1ZXNcbi8vIGNhbiBtYXRjaCBsb3RzIG9mIGRpZmZlcmVudCBzdHJpbmcgdmFsdWVzIChlLmcuLCAxbiA9PSAnKzAwMDAxJykuXG5cblxuZnVuY3Rpb24gZmluZExvb3NlTWF0Y2hpbmdQcmltaXRpdmVzKHByaW0pIHtcbiAgc3dpdGNoIChfdHlwZW9mKHByaW0pKSB7XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIC8vIE9ubHkgcGFzcyBpbiBudWxsIGFzIG9iamVjdCFcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHByaW0gPSArcHJpbTtcbiAgICAvLyBMb29zZSBlcXVhbCBlbnRyaWVzIGV4aXN0IG9ubHkgaWYgdGhlIHN0cmluZyBpcyBwb3NzaWJsZSB0byBjb252ZXJ0IHRvXG4gICAgLy8gYSByZWd1bGFyIG51bWJlciBhbmQgbm90IE5hTi5cbiAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBpZiAobnVtYmVySXNOYU4ocHJpbSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gc2V0TWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIHByaW0pIHtcbiAgdmFyIGFsdFZhbHVlID0gZmluZExvb3NlTWF0Y2hpbmdQcmltaXRpdmVzKHByaW0pO1xuICBpZiAoYWx0VmFsdWUgIT0gbnVsbCkgcmV0dXJuIGFsdFZhbHVlO1xuICByZXR1cm4gYi5oYXMoYWx0VmFsdWUpICYmICFhLmhhcyhhbHRWYWx1ZSk7XG59XG5cbmZ1bmN0aW9uIG1hcE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCBwcmltLCBpdGVtLCBtZW1vKSB7XG4gIHZhciBhbHRWYWx1ZSA9IGZpbmRMb29zZU1hdGNoaW5nUHJpbWl0aXZlcyhwcmltKTtcblxuICBpZiAoYWx0VmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBhbHRWYWx1ZTtcbiAgfVxuXG4gIHZhciBjdXJCID0gYi5nZXQoYWx0VmFsdWUpO1xuXG4gIGlmIChjdXJCID09PSB1bmRlZmluZWQgJiYgIWIuaGFzKGFsdFZhbHVlKSB8fCAhaW5uZXJEZWVwRXF1YWwoaXRlbSwgY3VyQiwgZmFsc2UsIG1lbW8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuICFhLmhhcyhhbHRWYWx1ZSkgJiYgaW5uZXJEZWVwRXF1YWwoaXRlbSwgY3VyQiwgZmFsc2UsIG1lbW8pO1xufVxuXG5mdW5jdGlvbiBzZXRFcXVpdihhLCBiLCBzdHJpY3QsIG1lbW8pIHtcbiAgLy8gVGhpcyBpcyBhIGxhemlseSBpbml0aWF0ZWQgU2V0IG9mIGVudHJpZXMgd2hpY2ggaGF2ZSB0byBiZSBjb21wYXJlZFxuICAvLyBwYWlyd2lzZS5cbiAgdmFyIHNldCA9IG51bGw7XG4gIHZhciBhVmFsdWVzID0gYXJyYXlGcm9tU2V0KGEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYVZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB2YWwgPSBhVmFsdWVzW2ldOyAvLyBOb3RlOiBDaGVja2luZyBmb3IgdGhlIG9iamVjdHMgZmlyc3QgaW1wcm92ZXMgdGhlIHBlcmZvcm1hbmNlIGZvciBvYmplY3RcbiAgICAvLyBoZWF2eSBzZXRzIGJ1dCBpdCBpcyBhIG1pbm9yIHNsb3cgZG93biBmb3IgcHJpbWl0aXZlcy4gQXMgdGhleSBhcmUgZmFzdFxuICAgIC8vIHRvIGNoZWNrIHRoaXMgaW1wcm92ZXMgdGhlIHdvcnN0IGNhc2Ugc2NlbmFyaW8gaW5zdGVhZC5cblxuICAgIGlmIChfdHlwZW9mKHZhbCkgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgaWYgKHNldCA9PT0gbnVsbCkge1xuICAgICAgICBzZXQgPSBuZXcgU2V0KCk7XG4gICAgICB9IC8vIElmIHRoZSBzcGVjaWZpZWQgdmFsdWUgZG9lc24ndCBleGlzdCBpbiB0aGUgc2Vjb25kIHNldCBpdHMgYW4gbm90IG51bGxcbiAgICAgIC8vIG9iamVjdCAob3Igbm9uIHN0cmljdCBvbmx5OiBhIG5vdCBtYXRjaGluZyBwcmltaXRpdmUpIHdlJ2xsIG5lZWQgdG8gZ29cbiAgICAgIC8vIGh1bnRpbmcgZm9yIHNvbWV0aGluZyB0aGF0cyBkZWVwLShzdHJpY3QtKWVxdWFsIHRvIGl0LiBUbyBtYWtlIHRoaXNcbiAgICAgIC8vIE8obiBsb2cgbikgY29tcGxleGl0eSB3ZSBoYXZlIHRvIGNvcHkgdGhlc2UgdmFsdWVzIGluIGEgbmV3IHNldCBmaXJzdC5cblxuXG4gICAgICBzZXQuYWRkKHZhbCk7XG4gICAgfSBlbHNlIGlmICghYi5oYXModmFsKSkge1xuICAgICAgaWYgKHN0cmljdCkgcmV0dXJuIGZhbHNlOyAvLyBGYXN0IHBhdGggdG8gZGV0ZWN0IG1pc3Npbmcgc3RyaW5nLCBzeW1ib2wsIHVuZGVmaW5lZCBhbmQgbnVsbCB2YWx1ZXMuXG5cbiAgICAgIGlmICghc2V0TWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2V0ID09PSBudWxsKSB7XG4gICAgICAgIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgIH1cblxuICAgICAgc2V0LmFkZCh2YWwpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzZXQgIT09IG51bGwpIHtcbiAgICB2YXIgYlZhbHVlcyA9IGFycmF5RnJvbVNldChiKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBiVmFsdWVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF92YWwgPSBiVmFsdWVzW19pXTsgLy8gV2UgaGF2ZSB0byBjaGVjayBpZiBhIHByaW1pdGl2ZSB2YWx1ZSBpcyBhbHJlYWR5XG4gICAgICAvLyBtYXRjaGluZyBhbmQgb25seSBpZiBpdCdzIG5vdCwgZ28gaHVudGluZyBmb3IgaXQuXG5cbiAgICAgIGlmIChfdHlwZW9mKF92YWwpID09PSAnb2JqZWN0JyAmJiBfdmFsICE9PSBudWxsKSB7XG4gICAgICAgIGlmICghc2V0SGFzRXF1YWxFbGVtZW50KHNldCwgX3ZhbCwgc3RyaWN0LCBtZW1vKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmICFhLmhhcyhfdmFsKSAmJiAhc2V0SGFzRXF1YWxFbGVtZW50KHNldCwgX3ZhbCwgc3RyaWN0LCBtZW1vKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldC5zaXplID09PSAwO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG1hcEhhc0VxdWFsRW50cnkoc2V0LCBtYXAsIGtleTEsIGl0ZW0xLCBzdHJpY3QsIG1lbW8pIHtcbiAgLy8gVG8gYmUgYWJsZSB0byBoYW5kbGUgY2FzZXMgbGlrZTpcbiAgLy8gICBNYXAoW1t7fSwgJ2EnXSwgW3t9LCAnYiddXSkgdnMgTWFwKFtbe30sICdiJ10sIFt7fSwgJ2EnXV0pXG4gIC8vIC4uLiB3ZSBuZWVkIHRvIGNvbnNpZGVyICphbGwqIG1hdGNoaW5nIGtleXMsIG5vdCBqdXN0IHRoZSBmaXJzdCB3ZSBmaW5kLlxuICB2YXIgc2V0VmFsdWVzID0gYXJyYXlGcm9tU2V0KHNldCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5MiA9IHNldFZhbHVlc1tpXTtcblxuICAgIGlmIChpbm5lckRlZXBFcXVhbChrZXkxLCBrZXkyLCBzdHJpY3QsIG1lbW8pICYmIGlubmVyRGVlcEVxdWFsKGl0ZW0xLCBtYXAuZ2V0KGtleTIpLCBzdHJpY3QsIG1lbW8pKSB7XG4gICAgICBzZXQuZGVsZXRlKGtleTIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBtYXBFcXVpdihhLCBiLCBzdHJpY3QsIG1lbW8pIHtcbiAgdmFyIHNldCA9IG51bGw7XG4gIHZhciBhRW50cmllcyA9IGFycmF5RnJvbU1hcChhKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFFbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9hRW50cmllcyRpID0gX3NsaWNlZFRvQXJyYXkoYUVudHJpZXNbaV0sIDIpLFxuICAgICAgICBrZXkgPSBfYUVudHJpZXMkaVswXSxcbiAgICAgICAgaXRlbTEgPSBfYUVudHJpZXMkaVsxXTtcblxuICAgIGlmIChfdHlwZW9mKGtleSkgPT09ICdvYmplY3QnICYmIGtleSAhPT0gbnVsbCkge1xuICAgICAgaWYgKHNldCA9PT0gbnVsbCkge1xuICAgICAgICBzZXQgPSBuZXcgU2V0KCk7XG4gICAgICB9XG5cbiAgICAgIHNldC5hZGQoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQnkgZGlyZWN0bHkgcmV0cmlldmluZyB0aGUgdmFsdWUgd2UgcHJldmVudCBhbm90aGVyIGIuaGFzKGtleSkgY2hlY2sgaW5cbiAgICAgIC8vIGFsbW9zdCBhbGwgcG9zc2libGUgY2FzZXMuXG4gICAgICB2YXIgaXRlbTIgPSBiLmdldChrZXkpO1xuXG4gICAgICBpZiAoaXRlbTIgPT09IHVuZGVmaW5lZCAmJiAhYi5oYXMoa2V5KSB8fCAhaW5uZXJEZWVwRXF1YWwoaXRlbTEsIGl0ZW0yLCBzdHJpY3QsIG1lbW8pKSB7XG4gICAgICAgIGlmIChzdHJpY3QpIHJldHVybiBmYWxzZTsgLy8gRmFzdCBwYXRoIHRvIGRldGVjdCBtaXNzaW5nIHN0cmluZywgc3ltYm9sLCB1bmRlZmluZWQgYW5kIG51bGxcbiAgICAgICAgLy8ga2V5cy5cblxuICAgICAgICBpZiAoIW1hcE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCBrZXksIGl0ZW0xLCBtZW1vKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGlmIChzZXQgPT09IG51bGwpIHtcbiAgICAgICAgICBzZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXQuYWRkKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHNldCAhPT0gbnVsbCkge1xuICAgIHZhciBiRW50cmllcyA9IGFycmF5RnJvbU1hcChiKTtcblxuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGJFbnRyaWVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIHZhciBfYkVudHJpZXMkX2kgPSBfc2xpY2VkVG9BcnJheShiRW50cmllc1tfaTJdLCAyKSxcbiAgICAgICAgICBrZXkgPSBfYkVudHJpZXMkX2lbMF0sXG4gICAgICAgICAgaXRlbSA9IF9iRW50cmllcyRfaVsxXTtcblxuICAgICAgaWYgKF90eXBlb2Yoa2V5KSA9PT0gJ29iamVjdCcgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICAgIGlmICghbWFwSGFzRXF1YWxFbnRyeShzZXQsIGEsIGtleSwgaXRlbSwgc3RyaWN0LCBtZW1vKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmICghYS5oYXMoa2V5KSB8fCAhaW5uZXJEZWVwRXF1YWwoYS5nZXQoa2V5KSwgaXRlbSwgZmFsc2UsIG1lbW8pKSAmJiAhbWFwSGFzRXF1YWxFbnRyeShzZXQsIGEsIGtleSwgaXRlbSwgZmFsc2UsIG1lbW8pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2V0LnNpemUgPT09IDA7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYiwgc3RyaWN0LCBrZXlzLCBtZW1vcywgaXRlcmF0aW9uVHlwZSkge1xuICAvLyBTZXRzIGFuZCBtYXBzIGRvbid0IGhhdmUgdGhlaXIgZW50cmllcyBhY2Nlc3NpYmxlIHZpYSBub3JtYWwgb2JqZWN0XG4gIC8vIHByb3BlcnRpZXMuXG4gIHZhciBpID0gMDtcblxuICBpZiAoaXRlcmF0aW9uVHlwZSA9PT0ga0lzU2V0KSB7XG4gICAgaWYgKCFzZXRFcXVpdihhLCBiLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpdGVyYXRpb25UeXBlID09PSBrSXNNYXApIHtcbiAgICBpZiAoIW1hcEVxdWl2KGEsIGIsIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGl0ZXJhdGlvblR5cGUgPT09IGtJc0FycmF5KSB7XG4gICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkoYSwgaSkpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShiLCBpKSB8fCAhaW5uZXJEZWVwRXF1YWwoYVtpXSwgYltpXSwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaGFzT3duUHJvcGVydHkoYiwgaSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXJyYXkgaXMgc3BhcnNlLlxuICAgICAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcblxuICAgICAgICBmb3IgKDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNBW2ldO1xuXG4gICAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShiLCBrZXkpIHx8ICFpbm5lckRlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5c0EubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gVGhlIHBhaXIgbXVzdCBoYXZlIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleS5cbiAgLy8gUG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdDpcblxuXG4gIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9rZXkgPSBrZXlzW2ldO1xuXG4gICAgaWYgKCFpbm5lckRlZXBFcXVhbChhW19rZXldLCBiW19rZXldLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc0RlZXBFcXVhbCh2YWwxLCB2YWwyKSB7XG4gIHJldHVybiBpbm5lckRlZXBFcXVhbCh2YWwxLCB2YWwyLCBrTG9vc2UpO1xufVxuXG5mdW5jdGlvbiBpc0RlZXBTdHJpY3RFcXVhbCh2YWwxLCB2YWwyKSB7XG4gIHJldHVybiBpbm5lckRlZXBFcXVhbCh2YWwxLCB2YWwyLCBrU3RyaWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzRGVlcEVxdWFsOiBpc0RlZXBFcXVhbCxcbiAgaXNEZWVwU3RyaWN0RXF1YWw6IGlzRGVlcFN0cmljdEVxdWFsXG59O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMjY4MDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEdldEludHJpbnNpYyA9IF9fd2VicGFja19yZXF1aXJlX18oNzI4Nik7XG5cbnZhciBjYWxsQmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oOTQyOSk7XG5cbnZhciAkaW5kZXhPZiA9IGNhbGxCaW5kKEdldEludHJpbnNpYygnU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mJykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCb3VuZEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0dmFyIGludHJpbnNpYyA9IEdldEludHJpbnNpYyhuYW1lLCAhIWFsbG93TWlzc2luZyk7XG5cdGlmICh0eXBlb2YgaW50cmluc2ljID09PSAnZnVuY3Rpb24nICYmICRpbmRleE9mKG5hbWUsICcucHJvdG90eXBlLicpID4gLTEpIHtcblx0XHRyZXR1cm4gY2FsbEJpbmQoaW50cmluc2ljKTtcblx0fVxuXHRyZXR1cm4gaW50cmluc2ljO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTQyOTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwOTApO1xudmFyIEdldEludHJpbnNpYyA9IF9fd2VicGFja19yZXF1aXJlX18oNzI4Nik7XG5cbnZhciAkYXBwbHkgPSBHZXRJbnRyaW5zaWMoJyVGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHklJyk7XG52YXIgJGNhbGwgPSBHZXRJbnRyaW5zaWMoJyVGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCUnKTtcbnZhciAkcmVmbGVjdEFwcGx5ID0gR2V0SW50cmluc2ljKCclUmVmbGVjdC5hcHBseSUnLCB0cnVlKSB8fCBiaW5kLmNhbGwoJGNhbGwsICRhcHBseSk7XG5cbnZhciAkZ09QRCA9IEdldEludHJpbnNpYygnJU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IlJywgdHJ1ZSk7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmRlZmluZVByb3BlcnR5JScsIHRydWUpO1xudmFyICRtYXggPSBHZXRJbnRyaW5zaWMoJyVNYXRoLm1heCUnKTtcblxuaWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHR0cnkge1xuXHRcdCRkZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IHZhbHVlOiAxIH0pO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gSUUgOCBoYXMgYSBicm9rZW4gZGVmaW5lUHJvcGVydHlcblx0XHQkZGVmaW5lUHJvcGVydHkgPSBudWxsO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FsbEJpbmQob3JpZ2luYWxGdW5jdGlvbikge1xuXHR2YXIgZnVuYyA9ICRyZWZsZWN0QXBwbHkoYmluZCwgJGNhbGwsIGFyZ3VtZW50cyk7XG5cdGlmICgkZ09QRCAmJiAkZGVmaW5lUHJvcGVydHkpIHtcblx0XHR2YXIgZGVzYyA9ICRnT1BEKGZ1bmMsICdsZW5ndGgnKTtcblx0XHRpZiAoZGVzYy5jb25maWd1cmFibGUpIHtcblx0XHRcdC8vIG9yaWdpbmFsIGxlbmd0aCwgcGx1cyB0aGUgcmVjZWl2ZXIsIG1pbnVzIGFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyAoYWZ0ZXIgdGhlIHJlY2VpdmVyKVxuXHRcdFx0JGRlZmluZVByb3BlcnR5KFxuXHRcdFx0XHRmdW5jLFxuXHRcdFx0XHQnbGVuZ3RoJyxcblx0XHRcdFx0eyB2YWx1ZTogMSArICRtYXgoMCwgb3JpZ2luYWxGdW5jdGlvbi5sZW5ndGggLSAoYXJndW1lbnRzLmxlbmd0aCAtIDEpKSB9XG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZnVuYztcbn07XG5cbnZhciBhcHBseUJpbmQgPSBmdW5jdGlvbiBhcHBseUJpbmQoKSB7XG5cdHJldHVybiAkcmVmbGVjdEFwcGx5KGJpbmQsICRhcHBseSwgYXJndW1lbnRzKTtcbn07XG5cbmlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0JGRlZmluZVByb3BlcnR5KG1vZHVsZS5leHBvcnRzLCAnYXBwbHknLCB7IHZhbHVlOiBhcHBseUJpbmQgfSk7XG59IGVsc2Uge1xuXHRtb2R1bGUuZXhwb3J0cy5hcHBseSA9IGFwcGx5QmluZDtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzcxNjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLypnbG9iYWwgd2luZG93LCBnbG9iYWwqL1xudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzMzUpXG52YXIgYXNzZXJ0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjk2KVxuZnVuY3Rpb24gbm93KCkgeyByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgfVxuXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2VcbnZhciBjb25zb2xlXG52YXIgdGltZXMgPSB7fVxuXG5pZiAodHlwZW9mIF9fd2VicGFja19yZXF1aXJlX18uZyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBfX3dlYnBhY2tfcmVxdWlyZV9fLmcuY29uc29sZSkge1xuICAgIGNvbnNvbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmcuY29uc29sZVxufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5jb25zb2xlKSB7XG4gICAgY29uc29sZSA9IHdpbmRvdy5jb25zb2xlXG59IGVsc2Uge1xuICAgIGNvbnNvbGUgPSB7fVxufVxuXG52YXIgZnVuY3Rpb25zID0gW1xuICAgIFtsb2csIFwibG9nXCJdLFxuICAgIFtpbmZvLCBcImluZm9cIl0sXG4gICAgW3dhcm4sIFwid2FyblwiXSxcbiAgICBbZXJyb3IsIFwiZXJyb3JcIl0sXG4gICAgW3RpbWUsIFwidGltZVwiXSxcbiAgICBbdGltZUVuZCwgXCJ0aW1lRW5kXCJdLFxuICAgIFt0cmFjZSwgXCJ0cmFjZVwiXSxcbiAgICBbZGlyLCBcImRpclwiXSxcbiAgICBbY29uc29sZUFzc2VydCwgXCJhc3NlcnRcIl1cbl1cblxuZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdHVwbGUgPSBmdW5jdGlvbnNbaV1cbiAgICB2YXIgZiA9IHR1cGxlWzBdXG4gICAgdmFyIG5hbWUgPSB0dXBsZVsxXVxuXG4gICAgaWYgKCFjb25zb2xlW25hbWVdKSB7XG4gICAgICAgIGNvbnNvbGVbbmFtZV0gPSBmXG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnNvbGVcblxuZnVuY3Rpb24gbG9nKCkge31cblxuZnVuY3Rpb24gaW5mbygpIHtcbiAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG59XG5cbmZ1bmN0aW9uIHdhcm4oKSB7XG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxufVxuXG5mdW5jdGlvbiBlcnJvcigpIHtcbiAgICBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxufVxuXG5mdW5jdGlvbiB0aW1lKGxhYmVsKSB7XG4gICAgdGltZXNbbGFiZWxdID0gbm93KClcbn1cblxuZnVuY3Rpb24gdGltZUVuZChsYWJlbCkge1xuICAgIHZhciB0aW1lID0gdGltZXNbbGFiZWxdXG4gICAgaWYgKCF0aW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHN1Y2ggbGFiZWw6IFwiICsgbGFiZWwpXG4gICAgfVxuXG4gICAgZGVsZXRlIHRpbWVzW2xhYmVsXVxuICAgIHZhciBkdXJhdGlvbiA9IG5vdygpIC0gdGltZVxuICAgIGNvbnNvbGUubG9nKGxhYmVsICsgXCI6IFwiICsgZHVyYXRpb24gKyBcIm1zXCIpXG59XG5cbmZ1bmN0aW9uIHRyYWNlKCkge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKVxuICAgIGVyci5uYW1lID0gXCJUcmFjZVwiXG4gICAgZXJyLm1lc3NhZ2UgPSB1dGlsLmZvcm1hdC5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICAgY29uc29sZS5lcnJvcihlcnIuc3RhY2spXG59XG5cbmZ1bmN0aW9uIGRpcihvYmplY3QpIHtcbiAgICBjb25zb2xlLmxvZyh1dGlsLmluc3BlY3Qob2JqZWN0KSArIFwiXFxuXCIpXG59XG5cbmZ1bmN0aW9uIGNvbnNvbGVBc3NlcnQoZXhwcmVzc2lvbikge1xuICAgIGlmICghZXhwcmVzc2lvbikge1xuICAgICAgICB2YXIgYXJyID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gICAgICAgIGFzc2VydC5vayhmYWxzZSwgdXRpbC5mb3JtYXQuYXBwbHkobnVsbCwgYXJyKSlcbiAgICB9XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ5MjY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBrZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDY0KTtcbnZhciBoYXNTeW1ib2xzID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sKCdmb28nKSA9PT0gJ3N5bWJvbCc7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcbnZhciBvcmlnRGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gKGZuKSB7XG5cdHJldHVybiB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgJiYgdG9TdHIuY2FsbChmbikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xuXG52YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oMTE4MSkoKTtcblxudmFyIHN1cHBvcnRzRGVzY3JpcHRvcnMgPSBvcmlnRGVmaW5lUHJvcGVydHkgJiYgaGFzUHJvcGVydHlEZXNjcmlwdG9ycztcblxudmFyIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgdmFsdWUsIHByZWRpY2F0ZSkge1xuXHRpZiAobmFtZSBpbiBvYmplY3QpIHtcblx0XHRpZiAocHJlZGljYXRlID09PSB0cnVlKSB7XG5cdFx0XHRpZiAob2JqZWN0W25hbWVdID09PSB2YWx1ZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICghaXNGdW5jdGlvbihwcmVkaWNhdGUpIHx8ICFwcmVkaWNhdGUoKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0fVxuXHRpZiAoc3VwcG9ydHNEZXNjcmlwdG9ycykge1xuXHRcdG9yaWdEZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0d3JpdGFibGU6IHRydWVcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHRvYmplY3RbbmFtZV0gPSB2YWx1ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuXHR9XG59O1xuXG52YXIgZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmplY3QsIG1hcCkge1xuXHR2YXIgcHJlZGljYXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDoge307XG5cdHZhciBwcm9wcyA9IGtleXMobWFwKTtcblx0aWYgKGhhc1N5bWJvbHMpIHtcblx0XHRwcm9wcyA9IGNvbmNhdC5jYWxsKHByb3BzLCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG1hcCkpO1xuXHR9XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRkZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BzW2ldLCBtYXBbcHJvcHNbaV1dLCBwcmVkaWNhdGVzW3Byb3BzW2ldXSk7XG5cdH1cbn07XG5cbmRlZmluZVByb3BlcnRpZXMuc3VwcG9ydHNEZXNjcmlwdG9ycyA9ICEhc3VwcG9ydHNEZXNjcmlwdG9ycztcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0aWVzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0OTU2OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvZGUgcmVmYWN0b3JlZCBmcm9tIE1vemlsbGEgRGV2ZWxvcGVyIE5ldHdvcms6XG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvYXNzaWduXG4gKi9cblxuXG5cbmZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIGZpcnN0U291cmNlKSB7XG4gIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBmaXJzdCBhcmd1bWVudCB0byBvYmplY3QnKTtcbiAgfVxuXG4gIHZhciB0byA9IE9iamVjdCh0YXJnZXQpO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuZXh0U291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgIGlmIChuZXh0U291cmNlID09PSB1bmRlZmluZWQgfHwgbmV4dFNvdXJjZSA9PT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGtleXNBcnJheSA9IE9iamVjdC5rZXlzKE9iamVjdChuZXh0U291cmNlKSk7XG4gICAgZm9yICh2YXIgbmV4dEluZGV4ID0gMCwgbGVuID0ga2V5c0FycmF5Lmxlbmd0aDsgbmV4dEluZGV4IDwgbGVuOyBuZXh0SW5kZXgrKykge1xuICAgICAgdmFyIG5leHRLZXkgPSBrZXlzQXJyYXlbbmV4dEluZGV4XTtcbiAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuZXh0U291cmNlLCBuZXh0S2V5KTtcbiAgICAgIGlmIChkZXNjICE9PSB1bmRlZmluZWQgJiYgZGVzYy5lbnVtZXJhYmxlKSB7XG4gICAgICAgIHRvW25leHRLZXldID0gbmV4dFNvdXJjZVtuZXh0S2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvO1xufVxuXG5mdW5jdGlvbiBwb2x5ZmlsbCgpIHtcbiAgaWYgKCFPYmplY3QuYXNzaWduKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdCwgJ2Fzc2lnbicsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogYXNzaWduXG4gICAgfSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFzc2lnbjogYXNzaWduLFxuICBwb2x5ZmlsbDogcG9seWZpbGxcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDMyNDM6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NjgwKTtcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmb3JFYWNoQXJyYXkgPSBmdW5jdGlvbiBmb3JFYWNoQXJyYXkoYXJyYXksIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgaSkpIHtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IoYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoU3RyaW5nID0gZnVuY3Rpb24gZm9yRWFjaFN0cmluZyhzdHJpbmcsIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gbm8gc3VjaCB0aGluZyBhcyBhIHNwYXJzZSBzdHJpbmcuXG4gICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihzdHJpbmcuY2hhckF0KGkpLCBpLCBzdHJpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgc3RyaW5nLmNoYXJBdChpKSwgaSwgc3RyaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoT2JqZWN0ID0gZnVuY3Rpb24gZm9yRWFjaE9iamVjdChvYmplY3QsIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGsgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgaykpIHtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3Iob2JqZWN0W2tdLCBrLCBvYmplY3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5jYWxsKHJlY2VpdmVyLCBvYmplY3Rba10sIGssIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2gobGlzdCwgaXRlcmF0b3IsIHRoaXNBcmcpIHtcbiAgICBpZiAoIWlzQ2FsbGFibGUoaXRlcmF0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2l0ZXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIHZhciByZWNlaXZlcjtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgIHJlY2VpdmVyID0gdGhpc0FyZztcbiAgICB9XG5cbiAgICBpZiAodG9TdHIuY2FsbChsaXN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICBmb3JFYWNoQXJyYXkobGlzdCwgaXRlcmF0b3IsIHJlY2VpdmVyKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBmb3JFYWNoU3RyaW5nKGxpc3QsIGl0ZXJhdG9yLCByZWNlaXZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yRWFjaE9iamVjdChsaXN0LCBpdGVyYXRvciwgcmVjZWl2ZXIpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzc5NTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qIGVzbGludCBuby1pbnZhbGlkLXRoaXM6IDEgKi9cblxudmFyIEVSUk9SX01FU1NBR0UgPSAnRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnO1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmdW5jVHlwZSA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZCh0aGF0KSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicgfHwgdG9TdHIuY2FsbCh0YXJnZXQpICE9PSBmdW5jVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUk9SX01FU1NBR0UgKyB0YXJnZXQpO1xuICAgIH1cbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIHZhciBib3VuZDtcbiAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGJvdW5kTGVuZ3RoID0gTWF0aC5tYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcbiAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJvdW5kQXJncy5wdXNoKCckJyArIGkpO1xuICAgIH1cblxuICAgIGJvdW5kID0gRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBib3VuZEFyZ3Muam9pbignLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgIHZhciBFbXB0eSA9IGZ1bmN0aW9uIEVtcHR5KCkge307XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBib3VuZDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQwOTA6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNzc5NSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgaW1wbGVtZW50YXRpb247XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDcyODY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB1bmRlZmluZWQ7XG5cbnZhciAkU3ludGF4RXJyb3IgPSBTeW50YXhFcnJvcjtcbnZhciAkRnVuY3Rpb24gPSBGdW5jdGlvbjtcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbnZhciBnZXRFdmFsbGVkQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoZXhwcmVzc2lvblN5bnRheCkge1xuXHR0cnkge1xuXHRcdHJldHVybiAkRnVuY3Rpb24oJ1widXNlIHN0cmljdFwiOyByZXR1cm4gKCcgKyBleHByZXNzaW9uU3ludGF4ICsgJykuY29uc3RydWN0b3I7JykoKTtcblx0fSBjYXRjaCAoZSkge31cbn07XG5cbnZhciAkZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5pZiAoJGdPUEQpIHtcblx0dHJ5IHtcblx0XHQkZ09QRCh7fSwgJycpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0JGdPUEQgPSBudWxsOyAvLyB0aGlzIGlzIElFIDgsIHdoaWNoIGhhcyBhIGJyb2tlbiBnT1BEXG5cdH1cbn1cblxudmFyIHRocm93VHlwZUVycm9yID0gZnVuY3Rpb24gKCkge1xuXHR0aHJvdyBuZXcgJFR5cGVFcnJvcigpO1xufTtcbnZhciBUaHJvd1R5cGVFcnJvciA9ICRnT1BEXG5cdD8gKGZ1bmN0aW9uICgpIHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9ucywgbm8tY2FsbGVyLCBuby1yZXN0cmljdGVkLXByb3BlcnRpZXNcblx0XHRcdGFyZ3VtZW50cy5jYWxsZWU7IC8vIElFIDggZG9lcyBub3QgdGhyb3cgaGVyZVxuXHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdH0gY2F0Y2ggKGNhbGxlZVRocm93cykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gSUUgOCB0aHJvd3Mgb24gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhcmd1bWVudHMsICcnKVxuXHRcdFx0XHRyZXR1cm4gJGdPUEQoYXJndW1lbnRzLCAnY2FsbGVlJykuZ2V0O1xuXHRcdFx0fSBjYXRjaCAoZ09QRHRocm93cykge1xuXHRcdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCkpXG5cdDogdGhyb3dUeXBlRXJyb3I7XG5cbnZhciBoYXNTeW1ib2xzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjM2KSgpO1xudmFyIGhhc1Byb3RvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDg2KSgpO1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgKFxuXHRoYXNQcm90b1xuXHRcdD8gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguX19wcm90b19fOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG9cblx0XHQ6IG51bGxcbik7XG5cbnZhciBuZWVkc0V2YWwgPSB7fTtcblxudmFyIFR5cGVkQXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgfHwgIWdldFByb3RvID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8oVWludDhBcnJheSk7XG5cbnZhciBJTlRSSU5TSUNTID0ge1xuXHQnJUFnZ3JlZ2F0ZUVycm9yJSc6IHR5cGVvZiBBZ2dyZWdhdGVFcnJvciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBZ2dyZWdhdGVFcnJvcixcblx0JyVBcnJheSUnOiBBcnJheSxcblx0JyVBcnJheUJ1ZmZlciUnOiB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXJyYXlCdWZmZXIsXG5cdCclQXJyYXlJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzICYmIGdldFByb3RvID8gZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Zyb21TeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogdW5kZWZpbmVkLFxuXHQnJUFzeW5jRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IG5lZWRzRXZhbCxcblx0JyVBdG9taWNzJSc6IHR5cGVvZiBBdG9taWNzID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEF0b21pY3MsXG5cdCclQmlnSW50JSc6IHR5cGVvZiBCaWdJbnQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQmlnSW50LFxuXHQnJUJpZ0ludDY0QXJyYXklJzogdHlwZW9mIEJpZ0ludDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQmlnSW50NjRBcnJheSxcblx0JyVCaWdVaW50NjRBcnJheSUnOiB0eXBlb2YgQmlnVWludDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQmlnVWludDY0QXJyYXksXG5cdCclQm9vbGVhbiUnOiBCb29sZWFuLFxuXHQnJURhdGFWaWV3JSc6IHR5cGVvZiBEYXRhVmlldyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBEYXRhVmlldyxcblx0JyVEYXRlJSc6IERhdGUsXG5cdCclZGVjb2RlVVJJJSc6IGRlY29kZVVSSSxcblx0JyVkZWNvZGVVUklDb21wb25lbnQlJzogZGVjb2RlVVJJQ29tcG9uZW50LFxuXHQnJWVuY29kZVVSSSUnOiBlbmNvZGVVUkksXG5cdCclZW5jb2RlVVJJQ29tcG9uZW50JSc6IGVuY29kZVVSSUNvbXBvbmVudCxcblx0JyVFcnJvciUnOiBFcnJvcixcblx0JyVldmFsJSc6IGV2YWwsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXZhbFxuXHQnJUV2YWxFcnJvciUnOiBFdmFsRXJyb3IsXG5cdCclRmxvYXQzMkFycmF5JSc6IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQzMkFycmF5LFxuXHQnJUZsb2F0NjRBcnJheSUnOiB0eXBlb2YgRmxvYXQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0NjRBcnJheSxcblx0JyVGaW5hbGl6YXRpb25SZWdpc3RyeSUnOiB0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmluYWxpemF0aW9uUmVnaXN0cnksXG5cdCclRnVuY3Rpb24lJzogJEZ1bmN0aW9uLFxuXHQnJUdlbmVyYXRvckZ1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVJbnQ4QXJyYXklJzogdHlwZW9mIEludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQ4QXJyYXksXG5cdCclSW50MTZBcnJheSUnOiB0eXBlb2YgSW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQxNkFycmF5LFxuXHQnJUludDMyQXJyYXklJzogdHlwZW9mIEludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MzJBcnJheSxcblx0JyVpc0Zpbml0ZSUnOiBpc0Zpbml0ZSxcblx0JyVpc05hTiUnOiBpc05hTixcblx0JyVJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzICYmIGdldFByb3RvID8gZ2V0UHJvdG8oZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSkgOiB1bmRlZmluZWQsXG5cdCclSlNPTiUnOiB0eXBlb2YgSlNPTiA9PT0gJ29iamVjdCcgPyBKU09OIDogdW5kZWZpbmVkLFxuXHQnJU1hcCUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IE1hcCxcblx0JyVNYXBJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyB8fCAhZ2V0UHJvdG8gPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgTWFwKClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVNYXRoJSc6IE1hdGgsXG5cdCclTnVtYmVyJSc6IE51bWJlcixcblx0JyVPYmplY3QlJzogT2JqZWN0LFxuXHQnJXBhcnNlRmxvYXQlJzogcGFyc2VGbG9hdCxcblx0JyVwYXJzZUludCUnOiBwYXJzZUludCxcblx0JyVQcm9taXNlJSc6IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb21pc2UsXG5cdCclUHJveHklJzogdHlwZW9mIFByb3h5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb3h5LFxuXHQnJVJhbmdlRXJyb3IlJzogUmFuZ2VFcnJvcixcblx0JyVSZWZlcmVuY2VFcnJvciUnOiBSZWZlcmVuY2VFcnJvcixcblx0JyVSZWZsZWN0JSc6IHR5cGVvZiBSZWZsZWN0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFJlZmxlY3QsXG5cdCclUmVnRXhwJSc6IFJlZ0V4cCxcblx0JyVTZXQlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTZXQsXG5cdCclU2V0SXRlcmF0b3JQcm90b3R5cGUlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHMgfHwgIWdldFByb3RvID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IFNldCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXG5cdCclU2hhcmVkQXJyYXlCdWZmZXIlJzogdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNoYXJlZEFycmF5QnVmZmVyLFxuXHQnJVN0cmluZyUnOiBTdHJpbmcsXG5cdCclU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyAmJiBnZXRQcm90byA/IGdldFByb3RvKCcnW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclU3ltYm9sJSc6IGhhc1N5bWJvbHMgPyBTeW1ib2wgOiB1bmRlZmluZWQsXG5cdCclU3ludGF4RXJyb3IlJzogJFN5bnRheEVycm9yLFxuXHQnJVRocm93VHlwZUVycm9yJSc6IFRocm93VHlwZUVycm9yLFxuXHQnJVR5cGVkQXJyYXklJzogVHlwZWRBcnJheSxcblx0JyVUeXBlRXJyb3IlJzogJFR5cGVFcnJvcixcblx0JyVVaW50OEFycmF5JSc6IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4QXJyYXksXG5cdCclVWludDhDbGFtcGVkQXJyYXklJzogdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4Q2xhbXBlZEFycmF5LFxuXHQnJVVpbnQxNkFycmF5JSc6IHR5cGVvZiBVaW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MTZBcnJheSxcblx0JyVVaW50MzJBcnJheSUnOiB0eXBlb2YgVWludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDMyQXJyYXksXG5cdCclVVJJRXJyb3IlJzogVVJJRXJyb3IsXG5cdCclV2Vha01hcCUnOiB0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrTWFwLFxuXHQnJVdlYWtSZWYlJzogdHlwZW9mIFdlYWtSZWYgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1JlZixcblx0JyVXZWFrU2V0JSc6IHR5cGVvZiBXZWFrU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtTZXRcbn07XG5cbmlmIChnZXRQcm90bykge1xuXHR0cnkge1xuXHRcdG51bGwuZXJyb3I7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zaGFkb3dyZWFsbS9wdWxsLzM4NCNpc3N1ZWNvbW1lbnQtMTM2NDI2NDIyOVxuXHRcdHZhciBlcnJvclByb3RvID0gZ2V0UHJvdG8oZ2V0UHJvdG8oZSkpO1xuXHRcdElOVFJJTlNJQ1NbJyVFcnJvci5wcm90b3R5cGUlJ10gPSBlcnJvclByb3RvO1xuXHR9XG59XG5cbnZhciBkb0V2YWwgPSBmdW5jdGlvbiBkb0V2YWwobmFtZSkge1xuXHR2YXIgdmFsdWU7XG5cdGlmIChuYW1lID09PSAnJUFzeW5jRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yJScpIHtcblx0XHR2YXIgZm4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpO1xuXHRcdGlmIChmbikge1xuXHRcdFx0dmFsdWUgPSBmbi5wcm90b3R5cGU7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnKSB7XG5cdFx0dmFyIGdlbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yJScpO1xuXHRcdGlmIChnZW4gJiYgZ2V0UHJvdG8pIHtcblx0XHRcdHZhbHVlID0gZ2V0UHJvdG8oZ2VuLnByb3RvdHlwZSk7XG5cdFx0fVxuXHR9XG5cblx0SU5UUklOU0lDU1tuYW1lXSA9IHZhbHVlO1xuXG5cdHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBMRUdBQ1lfQUxJQVNFUyA9IHtcblx0JyVBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiBbJ0FycmF5QnVmZmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFycmF5UHJvdG90eXBlJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclQXJyYXlQcm90b19lbnRyaWVzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2VudHJpZXMnXSxcblx0JyVBcnJheVByb3RvX2ZvckVhY2glJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZm9yRWFjaCddLFxuXHQnJUFycmF5UHJvdG9fa2V5cyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdrZXlzJ10sXG5cdCclQXJyYXlQcm90b192YWx1ZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAndmFsdWVzJ10sXG5cdCclQXN5bmNGdW5jdGlvblByb3RvdHlwZSUnOiBbJ0FzeW5jRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclQXN5bmNHZW5lcmF0b3IlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFzeW5jR2VuZXJhdG9yUHJvdG90eXBlJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXG5cdCclQm9vbGVhblByb3RvdHlwZSUnOiBbJ0Jvb2xlYW4nLCAncHJvdG90eXBlJ10sXG5cdCclRGF0YVZpZXdQcm90b3R5cGUlJzogWydEYXRhVmlldycsICdwcm90b3R5cGUnXSxcblx0JyVEYXRlUHJvdG90eXBlJSc6IFsnRGF0ZScsICdwcm90b3R5cGUnXSxcblx0JyVFcnJvclByb3RvdHlwZSUnOiBbJ0Vycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJUV2YWxFcnJvclByb3RvdHlwZSUnOiBbJ0V2YWxFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVGbG9hdDMyQXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclRmxvYXQ2NEFycmF5UHJvdG90eXBlJSc6IFsnRmxvYXQ2NEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUZ1bmN0aW9uUHJvdG90eXBlJSc6IFsnRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclR2VuZXJhdG9yJSc6IFsnR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclR2VuZXJhdG9yUHJvdG90eXBlJSc6IFsnR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDhBcnJheVByb3RvdHlwZSUnOiBbJ0ludDhBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQxNkFycmF5UHJvdG90eXBlJSc6IFsnSW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQzMkFycmF5UHJvdG90eXBlJSc6IFsnSW50MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVKU09OUGFyc2UlJzogWydKU09OJywgJ3BhcnNlJ10sXG5cdCclSlNPTlN0cmluZ2lmeSUnOiBbJ0pTT04nLCAnc3RyaW5naWZ5J10sXG5cdCclTWFwUHJvdG90eXBlJSc6IFsnTWFwJywgJ3Byb3RvdHlwZSddLFxuXHQnJU51bWJlclByb3RvdHlwZSUnOiBbJ051bWJlcicsICdwcm90b3R5cGUnXSxcblx0JyVPYmplY3RQcm90b3R5cGUlJzogWydPYmplY3QnLCAncHJvdG90eXBlJ10sXG5cdCclT2JqUHJvdG9fdG9TdHJpbmclJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3RvU3RyaW5nJ10sXG5cdCclT2JqUHJvdG9fdmFsdWVPZiUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndmFsdWVPZiddLFxuXHQnJVByb21pc2VQcm90b3R5cGUlJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZSddLFxuXHQnJVByb21pc2VQcm90b190aGVuJSc6IFsnUHJvbWlzZScsICdwcm90b3R5cGUnLCAndGhlbiddLFxuXHQnJVByb21pc2VfYWxsJSc6IFsnUHJvbWlzZScsICdhbGwnXSxcblx0JyVQcm9taXNlX3JlamVjdCUnOiBbJ1Byb21pc2UnLCAncmVqZWN0J10sXG5cdCclUHJvbWlzZV9yZXNvbHZlJSc6IFsnUHJvbWlzZScsICdyZXNvbHZlJ10sXG5cdCclUmFuZ2VFcnJvclByb3RvdHlwZSUnOiBbJ1JhbmdlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclUmVmZXJlbmNlRXJyb3JQcm90b3R5cGUlJzogWydSZWZlcmVuY2VFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVSZWdFeHBQcm90b3R5cGUlJzogWydSZWdFeHAnLCAncHJvdG90eXBlJ10sXG5cdCclU2V0UHJvdG90eXBlJSc6IFsnU2V0JywgJ3Byb3RvdHlwZSddLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnU2hhcmVkQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXG5cdCclU3RyaW5nUHJvdG90eXBlJSc6IFsnU3RyaW5nJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN5bWJvbFByb3RvdHlwZSUnOiBbJ1N5bWJvbCcsICdwcm90b3R5cGUnXSxcblx0JyVTeW50YXhFcnJvclByb3RvdHlwZSUnOiBbJ1N5bnRheEVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVR5cGVkQXJyYXlQcm90b3R5cGUlJzogWydUeXBlZEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVR5cGVFcnJvclByb3RvdHlwZSUnOiBbJ1R5cGVFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVVaW50OEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQ4Q2xhbXBlZEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQxNkFycmF5UHJvdG90eXBlJSc6IFsnVWludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDMyQXJyYXlQcm90b3R5cGUlJzogWydVaW50MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVUklFcnJvclByb3RvdHlwZSUnOiBbJ1VSSUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVdlYWtNYXBQcm90b3R5cGUlJzogWydXZWFrTWFwJywgJ3Byb3RvdHlwZSddLFxuXHQnJVdlYWtTZXRQcm90b3R5cGUlJzogWydXZWFrU2V0JywgJ3Byb3RvdHlwZSddXG59O1xuXG52YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oNDA5MCk7XG52YXIgaGFzT3duID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMTk4KTtcbnZhciAkY29uY2F0ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIEFycmF5LnByb3RvdHlwZS5jb25jYXQpO1xudmFyICRzcGxpY2VBcHBseSA9IGJpbmQuY2FsbChGdW5jdGlvbi5hcHBseSwgQXJyYXkucHJvdG90eXBlLnNwbGljZSk7XG52YXIgJHJlcGxhY2UgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKTtcbnZhciAkc3RyU2xpY2UgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5zbGljZSk7XG52YXIgJGV4ZWMgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgUmVnRXhwLnByb3RvdHlwZS5leGVjKTtcblxuLyogYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvNC4xNy4xNS9kaXN0L2xvZGFzaC5qcyNMNjczNS1MNjc0NCAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14lLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCUkKSkvZztcbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZzsgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgc3RyaW5nVG9QYXRoID0gZnVuY3Rpb24gc3RyaW5nVG9QYXRoKHN0cmluZykge1xuXHR2YXIgZmlyc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAwLCAxKTtcblx0dmFyIGxhc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAtMSk7XG5cdGlmIChmaXJzdCA9PT0gJyUnICYmIGxhc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgY2xvc2luZyBgJWAnKTtcblx0fSBlbHNlIGlmIChsYXN0ID09PSAnJScgJiYgZmlyc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgb3BlbmluZyBgJWAnKTtcblx0fVxuXHR2YXIgcmVzdWx0ID0gW107XG5cdCRyZXBsYWNlKHN0cmluZywgcmVQcm9wTmFtZSwgZnVuY3Rpb24gKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcblx0XHRyZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBxdW90ZSA/ICRyZXBsYWNlKHN1YlN0cmluZywgcmVFc2NhcGVDaGFyLCAnJDEnKSA6IG51bWJlciB8fCBtYXRjaDtcblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuLyogZW5kIGFkYXB0YXRpb24gKi9cblxudmFyIGdldEJhc2VJbnRyaW5zaWMgPSBmdW5jdGlvbiBnZXRCYXNlSW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHR2YXIgaW50cmluc2ljTmFtZSA9IG5hbWU7XG5cdHZhciBhbGlhcztcblx0aWYgKGhhc093bihMRUdBQ1lfQUxJQVNFUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHRhbGlhcyA9IExFR0FDWV9BTElBU0VTW2ludHJpbnNpY05hbWVdO1xuXHRcdGludHJpbnNpY05hbWUgPSAnJScgKyBhbGlhc1swXSArICclJztcblx0fVxuXG5cdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHR2YXIgdmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY05hbWVdO1xuXHRcdGlmICh2YWx1ZSA9PT0gbmVlZHNFdmFsKSB7XG5cdFx0XHR2YWx1ZSA9IGRvRXZhbChpbnRyaW5zaWNOYW1lKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgJiYgIWFsbG93TWlzc2luZykge1xuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIGZpbGUgYW4gaXNzdWUhJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFsaWFzOiBhbGlhcyxcblx0XHRcdG5hbWU6IGludHJpbnNpY05hbWUsXG5cdFx0XHR2YWx1ZTogdmFsdWVcblx0XHR9O1xuXHR9XG5cblx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBkb2VzIG5vdCBleGlzdCEnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gR2V0SW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHRpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8IG5hbWUubGVuZ3RoID09PSAwKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBhbGxvd01pc3NpbmcgIT09ICdib29sZWFuJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdcImFsbG93TWlzc2luZ1wiIGFyZ3VtZW50IG11c3QgYmUgYSBib29sZWFuJyk7XG5cdH1cblxuXHRpZiAoJGV4ZWMoL14lP1teJV0qJT8kLywgbmFtZSkgPT09IG51bGwpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdgJWAgbWF5IG5vdCBiZSBwcmVzZW50IGFueXdoZXJlIGJ1dCBhdCB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgdGhlIGludHJpbnNpYyBuYW1lJyk7XG5cdH1cblx0dmFyIHBhcnRzID0gc3RyaW5nVG9QYXRoKG5hbWUpO1xuXHR2YXIgaW50cmluc2ljQmFzZU5hbWUgPSBwYXJ0cy5sZW5ndGggPiAwID8gcGFydHNbMF0gOiAnJztcblxuXHR2YXIgaW50cmluc2ljID0gZ2V0QmFzZUludHJpbnNpYygnJScgKyBpbnRyaW5zaWNCYXNlTmFtZSArICclJywgYWxsb3dNaXNzaW5nKTtcblx0dmFyIGludHJpbnNpY1JlYWxOYW1lID0gaW50cmluc2ljLm5hbWU7XG5cdHZhciB2YWx1ZSA9IGludHJpbnNpYy52YWx1ZTtcblx0dmFyIHNraXBGdXJ0aGVyQ2FjaGluZyA9IGZhbHNlO1xuXG5cdHZhciBhbGlhcyA9IGludHJpbnNpYy5hbGlhcztcblx0aWYgKGFsaWFzKSB7XG5cdFx0aW50cmluc2ljQmFzZU5hbWUgPSBhbGlhc1swXTtcblx0XHQkc3BsaWNlQXBwbHkocGFydHMsICRjb25jYXQoWzAsIDFdLCBhbGlhcykpO1xuXHR9XG5cblx0Zm9yICh2YXIgaSA9IDEsIGlzT3duID0gdHJ1ZTsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0dmFyIHBhcnQgPSBwYXJ0c1tpXTtcblx0XHR2YXIgZmlyc3QgPSAkc3RyU2xpY2UocGFydCwgMCwgMSk7XG5cdFx0dmFyIGxhc3QgPSAkc3RyU2xpY2UocGFydCwgLTEpO1xuXHRcdGlmIChcblx0XHRcdChcblx0XHRcdFx0KGZpcnN0ID09PSAnXCInIHx8IGZpcnN0ID09PSBcIidcIiB8fCBmaXJzdCA9PT0gJ2AnKVxuXHRcdFx0XHR8fCAobGFzdCA9PT0gJ1wiJyB8fCBsYXN0ID09PSBcIidcIiB8fCBsYXN0ID09PSAnYCcpXG5cdFx0XHQpXG5cdFx0XHQmJiBmaXJzdCAhPT0gbGFzdFxuXHRcdCkge1xuXHRcdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcigncHJvcGVydHkgbmFtZXMgd2l0aCBxdW90ZXMgbXVzdCBoYXZlIG1hdGNoaW5nIHF1b3RlcycpO1xuXHRcdH1cblx0XHRpZiAocGFydCA9PT0gJ2NvbnN0cnVjdG9yJyB8fCAhaXNPd24pIHtcblx0XHRcdHNraXBGdXJ0aGVyQ2FjaGluZyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aW50cmluc2ljQmFzZU5hbWUgKz0gJy4nICsgcGFydDtcblx0XHRpbnRyaW5zaWNSZWFsTmFtZSA9ICclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnO1xuXG5cdFx0aWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNSZWFsTmFtZSkpIHtcblx0XHRcdHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV07XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRpZiAoIShwYXJ0IGluIHZhbHVlKSkge1xuXHRcdFx0XHRpZiAoIWFsbG93TWlzc2luZykge1xuXHRcdFx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdiYXNlIGludHJpbnNpYyBmb3IgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IHRoZSBwcm9wZXJ0eSBpcyBub3QgYXZhaWxhYmxlLicpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2b2lkIHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdGlmICgkZ09QRCAmJiAoaSArIDEpID49IHBhcnRzLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgZGVzYyA9ICRnT1BEKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0aXNPd24gPSAhIWRlc2M7XG5cblx0XHRcdFx0Ly8gQnkgY29udmVudGlvbiwgd2hlbiBhIGRhdGEgcHJvcGVydHkgaXMgY29udmVydGVkIHRvIGFuIGFjY2Vzc29yXG5cdFx0XHRcdC8vIHByb3BlcnR5IHRvIGVtdWxhdGUgYSBkYXRhIHByb3BlcnR5IHRoYXQgZG9lcyBub3Qgc3VmZmVyIGZyb21cblx0XHRcdFx0Ly8gdGhlIG92ZXJyaWRlIG1pc3Rha2UsIHRoYXQgYWNjZXNzb3IncyBnZXR0ZXIgaXMgbWFya2VkIHdpdGhcblx0XHRcdFx0Ly8gYW4gYG9yaWdpbmFsVmFsdWVgIHByb3BlcnR5LiBIZXJlLCB3aGVuIHdlIGRldGVjdCB0aGlzLCB3ZVxuXHRcdFx0XHQvLyB1cGhvbGQgdGhlIGlsbHVzaW9uIGJ5IHByZXRlbmRpbmcgdG8gc2VlIHRoYXQgb3JpZ2luYWwgZGF0YVxuXHRcdFx0XHQvLyBwcm9wZXJ0eSwgaS5lLiwgcmV0dXJuaW5nIHRoZSB2YWx1ZSByYXRoZXIgdGhhbiB0aGUgZ2V0dGVyXG5cdFx0XHRcdC8vIGl0c2VsZi5cblx0XHRcdFx0aWYgKGlzT3duICYmICdnZXQnIGluIGRlc2MgJiYgISgnb3JpZ2luYWxWYWx1ZScgaW4gZGVzYy5nZXQpKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBkZXNjLmdldDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpc093biA9IGhhc093bih2YWx1ZSwgcGFydCk7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpc093biAmJiAhc2tpcEZ1cnRoZXJDYWNoaW5nKSB7XG5cdFx0XHRcdElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB2YWx1ZTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDMyNjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEdldEludHJpbnNpYyA9IF9fd2VicGFja19yZXF1aXJlX18oNzI4Nik7XG5cbnZhciAkZ09QRCA9IEdldEludHJpbnNpYygnJU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IlJywgdHJ1ZSk7XG5cbmlmICgkZ09QRCkge1xuXHR0cnkge1xuXHRcdCRnT1BEKFtdLCAnbGVuZ3RoJyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBnT1BEXG5cdFx0JGdPUEQgPSBudWxsO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gJGdPUEQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDExODE6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBHZXRJbnRyaW5zaWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyODYpO1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmRlZmluZVByb3BlcnR5JScsIHRydWUpO1xuXG52YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9ycyA9IGZ1bmN0aW9uIGhhc1Byb3BlcnR5RGVzY3JpcHRvcnMoKSB7XG5cdGlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0XHR0cnkge1xuXHRcdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG5oYXNQcm9wZXJ0eURlc2NyaXB0b3JzLmhhc0FycmF5TGVuZ3RoRGVmaW5lQnVnID0gZnVuY3Rpb24gaGFzQXJyYXlMZW5ndGhEZWZpbmVCdWcoKSB7XG5cdC8vIG5vZGUgdjAuNiBoYXMgYSBidWcgd2hlcmUgYXJyYXkgbGVuZ3RocyBjYW4gYmUgU2V0IGJ1dCBub3QgRGVmaW5lZFxuXHRpZiAoIWhhc1Byb3BlcnR5RGVzY3JpcHRvcnMoKSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdHRyeSB7XG5cdFx0cmV0dXJuICRkZWZpbmVQcm9wZXJ0eShbXSwgJ2xlbmd0aCcsIHsgdmFsdWU6IDEgfSkubGVuZ3RoICE9PSAxO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gSW4gRmlyZWZveCA0LTIyLCBkZWZpbmluZyBsZW5ndGggb24gYW4gYXJyYXkgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NDg2OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHRlc3QgPSB7XG5cdGZvbzoge31cbn07XG5cbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1Byb3RvKCkge1xuXHRyZXR1cm4geyBfX3Byb3RvX186IHRlc3QgfS5mb28gPT09IHRlc3QuZm9vICYmICEoeyBfX3Byb3RvX186IG51bGwgfSBpbnN0YW5jZW9mICRPYmplY3QpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjYzNjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIG9yaWdTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2w7XG52YXIgaGFzU3ltYm9sU2hhbSA9IF9fd2VicGFja19yZXF1aXJlX18oNjY3OSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzTmF0aXZlU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sKCdmb28nKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sKCdiYXInKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0cmV0dXJuIGhhc1N5bWJvbFNoYW0oKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY2Nzk6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKiBlc2xpbnQgY29tcGxleGl0eTogWzIsIDE4XSwgbWF4LXN0YXRlbWVudHM6IFsyLCAzM10gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJykgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdHZhciBvYmogPSB7fTtcblx0dmFyIHN5bSA9IFN5bWJvbCgndGVzdCcpO1xuXHR2YXIgc3ltT2JqID0gT2JqZWN0KHN5bSk7XG5cdGlmICh0eXBlb2Ygc3ltID09PSAnc3RyaW5nJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bU9iaikgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvb2JqZWN0LmFzc2lnbi9pc3N1ZXMvMTdcblx0Ly8gaWYgKHN5bSBpbnN0YW5jZW9mIFN5bWJvbCkgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzL2lzc3Vlcy80XG5cdC8vIGlmICghKHN5bU9iaiBpbnN0YW5jZW9mIFN5bWJvbCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gaWYgKHR5cGVvZiBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyBpZiAoU3RyaW5nKHN5bSkgIT09IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1WYWwgPSA0Mjtcblx0b2JqW3N5bV0gPSBzeW1WYWw7XG5cdGZvciAoc3ltIGluIG9iaikgeyByZXR1cm4gZmFsc2U7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgbm8tdW5yZWFjaGFibGUtbG9vcFxuXHRpZiAodHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaik7XG5cdGlmIChzeW1zLmxlbmd0aCAhPT0gMSB8fCBzeW1zWzBdICE9PSBzeW0pIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqLCBzeW0pKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHN5bSk7XG5cdFx0aWYgKGRlc2NyaXB0b3IudmFsdWUgIT09IHN5bVZhbCB8fCBkZXNjcmlwdG9yLmVudW1lcmFibGUgIT09IHRydWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDcyMjY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBoYXNTeW1ib2xzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Njc5KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNUb1N0cmluZ1RhZ1NoYW1zKCkge1xuXHRyZXR1cm4gaGFzU3ltYm9scygpICYmICEhU3ltYm9sLnRvU3RyaW5nVGFnO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzE5ODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwOTApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTI4NTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbmlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjYzNTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGhhc1RvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MjI2KSgpO1xudmFyIGNhbGxCb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMjY4MCk7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcblxudmFyIGlzU3RhbmRhcmRBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHRpZiAoaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0cmV0dXJuICR0b1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxudmFyIGlzTGVnYWN5QXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0aWYgKGlzU3RhbmRhcmRBcmd1bWVudHModmFsdWUpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIHZhbHVlICE9PSBudWxsICYmXG5cdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG5cdFx0dmFsdWUubGVuZ3RoID49IDAgJiZcblx0XHQkdG9TdHJpbmcodmFsdWUpICE9PSAnW29iamVjdCBBcnJheV0nICYmXG5cdFx0JHRvU3RyaW5nKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xuXG52YXIgc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA9IChmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBpc1N0YW5kYXJkQXJndW1lbnRzKGFyZ3VtZW50cyk7XG59KCkpO1xuXG5pc1N0YW5kYXJkQXJndW1lbnRzLmlzTGVnYWN5QXJndW1lbnRzID0gaXNMZWdhY3lBcmd1bWVudHM7IC8vIGZvciB0ZXN0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMgPyBpc1N0YW5kYXJkQXJndW1lbnRzIDogaXNMZWdhY3lBcmd1bWVudHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk2ODA6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgZm5Ub1N0ciA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbnZhciByZWZsZWN0QXBwbHkgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdCAhPT0gbnVsbCAmJiBSZWZsZWN0LmFwcGx5O1xudmFyIGJhZEFycmF5TGlrZTtcbnZhciBpc0NhbGxhYmxlTWFya2VyO1xuaWYgKHR5cGVvZiByZWZsZWN0QXBwbHkgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xuXHR0cnkge1xuXHRcdGJhZEFycmF5TGlrZSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2xlbmd0aCcsIHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aHJvdyBpc0NhbGxhYmxlTWFya2VyO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGlzQ2FsbGFibGVNYXJrZXIgPSB7fTtcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuXHRcdHJlZmxlY3RBcHBseShmdW5jdGlvbiAoKSB7IHRocm93IDQyOyB9LCBudWxsLCBiYWRBcnJheUxpa2UpO1xuXHR9IGNhdGNoIChfKSB7XG5cdFx0aWYgKF8gIT09IGlzQ2FsbGFibGVNYXJrZXIpIHtcblx0XHRcdHJlZmxlY3RBcHBseSA9IG51bGw7XG5cdFx0fVxuXHR9XG59IGVsc2Uge1xuXHRyZWZsZWN0QXBwbHkgPSBudWxsO1xufVxuXG52YXIgY29uc3RydWN0b3JSZWdleCA9IC9eXFxzKmNsYXNzXFxiLztcbnZhciBpc0VTNkNsYXNzRm4gPSBmdW5jdGlvbiBpc0VTNkNsYXNzRnVuY3Rpb24odmFsdWUpIHtcblx0dHJ5IHtcblx0XHR2YXIgZm5TdHIgPSBmblRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiBjb25zdHJ1Y3RvclJlZ2V4LnRlc3QoZm5TdHIpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlOyAvLyBub3QgYSBmdW5jdGlvblxuXHR9XG59O1xuXG52YXIgdHJ5RnVuY3Rpb25PYmplY3QgPSBmdW5jdGlvbiB0cnlGdW5jdGlvblRvU3RyKHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0aWYgKGlzRVM2Q2xhc3NGbih2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0Zm5Ub1N0ci5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgb2JqZWN0Q2xhc3MgPSAnW29iamVjdCBPYmplY3RdJztcbnZhciBmbkNsYXNzID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbnZhciBnZW5DbGFzcyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7XG52YXIgZGRhQ2xhc3MgPSAnW29iamVjdCBIVE1MQWxsQ29sbGVjdGlvbl0nOyAvLyBJRSAxMVxudmFyIGRkYUNsYXNzMiA9ICdbb2JqZWN0IEhUTUwgZG9jdW1lbnQuYWxsIGNsYXNzXSc7XG52YXIgZGRhQ2xhc3MzID0gJ1tvYmplY3QgSFRNTENvbGxlY3Rpb25dJzsgLy8gSUUgOS0xMFxudmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiAhIVN5bWJvbC50b1N0cmluZ1RhZzsgLy8gYmV0dGVyOiB1c2UgYGhhcy10b3N0cmluZ3RhZ2BcblxudmFyIGlzSUU2OCA9ICEoMCBpbiBbLF0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNwYXJzZS1hcnJheXMsIGNvbW1hLXNwYWNpbmdcblxudmFyIGlzRERBID0gZnVuY3Rpb24gaXNEb2N1bWVudERvdEFsbCgpIHsgcmV0dXJuIGZhbHNlOyB9O1xuaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ29iamVjdCcpIHtcblx0Ly8gRmlyZWZveCAzIGNhbm9uaWNhbGl6ZXMgRERBIHRvIHVuZGVmaW5lZCB3aGVuIGl0J3Mgbm90IGFjY2Vzc2VkIGRpcmVjdGx5XG5cdHZhciBhbGwgPSBkb2N1bWVudC5hbGw7XG5cdGlmICh0b1N0ci5jYWxsKGFsbCkgPT09IHRvU3RyLmNhbGwoZG9jdW1lbnQuYWxsKSkge1xuXHRcdGlzRERBID0gZnVuY3Rpb24gaXNEb2N1bWVudERvdEFsbCh2YWx1ZSkge1xuXHRcdFx0LyogZ2xvYmFscyBkb2N1bWVudDogZmFsc2UgKi9cblx0XHRcdC8vIGluIElFIDYtOCwgdHlwZW9mIGRvY3VtZW50LmFsbCBpcyBcIm9iamVjdFwiIGFuZCBpdCdzIHRydXRoeVxuXHRcdFx0aWYgKChpc0lFNjggfHwgIXZhbHVlKSAmJiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHZhciBzdHIgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0c3RyID09PSBkZGFDbGFzc1xuXHRcdFx0XHRcdFx0fHwgc3RyID09PSBkZGFDbGFzczJcblx0XHRcdFx0XHRcdHx8IHN0ciA9PT0gZGRhQ2xhc3MzIC8vIG9wZXJhIDEyLjE2XG5cdFx0XHRcdFx0XHR8fCBzdHIgPT09IG9iamVjdENsYXNzIC8vIElFIDYtOFxuXHRcdFx0XHRcdCkgJiYgdmFsdWUoJycpID09IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHsgLyoqLyB9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZmxlY3RBcHBseVxuXHQ/IGZ1bmN0aW9uIGlzQ2FsbGFibGUodmFsdWUpIHtcblx0XHRpZiAoaXNEREEodmFsdWUpKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0aWYgKCF2YWx1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0dHJ5IHtcblx0XHRcdHJlZmxlY3RBcHBseSh2YWx1ZSwgbnVsbCwgYmFkQXJyYXlMaWtlKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRpZiAoZSAhPT0gaXNDYWxsYWJsZU1hcmtlcikgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR9XG5cdFx0cmV0dXJuICFpc0VTNkNsYXNzRm4odmFsdWUpICYmIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKTtcblx0fVxuXHQ6IGZ1bmN0aW9uIGlzQ2FsbGFibGUodmFsdWUpIHtcblx0XHRpZiAoaXNEREEodmFsdWUpKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0aWYgKCF2YWx1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0aWYgKGhhc1RvU3RyaW5nVGFnKSB7IHJldHVybiB0cnlGdW5jdGlvbk9iamVjdCh2YWx1ZSk7IH1cblx0XHRpZiAoaXNFUzZDbGFzc0ZuKHZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR2YXIgc3RyQ2xhc3MgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0XHRpZiAoc3RyQ2xhc3MgIT09IGZuQ2xhc3MgJiYgc3RyQ2xhc3MgIT09IGdlbkNsYXNzICYmICEoL15cXFtvYmplY3QgSFRNTC8pLnRlc3Qoc3RyQ2xhc3MpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdHJldHVybiB0cnlGdW5jdGlvbk9iamVjdCh2YWx1ZSk7XG5cdH07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDMxMzg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZm5Ub1N0ciA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbnZhciBpc0ZuUmVnZXggPSAvXlxccyooPzpmdW5jdGlvbik/XFwqLztcbnZhciBoYXNUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oNzIyNikoKTtcbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBnZXRHZW5lcmF0b3JGdW5jID0gZnVuY3Rpb24gKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0dHJ5IHtcblx0XHRyZXR1cm4gRnVuY3Rpb24oJ3JldHVybiBmdW5jdGlvbiooKSB7fScpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0fVxufTtcbnZhciBHZW5lcmF0b3JGdW5jdGlvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0dlbmVyYXRvckZ1bmN0aW9uKGZuKSB7XG5cdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKGlzRm5SZWdleC50ZXN0KGZuVG9TdHIuY2FsbChmbikpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHZhciBzdHIgPSB0b1N0ci5jYWxsKGZuKTtcblx0XHRyZXR1cm4gc3RyID09PSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xuXHR9XG5cdGlmICghZ2V0UHJvdG8pIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKHR5cGVvZiBHZW5lcmF0b3JGdW5jdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR2YXIgZ2VuZXJhdG9yRnVuYyA9IGdldEdlbmVyYXRvckZ1bmMoKTtcblx0XHRHZW5lcmF0b3JGdW5jdGlvbiA9IGdlbmVyYXRvckZ1bmMgPyBnZXRQcm90byhnZW5lcmF0b3JGdW5jKSA6IGZhbHNlO1xuXHR9XG5cdHJldHVybiBnZXRQcm90byhmbikgPT09IEdlbmVyYXRvckZ1bmN0aW9uO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzA1Mzpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIuaXNuYW4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDc4Mjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGNhbGxCaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NDI5KTtcbnZhciBkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5MjYpO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwNTMpO1xudmFyIGdldFBvbHlmaWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NTUpO1xudmFyIHNoaW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzNDYpO1xuXG52YXIgcG9seWZpbGwgPSBjYWxsQmluZChnZXRQb2x5ZmlsbCgpLCBOdW1iZXIpO1xuXG4vKiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLmlzbmFuICovXG5cbmRlZmluZShwb2x5ZmlsbCwge1xuXHRnZXRQb2x5ZmlsbDogZ2V0UG9seWZpbGwsXG5cdGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvbixcblx0c2hpbTogc2hpbVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcG9seWZpbGw7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc1NTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGltcGxlbWVudGF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MDUzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQb2x5ZmlsbCgpIHtcblx0aWYgKE51bWJlci5pc05hTiAmJiBOdW1iZXIuaXNOYU4oTmFOKSAmJiAhTnVtYmVyLmlzTmFOKCdhJykpIHtcblx0XHRyZXR1cm4gTnVtYmVyLmlzTmFOO1xuXHR9XG5cdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDUzNDY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5MjYpO1xudmFyIGdldFBvbHlmaWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NTUpO1xuXG4vKiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLmlzbmFuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hpbU51bWJlcklzTmFOKCkge1xuXHR2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuXHRkZWZpbmUoTnVtYmVyLCB7IGlzTmFOOiBwb2x5ZmlsbCB9LCB7XG5cdFx0aXNOYU46IGZ1bmN0aW9uIHRlc3RJc05hTigpIHtcblx0XHRcdHJldHVybiBOdW1iZXIuaXNOYU4gIT09IHBvbHlmaWxsO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDE5ODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHdoaWNoVHlwZWRBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oMjA5NCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNUeXBlZEFycmF5KHZhbHVlKSB7XG5cdHJldHVybiAhIXdoaWNoVHlwZWRBcnJheSh2YWx1ZSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4MTY5OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIG51bWJlcklzTmFOID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzKGEsIGIpIHtcblx0aWYgKGEgPT09IDAgJiYgYiA9PT0gMCkge1xuXHRcdHJldHVybiAxIC8gYSA9PT0gMSAvIGI7XG5cdH1cblx0aWYgKGEgPT09IGIpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRpZiAobnVtYmVySXNOYU4oYSkgJiYgbnVtYmVySXNOYU4oYikpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ2Nzk6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5MjYpO1xudmFyIGNhbGxCaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NDI5KTtcblxudmFyIGltcGxlbWVudGF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MTY5KTtcbnZhciBnZXRQb2x5ZmlsbCA9IF9fd2VicGFja19yZXF1aXJlX18oODA3MCk7XG52YXIgc2hpbSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkxKTtcblxudmFyIHBvbHlmaWxsID0gY2FsbEJpbmQoZ2V0UG9seWZpbGwoKSwgT2JqZWN0KTtcblxuZGVmaW5lKHBvbHlmaWxsLCB7XG5cdGdldFBvbHlmaWxsOiBnZXRQb2x5ZmlsbCxcblx0aW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uLFxuXHRzaGltOiBzaGltXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwb2x5ZmlsbDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODA3MDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGltcGxlbWVudGF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MTY5KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQb2x5ZmlsbCgpIHtcblx0cmV0dXJuIHR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBpbXBsZW1lbnRhdGlvbjtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDE5MTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGdldFBvbHlmaWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MDcwKTtcbnZhciBkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5MjYpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1PYmplY3RJcygpIHtcblx0dmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKTtcblx0ZGVmaW5lKE9iamVjdCwgeyBpczogcG9seWZpbGwgfSwge1xuXHRcdGlzOiBmdW5jdGlvbiB0ZXN0T2JqZWN0SXMoKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmlzICE9PSBwb2x5ZmlsbDtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gcG9seWZpbGw7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1NjkxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIga2V5c1NoaW07XG5pZiAoIU9iamVjdC5rZXlzKSB7XG5cdC8vIG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltXG5cdHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXHR2YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXHR2YXIgaXNBcmdzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MDEpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGdsb2JhbC1yZXF1aXJlXG5cdHZhciBpc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXHR2YXIgaGFzRG9udEVudW1CdWcgPSAhaXNFbnVtZXJhYmxlLmNhbGwoeyB0b1N0cmluZzogbnVsbCB9LCAndG9TdHJpbmcnKTtcblx0dmFyIGhhc1Byb3RvRW51bUJ1ZyA9IGlzRW51bWVyYWJsZS5jYWxsKGZ1bmN0aW9uICgpIHt9LCAncHJvdG90eXBlJyk7XG5cdHZhciBkb250RW51bXMgPSBbXG5cdFx0J3RvU3RyaW5nJyxcblx0XHQndG9Mb2NhbGVTdHJpbmcnLFxuXHRcdCd2YWx1ZU9mJyxcblx0XHQnaGFzT3duUHJvcGVydHknLFxuXHRcdCdpc1Byb3RvdHlwZU9mJyxcblx0XHQncHJvcGVydHlJc0VudW1lcmFibGUnLFxuXHRcdCdjb25zdHJ1Y3Rvcidcblx0XTtcblx0dmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlID0gZnVuY3Rpb24gKG8pIHtcblx0XHR2YXIgY3RvciA9IG8uY29uc3RydWN0b3I7XG5cdFx0cmV0dXJuIGN0b3IgJiYgY3Rvci5wcm90b3R5cGUgPT09IG87XG5cdH07XG5cdHZhciBleGNsdWRlZEtleXMgPSB7XG5cdFx0JGFwcGxpY2F0aW9uQ2FjaGU6IHRydWUsXG5cdFx0JGNvbnNvbGU6IHRydWUsXG5cdFx0JGV4dGVybmFsOiB0cnVlLFxuXHRcdCRmcmFtZTogdHJ1ZSxcblx0XHQkZnJhbWVFbGVtZW50OiB0cnVlLFxuXHRcdCRmcmFtZXM6IHRydWUsXG5cdFx0JGlubmVySGVpZ2h0OiB0cnVlLFxuXHRcdCRpbm5lcldpZHRoOiB0cnVlLFxuXHRcdCRvbm1vemZ1bGxzY3JlZW5jaGFuZ2U6IHRydWUsXG5cdFx0JG9ubW96ZnVsbHNjcmVlbmVycm9yOiB0cnVlLFxuXHRcdCRvdXRlckhlaWdodDogdHJ1ZSxcblx0XHQkb3V0ZXJXaWR0aDogdHJ1ZSxcblx0XHQkcGFnZVhPZmZzZXQ6IHRydWUsXG5cdFx0JHBhZ2VZT2Zmc2V0OiB0cnVlLFxuXHRcdCRwYXJlbnQ6IHRydWUsXG5cdFx0JHNjcm9sbExlZnQ6IHRydWUsXG5cdFx0JHNjcm9sbFRvcDogdHJ1ZSxcblx0XHQkc2Nyb2xsWDogdHJ1ZSxcblx0XHQkc2Nyb2xsWTogdHJ1ZSxcblx0XHQkc2VsZjogdHJ1ZSxcblx0XHQkd2Via2l0SW5kZXhlZERCOiB0cnVlLFxuXHRcdCR3ZWJraXRTdG9yYWdlSW5mbzogdHJ1ZSxcblx0XHQkd2luZG93OiB0cnVlXG5cdH07XG5cdHZhciBoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcgPSAoZnVuY3Rpb24gKCkge1xuXHRcdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0Zm9yICh2YXIgayBpbiB3aW5kb3cpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICghZXhjbHVkZWRLZXlzWyckJyArIGtdICYmIGhhcy5jYWxsKHdpbmRvdywgaykgJiYgd2luZG93W2tdICE9PSBudWxsICYmIHR5cGVvZiB3aW5kb3dba10gPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKHdpbmRvd1trXSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0oKSk7XG5cdHZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kgPSBmdW5jdGlvbiAobykge1xuXHRcdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1Zykge1xuXHRcdFx0cmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG8pO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG8pO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG5cblx0a2V5c1NoaW0gPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuXHRcdHZhciBpc09iamVjdCA9IG9iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jztcblx0XHR2YXIgaXNGdW5jdGlvbiA9IHRvU3RyLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0XHR2YXIgaXNBcmd1bWVudHMgPSBpc0FyZ3Mob2JqZWN0KTtcblx0XHR2YXIgaXNTdHJpbmcgPSBpc09iamVjdCAmJiB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuXHRcdHZhciB0aGVLZXlzID0gW107XG5cblx0XHRpZiAoIWlzT2JqZWN0ICYmICFpc0Z1bmN0aW9uICYmICFpc0FyZ3VtZW50cykge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmtleXMgY2FsbGVkIG9uIGEgbm9uLW9iamVjdCcpO1xuXHRcdH1cblxuXHRcdHZhciBza2lwUHJvdG8gPSBoYXNQcm90b0VudW1CdWcgJiYgaXNGdW5jdGlvbjtcblx0XHRpZiAoaXNTdHJpbmcgJiYgb2JqZWN0Lmxlbmd0aCA+IDAgJiYgIWhhcy5jYWxsKG9iamVjdCwgMCkpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcoaSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpc0FyZ3VtZW50cyAmJiBvYmplY3QubGVuZ3RoID4gMCkge1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBvYmplY3QubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhqKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG5cdFx0XHRcdGlmICghKHNraXBQcm90byAmJiBuYW1lID09PSAncHJvdG90eXBlJykgJiYgaGFzLmNhbGwob2JqZWN0LCBuYW1lKSkge1xuXHRcdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcobmFtZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGhhc0RvbnRFbnVtQnVnKSB7XG5cdFx0XHR2YXIgc2tpcENvbnN0cnVjdG9yID0gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5KG9iamVjdCk7XG5cblx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgZG9udEVudW1zLmxlbmd0aDsgKytrKSB7XG5cdFx0XHRcdGlmICghKHNraXBDb25zdHJ1Y3RvciAmJiBkb250RW51bXNba10gPT09ICdjb25zdHJ1Y3RvcicpICYmIGhhcy5jYWxsKG9iamVjdCwgZG9udEVudW1zW2tdKSkge1xuXHRcdFx0XHRcdHRoZUtleXMucHVzaChkb250RW51bXNba10pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGVLZXlzO1xuXHR9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBrZXlzU2hpbTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzQ2NDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGlzQXJncyA9IF9fd2VicGFja19yZXF1aXJlX18oODAxKTtcblxudmFyIG9yaWdLZXlzID0gT2JqZWN0LmtleXM7XG52YXIga2V5c1NoaW0gPSBvcmlnS2V5cyA/IGZ1bmN0aW9uIGtleXMobykgeyByZXR1cm4gb3JpZ0tleXMobyk7IH0gOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2OTEpO1xuXG52YXIgb3JpZ2luYWxLZXlzID0gT2JqZWN0LmtleXM7XG5cbmtleXNTaGltLnNoaW0gPSBmdW5jdGlvbiBzaGltT2JqZWN0S2V5cygpIHtcblx0aWYgKE9iamVjdC5rZXlzKSB7XG5cdFx0dmFyIGtleXNXb3Jrc1dpdGhBcmd1bWVudHMgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gU2FmYXJpIDUuMCBidWdcblx0XHRcdHZhciBhcmdzID0gT2JqZWN0LmtleXMoYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBhcmdzICYmIGFyZ3MubGVuZ3RoID09PSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdH0oMSwgMikpO1xuXHRcdGlmICgha2V5c1dvcmtzV2l0aEFyZ3VtZW50cykge1xuXHRcdFx0T2JqZWN0LmtleXMgPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuXHRcdFx0XHRpZiAoaXNBcmdzKG9iamVjdCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxLZXlzKHNsaWNlLmNhbGwob2JqZWN0KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsS2V5cyhvYmplY3QpO1xuXHRcdFx0fTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0T2JqZWN0LmtleXMgPSBrZXlzU2hpbTtcblx0fVxuXHRyZXR1cm4gT2JqZWN0LmtleXMgfHwga2V5c1NoaW07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNTaGltO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4MDE6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdHZhciBzdHIgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0dmFyIGlzQXJncyA9IHN0ciA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cdGlmICghaXNBcmdzKSB7XG5cdFx0aXNBcmdzID0gc3RyICE9PSAnW29iamVjdCBBcnJheV0nICYmXG5cdFx0XHR2YWx1ZSAhPT0gbnVsbCAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcblx0XHRcdHZhbHVlLmxlbmd0aCA+PSAwICYmXG5cdFx0XHR0b1N0ci5jYWxsKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdH1cblx0cmV0dXJuIGlzQXJncztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ0MDY6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG4vLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NDg3OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEJhc2VTZXJ2aWNlOiAoKSA9PiAoLyogYmluZGluZyAqLyBCYXNlU2VydmljZSlcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Mjk3KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdGV4dGRvY3VtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4ODEpO1xuZnVuY3Rpb24gX2RlZmluZV9wcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuXG5cbmNsYXNzIEJhc2VTZXJ2aWNlIHtcbiAgICBhZGREb2N1bWVudChkb2N1bWVudCkge1xuICAgICAgICB0aGlzLmRvY3VtZW50c1tkb2N1bWVudC51cmldID0gdnNjb2RlX2xhbmd1YWdlc2VydmVyX3RleHRkb2N1bWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLlRleHREb2N1bWVudCAqLyAubi5jcmVhdGUoZG9jdW1lbnQudXJpLCBkb2N1bWVudC5sYW5ndWFnZUlkLCBkb2N1bWVudC52ZXJzaW9uLCBkb2N1bWVudC50ZXh0KTtcbiAgICAvL1RPRE86XG4gICAgLyppZiAob3B0aW9ucylcbiAgICAgICAgICAgIHRoaXMuc2V0U2Vzc2lvbk9wdGlvbnMoc2Vzc2lvbklELCBvcHRpb25zKTsqLyB9XG4gICAgZ2V0RG9jdW1lbnQodXJpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50c1t1cmldO1xuICAgIH1cbiAgICByZW1vdmVEb2N1bWVudChkb2N1bWVudCkge1xuICAgICAgICBkZWxldGUgdGhpcy5kb2N1bWVudHNbZG9jdW1lbnQudXJpXTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1tkb2N1bWVudC51cmldKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5vcHRpb25zW2RvY3VtZW50LnVyaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RG9jdW1lbnRWYWx1ZSh1cmkpIHtcbiAgICAgICAgdmFyIF90aGlzX2dldERvY3VtZW50O1xuICAgICAgICByZXR1cm4gKF90aGlzX2dldERvY3VtZW50ID0gdGhpcy5nZXREb2N1bWVudCh1cmkpKSA9PT0gbnVsbCB8fCBfdGhpc19nZXREb2N1bWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXNfZ2V0RG9jdW1lbnQuZ2V0VGV4dCgpO1xuICAgIH1cbiAgICBzZXRWYWx1ZShpZGVudGlmaWVyLCB2YWx1ZSkge1xuICAgICAgICBsZXQgZG9jdW1lbnQgPSB0aGlzLmdldERvY3VtZW50KGlkZW50aWZpZXIudXJpKTtcbiAgICAgICAgaWYgKGRvY3VtZW50KSB7XG4gICAgICAgICAgICBkb2N1bWVudCA9IHZzY29kZV9sYW5ndWFnZXNlcnZlcl90ZXh0ZG9jdW1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5UZXh0RG9jdW1lbnQgKi8gLm4uY3JlYXRlKGRvY3VtZW50LnVyaSwgZG9jdW1lbnQubGFuZ3VhZ2VJZCwgZG9jdW1lbnQudmVyc2lvbiwgdmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudHNbZG9jdW1lbnQudXJpXSA9IGRvY3VtZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEdsb2JhbE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLmdsb2JhbE9wdGlvbnMgPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcbiAgICB9XG4gICAgc2V0T3B0aW9ucyhzZXNzaW9uSUQsIG9wdGlvbnMsIG1lcmdlID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zW3Nlc3Npb25JRF0gPSBtZXJnZSA/ICgwLF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLm1lcmdlT2JqZWN0cyAqLyAuUE0pKG9wdGlvbnMsIHRoaXMub3B0aW9uc1tzZXNzaW9uSURdKSA6IG9wdGlvbnM7XG4gICAgfVxuICAgIGdldE9wdGlvbihzZXNzaW9uSUQsIG9wdGlvbk5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1tzZXNzaW9uSURdICYmIHRoaXMub3B0aW9uc1tzZXNzaW9uSURdW29wdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3Nlc3Npb25JRF1bb3B0aW9uTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nbG9iYWxPcHRpb25zW29wdGlvbk5hbWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGx5RGVsdGFzKGlkZW50aWZpZXIsIGRlbHRhcykge1xuICAgICAgICBsZXQgZG9jdW1lbnQgPSB0aGlzLmdldERvY3VtZW50KGlkZW50aWZpZXIudXJpKTtcbiAgICAgICAgaWYgKGRvY3VtZW50KSB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdGV4dGRvY3VtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18vKiAuVGV4dERvY3VtZW50ICovIC5uLnVwZGF0ZShkb2N1bWVudCwgZGVsdGFzLCBpZGVudGlmaWVyLnZlcnNpb24pO1xuICAgIH1cbiAgICBhc3luYyBkb0NvbXBsZXRlKGRvY3VtZW50LCBwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgZG9Ib3Zlcihkb2N1bWVudCwgcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGRvUmVzb2x2ZShpdGVtKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyBkb1ZhbGlkYXRpb24oZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBmb3JtYXQoZG9jdW1lbnQsIHJhbmdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xuICAgIH1cbiAgICBhc3luYyBwcm92aWRlU2lnbmF0dXJlSGVscChkb2N1bWVudCwgcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGZpbmREb2N1bWVudEhpZ2hsaWdodHMoZG9jdW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnNUb0ZpbHRlckRpYWdub3N0aWNzKCkge1xuICAgICAgICB2YXIgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9JZ25vcmUsIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvVHJlYXRBc1dhcm5pbmcsIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm8sIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvSWdub3JlLCBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yTWVzc2FnZXNUb1RyZWF0QXNXYXJuaW5nLCBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yTWVzc2FnZXNUb1RyZWF0QXNJbmZvO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3JDb2Rlc1RvSWdub3JlOiAoX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9JZ25vcmUgPSB0aGlzLmdsb2JhbE9wdGlvbnMuZXJyb3JDb2Rlc1RvSWdub3JlKSAhPT0gbnVsbCAmJiBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb0lnbm9yZSAhPT0gdm9pZCAwID8gX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9JZ25vcmUgOiBbXSxcbiAgICAgICAgICAgIGVycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nOiAoX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9UcmVhdEFzV2FybmluZyA9IHRoaXMuZ2xvYmFsT3B0aW9ucy5lcnJvckNvZGVzVG9UcmVhdEFzV2FybmluZykgIT09IG51bGwgJiYgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9UcmVhdEFzV2FybmluZyAhPT0gdm9pZCAwID8gX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9UcmVhdEFzV2FybmluZyA6IFtdLFxuICAgICAgICAgICAgZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm86IChfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNJbmZvID0gdGhpcy5nbG9iYWxPcHRpb25zLmVycm9yQ29kZXNUb1RyZWF0QXNJbmZvKSAhPT0gbnVsbCAmJiBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNJbmZvICE9PSB2b2lkIDAgPyBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNJbmZvIDogW10sXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2VzVG9JZ25vcmU6IChfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yTWVzc2FnZXNUb0lnbm9yZSA9IHRoaXMuZ2xvYmFsT3B0aW9ucy5lcnJvck1lc3NhZ2VzVG9JZ25vcmUpICE9PSBudWxsICYmIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvSWdub3JlICE9PSB2b2lkIDAgPyBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yTWVzc2FnZXNUb0lnbm9yZSA6IFtdLFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmc6IChfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yTWVzc2FnZXNUb1RyZWF0QXNXYXJuaW5nID0gdGhpcy5nbG9iYWxPcHRpb25zLmVycm9yTWVzc2FnZXNUb1RyZWF0QXNXYXJuaW5nKSAhPT0gbnVsbCAmJiBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yTWVzc2FnZXNUb1RyZWF0QXNXYXJuaW5nICE9PSB2b2lkIDAgPyBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yTWVzc2FnZXNUb1RyZWF0QXNXYXJuaW5nIDogW10sXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbzogKF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc0luZm8gPSB0aGlzLmdsb2JhbE9wdGlvbnMuZXJyb3JNZXNzYWdlc1RvVHJlYXRBc0luZm8pICE9PSBudWxsICYmIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc0luZm8gIT09IHZvaWQgMCA/IF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc0luZm8gOiBbXVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihtb2RlKXtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcIm1vZGVcIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcImRvY3VtZW50c1wiLCB7fSk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJvcHRpb25zXCIsIHt9KTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcImdsb2JhbE9wdGlvbnNcIiwge30pO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwic2VydmljZURhdGFcIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInNlcnZpY2VDYXBhYmlsaXRpZXNcIiwge30pO1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjI5Nzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBQTTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gbWVyZ2VPYmplY3RzKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnRzIG5vdEVtcHR5LCBtZXJnZVJhbmdlcywgY2hlY2tWYWx1ZUFnYWluc3RSZWdleHBBcnJheSAqL1xuZnVuY3Rpb24gbWVyZ2VPYmplY3RzKG9iajEsIG9iajIpIHtcbiAgICBpZiAoIW9iajEpIHJldHVybiBvYmoyO1xuICAgIGlmICghb2JqMikgcmV0dXJuIG9iajE7XG4gICAgY29uc3QgbWVyZ2VkT2JqZWN0cyA9IHtcbiAgICAgICAgLi4ub2JqMixcbiAgICAgICAgLi4ub2JqMVxuICAgIH07IC8vIEdpdmUgcHJpb3JpdHkgdG8gb2JqMSB2YWx1ZXMgYnkgc3ByZWFkaW5nIG9iajIgZmlyc3QsIHRoZW4gb2JqMVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG1lcmdlZE9iamVjdHMpKXtcbiAgICAgICAgaWYgKG9iajFba2V5XSAmJiBvYmoyW2tleV0pIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iajFba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRPYmplY3RzW2tleV0gPSBvYmoxW2tleV0uY29uY2F0KG9iajJba2V5XSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqMltrZXldKSkge1xuICAgICAgICAgICAgICAgIG1lcmdlZE9iamVjdHNba2V5XSA9IG9iajJba2V5XS5jb25jYXQob2JqMVtrZXldKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iajFba2V5XSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iajJba2V5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRPYmplY3RzW2tleV0gPSBtZXJnZU9iamVjdHMob2JqMVtrZXldLCBvYmoyW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWRPYmplY3RzO1xufVxuZnVuY3Rpb24gbm90RW1wdHkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbi8vdGFrZW4gd2l0aCBzbWFsbCBjaGFuZ2VzIGZyb20gYWNlLWNvZGVcbmZ1bmN0aW9uIG1lcmdlUmFuZ2VzKHJhbmdlcykge1xuICAgIHZhciBsaXN0ID0gcmFuZ2VzO1xuICAgIGxpc3QgPSBsaXN0LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gY29tcGFyZVBvaW50cyhhLnN0YXJ0LCBiLnN0YXJ0KTtcbiAgICB9KTtcbiAgICB2YXIgbmV4dCA9IGxpc3RbMF0sIHJhbmdlO1xuICAgIGZvcih2YXIgaSA9IDE7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgcmFuZ2UgPSBuZXh0O1xuICAgICAgICBuZXh0ID0gbGlzdFtpXTtcbiAgICAgICAgdmFyIGNtcCA9IGNvbXBhcmVQb2ludHMocmFuZ2UuZW5kLCBuZXh0LnN0YXJ0KTtcbiAgICAgICAgaWYgKGNtcCA8IDApIGNvbnRpbnVlO1xuICAgICAgICBpZiAoY21wID09IDAgJiYgIXJhbmdlLmlzRW1wdHkoKSAmJiAhbmV4dC5pc0VtcHR5KCkpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoY29tcGFyZVBvaW50cyhyYW5nZS5lbmQsIG5leHQuZW5kKSA8IDApIHtcbiAgICAgICAgICAgIHJhbmdlLmVuZC5yb3cgPSBuZXh0LmVuZC5yb3c7XG4gICAgICAgICAgICByYW5nZS5lbmQuY29sdW1uID0gbmV4dC5lbmQuY29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICBuZXh0ID0gcmFuZ2U7XG4gICAgICAgIGktLTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG59XG5mdW5jdGlvbiBjb21wYXJlUG9pbnRzKHAxLCBwMikge1xuICAgIHJldHVybiBwMS5yb3cgLSBwMi5yb3cgfHwgcDEuY29sdW1uIC0gcDIuY29sdW1uO1xufVxuZnVuY3Rpb24gY2hlY2tWYWx1ZUFnYWluc3RSZWdleHBBcnJheSh2YWx1ZSwgcmVnZXhwQXJyYXkpIHtcbiAgICBpZiAoIXJlZ2V4cEFycmF5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHJlZ2V4cEFycmF5Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgaWYgKHJlZ2V4cEFycmF5W2ldLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDgyOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDg5NTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL3V0aWwvdHlwZXMuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMTEyY2M3YzI3NTUxMjU0YWEyYjE3MDk4ZmI3NzQ4NjdmMDVlZDBkOVxuXG5cblxudmFyIGlzQXJndW1lbnRzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjM1KTtcbnZhciBpc0dlbmVyYXRvckZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMTM4KTtcbnZhciB3aGljaFR5cGVkQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwOTQpO1xudmFyIGlzVHlwZWRBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oMTk4KTtcblxuZnVuY3Rpb24gdW5jdXJyeVRoaXMoZikge1xuICByZXR1cm4gZi5jYWxsLmJpbmQoZik7XG59XG5cbnZhciBCaWdJbnRTdXBwb3J0ZWQgPSB0eXBlb2YgQmlnSW50ICE9PSAndW5kZWZpbmVkJztcbnZhciBTeW1ib2xTdXBwb3J0ZWQgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJztcblxudmFyIE9iamVjdFRvU3RyaW5nID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG5cbnZhciBudW1iZXJWYWx1ZSA9IHVuY3VycnlUaGlzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZik7XG52YXIgc3RyaW5nVmFsdWUgPSB1bmN1cnJ5VGhpcyhTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YpO1xudmFyIGJvb2xlYW5WYWx1ZSA9IHVuY3VycnlUaGlzKEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YpO1xuXG5pZiAoQmlnSW50U3VwcG9ydGVkKSB7XG4gIHZhciBiaWdJbnRWYWx1ZSA9IHVuY3VycnlUaGlzKEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZik7XG59XG5cbmlmIChTeW1ib2xTdXBwb3J0ZWQpIHtcbiAgdmFyIHN5bWJvbFZhbHVlID0gdW5jdXJyeVRoaXMoU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgcHJvdG90eXBlVmFsdWVPZikge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIHByb3RvdHlwZVZhbHVlT2YodmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0cy5pc0FyZ3VtZW50c09iamVjdCA9IGlzQXJndW1lbnRzT2JqZWN0O1xuZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gaXNHZW5lcmF0b3JGdW5jdGlvbjtcbmV4cG9ydHMuaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuXG4vLyBUYWtlbiBmcm9tIGhlcmUgYW5kIG1vZGlmaWVkIGZvciBiZXR0ZXIgYnJvd3NlciBzdXBwb3J0XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3AtaXMtcHJvbWlzZS9ibG9iL2NkYTM1YTUxM2JkYTAzZjk3N2FkNWNkZTNhMDc5ZDIzN2U4MmQ3ZWYvaW5kZXguanNcbmZ1bmN0aW9uIGlzUHJvbWlzZShpbnB1dCkge1xuXHRyZXR1cm4gKFxuXHRcdChcblx0XHRcdHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJlxuXHRcdFx0aW5wdXQgaW5zdGFuY2VvZiBQcm9taXNlXG5cdFx0KSB8fFxuXHRcdChcblx0XHRcdGlucHV0ICE9PSBudWxsICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdFx0dHlwZW9mIGlucHV0LmNhdGNoID09PSAnZnVuY3Rpb24nXG5cdFx0KVxuXHQpO1xufVxuZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIEFycmF5QnVmZmVyLmlzVmlldykge1xuICAgIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICBpc1R5cGVkQXJyYXkodmFsdWUpIHx8XG4gICAgaXNEYXRhVmlldyh2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNBcnJheUJ1ZmZlclZpZXcgPSBpc0FycmF5QnVmZmVyVmlldztcblxuXG5mdW5jdGlvbiBpc1VpbnQ4QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50OEFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50OEFycmF5ID0gaXNVaW50OEFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQ4Q2xhbXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDhDbGFtcGVkQXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQ4Q2xhbXBlZEFycmF5ID0gaXNVaW50OENsYW1wZWRBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQxNkFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50MTZBcnJheSA9IGlzVWludDE2QXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50MzJBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDMyQXJyYXkgPSBpc1VpbnQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDhBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDhBcnJheSc7XG59XG5leHBvcnRzLmlzSW50OEFycmF5ID0gaXNJbnQ4QXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDE2QXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDE2QXJyYXkgPSBpc0ludDE2QXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDMyQXJyYXkgPSBpc0ludDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzRmxvYXQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnRmxvYXQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNGbG9hdDMyQXJyYXkgPSBpc0Zsb2F0MzJBcnJheTtcblxuZnVuY3Rpb24gaXNGbG9hdDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdGbG9hdDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0Zsb2F0NjRBcnJheSA9IGlzRmxvYXQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc0JpZ0ludDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdCaWdJbnQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNCaWdJbnQ2NEFycmF5ID0gaXNCaWdJbnQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc0JpZ1VpbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnQmlnVWludDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0JpZ1VpbnQ2NEFycmF5ID0gaXNCaWdVaW50NjRBcnJheTtcblxuZnVuY3Rpb24gaXNNYXBUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBNYXBdJztcbn1cbmlzTWFwVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNNYXBUb1N0cmluZyhuZXcgTWFwKCkpXG4pO1xuXG5mdW5jdGlvbiBpc01hcCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNNYXBUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc01hcFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBNYXA7XG59XG5leHBvcnRzLmlzTWFwID0gaXNNYXA7XG5cbmZ1bmN0aW9uIGlzU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2V0XSc7XG59XG5pc1NldFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzU2V0VG9TdHJpbmcobmV3IFNldCgpKVxuKTtcbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc1NldFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzU2V0VG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNldDtcbn1cbmV4cG9ydHMuaXNTZXQgPSBpc1NldDtcblxuZnVuY3Rpb24gaXNXZWFrTWFwVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha01hcF0nO1xufVxuaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzV2Vha01hcFRvU3RyaW5nKG5ldyBXZWFrTWFwKCkpXG4pO1xuZnVuY3Rpb24gaXNXZWFrTWFwKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNXZWFrTWFwVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFdlYWtNYXA7XG59XG5leHBvcnRzLmlzV2Vha01hcCA9IGlzV2Vha01hcDtcblxuZnVuY3Rpb24gaXNXZWFrU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha1NldF0nO1xufVxuaXNXZWFrU2V0VG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFdlYWtTZXQgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzV2Vha1NldFRvU3RyaW5nKG5ldyBXZWFrU2V0KCkpXG4pO1xuZnVuY3Rpb24gaXNXZWFrU2V0KHZhbHVlKSB7XG4gIHJldHVybiBpc1dlYWtTZXRUb1N0cmluZyh2YWx1ZSk7XG59XG5leHBvcnRzLmlzV2Vha1NldCA9IGlzV2Vha1NldDtcblxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG59XG5pc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc0FycmF5QnVmZmVyVG9TdHJpbmcobmV3IEFycmF5QnVmZmVyKCkpXG4pO1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbn1cbmV4cG9ydHMuaXNBcnJheUJ1ZmZlciA9IGlzQXJyYXlCdWZmZXI7XG5cbmZ1bmN0aW9uIGlzRGF0YVZpZXdUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBEYXRhVmlld10nO1xufVxuaXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIERhdGFWaWV3ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc0RhdGFWaWV3VG9TdHJpbmcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSwgMCwgMSkpXG4pO1xuZnVuY3Rpb24gaXNEYXRhVmlldyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0RhdGFWaWV3VG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNEYXRhVmlld1RvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBEYXRhVmlldztcbn1cbmV4cG9ydHMuaXNEYXRhVmlldyA9IGlzRGF0YVZpZXc7XG5cbi8vIFN0b3JlIGEgY29weSBvZiBTaGFyZWRBcnJheUJ1ZmZlciBpbiBjYXNlIGl0J3MgZGVsZXRlZCBlbHNld2hlcmVcbnZhciBTaGFyZWRBcnJheUJ1ZmZlckNvcHkgPSB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnID8gU2hhcmVkQXJyYXlCdWZmZXIgOiB1bmRlZmluZWQ7XG5mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2hhcmVkQXJyYXlCdWZmZXJdJztcbn1cbmZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlckNvcHkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9IGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgU2hhcmVkQXJyYXlCdWZmZXJDb3B5KCkpO1xuICB9XG5cbiAgcmV0dXJuIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyQ29weTtcbn1cbmV4cG9ydHMuaXNTaGFyZWRBcnJheUJ1ZmZlciA9IGlzU2hhcmVkQXJyYXlCdWZmZXI7XG5cbmZ1bmN0aW9uIGlzQXN5bmNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXSc7XG59XG5leHBvcnRzLmlzQXN5bmNGdW5jdGlvbiA9IGlzQXN5bmNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNNYXBJdGVyYXRvcih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBNYXAgSXRlcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNNYXBJdGVyYXRvciA9IGlzTWFwSXRlcmF0b3I7XG5cbmZ1bmN0aW9uIGlzU2V0SXRlcmF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2V0IEl0ZXJhdG9yXSc7XG59XG5leHBvcnRzLmlzU2V0SXRlcmF0b3IgPSBpc1NldEl0ZXJhdG9yO1xuXG5mdW5jdGlvbiBpc0dlbmVyYXRvck9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBHZW5lcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNHZW5lcmF0b3JPYmplY3QgPSBpc0dlbmVyYXRvck9iamVjdDtcblxuZnVuY3Rpb24gaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYkFzc2VtYmx5Lk1vZHVsZV0nO1xufVxuZXhwb3J0cy5pc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUgPSBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGU7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBudW1iZXJWYWx1ZSk7XG59XG5leHBvcnRzLmlzTnVtYmVyT2JqZWN0ID0gaXNOdW1iZXJPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzdHJpbmdWYWx1ZSk7XG59XG5leHBvcnRzLmlzU3RyaW5nT2JqZWN0ID0gaXNTdHJpbmdPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgYm9vbGVhblZhbHVlKTtcbn1cbmV4cG9ydHMuaXNCb29sZWFuT2JqZWN0ID0gaXNCb29sZWFuT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0JpZ0ludE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gQmlnSW50U3VwcG9ydGVkICYmIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIGJpZ0ludFZhbHVlKTtcbn1cbmV4cG9ydHMuaXNCaWdJbnRPYmplY3QgPSBpc0JpZ0ludE9iamVjdDtcblxuZnVuY3Rpb24gaXNTeW1ib2xPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIFN5bWJvbFN1cHBvcnRlZCAmJiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzeW1ib2xWYWx1ZSk7XG59XG5leHBvcnRzLmlzU3ltYm9sT2JqZWN0ID0gaXNTeW1ib2xPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQm94ZWRQcmltaXRpdmUodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICBpc051bWJlck9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc1N0cmluZ09iamVjdCh2YWx1ZSkgfHxcbiAgICBpc0Jvb2xlYW5PYmplY3QodmFsdWUpIHx8XG4gICAgaXNCaWdJbnRPYmplY3QodmFsdWUpIHx8XG4gICAgaXNTeW1ib2xPYmplY3QodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQm94ZWRQcmltaXRpdmUgPSBpc0JveGVkUHJpbWl0aXZlO1xuXG5mdW5jdGlvbiBpc0FueUFycmF5QnVmZmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICAgIGlzQXJyYXlCdWZmZXIodmFsdWUpIHx8XG4gICAgaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNBbnlBcnJheUJ1ZmZlciA9IGlzQW55QXJyYXlCdWZmZXI7XG5cblsnaXNQcm94eScsICdpc0V4dGVybmFsJywgJ2lzTW9kdWxlTmFtZXNwYWNlT2JqZWN0J10uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG1ldGhvZCwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXRob2QgKyAnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdXNlcmxhbmQnKTtcbiAgICB9XG4gIH0pO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDMzMzU6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qIHByb3ZpZGVkIGRlcGVuZGVuY3kgKi8gdmFyIHByb2Nlc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0MDYpO1xuLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgY29uc29sZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzcxNik7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyB8fFxuICBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgZGVzY3JpcHRvcnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc2NyaXB0b3JzW2tleXNbaV1dID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVzY3JpcHRvcnM7XG4gIH07XG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52UmVnZXggPSAvXiQvO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRykge1xuICB2YXIgZGVidWdFbnYgPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHO1xuICBkZWJ1Z0VudiA9IGRlYnVnRW52LnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrPy5dL2csICdcXFxcJCYnKVxuICAgIC5yZXBsYWNlKC9cXCovZywgJy4qJylcbiAgICAucmVwbGFjZSgvLC9nLCAnJHxeJylcbiAgICAudG9VcHBlckNhc2UoKTtcbiAgZGVidWdFbnZSZWdleCA9IG5ldyBSZWdFeHAoJ14nICsgZGVidWdFbnYgKyAnJCcsICdpJyk7XG59XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKGRlYnVnRW52UmVnZXgudGVzdChzZXQpKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnNsaWNlKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmV4cG9ydHMudHlwZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4OTUpO1xuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuZXhwb3J0cy50eXBlcy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcbmV4cG9ydHMudHlwZXMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5leHBvcnRzLnR5cGVzLmlzTmF0aXZlRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Mik7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTI4NSk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG52YXIga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgPyBTeW1ib2woJ3V0aWwucHJvbWlzaWZ5LmN1c3RvbScpIDogdW5kZWZpbmVkO1xuXG5leHBvcnRzLnByb21pc2lmeSA9IGZ1bmN0aW9uIHByb21pc2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCAmJiBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdKSB7XG4gICAgdmFyIGZuID0gb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ1dGlsLnByb21pc2lmeS5jdXN0b21cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgZnVuY3Rpb24gZm4oKSB7XG4gICAgdmFyIHByb21pc2VSZXNvbHZlLCBwcm9taXNlUmVqZWN0O1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgcHJvbWlzZVJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcblxuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cbiAgICBhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgdmFsdWUpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZVJlc29sdmUodmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGZuLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoXG4gICAgZm4sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbClcbiAgKTtcbn1cblxuZXhwb3J0cy5wcm9taXNpZnkuY3VzdG9tID0ga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5T25SZWplY3RlZChyZWFzb24sIGNiKSB7XG4gIC8vIGAhcmVhc29uYCBndWFyZCBpbnNwaXJlZCBieSBibHVlYmlyZCAoUmVmOiBodHRwczovL2dvby5nbC90NUlTNk0pLlxuICAvLyBCZWNhdXNlIGBudWxsYCBpcyBhIHNwZWNpYWwgZXJyb3IgdmFsdWUgaW4gY2FsbGJhY2tzIHdoaWNoIG1lYW5zIFwibm8gZXJyb3JcbiAgLy8gb2NjdXJyZWRcIiwgd2UgZXJyb3Itd3JhcCBzbyB0aGUgY2FsbGJhY2sgY29uc3VtZXIgY2FuIGRpc3Rpbmd1aXNoIGJldHdlZW5cbiAgLy8gXCJ0aGUgcHJvbWlzZSByZWplY3RlZCB3aXRoIG51bGxcIiBvciBcInRoZSBwcm9taXNlIGZ1bGZpbGxlZCB3aXRoIHVuZGVmaW5lZFwiLlxuICBpZiAoIXJlYXNvbikge1xuICAgIHZhciBuZXdSZWFzb24gPSBuZXcgRXJyb3IoJ1Byb21pc2Ugd2FzIHJlamVjdGVkIHdpdGggYSBmYWxzeSB2YWx1ZScpO1xuICAgIG5ld1JlYXNvbi5yZWFzb24gPSByZWFzb247XG4gICAgcmVhc29uID0gbmV3UmVhc29uO1xuICB9XG4gIHJldHVybiBjYihyZWFzb24pO1xufVxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIC8vIFdlIERPIE5PVCByZXR1cm4gdGhlIHByb21pc2UgYXMgaXQgZ2l2ZXMgdGhlIHVzZXIgYSBmYWxzZSBzZW5zZSB0aGF0XG4gIC8vIHRoZSBwcm9taXNlIGlzIGFjdHVhbGx5IHNvbWVob3cgcmVsYXRlZCB0byB0aGUgY2FsbGJhY2sncyBleGVjdXRpb25cbiAgLy8gYW5kIHRoYXQgdGhlIGNhbGxiYWNrIHRocm93aW5nIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlLlxuICBmdW5jdGlvbiBjYWxsYmFja2lmaWVkKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIHZhciBtYXliZUNiID0gYXJncy5wb3AoKTtcbiAgICBpZiAodHlwZW9mIG1heWJlQ2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsYXN0IGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNiID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbWF5YmVDYi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgLy8gSW4gdHJ1ZSBub2RlIHN0eWxlIHdlIHByb2Nlc3MgdGhlIGNhbGxiYWNrIG9uIGBuZXh0VGlja2Agd2l0aCBhbGwgdGhlXG4gICAgLy8gaW1wbGljYXRpb25zIChzdGFjaywgYHVuY2F1Z2h0RXhjZXB0aW9uYCwgYGFzeW5jX2hvb2tzYClcbiAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmV0KSB7IHByb2Nlc3MubmV4dFRpY2soY2IuYmluZChudWxsLCBudWxsLCByZXQpKSB9LFxuICAgICAgICAgICAgZnVuY3Rpb24ocmVqKSB7IHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2tpZnlPblJlamVjdGVkLmJpbmQobnVsbCwgcmVqLCBjYikpIH0pO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNhbGxiYWNraWZpZWQsIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjYWxsYmFja2lmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKSk7XG4gIHJldHVybiBjYWxsYmFja2lmaWVkO1xufVxuZXhwb3J0cy5jYWxsYmFja2lmeSA9IGNhbGxiYWNraWZ5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMjAwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OTUzKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDU5NTM6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uID0gZXhwb3J0cy5Ccm93c2VyTWVzc2FnZVdyaXRlciA9IGV4cG9ydHMuQnJvd3Nlck1lc3NhZ2VSZWFkZXIgPSB2b2lkIDA7XG5jb25zdCByaWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzYzMik7XG4vLyBJbnN0YWxsIHRoZSBicm93c2VyIHJ1bnRpbWUgYWJzdHJhY3QuXG5yaWxfMS5kZWZhdWx0Lmluc3RhbGwoKTtcbmNvbnN0IGFwaV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MjQ3KTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDUyNDcpLCBleHBvcnRzKTtcbmNsYXNzIEJyb3dzZXJNZXNzYWdlUmVhZGVyIGV4dGVuZHMgYXBpXzEuQWJzdHJhY3RNZXNzYWdlUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3J0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX29uRGF0YSA9IG5ldyBhcGlfMS5FbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VMaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fb25EYXRhLmZpcmUoZXZlbnQuZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHBvcnQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXZlbnQpID0+IHRoaXMuZmlyZUVycm9yKGV2ZW50KSk7XG4gICAgICAgIHBvcnQub25tZXNzYWdlID0gdGhpcy5fbWVzc2FnZUxpc3RlbmVyO1xuICAgIH1cbiAgICBsaXN0ZW4oY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uRGF0YS5ldmVudChjYWxsYmFjayk7XG4gICAgfVxufVxuZXhwb3J0cy5Ccm93c2VyTWVzc2FnZVJlYWRlciA9IEJyb3dzZXJNZXNzYWdlUmVhZGVyO1xuY2xhc3MgQnJvd3Nlck1lc3NhZ2VXcml0ZXIgZXh0ZW5kcyBhcGlfMS5BYnN0cmFjdE1lc3NhZ2VXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHBvcnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wb3J0ID0gcG9ydDtcbiAgICAgICAgdGhpcy5lcnJvckNvdW50ID0gMDtcbiAgICAgICAgcG9ydC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIChldmVudCkgPT4gdGhpcy5maXJlRXJyb3IoZXZlbnQpKTtcbiAgICB9XG4gICAgd3JpdGUobXNnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnBvcnQucG9zdE1lc3NhZ2UobXNnKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IsIG1zZyk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUVycm9yKGVycm9yLCBtc2cpIHtcbiAgICAgICAgdGhpcy5lcnJvckNvdW50Kys7XG4gICAgICAgIHRoaXMuZmlyZUVycm9yKGVycm9yLCBtc2csIHRoaXMuZXJyb3JDb3VudCk7XG4gICAgfVxuICAgIGVuZCgpIHtcbiAgICB9XG59XG5leHBvcnRzLkJyb3dzZXJNZXNzYWdlV3JpdGVyID0gQnJvd3Nlck1lc3NhZ2VXcml0ZXI7XG5mdW5jdGlvbiBjcmVhdGVNZXNzYWdlQ29ubmVjdGlvbihyZWFkZXIsIHdyaXRlciwgbG9nZ2VyLCBvcHRpb25zKSB7XG4gICAgaWYgKGxvZ2dlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvZ2dlciA9IGFwaV8xLk51bGxMb2dnZXI7XG4gICAgfVxuICAgIGlmIChhcGlfMS5Db25uZWN0aW9uU3RyYXRlZ3kuaXMob3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsgY29ubmVjdGlvblN0cmF0ZWd5OiBvcHRpb25zIH07XG4gICAgfVxuICAgIHJldHVybiAoMCwgYXBpXzEuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24pKHJlYWRlciwgd3JpdGVyLCBsb2dnZXIsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiA9IGNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNjMyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIHByb3ZpZGVkIGRlcGVuZGVuY3kgKi8gdmFyIGNvbnNvbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3MTYpO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmNvbnN0IGFwaV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MjQ3KTtcbmNsYXNzIE1lc3NhZ2VCdWZmZXIgZXh0ZW5kcyBhcGlfMS5BYnN0cmFjdE1lc3NhZ2VCdWZmZXIge1xuICAgIGNvbnN0cnVjdG9yKGVuY29kaW5nID0gJ3V0Zi04Jykge1xuICAgICAgICBzdXBlcihlbmNvZGluZyk7XG4gICAgICAgIHRoaXMuYXNjaWlEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCdhc2NpaScpO1xuICAgIH1cbiAgICBlbXB0eUJ1ZmZlcigpIHtcbiAgICAgICAgcmV0dXJuIE1lc3NhZ2VCdWZmZXIuZW1wdHlCdWZmZXI7XG4gICAgfVxuICAgIGZyb21TdHJpbmcodmFsdWUsIF9lbmNvZGluZykge1xuICAgICAgICByZXR1cm4gKG5ldyBUZXh0RW5jb2RlcigpKS5lbmNvZGUodmFsdWUpO1xuICAgIH1cbiAgICB0b1N0cmluZyh2YWx1ZSwgZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAnYXNjaWknKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hc2NpaURlY29kZXIuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAobmV3IFRleHREZWNvZGVyKGVuY29kaW5nKSkuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc05hdGl2ZShidWZmZXIsIGxlbmd0aCkge1xuICAgICAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWxsb2NOYXRpdmUobGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIH1cbn1cbk1lc3NhZ2VCdWZmZXIuZW1wdHlCdWZmZXIgPSBuZXcgVWludDhBcnJheSgwKTtcbmNsYXNzIFJlYWRhYmxlU3RyZWFtV3JhcHBlciB7XG4gICAgY29uc3RydWN0b3Ioc29ja2V0KSB7XG4gICAgICAgIHRoaXMuc29ja2V0ID0gc29ja2V0O1xuICAgICAgICB0aGlzLl9vbkRhdGEgPSBuZXcgYXBpXzEuRW1pdHRlcigpO1xuICAgICAgICB0aGlzLl9tZXNzYWdlTGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgYmxvYi5hcnJheUJ1ZmZlcigpLnRoZW4oKGJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRGF0YS5maXJlKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpO1xuICAgICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICgwLCBhcGlfMS5SQUwpKCkuY29uc29sZS5lcnJvcihgQ29udmVydGluZyBibG9iIHRvIGFycmF5IGJ1ZmZlciBmYWlsZWQuYCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuX21lc3NhZ2VMaXN0ZW5lcik7XG4gICAgfVxuICAgIG9uQ2xvc2UobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBhcGlfMS5EaXNwb3NhYmxlLmNyZWF0ZSgoKSA9PiB0aGlzLnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbG9zZScsIGxpc3RlbmVyKSk7XG4gICAgfVxuICAgIG9uRXJyb3IobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBhcGlfMS5EaXNwb3NhYmxlLmNyZWF0ZSgoKSA9PiB0aGlzLnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGxpc3RlbmVyKSk7XG4gICAgfVxuICAgIG9uRW5kKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2VuZCcsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGFwaV8xLkRpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHRoaXMuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZCcsIGxpc3RlbmVyKSk7XG4gICAgfVxuICAgIG9uRGF0YShsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fb25EYXRhLmV2ZW50KGxpc3RlbmVyKTtcbiAgICB9XG59XG5jbGFzcyBXcml0YWJsZVN0cmVhbVdyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKHNvY2tldCkge1xuICAgICAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgICB9XG4gICAgb25DbG9zZShsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGFwaV8xLkRpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHRoaXMuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgb25FcnJvcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGFwaV8xLkRpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHRoaXMuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgb25FbmQobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZW5kJywgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gYXBpXzEuRGlzcG9zYWJsZS5jcmVhdGUoKCkgPT4gdGhpcy5zb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgd3JpdGUoZGF0YSwgZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgZW5jb2RpbmcgIT09ICd1dGYtOCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluIGEgQnJvd3NlciBlbnZpcm9ubWVudHMgb25seSB1dGYtOCB0ZXh0IGVuY29kaW5nIGlzIHN1cHBvcnRlZC4gQnV0IGdvdCBlbmNvZGluZzogJHtlbmNvZGluZ31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5zZW5kKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZW5kKCkge1xuICAgICAgICB0aGlzLnNvY2tldC5jbG9zZSgpO1xuICAgIH1cbn1cbmNvbnN0IF90ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgX3JpbCA9IE9iamVjdC5mcmVlemUoe1xuICAgIG1lc3NhZ2VCdWZmZXI6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBjcmVhdGU6IChlbmNvZGluZykgPT4gbmV3IE1lc3NhZ2VCdWZmZXIoZW5jb2RpbmcpXG4gICAgfSksXG4gICAgYXBwbGljYXRpb25Kc29uOiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgZW5jb2RlcjogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICBuYW1lOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICBlbmNvZGU6IChtc2csIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jaGFyc2V0ICE9PSAndXRmLTgnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW4gYSBCcm93c2VyIGVudmlyb25tZW50cyBvbmx5IHV0Zi04IHRleHQgZW5jb2RpbmcgaXMgc3VwcG9ydGVkLiBCdXQgZ290IGVuY29kaW5nOiAke29wdGlvbnMuY2hhcnNldH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShfdGV4dEVuY29kZXIuZW5jb2RlKEpTT04uc3RyaW5naWZ5KG1zZywgdW5kZWZpbmVkLCAwKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgZGVjb2RlcjogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICBuYW1lOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICBkZWNvZGU6IChidWZmZXIsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIShidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluIGEgQnJvd3NlciBlbnZpcm9ubWVudHMgb25seSBVaW50OEFycmF5cyBhcmUgc3VwcG9ydGVkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKEpTT04ucGFyc2UobmV3IFRleHREZWNvZGVyKG9wdGlvbnMuY2hhcnNldCkuZGVjb2RlKGJ1ZmZlcikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9KSxcbiAgICBzdHJlYW06IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBhc1JlYWRhYmxlU3RyZWFtOiAoc29ja2V0KSA9PiBuZXcgUmVhZGFibGVTdHJlYW1XcmFwcGVyKHNvY2tldCksXG4gICAgICAgIGFzV3JpdGFibGVTdHJlYW06IChzb2NrZXQpID0+IG5ldyBXcml0YWJsZVN0cmVhbVdyYXBwZXIoc29ja2V0KVxuICAgIH0pLFxuICAgIGNvbnNvbGU6IGNvbnNvbGUsXG4gICAgdGltZXI6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCBtcywgLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dChjYWxsYmFjaywgbXMsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZGlzcG9zZTogKCkgPT4gY2xlYXJUaW1lb3V0KGhhbmRsZSkgfTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KGNhbGxiYWNrLCAwLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB7IGRpc3Bvc2U6ICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpIH07XG4gICAgICAgIH0sXG4gICAgICAgIHNldEludGVydmFsKGNhbGxiYWNrLCBtcywgLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0SW50ZXJ2YWwoY2FsbGJhY2ssIG1zLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB7IGRpc3Bvc2U6ICgpID0+IGNsZWFySW50ZXJ2YWwoaGFuZGxlKSB9O1xuICAgICAgICB9LFxuICAgIH0pXG59KTtcbmZ1bmN0aW9uIFJJTCgpIHtcbiAgICByZXR1cm4gX3JpbDtcbn1cbihmdW5jdGlvbiAoUklMKSB7XG4gICAgZnVuY3Rpb24gaW5zdGFsbCgpIHtcbiAgICAgICAgYXBpXzEuUkFMLmluc3RhbGwoX3JpbCk7XG4gICAgfVxuICAgIFJJTC5pbnN0YWxsID0gaW5zdGFsbDtcbn0pKFJJTCB8fCAoUklMID0ge30pKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUklMO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MjQ3OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uL3R5cGluZ3MvdGhlbmFibGUuZC50c1wiIC8+XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuUHJvZ3Jlc3NUeXBlID0gZXhwb3J0cy5Qcm9ncmVzc1Rva2VuID0gZXhwb3J0cy5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiA9IGV4cG9ydHMuTnVsbExvZ2dlciA9IGV4cG9ydHMuQ29ubmVjdGlvbk9wdGlvbnMgPSBleHBvcnRzLkNvbm5lY3Rpb25TdHJhdGVneSA9IGV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlQnVmZmVyID0gZXhwb3J0cy5Xcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyID0gZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLk1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLlJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlciA9IGV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5NZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5TaGFyZWRBcnJheVJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLlNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblRva2VuID0gZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSA9IGV4cG9ydHMuRW1pdHRlciA9IGV4cG9ydHMuRXZlbnQgPSBleHBvcnRzLkRpc3Bvc2FibGUgPSBleHBvcnRzLkxSVUNhY2hlID0gZXhwb3J0cy5Ub3VjaCA9IGV4cG9ydHMuTGlua2VkTWFwID0gZXhwb3J0cy5QYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlOSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTggPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU3ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNiA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTUgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU0ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMyA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTIgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUxID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMCA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZSA9IGV4cG9ydHMuRXJyb3JDb2RlcyA9IGV4cG9ydHMuUmVzcG9uc2VFcnJvciA9IGV4cG9ydHMuUmVxdWVzdFR5cGU5ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTggPSBleHBvcnRzLlJlcXVlc3RUeXBlNyA9IGV4cG9ydHMuUmVxdWVzdFR5cGU2ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTUgPSBleHBvcnRzLlJlcXVlc3RUeXBlNCA9IGV4cG9ydHMuUmVxdWVzdFR5cGUzID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTIgPSBleHBvcnRzLlJlcXVlc3RUeXBlMSA9IGV4cG9ydHMuUmVxdWVzdFR5cGUwID0gZXhwb3J0cy5SZXF1ZXN0VHlwZSA9IGV4cG9ydHMuTWVzc2FnZSA9IGV4cG9ydHMuUkFMID0gdm9pZCAwO1xuZXhwb3J0cy5NZXNzYWdlU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSA9IGV4cG9ydHMuQ29ubmVjdGlvbkVycm9yID0gZXhwb3J0cy5Db25uZWN0aW9uRXJyb3JzID0gZXhwb3J0cy5Mb2dUcmFjZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuU2V0VHJhY2VOb3RpZmljYXRpb24gPSBleHBvcnRzLlRyYWNlRm9ybWF0ID0gZXhwb3J0cy5UcmFjZVZhbHVlcyA9IGV4cG9ydHMuVHJhY2UgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MTQxKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lc3NhZ2VcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk1lc3NhZ2U7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLlJlcXVlc3RUeXBlOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlMFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGUwOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlMVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGUxOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlMlwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGUyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlM1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGUzOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlNFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlNVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU1OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlNlwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU2OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlN1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU3OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlOFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU4OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlOVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlc3BvbnNlRXJyb3JcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3I7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXJyb3JDb2Rlc1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuRXJyb3JDb2RlczsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGUwXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlMDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlMVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTE7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGUzXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlMzsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlNFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU1OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGU2XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlNjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlN1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTc7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZThcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU4OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGU5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlOTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQYXJhbWV0ZXJTdHJ1Y3R1cmVzXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzOyB9IH0pKTtcbmNvbnN0IGxpbmtlZE1hcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MDQwKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxpbmtlZE1hcFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpbmtlZE1hcF8xLkxpbmtlZE1hcDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMUlVDYWNoZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpbmtlZE1hcF8xLkxSVUNhY2hlOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRvdWNoXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGlua2VkTWFwXzEuVG91Y2g7IH0gfSkpO1xuY29uc3QgZGlzcG9zYWJsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDM3KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpc3Bvc2FibGVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkaXNwb3NhYmxlXzEuRGlzcG9zYWJsZTsgfSB9KSk7XG5jb25zdCBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTE2NSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdmVudFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV2ZW50c18xLkV2ZW50OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVtaXR0ZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldmVudHNfMS5FbWl0dGVyOyB9IH0pKTtcbmNvbnN0IGNhbmNlbGxhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MTUpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2VcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYW5jZWxsYXRpb25fMS5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYW5jZWxsYXRpb25Ub2tlblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbmNlbGxhdGlvbl8xLkNhbmNlbGxhdGlvblRva2VuOyB9IH0pKTtcbmNvbnN0IHNoYXJlZEFycmF5Q2FuY2VsbGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3OCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTaGFyZWRBcnJheVNlbmRlclN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhcmVkQXJyYXlDYW5jZWxsYXRpb25fMS5TaGFyZWRBcnJheVNlbmRlclN0cmF0ZWd5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNoYXJlZEFycmF5UmVjZWl2ZXJTdHJhdGVneVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNoYXJlZEFycmF5Q2FuY2VsbGF0aW9uXzEuU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5OyB9IH0pKTtcbmNvbnN0IG1lc3NhZ2VSZWFkZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDUxKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lc3NhZ2VSZWFkZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlUmVhZGVyXzEuTWVzc2FnZVJlYWRlcjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBYnN0cmFjdE1lc3NhZ2VSZWFkZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlUmVhZGVyXzEuQWJzdHJhY3RNZXNzYWdlUmVhZGVyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VSZWFkZXJfMS5SZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXI7IH0gfSkpO1xuY29uc3QgbWVzc2FnZVdyaXRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjUxKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lc3NhZ2VXcml0ZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlV3JpdGVyXzEuTWVzc2FnZVdyaXRlcjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBYnN0cmFjdE1lc3NhZ2VXcml0ZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlV3JpdGVyXzEuQWJzdHJhY3RNZXNzYWdlV3JpdGVyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldyaXRlYWJsZVN0cmVhbU1lc3NhZ2VXcml0ZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlV3JpdGVyXzEuV3JpdGVhYmxlU3RyZWFtTWVzc2FnZVdyaXRlcjsgfSB9KSk7XG5jb25zdCBtZXNzYWdlQnVmZmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg2NTIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWJzdHJhY3RNZXNzYWdlQnVmZmVyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZUJ1ZmZlcl8xLkFic3RyYWN0TWVzc2FnZUJ1ZmZlcjsgfSB9KSk7XG5jb25zdCBjb25uZWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5MDgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29ubmVjdGlvblN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNvbm5lY3Rpb25TdHJhdGVneTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb25uZWN0aW9uT3B0aW9uc1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Db25uZWN0aW9uT3B0aW9uczsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOdWxsTG9nZ2VyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLk51bGxMb2dnZXI7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb247IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUHJvZ3Jlc3NUb2tlblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Qcm9ncmVzc1Rva2VuOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlByb2dyZXNzVHlwZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Qcm9ncmVzc1R5cGU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhY2VcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuVHJhY2U7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhY2VWYWx1ZXNcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuVHJhY2VWYWx1ZXM7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhY2VGb3JtYXRcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuVHJhY2VGb3JtYXQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2V0VHJhY2VOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuU2V0VHJhY2VOb3RpZmljYXRpb247IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTG9nVHJhY2VOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuTG9nVHJhY2VOb3RpZmljYXRpb247IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29ubmVjdGlvbkVycm9yc1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Db25uZWN0aW9uRXJyb3JzOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbm5lY3Rpb25FcnJvclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Db25uZWN0aW9uRXJyb3I7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5DYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbmNlbGxhdGlvblN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNhbmNlbGxhdGlvblN0cmF0ZWd5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lc3NhZ2VTdHJhdGVneVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5NZXNzYWdlU3RyYXRlZ3k7IH0gfSkpO1xuY29uc3QgcmFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3MDYpO1xuZXhwb3J0cy5SQUwgPSByYWxfMS5kZWZhdWx0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MTU6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW4gPSB2b2lkIDA7XG5jb25zdCByYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTcwNik7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oODgxMSk7XG5jb25zdCBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTE2NSk7XG52YXIgQ2FuY2VsbGF0aW9uVG9rZW47XG4oZnVuY3Rpb24gKENhbmNlbGxhdGlvblRva2VuKSB7XG4gICAgQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBpc0NhbmNlbGxhdGlvblJlcXVlc3RlZDogZmFsc2UsXG4gICAgICAgIG9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkOiBldmVudHNfMS5FdmVudC5Ob25lXG4gICAgfSk7XG4gICAgQ2FuY2VsbGF0aW9uVG9rZW4uQ2FuY2VsbGVkID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIGlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkOiB0cnVlLFxuICAgICAgICBvbkNhbmNlbGxhdGlvblJlcXVlc3RlZDogZXZlbnRzXzEuRXZlbnQuTm9uZVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIChjYW5kaWRhdGUgPT09IENhbmNlbGxhdGlvblRva2VuLk5vbmVcbiAgICAgICAgICAgIHx8IGNhbmRpZGF0ZSA9PT0gQ2FuY2VsbGF0aW9uVG9rZW4uQ2FuY2VsbGVkXG4gICAgICAgICAgICB8fCAoSXMuYm9vbGVhbihjYW5kaWRhdGUuaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQpICYmICEhY2FuZGlkYXRlLm9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKSk7XG4gICAgfVxuICAgIENhbmNlbGxhdGlvblRva2VuLmlzID0gaXM7XG59KShDYW5jZWxsYXRpb25Ub2tlbiA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW4gfHwgKGV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW4gPSB7fSkpO1xuY29uc3Qgc2hvcnRjdXRFdmVudCA9IE9iamVjdC5mcmVlemUoZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgY29uc3QgaGFuZGxlID0gKDAsIHJhbF8xLmRlZmF1bHQpKCkudGltZXIuc2V0VGltZW91dChjYWxsYmFjay5iaW5kKGNvbnRleHQpLCAwKTtcbiAgICByZXR1cm4geyBkaXNwb3NlKCkgeyBoYW5kbGUuZGlzcG9zZSgpOyB9IH07XG59KTtcbmNsYXNzIE11dGFibGVUb2tlbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0NhbmNlbGxlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0NhbmNlbGxlZDtcbiAgICB9XG4gICAgZ2V0IG9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCkge1xuICAgICAgICBpZiAodGhpcy5faXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzaG9ydGN1dEV2ZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZW1pdHRlcikge1xuICAgICAgICAgICAgdGhpcy5fZW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9lbWl0dGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2VtaXR0ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSB7XG4gICAgZ2V0IHRva2VuKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Rva2VuKSB7XG4gICAgICAgICAgICAvLyBiZSBsYXp5IGFuZCBjcmVhdGUgdGhlIHRva2VuIG9ubHkgd2hlblxuICAgICAgICAgICAgLy8gYWN0dWFsbHkgbmVlZGVkXG4gICAgICAgICAgICB0aGlzLl90b2tlbiA9IG5ldyBNdXRhYmxlVG9rZW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW47XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90b2tlbikge1xuICAgICAgICAgICAgLy8gc2F2ZSBhbiBvYmplY3QgYnkgcmV0dXJuaW5nIHRoZSBkZWZhdWx0XG4gICAgICAgICAgICAvLyBjYW5jZWxsZWQgdG9rZW4gd2hlbiBjYW5jZWxsYXRpb24gaGFwcGVuc1xuICAgICAgICAgICAgLy8gYmVmb3JlIHNvbWVvbmUgYXNrcyBmb3IgdGhlIHRva2VuXG4gICAgICAgICAgICB0aGlzLl90b2tlbiA9IENhbmNlbGxhdGlvblRva2VuLkNhbmNlbGxlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdG9rZW4pIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSB0byBpbml0aWFsaXplIHdpdGggYW4gZW1wdHkgdG9rZW4gaWYgd2UgaGFkIG5vbmVcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl90b2tlbiBpbnN0YW5jZW9mIE11dGFibGVUb2tlbikge1xuICAgICAgICAgICAgLy8gYWN0dWFsbHkgZGlzcG9zZVxuICAgICAgICAgICAgdGhpcy5fdG9rZW4uZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSA9IENhbmNlbGxhdGlvblRva2VuU291cmNlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxOTA4OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uID0gZXhwb3J0cy5Db25uZWN0aW9uT3B0aW9ucyA9IGV4cG9ydHMuTWVzc2FnZVN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25TdHJhdGVneSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLlJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0gZXhwb3J0cy5JZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLkNvbm5lY3Rpb25TdHJhdGVneSA9IGV4cG9ydHMuQ29ubmVjdGlvbkVycm9yID0gZXhwb3J0cy5Db25uZWN0aW9uRXJyb3JzID0gZXhwb3J0cy5Mb2dUcmFjZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuU2V0VHJhY2VOb3RpZmljYXRpb24gPSBleHBvcnRzLlRyYWNlRm9ybWF0ID0gZXhwb3J0cy5UcmFjZVZhbHVlcyA9IGV4cG9ydHMuVHJhY2UgPSBleHBvcnRzLk51bGxMb2dnZXIgPSBleHBvcnRzLlByb2dyZXNzVHlwZSA9IGV4cG9ydHMuUHJvZ3Jlc3NUb2tlbiA9IHZvaWQgMDtcbmNvbnN0IHJhbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NzA2KTtcbmNvbnN0IElzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4ODExKTtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxNDEpO1xuY29uc3QgbGlua2VkTWFwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwNDApO1xuY29uc3QgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxNjUpO1xuY29uc3QgY2FuY2VsbGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxNSk7XG52YXIgQ2FuY2VsTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChDYW5jZWxOb3RpZmljYXRpb24pIHtcbiAgICBDYW5jZWxOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUoJyQvY2FuY2VsUmVxdWVzdCcpO1xufSkoQ2FuY2VsTm90aWZpY2F0aW9uIHx8IChDYW5jZWxOb3RpZmljYXRpb24gPSB7fSkpO1xudmFyIFByb2dyZXNzVG9rZW47XG4oZnVuY3Rpb24gKFByb2dyZXNzVG9rZW4pIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xuICAgIH1cbiAgICBQcm9ncmVzc1Rva2VuLmlzID0gaXM7XG59KShQcm9ncmVzc1Rva2VuID0gZXhwb3J0cy5Qcm9ncmVzc1Rva2VuIHx8IChleHBvcnRzLlByb2dyZXNzVG9rZW4gPSB7fSkpO1xudmFyIFByb2dyZXNzTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChQcm9ncmVzc05vdGlmaWNhdGlvbikge1xuICAgIFByb2dyZXNzTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlKCckL3Byb2dyZXNzJyk7XG59KShQcm9ncmVzc05vdGlmaWNhdGlvbiB8fCAoUHJvZ3Jlc3NOb3RpZmljYXRpb24gPSB7fSkpO1xuY2xhc3MgUHJvZ3Jlc3NUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICB9XG59XG5leHBvcnRzLlByb2dyZXNzVHlwZSA9IFByb2dyZXNzVHlwZTtcbnZhciBTdGFyUmVxdWVzdEhhbmRsZXI7XG4oZnVuY3Rpb24gKFN0YXJSZXF1ZXN0SGFuZGxlcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBJcy5mdW5jKHZhbHVlKTtcbiAgICB9XG4gICAgU3RhclJlcXVlc3RIYW5kbGVyLmlzID0gaXM7XG59KShTdGFyUmVxdWVzdEhhbmRsZXIgfHwgKFN0YXJSZXF1ZXN0SGFuZGxlciA9IHt9KSk7XG5leHBvcnRzLk51bGxMb2dnZXIgPSBPYmplY3QuZnJlZXplKHtcbiAgICBlcnJvcjogKCkgPT4geyB9LFxuICAgIHdhcm46ICgpID0+IHsgfSxcbiAgICBpbmZvOiAoKSA9PiB7IH0sXG4gICAgbG9nOiAoKSA9PiB7IH1cbn0pO1xudmFyIFRyYWNlO1xuKGZ1bmN0aW9uIChUcmFjZSkge1xuICAgIFRyYWNlW1RyYWNlW1wiT2ZmXCJdID0gMF0gPSBcIk9mZlwiO1xuICAgIFRyYWNlW1RyYWNlW1wiTWVzc2FnZXNcIl0gPSAxXSA9IFwiTWVzc2FnZXNcIjtcbiAgICBUcmFjZVtUcmFjZVtcIkNvbXBhY3RcIl0gPSAyXSA9IFwiQ29tcGFjdFwiO1xuICAgIFRyYWNlW1RyYWNlW1wiVmVyYm9zZVwiXSA9IDNdID0gXCJWZXJib3NlXCI7XG59KShUcmFjZSA9IGV4cG9ydHMuVHJhY2UgfHwgKGV4cG9ydHMuVHJhY2UgPSB7fSkpO1xudmFyIFRyYWNlVmFsdWVzO1xuKGZ1bmN0aW9uIChUcmFjZVZhbHVlcykge1xuICAgIC8qKlxuICAgICAqIFR1cm4gdHJhY2luZyBvZmYuXG4gICAgICovXG4gICAgVHJhY2VWYWx1ZXMuT2ZmID0gJ29mZic7XG4gICAgLyoqXG4gICAgICogVHJhY2UgbWVzc2FnZXMgb25seS5cbiAgICAgKi9cbiAgICBUcmFjZVZhbHVlcy5NZXNzYWdlcyA9ICdtZXNzYWdlcyc7XG4gICAgLyoqXG4gICAgICogQ29tcGFjdCBtZXNzYWdlIHRyYWNpbmcuXG4gICAgICovXG4gICAgVHJhY2VWYWx1ZXMuQ29tcGFjdCA9ICdjb21wYWN0JztcbiAgICAvKipcbiAgICAgKiBWZXJib3NlIG1lc3NhZ2UgdHJhY2luZy5cbiAgICAgKi9cbiAgICBUcmFjZVZhbHVlcy5WZXJib3NlID0gJ3ZlcmJvc2UnO1xufSkoVHJhY2VWYWx1ZXMgPSBleHBvcnRzLlRyYWNlVmFsdWVzIHx8IChleHBvcnRzLlRyYWNlVmFsdWVzID0ge30pKTtcbihmdW5jdGlvbiAoVHJhY2UpIHtcbiAgICBmdW5jdGlvbiBmcm9tU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGlmICghSXMuc3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFRyYWNlLk9mZjtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ29mZic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYWNlLk9mZjtcbiAgICAgICAgICAgIGNhc2UgJ21lc3NhZ2VzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhY2UuTWVzc2FnZXM7XG4gICAgICAgICAgICBjYXNlICdjb21wYWN0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhY2UuQ29tcGFjdDtcbiAgICAgICAgICAgIGNhc2UgJ3ZlcmJvc2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBUcmFjZS5WZXJib3NlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhY2UuT2ZmO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRyYWNlLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgVHJhY2UuT2ZmOlxuICAgICAgICAgICAgICAgIHJldHVybiAnb2ZmJztcbiAgICAgICAgICAgIGNhc2UgVHJhY2UuTWVzc2FnZXM6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdtZXNzYWdlcyc7XG4gICAgICAgICAgICBjYXNlIFRyYWNlLkNvbXBhY3Q6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdjb21wYWN0JztcbiAgICAgICAgICAgIGNhc2UgVHJhY2UuVmVyYm9zZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3ZlcmJvc2UnO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ29mZic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVHJhY2UudG9TdHJpbmcgPSB0b1N0cmluZztcbn0pKFRyYWNlID0gZXhwb3J0cy5UcmFjZSB8fCAoZXhwb3J0cy5UcmFjZSA9IHt9KSk7XG52YXIgVHJhY2VGb3JtYXQ7XG4oZnVuY3Rpb24gKFRyYWNlRm9ybWF0KSB7XG4gICAgVHJhY2VGb3JtYXRbXCJUZXh0XCJdID0gXCJ0ZXh0XCI7XG4gICAgVHJhY2VGb3JtYXRbXCJKU09OXCJdID0gXCJqc29uXCI7XG59KShUcmFjZUZvcm1hdCA9IGV4cG9ydHMuVHJhY2VGb3JtYXQgfHwgKGV4cG9ydHMuVHJhY2VGb3JtYXQgPSB7fSkpO1xuKGZ1bmN0aW9uIChUcmFjZUZvcm1hdCkge1xuICAgIGZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgaWYgKCFJcy5zdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gVHJhY2VGb3JtYXQuVGV4dDtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJ2pzb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gVHJhY2VGb3JtYXQuSlNPTjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBUcmFjZUZvcm1hdC5UZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIFRyYWNlRm9ybWF0LmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xufSkoVHJhY2VGb3JtYXQgPSBleHBvcnRzLlRyYWNlRm9ybWF0IHx8IChleHBvcnRzLlRyYWNlRm9ybWF0ID0ge30pKTtcbnZhciBTZXRUcmFjZU5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoU2V0VHJhY2VOb3RpZmljYXRpb24pIHtcbiAgICBTZXRUcmFjZU5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZSgnJC9zZXRUcmFjZScpO1xufSkoU2V0VHJhY2VOb3RpZmljYXRpb24gPSBleHBvcnRzLlNldFRyYWNlTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLlNldFRyYWNlTm90aWZpY2F0aW9uID0ge30pKTtcbnZhciBMb2dUcmFjZU5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoTG9nVHJhY2VOb3RpZmljYXRpb24pIHtcbiAgICBMb2dUcmFjZU5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZSgnJC9sb2dUcmFjZScpO1xufSkoTG9nVHJhY2VOb3RpZmljYXRpb24gPSBleHBvcnRzLkxvZ1RyYWNlTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkxvZ1RyYWNlTm90aWZpY2F0aW9uID0ge30pKTtcbnZhciBDb25uZWN0aW9uRXJyb3JzO1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uRXJyb3JzKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbm5lY3Rpb24gaXMgY2xvc2VkLlxuICAgICAqL1xuICAgIENvbm5lY3Rpb25FcnJvcnNbQ29ubmVjdGlvbkVycm9yc1tcIkNsb3NlZFwiXSA9IDFdID0gXCJDbG9zZWRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgY29ubmVjdGlvbiBnb3QgZGlzcG9zZWQuXG4gICAgICovXG4gICAgQ29ubmVjdGlvbkVycm9yc1tDb25uZWN0aW9uRXJyb3JzW1wiRGlzcG9zZWRcIl0gPSAyXSA9IFwiRGlzcG9zZWRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgY29ubmVjdGlvbiBpcyBhbHJlYWR5IGluIGxpc3RlbmluZyBtb2RlLlxuICAgICAqL1xuICAgIENvbm5lY3Rpb25FcnJvcnNbQ29ubmVjdGlvbkVycm9yc1tcIkFscmVhZHlMaXN0ZW5pbmdcIl0gPSAzXSA9IFwiQWxyZWFkeUxpc3RlbmluZ1wiO1xufSkoQ29ubmVjdGlvbkVycm9ycyA9IGV4cG9ydHMuQ29ubmVjdGlvbkVycm9ycyB8fCAoZXhwb3J0cy5Db25uZWN0aW9uRXJyb3JzID0ge30pKTtcbmNsYXNzIENvbm5lY3Rpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQ29ubmVjdGlvbkVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Db25uZWN0aW9uRXJyb3IgPSBDb25uZWN0aW9uRXJyb3I7XG52YXIgQ29ubmVjdGlvblN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uU3RyYXRlZ3kpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5jYW5jZWxVbmRpc3BhdGNoZWQpO1xuICAgIH1cbiAgICBDb25uZWN0aW9uU3RyYXRlZ3kuaXMgPSBpcztcbn0pKENvbm5lY3Rpb25TdHJhdGVneSA9IGV4cG9ydHMuQ29ubmVjdGlvblN0cmF0ZWd5IHx8IChleHBvcnRzLkNvbm5lY3Rpb25TdHJhdGVneSA9IHt9KSk7XG52YXIgSWRDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChJZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiAoY2FuZGlkYXRlLmtpbmQgPT09IHVuZGVmaW5lZCB8fCBjYW5kaWRhdGUua2luZCA9PT0gJ2lkJykgJiYgSXMuZnVuYyhjYW5kaWRhdGUuY3JlYXRlQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UpICYmIChjYW5kaWRhdGUuZGlzcG9zZSA9PT0gdW5kZWZpbmVkIHx8IElzLmZ1bmMoY2FuZGlkYXRlLmRpc3Bvc2UpKTtcbiAgICB9XG4gICAgSWRDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5LmlzID0gaXM7XG59KShJZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLklkQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSB8fCAoZXhwb3J0cy5JZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSB7fSkpO1xudmFyIFJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChSZXF1ZXN0Q2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSkge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGNhbmRpZGF0ZS5raW5kID09PSAncmVxdWVzdCcgJiYgSXMuZnVuYyhjYW5kaWRhdGUuY3JlYXRlQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UpICYmIChjYW5kaWRhdGUuZGlzcG9zZSA9PT0gdW5kZWZpbmVkIHx8IElzLmZ1bmMoY2FuZGlkYXRlLmRpc3Bvc2UpKTtcbiAgICB9XG4gICAgUmVxdWVzdENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuaXMgPSBpcztcbn0pKFJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0gZXhwb3J0cy5SZXF1ZXN0Q2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSB8fCAoZXhwb3J0cy5SZXF1ZXN0Q2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSA9IHt9KSk7XG52YXIgQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneTtcbihmdW5jdGlvbiAoQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSkge1xuICAgIENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuTWVzc2FnZSA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBjcmVhdGVDYW5jZWxsYXRpb25Ub2tlblNvdXJjZShfKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGNhbmNlbGxhdGlvbl8xLkNhbmNlbGxhdGlvblRva2VuU291cmNlKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gSWRDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5LmlzKHZhbHVlKSB8fCBSZXF1ZXN0Q2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneS5pcyh2YWx1ZSk7XG4gICAgfVxuICAgIENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuaXMgPSBpcztcbn0pKENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgfHwgKGV4cG9ydHMuQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSA9IHt9KSk7XG52YXIgQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3k7XG4oZnVuY3Rpb24gKENhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5KSB7XG4gICAgQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kuTWVzc2FnZSA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBzZW5kQ2FuY2VsbGF0aW9uKGNvbm4sIGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gY29ubi5zZW5kTm90aWZpY2F0aW9uKENhbmNlbE5vdGlmaWNhdGlvbi50eXBlLCB7IGlkIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhbnVwKF8pIHsgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLmZ1bmMoY2FuZGlkYXRlLnNlbmRDYW5jZWxsYXRpb24pICYmIElzLmZ1bmMoY2FuZGlkYXRlLmNsZWFudXApO1xuICAgIH1cbiAgICBDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneS5pcyA9IGlzO1xufSkoQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5IHx8IChleHBvcnRzLkNhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5ID0ge30pKTtcbnZhciBDYW5jZWxsYXRpb25TdHJhdGVneTtcbihmdW5jdGlvbiAoQ2FuY2VsbGF0aW9uU3RyYXRlZ3kpIHtcbiAgICBDYW5jZWxsYXRpb25TdHJhdGVneS5NZXNzYWdlID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIHJlY2VpdmVyOiBDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5Lk1lc3NhZ2UsXG4gICAgICAgIHNlbmRlcjogQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kuTWVzc2FnZVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuaXMoY2FuZGlkYXRlLnJlY2VpdmVyKSAmJiBDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneS5pcyhjYW5kaWRhdGUuc2VuZGVyKTtcbiAgICB9XG4gICAgQ2FuY2VsbGF0aW9uU3RyYXRlZ3kuaXMgPSBpcztcbn0pKENhbmNlbGxhdGlvblN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25TdHJhdGVneSB8fCAoZXhwb3J0cy5DYW5jZWxsYXRpb25TdHJhdGVneSA9IHt9KSk7XG52YXIgTWVzc2FnZVN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChNZXNzYWdlU3RyYXRlZ3kpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5oYW5kbGVNZXNzYWdlKTtcbiAgICB9XG4gICAgTWVzc2FnZVN0cmF0ZWd5LmlzID0gaXM7XG59KShNZXNzYWdlU3RyYXRlZ3kgPSBleHBvcnRzLk1lc3NhZ2VTdHJhdGVneSB8fCAoZXhwb3J0cy5NZXNzYWdlU3RyYXRlZ3kgPSB7fSkpO1xudmFyIENvbm5lY3Rpb25PcHRpb25zO1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIChDYW5jZWxsYXRpb25TdHJhdGVneS5pcyhjYW5kaWRhdGUuY2FuY2VsbGF0aW9uU3RyYXRlZ3kpIHx8IENvbm5lY3Rpb25TdHJhdGVneS5pcyhjYW5kaWRhdGUuY29ubmVjdGlvblN0cmF0ZWd5KSB8fCBNZXNzYWdlU3RyYXRlZ3kuaXMoY2FuZGlkYXRlLm1lc3NhZ2VTdHJhdGVneSkpO1xuICAgIH1cbiAgICBDb25uZWN0aW9uT3B0aW9ucy5pcyA9IGlzO1xufSkoQ29ubmVjdGlvbk9wdGlvbnMgPSBleHBvcnRzLkNvbm5lY3Rpb25PcHRpb25zIHx8IChleHBvcnRzLkNvbm5lY3Rpb25PcHRpb25zID0ge30pKTtcbnZhciBDb25uZWN0aW9uU3RhdGU7XG4oZnVuY3Rpb24gKENvbm5lY3Rpb25TdGF0ZSkge1xuICAgIENvbm5lY3Rpb25TdGF0ZVtDb25uZWN0aW9uU3RhdGVbXCJOZXdcIl0gPSAxXSA9IFwiTmV3XCI7XG4gICAgQ29ubmVjdGlvblN0YXRlW0Nvbm5lY3Rpb25TdGF0ZVtcIkxpc3RlbmluZ1wiXSA9IDJdID0gXCJMaXN0ZW5pbmdcIjtcbiAgICBDb25uZWN0aW9uU3RhdGVbQ29ubmVjdGlvblN0YXRlW1wiQ2xvc2VkXCJdID0gM10gPSBcIkNsb3NlZFwiO1xuICAgIENvbm5lY3Rpb25TdGF0ZVtDb25uZWN0aW9uU3RhdGVbXCJEaXNwb3NlZFwiXSA9IDRdID0gXCJEaXNwb3NlZFwiO1xufSkoQ29ubmVjdGlvblN0YXRlIHx8IChDb25uZWN0aW9uU3RhdGUgPSB7fSkpO1xuZnVuY3Rpb24gY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24obWVzc2FnZVJlYWRlciwgbWVzc2FnZVdyaXRlciwgX2xvZ2dlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGxvZ2dlciA9IF9sb2dnZXIgIT09IHVuZGVmaW5lZCA/IF9sb2dnZXIgOiBleHBvcnRzLk51bGxMb2dnZXI7XG4gICAgbGV0IHNlcXVlbmNlTnVtYmVyID0gMDtcbiAgICBsZXQgbm90aWZpY2F0aW9uU2VxdWVuY2VOdW1iZXIgPSAwO1xuICAgIGxldCB1bmtub3duUmVzcG9uc2VTZXF1ZW5jZU51bWJlciA9IDA7XG4gICAgY29uc3QgdmVyc2lvbiA9ICcyLjAnO1xuICAgIGxldCBzdGFyUmVxdWVzdEhhbmRsZXIgPSB1bmRlZmluZWQ7XG4gICAgY29uc3QgcmVxdWVzdEhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgIGxldCBzdGFyTm90aWZpY2F0aW9uSGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBub3RpZmljYXRpb25IYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBwcm9ncmVzc0hhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgIGxldCB0aW1lcjtcbiAgICBsZXQgbWVzc2FnZVF1ZXVlID0gbmV3IGxpbmtlZE1hcF8xLkxpbmtlZE1hcCgpO1xuICAgIGxldCByZXNwb25zZVByb21pc2VzID0gbmV3IE1hcCgpO1xuICAgIGxldCBrbm93bkNhbmNlbGVkUmVxdWVzdHMgPSBuZXcgU2V0KCk7XG4gICAgbGV0IHJlcXVlc3RUb2tlbnMgPSBuZXcgTWFwKCk7XG4gICAgbGV0IHRyYWNlID0gVHJhY2UuT2ZmO1xuICAgIGxldCB0cmFjZUZvcm1hdCA9IFRyYWNlRm9ybWF0LlRleHQ7XG4gICAgbGV0IHRyYWNlcjtcbiAgICBsZXQgc3RhdGUgPSBDb25uZWN0aW9uU3RhdGUuTmV3O1xuICAgIGNvbnN0IGVycm9yRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgY29uc3QgY2xvc2VFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICBjb25zdCB1bmhhbmRsZWROb3RpZmljYXRpb25FbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICBjb25zdCB1bmhhbmRsZWRQcm9ncmVzc0VtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgIGNvbnN0IGRpc3Bvc2VFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICBjb25zdCBjYW5jZWxsYXRpb25TdHJhdGVneSA9IChvcHRpb25zICYmIG9wdGlvbnMuY2FuY2VsbGF0aW9uU3RyYXRlZ3kpID8gb3B0aW9ucy5jYW5jZWxsYXRpb25TdHJhdGVneSA6IENhbmNlbGxhdGlvblN0cmF0ZWd5Lk1lc3NhZ2U7XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVxdWVzdFF1ZXVlS2V5KGlkKSB7XG4gICAgICAgIGlmIChpZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBzZW5kIHJlcXVlc3RzIHdpdGggaWQgbnVsbCBzaW5jZSB0aGUgcmVzcG9uc2UgY2FuJ3QgYmUgY29ycmVsYXRlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ3JlcS0nICsgaWQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2VRdWV1ZUtleShpZCkge1xuICAgICAgICBpZiAoaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAncmVzLXVua25vd24tJyArICgrK3Vua25vd25SZXNwb25zZVNlcXVlbmNlTnVtYmVyKS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdyZXMtJyArIGlkLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlTm90aWZpY2F0aW9uUXVldWVLZXkoKSB7XG4gICAgICAgIHJldHVybiAnbm90LScgKyAoKytub3RpZmljYXRpb25TZXF1ZW5jZU51bWJlcikudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkTWVzc2FnZVRvUXVldWUocXVldWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc1JlcXVlc3QobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIHF1ZXVlLnNldChjcmVhdGVSZXF1ZXN0UXVldWVLZXkobWVzc2FnZS5pZCksIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc1Jlc3BvbnNlKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBxdWV1ZS5zZXQoY3JlYXRlUmVzcG9uc2VRdWV1ZUtleShtZXNzYWdlLmlkKSwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBxdWV1ZS5zZXQoY3JlYXRlTm90aWZpY2F0aW9uUXVldWVLZXkoKSwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2FuY2VsVW5kaXNwYXRjaGVkKF9tZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTGlzdGVuaW5nKCkge1xuICAgICAgICByZXR1cm4gc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5MaXN0ZW5pbmc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzQ2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5DbG9zZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzRGlzcG9zZWQoKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkRpc3Bvc2VkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbG9zZUhhbmRsZXIoKSB7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLk5ldyB8fCBzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkxpc3RlbmluZykge1xuICAgICAgICAgICAgc3RhdGUgPSBDb25uZWN0aW9uU3RhdGUuQ2xvc2VkO1xuICAgICAgICAgICAgY2xvc2VFbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgY29ubmVjdGlvbiBpcyBkaXNwb3NlZCBkb24ndCBzZW50IGNsb3NlIGV2ZW50cy5cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZEVycm9ySGFuZGxlcihlcnJvcikge1xuICAgICAgICBlcnJvckVtaXR0ZXIuZmlyZShbZXJyb3IsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlRXJyb3JIYW5kbGVyKGRhdGEpIHtcbiAgICAgICAgZXJyb3JFbWl0dGVyLmZpcmUoZGF0YSk7XG4gICAgfVxuICAgIG1lc3NhZ2VSZWFkZXIub25DbG9zZShjbG9zZUhhbmRsZXIpO1xuICAgIG1lc3NhZ2VSZWFkZXIub25FcnJvcihyZWFkRXJyb3JIYW5kbGVyKTtcbiAgICBtZXNzYWdlV3JpdGVyLm9uQ2xvc2UoY2xvc2VIYW5kbGVyKTtcbiAgICBtZXNzYWdlV3JpdGVyLm9uRXJyb3Iod3JpdGVFcnJvckhhbmRsZXIpO1xuICAgIGZ1bmN0aW9uIHRyaWdnZXJNZXNzYWdlUXVldWUoKSB7XG4gICAgICAgIGlmICh0aW1lciB8fCBtZXNzYWdlUXVldWUuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVyID0gKDAsIHJhbF8xLmRlZmF1bHQpKCkudGltZXIuc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgIHRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcHJvY2Vzc01lc3NhZ2VRdWV1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNSZXF1ZXN0KG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBoYW5kbGVSZXF1ZXN0KG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc05vdGlmaWNhdGlvbihtZXNzYWdlKSkge1xuICAgICAgICAgICAgaGFuZGxlTm90aWZpY2F0aW9uKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc1Jlc3BvbnNlKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBoYW5kbGVSZXNwb25zZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZUludmFsaWRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb2Nlc3NNZXNzYWdlUXVldWUoKSB7XG4gICAgICAgIGlmIChtZXNzYWdlUXVldWUuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlUXVldWUuc2hpZnQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VTdHJhdGVneSA9IG9wdGlvbnM/Lm1lc3NhZ2VTdHJhdGVneTtcbiAgICAgICAgICAgIGlmIChNZXNzYWdlU3RyYXRlZ3kuaXMobWVzc2FnZVN0cmF0ZWd5KSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VTdHJhdGVneS5oYW5kbGVNZXNzYWdlKG1lc3NhZ2UsIGhhbmRsZU1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyaWdnZXJNZXNzYWdlUXVldWUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjYWxsYmFjayA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIHJlY2VpdmVkIGEgY2FuY2VsbGF0aW9uIG1lc3NhZ2UuIENoZWNrIGlmIHRoZSBtZXNzYWdlIGlzIHN0aWxsIGluIHRoZSBxdWV1ZVxuICAgICAgICAgICAgLy8gYW5kIGNhbmNlbCBpdCBpZiBhbGxvd2VkIHRvIGRvIHNvLlxuICAgICAgICAgICAgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc05vdGlmaWNhdGlvbihtZXNzYWdlKSAmJiBtZXNzYWdlLm1ldGhvZCA9PT0gQ2FuY2VsTm90aWZpY2F0aW9uLnR5cGUubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsSWQgPSBtZXNzYWdlLnBhcmFtcy5pZDtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBjcmVhdGVSZXF1ZXN0UXVldWVLZXkoY2FuY2VsSWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvQ2FuY2VsID0gbWVzc2FnZVF1ZXVlLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNSZXF1ZXN0KHRvQ2FuY2VsKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJhdGVneSA9IG9wdGlvbnM/LmNvbm5lY3Rpb25TdHJhdGVneTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSAoc3RyYXRlZ3kgJiYgc3RyYXRlZ3kuY2FuY2VsVW5kaXNwYXRjaGVkKSA/IHN0cmF0ZWd5LmNhbmNlbFVuZGlzcGF0Y2hlZCh0b0NhbmNlbCwgY2FuY2VsVW5kaXNwYXRjaGVkKSA6IGNhbmNlbFVuZGlzcGF0Y2hlZCh0b0NhbmNlbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiAocmVzcG9uc2UuZXJyb3IgIT09IHVuZGVmaW5lZCB8fCByZXNwb25zZS5yZXN1bHQgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VRdWV1ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuZGVsZXRlKGNhbmNlbElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmlkID0gdG9DYW5jZWwuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjZVNlbmRpbmdSZXNwb25zZShyZXNwb25zZSwgbWVzc2FnZS5tZXRob2QsIERhdGUubm93KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVdyaXRlci53cml0ZShyZXNwb25zZSkuY2F0Y2goKCkgPT4gbG9nZ2VyLmVycm9yKGBTZW5kaW5nIHJlc3BvbnNlIGZvciBjYW5jZWxlZCBtZXNzYWdlIGZhaWxlZC5gKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsbGF0aW9uVG9rZW4gPSByZXF1ZXN0VG9rZW5zLmdldChjYW5jZWxJZCk7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHJlcXVlc3QgaXMgYWxyZWFkeSBydW5uaW5nLiBDYW5jZWwgdGhlIHRva2VuXG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbGxhdGlvblRva2VuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uVG9rZW4uY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlUmVjZWl2ZWROb3RpZmljYXRpb24obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoZSBjYW5jZWwgYnV0IHN0aWxsIHF1ZXVlIHRoZSBtZXNzYWdlIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGNsZWFuIHVwIHN0YXRlIGluIHByb2Nlc3MgbWVzc2FnZS5cbiAgICAgICAgICAgICAgICAgICAga25vd25DYW5jZWxlZFJlcXVlc3RzLmFkZChjYW5jZWxJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkTWVzc2FnZVRvUXVldWUobWVzc2FnZVF1ZXVlLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyaWdnZXJNZXNzYWdlUXVldWUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gaGFuZGxlUmVxdWVzdChyZXF1ZXN0TWVzc2FnZSkge1xuICAgICAgICBpZiAoaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICAvLyB3ZSByZXR1cm4gaGVyZSBzaWxlbnRseSBzaW5jZSB3ZSBmaXJlZCBhbiBldmVudCB3aGVuIHRoZVxuICAgICAgICAgICAgLy8gY29ubmVjdGlvbiBnb3QgZGlzcG9zZWQuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVwbHkocmVzdWx0T3JFcnJvciwgbWV0aG9kLCBzdGFydFRpbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAganNvbnJwYzogdmVyc2lvbixcbiAgICAgICAgICAgICAgICBpZDogcmVxdWVzdE1lc3NhZ2UuaWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocmVzdWx0T3JFcnJvciBpbnN0YW5jZW9mIG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXJyb3IgPSByZXN1bHRPckVycm9yLnRvSnNvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5yZXN1bHQgPSByZXN1bHRPckVycm9yID09PSB1bmRlZmluZWQgPyBudWxsIDogcmVzdWx0T3JFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNlU2VuZGluZ1Jlc3BvbnNlKG1lc3NhZ2UsIG1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIG1lc3NhZ2VXcml0ZXIud3JpdGUobWVzc2FnZSkuY2F0Y2goKCkgPT4gbG9nZ2VyLmVycm9yKGBTZW5kaW5nIHJlc3BvbnNlIGZhaWxlZC5gKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVwbHlFcnJvcihlcnJvciwgbWV0aG9kLCBzdGFydFRpbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAganNvbnJwYzogdmVyc2lvbixcbiAgICAgICAgICAgICAgICBpZDogcmVxdWVzdE1lc3NhZ2UuaWQsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLnRvSnNvbigpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJhY2VTZW5kaW5nUmVzcG9uc2UobWVzc2FnZSwgbWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgbWVzc2FnZVdyaXRlci53cml0ZShtZXNzYWdlKS5jYXRjaCgoKSA9PiBsb2dnZXIuZXJyb3IoYFNlbmRpbmcgcmVzcG9uc2UgZmFpbGVkLmApKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXBseVN1Y2Nlc3MocmVzdWx0LCBtZXRob2QsIHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgLy8gVGhlIEpTT04gUlBDIGRlZmluZXMgdGhhdCBhIHJlc3BvbnNlIG11c3QgZWl0aGVyIGhhdmUgYSByZXN1bHQgb3IgYW4gZXJyb3JcbiAgICAgICAgICAgIC8vIFNvIHdlIGNhbid0IHRyZWF0IHVuZGVmaW5lZCBhcyBhIHZhbGlkIHJlc3BvbnNlIHJlc3VsdC5cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGpzb25ycGM6IHZlcnNpb24sXG4gICAgICAgICAgICAgICAgaWQ6IHJlcXVlc3RNZXNzYWdlLmlkLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJhY2VTZW5kaW5nUmVzcG9uc2UobWVzc2FnZSwgbWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgbWVzc2FnZVdyaXRlci53cml0ZShtZXNzYWdlKS5jYXRjaCgoKSA9PiBsb2dnZXIuZXJyb3IoYFNlbmRpbmcgcmVzcG9uc2UgZmFpbGVkLmApKTtcbiAgICAgICAgfVxuICAgICAgICB0cmFjZVJlY2VpdmVkUmVxdWVzdChyZXF1ZXN0TWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSByZXF1ZXN0SGFuZGxlcnMuZ2V0KHJlcXVlc3RNZXNzYWdlLm1ldGhvZCk7XG4gICAgICAgIGxldCB0eXBlO1xuICAgICAgICBsZXQgcmVxdWVzdEhhbmRsZXI7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICB0eXBlID0gZWxlbWVudC50eXBlO1xuICAgICAgICAgICAgcmVxdWVzdEhhbmRsZXIgPSBlbGVtZW50LmhhbmRsZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKHJlcXVlc3RIYW5kbGVyIHx8IHN0YXJSZXF1ZXN0SGFuZGxlcikge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5LZXkgPSByZXF1ZXN0TWVzc2FnZS5pZCA/PyBTdHJpbmcoRGF0ZS5ub3coKSk7IC8vXG4gICAgICAgICAgICBjb25zdCBjYW5jZWxsYXRpb25Tb3VyY2UgPSBJZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuaXMoY2FuY2VsbGF0aW9uU3RyYXRlZ3kucmVjZWl2ZXIpXG4gICAgICAgICAgICAgICAgPyBjYW5jZWxsYXRpb25TdHJhdGVneS5yZWNlaXZlci5jcmVhdGVDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSh0b2tlbktleSlcbiAgICAgICAgICAgICAgICA6IGNhbmNlbGxhdGlvblN0cmF0ZWd5LnJlY2VpdmVyLmNyZWF0ZUNhbmNlbGxhdGlvblRva2VuU291cmNlKHJlcXVlc3RNZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0TWVzc2FnZS5pZCAhPT0gbnVsbCAmJiBrbm93bkNhbmNlbGVkUmVxdWVzdHMuaGFzKHJlcXVlc3RNZXNzYWdlLmlkKSkge1xuICAgICAgICAgICAgICAgIGNhbmNlbGxhdGlvblNvdXJjZS5jYW5jZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0TWVzc2FnZS5pZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuc2V0KHRva2VuS2V5LCBjYW5jZWxsYXRpb25Tb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgaGFuZGxlclJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RNZXNzYWdlLnBhcmFtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUubnVtYmVyT2ZQYXJhbXMgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLkludmFsaWRQYXJhbXMsIGBSZXF1ZXN0ICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfSBkZWZpbmVzICR7dHlwZS5udW1iZXJPZlBhcmFtc30gcGFyYW1zIGJ1dCByZWNlaXZlZCBub25lLmApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlclJlc3VsdCA9IHJlcXVlc3RIYW5kbGVyKGNhbmNlbGxhdGlvblNvdXJjZS50b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXF1ZXN0TWVzc2FnZS5wYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUucGFyYW1ldGVyU3RydWN0dXJlcyA9PT0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuSW52YWxpZFBhcmFtcywgYFJlcXVlc3QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9IGRlZmluZXMgcGFyYW1ldGVycyBieSBuYW1lIGJ1dCByZWNlaXZlZCBwYXJhbWV0ZXJzIGJ5IHBvc2l0aW9uYCksIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyUmVzdWx0ID0gcmVxdWVzdEhhbmRsZXIoLi4ucmVxdWVzdE1lc3NhZ2UucGFyYW1zLCBjYW5jZWxsYXRpb25Tb3VyY2UudG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLnBhcmFtZXRlclN0cnVjdHVyZXMgPT09IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieVBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnZhbGlkUGFyYW1zLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZGVmaW5lcyBwYXJhbWV0ZXJzIGJ5IHBvc2l0aW9uIGJ1dCByZWNlaXZlZCBwYXJhbWV0ZXJzIGJ5IG5hbWVgKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJSZXN1bHQgPSByZXF1ZXN0SGFuZGxlcihyZXF1ZXN0TWVzc2FnZS5wYXJhbXMsIGNhbmNlbGxhdGlvblNvdXJjZS50b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhclJlcXVlc3RIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJSZXN1bHQgPSBzdGFyUmVxdWVzdEhhbmRsZXIocmVxdWVzdE1lc3NhZ2UubWV0aG9kLCByZXF1ZXN0TWVzc2FnZS5wYXJhbXMsIGNhbmNlbGxhdGlvblNvdXJjZS50b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBoYW5kbGVyUmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmICghaGFuZGxlclJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW5zLmRlbGV0ZSh0b2tlbktleSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcGx5U3VjY2VzcyhoYW5kbGVyUmVzdWx0LCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb21pc2UudGhlbikge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oKHJlc3VsdE9yRXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuZGVsZXRlKHRva2VuS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5KHJlc3VsdE9yRXJyb3IsIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFRva2Vucy5kZWxldGUodG9rZW5LZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihlcnJvciwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IgJiYgSXMuc3RyaW5nKGVycm9yLm1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnRlcm5hbEVycm9yLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZmFpbGVkIHdpdGggbWVzc2FnZTogJHtlcnJvci5tZXNzYWdlfWApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLkludGVybmFsRXJyb3IsIGBSZXF1ZXN0ICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfSBmYWlsZWQgdW5leHBlY3RlZGx5IHdpdGhvdXQgcHJvdmlkaW5nIGFueSBkZXRhaWxzLmApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFRva2Vucy5kZWxldGUodG9rZW5LZXkpO1xuICAgICAgICAgICAgICAgICAgICByZXBseShoYW5kbGVyUmVzdWx0LCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFRva2Vucy5kZWxldGUodG9rZW5LZXkpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXBseShlcnJvciwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnJvciAmJiBJcy5zdHJpbmcoZXJyb3IubWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnRlcm5hbEVycm9yLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZmFpbGVkIHdpdGggbWVzc2FnZTogJHtlcnJvci5tZXNzYWdlfWApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLkludGVybmFsRXJyb3IsIGBSZXF1ZXN0ICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfSBmYWlsZWQgdW5leHBlY3RlZGx5IHdpdGhvdXQgcHJvdmlkaW5nIGFueSBkZXRhaWxzLmApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5NZXRob2ROb3RGb3VuZCwgYFVuaGFuZGxlZCBtZXRob2QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9YCksIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVSZXNwb25zZShyZXNwb25zZU1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGlzRGlzcG9zZWQoKSkge1xuICAgICAgICAgICAgLy8gU2VlIGhhbmRsZSByZXF1ZXN0LlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNwb25zZU1lc3NhZ2UuaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZU1lc3NhZ2UuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFJlY2VpdmVkIHJlc3BvbnNlIG1lc3NhZ2Ugd2l0aG91dCBpZDogRXJyb3IgaXM6IFxcbiR7SlNPTi5zdHJpbmdpZnkocmVzcG9uc2VNZXNzYWdlLmVycm9yLCB1bmRlZmluZWQsIDQpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBSZWNlaXZlZCByZXNwb25zZSBtZXNzYWdlIHdpdGhvdXQgaWQuIE5vIGZ1cnRoZXIgZXJyb3IgaW5mb3JtYXRpb24gcHJvdmlkZWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSByZXNwb25zZU1lc3NhZ2UuaWQ7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSByZXNwb25zZVByb21pc2VzLmdldChrZXkpO1xuICAgICAgICAgICAgdHJhY2VSZWNlaXZlZFJlc3BvbnNlKHJlc3BvbnNlTWVzc2FnZSwgcmVzcG9uc2VQcm9taXNlKTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVByb21pc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSByZXNwb25zZU1lc3NhZ2UuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVqZWN0KG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IoZXJyb3IuY29kZSwgZXJyb3IubWVzc2FnZSwgZXJyb3IuZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlTWVzc2FnZS5yZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlc29sdmUocmVzcG9uc2VNZXNzYWdlLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBuZXZlciBoYXBwZW4uJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFJlc3BvbnNlIGhhbmRsZXIgJyR7cmVzcG9uc2VQcm9taXNlLm1ldGhvZH0nIGZhaWxlZCB3aXRoIG1lc3NhZ2U6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgUmVzcG9uc2UgaGFuZGxlciAnJHtyZXNwb25zZVByb21pc2UubWV0aG9kfScgZmFpbGVkIHVuZXhwZWN0ZWRseS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVOb3RpZmljYXRpb24obWVzc2FnZSkge1xuICAgICAgICBpZiAoaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICAvLyBTZWUgaGFuZGxlIHJlcXVlc3QuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHR5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBub3RpZmljYXRpb25IYW5kbGVyO1xuICAgICAgICBpZiAobWVzc2FnZS5tZXRob2QgPT09IENhbmNlbE5vdGlmaWNhdGlvbi50eXBlLm1ldGhvZCkge1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsSWQgPSBtZXNzYWdlLnBhcmFtcy5pZDtcbiAgICAgICAgICAgIGtub3duQ2FuY2VsZWRSZXF1ZXN0cy5kZWxldGUoY2FuY2VsSWQpO1xuICAgICAgICAgICAgdHJhY2VSZWNlaXZlZE5vdGlmaWNhdGlvbihtZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBub3RpZmljYXRpb25IYW5kbGVycy5nZXQobWVzc2FnZS5tZXRob2QpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVyID0gZWxlbWVudC5oYW5kbGVyO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vdGlmaWNhdGlvbkhhbmRsZXIgfHwgc3Rhck5vdGlmaWNhdGlvbkhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdHJhY2VSZWNlaXZlZE5vdGlmaWNhdGlvbihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBpZiAobm90aWZpY2F0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5wYXJhbXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlLm51bWJlck9mUGFyYW1zICE9PSAwICYmIHR5cGUucGFyYW1ldGVyU3RydWN0dXJlcyAhPT0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE5vdGlmaWNhdGlvbiAke21lc3NhZ2UubWV0aG9kfSBkZWZpbmVzICR7dHlwZS5udW1iZXJPZlBhcmFtc30gcGFyYW1zIGJ1dCByZWNlaXZlZCBub25lLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG1lc3NhZ2UucGFyYW1zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgYXJlIEpTT04tUlBDIGxpYnJhcmllcyB0aGF0IHNlbmQgcHJvZ3Jlc3MgbWVzc2FnZSBhcyBwb3NpdGlvbmFsIHBhcmFtcyBhbHRob3VnaFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGFzIG5hbWVkLiBTbyBjb252ZXJ0IHRoZW0gaWYgdGhpcyBpcyB0aGUgY2FzZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IG1lc3NhZ2UucGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBQcm9ncmVzc05vdGlmaWNhdGlvbi50eXBlLm1ldGhvZCAmJiBwYXJhbXMubGVuZ3RoID09PSAyICYmIFByb2dyZXNzVG9rZW4uaXMocGFyYW1zWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXIoeyB0b2tlbjogcGFyYW1zWzBdLCB2YWx1ZTogcGFyYW1zWzFdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZS5wYXJhbWV0ZXJTdHJ1Y3R1cmVzID09PSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE5vdGlmaWNhdGlvbiAke21lc3NhZ2UubWV0aG9kfSBkZWZpbmVzIHBhcmFtZXRlcnMgYnkgbmFtZSBidXQgcmVjZWl2ZWQgcGFyYW1ldGVycyBieSBwb3NpdGlvbmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlLm51bWJlck9mUGFyYW1zICE9PSBtZXNzYWdlLnBhcmFtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTm90aWZpY2F0aW9uICR7bWVzc2FnZS5tZXRob2R9IGRlZmluZXMgJHt0eXBlLm51bWJlck9mUGFyYW1zfSBwYXJhbXMgYnV0IHJlY2VpdmVkICR7cGFyYW1zLmxlbmd0aH0gYXJndW1lbnRzYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlciguLi5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLnBhcmFtZXRlclN0cnVjdHVyZXMgPT09IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieVBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBOb3RpZmljYXRpb24gJHttZXNzYWdlLm1ldGhvZH0gZGVmaW5lcyBwYXJhbWV0ZXJzIGJ5IHBvc2l0aW9uIGJ1dCByZWNlaXZlZCBwYXJhbWV0ZXJzIGJ5IG5hbWVgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXIobWVzc2FnZS5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJOb3RpZmljYXRpb25IYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJOb3RpZmljYXRpb25IYW5kbGVyKG1lc3NhZ2UubWV0aG9kLCBtZXNzYWdlLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBOb3RpZmljYXRpb24gaGFuZGxlciAnJHttZXNzYWdlLm1ldGhvZH0nIGZhaWxlZCB3aXRoIG1lc3NhZ2U6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTm90aWZpY2F0aW9uIGhhbmRsZXIgJyR7bWVzc2FnZS5tZXRob2R9JyBmYWlsZWQgdW5leHBlY3RlZGx5LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVuaGFuZGxlZE5vdGlmaWNhdGlvbkVtaXR0ZXIuZmlyZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVJbnZhbGlkTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdSZWNlaXZlZCBlbXB0eSBtZXNzYWdlLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5lcnJvcihgUmVjZWl2ZWQgbWVzc2FnZSB3aGljaCBpcyBuZWl0aGVyIGEgcmVzcG9uc2Ugbm9yIGEgbm90aWZpY2F0aW9uIG1lc3NhZ2U6XFxuJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlLCBudWxsLCA0KX1gKTtcbiAgICAgICAgLy8gVGVzdCB3aGV0aGVyIHdlIGZpbmQgYW4gaWQgdG8gcmVqZWN0IHRoZSBwcm9taXNlXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIGlmIChJcy5zdHJpbmcocmVzcG9uc2VNZXNzYWdlLmlkKSB8fCBJcy5udW1iZXIocmVzcG9uc2VNZXNzYWdlLmlkKSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gcmVzcG9uc2VNZXNzYWdlLmlkO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VIYW5kbGVyID0gcmVzcG9uc2VQcm9taXNlcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZUhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZUhhbmRsZXIucmVqZWN0KG5ldyBFcnJvcignVGhlIHJlY2VpdmVkIHJlc3BvbnNlIGhhcyBuZWl0aGVyIGEgcmVzdWx0IG5vciBhbiBlcnJvciBwcm9wZXJ0eS4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RyaW5naWZ5VHJhY2UocGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMgPT09IHVuZGVmaW5lZCB8fCBwYXJhbXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0cmFjZSkge1xuICAgICAgICAgICAgY2FzZSBUcmFjZS5WZXJib3NlOlxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXJhbXMsIG51bGwsIDQpO1xuICAgICAgICAgICAgY2FzZSBUcmFjZS5Db21wYWN0OlxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXJhbXMpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYWNlU2VuZGluZ1JlcXVlc3QobWVzc2FnZSkge1xuICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLk9mZiB8fCAhdHJhY2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNlRm9ybWF0ID09PSBUcmFjZUZvcm1hdC5UZXh0KSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICgodHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3QpICYmIG1lc3NhZ2UucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGBQYXJhbXM6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5wYXJhbXMpfVxcblxcbmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZXIubG9nKGBTZW5kaW5nIHJlcXVlc3QgJyR7bWVzc2FnZS5tZXRob2R9IC0gKCR7bWVzc2FnZS5pZH0pJy5gLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0xTUE1lc3NhZ2UoJ3NlbmQtcmVxdWVzdCcsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYWNlU2VuZGluZ05vdGlmaWNhdGlvbihtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2VGb3JtYXQgPT09IFRyYWNlRm9ybWF0LlRleHQpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5WZXJib3NlIHx8IHRyYWNlID09PSBUcmFjZS5Db21wYWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBgUGFyYW1zOiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UucGFyYW1zKX1cXG5cXG5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICdObyBwYXJhbWV0ZXJzIHByb3ZpZGVkLlxcblxcbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2VyLmxvZyhgU2VuZGluZyBub3RpZmljYXRpb24gJyR7bWVzc2FnZS5tZXRob2R9Jy5gLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0xTUE1lc3NhZ2UoJ3NlbmQtbm90aWZpY2F0aW9uJywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhY2VTZW5kaW5nUmVzcG9uc2UobWVzc2FnZSwgbWV0aG9kLCBzdGFydFRpbWUpIHtcbiAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYgfHwgIXRyYWNlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZUZvcm1hdCA9PT0gVHJhY2VGb3JtYXQuVGV4dCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5lcnJvciAmJiBtZXNzYWdlLmVycm9yLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGBFcnJvciBkYXRhOiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UuZXJyb3IuZGF0YSl9XFxuXFxuYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGBSZXN1bHQ6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5yZXN1bHQpfVxcblxcbmA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWVzc2FnZS5lcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gJ05vIHJlc3VsdCByZXR1cm5lZC5cXG5cXG4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2VyLmxvZyhgU2VuZGluZyByZXNwb25zZSAnJHttZXRob2R9IC0gKCR7bWVzc2FnZS5pZH0pJy4gUHJvY2Vzc2luZyByZXF1ZXN0IHRvb2sgJHtEYXRlLm5vdygpIC0gc3RhcnRUaW1lfW1zYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdzZW5kLXJlc3BvbnNlJywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhY2VSZWNlaXZlZFJlcXVlc3QobWVzc2FnZSkge1xuICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLk9mZiB8fCAhdHJhY2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNlRm9ybWF0ID09PSBUcmFjZUZvcm1hdC5UZXh0KSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICgodHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3QpICYmIG1lc3NhZ2UucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGBQYXJhbXM6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5wYXJhbXMpfVxcblxcbmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZXIubG9nKGBSZWNlaXZlZCByZXF1ZXN0ICcke21lc3NhZ2UubWV0aG9kfSAtICgke21lc3NhZ2UuaWR9KScuYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdyZWNlaXZlLXJlcXVlc3QnLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFjZVJlY2VpdmVkTm90aWZpY2F0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYgfHwgIXRyYWNlciB8fCBtZXNzYWdlLm1ldGhvZCA9PT0gTG9nVHJhY2VOb3RpZmljYXRpb24udHlwZS5tZXRob2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2VGb3JtYXQgPT09IFRyYWNlRm9ybWF0LlRleHQpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5WZXJib3NlIHx8IHRyYWNlID09PSBUcmFjZS5Db21wYWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBgUGFyYW1zOiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UucGFyYW1zKX1cXG5cXG5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICdObyBwYXJhbWV0ZXJzIHByb3ZpZGVkLlxcblxcbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2VyLmxvZyhgUmVjZWl2ZWQgbm90aWZpY2F0aW9uICcke21lc3NhZ2UubWV0aG9kfScuYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdyZWNlaXZlLW5vdGlmaWNhdGlvbicsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYWNlUmVjZWl2ZWRSZXNwb25zZShtZXNzYWdlLCByZXNwb25zZVByb21pc2UpIHtcbiAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYgfHwgIXRyYWNlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZUZvcm1hdCA9PT0gVHJhY2VGb3JtYXQuVGV4dCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5lcnJvciAmJiBtZXNzYWdlLmVycm9yLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGBFcnJvciBkYXRhOiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UuZXJyb3IuZGF0YSl9XFxuXFxuYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGBSZXN1bHQ6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5yZXN1bHQpfVxcblxcbmA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWVzc2FnZS5lcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gJ05vIHJlc3VsdCByZXR1cm5lZC5cXG5cXG4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbWVzc2FnZS5lcnJvciA/IGAgUmVxdWVzdCBmYWlsZWQ6ICR7bWVzc2FnZS5lcnJvci5tZXNzYWdlfSAoJHttZXNzYWdlLmVycm9yLmNvZGV9KS5gIDogJyc7XG4gICAgICAgICAgICAgICAgdHJhY2VyLmxvZyhgUmVjZWl2ZWQgcmVzcG9uc2UgJyR7cmVzcG9uc2VQcm9taXNlLm1ldGhvZH0gLSAoJHttZXNzYWdlLmlkfSknIGluICR7RGF0ZS5ub3coKSAtIHJlc3BvbnNlUHJvbWlzZS50aW1lclN0YXJ0fW1zLiR7ZXJyb3J9YCwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFjZXIubG9nKGBSZWNlaXZlZCByZXNwb25zZSAke21lc3NhZ2UuaWR9IHdpdGhvdXQgYWN0aXZlIHJlc3BvbnNlIHByb21pc2UuYCwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdyZWNlaXZlLXJlc3BvbnNlJywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbG9nTFNQTWVzc2FnZSh0eXBlLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICghdHJhY2VyIHx8IHRyYWNlID09PSBUcmFjZS5PZmYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsc3BNZXNzYWdlID0ge1xuICAgICAgICAgICAgaXNMU1BNZXNzYWdlOiB0cnVlLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgICAgfTtcbiAgICAgICAgdHJhY2VyLmxvZyhsc3BNZXNzYWdlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGhyb3dJZkNsb3NlZE9yRGlzcG9zZWQoKSB7XG4gICAgICAgIGlmIChpc0Nsb3NlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKENvbm5lY3Rpb25FcnJvcnMuQ2xvc2VkLCAnQ29ubmVjdGlvbiBpcyBjbG9zZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGlzcG9zZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihDb25uZWN0aW9uRXJyb3JzLkRpc3Bvc2VkLCAnQ29ubmVjdGlvbiBpcyBkaXNwb3NlZC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0aHJvd0lmTGlzdGVuaW5nKCkge1xuICAgICAgICBpZiAoaXNMaXN0ZW5pbmcoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihDb25uZWN0aW9uRXJyb3JzLkFscmVhZHlMaXN0ZW5pbmcsICdDb25uZWN0aW9uIGlzIGFscmVhZHkgbGlzdGVuaW5nJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdGhyb3dJZk5vdExpc3RlbmluZygpIHtcbiAgICAgICAgaWYgKCFpc0xpc3RlbmluZygpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGwgbGlzdGVuKCkgZmlyc3QuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdW5kZWZpbmVkVG9OdWxsKHBhcmFtKSB7XG4gICAgICAgIGlmIChwYXJhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBudWxsVG9VbmRlZmluZWQocGFyYW0pIHtcbiAgICAgICAgaWYgKHBhcmFtID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTmFtZWRQYXJhbShwYXJhbSkge1xuICAgICAgICByZXR1cm4gcGFyYW0gIT09IHVuZGVmaW5lZCAmJiBwYXJhbSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShwYXJhbSkgJiYgdHlwZW9mIHBhcmFtID09PSAnb2JqZWN0JztcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcHV0ZVNpbmdsZVBhcmFtKHBhcmFtZXRlclN0cnVjdHVyZXMsIHBhcmFtKSB7XG4gICAgICAgIHN3aXRjaCAocGFyYW1ldGVyU3RydWN0dXJlcykge1xuICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYXV0bzpcbiAgICAgICAgICAgICAgICBpZiAoaXNOYW1lZFBhcmFtKHBhcmFtKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFRvVW5kZWZpbmVkKHBhcmFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdW5kZWZpbmVkVG9OdWxsKHBhcmFtKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lOlxuICAgICAgICAgICAgICAgIGlmICghaXNOYW1lZFBhcmFtKHBhcmFtKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlY2VpdmVkIHBhcmFtZXRlcnMgYnkgbmFtZSBidXQgcGFyYW0gaXMgbm90IGFuIG9iamVjdCBsaXRlcmFsLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFRvVW5kZWZpbmVkKHBhcmFtKTtcbiAgICAgICAgICAgIGNhc2UgbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5UG9zaXRpb246XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWRUb051bGwocGFyYW0pXTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHBhcmFtZXRlciBzdHJ1Y3R1cmUgJHtwYXJhbWV0ZXJTdHJ1Y3R1cmVzLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcHV0ZU1lc3NhZ2VQYXJhbXModHlwZSwgcGFyYW1zKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGNvbnN0IG51bWJlck9mUGFyYW1zID0gdHlwZS5udW1iZXJPZlBhcmFtcztcbiAgICAgICAgc3dpdGNoIChudW1iZXJPZlBhcmFtcykge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjb21wdXRlU2luZ2xlUGFyYW0odHlwZS5wYXJhbWV0ZXJTdHJ1Y3R1cmVzLCBwYXJhbXNbMF0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGggJiYgaSA8IG51bWJlck9mUGFyYW1zOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godW5kZWZpbmVkVG9OdWxsKHBhcmFtc1tpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA8IG51bWJlck9mUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBwYXJhbXMubGVuZ3RoOyBpIDwgbnVtYmVyT2ZQYXJhbXM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgY29ubmVjdGlvbiA9IHtcbiAgICAgICAgc2VuZE5vdGlmaWNhdGlvbjogKHR5cGUsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCk7XG4gICAgICAgICAgICBsZXQgbWV0aG9kO1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2VQYXJhbXM7XG4gICAgICAgICAgICBpZiAoSXMuc3RyaW5nKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdCA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtU3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBwYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG87XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5pcyhmaXJzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1TdGFydCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlclN0cnVjdHVyZXMgPSBmaXJzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtRW5kID0gYXJncy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtYmVyT2ZQYXJhbXMgPSBwYXJhbUVuZCAtIHBhcmFtU3RhcnQ7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChudW1iZXJPZlBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSBjb21wdXRlU2luZ2xlUGFyYW0ocGFyYW1ldGVyU3RydWN0dXJlcywgYXJnc1twYXJhbVN0YXJ0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJTdHJ1Y3R1cmVzID09PSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWNlaXZlZCAke251bWJlck9mUGFyYW1zfSBwYXJhbWV0ZXJzIGZvciAnYnkgTmFtZScgbm90aWZpY2F0aW9uIHBhcmFtZXRlciBzdHJ1Y3R1cmUuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gYXJncy5zbGljZShwYXJhbVN0YXJ0LCBwYXJhbUVuZCkubWFwKHZhbHVlID0+IHVuZGVmaW5lZFRvTnVsbCh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gYXJncztcbiAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlLm1ldGhvZDtcbiAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gY29tcHV0ZU1lc3NhZ2VQYXJhbXModHlwZSwgcGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbk1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAganNvbnJwYzogdmVyc2lvbixcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IG1lc3NhZ2VQYXJhbXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cmFjZVNlbmRpbmdOb3RpZmljYXRpb24obm90aWZpY2F0aW9uTWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZVdyaXRlci53cml0ZShub3RpZmljYXRpb25NZXNzYWdlKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFNlbmRpbmcgbm90aWZpY2F0aW9uIGZhaWxlZC5gKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbk5vdGlmaWNhdGlvbjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCk7XG4gICAgICAgICAgICBsZXQgbWV0aG9kO1xuICAgICAgICAgICAgaWYgKElzLmZ1bmModHlwZSkpIHtcbiAgICAgICAgICAgICAgICBzdGFyTm90aWZpY2F0aW9uSGFuZGxlciA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKElzLnN0cmluZyh0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVycy5zZXQodHlwZSwgeyB0eXBlOiB1bmRlZmluZWQsIGhhbmRsZXIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlLm1ldGhvZDtcbiAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlcnMuc2V0KHR5cGUubWV0aG9kLCB7IHR5cGUsIGhhbmRsZXIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlcnMuZGVsZXRlKG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFyTm90aWZpY2F0aW9uSGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIG9uUHJvZ3Jlc3M6IChfdHlwZSwgdG9rZW4sIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChwcm9ncmVzc0hhbmRsZXJzLmhhcyh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb2dyZXNzIGhhbmRsZXIgZm9yIHRva2VuICR7dG9rZW59IGFscmVhZHkgcmVnaXN0ZXJlZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvZ3Jlc3NIYW5kbGVycy5zZXQodG9rZW4sIGhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzSGFuZGxlcnMuZGVsZXRlKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBzZW5kUHJvZ3Jlc3M6IChfdHlwZSwgdG9rZW4sIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgYXdhaXQgYnV0IHNpbXBsZSByZXR1cm4gdG8gZW5zdXJlIHRoYXQgd2UgZG9uJ3QgaGF2ZSBhbm90aGVyXG4gICAgICAgICAgICAvLyBhc3luYyBzY2hlZHVsaW5nLiBPdGhlcndpc2Ugb25lIHNlbmQgY291bGQgb3ZlcnRha2UgYW5vdGhlciBzZW5kLlxuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uc2VuZE5vdGlmaWNhdGlvbihQcm9ncmVzc05vdGlmaWNhdGlvbi50eXBlLCB7IHRva2VuLCB2YWx1ZSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25VbmhhbmRsZWRQcm9ncmVzczogdW5oYW5kbGVkUHJvZ3Jlc3NFbWl0dGVyLmV2ZW50LFxuICAgICAgICBzZW5kUmVxdWVzdDogKHR5cGUsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCk7XG4gICAgICAgICAgICB0aHJvd0lmTm90TGlzdGVuaW5nKCk7XG4gICAgICAgICAgICBsZXQgbWV0aG9kO1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2VQYXJhbXM7XG4gICAgICAgICAgICBsZXQgdG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoSXMuc3RyaW5nKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdCA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1TdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtZXRlclN0cnVjdHVyZXMgPSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYXV0bztcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmlzKGZpcnN0KSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbVN0YXJ0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyU3RydWN0dXJlcyA9IGZpcnN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1FbmQgPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoY2FuY2VsbGF0aW9uXzEuQ2FuY2VsbGF0aW9uVG9rZW4uaXMobGFzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1FbmQgPSBwYXJhbUVuZCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gbGFzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtYmVyT2ZQYXJhbXMgPSBwYXJhbUVuZCAtIHBhcmFtU3RhcnQ7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChudW1iZXJPZlBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSBjb21wdXRlU2luZ2xlUGFyYW0ocGFyYW1ldGVyU3RydWN0dXJlcywgYXJnc1twYXJhbVN0YXJ0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJTdHJ1Y3R1cmVzID09PSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWNlaXZlZCAke251bWJlck9mUGFyYW1zfSBwYXJhbWV0ZXJzIGZvciAnYnkgTmFtZScgcmVxdWVzdCBwYXJhbWV0ZXIgc3RydWN0dXJlLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IGFyZ3Muc2xpY2UocGFyYW1TdGFydCwgcGFyYW1FbmQpLm1hcCh2YWx1ZSA9PiB1bmRlZmluZWRUb051bGwodmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZS5tZXRob2Q7XG4gICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IGNvbXB1dGVNZXNzYWdlUGFyYW1zKHR5cGUsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtYmVyT2ZQYXJhbXMgPSB0eXBlLm51bWJlck9mUGFyYW1zO1xuICAgICAgICAgICAgICAgIHRva2VuID0gY2FuY2VsbGF0aW9uXzEuQ2FuY2VsbGF0aW9uVG9rZW4uaXMocGFyYW1zW251bWJlck9mUGFyYW1zXSkgPyBwYXJhbXNbbnVtYmVyT2ZQYXJhbXNdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaWQgPSBzZXF1ZW5jZU51bWJlcisrO1xuICAgICAgICAgICAgbGV0IGRpc3Bvc2FibGU7XG4gICAgICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NhYmxlID0gdG9rZW4ub25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gY2FuY2VsbGF0aW9uU3RyYXRlZ3kuc2VuZGVyLnNlbmRDYW5jZWxsYXRpb24oY29ubmVjdGlvbiwgaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBSZWNlaXZlZCBubyBwcm9taXNlIGZyb20gY2FuY2VsbGF0aW9uIHN0cmF0ZWd5IHdoZW4gY2FuY2VsbGluZyBpZCAke2lkfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYFNlbmRpbmcgY2FuY2VsbGF0aW9uIG1lc3NhZ2VzIGZvciBpZCAke2lkfSBmYWlsZWRgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0TWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICBqc29ucnBjOiB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IG1lc3NhZ2VQYXJhbXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cmFjZVNlbmRpbmdSZXF1ZXN0KHJlcXVlc3RNZXNzYWdlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FuY2VsbGF0aW9uU3RyYXRlZ3kuc2VuZGVyLmVuYWJsZUNhbmNlbGxhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNhbmNlbGxhdGlvblN0cmF0ZWd5LnNlbmRlci5lbmFibGVDYW5jZWxsYXRpb24ocmVxdWVzdE1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlV2l0aENsZWFudXAgPSAocikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHIpO1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25TdHJhdGVneS5zZW5kZXIuY2xlYW51cChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FibGU/LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlamVjdFdpdGhDbGVhbnVwID0gKHIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHIpO1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25TdHJhdGVneS5zZW5kZXIuY2xlYW51cChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FibGU/LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IHsgbWV0aG9kOiBtZXRob2QsIHRpbWVyU3RhcnQ6IERhdGUubm93KCksIHJlc29sdmU6IHJlc29sdmVXaXRoQ2xlYW51cCwgcmVqZWN0OiByZWplY3RXaXRoQ2xlYW51cCB9O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG1lc3NhZ2VXcml0ZXIud3JpdGUocmVxdWVzdE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2VzLnNldChpZCwgcmVzcG9uc2VQcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgU2VuZGluZyByZXF1ZXN0IGZhaWxlZC5gKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV3JpdGluZyB0aGUgbWVzc2FnZSBmYWlsZWQuIFNvIHdlIG5lZWQgdG8gcmVqZWN0IHRoZSBwcm9taXNlLlxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVqZWN0KG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLk1lc3NhZ2VXcml0ZUVycm9yLCBlcnJvci5tZXNzYWdlID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIHJlYXNvbicpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUmVxdWVzdDogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCk7XG4gICAgICAgICAgICBsZXQgbWV0aG9kID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChTdGFyUmVxdWVzdEhhbmRsZXIuaXModHlwZSkpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgc3RhclJlcXVlc3RIYW5kbGVyID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKElzLnN0cmluZyh0eXBlKSkge1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SGFuZGxlcnMuc2V0KHR5cGUsIHsgaGFuZGxlcjogaGFuZGxlciwgdHlwZTogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZS5tZXRob2Q7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIYW5kbGVycy5zZXQodHlwZS5tZXRob2QsIHsgdHlwZSwgaGFuZGxlciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhhbmRsZXJzLmRlbGV0ZShtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhclJlcXVlc3RIYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzUGVuZGluZ1Jlc3BvbnNlOiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VQcm9taXNlcy5zaXplID4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhY2U6IGFzeW5jIChfdmFsdWUsIF90cmFjZXIsIHNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgbGV0IF9zZW5kTm90aWZpY2F0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgX3RyYWNlRm9ybWF0ID0gVHJhY2VGb3JtYXQuVGV4dDtcbiAgICAgICAgICAgIGlmIChzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChJcy5ib29sZWFuKHNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgX3NlbmROb3RpZmljYXRpb24gPSBzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfc2VuZE5vdGlmaWNhdGlvbiA9IHNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucy5zZW5kTm90aWZpY2F0aW9uIHx8IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBfdHJhY2VGb3JtYXQgPSBzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMudHJhY2VGb3JtYXQgfHwgVHJhY2VGb3JtYXQuVGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZSA9IF92YWx1ZTtcbiAgICAgICAgICAgIHRyYWNlRm9ybWF0ID0gX3RyYWNlRm9ybWF0O1xuICAgICAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYpIHtcbiAgICAgICAgICAgICAgICB0cmFjZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFjZXIgPSBfdHJhY2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9zZW5kTm90aWZpY2F0aW9uICYmICFpc0Nsb3NlZCgpICYmICFpc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uZWN0aW9uLnNlbmROb3RpZmljYXRpb24oU2V0VHJhY2VOb3RpZmljYXRpb24udHlwZSwgeyB2YWx1ZTogVHJhY2UudG9TdHJpbmcoX3ZhbHVlKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogZXJyb3JFbWl0dGVyLmV2ZW50LFxuICAgICAgICBvbkNsb3NlOiBjbG9zZUVtaXR0ZXIuZXZlbnQsXG4gICAgICAgIG9uVW5oYW5kbGVkTm90aWZpY2F0aW9uOiB1bmhhbmRsZWROb3RpZmljYXRpb25FbWl0dGVyLmV2ZW50LFxuICAgICAgICBvbkRpc3Bvc2U6IGRpc3Bvc2VFbWl0dGVyLmV2ZW50LFxuICAgICAgICBlbmQ6ICgpID0+IHtcbiAgICAgICAgICAgIG1lc3NhZ2VXcml0ZXIuZW5kKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZSA9IENvbm5lY3Rpb25TdGF0ZS5EaXNwb3NlZDtcbiAgICAgICAgICAgIGRpc3Bvc2VFbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuUGVuZGluZ1Jlc3BvbnNlUmVqZWN0ZWQsICdQZW5kaW5nIHJlc3BvbnNlIHJlamVjdGVkIHNpbmNlIGNvbm5lY3Rpb24gZ290IGRpc3Bvc2VkJyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb21pc2Ugb2YgcmVzcG9uc2VQcm9taXNlcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIHByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICByZXF1ZXN0VG9rZW5zID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAga25vd25DYW5jZWxlZFJlcXVlc3RzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgbWVzc2FnZVF1ZXVlID0gbmV3IGxpbmtlZE1hcF8xLkxpbmtlZE1hcCgpO1xuICAgICAgICAgICAgLy8gVGVzdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIGlmIChJcy5mdW5jKG1lc3NhZ2VXcml0ZXIuZGlzcG9zZSkpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlV3JpdGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChJcy5mdW5jKG1lc3NhZ2VSZWFkZXIuZGlzcG9zZSkpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlUmVhZGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbGlzdGVuOiAoKSA9PiB7XG4gICAgICAgICAgICB0aHJvd0lmQ2xvc2VkT3JEaXNwb3NlZCgpO1xuICAgICAgICAgICAgdGhyb3dJZkxpc3RlbmluZygpO1xuICAgICAgICAgICAgc3RhdGUgPSBDb25uZWN0aW9uU3RhdGUuTGlzdGVuaW5nO1xuICAgICAgICAgICAgbWVzc2FnZVJlYWRlci5saXN0ZW4oY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICBpbnNwZWN0OiAoKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgKDAsIHJhbF8xLmRlZmF1bHQpKCkuY29uc29sZS5sb2coJ2luc3BlY3QnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29ubmVjdGlvbi5vbk5vdGlmaWNhdGlvbihMb2dUcmFjZU5vdGlmaWNhdGlvbi50eXBlLCAocGFyYW1zKSA9PiB7XG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ZXJib3NlID0gdHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3Q7XG4gICAgICAgIHRyYWNlci5sb2cocGFyYW1zLm1lc3NhZ2UsIHZlcmJvc2UgPyBwYXJhbXMudmVyYm9zZSA6IHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gICAgY29ubmVjdGlvbi5vbk5vdGlmaWNhdGlvbihQcm9ncmVzc05vdGlmaWNhdGlvbi50eXBlLCAocGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBwcm9ncmVzc0hhbmRsZXJzLmdldChwYXJhbXMudG9rZW4pO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgaGFuZGxlcihwYXJhbXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdW5oYW5kbGVkUHJvZ3Jlc3NFbWl0dGVyLmZpcmUocGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb25uZWN0aW9uO1xufVxuZXhwb3J0cy5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiA9IGNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NDM3OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuRGlzcG9zYWJsZSA9IHZvaWQgMDtcbnZhciBEaXNwb3NhYmxlO1xuKGZ1bmN0aW9uIChEaXNwb3NhYmxlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpc3Bvc2U6IGZ1bmNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgRGlzcG9zYWJsZS5jcmVhdGUgPSBjcmVhdGU7XG59KShEaXNwb3NhYmxlID0gZXhwb3J0cy5EaXNwb3NhYmxlIHx8IChleHBvcnRzLkRpc3Bvc2FibGUgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MTY1OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkVtaXR0ZXIgPSBleHBvcnRzLkV2ZW50ID0gdm9pZCAwO1xuY29uc3QgcmFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3MDYpO1xudmFyIEV2ZW50O1xuKGZ1bmN0aW9uIChFdmVudCkge1xuICAgIGNvbnN0IF9kaXNwb3NhYmxlID0geyBkaXNwb3NlKCkgeyB9IH07XG4gICAgRXZlbnQuTm9uZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9kaXNwb3NhYmxlOyB9O1xufSkoRXZlbnQgPSBleHBvcnRzLkV2ZW50IHx8IChleHBvcnRzLkV2ZW50ID0ge30pKTtcbmNsYXNzIENhbGxiYWNrTGlzdCB7XG4gICAgYWRkKGNhbGxiYWNrLCBjb250ZXh0ID0gbnVsbCwgYnVja2V0KSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICB0aGlzLl9jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShidWNrZXQpKSB7XG4gICAgICAgICAgICBidWNrZXQucHVzaCh7IGRpc3Bvc2U6ICgpID0+IHRoaXMucmVtb3ZlKGNhbGxiYWNrLCBjb250ZXh0KSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUoY2FsbGJhY2ssIGNvbnRleHQgPSBudWxsKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZvdW5kQ2FsbGJhY2tXaXRoRGlmZmVyZW50Q29udGV4dCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5fY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2FsbGJhY2tzW2ldID09PSBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jb250ZXh0c1tpXSA9PT0gY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsYmFjayAmIGNvbnRleHQgbWF0Y2ggPT4gcmVtb3ZlIGl0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRDYWxsYmFja1dpdGhEaWZmZXJlbnRDb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kQ2FsbGJhY2tXaXRoRGlmZmVyZW50Q29udGV4dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaGVuIGFkZGluZyBhIGxpc3RlbmVyIHdpdGggYSBjb250ZXh0LCB5b3Ugc2hvdWxkIHJlbW92ZSBpdCB3aXRoIHRoZSBzYW1lIGNvbnRleHQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnZva2UoLi4uYXJncykge1xuICAgICAgICBpZiAoIXRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IFtdLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3Muc2xpY2UoMCksIGNvbnRleHRzID0gdGhpcy5fY29udGV4dHMuc2xpY2UoMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goY2FsbGJhY2tzW2ldLmFwcGx5KGNvbnRleHRzW2ldLCBhcmdzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgKDAsIHJhbF8xLmRlZmF1bHQpKCkuY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuX2NhbGxiYWNrcyB8fCB0aGlzLl9jYWxsYmFja3MubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2NvbnRleHRzID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmNsYXNzIEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKF9vcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBfb3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9yIHRoZSBwdWJsaWMgdG8gYWxsb3cgdG8gc3Vic2NyaWJlXG4gICAgICogdG8gZXZlbnRzIGZyb20gdGhpcyBFbWl0dGVyXG4gICAgICovXG4gICAgZ2V0IGV2ZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudCA9IChsaXN0ZW5lciwgdGhpc0FyZ3MsIGRpc3Bvc2FibGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gbmV3IENhbGxiYWNrTGlzdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucyAmJiB0aGlzLl9vcHRpb25zLm9uRmlyc3RMaXN0ZW5lckFkZCAmJiB0aGlzLl9jYWxsYmFja3MuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMub25GaXJzdExpc3RlbmVyQWRkKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MuYWRkKGxpc3RlbmVyLCB0aGlzQXJncyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpc3Bvc2FibGUgaXMgZGlzcG9zZWQgYWZ0ZXIgZW1pdHRlciBpcyBkaXNwb3NlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MucmVtb3ZlKGxpc3RlbmVyLCB0aGlzQXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZGlzcG9zZSA9IEVtaXR0ZXIuX25vb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucyAmJiB0aGlzLl9vcHRpb25zLm9uTGFzdExpc3RlbmVyUmVtb3ZlICYmIHRoaXMuX2NhbGxiYWNrcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLm9uTGFzdExpc3RlbmVyUmVtb3ZlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkaXNwb3NhYmxlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zYWJsZXMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvIGJlIGtlcHQgcHJpdmF0ZSB0byBmaXJlIGFuIGV2ZW50IHRvXG4gICAgICogc3Vic2NyaWJlcnNcbiAgICAgKi9cbiAgICBmaXJlKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5pbnZva2UuY2FsbCh0aGlzLl9jYWxsYmFja3MsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5FbWl0dGVyID0gRW1pdHRlcjtcbkVtaXR0ZXIuX25vb3AgPSBmdW5jdGlvbiAoKSB7IH07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg4MTE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuc3RyaW5nQXJyYXkgPSBleHBvcnRzLmFycmF5ID0gZXhwb3J0cy5mdW5jID0gZXhwb3J0cy5lcnJvciA9IGV4cG9ydHMubnVtYmVyID0gZXhwb3J0cy5zdHJpbmcgPSBleHBvcnRzLmJvb2xlYW4gPSB2b2lkIDA7XG5mdW5jdGlvbiBib29sZWFuKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZTtcbn1cbmV4cG9ydHMuYm9vbGVhbiA9IGJvb2xlYW47XG5mdW5jdGlvbiBzdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZztcbn1cbmV4cG9ydHMuc3RyaW5nID0gc3RyaW5nO1xuZnVuY3Rpb24gbnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXI7XG59XG5leHBvcnRzLm51bWJlciA9IG51bWJlcjtcbmZ1bmN0aW9uIGVycm9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRXJyb3I7XG59XG5leHBvcnRzLmVycm9yID0gZXJyb3I7XG5mdW5jdGlvbiBmdW5jKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuZnVuYyA9IGZ1bmM7XG5mdW5jdGlvbiBhcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbmV4cG9ydHMuYXJyYXkgPSBhcnJheTtcbmZ1bmN0aW9uIHN0cmluZ0FycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIGFycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShlbGVtID0+IHN0cmluZyhlbGVtKSk7XG59XG5leHBvcnRzLnN0cmluZ0FycmF5ID0gc3RyaW5nQXJyYXk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDcwNDA6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbnZhciBfYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5MUlVDYWNoZSA9IGV4cG9ydHMuTGlua2VkTWFwID0gZXhwb3J0cy5Ub3VjaCA9IHZvaWQgMDtcbnZhciBUb3VjaDtcbihmdW5jdGlvbiAoVG91Y2gpIHtcbiAgICBUb3VjaC5Ob25lID0gMDtcbiAgICBUb3VjaC5GaXJzdCA9IDE7XG4gICAgVG91Y2guQXNPbGQgPSBUb3VjaC5GaXJzdDtcbiAgICBUb3VjaC5MYXN0ID0gMjtcbiAgICBUb3VjaC5Bc05ldyA9IFRvdWNoLkxhc3Q7XG59KShUb3VjaCA9IGV4cG9ydHMuVG91Y2ggfHwgKGV4cG9ydHMuVG91Y2ggPSB7fSkpO1xuY2xhc3MgTGlua2VkTWFwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpc1tfYV0gPSAnTGlua2VkTWFwJztcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9oZWFkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl90YWlsID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9zaXplID0gMDtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSAwO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fbWFwLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2hlYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3RhaWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xuICAgICAgICB0aGlzLl9zdGF0ZSsrO1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuX2hlYWQgJiYgIXRoaXMuX3RhaWw7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVhZD8udmFsdWU7XG4gICAgfVxuICAgIGdldCBsYXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFpbD8udmFsdWU7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5oYXMoa2V5KTtcbiAgICB9XG4gICAgZ2V0KGtleSwgdG91Y2ggPSBUb3VjaC5Ob25lKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG91Y2ggIT09IFRvdWNoLk5vbmUpIHtcbiAgICAgICAgICAgIHRoaXMudG91Y2goaXRlbSwgdG91Y2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSwgdG91Y2ggPSBUb3VjaC5Ob25lKSB7XG4gICAgICAgIGxldCBpdGVtID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgaXRlbS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRvdWNoICE9PSBUb3VjaC5Ob25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b3VjaChpdGVtLCB0b3VjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVtID0geyBrZXksIHZhbHVlLCBuZXh0OiB1bmRlZmluZWQsIHByZXZpb3VzOiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgIHN3aXRjaCAodG91Y2gpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFRvdWNoLk5vbmU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUxhc3QoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVG91Y2guRmlyc3Q6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUZpcnN0KGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRvdWNoLkxhc3Q6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUxhc3QoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUxhc3QoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWFwLnNldChrZXksIGl0ZW0pO1xuICAgICAgICAgICAgdGhpcy5fc2l6ZSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMucmVtb3ZlKGtleSk7XG4gICAgfVxuICAgIHJlbW92ZShrZXkpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgdGhpcy5yZW1vdmVJdGVtKGl0ZW0pO1xuICAgICAgICB0aGlzLl9zaXplLS07XG4gICAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgIH1cbiAgICBzaGlmdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkICYmICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faGVhZCB8fCAhdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5faGVhZDtcbiAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShpdGVtLmtleSk7XG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbShpdGVtKTtcbiAgICAgICAgdGhpcy5fc2l6ZS0tO1xuICAgICAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgICB9XG4gICAgZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5faGVhZDtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzQXJnKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tmbi5iaW5kKHRoaXNBcmcpKGN1cnJlbnQudmFsdWUsIGN1cnJlbnQua2V5LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrZm4oY3VycmVudC52YWx1ZSwgY3VycmVudC5rZXksIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGlua2VkTWFwIGdvdCBtb2RpZmllZCBkdXJpbmcgaXRlcmF0aW9uLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBrZXlzKCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0ge1xuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl06ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaW5rZWRNYXAgZ290IG1vZGlmaWVkIGR1cmluZyBpdGVyYXRpb24uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgdmFsdWU6IGN1cnJlbnQua2V5LCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgIH1cbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5faGVhZDtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB7XG4gICAgICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExpbmtlZE1hcCBnb3QgbW9kaWZpZWQgZHVyaW5nIGl0ZXJhdGlvbi5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyB2YWx1ZTogY3VycmVudC52YWx1ZSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9XG4gICAgZW50cmllcygpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHtcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgIT09IHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGlua2VkTWFwIGdvdCBtb2RpZmllZCBkdXJpbmcgaXRlcmF0aW9uLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHZhbHVlOiBbY3VycmVudC5rZXksIGN1cnJlbnQudmFsdWVdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgIH1cbiAgICBbKF9hID0gU3ltYm9sLnRvU3RyaW5nVGFnLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcygpO1xuICAgIH1cbiAgICB0cmltT2xkKG5ld1NpemUpIHtcbiAgICAgICAgaWYgKG5ld1NpemUgPj0gdGhpcy5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1NpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIGxldCBjdXJyZW50U2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudFNpemUgPiBuZXdTaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGN1cnJlbnQua2V5KTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICBjdXJyZW50U2l6ZS0tO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hlYWQgPSBjdXJyZW50O1xuICAgICAgICB0aGlzLl9zaXplID0gY3VycmVudFNpemU7XG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICBjdXJyZW50LnByZXZpb3VzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgfVxuICAgIGFkZEl0ZW1GaXJzdChpdGVtKSB7XG4gICAgICAgIC8vIEZpcnN0IHRpbWUgSW5zZXJ0XG4gICAgICAgIGlmICghdGhpcy5faGVhZCAmJiAhdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2hlYWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVtLm5leHQgPSB0aGlzLl9oZWFkO1xuICAgICAgICAgICAgdGhpcy5faGVhZC5wcmV2aW91cyA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGVhZCA9IGl0ZW07XG4gICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgfVxuICAgIGFkZEl0ZW1MYXN0KGl0ZW0pIHtcbiAgICAgICAgLy8gRmlyc3QgdGltZSBJbnNlcnRcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkICYmICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMgPSB0aGlzLl90YWlsO1xuICAgICAgICAgICAgdGhpcy5fdGFpbC5uZXh0ID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90YWlsID0gaXRlbTtcbiAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICB9XG4gICAgcmVtb3ZlSXRlbShpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtID09PSB0aGlzLl9oZWFkICYmIGl0ZW0gPT09IHRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGl0ZW0gPT09IHRoaXMuX2hlYWQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuZWQgaWYgc2l6ZSA9PT0gMSB3aGljaCBpcyBoYW5kbGVcbiAgICAgICAgICAgIC8vIGJ5IHRoZSBjYXNlIGFib3ZlLlxuICAgICAgICAgICAgaWYgKCFpdGVtLm5leHQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbS5uZXh0LnByZXZpb3VzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IGl0ZW0ubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpdGVtID09PSB0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbmVkIGlmIHNpemUgPT09IDEgd2hpY2ggaXMgaGFuZGxlXG4gICAgICAgICAgICAvLyBieSB0aGUgY2FzZSBhYm92ZS5cbiAgICAgICAgICAgIGlmICghaXRlbS5wcmV2aW91cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtLnByZXZpb3VzLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gaXRlbS5wcmV2aW91cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBpdGVtLm5leHQ7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IGl0ZW0ucHJldmlvdXM7XG4gICAgICAgICAgICBpZiAoIW5leHQgfHwgIXByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGl0ZW0ubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaXRlbS5wcmV2aW91cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICB9XG4gICAgdG91Y2goaXRlbSwgdG91Y2gpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkIHx8ICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodG91Y2ggIT09IFRvdWNoLkZpcnN0ICYmIHRvdWNoICE9PSBUb3VjaC5MYXN0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3VjaCA9PT0gVG91Y2guRmlyc3QpIHtcbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl9oZWFkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGl0ZW0ubmV4dDtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gaXRlbS5wcmV2aW91cztcbiAgICAgICAgICAgIC8vIFVubGluayB0aGUgaXRlbVxuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IHRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgICAgICAvLyBwcmV2aW91cyBtdXN0IGJlIGRlZmluZWQgc2luY2UgaXRlbSB3YXMgbm90IGhlYWQgYnV0IGlzIHRhaWxcbiAgICAgICAgICAgICAgICAvLyBTbyB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uIGl0ZW0gaW4gdGhlIG1hcFxuICAgICAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFpbCA9IHByZXZpb3VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQm90aCBuZXh0IGFuZCBwcmV2aW91cyBhcmUgbm90IHVuZGVmaW5lZCBzaW5jZSBpdGVtIHdhcyBuZWl0aGVyIGhlYWQgbm9yIHRhaWwuXG4gICAgICAgICAgICAgICAgbmV4dC5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSBub2RlIGF0IGhlYWRcbiAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpdGVtLm5leHQgPSB0aGlzLl9oZWFkO1xuICAgICAgICAgICAgdGhpcy5faGVhZC5wcmV2aW91cyA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gaXRlbTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodG91Y2ggPT09IFRvdWNoLkxhc3QpIHtcbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGl0ZW0ubmV4dDtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gaXRlbS5wcmV2aW91cztcbiAgICAgICAgICAgIC8vIFVubGluayB0aGUgaXRlbS5cbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl9oZWFkKSB7XG4gICAgICAgICAgICAgICAgLy8gbmV4dCBtdXN0IGJlIGRlZmluZWQgc2luY2UgaXRlbSB3YXMgbm90IHRhaWwgYnV0IGlzIGhlYWRcbiAgICAgICAgICAgICAgICAvLyBTbyB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uIGl0ZW0gaW4gdGhlIG1hcFxuICAgICAgICAgICAgICAgIG5leHQucHJldmlvdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5faGVhZCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBCb3RoIG5leHQgYW5kIHByZXZpb3VzIGFyZSBub3QgdW5kZWZpbmVkIHNpbmNlIGl0ZW0gd2FzIG5laXRoZXIgaGVhZCBub3IgdGFpbC5cbiAgICAgICAgICAgICAgICBuZXh0LnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgICAgICAgICAgICAgcHJldmlvdXMubmV4dCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpdGVtLnByZXZpb3VzID0gdGhpcy5fdGFpbDtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwubmV4dCA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gaXRlbTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgIHRoaXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgZnJvbUpTT04oZGF0YSkge1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MaW5rZWRNYXAgPSBMaW5rZWRNYXA7XG5jbGFzcyBMUlVDYWNoZSBleHRlbmRzIExpbmtlZE1hcCB7XG4gICAgY29uc3RydWN0b3IobGltaXQsIHJhdGlvID0gMSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9saW1pdCA9IGxpbWl0O1xuICAgICAgICB0aGlzLl9yYXRpbyA9IE1hdGgubWluKE1hdGgubWF4KDAsIHJhdGlvKSwgMSk7XG4gICAgfVxuICAgIGdldCBsaW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbWl0O1xuICAgIH1cbiAgICBzZXQgbGltaXQobGltaXQpIHtcbiAgICAgICAgdGhpcy5fbGltaXQgPSBsaW1pdDtcbiAgICAgICAgdGhpcy5jaGVja1RyaW0oKTtcbiAgICB9XG4gICAgZ2V0IHJhdGlvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmF0aW87XG4gICAgfVxuICAgIHNldCByYXRpbyhyYXRpbykge1xuICAgICAgICB0aGlzLl9yYXRpbyA9IE1hdGgubWluKE1hdGgubWF4KDAsIHJhdGlvKSwgMSk7XG4gICAgICAgIHRoaXMuY2hlY2tUcmltKCk7XG4gICAgfVxuICAgIGdldChrZXksIHRvdWNoID0gVG91Y2guQXNOZXcpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldChrZXksIHRvdWNoKTtcbiAgICB9XG4gICAgcGVlayhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldChrZXksIFRvdWNoLk5vbmUpO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBzdXBlci5zZXQoa2V5LCB2YWx1ZSwgVG91Y2guTGFzdCk7XG4gICAgICAgIHRoaXMuY2hlY2tUcmltKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjaGVja1RyaW0oKSB7XG4gICAgICAgIGlmICh0aGlzLnNpemUgPiB0aGlzLl9saW1pdCkge1xuICAgICAgICAgICAgdGhpcy50cmltT2xkKE1hdGgucm91bmQodGhpcy5fbGltaXQgKiB0aGlzLl9yYXRpbykpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MUlVDYWNoZSA9IExSVUNhY2hlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NjUyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlQnVmZmVyID0gdm9pZCAwO1xuY29uc3QgQ1IgPSAxMztcbmNvbnN0IExGID0gMTA7XG5jb25zdCBDUkxGID0gJ1xcclxcbic7XG5jbGFzcyBBYnN0cmFjdE1lc3NhZ2VCdWZmZXIge1xuICAgIGNvbnN0cnVjdG9yKGVuY29kaW5nID0gJ3V0Zi04Jykge1xuICAgICAgICB0aGlzLl9lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgICAgICB0aGlzLl9jaHVua3MgPSBbXTtcbiAgICAgICAgdGhpcy5fdG90YWxMZW5ndGggPSAwO1xuICAgIH1cbiAgICBnZXQgZW5jb2RpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmNvZGluZztcbiAgICB9XG4gICAgYXBwZW5kKGNodW5rKSB7XG4gICAgICAgIGNvbnN0IHRvQXBwZW5kID0gdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJyA/IHRoaXMuZnJvbVN0cmluZyhjaHVuaywgdGhpcy5fZW5jb2RpbmcpIDogY2h1bms7XG4gICAgICAgIHRoaXMuX2NodW5rcy5wdXNoKHRvQXBwZW5kKTtcbiAgICAgICAgdGhpcy5fdG90YWxMZW5ndGggKz0gdG9BcHBlbmQuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgdHJ5UmVhZEhlYWRlcnMobG93ZXJDYXNlS2V5cyA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLl9jaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGF0ZSA9IDA7XG4gICAgICAgIGxldCBjaHVua0luZGV4ID0gMDtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGxldCBjaHVua0J5dGVzUmVhZCA9IDA7XG4gICAgICAgIHJvdzogd2hpbGUgKGNodW5rSW5kZXggPCB0aGlzLl9jaHVua3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2NodW5rc1tjaHVua0luZGV4XTtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICBjb2x1bW46IHdoaWxlIChvZmZzZXQgPCBjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNodW5rW29mZnNldF07XG4gICAgICAgICAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENSOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTEY6XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgcm93O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNodW5rQnl0ZXNSZWFkICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBjaHVua0luZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlICE9PSA0KSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBidWZmZXIgY29udGFpbnMgdGhlIHR3byBDUkxGIGF0IHRoZSBlbmQuIFNvIHdlIHdpbGxcbiAgICAgICAgLy8gaGF2ZSB0d28gZW1wdHkgbGluZXMgYWZ0ZXIgdGhlIHNwbGl0IGF0IHRoZSBlbmQgYXMgd2VsbC5cbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5fcmVhZChjaHVua0J5dGVzUmVhZCArIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMudG9TdHJpbmcoYnVmZmVyLCAnYXNjaWknKS5zcGxpdChDUkxGKTtcbiAgICAgICAgaWYgKGhlYWRlcnMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXIgPSBoZWFkZXJzW2ldO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBoZWFkZXIuaW5kZXhPZignOicpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWVzc2FnZSBoZWFkZXIgbXVzdCBzZXBhcmF0ZSBrZXkgYW5kIHZhbHVlIHVzaW5nIDonKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGhlYWRlci5zdWJzdHIoMCwgaW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBoZWFkZXIuc3Vic3RyKGluZGV4ICsgMSkudHJpbSgpO1xuICAgICAgICAgICAgcmVzdWx0LnNldChsb3dlckNhc2VLZXlzID8ga2V5LnRvTG93ZXJDYXNlKCkgOiBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0cnlSZWFkQm9keShsZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RvdGFsTGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkKGxlbmd0aCk7XG4gICAgfVxuICAgIGdldCBudW1iZXJPZkJ5dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG90YWxMZW5ndGg7XG4gICAgfVxuICAgIF9yZWFkKGJ5dGVDb3VudCkge1xuICAgICAgICBpZiAoYnl0ZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbXB0eUJ1ZmZlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChieXRlQ291bnQgPiB0aGlzLl90b3RhbExlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVhZCBzbyBtYW55IGJ5dGVzIWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jaHVua3NbMF0uYnl0ZUxlbmd0aCA9PT0gYnl0ZUNvdW50KSB7XG4gICAgICAgICAgICAvLyBzdXBlciBmYXN0IHBhdGgsIHByZWNpc2VseSBmaXJzdCBjaHVuayBtdXN0IGJlIHJldHVybmVkXG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2NodW5rc1swXTtcbiAgICAgICAgICAgIHRoaXMuX2NodW5rcy5zaGlmdCgpO1xuICAgICAgICAgICAgdGhpcy5fdG90YWxMZW5ndGggLT0gYnl0ZUNvdW50O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXNOYXRpdmUoY2h1bmspO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jaHVua3NbMF0uYnl0ZUxlbmd0aCA+IGJ5dGVDb3VudCkge1xuICAgICAgICAgICAgLy8gZmFzdCBwYXRoLCB0aGUgcmVhZGluZyBpcyBlbnRpcmVseSB3aXRoaW4gdGhlIGZpcnN0IGNodW5rXG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2NodW5rc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYXNOYXRpdmUoY2h1bmssIGJ5dGVDb3VudCk7XG4gICAgICAgICAgICB0aGlzLl9jaHVua3NbMF0gPSBjaHVuay5zbGljZShieXRlQ291bnQpO1xuICAgICAgICAgICAgdGhpcy5fdG90YWxMZW5ndGggLT0gYnl0ZUNvdW50O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmFsbG9jTmF0aXZlKGJ5dGVDb3VudCk7XG4gICAgICAgIGxldCByZXN1bHRPZmZzZXQgPSAwO1xuICAgICAgICBsZXQgY2h1bmtJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChieXRlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2NodW5rc1tjaHVua0luZGV4XTtcbiAgICAgICAgICAgIGlmIChjaHVuay5ieXRlTGVuZ3RoID4gYnl0ZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjaHVuayB3aWxsIHN1cnZpdmVcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVua1BhcnQgPSBjaHVuay5zbGljZSgwLCBieXRlQ291bnQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoY2h1bmtQYXJ0LCByZXN1bHRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdE9mZnNldCArPSBieXRlQ291bnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2h1bmtzW2NodW5rSW5kZXhdID0gY2h1bmsuc2xpY2UoYnl0ZUNvdW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLl90b3RhbExlbmd0aCAtPSBieXRlQ291bnQ7XG4gICAgICAgICAgICAgICAgYnl0ZUNvdW50IC09IGJ5dGVDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgY2h1bmsgd2lsbCBiZSBlbnRpcmVseSByZWFkXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChjaHVuaywgcmVzdWx0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICByZXN1bHRPZmZzZXQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaHVua3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90b3RhbExlbmd0aCAtPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJ5dGVDb3VudCAtPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VCdWZmZXIgPSBBYnN0cmFjdE1lc3NhZ2VCdWZmZXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ1MTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5SZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXIgPSBleHBvcnRzLkFic3RyYWN0TWVzc2FnZVJlYWRlciA9IGV4cG9ydHMuTWVzc2FnZVJlYWRlciA9IHZvaWQgMDtcbmNvbnN0IHJhbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NzA2KTtcbmNvbnN0IElzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4ODExKTtcbmNvbnN0IGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MTY1KTtcbmNvbnN0IHNlbWFwaG9yZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMzM5KTtcbnZhciBNZXNzYWdlUmVhZGVyO1xuKGZ1bmN0aW9uIChNZXNzYWdlUmVhZGVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLmZ1bmMoY2FuZGlkYXRlLmxpc3RlbikgJiYgSXMuZnVuYyhjYW5kaWRhdGUuZGlzcG9zZSkgJiZcbiAgICAgICAgICAgIElzLmZ1bmMoY2FuZGlkYXRlLm9uRXJyb3IpICYmIElzLmZ1bmMoY2FuZGlkYXRlLm9uQ2xvc2UpICYmIElzLmZ1bmMoY2FuZGlkYXRlLm9uUGFydGlhbE1lc3NhZ2UpO1xuICAgIH1cbiAgICBNZXNzYWdlUmVhZGVyLmlzID0gaXM7XG59KShNZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5NZXNzYWdlUmVhZGVyIHx8IChleHBvcnRzLk1lc3NhZ2VSZWFkZXIgPSB7fSkpO1xuY2xhc3MgQWJzdHJhY3RNZXNzYWdlUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lcnJvckVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgICAgICB0aGlzLmNsb3NlRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgICAgIHRoaXMucGFydGlhbE1lc3NhZ2VFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5lcnJvckVtaXR0ZXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmNsb3NlRW1pdHRlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGdldCBvbkVycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvckVtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGZpcmVFcnJvcihlcnJvcikge1xuICAgICAgICB0aGlzLmVycm9yRW1pdHRlci5maXJlKHRoaXMuYXNFcnJvcihlcnJvcikpO1xuICAgIH1cbiAgICBnZXQgb25DbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2VFbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBmaXJlQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VFbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICB9XG4gICAgZ2V0IG9uUGFydGlhbE1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnRpYWxNZXNzYWdlRW1pdHRlci5ldmVudDtcbiAgICB9XG4gICAgZmlyZVBhcnRpYWxNZXNzYWdlKGluZm8pIHtcbiAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZUVtaXR0ZXIuZmlyZShpbmZvKTtcbiAgICB9XG4gICAgYXNFcnJvcihlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgUmVhZGVyIHJlY2VpdmVkIGVycm9yLiBSZWFzb246ICR7SXMuc3RyaW5nKGVycm9yLm1lc3NhZ2UpID8gZXJyb3IubWVzc2FnZSA6ICd1bmtub3duJ31gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlUmVhZGVyID0gQWJzdHJhY3RNZXNzYWdlUmVhZGVyO1xudmFyIFJlc29sdmVkTWVzc2FnZVJlYWRlck9wdGlvbnM7XG4oZnVuY3Rpb24gKFJlc29sdmVkTWVzc2FnZVJlYWRlck9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBmcm9tT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGxldCBjaGFyc2V0O1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBsZXQgY29udGVudERlY29kZXI7XG4gICAgICAgIGNvbnN0IGNvbnRlbnREZWNvZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgbGV0IGNvbnRlbnRUeXBlRGVjb2RlcjtcbiAgICAgICAgY29uc3QgY29udGVudFR5cGVEZWNvZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNoYXJzZXQgPSBvcHRpb25zID8/ICd1dGYtOCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFyc2V0ID0gb3B0aW9ucy5jaGFyc2V0ID8/ICd1dGYtOCc7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb250ZW50RGVjb2RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGVudERlY29kZXIgPSBvcHRpb25zLmNvbnRlbnREZWNvZGVyO1xuICAgICAgICAgICAgICAgIGNvbnRlbnREZWNvZGVycy5zZXQoY29udGVudERlY29kZXIubmFtZSwgY29udGVudERlY29kZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29udGVudERlY29kZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRlY29kZXIgb2Ygb3B0aW9ucy5jb250ZW50RGVjb2RlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudERlY29kZXJzLnNldChkZWNvZGVyLm5hbWUsIGRlY29kZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbnRlbnRUeXBlRGVjb2RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVEZWNvZGVyID0gb3B0aW9ucy5jb250ZW50VHlwZURlY29kZXI7XG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVEZWNvZGVycy5zZXQoY29udGVudFR5cGVEZWNvZGVyLm5hbWUsIGNvbnRlbnRUeXBlRGVjb2Rlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb250ZW50VHlwZURlY29kZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRlY29kZXIgb2Ygb3B0aW9ucy5jb250ZW50VHlwZURlY29kZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlRGVjb2RlcnMuc2V0KGRlY29kZXIubmFtZSwgZGVjb2Rlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZW50VHlwZURlY29kZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGVudFR5cGVEZWNvZGVyID0gKDAsIHJhbF8xLmRlZmF1bHQpKCkuYXBwbGljYXRpb25Kc29uLmRlY29kZXI7XG4gICAgICAgICAgICBjb250ZW50VHlwZURlY29kZXJzLnNldChjb250ZW50VHlwZURlY29kZXIubmFtZSwgY29udGVudFR5cGVEZWNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjaGFyc2V0LCBjb250ZW50RGVjb2RlciwgY29udGVudERlY29kZXJzLCBjb250ZW50VHlwZURlY29kZXIsIGNvbnRlbnRUeXBlRGVjb2RlcnMgfTtcbiAgICB9XG4gICAgUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucy5mcm9tT3B0aW9ucyA9IGZyb21PcHRpb25zO1xufSkoUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucyB8fCAoUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucyA9IHt9KSk7XG5jbGFzcyBSZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXIgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VSZWFkZXIge1xuICAgIGNvbnN0cnVjdG9yKHJlYWRhYmxlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucmVhZGFibGUgPSByZWFkYWJsZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucy5mcm9tT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSAoMCwgcmFsXzEuZGVmYXVsdCkoKS5tZXNzYWdlQnVmZmVyLmNyZWF0ZSh0aGlzLm9wdGlvbnMuY2hhcnNldCk7XG4gICAgICAgIHRoaXMuX3BhcnRpYWxNZXNzYWdlVGltZW91dCA9IDEwMDAwO1xuICAgICAgICB0aGlzLm5leHRNZXNzYWdlTGVuZ3RoID0gLTE7XG4gICAgICAgIHRoaXMubWVzc2FnZVRva2VuID0gMDtcbiAgICAgICAgdGhpcy5yZWFkU2VtYXBob3JlID0gbmV3IHNlbWFwaG9yZV8xLlNlbWFwaG9yZSgxKTtcbiAgICB9XG4gICAgc2V0IHBhcnRpYWxNZXNzYWdlVGltZW91dCh0aW1lb3V0KSB7XG4gICAgICAgIHRoaXMuX3BhcnRpYWxNZXNzYWdlVGltZW91dCA9IHRpbWVvdXQ7XG4gICAgfVxuICAgIGdldCBwYXJ0aWFsTWVzc2FnZVRpbWVvdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJ0aWFsTWVzc2FnZVRpbWVvdXQ7XG4gICAgfVxuICAgIGxpc3RlbihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm5leHRNZXNzYWdlTGVuZ3RoID0gLTE7XG4gICAgICAgIHRoaXMubWVzc2FnZVRva2VuID0gMDtcbiAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucmVhZGFibGUub25EYXRhKChkYXRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uRGF0YShkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVhZGFibGUub25FcnJvcigoZXJyb3IpID0+IHRoaXMuZmlyZUVycm9yKGVycm9yKSk7XG4gICAgICAgIHRoaXMucmVhZGFibGUub25DbG9zZSgoKSA9PiB0aGlzLmZpcmVDbG9zZSgpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgb25EYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5idWZmZXIuYXBwZW5kKGRhdGEpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubmV4dE1lc3NhZ2VMZW5ndGggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuYnVmZmVyLnRyeVJlYWRIZWFkZXJzKHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBoZWFkZXJzLmdldCgnY29udGVudC1sZW5ndGgnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlRXJyb3IobmV3IEVycm9yKCdIZWFkZXIgbXVzdCBwcm92aWRlIGEgQ29udGVudC1MZW5ndGggcHJvcGVydHkuJykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KGNvbnRlbnRMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihsZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZUVycm9yKG5ldyBFcnJvcignQ29udGVudC1MZW5ndGggdmFsdWUgbXVzdCBiZSBhIG51bWJlci4nKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0TWVzc2FnZUxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLmJ1ZmZlci50cnlSZWFkQm9keSh0aGlzLm5leHRNZXNzYWdlTGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChib2R5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvKiogV2UgaGF2ZW4ndCByZWNlaXZlZCB0aGUgZnVsbCBtZXNzYWdlIHlldC4gKi9cbiAgICAgICAgICAgICAgICB0aGlzLnNldFBhcnRpYWxNZXNzYWdlVGltZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsZWFyUGFydGlhbE1lc3NhZ2VUaW1lcigpO1xuICAgICAgICAgICAgdGhpcy5uZXh0TWVzc2FnZUxlbmd0aCA9IC0xO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UgY29udmVydCBvbmUgcmVjZWl2ZWQgbWVzc2FnZSBhZnRlciB0aGVcbiAgICAgICAgICAgIC8vIG90aGVyLiBPdGhlcndpc2UgaXQgY291bGQgaGFwcGVuIHRoYXQgYSBkZWNvZGluZyBvZiBhIHNlY29uZFxuICAgICAgICAgICAgLy8gc21hbGxlciBtZXNzYWdlIGZpbmlzaGVkIGJlZm9yZSB0aGUgZGVjb2Rpbmcgb2YgYSBmaXJzdCBsYXJnZXJcbiAgICAgICAgICAgIC8vIG1lc3NhZ2UgYW5kIHRoZW4gd2Ugd291bGQgZGVsaXZlciB0aGUgc2Vjb25kIG1lc3NhZ2UgZmlyc3QuXG4gICAgICAgICAgICB0aGlzLnJlYWRTZW1hcGhvcmUubG9jayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSB0aGlzLm9wdGlvbnMuY29udGVudERlY29kZXIgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IGF3YWl0IHRoaXMub3B0aW9ucy5jb250ZW50RGVjb2Rlci5kZWNvZGUoYm9keSlcbiAgICAgICAgICAgICAgICAgICAgOiBib2R5O1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCB0aGlzLm9wdGlvbnMuY29udGVudFR5cGVEZWNvZGVyLmRlY29kZShieXRlcywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXJQYXJ0aWFsTWVzc2FnZVRpbWVyKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnRpYWxNZXNzYWdlVGltZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFBhcnRpYWxNZXNzYWdlVGltZXIoKSB7XG4gICAgICAgIHRoaXMuY2xlYXJQYXJ0aWFsTWVzc2FnZVRpbWVyKCk7XG4gICAgICAgIGlmICh0aGlzLl9wYXJ0aWFsTWVzc2FnZVRpbWVvdXQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFydGlhbE1lc3NhZ2VUaW1lciA9ICgwLCByYWxfMS5kZWZhdWx0KSgpLnRpbWVyLnNldFRpbWVvdXQoKHRva2VuLCB0aW1lb3V0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRpYWxNZXNzYWdlVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IHRoaXMubWVzc2FnZVRva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlUGFydGlhbE1lc3NhZ2UoeyBtZXNzYWdlVG9rZW46IHRva2VuLCB3YWl0aW5nVGltZTogdGltZW91dCB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFBhcnRpYWxNZXNzYWdlVGltZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5fcGFydGlhbE1lc3NhZ2VUaW1lb3V0LCB0aGlzLm1lc3NhZ2VUb2tlbiwgdGhpcy5fcGFydGlhbE1lc3NhZ2VUaW1lb3V0KTtcbiAgICB9XG59XG5leHBvcnRzLlJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlciA9IFJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTI1MTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5Xcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyID0gZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLk1lc3NhZ2VXcml0ZXIgPSB2b2lkIDA7XG5jb25zdCByYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTcwNik7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oODgxMSk7XG5jb25zdCBzZW1hcGhvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjMzOSk7XG5jb25zdCBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTE2NSk7XG5jb25zdCBDb250ZW50TGVuZ3RoID0gJ0NvbnRlbnQtTGVuZ3RoOiAnO1xuY29uc3QgQ1JMRiA9ICdcXHJcXG4nO1xudmFyIE1lc3NhZ2VXcml0ZXI7XG4oZnVuY3Rpb24gKE1lc3NhZ2VXcml0ZXIpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuZnVuYyhjYW5kaWRhdGUuZGlzcG9zZSkgJiYgSXMuZnVuYyhjYW5kaWRhdGUub25DbG9zZSkgJiZcbiAgICAgICAgICAgIElzLmZ1bmMoY2FuZGlkYXRlLm9uRXJyb3IpICYmIElzLmZ1bmMoY2FuZGlkYXRlLndyaXRlKTtcbiAgICB9XG4gICAgTWVzc2FnZVdyaXRlci5pcyA9IGlzO1xufSkoTWVzc2FnZVdyaXRlciA9IGV4cG9ydHMuTWVzc2FnZVdyaXRlciB8fCAoZXhwb3J0cy5NZXNzYWdlV3JpdGVyID0ge30pKTtcbmNsYXNzIEFic3RyYWN0TWVzc2FnZVdyaXRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZXJyb3JFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5jbG9zZUVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLmVycm9yRW1pdHRlci5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuY2xvc2VFbWl0dGVyLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgZ2V0IG9uRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yRW1pdHRlci5ldmVudDtcbiAgICB9XG4gICAgZmlyZUVycm9yKGVycm9yLCBtZXNzYWdlLCBjb3VudCkge1xuICAgICAgICB0aGlzLmVycm9yRW1pdHRlci5maXJlKFt0aGlzLmFzRXJyb3IoZXJyb3IpLCBtZXNzYWdlLCBjb3VudF0pO1xuICAgIH1cbiAgICBnZXQgb25DbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2VFbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBmaXJlQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VFbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICB9XG4gICAgYXNFcnJvcihlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgV3JpdGVyIHJlY2VpdmVkIGVycm9yLiBSZWFzb246ICR7SXMuc3RyaW5nKGVycm9yLm1lc3NhZ2UpID8gZXJyb3IubWVzc2FnZSA6ICd1bmtub3duJ31gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlV3JpdGVyID0gQWJzdHJhY3RNZXNzYWdlV3JpdGVyO1xudmFyIFJlc29sdmVkTWVzc2FnZVdyaXRlck9wdGlvbnM7XG4oZnVuY3Rpb24gKFJlc29sdmVkTWVzc2FnZVdyaXRlck9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBmcm9tT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFyc2V0OiBvcHRpb25zID8/ICd1dGYtOCcsIGNvbnRlbnRUeXBlRW5jb2RlcjogKDAsIHJhbF8xLmRlZmF1bHQpKCkuYXBwbGljYXRpb25Kc29uLmVuY29kZXIgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNoYXJzZXQ6IG9wdGlvbnMuY2hhcnNldCA/PyAndXRmLTgnLCBjb250ZW50RW5jb2Rlcjogb3B0aW9ucy5jb250ZW50RW5jb2RlciwgY29udGVudFR5cGVFbmNvZGVyOiBvcHRpb25zLmNvbnRlbnRUeXBlRW5jb2RlciA/PyAoMCwgcmFsXzEuZGVmYXVsdCkoKS5hcHBsaWNhdGlvbkpzb24uZW5jb2RlciB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIFJlc29sdmVkTWVzc2FnZVdyaXRlck9wdGlvbnMuZnJvbU9wdGlvbnMgPSBmcm9tT3B0aW9ucztcbn0pKFJlc29sdmVkTWVzc2FnZVdyaXRlck9wdGlvbnMgfHwgKFJlc29sdmVkTWVzc2FnZVdyaXRlck9wdGlvbnMgPSB7fSkpO1xuY2xhc3MgV3JpdGVhYmxlU3RyZWFtTWVzc2FnZVdyaXRlciBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVdyaXRlciB7XG4gICAgY29uc3RydWN0b3Iod3JpdGFibGUsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IHdyaXRhYmxlO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBSZXNvbHZlZE1lc3NhZ2VXcml0ZXJPcHRpb25zLmZyb21PcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmVycm9yQ291bnQgPSAwO1xuICAgICAgICB0aGlzLndyaXRlU2VtYXBob3JlID0gbmV3IHNlbWFwaG9yZV8xLlNlbWFwaG9yZSgxKTtcbiAgICAgICAgdGhpcy53cml0YWJsZS5vbkVycm9yKChlcnJvcikgPT4gdGhpcy5maXJlRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgdGhpcy53cml0YWJsZS5vbkNsb3NlKCgpID0+IHRoaXMuZmlyZUNsb3NlKCkpO1xuICAgIH1cbiAgICBhc3luYyB3cml0ZShtc2cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVTZW1hcGhvcmUubG9jayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gdGhpcy5vcHRpb25zLmNvbnRlbnRUeXBlRW5jb2Rlci5lbmNvZGUobXNnLCB0aGlzLm9wdGlvbnMpLnRoZW4oKGJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29udGVudEVuY29kZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmNvbnRlbnRFbmNvZGVyLmVuY29kZShidWZmZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkLnRoZW4oKGJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLnB1c2goQ29udGVudExlbmd0aCwgYnVmZmVyLmJ5dGVMZW5ndGgudG9TdHJpbmcoKSwgQ1JMRik7XG4gICAgICAgICAgICAgICAgaGVhZGVycy5wdXNoKENSTEYpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRvV3JpdGUobXNnLCBoZWFkZXJzLCBidWZmZXIpO1xuICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBkb1dyaXRlKG1zZywgaGVhZGVycywgZGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy53cml0YWJsZS53cml0ZShoZWFkZXJzLmpvaW4oJycpLCAnYXNjaWknKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndyaXRhYmxlLndyaXRlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlcnJvciwgbXNnKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlRXJyb3IoZXJyb3IsIG1zZykge1xuICAgICAgICB0aGlzLmVycm9yQ291bnQrKztcbiAgICAgICAgdGhpcy5maXJlRXJyb3IoZXJyb3IsIG1zZywgdGhpcy5lcnJvckNvdW50KTtcbiAgICB9XG4gICAgZW5kKCkge1xuICAgICAgICB0aGlzLndyaXRhYmxlLmVuZCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuV3JpdGVhYmxlU3RyZWFtTWVzc2FnZVdyaXRlciA9IFdyaXRlYWJsZVN0cmVhbU1lc3NhZ2VXcml0ZXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkxNDE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuTWVzc2FnZSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTkgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU4ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNyA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTYgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU1ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNCA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTMgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUyID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTAgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUgPSBleHBvcnRzLlJlcXVlc3RUeXBlOSA9IGV4cG9ydHMuUmVxdWVzdFR5cGU4ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTcgPSBleHBvcnRzLlJlcXVlc3RUeXBlNiA9IGV4cG9ydHMuUmVxdWVzdFR5cGU1ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTQgPSBleHBvcnRzLlJlcXVlc3RUeXBlMyA9IGV4cG9ydHMuUmVxdWVzdFR5cGUyID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTEgPSBleHBvcnRzLlJlcXVlc3RUeXBlID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTAgPSBleHBvcnRzLkFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSA9IGV4cG9ydHMuUGFyYW1ldGVyU3RydWN0dXJlcyA9IGV4cG9ydHMuUmVzcG9uc2VFcnJvciA9IGV4cG9ydHMuRXJyb3JDb2RlcyA9IHZvaWQgMDtcbmNvbnN0IGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4ODExKTtcbi8qKlxuICogUHJlZGVmaW5lZCBlcnJvciBjb2Rlcy5cbiAqL1xudmFyIEVycm9yQ29kZXM7XG4oZnVuY3Rpb24gKEVycm9yQ29kZXMpIHtcbiAgICAvLyBEZWZpbmVkIGJ5IEpTT04gUlBDXG4gICAgRXJyb3JDb2Rlcy5QYXJzZUVycm9yID0gLTMyNzAwO1xuICAgIEVycm9yQ29kZXMuSW52YWxpZFJlcXVlc3QgPSAtMzI2MDA7XG4gICAgRXJyb3JDb2Rlcy5NZXRob2ROb3RGb3VuZCA9IC0zMjYwMTtcbiAgICBFcnJvckNvZGVzLkludmFsaWRQYXJhbXMgPSAtMzI2MDI7XG4gICAgRXJyb3JDb2Rlcy5JbnRlcm5hbEVycm9yID0gLTMyNjAzO1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIHN0YXJ0IHJhbmdlIG9mIEpTT04gUlBDIHJlc2VydmVkIGVycm9yIGNvZGVzLlxuICAgICAqIEl0IGRvZXNuJ3QgZGVub3RlIGEgcmVhbCBlcnJvciBjb2RlLiBObyBhcHBsaWNhdGlvbiBlcnJvciBjb2RlcyBzaG91bGRcbiAgICAgKiBiZSBkZWZpbmVkIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgcmFuZ2UuIEZvciBiYWNrd2FyZHNcbiAgICAgKiBjb21wYXRpYmlsaXR5IHRoZSBgU2VydmVyTm90SW5pdGlhbGl6ZWRgIGFuZCB0aGUgYFVua25vd25FcnJvckNvZGVgXG4gICAgICogYXJlIGxlZnQgaW4gdGhlIHJhbmdlLlxuICAgICAqXG4gICAgICogQHNpbmNlIDMuMTYuMFxuICAgICovXG4gICAgRXJyb3JDb2Rlcy5qc29ucnBjUmVzZXJ2ZWRFcnJvclJhbmdlU3RhcnQgPSAtMzIwOTk7XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSAganNvbnJwY1Jlc2VydmVkRXJyb3JSYW5nZVN0YXJ0ICovXG4gICAgRXJyb3JDb2Rlcy5zZXJ2ZXJFcnJvclN0YXJ0ID0gLTMyMDk5O1xuICAgIC8qKlxuICAgICAqIEFuIGVycm9yIG9jY3VycmVkIHdoZW4gd3JpdGUgYSBtZXNzYWdlIHRvIHRoZSB0cmFuc3BvcnQgbGF5ZXIuXG4gICAgICovXG4gICAgRXJyb3JDb2Rlcy5NZXNzYWdlV3JpdGVFcnJvciA9IC0zMjA5OTtcbiAgICAvKipcbiAgICAgKiBBbiBlcnJvciBvY2N1cnJlZCB3aGVuIHJlYWRpbmcgYSBtZXNzYWdlIGZyb20gdGhlIHRyYW5zcG9ydCBsYXllci5cbiAgICAgKi9cbiAgICBFcnJvckNvZGVzLk1lc3NhZ2VSZWFkRXJyb3IgPSAtMzIwOTg7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbm5lY3Rpb24gZ290IGRpc3Bvc2VkIG9yIGxvc3QgYW5kIGFsbCBwZW5kaW5nIHJlc3BvbnNlcyBnb3RcbiAgICAgKiByZWplY3RlZC5cbiAgICAgKi9cbiAgICBFcnJvckNvZGVzLlBlbmRpbmdSZXNwb25zZVJlamVjdGVkID0gLTMyMDk3O1xuICAgIC8qKlxuICAgICAqIFRoZSBjb25uZWN0aW9uIGlzIGluYWN0aXZlIGFuZCBhIHVzZSBvZiBpdCBmYWlsZWQuXG4gICAgICovXG4gICAgRXJyb3JDb2Rlcy5Db25uZWN0aW9uSW5hY3RpdmUgPSAtMzIwOTY7XG4gICAgLyoqXG4gICAgICogRXJyb3IgY29kZSBpbmRpY2F0aW5nIHRoYXQgYSBzZXJ2ZXIgcmVjZWl2ZWQgYSBub3RpZmljYXRpb24gb3JcbiAgICAgKiByZXF1ZXN0IGJlZm9yZSB0aGUgc2VydmVyIGhhcyByZWNlaXZlZCB0aGUgYGluaXRpYWxpemVgIHJlcXVlc3QuXG4gICAgICovXG4gICAgRXJyb3JDb2Rlcy5TZXJ2ZXJOb3RJbml0aWFsaXplZCA9IC0zMjAwMjtcbiAgICBFcnJvckNvZGVzLlVua25vd25FcnJvckNvZGUgPSAtMzIwMDE7XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgZW5kIHJhbmdlIG9mIEpTT04gUlBDIHJlc2VydmVkIGVycm9yIGNvZGVzLlxuICAgICAqIEl0IGRvZXNuJ3QgZGVub3RlIGEgcmVhbCBlcnJvciBjb2RlLlxuICAgICAqXG4gICAgICogQHNpbmNlIDMuMTYuMFxuICAgICovXG4gICAgRXJyb3JDb2Rlcy5qc29ucnBjUmVzZXJ2ZWRFcnJvclJhbmdlRW5kID0gLTMyMDAwO1xuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgIGpzb25ycGNSZXNlcnZlZEVycm9yUmFuZ2VFbmQgKi9cbiAgICBFcnJvckNvZGVzLnNlcnZlckVycm9yRW5kID0gLTMyMDAwO1xufSkoRXJyb3JDb2RlcyA9IGV4cG9ydHMuRXJyb3JDb2RlcyB8fCAoZXhwb3J0cy5FcnJvckNvZGVzID0ge30pKTtcbi8qKlxuICogQW4gZXJyb3Igb2JqZWN0IHJldHVybiBpbiBhIHJlc3BvbnNlIGluIGNhc2UgYSByZXF1ZXN0XG4gKiBoYXMgZmFpbGVkLlxuICovXG5jbGFzcyBSZXNwb25zZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2UsIGRhdGEpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY29kZSA9IGlzLm51bWJlcihjb2RlKSA/IGNvZGUgOiBFcnJvckNvZGVzLlVua25vd25FcnJvckNvZGU7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBSZXNwb25zZUVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIHRvSnNvbigpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgY29kZTogdGhpcy5jb2RlLFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLlJlc3BvbnNlRXJyb3IgPSBSZXNwb25zZUVycm9yO1xuY2xhc3MgUGFyYW1ldGVyU3RydWN0dXJlcyB7XG4gICAgY29uc3RydWN0b3Ioa2luZCkge1xuICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgIH1cbiAgICBzdGF0aWMgaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG8gfHwgdmFsdWUgPT09IFBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lIHx8IHZhbHVlID09PSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5UG9zaXRpb247XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5raW5kO1xuICAgIH1cbn1cbmV4cG9ydHMuUGFyYW1ldGVyU3RydWN0dXJlcyA9IFBhcmFtZXRlclN0cnVjdHVyZXM7XG4vKipcbiAqIFRoZSBwYXJhbWV0ZXIgc3RydWN0dXJlIGlzIGF1dG9tYXRpY2FsbHkgaW5mZXJyZWQgb24gdGhlIG51bWJlciBvZiBwYXJhbWV0ZXJzXG4gKiBhbmQgdGhlIHBhcmFtZXRlciB0eXBlIGluIGNhc2Ugb2YgYSBzaW5nbGUgcGFyYW0uXG4gKi9cblBhcmFtZXRlclN0cnVjdHVyZXMuYXV0byA9IG5ldyBQYXJhbWV0ZXJTdHJ1Y3R1cmVzKCdhdXRvJyk7XG4vKipcbiAqIEZvcmNlcyBgYnlQb3NpdGlvbmAgcGFyYW1ldGVyIHN0cnVjdHVyZS4gVGhpcyBpcyB1c2VmdWwgaWYgeW91IGhhdmUgYSBzaW5nbGVcbiAqIHBhcmFtZXRlciB3aGljaCBoYXMgYSBsaXRlcmFsIHR5cGUuXG4gKi9cblBhcmFtZXRlclN0cnVjdHVyZXMuYnlQb3NpdGlvbiA9IG5ldyBQYXJhbWV0ZXJTdHJ1Y3R1cmVzKCdieVBvc2l0aW9uJyk7XG4vKipcbiAqIEZvcmNlcyBgYnlOYW1lYCBwYXJhbWV0ZXIgc3RydWN0dXJlLiBUaGlzIGlzIG9ubHkgdXNlZnVsIHdoZW4gaGF2aW5nIGEgc2luZ2xlXG4gKiBwYXJhbWV0ZXIuIFRoZSBsaWJyYXJ5IHdpbGwgcmVwb3J0IGVycm9ycyBpZiB1c2VkIHdpdGggYSBkaWZmZXJlbnQgbnVtYmVyIG9mXG4gKiBwYXJhbWV0ZXJzLlxuICovXG5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSA9IG5ldyBQYXJhbWV0ZXJTdHJ1Y3R1cmVzKCdieU5hbWUnKTtcbi8qKlxuICogQW4gYWJzdHJhY3QgaW1wbGVtZW50YXRpb24gb2YgYSBNZXNzYWdlVHlwZS5cbiAqL1xuY2xhc3MgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QsIG51bWJlck9mUGFyYW1zKSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICB0aGlzLm51bWJlck9mUGFyYW1zID0gbnVtYmVyT2ZQYXJhbXM7XG4gICAgfVxuICAgIGdldCBwYXJhbWV0ZXJTdHJ1Y3R1cmVzKCkge1xuICAgICAgICByZXR1cm4gUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvO1xuICAgIH1cbn1cbmV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlID0gQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlO1xuLyoqXG4gKiBDbGFzc2VzIHRvIHR5cGUgcmVxdWVzdCByZXNwb25zZSBwYWlyc1xuICovXG5jbGFzcyBSZXF1ZXN0VHlwZTAgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDApO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGUwID0gUmVxdWVzdFR5cGUwO1xuY2xhc3MgUmVxdWVzdFR5cGUgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG8pIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAxKTtcbiAgICAgICAgdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcyA9IF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbiAgICBnZXQgcGFyYW1ldGVyU3RydWN0dXJlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZSA9IFJlcXVlc3RUeXBlO1xuY2xhc3MgUmVxdWVzdFR5cGUxIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QsIF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMSk7XG4gICAgICAgIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBfcGFyYW1ldGVyU3RydWN0dXJlcztcbiAgICB9XG4gICAgZ2V0IHBhcmFtZXRlclN0cnVjdHVyZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGUxID0gUmVxdWVzdFR5cGUxO1xuY2xhc3MgUmVxdWVzdFR5cGUyIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAyKTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlMiA9IFJlcXVlc3RUeXBlMjtcbmNsYXNzIFJlcXVlc3RUeXBlMyBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMyk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTMgPSBSZXF1ZXN0VHlwZTM7XG5jbGFzcyBSZXF1ZXN0VHlwZTQgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDQpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGU0ID0gUmVxdWVzdFR5cGU0O1xuY2xhc3MgUmVxdWVzdFR5cGU1IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA1KTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlNSA9IFJlcXVlc3RUeXBlNTtcbmNsYXNzIFJlcXVlc3RUeXBlNiBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNik7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTYgPSBSZXF1ZXN0VHlwZTY7XG5jbGFzcyBSZXF1ZXN0VHlwZTcgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDcpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGU3ID0gUmVxdWVzdFR5cGU3O1xuY2xhc3MgUmVxdWVzdFR5cGU4IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA4KTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlOCA9IFJlcXVlc3RUeXBlODtcbmNsYXNzIFJlcXVlc3RUeXBlOSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgOSk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTkgPSBSZXF1ZXN0VHlwZTk7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QsIF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMSk7XG4gICAgICAgIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBfcGFyYW1ldGVyU3RydWN0dXJlcztcbiAgICB9XG4gICAgZ2V0IHBhcmFtZXRlclN0cnVjdHVyZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZSA9IE5vdGlmaWNhdGlvblR5cGU7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlMCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMCk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMCA9IE5vdGlmaWNhdGlvblR5cGUwO1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTEgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG8pIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAxKTtcbiAgICAgICAgdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcyA9IF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbiAgICBnZXQgcGFyYW1ldGVyU3RydWN0dXJlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMSA9IE5vdGlmaWNhdGlvblR5cGUxO1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTIgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDIpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTIgPSBOb3RpZmljYXRpb25UeXBlMjtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGUzIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAzKTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGUzID0gTm90aWZpY2F0aW9uVHlwZTM7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlNCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNCk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNCA9IE5vdGlmaWNhdGlvblR5cGU0O1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTUgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDUpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTUgPSBOb3RpZmljYXRpb25UeXBlNTtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGU2IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA2KTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGU2ID0gTm90aWZpY2F0aW9uVHlwZTY7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlNyBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNyk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNyA9IE5vdGlmaWNhdGlvblR5cGU3O1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTggZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDgpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTggPSBOb3RpZmljYXRpb25UeXBlODtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGU5IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA5KTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGU5ID0gTm90aWZpY2F0aW9uVHlwZTk7XG52YXIgTWVzc2FnZTtcbihmdW5jdGlvbiAoTWVzc2FnZSkge1xuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoZSBnaXZlbiBtZXNzYWdlIGlzIGEgcmVxdWVzdCBtZXNzYWdlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNSZXF1ZXN0KG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gbWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBpcy5zdHJpbmcoY2FuZGlkYXRlLm1ldGhvZCkgJiYgKGlzLnN0cmluZyhjYW5kaWRhdGUuaWQpIHx8IGlzLm51bWJlcihjYW5kaWRhdGUuaWQpKTtcbiAgICB9XG4gICAgTWVzc2FnZS5pc1JlcXVlc3QgPSBpc1JlcXVlc3Q7XG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhlIGdpdmVuIG1lc3NhZ2UgaXMgYSBub3RpZmljYXRpb24gbWVzc2FnZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTm90aWZpY2F0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gbWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBpcy5zdHJpbmcoY2FuZGlkYXRlLm1ldGhvZCkgJiYgbWVzc2FnZS5pZCA9PT0gdm9pZCAwO1xuICAgIH1cbiAgICBNZXNzYWdlLmlzTm90aWZpY2F0aW9uID0gaXNOb3RpZmljYXRpb247XG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhlIGdpdmVuIG1lc3NhZ2UgaXMgYSByZXNwb25zZSBtZXNzYWdlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNSZXNwb25zZShtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IG1lc3NhZ2U7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgKGNhbmRpZGF0ZS5yZXN1bHQgIT09IHZvaWQgMCB8fCAhIWNhbmRpZGF0ZS5lcnJvcikgJiYgKGlzLnN0cmluZyhjYW5kaWRhdGUuaWQpIHx8IGlzLm51bWJlcihjYW5kaWRhdGUuaWQpIHx8IGNhbmRpZGF0ZS5pZCA9PT0gbnVsbCk7XG4gICAgfVxuICAgIE1lc3NhZ2UuaXNSZXNwb25zZSA9IGlzUmVzcG9uc2U7XG59KShNZXNzYWdlID0gZXhwb3J0cy5NZXNzYWdlIHx8IChleHBvcnRzLk1lc3NhZ2UgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1NzA2OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5sZXQgX3JhbDtcbmZ1bmN0aW9uIFJBTCgpIHtcbiAgICBpZiAoX3JhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gcnVudGltZSBhYnN0cmFjdGlvbiBsYXllciBpbnN0YWxsZWRgKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yYWw7XG59XG4oZnVuY3Rpb24gKFJBTCkge1xuICAgIGZ1bmN0aW9uIGluc3RhbGwocmFsKSB7XG4gICAgICAgIGlmIChyYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBydW50aW1lIGFic3RyYWN0aW9uIGxheWVyIHByb3ZpZGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgX3JhbCA9IHJhbDtcbiAgICB9XG4gICAgUkFMLmluc3RhbGwgPSBpbnN0YWxsO1xufSkoUkFMIHx8IChSQUwgPSB7fSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBSQUw7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDIzMzk6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuU2VtYXBob3JlID0gdm9pZCAwO1xuY29uc3QgcmFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3MDYpO1xuY2xhc3MgU2VtYXBob3JlIHtcbiAgICBjb25zdHJ1Y3RvcihjYXBhY2l0eSA9IDEpIHtcbiAgICAgICAgaWYgKGNhcGFjaXR5IDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FwYWNpdHkgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhcGFjaXR5ID0gY2FwYWNpdHk7XG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IDA7XG4gICAgICAgIHRoaXMuX3dhaXRpbmcgPSBbXTtcbiAgICB9XG4gICAgbG9jayh0aHVuaykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fd2FpdGluZy5wdXNoKHsgdGh1bmssIHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICAgICAgICAgIHRoaXMucnVuTmV4dCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGFjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgICB9XG4gICAgcnVuTmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dhaXRpbmcubGVuZ3RoID09PSAwIHx8IHRoaXMuX2FjdGl2ZSA9PT0gdGhpcy5fY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAoMCwgcmFsXzEuZGVmYXVsdCkoKS50aW1lci5zZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5kb1J1bk5leHQoKSk7XG4gICAgfVxuICAgIGRvUnVuTmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dhaXRpbmcubGVuZ3RoID09PSAwIHx8IHRoaXMuX2FjdGl2ZSA9PT0gdGhpcy5fY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5fd2FpdGluZy5zaGlmdCgpO1xuICAgICAgICB0aGlzLl9hY3RpdmUrKztcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZSA+IHRoaXMuX2NhcGFjaXR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvIG1hbnkgdGh1bmtzIGFjdGl2ZWApO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXh0LnRodW5rKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmUtLTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5OZXh0KCk7XG4gICAgICAgICAgICAgICAgfSwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmUtLTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5OZXh0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmUtLTtcbiAgICAgICAgICAgICAgICBuZXh0LnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bk5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmUtLTtcbiAgICAgICAgICAgIG5leHQucmVqZWN0KGVycik7XG4gICAgICAgICAgICB0aGlzLnJ1bk5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU2VtYXBob3JlID0gU2VtYXBob3JlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNzg6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5ID0gZXhwb3J0cy5TaGFyZWRBcnJheVNlbmRlclN0cmF0ZWd5ID0gdm9pZCAwO1xuY29uc3QgY2FuY2VsbGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxNSk7XG52YXIgQ2FuY2VsbGF0aW9uU3RhdGU7XG4oZnVuY3Rpb24gKENhbmNlbGxhdGlvblN0YXRlKSB7XG4gICAgQ2FuY2VsbGF0aW9uU3RhdGUuQ29udGludWUgPSAwO1xuICAgIENhbmNlbGxhdGlvblN0YXRlLkNhbmNlbGxlZCA9IDE7XG59KShDYW5jZWxsYXRpb25TdGF0ZSB8fCAoQ2FuY2VsbGF0aW9uU3RhdGUgPSB7fSkpO1xuY2xhc3MgU2hhcmVkQXJyYXlTZW5kZXJTdHJhdGVneSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgZW5hYmxlQ2FuY2VsbGF0aW9uKHJlcXVlc3QpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QuaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgU2hhcmVkQXJyYXlCdWZmZXIoNCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgSW50MzJBcnJheShidWZmZXIsIDAsIDEpO1xuICAgICAgICBkYXRhWzBdID0gQ2FuY2VsbGF0aW9uU3RhdGUuQ29udGludWU7XG4gICAgICAgIHRoaXMuYnVmZmVycy5zZXQocmVxdWVzdC5pZCwgYnVmZmVyKTtcbiAgICAgICAgcmVxdWVzdC4kY2FuY2VsbGF0aW9uRGF0YSA9IGJ1ZmZlcjtcbiAgICB9XG4gICAgYXN5bmMgc2VuZENhbmNlbGxhdGlvbihfY29ubiwgaWQpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5idWZmZXJzLmdldChpZCk7XG4gICAgICAgIGlmIChidWZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgSW50MzJBcnJheShidWZmZXIsIDAsIDEpO1xuICAgICAgICBBdG9taWNzLnN0b3JlKGRhdGEsIDAsIENhbmNlbGxhdGlvblN0YXRlLkNhbmNlbGxlZCk7XG4gICAgfVxuICAgIGNsZWFudXAoaWQpIHtcbiAgICAgICAgdGhpcy5idWZmZXJzLmRlbGV0ZShpZCk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuYnVmZmVycy5jbGVhcigpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2hhcmVkQXJyYXlTZW5kZXJTdHJhdGVneSA9IFNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3k7XG5jbGFzcyBTaGFyZWRBcnJheUJ1ZmZlckNhbmNlbGxhdGlvblRva2VuIHtcbiAgICBjb25zdHJ1Y3RvcihidWZmZXIpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IEludDMyQXJyYXkoYnVmZmVyLCAwLCAxKTtcbiAgICB9XG4gICAgZ2V0IGlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCkge1xuICAgICAgICByZXR1cm4gQXRvbWljcy5sb2FkKHRoaXMuZGF0YSwgMCkgPT09IENhbmNlbGxhdGlvblN0YXRlLkNhbmNlbGxlZDtcbiAgICB9XG4gICAgZ2V0IG9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbmNlbGxhdGlvbiBvdmVyIFNoYXJlZEFycmF5QnVmZmVyIGRvZXNuJ3Qgc3VwcG9ydCBjYW5jZWxsYXRpb24gZXZlbnRzYCk7XG4gICAgfVxufVxuY2xhc3MgU2hhcmVkQXJyYXlCdWZmZXJDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyKSB7XG4gICAgICAgIHRoaXMudG9rZW4gPSBuZXcgU2hhcmVkQXJyYXlCdWZmZXJDYW5jZWxsYXRpb25Ub2tlbihidWZmZXIpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgfVxufVxuY2xhc3MgU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5raW5kID0gJ3JlcXVlc3QnO1xuICAgIH1cbiAgICBjcmVhdGVDYW5jZWxsYXRpb25Ub2tlblNvdXJjZShyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHJlcXVlc3QuJGNhbmNlbGxhdGlvbkRhdGE7XG4gICAgICAgIGlmIChidWZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBjYW5jZWxsYXRpb25fMS5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2hhcmVkQXJyYXlCdWZmZXJDYW5jZWxsYXRpb25Ub2tlblNvdXJjZShidWZmZXIpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5ID0gU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNzg5OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOTQpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMjk0OlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5jcmVhdGVQcm90b2NvbENvbm5lY3Rpb24gPSB2b2lkIDA7XG5jb25zdCBicm93c2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMDApO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMTIwMCksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oOTM3MiksIGV4cG9ydHMpO1xuZnVuY3Rpb24gY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uKHJlYWRlciwgd3JpdGVyLCBsb2dnZXIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKDAsIGJyb3dzZXJfMS5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbikocmVhZGVyLCB3cml0ZXIsIGxvZ2dlciwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbiA9IGNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTM3Mjpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuTFNQRXJyb3JDb2RlcyA9IGV4cG9ydHMuY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uID0gdm9pZCAwO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oNTk1MyksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oNDc2NyksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oODU5OSksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oNjUyNSksIGV4cG9ydHMpO1xudmFyIGNvbm5lY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjc5OCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVQcm90b2NvbENvbm5lY3Rpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uOyB9IH0pKTtcbnZhciBMU1BFcnJvckNvZGVzO1xuKGZ1bmN0aW9uIChMU1BFcnJvckNvZGVzKSB7XG4gICAgLyoqXG4gICAgKiBUaGlzIGlzIHRoZSBzdGFydCByYW5nZSBvZiBMU1AgcmVzZXJ2ZWQgZXJyb3IgY29kZXMuXG4gICAgKiBJdCBkb2Vzbid0IGRlbm90ZSBhIHJlYWwgZXJyb3IgY29kZS5cbiAgICAqXG4gICAgKiBAc2luY2UgMy4xNi4wXG4gICAgKi9cbiAgICBMU1BFcnJvckNvZGVzLmxzcFJlc2VydmVkRXJyb3JSYW5nZVN0YXJ0ID0gLTMyODk5O1xuICAgIC8qKlxuICAgICAqIEEgcmVxdWVzdCBmYWlsZWQgYnV0IGl0IHdhcyBzeW50YWN0aWNhbGx5IGNvcnJlY3QsIGUuZyB0aGVcbiAgICAgKiBtZXRob2QgbmFtZSB3YXMga25vd24gYW5kIHRoZSBwYXJhbWV0ZXJzIHdlcmUgdmFsaWQuIFRoZSBlcnJvclxuICAgICAqIG1lc3NhZ2Ugc2hvdWxkIGNvbnRhaW4gaHVtYW4gcmVhZGFibGUgaW5mb3JtYXRpb24gYWJvdXQgd2h5XG4gICAgICogdGhlIHJlcXVlc3QgZmFpbGVkLlxuICAgICAqXG4gICAgICogQHNpbmNlIDMuMTcuMFxuICAgICAqL1xuICAgIExTUEVycm9yQ29kZXMuUmVxdWVzdEZhaWxlZCA9IC0zMjgwMztcbiAgICAvKipcbiAgICAgKiBUaGUgc2VydmVyIGNhbmNlbGxlZCB0aGUgcmVxdWVzdC4gVGhpcyBlcnJvciBjb2RlIHNob3VsZFxuICAgICAqIG9ubHkgYmUgdXNlZCBmb3IgcmVxdWVzdHMgdGhhdCBleHBsaWNpdGx5IHN1cHBvcnQgYmVpbmdcbiAgICAgKiBzZXJ2ZXIgY2FuY2VsbGFibGUuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMy4xNy4wXG4gICAgICovXG4gICAgTFNQRXJyb3JDb2Rlcy5TZXJ2ZXJDYW5jZWxsZWQgPSAtMzI4MDI7XG4gICAgLyoqXG4gICAgICogVGhlIHNlcnZlciBkZXRlY3RlZCB0aGF0IHRoZSBjb250ZW50IG9mIGEgZG9jdW1lbnQgZ290XG4gICAgICogbW9kaWZpZWQgb3V0c2lkZSBub3JtYWwgY29uZGl0aW9ucy4gQSBzZXJ2ZXIgc2hvdWxkXG4gICAgICogTk9UIHNlbmQgdGhpcyBlcnJvciBjb2RlIGlmIGl0IGRldGVjdHMgYSBjb250ZW50IGNoYW5nZVxuICAgICAqIGluIGl0IHVucHJvY2Vzc2VkIG1lc3NhZ2VzLiBUaGUgcmVzdWx0IGV2ZW4gY29tcHV0ZWRcbiAgICAgKiBvbiBhbiBvbGRlciBzdGF0ZSBtaWdodCBzdGlsbCBiZSB1c2VmdWwgZm9yIHRoZSBjbGllbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIGNsaWVudCBkZWNpZGVzIHRoYXQgYSByZXN1bHQgaXMgbm90IG9mIGFueSB1c2UgYW55bW9yZVxuICAgICAqIHRoZSBjbGllbnQgc2hvdWxkIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBMU1BFcnJvckNvZGVzLkNvbnRlbnRNb2RpZmllZCA9IC0zMjgwMTtcbiAgICAvKipcbiAgICAgKiBUaGUgY2xpZW50IGhhcyBjYW5jZWxlZCBhIHJlcXVlc3QgYW5kIGEgc2VydmVyIGFzIGRldGVjdGVkXG4gICAgICogdGhlIGNhbmNlbC5cbiAgICAgKi9cbiAgICBMU1BFcnJvckNvZGVzLlJlcXVlc3RDYW5jZWxsZWQgPSAtMzI4MDA7XG4gICAgLyoqXG4gICAgKiBUaGlzIGlzIHRoZSBlbmQgcmFuZ2Ugb2YgTFNQIHJlc2VydmVkIGVycm9yIGNvZGVzLlxuICAgICogSXQgZG9lc24ndCBkZW5vdGUgYSByZWFsIGVycm9yIGNvZGUuXG4gICAgKlxuICAgICogQHNpbmNlIDMuMTYuMFxuICAgICovXG4gICAgTFNQRXJyb3JDb2Rlcy5sc3BSZXNlcnZlZEVycm9yUmFuZ2VFbmQgPSAtMzI4MDA7XG59KShMU1BFcnJvckNvZGVzID0gZXhwb3J0cy5MU1BFcnJvckNvZGVzIHx8IChleHBvcnRzLkxTUEVycm9yQ29kZXMgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyNzk4OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLmNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbiA9IHZvaWQgMDtcbmNvbnN0IHZzY29kZV9qc29ucnBjXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5NTMpO1xuZnVuY3Rpb24gY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uKGlucHV0LCBvdXRwdXQsIGxvZ2dlciwgb3B0aW9ucykge1xuICAgIGlmICh2c2NvZGVfanNvbnJwY18xLkNvbm5lY3Rpb25TdHJhdGVneS5pcyhvcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0geyBjb25uZWN0aW9uU3RyYXRlZ3k6IG9wdGlvbnMgfTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCB2c2NvZGVfanNvbnJwY18xLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uKShpbnB1dCwgb3V0cHV0LCBsb2dnZXIsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5jcmVhdGVQcm90b2NvbENvbm5lY3Rpb24gPSBjcmVhdGVQcm90b2NvbENvbm5lY3Rpb247XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg1OTk6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlID0gZXhwb3J0cy5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUwID0gZXhwb3J0cy5Qcm90b2NvbFJlcXVlc3RUeXBlID0gZXhwb3J0cy5Qcm90b2NvbFJlcXVlc3RUeXBlMCA9IGV4cG9ydHMuUmVnaXN0cmF0aW9uVHlwZSA9IGV4cG9ydHMuTWVzc2FnZURpcmVjdGlvbiA9IHZvaWQgMDtcbmNvbnN0IHZzY29kZV9qc29ucnBjXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5NTMpO1xudmFyIE1lc3NhZ2VEaXJlY3Rpb247XG4oZnVuY3Rpb24gKE1lc3NhZ2VEaXJlY3Rpb24pIHtcbiAgICBNZXNzYWdlRGlyZWN0aW9uW1wiY2xpZW50VG9TZXJ2ZXJcIl0gPSBcImNsaWVudFRvU2VydmVyXCI7XG4gICAgTWVzc2FnZURpcmVjdGlvbltcInNlcnZlclRvQ2xpZW50XCJdID0gXCJzZXJ2ZXJUb0NsaWVudFwiO1xuICAgIE1lc3NhZ2VEaXJlY3Rpb25bXCJib3RoXCJdID0gXCJib3RoXCI7XG59KShNZXNzYWdlRGlyZWN0aW9uID0gZXhwb3J0cy5NZXNzYWdlRGlyZWN0aW9uIHx8IChleHBvcnRzLk1lc3NhZ2VEaXJlY3Rpb24gPSB7fSkpO1xuY2xhc3MgUmVnaXN0cmF0aW9uVHlwZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVnaXN0cmF0aW9uVHlwZSA9IFJlZ2lzdHJhdGlvblR5cGU7XG5jbGFzcyBQcm90b2NvbFJlcXVlc3RUeXBlMCBleHRlbmRzIHZzY29kZV9qc29ucnBjXzEuUmVxdWVzdFR5cGUwIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kKTtcbiAgICB9XG59XG5leHBvcnRzLlByb3RvY29sUmVxdWVzdFR5cGUwID0gUHJvdG9jb2xSZXF1ZXN0VHlwZTA7XG5jbGFzcyBQcm90b2NvbFJlcXVlc3RUeXBlIGV4dGVuZHMgdnNjb2RlX2pzb25ycGNfMS5SZXF1ZXN0VHlwZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgdnNjb2RlX2pzb25ycGNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm90b2NvbFJlcXVlc3RUeXBlID0gUHJvdG9jb2xSZXF1ZXN0VHlwZTtcbmNsYXNzIFByb3RvY29sTm90aWZpY2F0aW9uVHlwZTAgZXh0ZW5kcyB2c2NvZGVfanNvbnJwY18xLk5vdGlmaWNhdGlvblR5cGUwIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kKTtcbiAgICB9XG59XG5leHBvcnRzLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZTAgPSBQcm90b2NvbE5vdGlmaWNhdGlvblR5cGUwO1xuY2xhc3MgUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlIGV4dGVuZHMgdnNjb2RlX2pzb25ycGNfMS5Ob3RpZmljYXRpb25UeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCB2c2NvZGVfanNvbnJwY18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lKTtcbiAgICB9XG59XG5leHBvcnRzLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZSA9IFByb3RvY29sTm90aWZpY2F0aW9uVHlwZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDQzNDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIFR5cGVGb3gsIE1pY3Jvc29mdCBhbmQgb3RoZXJzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkNhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdCA9IGV4cG9ydHMuQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0ID0gZXhwb3J0cy5DYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTk5KTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc3VsdCBhIGBDYWxsSGllcmFyY2h5SXRlbWAgaW4gYSBkb2N1bWVudCBhdCBhIGdpdmVuIHBvc2l0aW9uLlxuICogQ2FuIGJlIHVzZWQgYXMgYW4gaW5wdXQgdG8gYW4gaW5jb21pbmcgb3Igb3V0Z29pbmcgY2FsbCBoaWVyYXJjaHkuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChDYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QpIHtcbiAgICBDYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9wcmVwYXJlQ2FsbEhpZXJhcmNoeSc7XG4gICAgQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdC5tZXRob2QpO1xufSkoQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0ID0gZXhwb3J0cy5DYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QgfHwgKGV4cG9ydHMuQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgdGhlIGluY29taW5nIGNhbGxzIGZvciBhIGdpdmVuIGBDYWxsSGllcmFyY2h5SXRlbWAuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QpIHtcbiAgICBDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QubWV0aG9kID0gJ2NhbGxIaWVyYXJjaHkvaW5jb21pbmdDYWxscyc7XG4gICAgQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdC5tZXRob2QpO1xufSkoQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0ID0gZXhwb3J0cy5DYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QgfHwgKGV4cG9ydHMuQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgdGhlIG91dGdvaW5nIGNhbGxzIGZvciBhIGdpdmVuIGBDYWxsSGllcmFyY2h5SXRlbWAuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChDYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QpIHtcbiAgICBDYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QubWV0aG9kID0gJ2NhbGxIaWVyYXJjaHkvb3V0Z29pbmdDYWxscyc7XG4gICAgQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdC5tZXRob2QpO1xufSkoQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0ID0gZXhwb3J0cy5DYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QgfHwgKGV4cG9ydHMuQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzkwODpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5Db2xvclByZXNlbnRhdGlvblJlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50Q29sb3JSZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODU5OSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBsaXN0IGFsbCBjb2xvciBzeW1ib2xzIGZvdW5kIGluIGEgZ2l2ZW4gdGV4dCBkb2N1bWVudC4gVGhlIHJlcXVlc3Qnc1xuICogcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIERvY3VtZW50Q29sb3JQYXJhbXN9IHRoZVxuICogcmVzcG9uc2UgaXMgb2YgdHlwZSB7QGxpbmsgQ29sb3JJbmZvcm1hdGlvbiBDb2xvckluZm9ybWF0aW9uW119IG9yIGEgVGhlbmFibGVcbiAqIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIERvY3VtZW50Q29sb3JSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEb2N1bWVudENvbG9yUmVxdWVzdCkge1xuICAgIERvY3VtZW50Q29sb3JSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvZG9jdW1lbnRDb2xvcic7XG4gICAgRG9jdW1lbnRDb2xvclJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudENvbG9yUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEb2N1bWVudENvbG9yUmVxdWVzdC5tZXRob2QpO1xufSkoRG9jdW1lbnRDb2xvclJlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50Q29sb3JSZXF1ZXN0IHx8IChleHBvcnRzLkRvY3VtZW50Q29sb3JSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIGxpc3QgYWxsIHByZXNlbnRhdGlvbiBmb3IgYSBjb2xvci4gVGhlIHJlcXVlc3Qnc1xuICogcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIENvbG9yUHJlc2VudGF0aW9uUGFyYW1zfSB0aGVcbiAqIHJlc3BvbnNlIGlzIG9mIHR5cGUge0BsaW5rIENvbG9ySW5mb3JtYXRpb24gQ29sb3JJbmZvcm1hdGlvbltdfSBvciBhIFRoZW5hYmxlXG4gKiB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBDb2xvclByZXNlbnRhdGlvblJlcXVlc3Q7XG4oZnVuY3Rpb24gKENvbG9yUHJlc2VudGF0aW9uUmVxdWVzdCkge1xuICAgIENvbG9yUHJlc2VudGF0aW9uUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2NvbG9yUHJlc2VudGF0aW9uJztcbiAgICBDb2xvclByZXNlbnRhdGlvblJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBDb2xvclByZXNlbnRhdGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0Lm1ldGhvZCk7XG59KShDb2xvclByZXNlbnRhdGlvblJlcXVlc3QgPSBleHBvcnRzLkNvbG9yUHJlc2VudGF0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5Db2xvclByZXNlbnRhdGlvblJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1NDQyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkNvbmZpZ3VyYXRpb25SZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODU5OSk7XG4vLy0tLS0gR2V0IENvbmZpZ3VyYXRpb24gcmVxdWVzdCAtLS0tXG4vKipcbiAqIFRoZSAnd29ya3NwYWNlL2NvbmZpZ3VyYXRpb24nIHJlcXVlc3QgaXMgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byBmZXRjaCBhIGNlcnRhaW5cbiAqIGNvbmZpZ3VyYXRpb24gc2V0dGluZy5cbiAqXG4gKiBUaGlzIHB1bGwgbW9kZWwgcmVwbGFjZXMgdGhlIG9sZCBwdXNoIG1vZGVsIHdlcmUgdGhlIGNsaWVudCBzaWduYWxlZCBjb25maWd1cmF0aW9uIGNoYW5nZSB2aWEgYW5cbiAqIGV2ZW50LiBJZiB0aGUgc2VydmVyIHN0aWxsIG5lZWRzIHRvIHJlYWN0IHRvIGNvbmZpZ3VyYXRpb24gY2hhbmdlcyAoc2luY2UgdGhlIHNlcnZlciBjYWNoZXMgdGhlXG4gKiByZXN1bHQgb2YgYHdvcmtzcGFjZS9jb25maWd1cmF0aW9uYCByZXF1ZXN0cykgdGhlIHNlcnZlciBzaG91bGQgcmVnaXN0ZXIgZm9yIGFuIGVtcHR5IGNvbmZpZ3VyYXRpb25cbiAqIGNoYW5nZSBldmVudCBhbmQgZW1wdHkgdGhlIGNhY2hlIGlmIHN1Y2ggYW4gZXZlbnQgaXMgcmVjZWl2ZWQuXG4gKi9cbnZhciBDb25maWd1cmF0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29uZmlndXJhdGlvblJlcXVlc3QpIHtcbiAgICBDb25maWd1cmF0aW9uUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL2NvbmZpZ3VyYXRpb24nO1xuICAgIENvbmZpZ3VyYXRpb25SZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgQ29uZmlndXJhdGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoQ29uZmlndXJhdGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKENvbmZpZ3VyYXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5Db25maWd1cmF0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5Db25maWd1cmF0aW9uUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDcyMTA6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuRGVjbGFyYXRpb25SZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODU5OSk7XG4vLyBAdHMtaWdub3JlOiB0byBhdm9pZCBpbmxpbmluZyBMb2NhdGlvbkxpbmsgYXMgZHluYW1pYyBpbXBvcnRcbmxldCBfX25vRHluYW1pY0ltcG9ydDtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgdGhlIHR5cGUgZGVmaW5pdGlvbiBsb2NhdGlvbnMgb2YgYSBzeW1ib2wgYXQgYSBnaXZlbiB0ZXh0XG4gKiBkb2N1bWVudCBwb3NpdGlvbi4gVGhlIHJlcXVlc3QncyBwYXJhbWV0ZXIgaXMgb2YgdHlwZSBbVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXNdXG4gKiAoI1RleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zKSB0aGUgcmVzcG9uc2UgaXMgb2YgdHlwZSB7QGxpbmsgRGVjbGFyYXRpb259XG4gKiBvciBhIHR5cGVkIGFycmF5IG9mIHtAbGluayBEZWNsYXJhdGlvbkxpbmt9IG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlc1xuICogdG8gc3VjaC5cbiAqL1xudmFyIERlY2xhcmF0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoRGVjbGFyYXRpb25SZXF1ZXN0KSB7XG4gICAgRGVjbGFyYXRpb25SZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvZGVjbGFyYXRpb24nO1xuICAgIERlY2xhcmF0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERlY2xhcmF0aW9uUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEZWNsYXJhdGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKERlY2xhcmF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuRGVjbGFyYXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLkRlY2xhcmF0aW9uUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDU2OTI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5Xb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZCA9IGV4cG9ydHMuRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGEgPSB2b2lkIDA7XG5jb25zdCB2c2NvZGVfanNvbnJwY18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OTUzKTtcbmNvbnN0IElzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNTIzKTtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1OTkpO1xuLyoqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBEaWFnbm9zdGljU2VydmVyQ2FuY2VsbGF0aW9uRGF0YTtcbihmdW5jdGlvbiAoRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGEpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5ib29sZWFuKGNhbmRpZGF0ZS5yZXRyaWdnZXJSZXF1ZXN0KTtcbiAgICB9XG4gICAgRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGEuaXMgPSBpcztcbn0pKERpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhID0gZXhwb3J0cy5EaWFnbm9zdGljU2VydmVyQ2FuY2VsbGF0aW9uRGF0YSB8fCAoZXhwb3J0cy5EaWFnbm9zdGljU2VydmVyQ2FuY2VsbGF0aW9uRGF0YSA9IHt9KSk7XG4vKipcbiAqIFRoZSBkb2N1bWVudCBkaWFnbm9zdGljIHJlcG9ydCBraW5kcy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBEb2N1bWVudERpYWdub3N0aWNSZXBvcnRLaW5kO1xuKGZ1bmN0aW9uIChEb2N1bWVudERpYWdub3N0aWNSZXBvcnRLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQSBkaWFnbm9zdGljIHJlcG9ydCB3aXRoIGEgZnVsbFxuICAgICAqIHNldCBvZiBwcm9ibGVtcy5cbiAgICAgKi9cbiAgICBEb2N1bWVudERpYWdub3N0aWNSZXBvcnRLaW5kLkZ1bGwgPSAnZnVsbCc7XG4gICAgLyoqXG4gICAgICogQSByZXBvcnQgaW5kaWNhdGluZyB0aGF0IHRoZSBsYXN0XG4gICAgICogcmV0dXJuZWQgcmVwb3J0IGlzIHN0aWxsIGFjY3VyYXRlLlxuICAgICAqL1xuICAgIERvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQuVW5jaGFuZ2VkID0gJ3VuY2hhbmdlZCc7XG59KShEb2N1bWVudERpYWdub3N0aWNSZXBvcnRLaW5kID0gZXhwb3J0cy5Eb2N1bWVudERpYWdub3N0aWNSZXBvcnRLaW5kIHx8IChleHBvcnRzLkRvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZG9jdW1lbnQgZGlhZ25vc3RpYyByZXF1ZXN0IGRlZmluaXRpb24uXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdDtcbihmdW5jdGlvbiAoRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdCkge1xuICAgIERvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9kaWFnbm9zdGljJztcbiAgICBEb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0Lm1ldGhvZCk7XG4gICAgRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdC5wYXJ0aWFsUmVzdWx0ID0gbmV3IHZzY29kZV9qc29ucnBjXzEuUHJvZ3Jlc3NUeXBlKCk7XG59KShEb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0IHx8IChleHBvcnRzLkRvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBUaGUgd29ya3NwYWNlIGRpYWdub3N0aWMgcmVxdWVzdCBkZWZpbml0aW9uLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIFdvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdCkge1xuICAgIFdvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0Lm1ldGhvZCA9ICd3b3Jrc3BhY2UvZGlhZ25vc3RpYyc7XG4gICAgV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdC5tZXRob2QpO1xuICAgIFdvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0LnBhcnRpYWxSZXN1bHQgPSBuZXcgdnNjb2RlX2pzb25ycGNfMS5Qcm9ncmVzc1R5cGUoKTtcbn0pKFdvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0ID0gZXhwb3J0cy5Xb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdCB8fCAoZXhwb3J0cy5Xb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFRoZSBkaWFnbm9zdGljIHJlZnJlc2ggcmVxdWVzdCBkZWZpbml0aW9uLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIERpYWdub3N0aWNSZWZyZXNoUmVxdWVzdDtcbihmdW5jdGlvbiAoRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0KSB7XG4gICAgRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0Lm1ldGhvZCA9IGB3b3Jrc3BhY2UvZGlhZ25vc3RpYy9yZWZyZXNoYDtcbiAgICBEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUwKERpYWdub3N0aWNSZWZyZXNoUmVxdWVzdC5tZXRob2QpO1xufSkoRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5EaWFnbm9zdGljUmVmcmVzaFJlcXVlc3QgfHwgKGV4cG9ydHMuRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjE5MDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5XaWxsRGVsZXRlRmlsZXNSZXF1ZXN0ID0gZXhwb3J0cy5EaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24gPSBleHBvcnRzLldpbGxSZW5hbWVGaWxlc1JlcXVlc3QgPSBleHBvcnRzLkRpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5XaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0ID0gZXhwb3J0cy5GaWxlT3BlcmF0aW9uUGF0dGVybktpbmQgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTk5KTtcbi8qKlxuICogQSBwYXR0ZXJuIGtpbmQgZGVzY3JpYmluZyBpZiBhIGdsb2IgcGF0dGVybiBtYXRjaGVzIGEgZmlsZSBhIGZvbGRlciBvclxuICogYm90aC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBGaWxlT3BlcmF0aW9uUGF0dGVybktpbmQ7XG4oZnVuY3Rpb24gKEZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBwYXR0ZXJuIG1hdGNoZXMgYSBmaWxlIG9ubHkuXG4gICAgICovXG4gICAgRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kLmZpbGUgPSAnZmlsZSc7XG4gICAgLyoqXG4gICAgICogVGhlIHBhdHRlcm4gbWF0Y2hlcyBhIGZvbGRlciBvbmx5LlxuICAgICAqL1xuICAgIEZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZC5mb2xkZXIgPSAnZm9sZGVyJztcbn0pKEZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZCA9IGV4cG9ydHMuRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kIHx8IChleHBvcnRzLkZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZCA9IHt9KSk7XG4vKipcbiAqIFRoZSB3aWxsIGNyZWF0ZSBmaWxlcyByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgYmVmb3JlIGZpbGVzIGFyZSBhY3R1YWxseVxuICogY3JlYXRlZCBhcyBsb25nIGFzIHRoZSBjcmVhdGlvbiBpcyB0cmlnZ2VyZWQgZnJvbSB3aXRoaW4gdGhlIGNsaWVudC5cbiAqXG4gKiBUaGUgcmVxdWVzdCBjYW4gcmV0dXJuIGEgYFdvcmtzcGFjZUVkaXRgIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB3b3Jrc3BhY2UgYmVmb3JlIHRoZVxuICogZmlsZXMgYXJlIGNyZWF0ZWQuIEhlbmNlIHRoZSBgV29ya3NwYWNlRWRpdGAgY2FuIG5vdCBtYW5pcHVsYXRlIHRoZSBjb250ZW50IG9mIHRoZSBmaWxlXG4gKiB0byBiZSBjcmVhdGVkLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFdpbGxDcmVhdGVGaWxlc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKFdpbGxDcmVhdGVGaWxlc1JlcXVlc3QpIHtcbiAgICBXaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0Lm1ldGhvZCA9ICd3b3Jrc3BhY2Uvd2lsbENyZWF0ZUZpbGVzJztcbiAgICBXaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgV2lsbENyZWF0ZUZpbGVzUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShXaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0Lm1ldGhvZCk7XG59KShXaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0ID0gZXhwb3J0cy5XaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0IHx8IChleHBvcnRzLldpbGxDcmVhdGVGaWxlc1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZGlkIGNyZWF0ZSBmaWxlcyBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB3aGVuXG4gKiBmaWxlcyB3ZXJlIGNyZWF0ZWQgZnJvbSB3aXRoaW4gdGhlIGNsaWVudC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBEaWRDcmVhdGVGaWxlc05vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24pIHtcbiAgICBEaWRDcmVhdGVGaWxlc05vdGlmaWNhdGlvbi5tZXRob2QgPSAnd29ya3NwYWNlL2RpZENyZWF0ZUZpbGVzJztcbiAgICBEaWRDcmVhdGVGaWxlc05vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDcmVhdGVGaWxlc05vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRDcmVhdGVGaWxlc05vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSB3aWxsIHJlbmFtZSBmaWxlcyByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgYmVmb3JlIGZpbGVzIGFyZSBhY3R1YWxseVxuICogcmVuYW1lZCBhcyBsb25nIGFzIHRoZSByZW5hbWUgaXMgdHJpZ2dlcmVkIGZyb20gd2l0aGluIHRoZSBjbGllbnQuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgV2lsbFJlbmFtZUZpbGVzUmVxdWVzdDtcbihmdW5jdGlvbiAoV2lsbFJlbmFtZUZpbGVzUmVxdWVzdCkge1xuICAgIFdpbGxSZW5hbWVGaWxlc1JlcXVlc3QubWV0aG9kID0gJ3dvcmtzcGFjZS93aWxsUmVuYW1lRmlsZXMnO1xuICAgIFdpbGxSZW5hbWVGaWxlc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBXaWxsUmVuYW1lRmlsZXNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFdpbGxSZW5hbWVGaWxlc1JlcXVlc3QubWV0aG9kKTtcbn0pKFdpbGxSZW5hbWVGaWxlc1JlcXVlc3QgPSBleHBvcnRzLldpbGxSZW5hbWVGaWxlc1JlcXVlc3QgfHwgKGV4cG9ydHMuV2lsbFJlbmFtZUZpbGVzUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFRoZSBkaWQgcmVuYW1lIGZpbGVzIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHdoZW5cbiAqIGZpbGVzIHdlcmUgcmVuYW1lZCBmcm9tIHdpdGhpbiB0aGUgY2xpZW50LlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIERpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbikge1xuICAgIERpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3b3Jrc3BhY2UvZGlkUmVuYW1lRmlsZXMnO1xuICAgIERpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIHdpbGwgZGVsZXRlIGZpbGVzIHJlcXVlc3QgaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciBiZWZvcmUgZmlsZXMgYXJlIGFjdHVhbGx5XG4gKiBkZWxldGVkIGFzIGxvbmcgYXMgdGhlIGRlbGV0aW9uIGlzIHRyaWdnZXJlZCBmcm9tIHdpdGhpbiB0aGUgY2xpZW50LlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIERpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbikge1xuICAgIERpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3b3Jrc3BhY2UvZGlkRGVsZXRlRmlsZXMnO1xuICAgIERpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIGRpZCBkZWxldGUgZmlsZXMgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgd2hlblxuICogZmlsZXMgd2VyZSBkZWxldGVkIGZyb20gd2l0aGluIHRoZSBjbGllbnQuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgV2lsbERlbGV0ZUZpbGVzUmVxdWVzdDtcbihmdW5jdGlvbiAoV2lsbERlbGV0ZUZpbGVzUmVxdWVzdCkge1xuICAgIFdpbGxEZWxldGVGaWxlc1JlcXVlc3QubWV0aG9kID0gJ3dvcmtzcGFjZS93aWxsRGVsZXRlRmlsZXMnO1xuICAgIFdpbGxEZWxldGVGaWxlc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBXaWxsRGVsZXRlRmlsZXNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFdpbGxEZWxldGVGaWxlc1JlcXVlc3QubWV0aG9kKTtcbn0pKFdpbGxEZWxldGVGaWxlc1JlcXVlc3QgPSBleHBvcnRzLldpbGxEZWxldGVGaWxlc1JlcXVlc3QgfHwgKGV4cG9ydHMuV2lsbERlbGV0ZUZpbGVzUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDcwMjk6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5Gb2xkaW5nUmFuZ2VSZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODU5OSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBwcm92aWRlIGZvbGRpbmcgcmFuZ2VzIGluIGEgZG9jdW1lbnQuIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBGb2xkaW5nUmFuZ2VQYXJhbXN9LCB0aGVcbiAqIHJlc3BvbnNlIGlzIG9mIHR5cGUge0BsaW5rIEZvbGRpbmdSYW5nZUxpc3R9IG9yIGEgVGhlbmFibGVcbiAqIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIEZvbGRpbmdSYW5nZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKEZvbGRpbmdSYW5nZVJlcXVlc3QpIHtcbiAgICBGb2xkaW5nUmFuZ2VSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvZm9sZGluZ1JhbmdlJztcbiAgICBGb2xkaW5nUmFuZ2VSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRm9sZGluZ1JhbmdlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShGb2xkaW5nUmFuZ2VSZXF1ZXN0Lm1ldGhvZCk7XG59KShGb2xkaW5nUmFuZ2VSZXF1ZXN0ID0gZXhwb3J0cy5Gb2xkaW5nUmFuZ2VSZXF1ZXN0IHx8IChleHBvcnRzLkZvbGRpbmdSYW5nZVJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5MzgwOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkltcGxlbWVudGF0aW9uUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1OTkpO1xuLy8gQHRzLWlnbm9yZTogdG8gYXZvaWQgaW5saW5pbmcgTG9jYXRpb25MaW5rIGFzIGR5bmFtaWMgaW1wb3J0XG5sZXQgX19ub0R5bmFtaWNJbXBvcnQ7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSBpbXBsZW1lbnRhdGlvbiBsb2NhdGlvbnMgb2YgYSBzeW1ib2wgYXQgYSBnaXZlbiB0ZXh0XG4gKiBkb2N1bWVudCBwb3NpdGlvbi4gVGhlIHJlcXVlc3QncyBwYXJhbWV0ZXIgaXMgb2YgdHlwZSBbVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXNdXG4gKiAoI1RleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zKSB0aGUgcmVzcG9uc2UgaXMgb2YgdHlwZSB7QGxpbmsgRGVmaW5pdGlvbn0gb3IgYVxuICogVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgSW1wbGVtZW50YXRpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChJbXBsZW1lbnRhdGlvblJlcXVlc3QpIHtcbiAgICBJbXBsZW1lbnRhdGlvblJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9pbXBsZW1lbnRhdGlvbic7XG4gICAgSW1wbGVtZW50YXRpb25SZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgSW1wbGVtZW50YXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKEltcGxlbWVudGF0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoSW1wbGVtZW50YXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5JbXBsZW1lbnRhdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuSW1wbGVtZW50YXRpb25SZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjMxNTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLklubGF5SGludFJlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5JbmxheUhpbnRSZXNvbHZlUmVxdWVzdCA9IGV4cG9ydHMuSW5sYXlIaW50UmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1OTkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcHJvdmlkZSBpbmxheSBoaW50cyBpbiBhIGRvY3VtZW50LiBUaGUgcmVxdWVzdCdzIHBhcmFtZXRlciBpcyBvZlxuICogdHlwZSB7QGxpbmsgSW5sYXlIaW50c1BhcmFtc30sIHRoZSByZXNwb25zZSBpcyBvZiB0eXBlXG4gKiB7QGxpbmsgSW5sYXlIaW50IElubGF5SGludFtdfSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBJbmxheUhpbnRSZXF1ZXN0O1xuKGZ1bmN0aW9uIChJbmxheUhpbnRSZXF1ZXN0KSB7XG4gICAgSW5sYXlIaW50UmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2lubGF5SGludCc7XG4gICAgSW5sYXlIaW50UmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIElubGF5SGludFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSW5sYXlIaW50UmVxdWVzdC5tZXRob2QpO1xufSkoSW5sYXlIaW50UmVxdWVzdCA9IGV4cG9ydHMuSW5sYXlIaW50UmVxdWVzdCB8fCAoZXhwb3J0cy5JbmxheUhpbnRSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGZvciBhbiBpbmxheSBoaW50LlxuICogVGhlIHJlcXVlc3QncyBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgSW5sYXlIaW50fSwgdGhlIHJlc3BvbnNlIGlzXG4gKiBvZiB0eXBlIHtAbGluayBJbmxheUhpbnR9IG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIElubGF5SGludFJlc29sdmVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChJbmxheUhpbnRSZXNvbHZlUmVxdWVzdCkge1xuICAgIElubGF5SGludFJlc29sdmVSZXF1ZXN0Lm1ldGhvZCA9ICdpbmxheUhpbnQvcmVzb2x2ZSc7XG4gICAgSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBJbmxheUhpbnRSZXNvbHZlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShJbmxheUhpbnRSZXNvbHZlUmVxdWVzdC5tZXRob2QpO1xufSkoSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLklubGF5SGludFJlc29sdmVSZXF1ZXN0IHx8IChleHBvcnRzLklubGF5SGludFJlc29sdmVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5sYXlIaW50UmVmcmVzaFJlcXVlc3Q7XG4oZnVuY3Rpb24gKElubGF5SGludFJlZnJlc2hSZXF1ZXN0KSB7XG4gICAgSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QubWV0aG9kID0gYHdvcmtzcGFjZS9pbmxheUhpbnQvcmVmcmVzaGA7XG4gICAgSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBJbmxheUhpbnRSZWZyZXNoUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QubWV0aG9kKTtcbn0pKElubGF5SGludFJlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5JbmxheUhpbnRSZWZyZXNoUmVxdWVzdCB8fCAoZXhwb3J0cy5JbmxheUhpbnRSZWZyZXNoUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc0MjU6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5JbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5JbmxpbmVWYWx1ZVJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTk5KTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHByb3ZpZGUgaW5saW5lIHZhbHVlcyBpbiBhIGRvY3VtZW50LiBUaGUgcmVxdWVzdCdzIHBhcmFtZXRlciBpcyBvZlxuICogdHlwZSB7QGxpbmsgSW5saW5lVmFsdWVQYXJhbXN9LCB0aGUgcmVzcG9uc2UgaXMgb2YgdHlwZVxuICoge0BsaW5rIElubGluZVZhbHVlIElubGluZVZhbHVlW119IG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIElubGluZVZhbHVlUmVxdWVzdDtcbihmdW5jdGlvbiAoSW5saW5lVmFsdWVSZXF1ZXN0KSB7XG4gICAgSW5saW5lVmFsdWVSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvaW5saW5lVmFsdWUnO1xuICAgIElubGluZVZhbHVlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIElubGluZVZhbHVlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShJbmxpbmVWYWx1ZVJlcXVlc3QubWV0aG9kKTtcbn0pKElubGluZVZhbHVlUmVxdWVzdCA9IGV4cG9ydHMuSW5saW5lVmFsdWVSZXF1ZXN0IHx8IChleHBvcnRzLklubGluZVZhbHVlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIElubGluZVZhbHVlUmVmcmVzaFJlcXVlc3Q7XG4oZnVuY3Rpb24gKElubGluZVZhbHVlUmVmcmVzaFJlcXVlc3QpIHtcbiAgICBJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0Lm1ldGhvZCA9IGB3b3Jrc3BhY2UvaW5saW5lVmFsdWUvcmVmcmVzaGA7XG4gICAgSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIElubGluZVZhbHVlUmVmcmVzaFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUwKElubGluZVZhbHVlUmVmcmVzaFJlcXVlc3QubWV0aG9kKTtcbn0pKElubGluZVZhbHVlUmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLklubGluZVZhbHVlUmVmcmVzaFJlcXVlc3QgfHwgKGV4cG9ydHMuSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY1MjU6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuV29ya3NwYWNlU3ltYm9sUmVxdWVzdCA9IGV4cG9ydHMuQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5Db2RlQWN0aW9uUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRTeW1ib2xSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QgPSBleHBvcnRzLlJlZmVyZW5jZXNSZXF1ZXN0ID0gZXhwb3J0cy5EZWZpbml0aW9uUmVxdWVzdCA9IGV4cG9ydHMuU2lnbmF0dXJlSGVscFJlcXVlc3QgPSBleHBvcnRzLlNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZCA9IGV4cG9ydHMuSG92ZXJSZXF1ZXN0ID0gZXhwb3J0cy5Db21wbGV0aW9uUmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLkNvbXBsZXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5Db21wbGV0aW9uVHJpZ2dlcktpbmQgPSBleHBvcnRzLlB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV2F0Y2hLaW5kID0gZXhwb3J0cy5SZWxhdGl2ZVBhdHRlcm4gPSBleHBvcnRzLkZpbGVDaGFuZ2VUeXBlID0gZXhwb3J0cy5EaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24gPSBleHBvcnRzLldpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdCA9IGV4cG9ydHMuV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLlRleHREb2N1bWVudFNhdmVSZWFzb24gPSBleHBvcnRzLkRpZFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLlRleHREb2N1bWVudENvbnRlbnRDaGFuZ2VFdmVudCA9IGV4cG9ydHMuRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuVGV4dERvY3VtZW50U3luY0tpbmQgPSBleHBvcnRzLlRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5Mb2dNZXNzYWdlTm90aWZpY2F0aW9uID0gZXhwb3J0cy5TaG93TWVzc2FnZVJlcXVlc3QgPSBleHBvcnRzLlNob3dNZXNzYWdlTm90aWZpY2F0aW9uID0gZXhwb3J0cy5NZXNzYWdlVHlwZSA9IGV4cG9ydHMuRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRXhpdE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuU2h1dGRvd25SZXF1ZXN0ID0gZXhwb3J0cy5Jbml0aWFsaXplZE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuSW5pdGlhbGl6ZUVycm9yQ29kZXMgPSBleHBvcnRzLkluaXRpYWxpemVSZXF1ZXN0ID0gZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzT3B0aW9ucyA9IGV4cG9ydHMuVGV4dERvY3VtZW50UmVnaXN0cmF0aW9uT3B0aW9ucyA9IGV4cG9ydHMuU3RhdGljUmVnaXN0cmF0aW9uT3B0aW9ucyA9IGV4cG9ydHMuUG9zaXRpb25FbmNvZGluZ0tpbmQgPSBleHBvcnRzLkZhaWx1cmVIYW5kbGluZ0tpbmQgPSBleHBvcnRzLlJlc291cmNlT3BlcmF0aW9uS2luZCA9IGV4cG9ydHMuVW5yZWdpc3RyYXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5SZWdpc3RyYXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudFNlbGVjdG9yID0gZXhwb3J0cy5Ob3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIgPSBleHBvcnRzLk5vdGVib29rRG9jdW1lbnRGaWx0ZXIgPSBleHBvcnRzLlRleHREb2N1bWVudEZpbHRlciA9IHZvaWQgMDtcbmV4cG9ydHMuVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdCA9IGV4cG9ydHMuVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0ID0gZXhwb3J0cy5Nb25pa2VyUmVxdWVzdCA9IGV4cG9ydHMuTW9uaWtlcktpbmQgPSBleHBvcnRzLlVuaXF1ZW5lc3NMZXZlbCA9IGV4cG9ydHMuV2lsbERlbGV0ZUZpbGVzUmVxdWVzdCA9IGV4cG9ydHMuRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb24gPSBleHBvcnRzLldpbGxSZW5hbWVGaWxlc1JlcXVlc3QgPSBleHBvcnRzLkRpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5XaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0ID0gZXhwb3J0cy5EaWRDcmVhdGVGaWxlc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kID0gZXhwb3J0cy5MaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0ID0gZXhwb3J0cy5TaG93RG9jdW1lbnRSZXF1ZXN0ID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0ID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZXF1ZXN0ID0gZXhwb3J0cy5Ub2tlbkZvcm1hdCA9IGV4cG9ydHMuQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0ID0gZXhwb3J0cy5DYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QgPSBleHBvcnRzLkNhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdCA9IGV4cG9ydHMuV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QgPSBleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3MgPSBleHBvcnRzLlNlbGVjdGlvblJhbmdlUmVxdWVzdCA9IGV4cG9ydHMuRGVjbGFyYXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5Gb2xkaW5nUmFuZ2VSZXF1ZXN0ID0gZXhwb3J0cy5Db2xvclByZXNlbnRhdGlvblJlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50Q29sb3JSZXF1ZXN0ID0gZXhwb3J0cy5Db25maWd1cmF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV29ya3NwYWNlRm9sZGVyc1JlcXVlc3QgPSBleHBvcnRzLlR5cGVEZWZpbml0aW9uUmVxdWVzdCA9IGV4cG9ydHMuSW1wbGVtZW50YXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5BcHBseVdvcmtzcGFjZUVkaXRSZXF1ZXN0ID0gZXhwb3J0cy5FeGVjdXRlQ29tbWFuZFJlcXVlc3QgPSBleHBvcnRzLlByZXBhcmVSZW5hbWVSZXF1ZXN0ID0gZXhwb3J0cy5SZW5hbWVSZXF1ZXN0ID0gZXhwb3J0cy5QcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvciA9IGV4cG9ydHMuRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRMaW5rUmVxdWVzdCA9IGV4cG9ydHMuQ29kZUxlbnNSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuQ29kZUxlbnNSZXNvbHZlUmVxdWVzdCA9IGV4cG9ydHMuQ29kZUxlbnNSZXF1ZXN0ID0gZXhwb3J0cy5Xb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdCA9IHZvaWQgMDtcbmV4cG9ydHMuRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2UgPSBleHBvcnRzLkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5Ob3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUgPSBleHBvcnRzLk5vdGVib29rRG9jdW1lbnQgPSBleHBvcnRzLk5vdGVib29rQ2VsbCA9IGV4cG9ydHMuRXhlY3V0aW9uU3VtbWFyeSA9IGV4cG9ydHMuTm90ZWJvb2tDZWxsS2luZCA9IGV4cG9ydHMuRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5Xb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZCA9IGV4cG9ydHMuRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGEgPSBleHBvcnRzLklubGF5SGludFJlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5JbmxheUhpbnRSZXNvbHZlUmVxdWVzdCA9IGV4cG9ydHMuSW5sYXlIaW50UmVxdWVzdCA9IGV4cG9ydHMuSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuSW5saW5lVmFsdWVSZXF1ZXN0ID0gZXhwb3J0cy5UeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTk5KTtcbmNvbnN0IHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NzY3KTtcbmNvbnN0IElzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNTIzKTtcbmNvbnN0IHByb3RvY29sX2ltcGxlbWVudGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzODApO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW1wbGVtZW50YXRpb25SZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfaW1wbGVtZW50YXRpb25fMS5JbXBsZW1lbnRhdGlvblJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfdHlwZURlZmluaXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oODY0Mik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUeXBlRGVmaW5pdGlvblJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF90eXBlRGVmaW5pdGlvbl8xLlR5cGVEZWZpbml0aW9uUmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF93b3Jrc3BhY2VGb2xkZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzQwMik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3dvcmtzcGFjZUZvbGRlcl8xLldvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF93b3Jrc3BhY2VGb2xkZXJfMS5EaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uOyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2NvbmZpZ3VyYXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTQ0Mik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb25maWd1cmF0aW9uUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2NvbmZpZ3VyYXRpb25fMS5Db25maWd1cmF0aW9uUmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9jb2xvclByb3ZpZGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc5MDgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRG9jdW1lbnRDb2xvclJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9jb2xvclByb3ZpZGVyXzEuRG9jdW1lbnRDb2xvclJlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfY29sb3JQcm92aWRlcl8xLkNvbG9yUHJlc2VudGF0aW9uUmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9mb2xkaW5nUmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzAyOSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGb2xkaW5nUmFuZ2VSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfZm9sZGluZ1JhbmdlXzEuRm9sZGluZ1JhbmdlUmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9kZWNsYXJhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MjEwKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRlY2xhcmF0aW9uUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2RlY2xhcmF0aW9uXzEuRGVjbGFyYXRpb25SZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX3NlbGVjdGlvblJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzOTIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfc2VsZWN0aW9uUmFuZ2VfMS5TZWxlY3Rpb25SYW5nZVJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfcHJvZ3Jlc3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzg5NSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXb3JrRG9uZVByb2dyZXNzXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfcHJvZ3Jlc3NfMS5Xb3JrRG9uZVByb2dyZXNzOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfcHJvZ3Jlc3NfMS5Xb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfcHJvZ3Jlc3NfMS5Xb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uOyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2NhbGxIaWVyYXJjaHlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDQzNCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9jYWxsSGllcmFyY2h5XzEuQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2NhbGxIaWVyYXJjaHlfMS5DYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfY2FsbEhpZXJhcmNoeV8xLkNhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9zZW1hbnRpY1Rva2Vuc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDg5KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRva2VuRm9ybWF0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfc2VtYW50aWNUb2tlbnNfMS5Ub2tlbkZvcm1hdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZW1hbnRpY1Rva2Vuc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9zZW1hbnRpY1Rva2Vuc18xLlNlbWFudGljVG9rZW5zUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3NlbWFudGljVG9rZW5zXzEuU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9zZW1hbnRpY1Rva2Vuc18xLlNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9zZW1hbnRpY1Rva2Vuc18xLlNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfc2VtYW50aWNUb2tlbnNfMS5TZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGU7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfc2hvd0RvY3VtZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1NDEpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2hvd0RvY3VtZW50UmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3Nob3dEb2N1bWVudF8xLlNob3dEb2N1bWVudFJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfbGlua2VkRWRpdGluZ1JhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyNyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbGlua2VkRWRpdGluZ1JhbmdlXzEuTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MTkwKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2ZpbGVPcGVyYXRpb25zXzEuRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfZmlsZU9wZXJhdGlvbnNfMS5EaWRDcmVhdGVGaWxlc05vdGlmaWNhdGlvbjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfZmlsZU9wZXJhdGlvbnNfMS5XaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfZmlsZU9wZXJhdGlvbnNfMS5EaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXaWxsUmVuYW1lRmlsZXNSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfZmlsZU9wZXJhdGlvbnNfMS5XaWxsUmVuYW1lRmlsZXNSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfZmlsZU9wZXJhdGlvbnNfMS5EaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXaWxsRGVsZXRlRmlsZXNSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfZmlsZU9wZXJhdGlvbnNfMS5XaWxsRGVsZXRlRmlsZXNSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX21vbmlrZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTk2NCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVbmlxdWVuZXNzTGV2ZWxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9tb25pa2VyXzEuVW5pcXVlbmVzc0xldmVsOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1vbmlrZXJLaW5kXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbW9uaWtlcl8xLk1vbmlrZXJLaW5kOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1vbmlrZXJSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbW9uaWtlcl8xLk1vbmlrZXJSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX3R5cGVIaWVyYXJjaHlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTMxOCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF90eXBlSGllcmFyY2h5XzEuVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF90eXBlSGllcmFyY2h5XzEuVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF90eXBlSGllcmFyY2h5XzEuVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2lubGluZVZhbHVlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0MjUpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5saW5lVmFsdWVSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfaW5saW5lVmFsdWVfMS5JbmxpbmVWYWx1ZVJlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2lubGluZVZhbHVlXzEuSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9pbmxheUhpbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjMxNSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmxheUhpbnRSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfaW5sYXlIaW50XzEuSW5sYXlIaW50UmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmxheUhpbnRSZXNvbHZlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2lubGF5SGludF8xLklubGF5SGludFJlc29sdmVSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklubGF5SGludFJlZnJlc2hSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfaW5sYXlIaW50XzEuSW5sYXlIaW50UmVmcmVzaFJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfZGlhZ25vc3RpY18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NjkyKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfZGlhZ25vc3RpY18xLkRpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmRcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kaWFnbm9zdGljXzEuRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfZGlhZ25vc3RpY18xLkRvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kaWFnbm9zdGljXzEuV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfZGlhZ25vc3RpY18xLkRpYWdub3N0aWNSZWZyZXNoUmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9ub3RlYm9va18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NDYwKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGVib29rQ2VsbEtpbmRcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9ub3RlYm9va18xLk5vdGVib29rQ2VsbEtpbmQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXhlY3V0aW9uU3VtbWFyeVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX25vdGVib29rXzEuRXhlY3V0aW9uU3VtbWFyeTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RlYm9va0NlbGxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9ub3RlYm9va18xLk5vdGVib29rQ2VsbDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RlYm9va0RvY3VtZW50XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5Ob3RlYm9va0RvY3VtZW50OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX25vdGVib29rXzEuTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5EaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RlYm9va0NlbGxBcnJheUNoYW5nZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX25vdGVib29rXzEuTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2U7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX25vdGVib29rXzEuRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX25vdGVib29rXzEuRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb247IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5EaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb247IH0gfSkpO1xuLy8gQHRzLWlnbm9yZTogdG8gYXZvaWQgaW5saW5pbmcgTG9jYXRpb25MaW5rIGFzIGR5bmFtaWMgaW1wb3J0XG5sZXQgX19ub0R5bmFtaWNJbXBvcnQ7XG4vKipcbiAqIFRoZSBUZXh0RG9jdW1lbnRGaWx0ZXIgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgVGV4dERvY3VtZW50RmlsdGVyfSBsaXRlcmFscy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBUZXh0RG9jdW1lbnRGaWx0ZXI7XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudEZpbHRlcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYW5ndWFnZSkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5zY2hlbWUpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUucGF0dGVybik7XG4gICAgfVxuICAgIFRleHREb2N1bWVudEZpbHRlci5pcyA9IGlzO1xufSkoVGV4dERvY3VtZW50RmlsdGVyID0gZXhwb3J0cy5UZXh0RG9jdW1lbnRGaWx0ZXIgfHwgKGV4cG9ydHMuVGV4dERvY3VtZW50RmlsdGVyID0ge30pKTtcbi8qKlxuICogVGhlIE5vdGVib29rRG9jdW1lbnRGaWx0ZXIgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgTm90ZWJvb2tEb2N1bWVudEZpbHRlcn0gbGl0ZXJhbHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgTm90ZWJvb2tEb2N1bWVudEZpbHRlcjtcbihmdW5jdGlvbiAoTm90ZWJvb2tEb2N1bWVudEZpbHRlcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLm5vdGVib29rVHlwZSkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5zY2hlbWUpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUucGF0dGVybikpO1xuICAgIH1cbiAgICBOb3RlYm9va0RvY3VtZW50RmlsdGVyLmlzID0gaXM7XG59KShOb3RlYm9va0RvY3VtZW50RmlsdGVyID0gZXhwb3J0cy5Ob3RlYm9va0RvY3VtZW50RmlsdGVyIHx8IChleHBvcnRzLk5vdGVib29rRG9jdW1lbnRGaWx0ZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgTm90ZWJvb2tDZWxsVGV4dERvY3VtZW50RmlsdGVyIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIE5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlcn0gbGl0ZXJhbHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgTm90ZWJvb2tDZWxsVGV4dERvY3VtZW50RmlsdGVyO1xuKGZ1bmN0aW9uIChOb3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKVxuICAgICAgICAgICAgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUubm90ZWJvb2spIHx8IE5vdGVib29rRG9jdW1lbnRGaWx0ZXIuaXMoY2FuZGlkYXRlLm5vdGVib29rKSlcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUubGFuZ3VhZ2UgPT09IHVuZGVmaW5lZCB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhbmd1YWdlKSk7XG4gICAgfVxuICAgIE5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlci5pcyA9IGlzO1xufSkoTm90ZWJvb2tDZWxsVGV4dERvY3VtZW50RmlsdGVyID0gZXhwb3J0cy5Ob3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIgfHwgKGV4cG9ydHMuTm90ZWJvb2tDZWxsVGV4dERvY3VtZW50RmlsdGVyID0ge30pKTtcbi8qKlxuICogVGhlIERvY3VtZW50U2VsZWN0b3IgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgRG9jdW1lbnRTZWxlY3Rvcn1zLlxuICovXG52YXIgRG9jdW1lbnRTZWxlY3RvcjtcbihmdW5jdGlvbiAoRG9jdW1lbnRTZWxlY3Rvcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBlbGVtIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIUlzLnN0cmluZyhlbGVtKSAmJiAhVGV4dERvY3VtZW50RmlsdGVyLmlzKGVsZW0pICYmICFOb3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIuaXMoZWxlbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIERvY3VtZW50U2VsZWN0b3IuaXMgPSBpcztcbn0pKERvY3VtZW50U2VsZWN0b3IgPSBleHBvcnRzLkRvY3VtZW50U2VsZWN0b3IgfHwgKGV4cG9ydHMuRG9jdW1lbnRTZWxlY3RvciA9IHt9KSk7XG4vKipcbiAqIFRoZSBgY2xpZW50L3JlZ2lzdGVyQ2FwYWJpbGl0eWAgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIHJlZ2lzdGVyIGEgbmV3IGNhcGFiaWxpdHlcbiAqIGhhbmRsZXIgb24gdGhlIGNsaWVudCBzaWRlLlxuICovXG52YXIgUmVnaXN0cmF0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoUmVnaXN0cmF0aW9uUmVxdWVzdCkge1xuICAgIFJlZ2lzdHJhdGlvblJlcXVlc3QubWV0aG9kID0gJ2NsaWVudC9yZWdpc3RlckNhcGFiaWxpdHknO1xuICAgIFJlZ2lzdHJhdGlvblJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBSZWdpc3RyYXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFJlZ2lzdHJhdGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKFJlZ2lzdHJhdGlvblJlcXVlc3QgPSBleHBvcnRzLlJlZ2lzdHJhdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuUmVnaXN0cmF0aW9uUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFRoZSBgY2xpZW50L3VucmVnaXN0ZXJDYXBhYmlsaXR5YCByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gdW5yZWdpc3RlciBhIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBjYXBhYmlsaXR5XG4gKiBoYW5kbGVyIG9uIHRoZSBjbGllbnQgc2lkZS5cbiAqL1xudmFyIFVucmVnaXN0cmF0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoVW5yZWdpc3RyYXRpb25SZXF1ZXN0KSB7XG4gICAgVW5yZWdpc3RyYXRpb25SZXF1ZXN0Lm1ldGhvZCA9ICdjbGllbnQvdW5yZWdpc3RlckNhcGFiaWxpdHknO1xuICAgIFVucmVnaXN0cmF0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIFVucmVnaXN0cmF0aW9uUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShVbnJlZ2lzdHJhdGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKFVucmVnaXN0cmF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuVW5yZWdpc3RyYXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLlVucmVnaXN0cmF0aW9uUmVxdWVzdCA9IHt9KSk7XG52YXIgUmVzb3VyY2VPcGVyYXRpb25LaW5kO1xuKGZ1bmN0aW9uIChSZXNvdXJjZU9wZXJhdGlvbktpbmQpIHtcbiAgICAvKipcbiAgICAgKiBTdXBwb3J0cyBjcmVhdGluZyBuZXcgZmlsZXMgYW5kIGZvbGRlcnMuXG4gICAgICovXG4gICAgUmVzb3VyY2VPcGVyYXRpb25LaW5kLkNyZWF0ZSA9ICdjcmVhdGUnO1xuICAgIC8qKlxuICAgICAqIFN1cHBvcnRzIHJlbmFtaW5nIGV4aXN0aW5nIGZpbGVzIGFuZCBmb2xkZXJzLlxuICAgICAqL1xuICAgIFJlc291cmNlT3BlcmF0aW9uS2luZC5SZW5hbWUgPSAncmVuYW1lJztcbiAgICAvKipcbiAgICAgKiBTdXBwb3J0cyBkZWxldGluZyBleGlzdGluZyBmaWxlcyBhbmQgZm9sZGVycy5cbiAgICAgKi9cbiAgICBSZXNvdXJjZU9wZXJhdGlvbktpbmQuRGVsZXRlID0gJ2RlbGV0ZSc7XG59KShSZXNvdXJjZU9wZXJhdGlvbktpbmQgPSBleHBvcnRzLlJlc291cmNlT3BlcmF0aW9uS2luZCB8fCAoZXhwb3J0cy5SZXNvdXJjZU9wZXJhdGlvbktpbmQgPSB7fSkpO1xudmFyIEZhaWx1cmVIYW5kbGluZ0tpbmQ7XG4oZnVuY3Rpb24gKEZhaWx1cmVIYW5kbGluZ0tpbmQpIHtcbiAgICAvKipcbiAgICAgKiBBcHBseWluZyB0aGUgd29ya3NwYWNlIGNoYW5nZSBpcyBzaW1wbHkgYWJvcnRlZCBpZiBvbmUgb2YgdGhlIGNoYW5nZXMgcHJvdmlkZWRcbiAgICAgKiBmYWlscy4gQWxsIG9wZXJhdGlvbnMgZXhlY3V0ZWQgYmVmb3JlIHRoZSBmYWlsaW5nIG9wZXJhdGlvbiBzdGF5IGV4ZWN1dGVkLlxuICAgICAqL1xuICAgIEZhaWx1cmVIYW5kbGluZ0tpbmQuQWJvcnQgPSAnYWJvcnQnO1xuICAgIC8qKlxuICAgICAqIEFsbCBvcGVyYXRpb25zIGFyZSBleGVjdXRlZCB0cmFuc2FjdGlvbmFsLiBUaGF0IG1lYW5zIHRoZXkgZWl0aGVyIGFsbFxuICAgICAqIHN1Y2NlZWQgb3Igbm8gY2hhbmdlcyBhdCBhbGwgYXJlIGFwcGxpZWQgdG8gdGhlIHdvcmtzcGFjZS5cbiAgICAgKi9cbiAgICBGYWlsdXJlSGFuZGxpbmdLaW5kLlRyYW5zYWN0aW9uYWwgPSAndHJhbnNhY3Rpb25hbCc7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHdvcmtzcGFjZSBlZGl0IGNvbnRhaW5zIG9ubHkgdGV4dHVhbCBmaWxlIGNoYW5nZXMgdGhleSBhcmUgZXhlY3V0ZWQgdHJhbnNhY3Rpb25hbC5cbiAgICAgKiBJZiByZXNvdXJjZSBjaGFuZ2VzIChjcmVhdGUsIHJlbmFtZSBvciBkZWxldGUgZmlsZSkgYXJlIHBhcnQgb2YgdGhlIGNoYW5nZSB0aGUgZmFpbHVyZVxuICAgICAqIGhhbmRsaW5nIHN0cmF0ZWd5IGlzIGFib3J0LlxuICAgICAqL1xuICAgIEZhaWx1cmVIYW5kbGluZ0tpbmQuVGV4dE9ubHlUcmFuc2FjdGlvbmFsID0gJ3RleHRPbmx5VHJhbnNhY3Rpb25hbCc7XG4gICAgLyoqXG4gICAgICogVGhlIGNsaWVudCB0cmllcyB0byB1bmRvIHRoZSBvcGVyYXRpb25zIGFscmVhZHkgZXhlY3V0ZWQuIEJ1dCB0aGVyZSBpcyBub1xuICAgICAqIGd1YXJhbnRlZSB0aGF0IHRoaXMgaXMgc3VjY2VlZGluZy5cbiAgICAgKi9cbiAgICBGYWlsdXJlSGFuZGxpbmdLaW5kLlVuZG8gPSAndW5kbyc7XG59KShGYWlsdXJlSGFuZGxpbmdLaW5kID0gZXhwb3J0cy5GYWlsdXJlSGFuZGxpbmdLaW5kIHx8IChleHBvcnRzLkZhaWx1cmVIYW5kbGluZ0tpbmQgPSB7fSkpO1xuLyoqXG4gKiBBIHNldCBvZiBwcmVkZWZpbmVkIHBvc2l0aW9uIGVuY29kaW5nIGtpbmRzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIFBvc2l0aW9uRW5jb2RpbmdLaW5kO1xuKGZ1bmN0aW9uIChQb3NpdGlvbkVuY29kaW5nS2luZCkge1xuICAgIC8qKlxuICAgICAqIENoYXJhY3RlciBvZmZzZXRzIGNvdW50IFVURi04IGNvZGUgdW5pdHMgKGUuZy4gYnl0ZXMpLlxuICAgICAqL1xuICAgIFBvc2l0aW9uRW5jb2RpbmdLaW5kLlVURjggPSAndXRmLTgnO1xuICAgIC8qKlxuICAgICAqIENoYXJhY3RlciBvZmZzZXRzIGNvdW50IFVURi0xNiBjb2RlIHVuaXRzLlxuICAgICAqXG4gICAgICogVGhpcyBpcyB0aGUgZGVmYXVsdCBhbmQgbXVzdCBhbHdheXMgYmUgc3VwcG9ydGVkXG4gICAgICogYnkgc2VydmVyc1xuICAgICAqL1xuICAgIFBvc2l0aW9uRW5jb2RpbmdLaW5kLlVURjE2ID0gJ3V0Zi0xNic7XG4gICAgLyoqXG4gICAgICogQ2hhcmFjdGVyIG9mZnNldHMgY291bnQgVVRGLTMyIGNvZGUgdW5pdHMuXG4gICAgICpcbiAgICAgKiBJbXBsZW1lbnRhdGlvbiBub3RlOiB0aGVzZSBhcmUgdGhlIHNhbWUgYXMgVW5pY29kZSBjb2RlcG9pbnRzLFxuICAgICAqIHNvIHRoaXMgYFBvc2l0aW9uRW5jb2RpbmdLaW5kYCBtYXkgYWxzbyBiZSB1c2VkIGZvciBhblxuICAgICAqIGVuY29kaW5nLWFnbm9zdGljIHJlcHJlc2VudGF0aW9uIG9mIGNoYXJhY3RlciBvZmZzZXRzLlxuICAgICAqL1xuICAgIFBvc2l0aW9uRW5jb2RpbmdLaW5kLlVURjMyID0gJ3V0Zi0zMic7XG59KShQb3NpdGlvbkVuY29kaW5nS2luZCA9IGV4cG9ydHMuUG9zaXRpb25FbmNvZGluZ0tpbmQgfHwgKGV4cG9ydHMuUG9zaXRpb25FbmNvZGluZ0tpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgU3RhdGljUmVnaXN0cmF0aW9uT3B0aW9ucyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBTdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zfSBsaXRlcmFscy5cbiAqL1xudmFyIFN0YXRpY1JlZ2lzdHJhdGlvbk9wdGlvbnM7XG4oZnVuY3Rpb24gKFN0YXRpY1JlZ2lzdHJhdGlvbk9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBoYXNJZCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmlkKSAmJiBjYW5kaWRhdGUuaWQubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgU3RhdGljUmVnaXN0cmF0aW9uT3B0aW9ucy5oYXNJZCA9IGhhc0lkO1xufSkoU3RhdGljUmVnaXN0cmF0aW9uT3B0aW9ucyA9IGV4cG9ydHMuU3RhdGljUmVnaXN0cmF0aW9uT3B0aW9ucyB8fCAoZXhwb3J0cy5TdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zID0ge30pKTtcbi8qKlxuICogVGhlIFRleHREb2N1bWVudFJlZ2lzdHJhdGlvbk9wdGlvbnMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgVGV4dERvY3VtZW50UmVnaXN0cmF0aW9uT3B0aW9uc30gbGl0ZXJhbHMuXG4gKi9cbnZhciBUZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zO1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgKGNhbmRpZGF0ZS5kb2N1bWVudFNlbGVjdG9yID09PSBudWxsIHx8IERvY3VtZW50U2VsZWN0b3IuaXMoY2FuZGlkYXRlLmRvY3VtZW50U2VsZWN0b3IpKTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50UmVnaXN0cmF0aW9uT3B0aW9ucy5pcyA9IGlzO1xufSkoVGV4dERvY3VtZW50UmVnaXN0cmF0aW9uT3B0aW9ucyA9IGV4cG9ydHMuVGV4dERvY3VtZW50UmVnaXN0cmF0aW9uT3B0aW9ucyB8fCAoZXhwb3J0cy5UZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zID0ge30pKTtcbi8qKlxuICogVGhlIFdvcmtEb25lUHJvZ3Jlc3NPcHRpb25zIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFdvcmtEb25lUHJvZ3Jlc3NPcHRpb25zfSBsaXRlcmFscy5cbiAqL1xudmFyIFdvcmtEb25lUHJvZ3Jlc3NPcHRpb25zO1xuKGZ1bmN0aW9uIChXb3JrRG9uZVByb2dyZXNzT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIChjYW5kaWRhdGUud29ya0RvbmVQcm9ncmVzcyA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLndvcmtEb25lUHJvZ3Jlc3MpKTtcbiAgICB9XG4gICAgV29ya0RvbmVQcm9ncmVzc09wdGlvbnMuaXMgPSBpcztcbiAgICBmdW5jdGlvbiBoYXNXb3JrRG9uZVByb2dyZXNzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLmJvb2xlYW4oY2FuZGlkYXRlLndvcmtEb25lUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICBXb3JrRG9uZVByb2dyZXNzT3B0aW9ucy5oYXNXb3JrRG9uZVByb2dyZXNzID0gaGFzV29ya0RvbmVQcm9ncmVzcztcbn0pKFdvcmtEb25lUHJvZ3Jlc3NPcHRpb25zID0gZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzT3B0aW9ucyB8fCAoZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzT3B0aW9ucyA9IHt9KSk7XG4vKipcbiAqIFRoZSBpbml0aWFsaXplIHJlcXVlc3QgaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlci5cbiAqIEl0IGlzIHNlbnQgb25jZSBhcyB0aGUgcmVxdWVzdCBhZnRlciBzdGFydGluZyB1cCB0aGUgc2VydmVyLlxuICogVGhlIHJlcXVlc3RzIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBJbml0aWFsaXplUGFyYW1zfVxuICogdGhlIHJlc3BvbnNlIGlmIG9mIHR5cGUge0BsaW5rIEluaXRpYWxpemVSZXN1bHR9IG9mIGEgVGhlbmFibGUgdGhhdFxuICogcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIEluaXRpYWxpemVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChJbml0aWFsaXplUmVxdWVzdCkge1xuICAgIEluaXRpYWxpemVSZXF1ZXN0Lm1ldGhvZCA9ICdpbml0aWFsaXplJztcbiAgICBJbml0aWFsaXplUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIEluaXRpYWxpemVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKEluaXRpYWxpemVSZXF1ZXN0Lm1ldGhvZCk7XG59KShJbml0aWFsaXplUmVxdWVzdCA9IGV4cG9ydHMuSW5pdGlhbGl6ZVJlcXVlc3QgfHwgKGV4cG9ydHMuSW5pdGlhbGl6ZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBLbm93biBlcnJvciBjb2RlcyBmb3IgYW4gYEluaXRpYWxpemVFcnJvckNvZGVzYDtcbiAqL1xudmFyIEluaXRpYWxpemVFcnJvckNvZGVzO1xuKGZ1bmN0aW9uIChJbml0aWFsaXplRXJyb3JDb2Rlcykge1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBwcm90b2NvbCB2ZXJzaW9uIHByb3ZpZGVkIGJ5IHRoZSBjbGllbnQgY2FuJ3QgYmUgaGFuZGxlZCBieSB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVGhpcyBpbml0aWFsaXplIGVycm9yIGdvdCByZXBsYWNlZCBieSBjbGllbnQgY2FwYWJpbGl0aWVzLiBUaGVyZSBpc1xuICAgICAqIG5vIHZlcnNpb24gaGFuZHNoYWtlIGluIHZlcnNpb24gMy4weFxuICAgICAqL1xuICAgIEluaXRpYWxpemVFcnJvckNvZGVzLnVua25vd25Qcm90b2NvbFZlcnNpb24gPSAxO1xufSkoSW5pdGlhbGl6ZUVycm9yQ29kZXMgPSBleHBvcnRzLkluaXRpYWxpemVFcnJvckNvZGVzIHx8IChleHBvcnRzLkluaXRpYWxpemVFcnJvckNvZGVzID0ge30pKTtcbi8qKlxuICogVGhlIGluaXRpYWxpemVkIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGVcbiAqIHNlcnZlciBhZnRlciB0aGUgY2xpZW50IGlzIGZ1bGx5IGluaXRpYWxpemVkIGFuZCB0aGUgc2VydmVyXG4gKiBpcyBhbGxvd2VkIHRvIHNlbmQgcmVxdWVzdHMgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQuXG4gKi9cbnZhciBJbml0aWFsaXplZE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoSW5pdGlhbGl6ZWROb3RpZmljYXRpb24pIHtcbiAgICBJbml0aWFsaXplZE5vdGlmaWNhdGlvbi5tZXRob2QgPSAnaW5pdGlhbGl6ZWQnO1xuICAgIEluaXRpYWxpemVkTm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgSW5pdGlhbGl6ZWROb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShJbml0aWFsaXplZE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoSW5pdGlhbGl6ZWROb3RpZmljYXRpb24gPSBleHBvcnRzLkluaXRpYWxpemVkTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkluaXRpYWxpemVkTm90aWZpY2F0aW9uID0ge30pKTtcbi8vLS0tLSBTaHV0ZG93biBNZXRob2QgLS0tLVxuLyoqXG4gKiBBIHNodXRkb3duIHJlcXVlc3QgaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlci5cbiAqIEl0IGlzIHNlbnQgb25jZSB3aGVuIHRoZSBjbGllbnQgZGVjaWRlcyB0byBzaHV0ZG93biB0aGVcbiAqIHNlcnZlci4gVGhlIG9ubHkgbm90aWZpY2F0aW9uIHRoYXQgaXMgc2VudCBhZnRlciBhIHNodXRkb3duIHJlcXVlc3RcbiAqIGlzIHRoZSBleGl0IGV2ZW50LlxuICovXG52YXIgU2h1dGRvd25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChTaHV0ZG93blJlcXVlc3QpIHtcbiAgICBTaHV0ZG93blJlcXVlc3QubWV0aG9kID0gJ3NodXRkb3duJztcbiAgICBTaHV0ZG93blJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBTaHV0ZG93blJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUwKFNodXRkb3duUmVxdWVzdC5tZXRob2QpO1xufSkoU2h1dGRvd25SZXF1ZXN0ID0gZXhwb3J0cy5TaHV0ZG93blJlcXVlc3QgfHwgKGV4cG9ydHMuU2h1dGRvd25SZXF1ZXN0ID0ge30pKTtcbi8vLS0tLSBFeGl0IE5vdGlmaWNhdGlvbiAtLS0tXG4vKipcbiAqIFRoZSBleGl0IGV2ZW50IGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgdG9cbiAqIGFzayB0aGUgc2VydmVyIHRvIGV4aXQgaXRzIHByb2Nlc3MuXG4gKi9cbnZhciBFeGl0Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChFeGl0Tm90aWZpY2F0aW9uKSB7XG4gICAgRXhpdE5vdGlmaWNhdGlvbi5tZXRob2QgPSAnZXhpdCc7XG4gICAgRXhpdE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIEV4aXROb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZTAoRXhpdE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRXhpdE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRXhpdE5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5FeGl0Tm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gY2hhbmdlIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyXG4gKiB3aGVuIHRoZSBjbGllbnQncyBjb25maWd1cmF0aW9uIGhhcyBjaGFuZ2VkLiBUaGUgbm90aWZpY2F0aW9uIGNvbnRhaW5zXG4gKiB0aGUgY2hhbmdlZCBjb25maWd1cmF0aW9uIGFzIGRlZmluZWQgYnkgdGhlIGxhbmd1YWdlIGNsaWVudC5cbiAqL1xudmFyIERpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24pIHtcbiAgICBEaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3b3Jrc3BhY2UvZGlkQ2hhbmdlQ29uZmlndXJhdGlvbic7XG4gICAgRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShEaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24gPSB7fSkpO1xuLy8tLS0tIE1lc3NhZ2Ugc2hvdyBhbmQgbG9nIG5vdGlmaWNhdGlvbnMgLS0tLVxuLyoqXG4gKiBUaGUgbWVzc2FnZSB0eXBlXG4gKi9cbnZhciBNZXNzYWdlVHlwZTtcbihmdW5jdGlvbiAoTWVzc2FnZVR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBBbiBlcnJvciBtZXNzYWdlLlxuICAgICAqL1xuICAgIE1lc3NhZ2VUeXBlLkVycm9yID0gMTtcbiAgICAvKipcbiAgICAgKiBBIHdhcm5pbmcgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBNZXNzYWdlVHlwZS5XYXJuaW5nID0gMjtcbiAgICAvKipcbiAgICAgKiBBbiBpbmZvcm1hdGlvbiBtZXNzYWdlLlxuICAgICAqL1xuICAgIE1lc3NhZ2VUeXBlLkluZm8gPSAzO1xuICAgIC8qKlxuICAgICAqIEEgbG9nIG1lc3NhZ2UuXG4gICAgICovXG4gICAgTWVzc2FnZVR5cGUuTG9nID0gNDtcbn0pKE1lc3NhZ2VUeXBlID0gZXhwb3J0cy5NZXNzYWdlVHlwZSB8fCAoZXhwb3J0cy5NZXNzYWdlVHlwZSA9IHt9KSk7XG4vKipcbiAqIFRoZSBzaG93IG1lc3NhZ2Ugbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSBhIHNlcnZlciB0byBhIGNsaWVudCB0byBhc2tcbiAqIHRoZSBjbGllbnQgdG8gZGlzcGxheSBhIHBhcnRpY3VsYXIgbWVzc2FnZSBpbiB0aGUgdXNlciBpbnRlcmZhY2UuXG4gKi9cbnZhciBTaG93TWVzc2FnZU5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoU2hvd01lc3NhZ2VOb3RpZmljYXRpb24pIHtcbiAgICBTaG93TWVzc2FnZU5vdGlmaWNhdGlvbi5tZXRob2QgPSAnd2luZG93L3Nob3dNZXNzYWdlJztcbiAgICBTaG93TWVzc2FnZU5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIFNob3dNZXNzYWdlTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoU2hvd01lc3NhZ2VOb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKFNob3dNZXNzYWdlTm90aWZpY2F0aW9uID0gZXhwb3J0cy5TaG93TWVzc2FnZU5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5TaG93TWVzc2FnZU5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBzaG93IG1lc3NhZ2UgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIHNob3cgYSBtZXNzYWdlXG4gKiBhbmQgYSBzZXQgb2Ygb3B0aW9ucyBhY3Rpb25zIHRvIHRoZSB1c2VyLlxuICovXG52YXIgU2hvd01lc3NhZ2VSZXF1ZXN0O1xuKGZ1bmN0aW9uIChTaG93TWVzc2FnZVJlcXVlc3QpIHtcbiAgICBTaG93TWVzc2FnZVJlcXVlc3QubWV0aG9kID0gJ3dpbmRvdy9zaG93TWVzc2FnZVJlcXVlc3QnO1xuICAgIFNob3dNZXNzYWdlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIFNob3dNZXNzYWdlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShTaG93TWVzc2FnZVJlcXVlc3QubWV0aG9kKTtcbn0pKFNob3dNZXNzYWdlUmVxdWVzdCA9IGV4cG9ydHMuU2hvd01lc3NhZ2VSZXF1ZXN0IHx8IChleHBvcnRzLlNob3dNZXNzYWdlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFRoZSBsb2cgbWVzc2FnZSBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byBhc2tcbiAqIHRoZSBjbGllbnQgdG8gbG9nIGEgcGFydGljdWxhciBtZXNzYWdlLlxuICovXG52YXIgTG9nTWVzc2FnZU5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoTG9nTWVzc2FnZU5vdGlmaWNhdGlvbikge1xuICAgIExvZ01lc3NhZ2VOb3RpZmljYXRpb24ubWV0aG9kID0gJ3dpbmRvdy9sb2dNZXNzYWdlJztcbiAgICBMb2dNZXNzYWdlTm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgTG9nTWVzc2FnZU5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKExvZ01lc3NhZ2VOb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKExvZ01lc3NhZ2VOb3RpZmljYXRpb24gPSBleHBvcnRzLkxvZ01lc3NhZ2VOb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuTG9nTWVzc2FnZU5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vLy0tLS0gVGVsZW1ldHJ5IG5vdGlmaWNhdGlvblxuLyoqXG4gKiBUaGUgdGVsZW1ldHJ5IGV2ZW50IG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIGFza1xuICogdGhlIGNsaWVudCB0byBsb2cgdGVsZW1ldHJ5IGRhdGEuXG4gKi9cbnZhciBUZWxlbWV0cnlFdmVudE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24pIHtcbiAgICBUZWxlbWV0cnlFdmVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAndGVsZW1ldHJ5L2V2ZW50JztcbiAgICBUZWxlbWV0cnlFdmVudE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIFRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKFRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5UZWxlbWV0cnlFdmVudE5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5UZWxlbWV0cnlFdmVudE5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIERlZmluZXMgaG93IHRoZSBob3N0IChlZGl0b3IpIHNob3VsZCBzeW5jXG4gKiBkb2N1bWVudCBjaGFuZ2VzIHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIuXG4gKi9cbnZhciBUZXh0RG9jdW1lbnRTeW5jS2luZDtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50U3luY0tpbmQpIHtcbiAgICAvKipcbiAgICAgKiBEb2N1bWVudHMgc2hvdWxkIG5vdCBiZSBzeW5jZWQgYXQgYWxsLlxuICAgICAqL1xuICAgIFRleHREb2N1bWVudFN5bmNLaW5kLk5vbmUgPSAwO1xuICAgIC8qKlxuICAgICAqIERvY3VtZW50cyBhcmUgc3luY2VkIGJ5IGFsd2F5cyBzZW5kaW5nIHRoZSBmdWxsIGNvbnRlbnRcbiAgICAgKiBvZiB0aGUgZG9jdW1lbnQuXG4gICAgICovXG4gICAgVGV4dERvY3VtZW50U3luY0tpbmQuRnVsbCA9IDE7XG4gICAgLyoqXG4gICAgICogRG9jdW1lbnRzIGFyZSBzeW5jZWQgYnkgc2VuZGluZyB0aGUgZnVsbCBjb250ZW50IG9uIG9wZW4uXG4gICAgICogQWZ0ZXIgdGhhdCBvbmx5IGluY3JlbWVudGFsIHVwZGF0ZXMgdG8gdGhlIGRvY3VtZW50IGFyZVxuICAgICAqIHNlbmQuXG4gICAgICovXG4gICAgVGV4dERvY3VtZW50U3luY0tpbmQuSW5jcmVtZW50YWwgPSAyO1xufSkoVGV4dERvY3VtZW50U3luY0tpbmQgPSBleHBvcnRzLlRleHREb2N1bWVudFN5bmNLaW5kIHx8IChleHBvcnRzLlRleHREb2N1bWVudFN5bmNLaW5kID0ge30pKTtcbi8qKlxuICogVGhlIGRvY3VtZW50IG9wZW4gbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgdG8gc2lnbmFsXG4gKiBuZXdseSBvcGVuZWQgdGV4dCBkb2N1bWVudHMuIFRoZSBkb2N1bWVudCdzIHRydXRoIGlzIG5vdyBtYW5hZ2VkIGJ5IHRoZSBjbGllbnRcbiAqIGFuZCB0aGUgc2VydmVyIG11c3Qgbm90IHRyeSB0byByZWFkIHRoZSBkb2N1bWVudCdzIHRydXRoIHVzaW5nIHRoZSBkb2N1bWVudCdzXG4gKiB1cmkuIE9wZW4gaW4gdGhpcyBzZW5zZSBtZWFucyBpdCBpcyBtYW5hZ2VkIGJ5IHRoZSBjbGllbnQuIEl0IGRvZXNuJ3QgbmVjZXNzYXJpbHlcbiAqIG1lYW4gdGhhdCBpdHMgY29udGVudCBpcyBwcmVzZW50ZWQgaW4gYW4gZWRpdG9yLiBBbiBvcGVuIG5vdGlmaWNhdGlvbiBtdXN0IG5vdFxuICogYmUgc2VudCBtb3JlIHRoYW4gb25jZSB3aXRob3V0IGEgY29ycmVzcG9uZGluZyBjbG9zZSBub3RpZmljYXRpb24gc2VuZCBiZWZvcmUuXG4gKiBUaGlzIG1lYW5zIG9wZW4gYW5kIGNsb3NlIG5vdGlmaWNhdGlvbiBtdXN0IGJlIGJhbGFuY2VkIGFuZCB0aGUgbWF4IG9wZW4gY291bnRcbiAqIGlzIG9uZS5cbiAqL1xudmFyIERpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24pIHtcbiAgICBEaWRPcGVuVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvZGlkT3Blbic7XG4gICAgRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRPcGVuVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShEaWRPcGVuVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRPcGVuVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xudmFyIFRleHREb2N1bWVudENvbnRlbnRDaGFuZ2VFdmVudDtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50KSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGluZm9ybWF0aW9uIGRlc2NyaWJlcyBhIGRlbHRhIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSW5jcmVtZW50YWwoZXZlbnQpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IGV2ZW50O1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgY2FuZGlkYXRlLnRleHQgPT09ICdzdHJpbmcnICYmIGNhbmRpZGF0ZS5yYW5nZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLnJhbmdlTGVuZ3RoID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGNhbmRpZGF0ZS5yYW5nZUxlbmd0aCA9PT0gJ251bWJlcicpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnQuaXNJbmNyZW1lbnRhbCA9IGlzSW5jcmVtZW50YWw7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGluZm9ybWF0aW9uIGRlc2NyaWJlcyBhIGZ1bGwgcmVwbGFjZW1lbnQgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGdWxsKGV2ZW50KSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSBldmVudDtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAhPT0gdW5kZWZpbmVkICYmIGNhbmRpZGF0ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIGNhbmRpZGF0ZS50ZXh0ID09PSAnc3RyaW5nJyAmJiBjYW5kaWRhdGUucmFuZ2UgPT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUucmFuZ2VMZW5ndGggPT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50LmlzRnVsbCA9IGlzRnVsbDtcbn0pKFRleHREb2N1bWVudENvbnRlbnRDaGFuZ2VFdmVudCA9IGV4cG9ydHMuVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50IHx8IChleHBvcnRzLlRleHREb2N1bWVudENvbnRlbnRDaGFuZ2VFdmVudCA9IHt9KSk7XG4vKipcbiAqIFRoZSBkb2N1bWVudCBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgdG8gc2lnbmFsXG4gKiBjaGFuZ2VzIHRvIGEgdGV4dCBkb2N1bWVudC5cbiAqL1xudmFyIERpZENoYW5nZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvZGlkQ2hhbmdlJztcbiAgICBEaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZENoYW5nZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZENoYW5nZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBkb2N1bWVudCBjbG9zZSBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB3aGVuXG4gKiB0aGUgZG9jdW1lbnQgZ290IGNsb3NlZCBpbiB0aGUgY2xpZW50LiBUaGUgZG9jdW1lbnQncyB0cnV0aCBub3cgZXhpc3RzIHdoZXJlXG4gKiB0aGUgZG9jdW1lbnQncyB1cmkgcG9pbnRzIHRvIChlLmcuIGlmIHRoZSBkb2N1bWVudCdzIHVyaSBpcyBhIGZpbGUgdXJpIHRoZVxuICogdHJ1dGggbm93IGV4aXN0cyBvbiBkaXNrKS4gQXMgd2l0aCB0aGUgb3BlbiBub3RpZmljYXRpb24gdGhlIGNsb3NlIG5vdGlmaWNhdGlvblxuICogaXMgYWJvdXQgbWFuYWdpbmcgdGhlIGRvY3VtZW50J3MgY29udGVudC4gUmVjZWl2aW5nIGEgY2xvc2Ugbm90aWZpY2F0aW9uXG4gKiBkb2Vzbid0IG1lYW4gdGhhdCB0aGUgZG9jdW1lbnQgd2FzIG9wZW4gaW4gYW4gZWRpdG9yIGJlZm9yZS4gQSBjbG9zZVxuICogbm90aWZpY2F0aW9uIHJlcXVpcmVzIGEgcHJldmlvdXMgb3BlbiBub3RpZmljYXRpb24gdG8gYmUgc2VudC5cbiAqL1xudmFyIERpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRDbG9zZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbikge1xuICAgIERpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvZGlkQ2xvc2UnO1xuICAgIERpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRDbG9zZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIGRvY3VtZW50IHNhdmUgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgd2hlblxuICogdGhlIGRvY3VtZW50IGdvdCBzYXZlZCBpbiB0aGUgY2xpZW50LlxuICovXG52YXIgRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbikge1xuICAgIERpZFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kID0gJ3RleHREb2N1bWVudC9kaWRTYXZlJztcbiAgICBEaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIFJlcHJlc2VudHMgcmVhc29ucyB3aHkgYSB0ZXh0IGRvY3VtZW50IGlzIHNhdmVkLlxuICovXG52YXIgVGV4dERvY3VtZW50U2F2ZVJlYXNvbjtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50U2F2ZVJlYXNvbikge1xuICAgIC8qKlxuICAgICAqIE1hbnVhbGx5IHRyaWdnZXJlZCwgZS5nLiBieSB0aGUgdXNlciBwcmVzc2luZyBzYXZlLCBieSBzdGFydGluZyBkZWJ1Z2dpbmcsXG4gICAgICogb3IgYnkgYW4gQVBJIGNhbGwuXG4gICAgICovXG4gICAgVGV4dERvY3VtZW50U2F2ZVJlYXNvbi5NYW51YWwgPSAxO1xuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpYyBhZnRlciBhIGRlbGF5LlxuICAgICAqL1xuICAgIFRleHREb2N1bWVudFNhdmVSZWFzb24uQWZ0ZXJEZWxheSA9IDI7XG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgZWRpdG9yIGxvc3QgZm9jdXMuXG4gICAgICovXG4gICAgVGV4dERvY3VtZW50U2F2ZVJlYXNvbi5Gb2N1c091dCA9IDM7XG59KShUZXh0RG9jdW1lbnRTYXZlUmVhc29uID0gZXhwb3J0cy5UZXh0RG9jdW1lbnRTYXZlUmVhc29uIHx8IChleHBvcnRzLlRleHREb2N1bWVudFNhdmVSZWFzb24gPSB7fSkpO1xuLyoqXG4gKiBBIGRvY3VtZW50IHdpbGwgc2F2ZSBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciBiZWZvcmVcbiAqIHRoZSBkb2N1bWVudCBpcyBhY3R1YWxseSBzYXZlZC5cbiAqL1xudmFyIFdpbGxTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChXaWxsU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbikge1xuICAgIFdpbGxTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvd2lsbFNhdmUnO1xuICAgIFdpbGxTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShXaWxsU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLldpbGxTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uIHx8IChleHBvcnRzLldpbGxTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogQSBkb2N1bWVudCB3aWxsIHNhdmUgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIGJlZm9yZVxuICogdGhlIGRvY3VtZW50IGlzIGFjdHVhbGx5IHNhdmVkLiBUaGUgcmVxdWVzdCBjYW4gcmV0dXJuIGFuIGFycmF5IG9mIFRleHRFZGl0c1xuICogd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSB0ZXh0IGRvY3VtZW50IGJlZm9yZSBpdCBpcyBzYXZlZC4gUGxlYXNlIG5vdGUgdGhhdFxuICogY2xpZW50cyBtaWdodCBkcm9wIHJlc3VsdHMgaWYgY29tcHV0aW5nIHRoZSB0ZXh0IGVkaXRzIHRvb2sgdG9vIGxvbmcgb3IgaWYgYVxuICogc2VydmVyIGNvbnN0YW50bHkgZmFpbHMgb24gdGhpcyByZXF1ZXN0LiBUaGlzIGlzIGRvbmUgdG8ga2VlcCB0aGUgc2F2ZSBmYXN0IGFuZFxuICogcmVsaWFibGUuXG4gKi9cbnZhciBXaWxsU2F2ZVRleHREb2N1bWVudFdhaXRVbnRpbFJlcXVlc3Q7XG4oZnVuY3Rpb24gKFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdCkge1xuICAgIFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3dpbGxTYXZlV2FpdFVudGlsJztcbiAgICBXaWxsU2F2ZVRleHREb2N1bWVudFdhaXRVbnRpbFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBXaWxsU2F2ZVRleHREb2N1bWVudFdhaXRVbnRpbFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0Lm1ldGhvZCk7XG59KShXaWxsU2F2ZVRleHREb2N1bWVudFdhaXRVbnRpbFJlcXVlc3QgPSBleHBvcnRzLldpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdCB8fCAoZXhwb3J0cy5XaWxsU2F2ZVRleHREb2N1bWVudFdhaXRVbnRpbFJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBUaGUgd2F0Y2hlZCBmaWxlcyBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB3aGVuXG4gKiB0aGUgY2xpZW50IGRldGVjdHMgY2hhbmdlcyB0byBmaWxlIHdhdGNoZWQgYnkgdGhlIGxhbmd1YWdlIGNsaWVudC5cbiAqL1xudmFyIERpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uKSB7XG4gICAgRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3b3Jrc3BhY2UvZGlkQ2hhbmdlV2F0Y2hlZEZpbGVzJztcbiAgICBEaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBmaWxlIGV2ZW50IHR5cGVcbiAqL1xudmFyIEZpbGVDaGFuZ2VUeXBlO1xuKGZ1bmN0aW9uIChGaWxlQ2hhbmdlVHlwZSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBmaWxlIGdvdCBjcmVhdGVkLlxuICAgICAqL1xuICAgIEZpbGVDaGFuZ2VUeXBlLkNyZWF0ZWQgPSAxO1xuICAgIC8qKlxuICAgICAqIFRoZSBmaWxlIGdvdCBjaGFuZ2VkLlxuICAgICAqL1xuICAgIEZpbGVDaGFuZ2VUeXBlLkNoYW5nZWQgPSAyO1xuICAgIC8qKlxuICAgICAqIFRoZSBmaWxlIGdvdCBkZWxldGVkLlxuICAgICAqL1xuICAgIEZpbGVDaGFuZ2VUeXBlLkRlbGV0ZWQgPSAzO1xufSkoRmlsZUNoYW5nZVR5cGUgPSBleHBvcnRzLkZpbGVDaGFuZ2VUeXBlIHx8IChleHBvcnRzLkZpbGVDaGFuZ2VUeXBlID0ge30pKTtcbnZhciBSZWxhdGl2ZVBhdHRlcm47XG4oZnVuY3Rpb24gKFJlbGF0aXZlUGF0dGVybikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmICh2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdHlwZXNfMS5VUkkuaXMoY2FuZGlkYXRlLmJhc2VVcmkpIHx8IHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLldvcmtzcGFjZUZvbGRlci5pcyhjYW5kaWRhdGUuYmFzZVVyaSkpICYmIElzLnN0cmluZyhjYW5kaWRhdGUucGF0dGVybik7XG4gICAgfVxuICAgIFJlbGF0aXZlUGF0dGVybi5pcyA9IGlzO1xufSkoUmVsYXRpdmVQYXR0ZXJuID0gZXhwb3J0cy5SZWxhdGl2ZVBhdHRlcm4gfHwgKGV4cG9ydHMuUmVsYXRpdmVQYXR0ZXJuID0ge30pKTtcbnZhciBXYXRjaEtpbmQ7XG4oZnVuY3Rpb24gKFdhdGNoS2luZCkge1xuICAgIC8qKlxuICAgICAqIEludGVyZXN0ZWQgaW4gY3JlYXRlIGV2ZW50cy5cbiAgICAgKi9cbiAgICBXYXRjaEtpbmQuQ3JlYXRlID0gMTtcbiAgICAvKipcbiAgICAgKiBJbnRlcmVzdGVkIGluIGNoYW5nZSBldmVudHNcbiAgICAgKi9cbiAgICBXYXRjaEtpbmQuQ2hhbmdlID0gMjtcbiAgICAvKipcbiAgICAgKiBJbnRlcmVzdGVkIGluIGRlbGV0ZSBldmVudHNcbiAgICAgKi9cbiAgICBXYXRjaEtpbmQuRGVsZXRlID0gNDtcbn0pKFdhdGNoS2luZCA9IGV4cG9ydHMuV2F0Y2hLaW5kIHx8IChleHBvcnRzLldhdGNoS2luZCA9IHt9KSk7XG4vKipcbiAqIERpYWdub3N0aWNzIG5vdGlmaWNhdGlvbiBhcmUgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byBzaWduYWxcbiAqIHJlc3VsdHMgb2YgdmFsaWRhdGlvbiBydW5zLlxuICovXG52YXIgUHVibGlzaERpYWdub3N0aWNzTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChQdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24pIHtcbiAgICBQdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24ubWV0aG9kID0gJ3RleHREb2N1bWVudC9wdWJsaXNoRGlhZ25vc3RpY3MnO1xuICAgIFB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIFB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKFB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoUHVibGlzaERpYWdub3N0aWNzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5QdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuUHVibGlzaERpYWdub3N0aWNzTm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogSG93IGEgY29tcGxldGlvbiB3YXMgdHJpZ2dlcmVkXG4gKi9cbnZhciBDb21wbGV0aW9uVHJpZ2dlcktpbmQ7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25UcmlnZ2VyS2luZCkge1xuICAgIC8qKlxuICAgICAqIENvbXBsZXRpb24gd2FzIHRyaWdnZXJlZCBieSB0eXBpbmcgYW4gaWRlbnRpZmllciAoMjR4NyBjb2RlXG4gICAgICogY29tcGxldGUpLCBtYW51YWwgaW52b2NhdGlvbiAoZS5nIEN0cmwrU3BhY2UpIG9yIHZpYSBBUEkuXG4gICAgICovXG4gICAgQ29tcGxldGlvblRyaWdnZXJLaW5kLkludm9rZWQgPSAxO1xuICAgIC8qKlxuICAgICAqIENvbXBsZXRpb24gd2FzIHRyaWdnZXJlZCBieSBhIHRyaWdnZXIgY2hhcmFjdGVyIHNwZWNpZmllZCBieVxuICAgICAqIHRoZSBgdHJpZ2dlckNoYXJhY3RlcnNgIHByb3BlcnRpZXMgb2YgdGhlIGBDb21wbGV0aW9uUmVnaXN0cmF0aW9uT3B0aW9uc2AuXG4gICAgICovXG4gICAgQ29tcGxldGlvblRyaWdnZXJLaW5kLlRyaWdnZXJDaGFyYWN0ZXIgPSAyO1xuICAgIC8qKlxuICAgICAqIENvbXBsZXRpb24gd2FzIHJlLXRyaWdnZXJlZCBhcyBjdXJyZW50IGNvbXBsZXRpb24gbGlzdCBpcyBpbmNvbXBsZXRlXG4gICAgICovXG4gICAgQ29tcGxldGlvblRyaWdnZXJLaW5kLlRyaWdnZXJGb3JJbmNvbXBsZXRlQ29tcGxldGlvbnMgPSAzO1xufSkoQ29tcGxldGlvblRyaWdnZXJLaW5kID0gZXhwb3J0cy5Db21wbGV0aW9uVHJpZ2dlcktpbmQgfHwgKGV4cG9ydHMuQ29tcGxldGlvblRyaWdnZXJLaW5kID0ge30pKTtcbi8qKlxuICogUmVxdWVzdCB0byByZXF1ZXN0IGNvbXBsZXRpb24gYXQgYSBnaXZlbiB0ZXh0IGRvY3VtZW50IHBvc2l0aW9uLiBUaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgVGV4dERvY3VtZW50UG9zaXRpb259IHRoZSByZXNwb25zZVxuICogaXMgb2YgdHlwZSB7QGxpbmsgQ29tcGxldGlvbkl0ZW0gQ29tcGxldGlvbkl0ZW1bXX0gb3Ige0BsaW5rIENvbXBsZXRpb25MaXN0fVxuICogb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKlxuICogVGhlIHJlcXVlc3QgY2FuIGRlbGF5IHRoZSBjb21wdXRhdGlvbiBvZiB0aGUge0BsaW5rIENvbXBsZXRpb25JdGVtLmRldGFpbCBgZGV0YWlsYH1cbiAqIGFuZCB7QGxpbmsgQ29tcGxldGlvbkl0ZW0uZG9jdW1lbnRhdGlvbiBgZG9jdW1lbnRhdGlvbmB9IHByb3BlcnRpZXMgdG8gdGhlIGBjb21wbGV0aW9uSXRlbS9yZXNvbHZlYFxuICogcmVxdWVzdC4gSG93ZXZlciwgcHJvcGVydGllcyB0aGF0IGFyZSBuZWVkZWQgZm9yIHRoZSBpbml0aWFsIHNvcnRpbmcgYW5kIGZpbHRlcmluZywgbGlrZSBgc29ydFRleHRgLFxuICogYGZpbHRlclRleHRgLCBgaW5zZXJ0VGV4dGAsIGFuZCBgdGV4dEVkaXRgLCBtdXN0IG5vdCBiZSBjaGFuZ2VkIGR1cmluZyByZXNvbHZlLlxuICovXG52YXIgQ29tcGxldGlvblJlcXVlc3Q7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25SZXF1ZXN0KSB7XG4gICAgQ29tcGxldGlvblJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9jb21wbGV0aW9uJztcbiAgICBDb21wbGV0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENvbXBsZXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENvbXBsZXRpb25SZXF1ZXN0Lm1ldGhvZCk7XG59KShDb21wbGV0aW9uUmVxdWVzdCA9IGV4cG9ydHMuQ29tcGxldGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuQ29tcGxldGlvblJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBSZXF1ZXN0IHRvIHJlc29sdmUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBmb3IgYSBnaXZlbiBjb21wbGV0aW9uIGl0ZW0uVGhlIHJlcXVlc3Qnc1xuICogcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIENvbXBsZXRpb25JdGVtfSB0aGUgcmVzcG9uc2VcbiAqIGlzIG9mIHR5cGUge0BsaW5rIENvbXBsZXRpb25JdGVtfSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIENvbXBsZXRpb25SZXNvbHZlUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29tcGxldGlvblJlc29sdmVSZXF1ZXN0KSB7XG4gICAgQ29tcGxldGlvblJlc29sdmVSZXF1ZXN0Lm1ldGhvZCA9ICdjb21wbGV0aW9uSXRlbS9yZXNvbHZlJztcbiAgICBDb21wbGV0aW9uUmVzb2x2ZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBDb21wbGV0aW9uUmVzb2x2ZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoQ29tcGxldGlvblJlc29sdmVSZXF1ZXN0Lm1ldGhvZCk7XG59KShDb21wbGV0aW9uUmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLkNvbXBsZXRpb25SZXNvbHZlUmVxdWVzdCB8fCAoZXhwb3J0cy5Db21wbGV0aW9uUmVzb2x2ZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBSZXF1ZXN0IHRvIHJlcXVlc3QgaG92ZXIgaW5mb3JtYXRpb24gYXQgYSBnaXZlbiB0ZXh0IGRvY3VtZW50IHBvc2l0aW9uLiBUaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgVGV4dERvY3VtZW50UG9zaXRpb259IHRoZSByZXNwb25zZSBpcyBvZlxuICogdHlwZSB7QGxpbmsgSG92ZXJ9IG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgSG92ZXJSZXF1ZXN0O1xuKGZ1bmN0aW9uIChIb3ZlclJlcXVlc3QpIHtcbiAgICBIb3ZlclJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9ob3Zlcic7XG4gICAgSG92ZXJSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgSG92ZXJSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKEhvdmVyUmVxdWVzdC5tZXRob2QpO1xufSkoSG92ZXJSZXF1ZXN0ID0gZXhwb3J0cy5Ib3ZlclJlcXVlc3QgfHwgKGV4cG9ydHMuSG92ZXJSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogSG93IGEgc2lnbmF0dXJlIGhlbHAgd2FzIHRyaWdnZXJlZC5cbiAqXG4gKiBAc2luY2UgMy4xNS4wXG4gKi9cbnZhciBTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQ7XG4oZnVuY3Rpb24gKFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZCkge1xuICAgIC8qKlxuICAgICAqIFNpZ25hdHVyZSBoZWxwIHdhcyBpbnZva2VkIG1hbnVhbGx5IGJ5IHRoZSB1c2VyIG9yIGJ5IGEgY29tbWFuZC5cbiAgICAgKi9cbiAgICBTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQuSW52b2tlZCA9IDE7XG4gICAgLyoqXG4gICAgICogU2lnbmF0dXJlIGhlbHAgd2FzIHRyaWdnZXJlZCBieSBhIHRyaWdnZXIgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZC5UcmlnZ2VyQ2hhcmFjdGVyID0gMjtcbiAgICAvKipcbiAgICAgKiBTaWduYXR1cmUgaGVscCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSBjdXJzb3IgbW92aW5nIG9yIGJ5IHRoZSBkb2N1bWVudCBjb250ZW50IGNoYW5naW5nLlxuICAgICAqL1xuICAgIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZC5Db250ZW50Q2hhbmdlID0gMztcbn0pKFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZCA9IGV4cG9ydHMuU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kIHx8IChleHBvcnRzLlNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZCA9IHt9KSk7XG52YXIgU2lnbmF0dXJlSGVscFJlcXVlc3Q7XG4oZnVuY3Rpb24gKFNpZ25hdHVyZUhlbHBSZXF1ZXN0KSB7XG4gICAgU2lnbmF0dXJlSGVscFJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9zaWduYXR1cmVIZWxwJztcbiAgICBTaWduYXR1cmVIZWxwUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFNpZ25hdHVyZUhlbHBSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFNpZ25hdHVyZUhlbHBSZXF1ZXN0Lm1ldGhvZCk7XG59KShTaWduYXR1cmVIZWxwUmVxdWVzdCA9IGV4cG9ydHMuU2lnbmF0dXJlSGVscFJlcXVlc3QgfHwgKGV4cG9ydHMuU2lnbmF0dXJlSGVscFJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSB0aGUgZGVmaW5pdGlvbiBsb2NhdGlvbiBvZiBhIHN5bWJvbCBhdCBhIGdpdmVuIHRleHRcbiAqIGRvY3VtZW50IHBvc2l0aW9uLiBUaGUgcmVxdWVzdCdzIHBhcmFtZXRlciBpcyBvZiB0eXBlIFtUZXh0RG9jdW1lbnRQb3NpdGlvbl1cbiAqICgjVGV4dERvY3VtZW50UG9zaXRpb24pIHRoZSByZXNwb25zZSBpcyBvZiBlaXRoZXIgdHlwZSB7QGxpbmsgRGVmaW5pdGlvbn1cbiAqIG9yIGEgdHlwZWQgYXJyYXkgb2Yge0BsaW5rIERlZmluaXRpb25MaW5rfSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXNcbiAqIHRvIHN1Y2guXG4gKi9cbnZhciBEZWZpbml0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoRGVmaW5pdGlvblJlcXVlc3QpIHtcbiAgICBEZWZpbml0aW9uUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2RlZmluaXRpb24nO1xuICAgIERlZmluaXRpb25SZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGVmaW5pdGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRGVmaW5pdGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKERlZmluaXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5EZWZpbml0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5EZWZpbml0aW9uUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHByb2plY3Qtd2lkZSByZWZlcmVuY2VzIGZvciB0aGUgc3ltYm9sIGRlbm90ZWRcbiAqIGJ5IHRoZSBnaXZlbiB0ZXh0IGRvY3VtZW50IHBvc2l0aW9uLiBUaGUgcmVxdWVzdCdzIHBhcmFtZXRlciBpcyBvZlxuICogdHlwZSB7QGxpbmsgUmVmZXJlbmNlUGFyYW1zfSB0aGUgcmVzcG9uc2UgaXMgb2YgdHlwZVxuICoge0BsaW5rIExvY2F0aW9uIExvY2F0aW9uW119IG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgUmVmZXJlbmNlc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKFJlZmVyZW5jZXNSZXF1ZXN0KSB7XG4gICAgUmVmZXJlbmNlc1JlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9yZWZlcmVuY2VzJztcbiAgICBSZWZlcmVuY2VzUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFJlZmVyZW5jZXNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFJlZmVyZW5jZXNSZXF1ZXN0Lm1ldGhvZCk7XG59KShSZWZlcmVuY2VzUmVxdWVzdCA9IGV4cG9ydHMuUmVmZXJlbmNlc1JlcXVlc3QgfHwgKGV4cG9ydHMuUmVmZXJlbmNlc1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBSZXF1ZXN0IHRvIHJlc29sdmUgYSB7QGxpbmsgRG9jdW1lbnRIaWdobGlnaHR9IGZvciBhIGdpdmVuXG4gKiB0ZXh0IGRvY3VtZW50IHBvc2l0aW9uLiBUaGUgcmVxdWVzdCdzIHBhcmFtZXRlciBpcyBvZiB0eXBlIFtUZXh0RG9jdW1lbnRQb3NpdGlvbl1cbiAqICgjVGV4dERvY3VtZW50UG9zaXRpb24pIHRoZSByZXF1ZXN0IHJlc3BvbnNlIGlzIG9mIHR5cGUgW0RvY3VtZW50SGlnaGxpZ2h0W11dXG4gKiAoI0RvY3VtZW50SGlnaGxpZ2h0KSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIERvY3VtZW50SGlnaGxpZ2h0UmVxdWVzdDtcbihmdW5jdGlvbiAoRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0KSB7XG4gICAgRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvZG9jdW1lbnRIaWdobGlnaHQnO1xuICAgIERvY3VtZW50SGlnaGxpZ2h0UmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERvY3VtZW50SGlnaGxpZ2h0UmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QubWV0aG9kKTtcbn0pKERvY3VtZW50SGlnaGxpZ2h0UmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0IHx8IChleHBvcnRzLkRvY3VtZW50SGlnaGxpZ2h0UmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBsaXN0IGFsbCBzeW1ib2xzIGZvdW5kIGluIGEgZ2l2ZW4gdGV4dCBkb2N1bWVudC4gVGhlIHJlcXVlc3Qnc1xuICogcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIFRleHREb2N1bWVudElkZW50aWZpZXJ9IHRoZVxuICogcmVzcG9uc2UgaXMgb2YgdHlwZSB7QGxpbmsgU3ltYm9sSW5mb3JtYXRpb24gU3ltYm9sSW5mb3JtYXRpb25bXX0gb3IgYSBUaGVuYWJsZVxuICogdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgRG9jdW1lbnRTeW1ib2xSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEb2N1bWVudFN5bWJvbFJlcXVlc3QpIHtcbiAgICBEb2N1bWVudFN5bWJvbFJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9kb2N1bWVudFN5bWJvbCc7XG4gICAgRG9jdW1lbnRTeW1ib2xSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRG9jdW1lbnRTeW1ib2xSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKERvY3VtZW50U3ltYm9sUmVxdWVzdC5tZXRob2QpO1xufSkoRG9jdW1lbnRTeW1ib2xSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudFN5bWJvbFJlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRTeW1ib2xSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHByb3ZpZGUgY29tbWFuZHMgZm9yIHRoZSBnaXZlbiB0ZXh0IGRvY3VtZW50IGFuZCByYW5nZS5cbiAqL1xudmFyIENvZGVBY3Rpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uUmVxdWVzdCkge1xuICAgIENvZGVBY3Rpb25SZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvY29kZUFjdGlvbic7XG4gICAgQ29kZUFjdGlvblJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBDb2RlQWN0aW9uUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDb2RlQWN0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoQ29kZUFjdGlvblJlcXVlc3QgPSBleHBvcnRzLkNvZGVBY3Rpb25SZXF1ZXN0IHx8IChleHBvcnRzLkNvZGVBY3Rpb25SZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogUmVxdWVzdCB0byByZXNvbHZlIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gZm9yIGEgZ2l2ZW4gY29kZSBhY3Rpb24uVGhlIHJlcXVlc3Qnc1xuICogcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIENvZGVBY3Rpb259IHRoZSByZXNwb25zZVxuICogaXMgb2YgdHlwZSB7QGxpbmsgQ29kZUFjdGlvbn0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBDb2RlQWN0aW9uUmVzb2x2ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKENvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdCkge1xuICAgIENvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdC5tZXRob2QgPSAnY29kZUFjdGlvbi9yZXNvbHZlJztcbiAgICBDb2RlQWN0aW9uUmVzb2x2ZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBDb2RlQWN0aW9uUmVzb2x2ZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0Lm1ldGhvZCk7XG59KShDb2RlQWN0aW9uUmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLkNvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdCB8fCAoZXhwb3J0cy5Db2RlQWN0aW9uUmVzb2x2ZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gbGlzdCBwcm9qZWN0LXdpZGUgc3ltYm9scyBtYXRjaGluZyB0aGUgcXVlcnkgc3RyaW5nIGdpdmVuXG4gKiBieSB0aGUge0BsaW5rIFdvcmtzcGFjZVN5bWJvbFBhcmFtc30uIFRoZSByZXNwb25zZSBpc1xuICogb2YgdHlwZSB7QGxpbmsgU3ltYm9sSW5mb3JtYXRpb24gU3ltYm9sSW5mb3JtYXRpb25bXX0gb3IgYSBUaGVuYWJsZSB0aGF0XG4gKiByZXNvbHZlcyB0byBzdWNoLlxuICpcbiAqIEBzaW5jZSAzLjE3LjAgLSBzdXBwb3J0IGZvciBXb3Jrc3BhY2VTeW1ib2wgaW4gdGhlIHJldHVybmVkIGRhdGEuIENsaWVudHNcbiAqICBuZWVkIHRvIGFkdmVydGlzZSBzdXBwb3J0IGZvciBXb3Jrc3BhY2VTeW1ib2xzIHZpYSB0aGUgY2xpZW50IGNhcGFiaWxpdHlcbiAqICBgd29ya3NwYWNlLnN5bWJvbC5yZXNvbHZlU3VwcG9ydGAuXG4gKlxuICovXG52YXIgV29ya3NwYWNlU3ltYm9sUmVxdWVzdDtcbihmdW5jdGlvbiAoV29ya3NwYWNlU3ltYm9sUmVxdWVzdCkge1xuICAgIFdvcmtzcGFjZVN5bWJvbFJlcXVlc3QubWV0aG9kID0gJ3dvcmtzcGFjZS9zeW1ib2wnO1xuICAgIFdvcmtzcGFjZVN5bWJvbFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBXb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFdvcmtzcGFjZVN5bWJvbFJlcXVlc3QubWV0aG9kKTtcbn0pKFdvcmtzcGFjZVN5bWJvbFJlcXVlc3QgPSBleHBvcnRzLldvcmtzcGFjZVN5bWJvbFJlcXVlc3QgfHwgKGV4cG9ydHMuV29ya3NwYWNlU3ltYm9sUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSByYW5nZSBpbnNpZGUgdGhlIHdvcmtzcGFjZVxuICogc3ltYm9sJ3MgbG9jYXRpb24uXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgV29ya3NwYWNlU3ltYm9sUmVzb2x2ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKFdvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0KSB7XG4gICAgV29ya3NwYWNlU3ltYm9sUmVzb2x2ZVJlcXVlc3QubWV0aG9kID0gJ3dvcmtzcGFjZVN5bWJvbC9yZXNvbHZlJztcbiAgICBXb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFdvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0Lm1ldGhvZCk7XG59KShXb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdCA9IGV4cG9ydHMuV29ya3NwYWNlU3ltYm9sUmVzb2x2ZVJlcXVlc3QgfHwgKGV4cG9ydHMuV29ya3NwYWNlU3ltYm9sUmVzb2x2ZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcHJvdmlkZSBjb2RlIGxlbnMgZm9yIHRoZSBnaXZlbiB0ZXh0IGRvY3VtZW50LlxuICovXG52YXIgQ29kZUxlbnNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChDb2RlTGVuc1JlcXVlc3QpIHtcbiAgICBDb2RlTGVuc1JlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9jb2RlTGVucyc7XG4gICAgQ29kZUxlbnNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgQ29kZUxlbnNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENvZGVMZW5zUmVxdWVzdC5tZXRob2QpO1xufSkoQ29kZUxlbnNSZXF1ZXN0ID0gZXhwb3J0cy5Db2RlTGVuc1JlcXVlc3QgfHwgKGV4cG9ydHMuQ29kZUxlbnNSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgYSBjb21tYW5kIGZvciBhIGdpdmVuIGNvZGUgbGVucy5cbiAqL1xudmFyIENvZGVMZW5zUmVzb2x2ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QpIHtcbiAgICBDb2RlTGVuc1Jlc29sdmVSZXF1ZXN0Lm1ldGhvZCA9ICdjb2RlTGVucy9yZXNvbHZlJztcbiAgICBDb2RlTGVuc1Jlc29sdmVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgQ29kZUxlbnNSZXNvbHZlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDb2RlTGVuc1Jlc29sdmVSZXF1ZXN0Lm1ldGhvZCk7XG59KShDb2RlTGVuc1Jlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5Db2RlTGVuc1Jlc29sdmVSZXF1ZXN0IHx8IChleHBvcnRzLkNvZGVMZW5zUmVzb2x2ZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVmcmVzaCBhbGwgY29kZSBhY3Rpb25zXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgQ29kZUxlbnNSZWZyZXNoUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29kZUxlbnNSZWZyZXNoUmVxdWVzdCkge1xuICAgIENvZGVMZW5zUmVmcmVzaFJlcXVlc3QubWV0aG9kID0gYHdvcmtzcGFjZS9jb2RlTGVucy9yZWZyZXNoYDtcbiAgICBDb2RlTGVuc1JlZnJlc2hSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgQ29kZUxlbnNSZWZyZXNoUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoQ29kZUxlbnNSZWZyZXNoUmVxdWVzdC5tZXRob2QpO1xufSkoQ29kZUxlbnNSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuQ29kZUxlbnNSZWZyZXNoUmVxdWVzdCB8fCAoZXhwb3J0cy5Db2RlTGVuc1JlZnJlc2hSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHByb3ZpZGUgZG9jdW1lbnQgbGlua3NcbiAqL1xudmFyIERvY3VtZW50TGlua1JlcXVlc3Q7XG4oZnVuY3Rpb24gKERvY3VtZW50TGlua1JlcXVlc3QpIHtcbiAgICBEb2N1bWVudExpbmtSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvZG9jdW1lbnRMaW5rJztcbiAgICBEb2N1bWVudExpbmtSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRG9jdW1lbnRMaW5rUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEb2N1bWVudExpbmtSZXF1ZXN0Lm1ldGhvZCk7XG59KShEb2N1bWVudExpbmtSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudExpbmtSZXF1ZXN0IHx8IChleHBvcnRzLkRvY3VtZW50TGlua1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBSZXF1ZXN0IHRvIHJlc29sdmUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBmb3IgYSBnaXZlbiBkb2N1bWVudCBsaW5rLiBUaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgRG9jdW1lbnRMaW5rfSB0aGUgcmVzcG9uc2VcbiAqIGlzIG9mIHR5cGUge0BsaW5rIERvY3VtZW50TGlua30gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdDtcbihmdW5jdGlvbiAoRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QpIHtcbiAgICBEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdC5tZXRob2QgPSAnZG9jdW1lbnRMaW5rL3Jlc29sdmUnO1xuICAgIERvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QubWV0aG9kKTtcbn0pKERvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byB0byBmb3JtYXQgYSB3aG9sZSBkb2N1bWVudC5cbiAqL1xudmFyIERvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3Q7XG4oZnVuY3Rpb24gKERvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3QpIHtcbiAgICBEb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvZm9ybWF0dGluZyc7XG4gICAgRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdC5tZXRob2QpO1xufSkoRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHRvIGZvcm1hdCBhIHJhbmdlIGluIGEgZG9jdW1lbnQuXG4gKi9cbnZhciBEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3Q7XG4oZnVuY3Rpb24gKERvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUmVxdWVzdCkge1xuICAgIERvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3JhbmdlRm9ybWF0dGluZyc7XG4gICAgRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKERvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUmVxdWVzdC5tZXRob2QpO1xufSkoRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIGZvcm1hdCBhIGRvY3VtZW50IG9uIHR5cGUuXG4gKi9cbnZhciBEb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0KSB7XG4gICAgRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L29uVHlwZUZvcm1hdHRpbmcnO1xuICAgIERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QubWV0aG9kKTtcbn0pKERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdCA9IHt9KSk7XG4vLy0tLS0gUmVuYW1lIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBQcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvcjtcbihmdW5jdGlvbiAoUHJlcGFyZVN1cHBvcnREZWZhdWx0QmVoYXZpb3IpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgY2xpZW50J3MgZGVmYXVsdCBiZWhhdmlvciBpcyB0byBzZWxlY3QgdGhlIGlkZW50aWZpZXJcbiAgICAgKiBhY2NvcmRpbmcgdGhlIHRvIGxhbmd1YWdlJ3Mgc3ludGF4IHJ1bGUuXG4gICAgICovXG4gICAgUHJlcGFyZVN1cHBvcnREZWZhdWx0QmVoYXZpb3IuSWRlbnRpZmllciA9IDE7XG59KShQcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvciA9IGV4cG9ydHMuUHJlcGFyZVN1cHBvcnREZWZhdWx0QmVoYXZpb3IgfHwgKGV4cG9ydHMuUHJlcGFyZVN1cHBvcnREZWZhdWx0QmVoYXZpb3IgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVuYW1lIGEgc3ltYm9sLlxuICovXG52YXIgUmVuYW1lUmVxdWVzdDtcbihmdW5jdGlvbiAoUmVuYW1lUmVxdWVzdCkge1xuICAgIFJlbmFtZVJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9yZW5hbWUnO1xuICAgIFJlbmFtZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBSZW5hbWVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFJlbmFtZVJlcXVlc3QubWV0aG9kKTtcbn0pKFJlbmFtZVJlcXVlc3QgPSBleHBvcnRzLlJlbmFtZVJlcXVlc3QgfHwgKGV4cG9ydHMuUmVuYW1lUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byB0ZXN0IGFuZCBwZXJmb3JtIHRoZSBzZXR1cCBuZWNlc3NhcnkgZm9yIGEgcmVuYW1lLlxuICpcbiAqIEBzaW5jZSAzLjE2IC0gc3VwcG9ydCBmb3IgZGVmYXVsdCBiZWhhdmlvclxuICovXG52YXIgUHJlcGFyZVJlbmFtZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKFByZXBhcmVSZW5hbWVSZXF1ZXN0KSB7XG4gICAgUHJlcGFyZVJlbmFtZVJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9wcmVwYXJlUmVuYW1lJztcbiAgICBQcmVwYXJlUmVuYW1lUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFByZXBhcmVSZW5hbWVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFByZXBhcmVSZW5hbWVSZXF1ZXN0Lm1ldGhvZCk7XG59KShQcmVwYXJlUmVuYW1lUmVxdWVzdCA9IGV4cG9ydHMuUHJlcGFyZVJlbmFtZVJlcXVlc3QgfHwgKGV4cG9ydHMuUHJlcGFyZVJlbmFtZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3Qgc2VuZCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB0byBleGVjdXRlIGEgY29tbWFuZC4gVGhlIHJlcXVlc3QgbWlnaHQgcmV0dXJuXG4gKiBhIHdvcmtzcGFjZSBlZGl0IHdoaWNoIHRoZSBjbGllbnQgd2lsbCBhcHBseSB0byB0aGUgd29ya3NwYWNlLlxuICovXG52YXIgRXhlY3V0ZUNvbW1hbmRSZXF1ZXN0O1xuKGZ1bmN0aW9uIChFeGVjdXRlQ29tbWFuZFJlcXVlc3QpIHtcbiAgICBFeGVjdXRlQ29tbWFuZFJlcXVlc3QubWV0aG9kID0gJ3dvcmtzcGFjZS9leGVjdXRlQ29tbWFuZCc7XG4gICAgRXhlY3V0ZUNvbW1hbmRSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRXhlY3V0ZUNvbW1hbmRSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKEV4ZWN1dGVDb21tYW5kUmVxdWVzdC5tZXRob2QpO1xufSkoRXhlY3V0ZUNvbW1hbmRSZXF1ZXN0ID0gZXhwb3J0cy5FeGVjdXRlQ29tbWFuZFJlcXVlc3QgfHwgKGV4cG9ydHMuRXhlY3V0ZUNvbW1hbmRSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gbW9kaWZpZWQgY2VydGFpbiByZXNvdXJjZXMuXG4gKi9cbnZhciBBcHBseVdvcmtzcGFjZUVkaXRSZXF1ZXN0O1xuKGZ1bmN0aW9uIChBcHBseVdvcmtzcGFjZUVkaXRSZXF1ZXN0KSB7XG4gICAgQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL2FwcGx5RWRpdCc7XG4gICAgQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIEFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoJ3dvcmtzcGFjZS9hcHBseUVkaXQnKTtcbn0pKEFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3QgPSBleHBvcnRzLkFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3QgfHwgKGV4cG9ydHMuQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDUyNzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkxpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTk5KTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHByb3ZpZGUgcmFuZ2VzIHRoYXQgY2FuIGJlIGVkaXRlZCB0b2dldGhlci5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBMaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0O1xuKGZ1bmN0aW9uIChMaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0KSB7XG4gICAgTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2xpbmtlZEVkaXRpbmdSYW5nZSc7XG4gICAgTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIExpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdC5tZXRob2QpO1xufSkoTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdCA9IGV4cG9ydHMuTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdCB8fCAoZXhwb3J0cy5MaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTk2NDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5Nb25pa2VyUmVxdWVzdCA9IGV4cG9ydHMuTW9uaWtlcktpbmQgPSBleHBvcnRzLlVuaXF1ZW5lc3NMZXZlbCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1OTkpO1xuLyoqXG4gKiBNb25pa2VyIHVuaXF1ZW5lc3MgbGV2ZWwgdG8gZGVmaW5lIHNjb3BlIG9mIHRoZSBtb25pa2VyLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFVuaXF1ZW5lc3NMZXZlbDtcbihmdW5jdGlvbiAoVW5pcXVlbmVzc0xldmVsKSB7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgaXMgb25seSB1bmlxdWUgaW5zaWRlIGEgZG9jdW1lbnRcbiAgICAgKi9cbiAgICBVbmlxdWVuZXNzTGV2ZWwuZG9jdW1lbnQgPSAnZG9jdW1lbnQnO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb25pa2VyIGlzIHVuaXF1ZSBpbnNpZGUgYSBwcm9qZWN0IGZvciB3aGljaCBhIGR1bXAgZ290IGNyZWF0ZWRcbiAgICAgKi9cbiAgICBVbmlxdWVuZXNzTGV2ZWwucHJvamVjdCA9ICdwcm9qZWN0JztcbiAgICAvKipcbiAgICAgKiBUaGUgbW9uaWtlciBpcyB1bmlxdWUgaW5zaWRlIHRoZSBncm91cCB0byB3aGljaCBhIHByb2plY3QgYmVsb25nc1xuICAgICAqL1xuICAgIFVuaXF1ZW5lc3NMZXZlbC5ncm91cCA9ICdncm91cCc7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgaXMgdW5pcXVlIGluc2lkZSB0aGUgbW9uaWtlciBzY2hlbWUuXG4gICAgICovXG4gICAgVW5pcXVlbmVzc0xldmVsLnNjaGVtZSA9ICdzY2hlbWUnO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb25pa2VyIGlzIGdsb2JhbGx5IHVuaXF1ZVxuICAgICAqL1xuICAgIFVuaXF1ZW5lc3NMZXZlbC5nbG9iYWwgPSAnZ2xvYmFsJztcbn0pKFVuaXF1ZW5lc3NMZXZlbCA9IGV4cG9ydHMuVW5pcXVlbmVzc0xldmVsIHx8IChleHBvcnRzLlVuaXF1ZW5lc3NMZXZlbCA9IHt9KSk7XG4vKipcbiAqIFRoZSBtb25pa2VyIGtpbmQuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgTW9uaWtlcktpbmQ7XG4oZnVuY3Rpb24gKE1vbmlrZXJLaW5kKSB7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgcmVwcmVzZW50IGEgc3ltYm9sIHRoYXQgaXMgaW1wb3J0ZWQgaW50byBhIHByb2plY3RcbiAgICAgKi9cbiAgICBNb25pa2VyS2luZC4kaW1wb3J0ID0gJ2ltcG9ydCc7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgcmVwcmVzZW50cyBhIHN5bWJvbCB0aGF0IGlzIGV4cG9ydGVkIGZyb20gYSBwcm9qZWN0XG4gICAgICovXG4gICAgTW9uaWtlcktpbmQuJGV4cG9ydCA9ICdleHBvcnQnO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb25pa2VyIHJlcHJlc2VudHMgYSBzeW1ib2wgdGhhdCBpcyBsb2NhbCB0byBhIHByb2plY3QgKGUuZy4gYSBsb2NhbFxuICAgICAqIHZhcmlhYmxlIG9mIGEgZnVuY3Rpb24sIGEgY2xhc3Mgbm90IHZpc2libGUgb3V0c2lkZSB0aGUgcHJvamVjdCwgLi4uKVxuICAgICAqL1xuICAgIE1vbmlrZXJLaW5kLmxvY2FsID0gJ2xvY2FsJztcbn0pKE1vbmlrZXJLaW5kID0gZXhwb3J0cy5Nb25pa2VyS2luZCB8fCAoZXhwb3J0cy5Nb25pa2VyS2luZCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBnZXQgdGhlIG1vbmlrZXIgb2YgYSBzeW1ib2wgYXQgYSBnaXZlbiB0ZXh0IGRvY3VtZW50IHBvc2l0aW9uLlxuICogVGhlIHJlcXVlc3QgcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIFRleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zfS5cbiAqIFRoZSByZXNwb25zZSBpcyBvZiB0eXBlIHtAbGluayBNb25pa2VyIE1vbmlrZXJbXX0gb3IgYG51bGxgLlxuICovXG52YXIgTW9uaWtlclJlcXVlc3Q7XG4oZnVuY3Rpb24gKE1vbmlrZXJSZXF1ZXN0KSB7XG4gICAgTW9uaWtlclJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9tb25pa2VyJztcbiAgICBNb25pa2VyUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIE1vbmlrZXJSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKE1vbmlrZXJSZXF1ZXN0Lm1ldGhvZCk7XG59KShNb25pa2VyUmVxdWVzdCA9IGV4cG9ydHMuTW9uaWtlclJlcXVlc3QgfHwgKGV4cG9ydHMuTW9uaWtlclJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NDYwOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkRpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLk5vdGVib29rQ2VsbEFycmF5Q2hhbmdlID0gZXhwb3J0cy5EaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlID0gZXhwb3J0cy5Ob3RlYm9va0RvY3VtZW50ID0gZXhwb3J0cy5Ob3RlYm9va0NlbGwgPSBleHBvcnRzLkV4ZWN1dGlvblN1bW1hcnkgPSBleHBvcnRzLk5vdGVib29rQ2VsbEtpbmQgPSB2b2lkIDA7XG5jb25zdCB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdHlwZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDc2Nyk7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oMjUyMyk7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTk5KTtcbi8qKlxuICogQSBub3RlYm9vayBjZWxsIGtpbmQuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgTm90ZWJvb2tDZWxsS2luZDtcbihmdW5jdGlvbiAoTm90ZWJvb2tDZWxsS2luZCkge1xuICAgIC8qKlxuICAgICAqIEEgbWFya3VwLWNlbGwgaXMgZm9ybWF0dGVkIHNvdXJjZSB0aGF0IGlzIHVzZWQgZm9yIGRpc3BsYXkuXG4gICAgICovXG4gICAgTm90ZWJvb2tDZWxsS2luZC5NYXJrdXAgPSAxO1xuICAgIC8qKlxuICAgICAqIEEgY29kZS1jZWxsIGlzIHNvdXJjZSBjb2RlLlxuICAgICAqL1xuICAgIE5vdGVib29rQ2VsbEtpbmQuQ29kZSA9IDI7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAxIHx8IHZhbHVlID09PSAyO1xuICAgIH1cbiAgICBOb3RlYm9va0NlbGxLaW5kLmlzID0gaXM7XG59KShOb3RlYm9va0NlbGxLaW5kID0gZXhwb3J0cy5Ob3RlYm9va0NlbGxLaW5kIHx8IChleHBvcnRzLk5vdGVib29rQ2VsbEtpbmQgPSB7fSkpO1xudmFyIEV4ZWN1dGlvblN1bW1hcnk7XG4oZnVuY3Rpb24gKEV4ZWN1dGlvblN1bW1hcnkpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoZXhlY3V0aW9uT3JkZXIsIHN1Y2Nlc3MpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBleGVjdXRpb25PcmRlciB9O1xuICAgICAgICBpZiAoc3VjY2VzcyA9PT0gdHJ1ZSB8fCBzdWNjZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmVzdWx0LnN1Y2Nlc3MgPSBzdWNjZXNzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIEV4ZWN1dGlvblN1bW1hcnkuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLnVpbnRlZ2VyLmlzKGNhbmRpZGF0ZS5leGVjdXRpb25PcmRlcikgJiYgKGNhbmRpZGF0ZS5zdWNjZXNzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUuc3VjY2VzcykpO1xuICAgIH1cbiAgICBFeGVjdXRpb25TdW1tYXJ5LmlzID0gaXM7XG4gICAgZnVuY3Rpb24gZXF1YWxzKG9uZSwgb3RoZXIpIHtcbiAgICAgICAgaWYgKG9uZSA9PT0gb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbmUgPT09IG51bGwgfHwgb25lID09PSB1bmRlZmluZWQgfHwgb3RoZXIgPT09IG51bGwgfHwgb3RoZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvbmUuZXhlY3V0aW9uT3JkZXIgPT09IG90aGVyLmV4ZWN1dGlvbk9yZGVyICYmIG9uZS5zdWNjZXNzID09PSBvdGhlci5zdWNjZXNzO1xuICAgIH1cbiAgICBFeGVjdXRpb25TdW1tYXJ5LmVxdWFscyA9IGVxdWFscztcbn0pKEV4ZWN1dGlvblN1bW1hcnkgPSBleHBvcnRzLkV4ZWN1dGlvblN1bW1hcnkgfHwgKGV4cG9ydHMuRXhlY3V0aW9uU3VtbWFyeSA9IHt9KSk7XG52YXIgTm90ZWJvb2tDZWxsO1xuKGZ1bmN0aW9uIChOb3RlYm9va0NlbGwpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoa2luZCwgZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHsga2luZCwgZG9jdW1lbnQgfTtcbiAgICB9XG4gICAgTm90ZWJvb2tDZWxsLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBOb3RlYm9va0NlbGxLaW5kLmlzKGNhbmRpZGF0ZS5raW5kKSAmJiB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdHlwZXNfMS5Eb2N1bWVudFVyaS5pcyhjYW5kaWRhdGUuZG9jdW1lbnQpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLm1ldGFkYXRhID09PSB1bmRlZmluZWQgfHwgSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUubWV0YWRhdGEpKTtcbiAgICB9XG4gICAgTm90ZWJvb2tDZWxsLmlzID0gaXM7XG4gICAgZnVuY3Rpb24gZGlmZihvbmUsIHR3bykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU2V0KCk7XG4gICAgICAgIGlmIChvbmUuZG9jdW1lbnQgIT09IHR3by5kb2N1bWVudCkge1xuICAgICAgICAgICAgcmVzdWx0LmFkZCgnZG9jdW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25lLmtpbmQgIT09IHR3by5raW5kKSB7XG4gICAgICAgICAgICByZXN1bHQuYWRkKCdraW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uZS5leGVjdXRpb25TdW1tYXJ5ICE9PSB0d28uZXhlY3V0aW9uU3VtbWFyeSkge1xuICAgICAgICAgICAgcmVzdWx0LmFkZCgnZXhlY3V0aW9uU3VtbWFyeScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgob25lLm1ldGFkYXRhICE9PSB1bmRlZmluZWQgfHwgdHdvLm1ldGFkYXRhICE9PSB1bmRlZmluZWQpICYmICFlcXVhbHNNZXRhZGF0YShvbmUubWV0YWRhdGEsIHR3by5tZXRhZGF0YSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hZGQoJ21ldGFkYXRhJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChvbmUuZXhlY3V0aW9uU3VtbWFyeSAhPT0gdW5kZWZpbmVkIHx8IHR3by5leGVjdXRpb25TdW1tYXJ5ICE9PSB1bmRlZmluZWQpICYmICFFeGVjdXRpb25TdW1tYXJ5LmVxdWFscyhvbmUuZXhlY3V0aW9uU3VtbWFyeSwgdHdvLmV4ZWN1dGlvblN1bW1hcnkpKSB7XG4gICAgICAgICAgICByZXN1bHQuYWRkKCdleGVjdXRpb25TdW1tYXJ5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgTm90ZWJvb2tDZWxsLmRpZmYgPSBkaWZmO1xuICAgIGZ1bmN0aW9uIGVxdWFsc01ldGFkYXRhKG9uZSwgb3RoZXIpIHtcbiAgICAgICAgaWYgKG9uZSA9PT0gb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbmUgPT09IG51bGwgfHwgb25lID09PSB1bmRlZmluZWQgfHwgb3RoZXIgPT09IG51bGwgfHwgb3RoZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb25lICE9PSB0eXBlb2Ygb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9uZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbmVBcnJheSA9IEFycmF5LmlzQXJyYXkob25lKTtcbiAgICAgICAgY29uc3Qgb3RoZXJBcnJheSA9IEFycmF5LmlzQXJyYXkob3RoZXIpO1xuICAgICAgICBpZiAob25lQXJyYXkgIT09IG90aGVyQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25lQXJyYXkgJiYgb3RoZXJBcnJheSkge1xuICAgICAgICAgICAgaWYgKG9uZS5sZW5ndGggIT09IG90aGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb25lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlcXVhbHNNZXRhZGF0YShvbmVbaV0sIG90aGVyW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5vYmplY3RMaXRlcmFsKG9uZSkgJiYgSXMub2JqZWN0TGl0ZXJhbChvdGhlcikpIHtcbiAgICAgICAgICAgIGNvbnN0IG9uZUtleXMgPSBPYmplY3Qua2V5cyhvbmUpO1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJLZXlzID0gT2JqZWN0LmtleXMob3RoZXIpO1xuICAgICAgICAgICAgaWYgKG9uZUtleXMubGVuZ3RoICE9PSBvdGhlcktleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25lS2V5cy5zb3J0KCk7XG4gICAgICAgICAgICBvdGhlcktleXMuc29ydCgpO1xuICAgICAgICAgICAgaWYgKCFlcXVhbHNNZXRhZGF0YShvbmVLZXlzLCBvdGhlcktleXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvbmVLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcCA9IG9uZUtleXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFlcXVhbHNNZXRhZGF0YShvbmVbcHJvcF0sIG90aGVyW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn0pKE5vdGVib29rQ2VsbCA9IGV4cG9ydHMuTm90ZWJvb2tDZWxsIHx8IChleHBvcnRzLk5vdGVib29rQ2VsbCA9IHt9KSk7XG52YXIgTm90ZWJvb2tEb2N1bWVudDtcbihmdW5jdGlvbiAoTm90ZWJvb2tEb2N1bWVudCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIG5vdGVib29rVHlwZSwgdmVyc2lvbiwgY2VsbHMpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpLCBub3RlYm9va1R5cGUsIHZlcnNpb24sIGNlbGxzIH07XG4gICAgfVxuICAgIE5vdGVib29rRG9jdW1lbnQuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdHlwZXNfMS5pbnRlZ2VyLmlzKGNhbmRpZGF0ZS52ZXJzaW9uKSAmJiBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5jZWxscywgTm90ZWJvb2tDZWxsLmlzKTtcbiAgICB9XG4gICAgTm90ZWJvb2tEb2N1bWVudC5pcyA9IGlzO1xufSkoTm90ZWJvb2tEb2N1bWVudCA9IGV4cG9ydHMuTm90ZWJvb2tEb2N1bWVudCB8fCAoZXhwb3J0cy5Ob3RlYm9va0RvY3VtZW50ID0ge30pKTtcbnZhciBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGU7XG4oZnVuY3Rpb24gKE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZSkge1xuICAgIE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZS5tZXRob2QgPSAnbm90ZWJvb2tEb2N1bWVudC9zeW5jJztcbiAgICBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUudHlwZSA9IG5ldyBtZXNzYWdlc18xLlJlZ2lzdHJhdGlvblR5cGUoTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZCk7XG59KShOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUgPSBleHBvcnRzLk5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZSB8fCAoZXhwb3J0cy5Ob3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUgPSB7fSkpO1xuLyoqXG4gKiBBIG5vdGlmaWNhdGlvbiBzZW50IHdoZW4gYSBub3RlYm9vayBvcGVucy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBEaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24pIHtcbiAgICBEaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAnbm90ZWJvb2tEb2N1bWVudC9kaWRPcGVuJztcbiAgICBEaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kKTtcbiAgICBEaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5yZWdpc3RyYXRpb25NZXRob2QgPSBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUubWV0aG9kO1xufSkoRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0ge30pKTtcbnZhciBOb3RlYm9va0NlbGxBcnJheUNoYW5nZTtcbihmdW5jdGlvbiAoTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2UpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdHlwZXNfMS51aW50ZWdlci5pcyhjYW5kaWRhdGUuc3RhcnQpICYmIHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLnVpbnRlZ2VyLmlzKGNhbmRpZGF0ZS5kZWxldGVDb3VudCkgJiYgKGNhbmRpZGF0ZS5jZWxscyA9PT0gdW5kZWZpbmVkIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLmNlbGxzLCBOb3RlYm9va0NlbGwuaXMpKTtcbiAgICB9XG4gICAgTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2UuaXMgPSBpcztcbiAgICBmdW5jdGlvbiBjcmVhdGUoc3RhcnQsIGRlbGV0ZUNvdW50LCBjZWxscykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7IHN0YXJ0LCBkZWxldGVDb3VudCB9O1xuICAgICAgICBpZiAoY2VsbHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmNlbGxzID0gY2VsbHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2UuY3JlYXRlID0gY3JlYXRlO1xufSkoTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2UgPSBleHBvcnRzLk5vdGVib29rQ2VsbEFycmF5Q2hhbmdlIHx8IChleHBvcnRzLk5vdGVib29rQ2VsbEFycmF5Q2hhbmdlID0ge30pKTtcbnZhciBEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAnbm90ZWJvb2tEb2N1bWVudC9kaWRDaGFuZ2UnO1xuICAgIERpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xuICAgIERpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ucmVnaXN0cmF0aW9uTWV0aG9kID0gTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZDtcbn0pKERpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIEEgbm90aWZpY2F0aW9uIHNlbnQgd2hlbiBhIG5vdGVib29rIGRvY3VtZW50IGlzIHNhdmVkLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIERpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbikge1xuICAgIERpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCA9ICdub3RlYm9va0RvY3VtZW50L2RpZFNhdmUnO1xuICAgIERpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xuICAgIERpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLnJlZ2lzdHJhdGlvbk1ldGhvZCA9IE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZS5tZXRob2Q7XG59KShEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBBIG5vdGlmaWNhdGlvbiBzZW50IHdoZW4gYSBub3RlYm9vayBjbG9zZXMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24pIHtcbiAgICBEaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kID0gJ25vdGVib29rRG9jdW1lbnQvZGlkQ2xvc2UnO1xuICAgIERpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xuICAgIERpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5yZWdpc3RyYXRpb25NZXRob2QgPSBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUubWV0aG9kO1xufSkoRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzg5NTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdCA9IGV4cG9ydHMuV29ya0RvbmVQcm9ncmVzcyA9IHZvaWQgMDtcbmNvbnN0IHZzY29kZV9qc29ucnBjXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5NTMpO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODU5OSk7XG52YXIgV29ya0RvbmVQcm9ncmVzcztcbihmdW5jdGlvbiAoV29ya0RvbmVQcm9ncmVzcykge1xuICAgIFdvcmtEb25lUHJvZ3Jlc3MudHlwZSA9IG5ldyB2c2NvZGVfanNvbnJwY18xLlByb2dyZXNzVHlwZSgpO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gV29ya0RvbmVQcm9ncmVzcy50eXBlO1xuICAgIH1cbiAgICBXb3JrRG9uZVByb2dyZXNzLmlzID0gaXM7XG59KShXb3JrRG9uZVByb2dyZXNzID0gZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzIHx8IChleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3MgPSB7fSkpO1xuLyoqXG4gKiBUaGUgYHdpbmRvdy93b3JrRG9uZVByb2dyZXNzL2NyZWF0ZWAgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIGluaXRpYXRlIHByb2dyZXNzXG4gKiByZXBvcnRpbmcgZnJvbSB0aGUgc2VydmVyLlxuICovXG52YXIgV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKFdvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0KSB7XG4gICAgV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QubWV0aG9kID0gJ3dpbmRvdy93b3JrRG9uZVByb2dyZXNzL2NyZWF0ZSc7XG4gICAgV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBXb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShXb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdC5tZXRob2QpO1xufSkoV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QgPSBleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0IHx8IChleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIGB3aW5kb3cvd29ya0RvbmVQcm9ncmVzcy9jYW5jZWxgIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB0byBjYW5jZWwgYSBwcm9ncmVzc1xuICogaW5pdGlhdGVkIG9uIHRoZSBzZXJ2ZXIgc2lkZS5cbiAqL1xudmFyIFdvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKFdvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24pIHtcbiAgICBXb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3aW5kb3cvd29ya0RvbmVQcm9ncmVzcy9jYW5jZWwnO1xuICAgIFdvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBXb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjM5Mjpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLlNlbGVjdGlvblJhbmdlUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1OTkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcHJvdmlkZSBzZWxlY3Rpb24gcmFuZ2VzIGluIGEgZG9jdW1lbnQuIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBTZWxlY3Rpb25SYW5nZVBhcmFtc30sIHRoZVxuICogcmVzcG9uc2UgaXMgb2YgdHlwZSB7QGxpbmsgU2VsZWN0aW9uUmFuZ2UgU2VsZWN0aW9uUmFuZ2VbXX0gb3IgYSBUaGVuYWJsZVxuICogdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0O1xuKGZ1bmN0aW9uIChTZWxlY3Rpb25SYW5nZVJlcXVlc3QpIHtcbiAgICBTZWxlY3Rpb25SYW5nZVJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9zZWxlY3Rpb25SYW5nZSc7XG4gICAgU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFNlbGVjdGlvblJhbmdlUmVxdWVzdC5tZXRob2QpO1xufSkoU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0ID0gZXhwb3J0cy5TZWxlY3Rpb25SYW5nZVJlcXVlc3QgfHwgKGV4cG9ydHMuU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODQ4OTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlID0gZXhwb3J0cy5Ub2tlbkZvcm1hdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1OTkpO1xuLy8tLS0tLS0tICd0ZXh0RG9jdW1lbnQvc2VtYW50aWNUb2tlbnMnIC0tLS0tXG52YXIgVG9rZW5Gb3JtYXQ7XG4oZnVuY3Rpb24gKFRva2VuRm9ybWF0KSB7XG4gICAgVG9rZW5Gb3JtYXQuUmVsYXRpdmUgPSAncmVsYXRpdmUnO1xufSkoVG9rZW5Gb3JtYXQgPSBleHBvcnRzLlRva2VuRm9ybWF0IHx8IChleHBvcnRzLlRva2VuRm9ybWF0ID0ge30pKTtcbnZhciBTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGU7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZSkge1xuICAgIFNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZS5tZXRob2QgPSAndGV4dERvY3VtZW50L3NlbWFudGljVG9rZW5zJztcbiAgICBTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUudHlwZSA9IG5ldyBtZXNzYWdlc18xLlJlZ2lzdHJhdGlvblR5cGUoU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZCk7XG59KShTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZSB8fCAoZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUgPSB7fSkpO1xuLyoqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBTZW1hbnRpY1Rva2Vuc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5zUmVxdWVzdCkge1xuICAgIFNlbWFudGljVG9rZW5zUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3NlbWFudGljVG9rZW5zL2Z1bGwnO1xuICAgIFNlbWFudGljVG9rZW5zUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFNlbWFudGljVG9rZW5zUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShTZW1hbnRpY1Rva2Vuc1JlcXVlc3QubWV0aG9kKTtcbiAgICBTZW1hbnRpY1Rva2Vuc1JlcXVlc3QucmVnaXN0cmF0aW9uTWV0aG9kID0gU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZDtcbn0pKFNlbWFudGljVG9rZW5zUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZXF1ZXN0IHx8IChleHBvcnRzLlNlbWFudGljVG9rZW5zUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0O1xuKGZ1bmN0aW9uIChTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdCkge1xuICAgIFNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvc2VtYW50aWNUb2tlbnMvZnVsbC9kZWx0YSc7XG4gICAgU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdC5tZXRob2QpO1xuICAgIFNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0LnJlZ2lzdHJhdGlvbk1ldGhvZCA9IFNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZS5tZXRob2Q7XG59KShTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QgfHwgKGV4cG9ydHMuU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBTZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdDtcbihmdW5jdGlvbiAoU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QpIHtcbiAgICBTZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3NlbWFudGljVG9rZW5zL3JhbmdlJztcbiAgICBTZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0Lm1ldGhvZCk7XG4gICAgU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QucmVnaXN0cmF0aW9uTWV0aG9kID0gU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZDtcbn0pKFNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0ID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdCB8fCAoZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3Q7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QpIHtcbiAgICBTZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0Lm1ldGhvZCA9IGB3b3Jrc3BhY2Uvc2VtYW50aWNUb2tlbnMvcmVmcmVzaGA7XG4gICAgU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUwKFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QubWV0aG9kKTtcbn0pKFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QgfHwgKGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDE1NDE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuU2hvd0RvY3VtZW50UmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1OTkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gc2hvdyBhIGRvY3VtZW50LiBUaGlzIHJlcXVlc3QgbWlnaHQgb3BlbiBhblxuICogZXh0ZXJuYWwgcHJvZ3JhbSBkZXBlbmRpbmcgb24gdGhlIHZhbHVlIG9mIHRoZSBVUkkgdG8gb3Blbi5cbiAqIEZvciBleGFtcGxlIGEgcmVxdWVzdCB0byBvcGVuIGBodHRwczovL2NvZGUudmlzdWFsc3R1ZGlvLmNvbS9gXG4gKiB3aWxsIHZlcnkgbGlrZWx5IG9wZW4gdGhlIFVSSSBpbiBhIFdFQiBicm93c2VyLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiovXG52YXIgU2hvd0RvY3VtZW50UmVxdWVzdDtcbihmdW5jdGlvbiAoU2hvd0RvY3VtZW50UmVxdWVzdCkge1xuICAgIFNob3dEb2N1bWVudFJlcXVlc3QubWV0aG9kID0gJ3dpbmRvdy9zaG93RG9jdW1lbnQnO1xuICAgIFNob3dEb2N1bWVudFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBTaG93RG9jdW1lbnRSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFNob3dEb2N1bWVudFJlcXVlc3QubWV0aG9kKTtcbn0pKFNob3dEb2N1bWVudFJlcXVlc3QgPSBleHBvcnRzLlNob3dEb2N1bWVudFJlcXVlc3QgfHwgKGV4cG9ydHMuU2hvd0RvY3VtZW50UmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg2NDI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuVHlwZURlZmluaXRpb25SZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODU5OSk7XG4vLyBAdHMtaWdub3JlOiB0byBhdm9pZCBpbmxpbmluZyBMb2NhdGlvTGluayBhcyBkeW5hbWljIGltcG9ydFxubGV0IF9fbm9EeW5hbWljSW1wb3J0O1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSB0aGUgdHlwZSBkZWZpbml0aW9uIGxvY2F0aW9ucyBvZiBhIHN5bWJvbCBhdCBhIGdpdmVuIHRleHRcbiAqIGRvY3VtZW50IHBvc2l0aW9uLiBUaGUgcmVxdWVzdCdzIHBhcmFtZXRlciBpcyBvZiB0eXBlIFtUZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtc11cbiAqICgjVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXMpIHRoZSByZXNwb25zZSBpcyBvZiB0eXBlIHtAbGluayBEZWZpbml0aW9ufSBvciBhXG4gKiBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBUeXBlRGVmaW5pdGlvblJlcXVlc3Q7XG4oZnVuY3Rpb24gKFR5cGVEZWZpbml0aW9uUmVxdWVzdCkge1xuICAgIFR5cGVEZWZpbml0aW9uUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3R5cGVEZWZpbml0aW9uJztcbiAgICBUeXBlRGVmaW5pdGlvblJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBUeXBlRGVmaW5pdGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoVHlwZURlZmluaXRpb25SZXF1ZXN0Lm1ldGhvZCk7XG59KShUeXBlRGVmaW5pdGlvblJlcXVlc3QgPSBleHBvcnRzLlR5cGVEZWZpbml0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5UeXBlRGVmaW5pdGlvblJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MzE4OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgVHlwZUZveCwgTWljcm9zb2Z0IGFuZCBvdGhlcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdCA9IGV4cG9ydHMuVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0ID0gZXhwb3J0cy5UeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTk5KTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc3VsdCBhIGBUeXBlSGllcmFyY2h5SXRlbWAgaW4gYSBkb2N1bWVudCBhdCBhIGdpdmVuIHBvc2l0aW9uLlxuICogQ2FuIGJlIHVzZWQgYXMgYW4gaW5wdXQgdG8gYSBzdWJ0eXBlcyBvciBzdXBlcnR5cGVzIHR5cGUgaGllcmFyY2h5LlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIFR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdDtcbihmdW5jdGlvbiAoVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0KSB7XG4gICAgVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvcHJlcGFyZVR5cGVIaWVyYXJjaHknO1xuICAgIFR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShUeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QubWV0aG9kKTtcbn0pKFR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IGV4cG9ydHMuVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0IHx8IChleHBvcnRzLlR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSBzdXBlcnR5cGVzIGZvciBhIGdpdmVuIGBUeXBlSGllcmFyY2h5SXRlbWAuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChUeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QpIHtcbiAgICBUeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QubWV0aG9kID0gJ3R5cGVIaWVyYXJjaHkvc3VwZXJ0eXBlcyc7XG4gICAgVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFR5cGVIaWVyYXJjaHlTdXBlcnR5cGVzUmVxdWVzdC5tZXRob2QpO1xufSkoVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0ID0gZXhwb3J0cy5UeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QgfHwgKGV4cG9ydHMuVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgdGhlIHN1YnR5cGVzIGZvciBhIGdpdmVuIGBUeXBlSGllcmFyY2h5SXRlbWAuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdDtcbihmdW5jdGlvbiAoVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdCkge1xuICAgIFR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QubWV0aG9kID0gJ3R5cGVIaWVyYXJjaHkvc3VidHlwZXMnO1xuICAgIFR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBUeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QubWV0aG9kKTtcbn0pKFR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QgPSBleHBvcnRzLlR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QgfHwgKGV4cG9ydHMuVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM0MDI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV29ya3NwYWNlRm9sZGVyc1JlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTk5KTtcbi8qKlxuICogVGhlIGB3b3Jrc3BhY2Uvd29ya3NwYWNlRm9sZGVyc2AgaXMgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byBmZXRjaCB0aGUgb3BlbiB3b3Jrc3BhY2UgZm9sZGVycy5cbiAqL1xudmFyIFdvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChXb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCkge1xuICAgIFdvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0Lm1ldGhvZCA9ICd3b3Jrc3BhY2Uvd29ya3NwYWNlRm9sZGVycyc7XG4gICAgV29ya3NwYWNlRm9sZGVyc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBXb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoV29ya3NwYWNlRm9sZGVyc1JlcXVlc3QubWV0aG9kKTtcbn0pKFdvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0ID0gZXhwb3J0cy5Xb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCB8fCAoZXhwb3J0cy5Xb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFRoZSBgd29ya3NwYWNlL2RpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNgIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHdoZW4gdGhlIHdvcmtzcGFjZVxuICogZm9sZGVyIGNvbmZpZ3VyYXRpb24gY2hhbmdlcy5cbiAqL1xudmFyIERpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24pIHtcbiAgICBEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3b3Jrc3BhY2UvZGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVycyc7XG4gICAgRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24gPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyNTIzOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLm9iamVjdExpdGVyYWwgPSBleHBvcnRzLnR5cGVkQXJyYXkgPSBleHBvcnRzLnN0cmluZ0FycmF5ID0gZXhwb3J0cy5hcnJheSA9IGV4cG9ydHMuZnVuYyA9IGV4cG9ydHMuZXJyb3IgPSBleHBvcnRzLm51bWJlciA9IGV4cG9ydHMuc3RyaW5nID0gZXhwb3J0cy5ib29sZWFuID0gdm9pZCAwO1xuZnVuY3Rpb24gYm9vbGVhbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2U7XG59XG5leHBvcnRzLmJvb2xlYW4gPSBib29sZWFuO1xuZnVuY3Rpb24gc3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmc7XG59XG5leHBvcnRzLnN0cmluZyA9IHN0cmluZztcbmZ1bmN0aW9uIG51bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyO1xufVxuZXhwb3J0cy5udW1iZXIgPSBudW1iZXI7XG5mdW5jdGlvbiBlcnJvcih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEVycm9yO1xufVxuZXhwb3J0cy5lcnJvciA9IGVycm9yO1xuZnVuY3Rpb24gZnVuYyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmZ1bmMgPSBmdW5jO1xuZnVuY3Rpb24gYXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5leHBvcnRzLmFycmF5ID0gYXJyYXk7XG5mdW5jdGlvbiBzdHJpbmdBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBhcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoZWxlbSA9PiBzdHJpbmcoZWxlbSkpO1xufVxuZXhwb3J0cy5zdHJpbmdBcnJheSA9IHN0cmluZ0FycmF5O1xuZnVuY3Rpb24gdHlwZWRBcnJheSh2YWx1ZSwgY2hlY2spIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoY2hlY2spO1xufVxuZXhwb3J0cy50eXBlZEFycmF5ID0gdHlwZWRBcnJheTtcbmZ1bmN0aW9uIG9iamVjdExpdGVyYWwodmFsdWUpIHtcbiAgICAvLyBTdHJpY3RseSBzcGVha2luZyBjbGFzcyBpbnN0YW5jZXMgcGFzcyB0aGlzIGNoZWNrIGFzIHdlbGwuIFNpbmNlIHRoZSBMU1BcbiAgICAvLyBkb2Vzbid0IHVzZSBjbGFzc2VzIHdlIGlnbm9yZSB0aGlzIGZvciBub3cuIElmIHdlIGRvIHdlIG5lZWQgdG8gYWRkIHNvbWV0aGluZ1xuICAgIC8vIGxpa2UgdGhpczogYE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3QuZ2V0UHJvdG90eXBlT2YoeCkpID09PSBudWxsYFxuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xufVxuZXhwb3J0cy5vYmplY3RMaXRlcmFsID0gb2JqZWN0TGl0ZXJhbDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDg4MTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBuOiAoKSA9PiAoLyogYmluZGluZyAqLyBUZXh0RG9jdW1lbnQpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxudmFyIF9fc3ByZWFkQXJyYXkgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbnZhciBGdWxsVGV4dERvY3VtZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZ1bGxUZXh0RG9jdW1lbnQodXJpLCBsYW5ndWFnZUlkLCB2ZXJzaW9uLCBjb250ZW50KSB7XG4gICAgICAgIHRoaXMuX3VyaSA9IHVyaTtcbiAgICAgICAgdGhpcy5fbGFuZ3VhZ2VJZCA9IGxhbmd1YWdlSWQ7XG4gICAgICAgIHRoaXMuX3ZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLl9jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZSwgXCJ1cmlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91cmk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUsIFwibGFuZ3VhZ2VJZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xhbmd1YWdlSWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUsIFwidmVyc2lvblwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcnNpb247XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5vZmZzZXRBdChyYW5nZS5zdGFydCk7XG4gICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5vZmZzZXRBdChyYW5nZS5lbmQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50O1xuICAgIH07XG4gICAgRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGNoYW5nZXMsIHZlcnNpb24pIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBjaGFuZ2VzXzEgPSBjaGFuZ2VzOyBfaSA8IGNoYW5nZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzXzFbX2ldO1xuICAgICAgICAgICAgaWYgKEZ1bGxUZXh0RG9jdW1lbnQuaXNJbmNyZW1lbnRhbChjaGFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFrZXMgc3VyZSBzdGFydCBpcyBiZWZvcmUgZW5kXG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZ2V0V2VsbGZvcm1lZFJhbmdlKGNoYW5nZS5yYW5nZSk7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGNvbnRlbnRcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRPZmZzZXQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kT2Zmc2V0ID0gdGhpcy5vZmZzZXRBdChyYW5nZS5lbmQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRlbnQgPSB0aGlzLl9jb250ZW50LnN1YnN0cmluZygwLCBzdGFydE9mZnNldCkgKyBjaGFuZ2UudGV4dCArIHRoaXMuX2NvbnRlbnQuc3Vic3RyaW5nKGVuZE9mZnNldCwgdGhpcy5fY29udGVudC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgb2Zmc2V0c1xuICAgICAgICAgICAgICAgIHZhciBzdGFydExpbmUgPSBNYXRoLm1heChyYW5nZS5zdGFydC5saW5lLCAwKTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kTGluZSA9IE1hdGgubWF4KHJhbmdlLmVuZC5saW5lLCAwKTtcbiAgICAgICAgICAgICAgICB2YXIgbGluZU9mZnNldHMgPSB0aGlzLl9saW5lT2Zmc2V0cztcbiAgICAgICAgICAgICAgICB2YXIgYWRkZWRMaW5lT2Zmc2V0cyA9IGNvbXB1dGVMaW5lT2Zmc2V0cyhjaGFuZ2UudGV4dCwgZmFsc2UsIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kTGluZSAtIHN0YXJ0TGluZSA9PT0gYWRkZWRMaW5lT2Zmc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFkZGVkTGluZU9mZnNldHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVPZmZzZXRzW2kgKyBzdGFydExpbmUgKyAxXSA9IGFkZGVkTGluZU9mZnNldHNbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGRlZExpbmVPZmZzZXRzLmxlbmd0aCA8IDEwMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lT2Zmc2V0cy5zcGxpY2UuYXBwbHkobGluZU9mZnNldHMsIF9fc3ByZWFkQXJyYXkoW3N0YXJ0TGluZSArIDEsIGVuZExpbmUgLSBzdGFydExpbmVdLCBhZGRlZExpbmVPZmZzZXRzLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBhdm9pZCB0b28gbWFueSBhcmd1bWVudHMgZm9yIHNwbGljZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSBsaW5lT2Zmc2V0cyA9IGxpbmVPZmZzZXRzLnNsaWNlKDAsIHN0YXJ0TGluZSArIDEpLmNvbmNhdChhZGRlZExpbmVPZmZzZXRzLCBsaW5lT2Zmc2V0cy5zbGljZShlbmRMaW5lICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkaWZmID0gY2hhbmdlLnRleHQubGVuZ3RoIC0gKGVuZE9mZnNldCAtIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoZGlmZiAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRMaW5lICsgMSArIGFkZGVkTGluZU9mZnNldHMubGVuZ3RoLCBsZW4gPSBsaW5lT2Zmc2V0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZU9mZnNldHNbaV0gPSBsaW5lT2Zmc2V0c1tpXSArIGRpZmY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChGdWxsVGV4dERvY3VtZW50LmlzRnVsbChjaGFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGVudCA9IGNoYW5nZS50ZXh0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNoYW5nZSBldmVudCByZWNlaXZlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIH07XG4gICAgRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUuZ2V0TGluZU9mZnNldHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9saW5lT2Zmc2V0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IGNvbXB1dGVMaW5lT2Zmc2V0cyh0aGlzLl9jb250ZW50LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbGluZU9mZnNldHM7XG4gICAgfTtcbiAgICBGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZS5wb3NpdGlvbkF0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSBNYXRoLm1heChNYXRoLm1pbihvZmZzZXQsIHRoaXMuX2NvbnRlbnQubGVuZ3RoKSwgMCk7XG4gICAgICAgIHZhciBsaW5lT2Zmc2V0cyA9IHRoaXMuZ2V0TGluZU9mZnNldHMoKTtcbiAgICAgICAgdmFyIGxvdyA9IDAsIGhpZ2ggPSBsaW5lT2Zmc2V0cy5sZW5ndGg7XG4gICAgICAgIGlmIChoaWdoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyBsaW5lOiAwLCBjaGFyYWN0ZXI6IG9mZnNldCB9O1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgICB2YXIgbWlkID0gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgICAgICAgIGlmIChsaW5lT2Zmc2V0c1ttaWRdID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG93IGlzIHRoZSBsZWFzdCB4IGZvciB3aGljaCB0aGUgbGluZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gdGhlIGN1cnJlbnQgb2Zmc2V0XG4gICAgICAgIC8vIG9yIGFycmF5Lmxlbmd0aCBpZiBubyBsaW5lIG9mZnNldCBpcyBsYXJnZXIgdGhhbiB0aGUgY3VycmVudCBvZmZzZXRcbiAgICAgICAgdmFyIGxpbmUgPSBsb3cgLSAxO1xuICAgICAgICByZXR1cm4geyBsaW5lOiBsaW5lLCBjaGFyYWN0ZXI6IG9mZnNldCAtIGxpbmVPZmZzZXRzW2xpbmVdIH07XG4gICAgfTtcbiAgICBGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZS5vZmZzZXRBdCA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICB2YXIgbGluZU9mZnNldHMgPSB0aGlzLmdldExpbmVPZmZzZXRzKCk7XG4gICAgICAgIGlmIChwb3NpdGlvbi5saW5lID49IGxpbmVPZmZzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvc2l0aW9uLmxpbmUgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGluZU9mZnNldCA9IGxpbmVPZmZzZXRzW3Bvc2l0aW9uLmxpbmVdO1xuICAgICAgICB2YXIgbmV4dExpbmVPZmZzZXQgPSAocG9zaXRpb24ubGluZSArIDEgPCBsaW5lT2Zmc2V0cy5sZW5ndGgpID8gbGluZU9mZnNldHNbcG9zaXRpb24ubGluZSArIDFdIDogdGhpcy5fY29udGVudC5sZW5ndGg7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihsaW5lT2Zmc2V0ICsgcG9zaXRpb24uY2hhcmFjdGVyLCBuZXh0TGluZU9mZnNldCksIGxpbmVPZmZzZXQpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLCBcImxpbmVDb3VudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGluZU9mZnNldHMoKS5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBGdWxsVGV4dERvY3VtZW50LmlzSW5jcmVtZW50YWwgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IGV2ZW50O1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgY2FuZGlkYXRlLnRleHQgPT09ICdzdHJpbmcnICYmIGNhbmRpZGF0ZS5yYW5nZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLnJhbmdlTGVuZ3RoID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGNhbmRpZGF0ZS5yYW5nZUxlbmd0aCA9PT0gJ251bWJlcicpO1xuICAgIH07XG4gICAgRnVsbFRleHREb2N1bWVudC5pc0Z1bGwgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IGV2ZW50O1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgY2FuZGlkYXRlLnRleHQgPT09ICdzdHJpbmcnICYmIGNhbmRpZGF0ZS5yYW5nZSA9PT0gdW5kZWZpbmVkICYmIGNhbmRpZGF0ZS5yYW5nZUxlbmd0aCA9PT0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgcmV0dXJuIEZ1bGxUZXh0RG9jdW1lbnQ7XG59KCkpO1xudmFyIFRleHREb2N1bWVudDtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0ZXh0IGRvY3VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIGxhbmd1YWdlSWQgIFRoZSBkb2N1bWVudCdzIGxhbmd1YWdlIElkLlxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIFRoZSBkb2N1bWVudCdzIGluaXRpYWwgdmVyc2lvbiBudW1iZXIuXG4gICAgICogQHBhcmFtIGNvbnRlbnQgVGhlIGRvY3VtZW50J3MgY29udGVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCBsYW5ndWFnZUlkLCB2ZXJzaW9uLCBjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVsbFRleHREb2N1bWVudCh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYSBUZXh0RG9jdW1lbnQgYnkgbW9kaWZ5aW5nIGl0cyBjb250ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRvY3VtZW50IHRoZSBkb2N1bWVudCB0byB1cGRhdGUuIE9ubHkgZG9jdW1lbnRzIGNyZWF0ZWQgYnkgVGV4dERvY3VtZW50LmNyZWF0ZSBhcmUgdmFsaWQgaW5wdXRzLlxuICAgICAqIEBwYXJhbSBjaGFuZ2VzIHRoZSBjaGFuZ2VzIHRvIGFwcGx5IHRvIHRoZSBkb2N1bWVudC5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiB0aGUgY2hhbmdlcyB2ZXJzaW9uIGZvciB0aGUgZG9jdW1lbnQuXG4gICAgICogQHJldHVybnMgVGhlIHVwZGF0ZWQgVGV4dERvY3VtZW50LiBOb3RlOiBUaGF0J3MgdGhlIHNhbWUgZG9jdW1lbnQgaW5zdGFuY2UgcGFzc2VkIGluIGFzIGZpcnN0IHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZShkb2N1bWVudCwgY2hhbmdlcywgdmVyc2lvbikge1xuICAgICAgICBpZiAoZG9jdW1lbnQgaW5zdGFuY2VvZiBGdWxsVGV4dERvY3VtZW50KSB7XG4gICAgICAgICAgICBkb2N1bWVudC51cGRhdGUoY2hhbmdlcywgdmVyc2lvbik7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHREb2N1bWVudC51cGRhdGU6IGRvY3VtZW50IG11c3QgYmUgY3JlYXRlZCBieSBUZXh0RG9jdW1lbnQuY3JlYXRlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVGV4dERvY3VtZW50LnVwZGF0ZSA9IHVwZGF0ZTtcbiAgICBmdW5jdGlvbiBhcHBseUVkaXRzKGRvY3VtZW50LCBlZGl0cykge1xuICAgICAgICB2YXIgdGV4dCA9IGRvY3VtZW50LmdldFRleHQoKTtcbiAgICAgICAgdmFyIHNvcnRlZEVkaXRzID0gbWVyZ2VTb3J0KGVkaXRzLm1hcChnZXRXZWxsZm9ybWVkRWRpdCksIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IGEucmFuZ2Uuc3RhcnQubGluZSAtIGIucmFuZ2Uuc3RhcnQubGluZTtcbiAgICAgICAgICAgIGlmIChkaWZmID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyIC0gYi5yYW5nZS5zdGFydC5jaGFyYWN0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsYXN0TW9kaWZpZWRPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgc3BhbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzb3J0ZWRFZGl0c18xID0gc29ydGVkRWRpdHM7IF9pIDwgc29ydGVkRWRpdHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBlID0gc29ydGVkRWRpdHNfMVtfaV07XG4gICAgICAgICAgICB2YXIgc3RhcnRPZmZzZXQgPSBkb2N1bWVudC5vZmZzZXRBdChlLnJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChzdGFydE9mZnNldCA8IGxhc3RNb2RpZmllZE9mZnNldCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3ZlcmxhcHBpbmcgZWRpdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnRPZmZzZXQgPiBsYXN0TW9kaWZpZWRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBzcGFucy5wdXNoKHRleHQuc3Vic3RyaW5nKGxhc3RNb2RpZmllZE9mZnNldCwgc3RhcnRPZmZzZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlLm5ld1RleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc3BhbnMucHVzaChlLm5ld1RleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdE1vZGlmaWVkT2Zmc2V0ID0gZG9jdW1lbnQub2Zmc2V0QXQoZS5yYW5nZS5lbmQpO1xuICAgICAgICB9XG4gICAgICAgIHNwYW5zLnB1c2godGV4dC5zdWJzdHIobGFzdE1vZGlmaWVkT2Zmc2V0KSk7XG4gICAgICAgIHJldHVybiBzcGFucy5qb2luKCcnKTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50LmFwcGx5RWRpdHMgPSBhcHBseUVkaXRzO1xufSkoVGV4dERvY3VtZW50IHx8IChUZXh0RG9jdW1lbnQgPSB7fSkpO1xuZnVuY3Rpb24gbWVyZ2VTb3J0KGRhdGEsIGNvbXBhcmUpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPD0gMSkge1xuICAgICAgICAvLyBzb3J0ZWRcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIHZhciBwID0gKGRhdGEubGVuZ3RoIC8gMikgfCAwO1xuICAgIHZhciBsZWZ0ID0gZGF0YS5zbGljZSgwLCBwKTtcbiAgICB2YXIgcmlnaHQgPSBkYXRhLnNsaWNlKHApO1xuICAgIG1lcmdlU29ydChsZWZ0LCBjb21wYXJlKTtcbiAgICBtZXJnZVNvcnQocmlnaHQsIGNvbXBhcmUpO1xuICAgIHZhciBsZWZ0SWR4ID0gMDtcbiAgICB2YXIgcmlnaHRJZHggPSAwO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAobGVmdElkeCA8IGxlZnQubGVuZ3RoICYmIHJpZ2h0SWR4IDwgcmlnaHQubGVuZ3RoKSB7XG4gICAgICAgIHZhciByZXQgPSBjb21wYXJlKGxlZnRbbGVmdElkeF0sIHJpZ2h0W3JpZ2h0SWR4XSk7XG4gICAgICAgIGlmIChyZXQgPD0gMCkge1xuICAgICAgICAgICAgLy8gc21hbGxlcl9lcXVhbCAtPiB0YWtlIGxlZnQgdG8gcHJlc2VydmUgb3JkZXJcbiAgICAgICAgICAgIGRhdGFbaSsrXSA9IGxlZnRbbGVmdElkeCsrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGdyZWF0ZXIgLT4gdGFrZSByaWdodFxuICAgICAgICAgICAgZGF0YVtpKytdID0gcmlnaHRbcmlnaHRJZHgrK107XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKGxlZnRJZHggPCBsZWZ0Lmxlbmd0aCkge1xuICAgICAgICBkYXRhW2krK10gPSBsZWZ0W2xlZnRJZHgrK107XG4gICAgfVxuICAgIHdoaWxlIChyaWdodElkeCA8IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICBkYXRhW2krK10gPSByaWdodFtyaWdodElkeCsrXTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBjb21wdXRlTGluZU9mZnNldHModGV4dCwgaXNBdExpbmVTdGFydCwgdGV4dE9mZnNldCkge1xuICAgIGlmICh0ZXh0T2Zmc2V0ID09PSB2b2lkIDApIHsgdGV4dE9mZnNldCA9IDA7IH1cbiAgICB2YXIgcmVzdWx0ID0gaXNBdExpbmVTdGFydCA/IFt0ZXh0T2Zmc2V0XSA6IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2ggPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjaCA9PT0gMTMgLyogQ2hhckNvZGUuQ2FycmlhZ2VSZXR1cm4gKi8gfHwgY2ggPT09IDEwIC8qIENoYXJDb2RlLkxpbmVGZWVkICovKSB7XG4gICAgICAgICAgICBpZiAoY2ggPT09IDEzIC8qIENoYXJDb2RlLkNhcnJpYWdlUmV0dXJuICovICYmIGkgKyAxIDwgdGV4dC5sZW5ndGggJiYgdGV4dC5jaGFyQ29kZUF0KGkgKyAxKSA9PT0gMTAgLyogQ2hhckNvZGUuTGluZUZlZWQgKi8pIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0ZXh0T2Zmc2V0ICsgaSArIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRXZWxsZm9ybWVkUmFuZ2UocmFuZ2UpIHtcbiAgICB2YXIgc3RhcnQgPSByYW5nZS5zdGFydDtcbiAgICB2YXIgZW5kID0gcmFuZ2UuZW5kO1xuICAgIGlmIChzdGFydC5saW5lID4gZW5kLmxpbmUgfHwgKHN0YXJ0LmxpbmUgPT09IGVuZC5saW5lICYmIHN0YXJ0LmNoYXJhY3RlciA+IGVuZC5jaGFyYWN0ZXIpKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXJ0OiBlbmQsIGVuZDogc3RhcnQgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlO1xufVxuZnVuY3Rpb24gZ2V0V2VsbGZvcm1lZEVkaXQodGV4dEVkaXQpIHtcbiAgICB2YXIgcmFuZ2UgPSBnZXRXZWxsZm9ybWVkUmFuZ2UodGV4dEVkaXQucmFuZ2UpO1xuICAgIGlmIChyYW5nZSAhPT0gdGV4dEVkaXQucmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHsgbmV3VGV4dDogdGV4dEVkaXQubmV3VGV4dCwgcmFuZ2U6IHJhbmdlIH07XG4gICAgfVxuICAgIHJldHVybiB0ZXh0RWRpdDtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDc2Nzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBBbm5vdGF0ZWRUZXh0RWRpdDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQW5ub3RhdGVkVGV4dEVkaXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDaGFuZ2VBbm5vdGF0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBDaGFuZ2VBbm5vdGF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29kZUFjdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29kZUFjdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvZGVBY3Rpb25Db250ZXh0OiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2RlQWN0aW9uQ29udGV4dCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvZGVBY3Rpb25LaW5kOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2RlQWN0aW9uS2luZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvZGVBY3Rpb25UcmlnZ2VyS2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29kZUFjdGlvblRyaWdnZXJLaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29kZURlc2NyaXB0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2RlRGVzY3JpcHRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb2RlTGVuczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29kZUxlbnMpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb2xvcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29sb3IpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb2xvckluZm9ybWF0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2xvckluZm9ybWF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29sb3JQcmVzZW50YXRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIENvbG9yUHJlc2VudGF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tbWFuZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29tbWFuZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvbXBsZXRpb25JdGVtOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb21wbGV0aW9uSXRlbSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvbXBsZXRpb25JdGVtS2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29tcGxldGlvbkl0ZW1LaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHM6ICgpID0+ICgvKiBiaW5kaW5nICovIENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tcGxldGlvbkl0ZW1UYWc6ICgpID0+ICgvKiBiaW5kaW5nICovIENvbXBsZXRpb25JdGVtVGFnKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tcGxldGlvbkxpc3Q6ICgpID0+ICgvKiBiaW5kaW5nICovIENvbXBsZXRpb25MaXN0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ3JlYXRlRmlsZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ3JlYXRlRmlsZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERlbGV0ZUZpbGU6ICgpID0+ICgvKiBiaW5kaW5nICovIERlbGV0ZUZpbGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBEaWFnbm9zdGljOiAoKSA9PiAoLyogYmluZGluZyAqLyBEaWFnbm9zdGljKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERpYWdub3N0aWNTZXZlcml0eTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRGlhZ25vc3RpY1NldmVyaXR5KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRGlhZ25vc3RpY1RhZzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRGlhZ25vc3RpY1RhZyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERvY3VtZW50SGlnaGxpZ2h0OiAoKSA9PiAoLyogYmluZGluZyAqLyBEb2N1bWVudEhpZ2hsaWdodCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERvY3VtZW50SGlnaGxpZ2h0S2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRG9jdW1lbnRIaWdobGlnaHRLaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRG9jdW1lbnRMaW5rOiAoKSA9PiAoLyogYmluZGluZyAqLyBEb2N1bWVudExpbmspLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBEb2N1bWVudFN5bWJvbDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRG9jdW1lbnRTeW1ib2wpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBEb2N1bWVudFVyaTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRG9jdW1lbnRVcmkpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBFT0w6ICgpID0+ICgvKiBiaW5kaW5nICovIEVPTCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEZvbGRpbmdSYW5nZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRm9sZGluZ1JhbmdlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRm9sZGluZ1JhbmdlS2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRm9sZGluZ1JhbmdlS2luZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEZvcm1hdHRpbmdPcHRpb25zOiAoKSA9PiAoLyogYmluZGluZyAqLyBGb3JtYXR0aW5nT3B0aW9ucyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEhvdmVyOiAoKSA9PiAoLyogYmluZGluZyAqLyBIb3ZlciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIElubGF5SGludDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5sYXlIaW50KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5sYXlIaW50S2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5sYXlIaW50S2luZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIElubGF5SGludExhYmVsUGFydDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5sYXlIaW50TGFiZWxQYXJ0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5saW5lVmFsdWVDb250ZXh0OiAoKSA9PiAoLyogYmluZGluZyAqLyBJbmxpbmVWYWx1ZUNvbnRleHQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBJbmxpbmVWYWx1ZVRleHQ6ICgpID0+ICgvKiBiaW5kaW5nICovIElubGluZVZhbHVlVGV4dCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIElubGluZVZhbHVlVmFyaWFibGVMb29rdXA6ICgpID0+ICgvKiBiaW5kaW5nICovIElubGluZVZhbHVlVmFyaWFibGVMb29rdXApLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBJbnNlcnRSZXBsYWNlRWRpdDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5zZXJ0UmVwbGFjZUVkaXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBJbnNlcnRUZXh0Rm9ybWF0OiAoKSA9PiAoLyogYmluZGluZyAqLyBJbnNlcnRUZXh0Rm9ybWF0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5zZXJ0VGV4dE1vZGU6ICgpID0+ICgvKiBiaW5kaW5nICovIEluc2VydFRleHRNb2RlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgTG9jYXRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIExvY2F0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgTG9jYXRpb25MaW5rOiAoKSA9PiAoLyogYmluZGluZyAqLyBMb2NhdGlvbkxpbmspLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBNYXJrZWRTdHJpbmc6ICgpID0+ICgvKiBiaW5kaW5nICovIE1hcmtlZFN0cmluZyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIE1hcmt1cENvbnRlbnQ6ICgpID0+ICgvKiBiaW5kaW5nICovIE1hcmt1cENvbnRlbnQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBNYXJrdXBLaW5kOiAoKSA9PiAoLyogYmluZGluZyAqLyBNYXJrdXBLaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyOiAoKSA9PiAoLyogYmluZGluZyAqLyBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBQYXJhbWV0ZXJJbmZvcm1hdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gUGFyYW1ldGVySW5mb3JtYXRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBQb3NpdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gUG9zaXRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBSYW5nZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gUmFuZ2UpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBSZW5hbWVGaWxlOiAoKSA9PiAoLyogYmluZGluZyAqLyBSZW5hbWVGaWxlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2VsZWN0aW9uUmFuZ2U6ICgpID0+ICgvKiBiaW5kaW5nICovIFNlbGVjdGlvblJhbmdlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU2VtYW50aWNUb2tlbk1vZGlmaWVycyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFNlbWFudGljVG9rZW5UeXBlczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU2VtYW50aWNUb2tlblR5cGVzKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2VtYW50aWNUb2tlbnM6ICgpID0+ICgvKiBiaW5kaW5nICovIFNlbWFudGljVG9rZW5zKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2lnbmF0dXJlSW5mb3JtYXRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIFNpZ25hdHVyZUluZm9ybWF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU3ltYm9sSW5mb3JtYXRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIFN5bWJvbEluZm9ybWF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU3ltYm9sS2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU3ltYm9sS2luZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFN5bWJvbFRhZzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU3ltYm9sVGFnKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgVGV4dERvY3VtZW50OiAoKSA9PiAoLyogYmluZGluZyAqLyBUZXh0RG9jdW1lbnQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBUZXh0RG9jdW1lbnRFZGl0OiAoKSA9PiAoLyogYmluZGluZyAqLyBUZXh0RG9jdW1lbnRFZGl0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgVGV4dERvY3VtZW50SWRlbnRpZmllcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVGV4dERvY3VtZW50SWRlbnRpZmllciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFRleHREb2N1bWVudEl0ZW06ICgpID0+ICgvKiBiaW5kaW5nICovIFRleHREb2N1bWVudEl0ZW0pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBUZXh0RWRpdDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVGV4dEVkaXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBVUkk6ICgpID0+ICgvKiBiaW5kaW5nICovIFVSSSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBXb3Jrc3BhY2VDaGFuZ2U6ICgpID0+ICgvKiBiaW5kaW5nICovIFdvcmtzcGFjZUNoYW5nZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFdvcmtzcGFjZUVkaXQ6ICgpID0+ICgvKiBiaW5kaW5nICovIFdvcmtzcGFjZUVkaXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBXb3Jrc3BhY2VGb2xkZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIFdvcmtzcGFjZUZvbGRlciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFdvcmtzcGFjZVN5bWJvbDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gV29ya3NwYWNlU3ltYm9sKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgaW50ZWdlcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gaW50ZWdlciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHVpbnRlZ2VyOiAoKSA9PiAoLyogYmluZGluZyAqLyB1aW50ZWdlcilcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG52YXIgRG9jdW1lbnRVcmk7XG4oZnVuY3Rpb24gKERvY3VtZW50VXJpKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIERvY3VtZW50VXJpLmlzID0gaXM7XG59KShEb2N1bWVudFVyaSB8fCAoRG9jdW1lbnRVcmkgPSB7fSkpO1xudmFyIFVSSTtcbihmdW5jdGlvbiAoVVJJKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIFVSSS5pcyA9IGlzO1xufSkoVVJJIHx8IChVUkkgPSB7fSkpO1xudmFyIGludGVnZXI7XG4oZnVuY3Rpb24gKGludGVnZXIpIHtcbiAgICBpbnRlZ2VyLk1JTl9WQUxVRSA9IC0yMTQ3NDgzNjQ4O1xuICAgIGludGVnZXIuTUFYX1ZBTFVFID0gMjE0NzQ4MzY0NztcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpbnRlZ2VyLk1JTl9WQUxVRSA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSBpbnRlZ2VyLk1BWF9WQUxVRTtcbiAgICB9XG4gICAgaW50ZWdlci5pcyA9IGlzO1xufSkoaW50ZWdlciB8fCAoaW50ZWdlciA9IHt9KSk7XG52YXIgdWludGVnZXI7XG4oZnVuY3Rpb24gKHVpbnRlZ2VyKSB7XG4gICAgdWludGVnZXIuTUlOX1ZBTFVFID0gMDtcbiAgICB1aW50ZWdlci5NQVhfVkFMVUUgPSAyMTQ3NDgzNjQ3O1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHVpbnRlZ2VyLk1JTl9WQUxVRSA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSB1aW50ZWdlci5NQVhfVkFMVUU7XG4gICAgfVxuICAgIHVpbnRlZ2VyLmlzID0gaXM7XG59KSh1aW50ZWdlciB8fCAodWludGVnZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgUG9zaXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgUG9zaXRpb259IGxpdGVyYWxzLlxuICovXG52YXIgUG9zaXRpb247XG4oZnVuY3Rpb24gKFBvc2l0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBQb3NpdGlvbiBsaXRlcmFsIGZyb20gdGhlIGdpdmVuIGxpbmUgYW5kIGNoYXJhY3Rlci5cbiAgICAgKiBAcGFyYW0gbGluZSBUaGUgcG9zaXRpb24ncyBsaW5lLlxuICAgICAqIEBwYXJhbSBjaGFyYWN0ZXIgVGhlIHBvc2l0aW9uJ3MgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsaW5lLCBjaGFyYWN0ZXIpIHtcbiAgICAgICAgaWYgKGxpbmUgPT09IE51bWJlci5NQVhfVkFMVUUpIHtcbiAgICAgICAgICAgIGxpbmUgPSB1aW50ZWdlci5NQVhfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXJhY3RlciA9PT0gTnVtYmVyLk1BWF9WQUxVRSkge1xuICAgICAgICAgICAgY2hhcmFjdGVyID0gdWludGVnZXIuTUFYX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxpbmU6IGxpbmUsIGNoYXJhY3RlcjogY2hhcmFjdGVyIH07XG4gICAgfVxuICAgIFBvc2l0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIFBvc2l0aW9ufSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5saW5lKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUuY2hhcmFjdGVyKTtcbiAgICB9XG4gICAgUG9zaXRpb24uaXMgPSBpcztcbn0pKFBvc2l0aW9uIHx8IChQb3NpdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBSYW5nZSBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBSYW5nZX0gbGl0ZXJhbHMuXG4gKi9cbnZhciBSYW5nZTtcbihmdW5jdGlvbiAoUmFuZ2UpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUob25lLCB0d28sIHRocmVlLCBmb3VyKSB7XG4gICAgICAgIGlmIChJcy51aW50ZWdlcihvbmUpICYmIElzLnVpbnRlZ2VyKHR3bykgJiYgSXMudWludGVnZXIodGhyZWUpICYmIElzLnVpbnRlZ2VyKGZvdXIpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGFydDogUG9zaXRpb24uY3JlYXRlKG9uZSwgdHdvKSwgZW5kOiBQb3NpdGlvbi5jcmVhdGUodGhyZWUsIGZvdXIpIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoUG9zaXRpb24uaXMob25lKSAmJiBQb3NpdGlvbi5pcyh0d28pKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGFydDogb25lLCBlbmQ6IHR3byB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmFuZ2UjY3JlYXRlIGNhbGxlZCB3aXRoIGludmFsaWQgYXJndW1lbnRzW1wiLmNvbmNhdChvbmUsIFwiLCBcIikuY29uY2F0KHR3bywgXCIsIFwiKS5jb25jYXQodGhyZWUsIFwiLCBcIikuY29uY2F0KGZvdXIsIFwiXVwiKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUmFuZ2UuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgUmFuZ2V9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUG9zaXRpb24uaXMoY2FuZGlkYXRlLnN0YXJ0KSAmJiBQb3NpdGlvbi5pcyhjYW5kaWRhdGUuZW5kKTtcbiAgICB9XG4gICAgUmFuZ2UuaXMgPSBpcztcbn0pKFJhbmdlIHx8IChSYW5nZSA9IHt9KSk7XG4vKipcbiAqIFRoZSBMb2NhdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBMb2NhdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBMb2NhdGlvbjtcbihmdW5jdGlvbiAoTG9jYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTG9jYXRpb24gbGl0ZXJhbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBsb2NhdGlvbidzIHVyaS5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIGxvY2F0aW9uJ3MgcmFuZ2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpOiB1cmksIHJhbmdlOiByYW5nZSB9O1xuICAgIH1cbiAgICBMb2NhdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBMb2NhdGlvbn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS51cmkpKTtcbiAgICB9XG4gICAgTG9jYXRpb24uaXMgPSBpcztcbn0pKExvY2F0aW9uIHx8IChMb2NhdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBMb2NhdGlvbkxpbmsgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgTG9jYXRpb25MaW5rfSBsaXRlcmFscy5cbiAqL1xudmFyIExvY2F0aW9uTGluaztcbihmdW5jdGlvbiAoTG9jYXRpb25MaW5rKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIExvY2F0aW9uTGluayBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB0YXJnZXRVcmkgVGhlIGRlZmluaXRpb24ncyB1cmkuXG4gICAgICogQHBhcmFtIHRhcmdldFJhbmdlIFRoZSBmdWxsIHJhbmdlIG9mIHRoZSBkZWZpbml0aW9uLlxuICAgICAqIEBwYXJhbSB0YXJnZXRTZWxlY3Rpb25SYW5nZSBUaGUgc3BhbiBvZiB0aGUgc3ltYm9sIGRlZmluaXRpb24gYXQgdGhlIHRhcmdldC5cbiAgICAgKiBAcGFyYW0gb3JpZ2luU2VsZWN0aW9uUmFuZ2UgVGhlIHNwYW4gb2YgdGhlIHN5bWJvbCBiZWluZyBkZWZpbmVkIGluIHRoZSBvcmlnaW5hdGluZyBzb3VyY2UgZmlsZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodGFyZ2V0VXJpLCB0YXJnZXRSYW5nZSwgdGFyZ2V0U2VsZWN0aW9uUmFuZ2UsIG9yaWdpblNlbGVjdGlvblJhbmdlKSB7XG4gICAgICAgIHJldHVybiB7IHRhcmdldFVyaTogdGFyZ2V0VXJpLCB0YXJnZXRSYW5nZTogdGFyZ2V0UmFuZ2UsIHRhcmdldFNlbGVjdGlvblJhbmdlOiB0YXJnZXRTZWxlY3Rpb25SYW5nZSwgb3JpZ2luU2VsZWN0aW9uUmFuZ2U6IG9yaWdpblNlbGVjdGlvblJhbmdlIH07XG4gICAgfVxuICAgIExvY2F0aW9uTGluay5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBMb2NhdGlvbkxpbmt9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnRhcmdldFJhbmdlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnRhcmdldFVyaSlcbiAgICAgICAgICAgICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS50YXJnZXRTZWxlY3Rpb25SYW5nZSlcbiAgICAgICAgICAgICYmIChSYW5nZS5pcyhjYW5kaWRhdGUub3JpZ2luU2VsZWN0aW9uUmFuZ2UpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUub3JpZ2luU2VsZWN0aW9uUmFuZ2UpKTtcbiAgICB9XG4gICAgTG9jYXRpb25MaW5rLmlzID0gaXM7XG59KShMb2NhdGlvbkxpbmsgfHwgKExvY2F0aW9uTGluayA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb2xvciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb2xvcn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBDb2xvcjtcbihmdW5jdGlvbiAoQ29sb3IpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbG9yIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWQ6IHJlZCxcbiAgICAgICAgICAgIGdyZWVuOiBncmVlbixcbiAgICAgICAgICAgIGJsdWU6IGJsdWUsXG4gICAgICAgICAgICBhbHBoYTogYWxwaGEsXG4gICAgICAgIH07XG4gICAgfVxuICAgIENvbG9yLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIENvbG9yfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLm51bWJlclJhbmdlKGNhbmRpZGF0ZS5yZWQsIDAsIDEpXG4gICAgICAgICAgICAmJiBJcy5udW1iZXJSYW5nZShjYW5kaWRhdGUuZ3JlZW4sIDAsIDEpXG4gICAgICAgICAgICAmJiBJcy5udW1iZXJSYW5nZShjYW5kaWRhdGUuYmx1ZSwgMCwgMSlcbiAgICAgICAgICAgICYmIElzLm51bWJlclJhbmdlKGNhbmRpZGF0ZS5hbHBoYSwgMCwgMSk7XG4gICAgfVxuICAgIENvbG9yLmlzID0gaXM7XG59KShDb2xvciB8fCAoQ29sb3IgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29sb3JJbmZvcm1hdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb2xvckluZm9ybWF0aW9ufSBsaXRlcmFscy5cbiAqL1xudmFyIENvbG9ySW5mb3JtYXRpb247XG4oZnVuY3Rpb24gKENvbG9ySW5mb3JtYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbG9ySW5mb3JtYXRpb24gbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIGNvbG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYW5nZTogcmFuZ2UsXG4gICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgIH07XG4gICAgfVxuICAgIENvbG9ySW5mb3JtYXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgQ29sb3JJbmZvcm1hdGlvbn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIENvbG9yLmlzKGNhbmRpZGF0ZS5jb2xvcik7XG4gICAgfVxuICAgIENvbG9ySW5mb3JtYXRpb24uaXMgPSBpcztcbn0pKENvbG9ySW5mb3JtYXRpb24gfHwgKENvbG9ySW5mb3JtYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29sb3IgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgQ29sb3JQcmVzZW50YXRpb259IGxpdGVyYWxzLlxuICovXG52YXIgQ29sb3JQcmVzZW50YXRpb247XG4oZnVuY3Rpb24gKENvbG9yUHJlc2VudGF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb2xvckluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsLCB0ZXh0RWRpdCwgYWRkaXRpb25hbFRleHRFZGl0cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICAgICAgdGV4dEVkaXQ6IHRleHRFZGl0LFxuICAgICAgICAgICAgYWRkaXRpb25hbFRleHRFZGl0czogYWRkaXRpb25hbFRleHRFZGl0cyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgQ29sb3JQcmVzZW50YXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgQ29sb3JJbmZvcm1hdGlvbn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhYmVsKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUudGV4dEVkaXQpIHx8IFRleHRFZGl0LmlzKGNhbmRpZGF0ZSkpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5hZGRpdGlvbmFsVGV4dEVkaXRzKSB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5hZGRpdGlvbmFsVGV4dEVkaXRzLCBUZXh0RWRpdC5pcykpO1xuICAgIH1cbiAgICBDb2xvclByZXNlbnRhdGlvbi5pcyA9IGlzO1xufSkoQ29sb3JQcmVzZW50YXRpb24gfHwgKENvbG9yUHJlc2VudGF0aW9uID0ge30pKTtcbi8qKlxuICogQSBzZXQgb2YgcHJlZGVmaW5lZCByYW5nZSBraW5kcy5cbiAqL1xudmFyIEZvbGRpbmdSYW5nZUtpbmQ7XG4oZnVuY3Rpb24gKEZvbGRpbmdSYW5nZUtpbmQpIHtcbiAgICAvKipcbiAgICAgKiBGb2xkaW5nIHJhbmdlIGZvciBhIGNvbW1lbnRcbiAgICAgKi9cbiAgICBGb2xkaW5nUmFuZ2VLaW5kLkNvbW1lbnQgPSAnY29tbWVudCc7XG4gICAgLyoqXG4gICAgICogRm9sZGluZyByYW5nZSBmb3IgYW4gaW1wb3J0IG9yIGluY2x1ZGVcbiAgICAgKi9cbiAgICBGb2xkaW5nUmFuZ2VLaW5kLkltcG9ydHMgPSAnaW1wb3J0cyc7XG4gICAgLyoqXG4gICAgICogRm9sZGluZyByYW5nZSBmb3IgYSByZWdpb24gKGUuZy4gYCNyZWdpb25gKVxuICAgICAqL1xuICAgIEZvbGRpbmdSYW5nZUtpbmQuUmVnaW9uID0gJ3JlZ2lvbic7XG59KShGb2xkaW5nUmFuZ2VLaW5kIHx8IChGb2xkaW5nUmFuZ2VLaW5kID0ge30pKTtcbi8qKlxuICogVGhlIGZvbGRpbmcgcmFuZ2UgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgRm9sZGluZ1JhbmdlfSBsaXRlcmFscy5cbiAqL1xudmFyIEZvbGRpbmdSYW5nZTtcbihmdW5jdGlvbiAoRm9sZGluZ1JhbmdlKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBGb2xkaW5nUmFuZ2UgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUoc3RhcnRMaW5lLCBlbmRMaW5lLCBzdGFydENoYXJhY3RlciwgZW5kQ2hhcmFjdGVyLCBraW5kLCBjb2xsYXBzZWRUZXh0KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBzdGFydExpbmU6IHN0YXJ0TGluZSxcbiAgICAgICAgICAgIGVuZExpbmU6IGVuZExpbmVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKElzLmRlZmluZWQoc3RhcnRDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnRDaGFyYWN0ZXIgPSBzdGFydENoYXJhY3RlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChlbmRDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICByZXN1bHQuZW5kQ2hhcmFjdGVyID0gZW5kQ2hhcmFjdGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGtpbmQpKSB7XG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGtpbmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQoY29sbGFwc2VkVGV4dCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jb2xsYXBzZWRUZXh0ID0gY29sbGFwc2VkVGV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBGb2xkaW5nUmFuZ2UuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRm9sZGluZ1JhbmdlfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5zdGFydExpbmUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5zdGFydExpbmUpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5zdGFydENoYXJhY3RlcikgfHwgSXMudWludGVnZXIoY2FuZGlkYXRlLnN0YXJ0Q2hhcmFjdGVyKSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmVuZENoYXJhY3RlcikgfHwgSXMudWludGVnZXIoY2FuZGlkYXRlLmVuZENoYXJhY3RlcikpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5raW5kKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmtpbmQpKTtcbiAgICB9XG4gICAgRm9sZGluZ1JhbmdlLmlzID0gaXM7XG59KShGb2xkaW5nUmFuZ2UgfHwgKEZvbGRpbmdSYW5nZSA9IHt9KSk7XG4vKipcbiAqIFRoZSBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb259IGxpdGVyYWxzLlxuICovXG52YXIgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbjtcbihmdW5jdGlvbiAoRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsb2NhdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb259IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgTG9jYXRpb24uaXMoY2FuZGlkYXRlLmxvY2F0aW9uKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uLmlzID0gaXM7XG59KShEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uIHx8IChEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIGRpYWdub3N0aWMncyBzZXZlcml0eS5cbiAqL1xudmFyIERpYWdub3N0aWNTZXZlcml0eTtcbihmdW5jdGlvbiAoRGlhZ25vc3RpY1NldmVyaXR5KSB7XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyBhbiBlcnJvci5cbiAgICAgKi9cbiAgICBEaWFnbm9zdGljU2V2ZXJpdHkuRXJyb3IgPSAxO1xuICAgIC8qKlxuICAgICAqIFJlcG9ydHMgYSB3YXJuaW5nLlxuICAgICAqL1xuICAgIERpYWdub3N0aWNTZXZlcml0eS5XYXJuaW5nID0gMjtcbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIGFuIGluZm9ybWF0aW9uLlxuICAgICAqL1xuICAgIERpYWdub3N0aWNTZXZlcml0eS5JbmZvcm1hdGlvbiA9IDM7XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyBhIGhpbnQuXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1NldmVyaXR5LkhpbnQgPSA0O1xufSkoRGlhZ25vc3RpY1NldmVyaXR5IHx8IChEaWFnbm9zdGljU2V2ZXJpdHkgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZGlhZ25vc3RpYyB0YWdzLlxuICpcbiAqIEBzaW5jZSAzLjE1LjBcbiAqL1xudmFyIERpYWdub3N0aWNUYWc7XG4oZnVuY3Rpb24gKERpYWdub3N0aWNUYWcpIHtcbiAgICAvKipcbiAgICAgKiBVbnVzZWQgb3IgdW5uZWNlc3NhcnkgY29kZS5cbiAgICAgKlxuICAgICAqIENsaWVudHMgYXJlIGFsbG93ZWQgdG8gcmVuZGVyIGRpYWdub3N0aWNzIHdpdGggdGhpcyB0YWcgZmFkZWQgb3V0IGluc3RlYWQgb2YgaGF2aW5nXG4gICAgICogYW4gZXJyb3Igc3F1aWdnbGUuXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1RhZy5Vbm5lY2Vzc2FyeSA9IDE7XG4gICAgLyoqXG4gICAgICogRGVwcmVjYXRlZCBvciBvYnNvbGV0ZSBjb2RlLlxuICAgICAqXG4gICAgICogQ2xpZW50cyBhcmUgYWxsb3dlZCB0byByZW5kZXJlZCBkaWFnbm9zdGljcyB3aXRoIHRoaXMgdGFnIHN0cmlrZSB0aHJvdWdoLlxuICAgICAqL1xuICAgIERpYWdub3N0aWNUYWcuRGVwcmVjYXRlZCA9IDI7XG59KShEaWFnbm9zdGljVGFnIHx8IChEaWFnbm9zdGljVGFnID0ge30pKTtcbi8qKlxuICogVGhlIENvZGVEZXNjcmlwdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBkZXNjcmlwdGlvbnMgZm9yIGRpYWdub3N0aWMgY29kZXMuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgQ29kZURlc2NyaXB0aW9uO1xuKGZ1bmN0aW9uIChDb2RlRGVzY3JpcHRpb24pIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5ocmVmKTtcbiAgICB9XG4gICAgQ29kZURlc2NyaXB0aW9uLmlzID0gaXM7XG59KShDb2RlRGVzY3JpcHRpb24gfHwgKENvZGVEZXNjcmlwdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBEaWFnbm9zdGljIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIERpYWdub3N0aWN9IGxpdGVyYWxzLlxuICovXG52YXIgRGlhZ25vc3RpYztcbihmdW5jdGlvbiAoRGlhZ25vc3RpYykge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRGlhZ25vc3RpYyBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgbWVzc2FnZSwgc2V2ZXJpdHksIGNvZGUsIHNvdXJjZSwgcmVsYXRlZEluZm9ybWF0aW9uKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7IHJhbmdlOiByYW5nZSwgbWVzc2FnZTogbWVzc2FnZSB9O1xuICAgICAgICBpZiAoSXMuZGVmaW5lZChzZXZlcml0eSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXZlcml0eSA9IHNldmVyaXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGNvZGUpKSB7XG4gICAgICAgICAgICByZXN1bHQuY29kZSA9IGNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQoc291cmNlKSkge1xuICAgICAgICAgICAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChyZWxhdGVkSW5mb3JtYXRpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQucmVsYXRlZEluZm9ybWF0aW9uID0gcmVsYXRlZEluZm9ybWF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIERpYWdub3N0aWMuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRGlhZ25vc3RpY30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpXG4gICAgICAgICAgICAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm1lc3NhZ2UpXG4gICAgICAgICAgICAmJiAoSXMubnVtYmVyKGNhbmRpZGF0ZS5zZXZlcml0eSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5zZXZlcml0eSkpXG4gICAgICAgICAgICAmJiAoSXMuaW50ZWdlcihjYW5kaWRhdGUuY29kZSkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5jb2RlKSB8fCBJcy51bmRlZmluZWQoY2FuZGlkYXRlLmNvZGUpKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuY29kZURlc2NyaXB0aW9uKSB8fCAoSXMuc3RyaW5nKChfYSA9IGNhbmRpZGF0ZS5jb2RlRGVzY3JpcHRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ocmVmKSkpXG4gICAgICAgICAgICAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5zb3VyY2UpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUuc291cmNlKSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLnJlbGF0ZWRJbmZvcm1hdGlvbikgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUucmVsYXRlZEluZm9ybWF0aW9uLCBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uLmlzKSk7XG4gICAgfVxuICAgIERpYWdub3N0aWMuaXMgPSBpcztcbn0pKERpYWdub3N0aWMgfHwgKERpYWdub3N0aWMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29tbWFuZCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb21tYW5kfSBsaXRlcmFscy5cbiAqL1xudmFyIENvbW1hbmQ7XG4oZnVuY3Rpb24gKENvbW1hbmQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbW1hbmQgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodGl0bGUsIGNvbW1hbmQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgdGl0bGU6IHRpdGxlLCBjb21tYW5kOiBjb21tYW5kIH07XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGFyZ3MpICYmIGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0LmFyZ3VtZW50cyA9IGFyZ3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgQ29tbWFuZC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb21tYW5kfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGl0bGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUuY29tbWFuZCk7XG4gICAgfVxuICAgIENvbW1hbmQuaXMgPSBpcztcbn0pKENvbW1hbmQgfHwgKENvbW1hbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgVGV4dEVkaXQgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgcmVwbGFjZSxcbiAqIGluc2VydCBhbmQgZGVsZXRlIGVkaXRzIG1vcmUgZWFzaWx5LlxuICovXG52YXIgVGV4dEVkaXQ7XG4oZnVuY3Rpb24gKFRleHRFZGl0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJlcGxhY2UgdGV4dCBlZGl0LlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGV4dCB0byBiZSByZXBsYWNlZC5cbiAgICAgKiBAcGFyYW0gbmV3VGV4dCBUaGUgbmV3IHRleHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwbGFjZShyYW5nZSwgbmV3VGV4dCkge1xuICAgICAgICByZXR1cm4geyByYW5nZTogcmFuZ2UsIG5ld1RleHQ6IG5ld1RleHQgfTtcbiAgICB9XG4gICAgVGV4dEVkaXQucmVwbGFjZSA9IHJlcGxhY2U7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnNlcnQgdGV4dCBlZGl0LlxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiBUaGUgcG9zaXRpb24gdG8gaW5zZXJ0IHRoZSB0ZXh0IGF0LlxuICAgICAqIEBwYXJhbSBuZXdUZXh0IFRoZSB0ZXh0IHRvIGJlIGluc2VydGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc2VydChwb3NpdGlvbiwgbmV3VGV4dCkge1xuICAgICAgICByZXR1cm4geyByYW5nZTogeyBzdGFydDogcG9zaXRpb24sIGVuZDogcG9zaXRpb24gfSwgbmV3VGV4dDogbmV3VGV4dCB9O1xuICAgIH1cbiAgICBUZXh0RWRpdC5pbnNlcnQgPSBpbnNlcnQ7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlbGV0ZSB0ZXh0IGVkaXQuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0ZXh0IHRvIGJlIGRlbGV0ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVsKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiByYW5nZSwgbmV3VGV4dDogJycgfTtcbiAgICB9XG4gICAgVGV4dEVkaXQuZGVsID0gZGVsO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKVxuICAgICAgICAgICAgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uZXdUZXh0KVxuICAgICAgICAgICAgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKTtcbiAgICB9XG4gICAgVGV4dEVkaXQuaXMgPSBpcztcbn0pKFRleHRFZGl0IHx8IChUZXh0RWRpdCA9IHt9KSk7XG52YXIgQ2hhbmdlQW5ub3RhdGlvbjtcbihmdW5jdGlvbiAoQ2hhbmdlQW5ub3RhdGlvbikge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCwgbmVlZHNDb25maXJtYXRpb24sIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7IGxhYmVsOiBsYWJlbCB9O1xuICAgICAgICBpZiAobmVlZHNDb25maXJtYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0Lm5lZWRzQ29uZmlybWF0aW9uID0gbmVlZHNDb25maXJtYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIENoYW5nZUFubm90YXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhYmVsKSAmJlxuICAgICAgICAgICAgKElzLmJvb2xlYW4oY2FuZGlkYXRlLm5lZWRzQ29uZmlybWF0aW9uKSB8fCBjYW5kaWRhdGUubmVlZHNDb25maXJtYXRpb24gPT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgIChJcy5zdHJpbmcoY2FuZGlkYXRlLmRlc2NyaXB0aW9uKSB8fCBjYW5kaWRhdGUuZGVzY3JpcHRpb24gPT09IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIENoYW5nZUFubm90YXRpb24uaXMgPSBpcztcbn0pKENoYW5nZUFubm90YXRpb24gfHwgKENoYW5nZUFubm90YXRpb24gPSB7fSkpO1xudmFyIENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyO1xuKGZ1bmN0aW9uIChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLnN0cmluZyhjYW5kaWRhdGUpO1xuICAgIH1cbiAgICBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyA9IGlzO1xufSkoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIgfHwgKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyID0ge30pKTtcbnZhciBBbm5vdGF0ZWRUZXh0RWRpdDtcbihmdW5jdGlvbiAoQW5ub3RhdGVkVGV4dEVkaXQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFubm90YXRlZCByZXBsYWNlIHRleHQgZWRpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGV4dCB0byBiZSByZXBsYWNlZC5cbiAgICAgKiBAcGFyYW0gbmV3VGV4dCBUaGUgbmV3IHRleHQuXG4gICAgICogQHBhcmFtIGFubm90YXRpb24gVGhlIGFubm90YXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwbGFjZShyYW5nZSwgbmV3VGV4dCwgYW5ub3RhdGlvbikge1xuICAgICAgICByZXR1cm4geyByYW5nZTogcmFuZ2UsIG5ld1RleHQ6IG5ld1RleHQsIGFubm90YXRpb25JZDogYW5ub3RhdGlvbiB9O1xuICAgIH1cbiAgICBBbm5vdGF0ZWRUZXh0RWRpdC5yZXBsYWNlID0gcmVwbGFjZTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFubm90YXRlZCBpbnNlcnQgdGV4dCBlZGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIFRoZSBwb3NpdGlvbiB0byBpbnNlcnQgdGhlIHRleHQgYXQuXG4gICAgICogQHBhcmFtIG5ld1RleHQgVGhlIHRleHQgdG8gYmUgaW5zZXJ0ZWQuXG4gICAgICogQHBhcmFtIGFubm90YXRpb24gVGhlIGFubm90YXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0LCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiB7IHN0YXJ0OiBwb3NpdGlvbiwgZW5kOiBwb3NpdGlvbiB9LCBuZXdUZXh0OiBuZXdUZXh0LCBhbm5vdGF0aW9uSWQ6IGFubm90YXRpb24gfTtcbiAgICB9XG4gICAgQW5ub3RhdGVkVGV4dEVkaXQuaW5zZXJ0ID0gaW5zZXJ0O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYW5ub3RhdGVkIGRlbGV0ZSB0ZXh0IGVkaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIG9mIHRleHQgdG8gYmUgZGVsZXRlZC5cbiAgICAgKiBAcGFyYW0gYW5ub3RhdGlvbiBUaGUgYW5ub3RhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWwocmFuZ2UsIGFubm90YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLCBuZXdUZXh0OiAnJywgYW5ub3RhdGlvbklkOiBhbm5vdGF0aW9uIH07XG4gICAgfVxuICAgIEFubm90YXRlZFRleHRFZGl0LmRlbCA9IGRlbDtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBUZXh0RWRpdC5pcyhjYW5kaWRhdGUpICYmIChDaGFuZ2VBbm5vdGF0aW9uLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpKTtcbiAgICB9XG4gICAgQW5ub3RhdGVkVGV4dEVkaXQuaXMgPSBpcztcbn0pKEFubm90YXRlZFRleHRFZGl0IHx8IChBbm5vdGF0ZWRUZXh0RWRpdCA9IHt9KSk7XG4vKipcbiAqIFRoZSBUZXh0RG9jdW1lbnRFZGl0IG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlXG4gKiBhbiBlZGl0IHRoYXQgbWFuaXB1bGF0ZXMgYSB0ZXh0IGRvY3VtZW50LlxuICovXG52YXIgVGV4dERvY3VtZW50RWRpdDtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50RWRpdCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYFRleHREb2N1bWVudEVkaXRgXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHRleHREb2N1bWVudCwgZWRpdHMpIHtcbiAgICAgICAgcmV0dXJuIHsgdGV4dERvY3VtZW50OiB0ZXh0RG9jdW1lbnQsIGVkaXRzOiBlZGl0cyB9O1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRFZGl0LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSlcbiAgICAgICAgICAgICYmIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllci5pcyhjYW5kaWRhdGUudGV4dERvY3VtZW50KVxuICAgICAgICAgICAgJiYgQXJyYXkuaXNBcnJheShjYW5kaWRhdGUuZWRpdHMpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRFZGl0LmlzID0gaXM7XG59KShUZXh0RG9jdW1lbnRFZGl0IHx8IChUZXh0RG9jdW1lbnRFZGl0ID0ge30pKTtcbnZhciBDcmVhdGVGaWxlO1xuKGZ1bmN0aW9uIChDcmVhdGVGaWxlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgb3B0aW9ucywgYW5ub3RhdGlvbikge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAga2luZDogJ2NyZWF0ZScsXG4gICAgICAgICAgICB1cmk6IHVyaVxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIChvcHRpb25zLm92ZXJ3cml0ZSAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuaWdub3JlSWZFeGlzdHMgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5ub3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQuYW5ub3RhdGlvbklkID0gYW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDcmVhdGVGaWxlLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgY2FuZGlkYXRlLmtpbmQgPT09ICdjcmVhdGUnICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiAoY2FuZGlkYXRlLm9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgKChjYW5kaWRhdGUub3B0aW9ucy5vdmVyd3JpdGUgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5vcHRpb25zLm92ZXJ3cml0ZSkpICYmIChjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZkV4aXN0cyA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMuaWdub3JlSWZFeGlzdHMpKSkpICYmIChjYW5kaWRhdGUuYW5ub3RhdGlvbklkID09PSB1bmRlZmluZWQgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoY2FuZGlkYXRlLmFubm90YXRpb25JZCkpO1xuICAgIH1cbiAgICBDcmVhdGVGaWxlLmlzID0gaXM7XG59KShDcmVhdGVGaWxlIHx8IChDcmVhdGVGaWxlID0ge30pKTtcbnZhciBSZW5hbWVGaWxlO1xuKGZ1bmN0aW9uIChSZW5hbWVGaWxlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKG9sZFVyaSwgbmV3VXJpLCBvcHRpb25zLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBraW5kOiAncmVuYW1lJyxcbiAgICAgICAgICAgIG9sZFVyaTogb2xkVXJpLFxuICAgICAgICAgICAgbmV3VXJpOiBuZXdVcmlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiAob3B0aW9ucy5vdmVyd3JpdGUgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmlnbm9yZUlmRXhpc3RzICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICByZXN1bHQub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFubm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmFubm90YXRpb25JZCA9IGFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgUmVuYW1lRmlsZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGNhbmRpZGF0ZS5raW5kID09PSAncmVuYW1lJyAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm9sZFVyaSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uZXdVcmkpICYmIChjYW5kaWRhdGUub3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAoKGNhbmRpZGF0ZS5vcHRpb25zLm92ZXJ3cml0ZSA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMub3ZlcndyaXRlKSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmRXhpc3RzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZkV4aXN0cykpKSkgJiYgKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQgPT09IHVuZGVmaW5lZCB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSk7XG4gICAgfVxuICAgIFJlbmFtZUZpbGUuaXMgPSBpcztcbn0pKFJlbmFtZUZpbGUgfHwgKFJlbmFtZUZpbGUgPSB7fSkpO1xudmFyIERlbGV0ZUZpbGU7XG4oZnVuY3Rpb24gKERlbGV0ZUZpbGUpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCBvcHRpb25zLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBraW5kOiAnZGVsZXRlJyxcbiAgICAgICAgICAgIHVyaTogdXJpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgKG9wdGlvbnMucmVjdXJzaXZlICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5pZ25vcmVJZk5vdEV4aXN0cyAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgcmVzdWx0Lm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbm5vdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hbm5vdGF0aW9uSWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIERlbGV0ZUZpbGUuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBjYW5kaWRhdGUua2luZCA9PT0gJ2RlbGV0ZScgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIChjYW5kaWRhdGUub3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAoKGNhbmRpZGF0ZS5vcHRpb25zLnJlY3Vyc2l2ZSA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMucmVjdXJzaXZlKSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmTm90RXhpc3RzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZk5vdEV4aXN0cykpKSkgJiYgKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQgPT09IHVuZGVmaW5lZCB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSk7XG4gICAgfVxuICAgIERlbGV0ZUZpbGUuaXMgPSBpcztcbn0pKERlbGV0ZUZpbGUgfHwgKERlbGV0ZUZpbGUgPSB7fSkpO1xudmFyIFdvcmtzcGFjZUVkaXQ7XG4oZnVuY3Rpb24gKFdvcmtzcGFjZUVkaXQpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuY2hhbmdlcyAhPT0gdW5kZWZpbmVkIHx8IGNhbmRpZGF0ZS5kb2N1bWVudENoYW5nZXMgIT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLmRvY3VtZW50Q2hhbmdlcy5ldmVyeShmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKElzLnN0cmluZyhjaGFuZ2Uua2luZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUZpbGUuaXMoY2hhbmdlKSB8fCBSZW5hbWVGaWxlLmlzKGNoYW5nZSkgfHwgRGVsZXRlRmlsZS5pcyhjaGFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRleHREb2N1bWVudEVkaXQuaXMoY2hhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgfVxuICAgIFdvcmtzcGFjZUVkaXQuaXMgPSBpcztcbn0pKFdvcmtzcGFjZUVkaXQgfHwgKFdvcmtzcGFjZUVkaXQgPSB7fSkpO1xudmFyIFRleHRFZGl0Q2hhbmdlSW1wbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZXh0RWRpdENoYW5nZUltcGwoZWRpdHMsIGNoYW5nZUFubm90YXRpb25zKSB7XG4gICAgICAgIHRoaXMuZWRpdHMgPSBlZGl0cztcbiAgICAgICAgdGhpcy5jaGFuZ2VBbm5vdGF0aW9ucyA9IGNoYW5nZUFubm90YXRpb25zO1xuICAgIH1cbiAgICBUZXh0RWRpdENoYW5nZUltcGwucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgbmV3VGV4dCwgYW5ub3RhdGlvbikge1xuICAgICAgICB2YXIgZWRpdDtcbiAgICAgICAgdmFyIGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlZGl0ID0gVGV4dEVkaXQuaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhhbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgaWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0Lmluc2VydChwb3NpdGlvbiwgbmV3VGV4dCwgYW5ub3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydENoYW5nZUFubm90YXRpb25zKHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgaWQgPSB0aGlzLmNoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIGVkaXQgPSBBbm5vdGF0ZWRUZXh0RWRpdC5pbnNlcnQocG9zaXRpb24sIG5ld1RleHQsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRzLnB1c2goZWRpdCk7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIChyYW5nZSwgbmV3VGV4dCwgYW5ub3RhdGlvbikge1xuICAgICAgICB2YXIgZWRpdDtcbiAgICAgICAgdmFyIGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlZGl0ID0gVGV4dEVkaXQucmVwbGFjZShyYW5nZSwgbmV3VGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoYW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGlkID0gYW5ub3RhdGlvbjtcbiAgICAgICAgICAgIGVkaXQgPSBBbm5vdGF0ZWRUZXh0RWRpdC5yZXBsYWNlKHJhbmdlLCBuZXdUZXh0LCBhbm5vdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0Q2hhbmdlQW5ub3RhdGlvbnModGhpcy5jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICBpZCA9IHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0LnJlcGxhY2UocmFuZ2UsIG5ld1RleHQsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRzLnB1c2goZWRpdCk7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKHJhbmdlLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciBlZGl0O1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVkaXQgPSBUZXh0RWRpdC5kZWwocmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pKSB7XG4gICAgICAgICAgICBpZCA9IGFubm90YXRpb247XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQuZGVsKHJhbmdlLCBhbm5vdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0Q2hhbmdlQW5ub3RhdGlvbnModGhpcy5jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICBpZCA9IHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0LmRlbChyYW5nZSwgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdHMucHVzaChlZGl0KTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGV4dEVkaXRDaGFuZ2VJbXBsLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZWRpdCkge1xuICAgICAgICB0aGlzLmVkaXRzLnB1c2goZWRpdCk7XG4gICAgfTtcbiAgICBUZXh0RWRpdENoYW5nZUltcGwucHJvdG90eXBlLmFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdHM7XG4gICAgfTtcbiAgICBUZXh0RWRpdENoYW5nZUltcGwucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVkaXRzLnNwbGljZSgwLCB0aGlzLmVkaXRzLmxlbmd0aCk7XG4gICAgfTtcbiAgICBUZXh0RWRpdENoYW5nZUltcGwucHJvdG90eXBlLmFzc2VydENoYW5nZUFubm90YXRpb25zID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUZXh0IGVkaXQgY2hhbmdlIGlzIG5vdCBjb25maWd1cmVkIHRvIG1hbmFnZSBjaGFuZ2UgYW5ub3RhdGlvbnMuXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVGV4dEVkaXRDaGFuZ2VJbXBsO1xufSgpKTtcbi8qKlxuICogQSBoZWxwZXIgY2xhc3NcbiAqL1xudmFyIENoYW5nZUFubm90YXRpb25zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENoYW5nZUFubm90YXRpb25zKGFubm90YXRpb25zKSB7XG4gICAgICAgIHRoaXMuX2Fubm90YXRpb25zID0gYW5ub3RhdGlvbnMgPT09IHVuZGVmaW5lZCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiBhbm5vdGF0aW9ucztcbiAgICAgICAgdGhpcy5fY291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xuICAgIH1cbiAgICBDaGFuZ2VBbm5vdGF0aW9ucy5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW5ub3RhdGlvbnM7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhbmdlQW5ub3RhdGlvbnMucHJvdG90eXBlLCBcInNpemVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ2hhbmdlQW5ub3RhdGlvbnMucHJvdG90eXBlLm1hbmFnZSA9IGZ1bmN0aW9uIChpZE9yQW5ub3RhdGlvbiwgYW5ub3RhdGlvbikge1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIGlmIChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhpZE9yQW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGlkID0gaWRPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZCA9IHRoaXMubmV4dElkKCk7XG4gICAgICAgICAgICBhbm5vdGF0aW9uID0gaWRPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2Fubm90YXRpb25zW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJZCBcIi5jb25jYXQoaWQsIFwiIGlzIGFscmVhZHkgaW4gdXNlLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYW5ub3RhdGlvbiBwcm92aWRlZCBmb3IgaWQgXCIuY29uY2F0KGlkKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYW5ub3RhdGlvbnNbaWRdID0gYW5ub3RhdGlvbjtcbiAgICAgICAgdGhpcy5fc2l6ZSsrO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfTtcbiAgICBDaGFuZ2VBbm5vdGF0aW9ucy5wcm90b3R5cGUubmV4dElkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jb3VudGVyKys7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb3VudGVyLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2hhbmdlQW5ub3RhdGlvbnM7XG59KCkpO1xuLyoqXG4gKiBBIHdvcmtzcGFjZSBjaGFuZ2UgaGVscHMgY29uc3RydWN0aW5nIGNoYW5nZXMgdG8gYSB3b3Jrc3BhY2UuXG4gKi9cbnZhciBXb3Jrc3BhY2VDaGFuZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV29ya3NwYWNlQ2hhbmdlKHdvcmtzcGFjZUVkaXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fdGV4dEVkaXRDaGFuZ2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgaWYgKHdvcmtzcGFjZUVkaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdCA9IHdvcmtzcGFjZUVkaXQ7XG4gICAgICAgICAgICBpZiAod29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyA9IG5ldyBDaGFuZ2VBbm5vdGF0aW9ucyh3b3Jrc3BhY2VFZGl0LmNoYW5nZUFubm90YXRpb25zKTtcbiAgICAgICAgICAgICAgICB3b3Jrc3BhY2VFZGl0LmNoYW5nZUFubm90YXRpb25zID0gdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMuYWxsKCk7XG4gICAgICAgICAgICAgICAgd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChUZXh0RG9jdW1lbnRFZGl0LmlzKGNoYW5nZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0RWRpdENoYW5nZSA9IG5ldyBUZXh0RWRpdENoYW5nZUltcGwoY2hhbmdlLmVkaXRzLCBfdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RleHRFZGl0Q2hhbmdlc1tjaGFuZ2UudGV4dERvY3VtZW50LnVyaV0gPSB0ZXh0RWRpdENoYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAod29ya3NwYWNlRWRpdC5jaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMod29ya3NwYWNlRWRpdC5jaGFuZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRFZGl0Q2hhbmdlID0gbmV3IFRleHRFZGl0Q2hhbmdlSW1wbCh3b3Jrc3BhY2VFZGl0LmNoYW5nZXNba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl90ZXh0RWRpdENoYW5nZXNba2V5XSA9IHRleHRFZGl0Q2hhbmdlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdCA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXb3Jrc3BhY2VDaGFuZ2UucHJvdG90eXBlLCBcImVkaXRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgdW5kZXJseWluZyB7QGxpbmsgV29ya3NwYWNlRWRpdH0gbGl0ZXJhbFxuICAgICAgICAgKiB1c2UgdG8gYmUgcmV0dXJuZWQgZnJvbSBhIHdvcmtzcGFjZSBlZGl0IG9wZXJhdGlvbiBsaWtlIHJlbmFtZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZUFubm90YXRpb25zID0gdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMuYWxsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmtzcGFjZUVkaXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBXb3Jrc3BhY2VDaGFuZ2UucHJvdG90eXBlLmdldFRleHRFZGl0Q2hhbmdlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmlzKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBkb2N1bWVudCBjaGFuZ2VzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRleHREb2N1bWVudCA9IHsgdXJpOiBrZXkudXJpLCB2ZXJzaW9uOiBrZXkudmVyc2lvbiB9O1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3RleHRFZGl0Q2hhbmdlc1t0ZXh0RG9jdW1lbnQudXJpXTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVkaXRzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIHRleHREb2N1bWVudEVkaXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHREb2N1bWVudDogdGV4dERvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICBlZGl0czogZWRpdHNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzLnB1c2godGV4dERvY3VtZW50RWRpdCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFRleHRFZGl0Q2hhbmdlSW1wbChlZGl0cywgdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRFZGl0Q2hhbmdlc1t0ZXh0RG9jdW1lbnQudXJpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmluaXRDaGFuZ2VzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBub3JtYWwgdGV4dCBlZGl0IGNoYW5nZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW2tleV07XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHZhciBlZGl0cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlc1trZXldID0gZWRpdHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFRleHRFZGl0Q2hhbmdlSW1wbChlZGl0cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW2tleV0gPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXb3Jrc3BhY2VDaGFuZ2UucHJvdG90eXBlLmluaXREb2N1bWVudENoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyA9IG5ldyBDaGFuZ2VBbm5vdGF0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMgPSB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5hbGwoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgV29ya3NwYWNlQ2hhbmdlLnByb3RvdHlwZS5pbml0Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQgJiYgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdvcmtzcGFjZUNoYW5nZS5wcm90b3R5cGUuY3JlYXRlRmlsZSA9IGZ1bmN0aW9uICh1cmksIG9wdGlvbnNPckFubm90YXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBkb2N1bWVudCBjaGFuZ2VzLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbm5vdGF0aW9uO1xuICAgICAgICBpZiAoQ2hhbmdlQW5ub3RhdGlvbi5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgYW5ub3RhdGlvbiA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9uc09yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3BlcmF0aW9uO1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IENyZWF0ZUZpbGUuY3JlYXRlKHVyaSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZCA9IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pID8gYW5ub3RhdGlvbiA6IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IENyZWF0ZUZpbGUuY3JlYXRlKHVyaSwgb3B0aW9ucywgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzLnB1c2gob3BlcmF0aW9uKTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgV29ya3NwYWNlQ2hhbmdlLnByb3RvdHlwZS5yZW5hbWVGaWxlID0gZnVuY3Rpb24gKG9sZFVyaSwgbmV3VXJpLCBvcHRpb25zT3JBbm5vdGF0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3Jrc3BhY2UgZWRpdCBpcyBub3QgY29uZmlndXJlZCBmb3IgZG9jdW1lbnQgY2hhbmdlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW5ub3RhdGlvbjtcbiAgICAgICAgaWYgKENoYW5nZUFubm90YXRpb24uaXMob3B0aW9uc09yQW5ub3RhdGlvbikgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMob3B0aW9uc09yQW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGFubm90YXRpb24gPSBvcHRpb25zT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wZXJhdGlvbjtcbiAgICAgICAgdmFyIGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBSZW5hbWVGaWxlLmNyZWF0ZShvbGRVcmksIG5ld1VyaSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZCA9IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pID8gYW5ub3RhdGlvbiA6IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IFJlbmFtZUZpbGUuY3JlYXRlKG9sZFVyaSwgbmV3VXJpLCBvcHRpb25zLCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMucHVzaChvcGVyYXRpb24pO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXb3Jrc3BhY2VDaGFuZ2UucHJvdG90eXBlLmRlbGV0ZUZpbGUgPSBmdW5jdGlvbiAodXJpLCBvcHRpb25zT3JBbm5vdGF0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3Jrc3BhY2UgZWRpdCBpcyBub3QgY29uZmlndXJlZCBmb3IgZG9jdW1lbnQgY2hhbmdlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW5ub3RhdGlvbjtcbiAgICAgICAgaWYgKENoYW5nZUFubm90YXRpb24uaXMob3B0aW9uc09yQW5ub3RhdGlvbikgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMob3B0aW9uc09yQW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGFubm90YXRpb24gPSBvcHRpb25zT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wZXJhdGlvbjtcbiAgICAgICAgdmFyIGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBEZWxldGVGaWxlLmNyZWF0ZSh1cmksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWQgPSBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhhbm5vdGF0aW9uKSA/IGFubm90YXRpb24gOiB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5tYW5hZ2UoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBEZWxldGVGaWxlLmNyZWF0ZSh1cmksIG9wdGlvbnMsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcy5wdXNoKG9wZXJhdGlvbik7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBXb3Jrc3BhY2VDaGFuZ2U7XG59KCkpO1xuXG4vKipcbiAqIFRoZSBUZXh0RG9jdW1lbnRJZGVudGlmaWVyIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFRleHREb2N1bWVudElkZW50aWZpZXJ9IGxpdGVyYWxzLlxuICovXG52YXIgVGV4dERvY3VtZW50SWRlbnRpZmllcjtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50SWRlbnRpZmllcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVGV4dERvY3VtZW50SWRlbnRpZmllciBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmkpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpOiB1cmkgfTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50SWRlbnRpZmllci5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBUZXh0RG9jdW1lbnRJZGVudGlmaWVyfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50SWRlbnRpZmllci5pcyA9IGlzO1xufSkoVGV4dERvY3VtZW50SWRlbnRpZmllciB8fCAoVGV4dERvY3VtZW50SWRlbnRpZmllciA9IHt9KSk7XG4vKipcbiAqIFRoZSBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXJ9IGxpdGVyYWxzLlxuICovXG52YXIgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcjtcbihmdW5jdGlvbiAoVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIFRoZSBkb2N1bWVudCdzIHZlcnNpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgdmVyc2lvbikge1xuICAgICAgICByZXR1cm4geyB1cmk6IHVyaSwgdmVyc2lvbjogdmVyc2lvbiB9O1xuICAgIH1cbiAgICBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXJ9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIElzLmludGVnZXIoY2FuZGlkYXRlLnZlcnNpb24pO1xuICAgIH1cbiAgICBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmlzID0gaXM7XG59KShWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIHx8IChWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyID0ge30pKTtcbi8qKlxuICogVGhlIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXJ9IGxpdGVyYWxzLlxuICovXG52YXIgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyO1xuKGZ1bmN0aW9uIChPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIFRoZSBkb2N1bWVudCdzIHZlcnNpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgdmVyc2lvbikge1xuICAgICAgICByZXR1cm4geyB1cmk6IHVyaSwgdmVyc2lvbjogdmVyc2lvbiB9O1xuICAgIH1cbiAgICBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiAoY2FuZGlkYXRlLnZlcnNpb24gPT09IG51bGwgfHwgSXMuaW50ZWdlcihjYW5kaWRhdGUudmVyc2lvbikpO1xuICAgIH1cbiAgICBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMgPSBpcztcbn0pKE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciB8fCAoT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyID0ge30pKTtcbi8qKlxuICogVGhlIFRleHREb2N1bWVudEl0ZW0gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgVGV4dERvY3VtZW50SXRlbX0gbGl0ZXJhbHMuXG4gKi9cbnZhciBUZXh0RG9jdW1lbnRJdGVtO1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRJdGVtKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBUZXh0RG9jdW1lbnRJdGVtIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIGxhbmd1YWdlSWQgVGhlIGRvY3VtZW50J3MgbGFuZ3VhZ2UgaWRlbnRpZmllci5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiBUaGUgZG9jdW1lbnQncyB2ZXJzaW9uIG51bWJlci5cbiAgICAgKiBAcGFyYW0gdGV4dCBUaGUgZG9jdW1lbnQncyB0ZXh0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpOiB1cmksIGxhbmd1YWdlSWQ6IGxhbmd1YWdlSWQsIHZlcnNpb246IHZlcnNpb24sIHRleHQ6IHRleHQgfTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50SXRlbS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBUZXh0RG9jdW1lbnRJdGVtfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhbmd1YWdlSWQpICYmIElzLmludGVnZXIoY2FuZGlkYXRlLnZlcnNpb24pICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGV4dCk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudEl0ZW0uaXMgPSBpcztcbn0pKFRleHREb2N1bWVudEl0ZW0gfHwgKFRleHREb2N1bWVudEl0ZW0gPSB7fSkpO1xuLyoqXG4gKiBEZXNjcmliZXMgdGhlIGNvbnRlbnQgdHlwZSB0aGF0IGEgY2xpZW50IHN1cHBvcnRzIGluIHZhcmlvdXNcbiAqIHJlc3VsdCBsaXRlcmFscyBsaWtlIGBIb3ZlcmAsIGBQYXJhbWV0ZXJJbmZvYCBvciBgQ29tcGxldGlvbkl0ZW1gLlxuICpcbiAqIFBsZWFzZSBub3RlIHRoYXQgYE1hcmt1cEtpbmRzYCBtdXN0IG5vdCBzdGFydCB3aXRoIGEgYCRgLiBUaGlzIGtpbmRzXG4gKiBhcmUgcmVzZXJ2ZWQgZm9yIGludGVybmFsIHVzYWdlLlxuICovXG52YXIgTWFya3VwS2luZDtcbihmdW5jdGlvbiAoTWFya3VwS2luZCkge1xuICAgIC8qKlxuICAgICAqIFBsYWluIHRleHQgaXMgc3VwcG9ydGVkIGFzIGEgY29udGVudCBmb3JtYXRcbiAgICAgKi9cbiAgICBNYXJrdXBLaW5kLlBsYWluVGV4dCA9ICdwbGFpbnRleHQnO1xuICAgIC8qKlxuICAgICAqIE1hcmtkb3duIGlzIHN1cHBvcnRlZCBhcyBhIGNvbnRlbnQgZm9ybWF0XG4gICAgICovXG4gICAgTWFya3VwS2luZC5NYXJrZG93biA9ICdtYXJrZG93bic7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsdWUgb2YgdGhlIHtAbGluayBNYXJrdXBLaW5kfSB0eXBlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSA9PT0gTWFya3VwS2luZC5QbGFpblRleHQgfHwgY2FuZGlkYXRlID09PSBNYXJrdXBLaW5kLk1hcmtkb3duO1xuICAgIH1cbiAgICBNYXJrdXBLaW5kLmlzID0gaXM7XG59KShNYXJrdXBLaW5kIHx8IChNYXJrdXBLaW5kID0ge30pKTtcbnZhciBNYXJrdXBDb250ZW50O1xuKGZ1bmN0aW9uIChNYXJrdXBDb250ZW50KSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgTWFya3VwQ29udGVudH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwodmFsdWUpICYmIE1hcmt1cEtpbmQuaXMoY2FuZGlkYXRlLmtpbmQpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudmFsdWUpO1xuICAgIH1cbiAgICBNYXJrdXBDb250ZW50LmlzID0gaXM7XG59KShNYXJrdXBDb250ZW50IHx8IChNYXJrdXBDb250ZW50ID0ge30pKTtcbi8qKlxuICogVGhlIGtpbmQgb2YgYSBjb21wbGV0aW9uIGVudHJ5LlxuICovXG52YXIgQ29tcGxldGlvbkl0ZW1LaW5kO1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbUtpbmQpIHtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuVGV4dCA9IDE7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLk1ldGhvZCA9IDI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZ1bmN0aW9uID0gMztcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ29uc3RydWN0b3IgPSA0O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5GaWVsZCA9IDU7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlZhcmlhYmxlID0gNjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ2xhc3MgPSA3O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5JbnRlcmZhY2UgPSA4O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Nb2R1bGUgPSA5O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Qcm9wZXJ0eSA9IDEwO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Vbml0ID0gMTE7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlZhbHVlID0gMTI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkVudW0gPSAxMztcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuS2V5d29yZCA9IDE0O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5TbmlwcGV0ID0gMTU7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkNvbG9yID0gMTY7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZpbGUgPSAxNztcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuUmVmZXJlbmNlID0gMTg7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZvbGRlciA9IDE5O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5FbnVtTWVtYmVyID0gMjA7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkNvbnN0YW50ID0gMjE7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlN0cnVjdCA9IDIyO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5FdmVudCA9IDIzO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5PcGVyYXRvciA9IDI0O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5UeXBlUGFyYW1ldGVyID0gMjU7XG59KShDb21wbGV0aW9uSXRlbUtpbmQgfHwgKENvbXBsZXRpb25JdGVtS2luZCA9IHt9KSk7XG4vKipcbiAqIERlZmluZXMgd2hldGhlciB0aGUgaW5zZXJ0IHRleHQgaW4gYSBjb21wbGV0aW9uIGl0ZW0gc2hvdWxkIGJlIGludGVycHJldGVkIGFzXG4gKiBwbGFpbiB0ZXh0IG9yIGEgc25pcHBldC5cbiAqL1xudmFyIEluc2VydFRleHRGb3JtYXQ7XG4oZnVuY3Rpb24gKEluc2VydFRleHRGb3JtYXQpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJpbWFyeSB0ZXh0IHRvIGJlIGluc2VydGVkIGlzIHRyZWF0ZWQgYXMgYSBwbGFpbiBzdHJpbmcuXG4gICAgICovXG4gICAgSW5zZXJ0VGV4dEZvcm1hdC5QbGFpblRleHQgPSAxO1xuICAgIC8qKlxuICAgICAqIFRoZSBwcmltYXJ5IHRleHQgdG8gYmUgaW5zZXJ0ZWQgaXMgdHJlYXRlZCBhcyBhIHNuaXBwZXQuXG4gICAgICpcbiAgICAgKiBBIHNuaXBwZXQgY2FuIGRlZmluZSB0YWIgc3RvcHMgYW5kIHBsYWNlaG9sZGVycyB3aXRoIGAkMWAsIGAkMmBcbiAgICAgKiBhbmQgYCR7Mzpmb299YC4gYCQwYCBkZWZpbmVzIHRoZSBmaW5hbCB0YWIgc3RvcCwgaXQgZGVmYXVsdHMgdG9cbiAgICAgKiB0aGUgZW5kIG9mIHRoZSBzbmlwcGV0LiBQbGFjZWhvbGRlcnMgd2l0aCBlcXVhbCBpZGVudGlmaWVycyBhcmUgbGlua2VkLFxuICAgICAqIHRoYXQgaXMgdHlwaW5nIGluIG9uZSB3aWxsIHVwZGF0ZSBvdGhlcnMgdG9vLlxuICAgICAqXG4gICAgICogU2VlIGFsc286IGh0dHBzOi8vbWljcm9zb2Z0LmdpdGh1Yi5pby9sYW5ndWFnZS1zZXJ2ZXItcHJvdG9jb2wvc3BlY2lmaWNhdGlvbnMvc3BlY2lmaWNhdGlvbi1jdXJyZW50LyNzbmlwcGV0X3N5bnRheFxuICAgICAqL1xuICAgIEluc2VydFRleHRGb3JtYXQuU25pcHBldCA9IDI7XG59KShJbnNlcnRUZXh0Rm9ybWF0IHx8IChJbnNlcnRUZXh0Rm9ybWF0ID0ge30pKTtcbi8qKlxuICogQ29tcGxldGlvbiBpdGVtIHRhZ3MgYXJlIGV4dHJhIGFubm90YXRpb25zIHRoYXQgdHdlYWsgdGhlIHJlbmRlcmluZyBvZiBhIGNvbXBsZXRpb25cbiAqIGl0ZW0uXG4gKlxuICogQHNpbmNlIDMuMTUuMFxuICovXG52YXIgQ29tcGxldGlvbkl0ZW1UYWc7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtVGFnKSB7XG4gICAgLyoqXG4gICAgICogUmVuZGVyIGEgY29tcGxldGlvbiBhcyBvYnNvbGV0ZSwgdXN1YWxseSB1c2luZyBhIHN0cmlrZS1vdXQuXG4gICAgICovXG4gICAgQ29tcGxldGlvbkl0ZW1UYWcuRGVwcmVjYXRlZCA9IDE7XG59KShDb21wbGV0aW9uSXRlbVRhZyB8fCAoQ29tcGxldGlvbkl0ZW1UYWcgPSB7fSkpO1xuLyoqXG4gKiBUaGUgSW5zZXJ0UmVwbGFjZUVkaXQgbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGggaW5zZXJ0IC8gcmVwbGFjZSBlZGl0cy5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBJbnNlcnRSZXBsYWNlRWRpdDtcbihmdW5jdGlvbiAoSW5zZXJ0UmVwbGFjZUVkaXQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc2VydCAvIHJlcGxhY2UgZWRpdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShuZXdUZXh0LCBpbnNlcnQsIHJlcGxhY2UpIHtcbiAgICAgICAgcmV0dXJuIHsgbmV3VGV4dDogbmV3VGV4dCwgaW5zZXJ0OiBpbnNlcnQsIHJlcGxhY2U6IHJlcGxhY2UgfTtcbiAgICB9XG4gICAgSW5zZXJ0UmVwbGFjZUVkaXQuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgSW5zZXJ0UmVwbGFjZUVkaXR9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uZXdUZXh0KSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUuaW5zZXJ0KSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmVwbGFjZSk7XG4gICAgfVxuICAgIEluc2VydFJlcGxhY2VFZGl0LmlzID0gaXM7XG59KShJbnNlcnRSZXBsYWNlRWRpdCB8fCAoSW5zZXJ0UmVwbGFjZUVkaXQgPSB7fSkpO1xuLyoqXG4gKiBIb3cgd2hpdGVzcGFjZSBhbmQgaW5kZW50YXRpb24gaXMgaGFuZGxlZCBkdXJpbmcgY29tcGxldGlvblxuICogaXRlbSBpbnNlcnRpb24uXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgSW5zZXJ0VGV4dE1vZGU7XG4oZnVuY3Rpb24gKEluc2VydFRleHRNb2RlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGluc2VydGlvbiBvciByZXBsYWNlIHN0cmluZ3MgaXMgdGFrZW4gYXMgaXQgaXMuIElmIHRoZVxuICAgICAqIHZhbHVlIGlzIG11bHRpIGxpbmUgdGhlIGxpbmVzIGJlbG93IHRoZSBjdXJzb3Igd2lsbCBiZVxuICAgICAqIGluc2VydGVkIHVzaW5nIHRoZSBpbmRlbnRhdGlvbiBkZWZpbmVkIGluIHRoZSBzdHJpbmcgdmFsdWUuXG4gICAgICogVGhlIGNsaWVudCB3aWxsIG5vdCBhcHBseSBhbnkga2luZCBvZiBhZGp1c3RtZW50cyB0byB0aGVcbiAgICAgKiBzdHJpbmcuXG4gICAgICovXG4gICAgSW5zZXJ0VGV4dE1vZGUuYXNJcyA9IDE7XG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBhZGp1c3RzIGxlYWRpbmcgd2hpdGVzcGFjZSBvZiBuZXcgbGluZXMgc28gdGhhdFxuICAgICAqIHRoZXkgbWF0Y2ggdGhlIGluZGVudGF0aW9uIHVwIHRvIHRoZSBjdXJzb3Igb2YgdGhlIGxpbmUgZm9yXG4gICAgICogd2hpY2ggdGhlIGl0ZW0gaXMgYWNjZXB0ZWQuXG4gICAgICpcbiAgICAgKiBDb25zaWRlciBhIGxpbmUgbGlrZSB0aGlzOiA8MnRhYnM+PGN1cnNvcj48M3RhYnM+Zm9vLiBBY2NlcHRpbmcgYVxuICAgICAqIG11bHRpIGxpbmUgY29tcGxldGlvbiBpdGVtIGlzIGluZGVudGVkIHVzaW5nIDIgdGFicyBhbmQgYWxsXG4gICAgICogZm9sbG93aW5nIGxpbmVzIGluc2VydGVkIHdpbGwgYmUgaW5kZW50ZWQgdXNpbmcgMiB0YWJzIGFzIHdlbGwuXG4gICAgICovXG4gICAgSW5zZXJ0VGV4dE1vZGUuYWRqdXN0SW5kZW50YXRpb24gPSAyO1xufSkoSW5zZXJ0VGV4dE1vZGUgfHwgKEluc2VydFRleHRNb2RlID0ge30pKTtcbnZhciBDb21wbGV0aW9uSXRlbUxhYmVsRGV0YWlscztcbihmdW5jdGlvbiAoQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHMpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUuZGV0YWlsKSB8fCBjYW5kaWRhdGUuZGV0YWlsID09PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5kZXNjcmlwdGlvbikgfHwgY2FuZGlkYXRlLmRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBDb21wbGV0aW9uSXRlbUxhYmVsRGV0YWlscy5pcyA9IGlzO1xufSkoQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHMgfHwgKENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzID0ge30pKTtcbi8qKlxuICogVGhlIENvbXBsZXRpb25JdGVtIG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoXG4gKiBjb21wbGV0aW9uIGl0ZW1zLlxuICovXG52YXIgQ29tcGxldGlvbkl0ZW07XG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY29tcGxldGlvbiBpdGVtIGFuZCBzZWVkIGl0IHdpdGggYSBsYWJlbC5cbiAgICAgKiBAcGFyYW0gbGFiZWwgVGhlIGNvbXBsZXRpb24gaXRlbSdzIGxhYmVsXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsKSB7XG4gICAgICAgIHJldHVybiB7IGxhYmVsOiBsYWJlbCB9O1xuICAgIH1cbiAgICBDb21wbGV0aW9uSXRlbS5jcmVhdGUgPSBjcmVhdGU7XG59KShDb21wbGV0aW9uSXRlbSB8fCAoQ29tcGxldGlvbkl0ZW0gPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29tcGxldGlvbkxpc3QgbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGhcbiAqIGNvbXBsZXRpb24gbGlzdHMuXG4gKi9cbnZhciBDb21wbGV0aW9uTGlzdDtcbihmdW5jdGlvbiAoQ29tcGxldGlvbkxpc3QpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbXBsZXRpb24gbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpdGVtcyBUaGUgY29tcGxldGlvbiBpdGVtcy5cbiAgICAgKiBAcGFyYW0gaXNJbmNvbXBsZXRlIFRoZSBsaXN0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUoaXRlbXMsIGlzSW5jb21wbGV0ZSkge1xuICAgICAgICByZXR1cm4geyBpdGVtczogaXRlbXMgPyBpdGVtcyA6IFtdLCBpc0luY29tcGxldGU6ICEhaXNJbmNvbXBsZXRlIH07XG4gICAgfVxuICAgIENvbXBsZXRpb25MaXN0LmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKENvbXBsZXRpb25MaXN0IHx8IChDb21wbGV0aW9uTGlzdCA9IHt9KSk7XG52YXIgTWFya2VkU3RyaW5nO1xuKGZ1bmN0aW9uIChNYXJrZWRTdHJpbmcpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbWFya2VkIHN0cmluZyBmcm9tIHBsYWluIHRleHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGxhaW5UZXh0IFRoZSBwbGFpbiB0ZXh0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21QbGFpblRleHQocGxhaW5UZXh0KSB7XG4gICAgICAgIHJldHVybiBwbGFpblRleHQucmVwbGFjZSgvW1xcXFxgKl97fVtcXF0oKSMrXFwtLiFdL2csICdcXFxcJCYnKTsgLy8gZXNjYXBlIG1hcmtkb3duIHN5bnRheCB0b2tlbnM6IGh0dHA6Ly9kYXJpbmdmaXJlYmFsbC5uZXQvcHJvamVjdHMvbWFya2Rvd24vc3ludGF4I2JhY2tzbGFzaFxuICAgIH1cbiAgICBNYXJrZWRTdHJpbmcuZnJvbVBsYWluVGV4dCA9IGZyb21QbGFpblRleHQ7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgTWFya2VkU3RyaW5nfSB0eXBlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLnN0cmluZyhjYW5kaWRhdGUpIHx8IChJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYW5ndWFnZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS52YWx1ZSkpO1xuICAgIH1cbiAgICBNYXJrZWRTdHJpbmcuaXMgPSBpcztcbn0pKE1hcmtlZFN0cmluZyB8fCAoTWFya2VkU3RyaW5nID0ge30pKTtcbnZhciBIb3ZlcjtcbihmdW5jdGlvbiAoSG92ZXIpIHtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgY29uZm9ybXMgdG8gdGhlIHtAbGluayBIb3Zlcn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuICEhY2FuZGlkYXRlICYmIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiAoTWFya3VwQ29udGVudC5pcyhjYW5kaWRhdGUuY29udGVudHMpIHx8XG4gICAgICAgICAgICBNYXJrZWRTdHJpbmcuaXMoY2FuZGlkYXRlLmNvbnRlbnRzKSB8fFxuICAgICAgICAgICAgSXMudHlwZWRBcnJheShjYW5kaWRhdGUuY29udGVudHMsIE1hcmtlZFN0cmluZy5pcykpICYmICh2YWx1ZS5yYW5nZSA9PT0gdW5kZWZpbmVkIHx8IFJhbmdlLmlzKHZhbHVlLnJhbmdlKSk7XG4gICAgfVxuICAgIEhvdmVyLmlzID0gaXM7XG59KShIb3ZlciB8fCAoSG92ZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgUGFyYW1ldGVySW5mb3JtYXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgUGFyYW1ldGVySW5mb3JtYXRpb259IGxpdGVyYWxzLlxuICovXG52YXIgUGFyYW1ldGVySW5mb3JtYXRpb247XG4oZnVuY3Rpb24gKFBhcmFtZXRlckluZm9ybWF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBwYXJhbWV0ZXIgaW5mb3JtYXRpb24gbGl0ZXJhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYWJlbCBBIGxhYmVsIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRhdGlvbiBBIGRvYyBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsLCBkb2N1bWVudGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudGF0aW9uID8geyBsYWJlbDogbGFiZWwsIGRvY3VtZW50YXRpb246IGRvY3VtZW50YXRpb24gfSA6IHsgbGFiZWw6IGxhYmVsIH07XG4gICAgfVxuICAgIFBhcmFtZXRlckluZm9ybWF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKFBhcmFtZXRlckluZm9ybWF0aW9uIHx8IChQYXJhbWV0ZXJJbmZvcm1hdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBTaWduYXR1cmVJbmZvcm1hdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBTaWduYXR1cmVJbmZvcm1hdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBTaWduYXR1cmVJbmZvcm1hdGlvbjtcbihmdW5jdGlvbiAoU2lnbmF0dXJlSW5mb3JtYXRpb24pIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUobGFiZWwsIGRvY3VtZW50YXRpb24pIHtcbiAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnNbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgbGFiZWw6IGxhYmVsIH07XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGRvY3VtZW50YXRpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQuZG9jdW1lbnRhdGlvbiA9IGRvY3VtZW50YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQocGFyYW1ldGVycykpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wYXJhbWV0ZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgU2lnbmF0dXJlSW5mb3JtYXRpb24uY3JlYXRlID0gY3JlYXRlO1xufSkoU2lnbmF0dXJlSW5mb3JtYXRpb24gfHwgKFNpZ25hdHVyZUluZm9ybWF0aW9uID0ge30pKTtcbi8qKlxuICogQSBkb2N1bWVudCBoaWdobGlnaHQga2luZC5cbiAqL1xudmFyIERvY3VtZW50SGlnaGxpZ2h0S2luZDtcbihmdW5jdGlvbiAoRG9jdW1lbnRIaWdobGlnaHRLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQSB0ZXh0dWFsIG9jY3VycmVuY2UuXG4gICAgICovXG4gICAgRG9jdW1lbnRIaWdobGlnaHRLaW5kLlRleHQgPSAxO1xuICAgIC8qKlxuICAgICAqIFJlYWQtYWNjZXNzIG9mIGEgc3ltYm9sLCBsaWtlIHJlYWRpbmcgYSB2YXJpYWJsZS5cbiAgICAgKi9cbiAgICBEb2N1bWVudEhpZ2hsaWdodEtpbmQuUmVhZCA9IDI7XG4gICAgLyoqXG4gICAgICogV3JpdGUtYWNjZXNzIG9mIGEgc3ltYm9sLCBsaWtlIHdyaXRpbmcgdG8gYSB2YXJpYWJsZS5cbiAgICAgKi9cbiAgICBEb2N1bWVudEhpZ2hsaWdodEtpbmQuV3JpdGUgPSAzO1xufSkoRG9jdW1lbnRIaWdobGlnaHRLaW5kIHx8IChEb2N1bWVudEhpZ2hsaWdodEtpbmQgPSB7fSkpO1xuLyoqXG4gKiBEb2N1bWVudEhpZ2hsaWdodCBuYW1lc3BhY2UgdG8gcHJvdmlkZSBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIERvY3VtZW50SGlnaGxpZ2h0fSBsaXRlcmFscy5cbiAqL1xudmFyIERvY3VtZW50SGlnaGxpZ2h0O1xuKGZ1bmN0aW9uIChEb2N1bWVudEhpZ2hsaWdodCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIERvY3VtZW50SGlnaGxpZ2h0IG9iamVjdC5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIHRoZSBoaWdobGlnaHQgYXBwbGllcyB0by5cbiAgICAgKiBAcGFyYW0ga2luZCBUaGUgaGlnaGxpZ2h0IGtpbmRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIGtpbmQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgcmFuZ2U6IHJhbmdlIH07XG4gICAgICAgIGlmIChJcy5udW1iZXIoa2luZCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0ga2luZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBEb2N1bWVudEhpZ2hsaWdodC5jcmVhdGUgPSBjcmVhdGU7XG59KShEb2N1bWVudEhpZ2hsaWdodCB8fCAoRG9jdW1lbnRIaWdobGlnaHQgPSB7fSkpO1xuLyoqXG4gKiBBIHN5bWJvbCBraW5kLlxuICovXG52YXIgU3ltYm9sS2luZDtcbihmdW5jdGlvbiAoU3ltYm9sS2luZCkge1xuICAgIFN5bWJvbEtpbmQuRmlsZSA9IDE7XG4gICAgU3ltYm9sS2luZC5Nb2R1bGUgPSAyO1xuICAgIFN5bWJvbEtpbmQuTmFtZXNwYWNlID0gMztcbiAgICBTeW1ib2xLaW5kLlBhY2thZ2UgPSA0O1xuICAgIFN5bWJvbEtpbmQuQ2xhc3MgPSA1O1xuICAgIFN5bWJvbEtpbmQuTWV0aG9kID0gNjtcbiAgICBTeW1ib2xLaW5kLlByb3BlcnR5ID0gNztcbiAgICBTeW1ib2xLaW5kLkZpZWxkID0gODtcbiAgICBTeW1ib2xLaW5kLkNvbnN0cnVjdG9yID0gOTtcbiAgICBTeW1ib2xLaW5kLkVudW0gPSAxMDtcbiAgICBTeW1ib2xLaW5kLkludGVyZmFjZSA9IDExO1xuICAgIFN5bWJvbEtpbmQuRnVuY3Rpb24gPSAxMjtcbiAgICBTeW1ib2xLaW5kLlZhcmlhYmxlID0gMTM7XG4gICAgU3ltYm9sS2luZC5Db25zdGFudCA9IDE0O1xuICAgIFN5bWJvbEtpbmQuU3RyaW5nID0gMTU7XG4gICAgU3ltYm9sS2luZC5OdW1iZXIgPSAxNjtcbiAgICBTeW1ib2xLaW5kLkJvb2xlYW4gPSAxNztcbiAgICBTeW1ib2xLaW5kLkFycmF5ID0gMTg7XG4gICAgU3ltYm9sS2luZC5PYmplY3QgPSAxOTtcbiAgICBTeW1ib2xLaW5kLktleSA9IDIwO1xuICAgIFN5bWJvbEtpbmQuTnVsbCA9IDIxO1xuICAgIFN5bWJvbEtpbmQuRW51bU1lbWJlciA9IDIyO1xuICAgIFN5bWJvbEtpbmQuU3RydWN0ID0gMjM7XG4gICAgU3ltYm9sS2luZC5FdmVudCA9IDI0O1xuICAgIFN5bWJvbEtpbmQuT3BlcmF0b3IgPSAyNTtcbiAgICBTeW1ib2xLaW5kLlR5cGVQYXJhbWV0ZXIgPSAyNjtcbn0pKFN5bWJvbEtpbmQgfHwgKFN5bWJvbEtpbmQgPSB7fSkpO1xuLyoqXG4gKiBTeW1ib2wgdGFncyBhcmUgZXh0cmEgYW5ub3RhdGlvbnMgdGhhdCB0d2VhayB0aGUgcmVuZGVyaW5nIG9mIGEgc3ltYm9sLlxuICpcbiAqIEBzaW5jZSAzLjE2XG4gKi9cbnZhciBTeW1ib2xUYWc7XG4oZnVuY3Rpb24gKFN5bWJvbFRhZykge1xuICAgIC8qKlxuICAgICAqIFJlbmRlciBhIHN5bWJvbCBhcyBvYnNvbGV0ZSwgdXN1YWxseSB1c2luZyBhIHN0cmlrZS1vdXQuXG4gICAgICovXG4gICAgU3ltYm9sVGFnLkRlcHJlY2F0ZWQgPSAxO1xufSkoU3ltYm9sVGFnIHx8IChTeW1ib2xUYWcgPSB7fSkpO1xudmFyIFN5bWJvbEluZm9ybWF0aW9uO1xuKGZ1bmN0aW9uIChTeW1ib2xJbmZvcm1hdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgc3ltYm9sIGluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBraW5kIFRoZSBraW5kIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0aGUgbG9jYXRpb24gb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSByZXNvdXJjZSBvZiB0aGUgbG9jYXRpb24gb2Ygc3ltYm9sLlxuICAgICAqIEBwYXJhbSBjb250YWluZXJOYW1lIFRoZSBuYW1lIG9mIHRoZSBzeW1ib2wgY29udGFpbmluZyB0aGUgc3ltYm9sLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShuYW1lLCBraW5kLCByYW5nZSwgdXJpLCBjb250YWluZXJOYW1lKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgICAgIGxvY2F0aW9uOiB7IHVyaTogdXJpLCByYW5nZTogcmFuZ2UgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoY29udGFpbmVyTmFtZSkge1xuICAgICAgICAgICAgcmVzdWx0LmNvbnRhaW5lck5hbWUgPSBjb250YWluZXJOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIFN5bWJvbEluZm9ybWF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKFN5bWJvbEluZm9ybWF0aW9uIHx8IChTeW1ib2xJbmZvcm1hdGlvbiA9IHt9KSk7XG52YXIgV29ya3NwYWNlU3ltYm9sO1xuKGZ1bmN0aW9uIChXb3Jrc3BhY2VTeW1ib2wpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgd29ya3NwYWNlIHN5bWJvbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIGtpbmQgVGhlIGtpbmQgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSByZXNvdXJjZSBvZiB0aGUgbG9jYXRpb24gb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgQW4gb3B0aW9ucyByYW5nZSBvZiB0aGUgbG9jYXRpb24uXG4gICAgICogQHJldHVybnMgQSBXb3Jrc3BhY2VTeW1ib2wuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKG5hbWUsIGtpbmQsIHVyaSwgcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8geyBuYW1lOiBuYW1lLCBraW5kOiBraW5kLCBsb2NhdGlvbjogeyB1cmk6IHVyaSwgcmFuZ2U6IHJhbmdlIH0gfVxuICAgICAgICAgICAgOiB7IG5hbWU6IG5hbWUsIGtpbmQ6IGtpbmQsIGxvY2F0aW9uOiB7IHVyaTogdXJpIH0gfTtcbiAgICB9XG4gICAgV29ya3NwYWNlU3ltYm9sLmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKFdvcmtzcGFjZVN5bWJvbCB8fCAoV29ya3NwYWNlU3ltYm9sID0ge30pKTtcbnZhciBEb2N1bWVudFN5bWJvbDtcbihmdW5jdGlvbiAoRG9jdW1lbnRTeW1ib2wpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHN5bWJvbCBpbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gZGV0YWlsIFRoZSBkZXRhaWwgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0ga2luZCBUaGUga2luZCBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gc2VsZWN0aW9uUmFuZ2UgVGhlIHNlbGVjdGlvblJhbmdlIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIGNoaWxkcmVuIENoaWxkcmVuIG9mIHRoZSBzeW1ib2wuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKG5hbWUsIGRldGFpbCwga2luZCwgcmFuZ2UsIHNlbGVjdGlvblJhbmdlLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGRldGFpbDogZGV0YWlsLFxuICAgICAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgICAgIHNlbGVjdGlvblJhbmdlOiBzZWxlY3Rpb25SYW5nZVxuICAgICAgICB9O1xuICAgICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRG9jdW1lbnRTeW1ib2wuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRG9jdW1lbnRTeW1ib2x9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiZcbiAgICAgICAgICAgIElzLnN0cmluZyhjYW5kaWRhdGUubmFtZSkgJiYgSXMubnVtYmVyKGNhbmRpZGF0ZS5raW5kKSAmJlxuICAgICAgICAgICAgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUuc2VsZWN0aW9uUmFuZ2UpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmRldGFpbCA9PT0gdW5kZWZpbmVkIHx8IElzLnN0cmluZyhjYW5kaWRhdGUuZGV0YWlsKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZGVwcmVjYXRlZCA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLmRlcHJlY2F0ZWQpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5jaGlsZHJlbiA9PT0gdW5kZWZpbmVkIHx8IEFycmF5LmlzQXJyYXkoY2FuZGlkYXRlLmNoaWxkcmVuKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUudGFncyA9PT0gdW5kZWZpbmVkIHx8IEFycmF5LmlzQXJyYXkoY2FuZGlkYXRlLnRhZ3MpKTtcbiAgICB9XG4gICAgRG9jdW1lbnRTeW1ib2wuaXMgPSBpcztcbn0pKERvY3VtZW50U3ltYm9sIHx8IChEb2N1bWVudFN5bWJvbCA9IHt9KSk7XG4vKipcbiAqIEEgc2V0IG9mIHByZWRlZmluZWQgY29kZSBhY3Rpb24ga2luZHNcbiAqL1xudmFyIENvZGVBY3Rpb25LaW5kO1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uS2luZCkge1xuICAgIC8qKlxuICAgICAqIEVtcHR5IGtpbmQuXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuRW1wdHkgPSAnJztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIHF1aWNrZml4IGFjdGlvbnM6ICdxdWlja2ZpeCdcbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5RdWlja0ZpeCA9ICdxdWlja2ZpeCc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciByZWZhY3RvcmluZyBhY3Rpb25zOiAncmVmYWN0b3InXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuUmVmYWN0b3IgPSAncmVmYWN0b3InO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcmVmYWN0b3JpbmcgZXh0cmFjdGlvbiBhY3Rpb25zOiAncmVmYWN0b3IuZXh0cmFjdCdcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgZXh0cmFjdCBhY3Rpb25zOlxuICAgICAqXG4gICAgICogLSBFeHRyYWN0IG1ldGhvZFxuICAgICAqIC0gRXh0cmFjdCBmdW5jdGlvblxuICAgICAqIC0gRXh0cmFjdCB2YXJpYWJsZVxuICAgICAqIC0gRXh0cmFjdCBpbnRlcmZhY2UgZnJvbSBjbGFzc1xuICAgICAqIC0gLi4uXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuUmVmYWN0b3JFeHRyYWN0ID0gJ3JlZmFjdG9yLmV4dHJhY3QnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcmVmYWN0b3JpbmcgaW5saW5lIGFjdGlvbnM6ICdyZWZhY3Rvci5pbmxpbmUnXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIGlubGluZSBhY3Rpb25zOlxuICAgICAqXG4gICAgICogLSBJbmxpbmUgZnVuY3Rpb25cbiAgICAgKiAtIElubGluZSB2YXJpYWJsZVxuICAgICAqIC0gSW5saW5lIGNvbnN0YW50XG4gICAgICogLSAuLi5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5SZWZhY3RvcklubGluZSA9ICdyZWZhY3Rvci5pbmxpbmUnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcmVmYWN0b3JpbmcgcmV3cml0ZSBhY3Rpb25zOiAncmVmYWN0b3IucmV3cml0ZSdcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgcmV3cml0ZSBhY3Rpb25zOlxuICAgICAqXG4gICAgICogLSBDb252ZXJ0IEphdmFTY3JpcHQgZnVuY3Rpb24gdG8gY2xhc3NcbiAgICAgKiAtIEFkZCBvciByZW1vdmUgcGFyYW1ldGVyXG4gICAgICogLSBFbmNhcHN1bGF0ZSBmaWVsZFxuICAgICAqIC0gTWFrZSBtZXRob2Qgc3RhdGljXG4gICAgICogLSBNb3ZlIG1ldGhvZCB0byBiYXNlIGNsYXNzXG4gICAgICogLSAuLi5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5SZWZhY3RvclJld3JpdGUgPSAncmVmYWN0b3IucmV3cml0ZSc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciBzb3VyY2UgYWN0aW9uczogYHNvdXJjZWBcbiAgICAgKlxuICAgICAqIFNvdXJjZSBjb2RlIGFjdGlvbnMgYXBwbHkgdG8gdGhlIGVudGlyZSBmaWxlLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlNvdXJjZSA9ICdzb3VyY2UnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgYW4gb3JnYW5pemUgaW1wb3J0cyBzb3VyY2UgYWN0aW9uOiBgc291cmNlLm9yZ2FuaXplSW1wb3J0c2BcbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5Tb3VyY2VPcmdhbml6ZUltcG9ydHMgPSAnc291cmNlLm9yZ2FuaXplSW1wb3J0cyc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciBhdXRvLWZpeCBzb3VyY2UgYWN0aW9uczogYHNvdXJjZS5maXhBbGxgLlxuICAgICAqXG4gICAgICogRml4IGFsbCBhY3Rpb25zIGF1dG9tYXRpY2FsbHkgZml4IGVycm9ycyB0aGF0IGhhdmUgYSBjbGVhciBmaXggdGhhdCBkbyBub3QgcmVxdWlyZSB1c2VyIGlucHV0LlxuICAgICAqIFRoZXkgc2hvdWxkIG5vdCBzdXBwcmVzcyBlcnJvcnMgb3IgcGVyZm9ybSB1bnNhZmUgZml4ZXMgc3VjaCBhcyBnZW5lcmF0aW5nIG5ldyB0eXBlcyBvciBjbGFzc2VzLlxuICAgICAqXG4gICAgICogQHNpbmNlIDMuMTUuMFxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlNvdXJjZUZpeEFsbCA9ICdzb3VyY2UuZml4QWxsJztcbn0pKENvZGVBY3Rpb25LaW5kIHx8IChDb2RlQWN0aW9uS2luZCA9IHt9KSk7XG4vKipcbiAqIFRoZSByZWFzb24gd2h5IGNvZGUgYWN0aW9ucyB3ZXJlIHJlcXVlc3RlZC5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBDb2RlQWN0aW9uVHJpZ2dlcktpbmQ7XG4oZnVuY3Rpb24gKENvZGVBY3Rpb25UcmlnZ2VyS2luZCkge1xuICAgIC8qKlxuICAgICAqIENvZGUgYWN0aW9ucyB3ZXJlIGV4cGxpY2l0bHkgcmVxdWVzdGVkIGJ5IHRoZSB1c2VyIG9yIGJ5IGFuIGV4dGVuc2lvbi5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCA9IDE7XG4gICAgLyoqXG4gICAgICogQ29kZSBhY3Rpb25zIHdlcmUgcmVxdWVzdGVkIGF1dG9tYXRpY2FsbHkuXG4gICAgICpcbiAgICAgKiBUaGlzIHR5cGljYWxseSBoYXBwZW5zIHdoZW4gY3VycmVudCBzZWxlY3Rpb24gaW4gYSBmaWxlIGNoYW5nZXMsIGJ1dCBjYW5cbiAgICAgKiBhbHNvIGJlIHRyaWdnZXJlZCB3aGVuIGZpbGUgY29udGVudCBjaGFuZ2VzLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25UcmlnZ2VyS2luZC5BdXRvbWF0aWMgPSAyO1xufSkoQ29kZUFjdGlvblRyaWdnZXJLaW5kIHx8IChDb2RlQWN0aW9uVHJpZ2dlcktpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29kZUFjdGlvbkNvbnRleHQgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgQ29kZUFjdGlvbkNvbnRleHR9IGxpdGVyYWxzLlxuICovXG52YXIgQ29kZUFjdGlvbkNvbnRleHQ7XG4oZnVuY3Rpb24gKENvZGVBY3Rpb25Db250ZXh0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb2RlQWN0aW9uQ29udGV4dCBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShkaWFnbm9zdGljcywgb25seSwgdHJpZ2dlcktpbmQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgZGlhZ25vc3RpY3M6IGRpYWdub3N0aWNzIH07XG4gICAgICAgIGlmIChvbmx5ICE9PSB1bmRlZmluZWQgJiYgb25seSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lm9ubHkgPSBvbmx5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmlnZ2VyS2luZCAhPT0gdW5kZWZpbmVkICYmIHRyaWdnZXJLaW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQudHJpZ2dlcktpbmQgPSB0cmlnZ2VyS2luZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb2RlQWN0aW9uQ29udGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb2RlQWN0aW9uQ29udGV4dH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5kaWFnbm9zdGljcywgRGlhZ25vc3RpYy5pcylcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUub25seSA9PT0gdW5kZWZpbmVkIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLm9ubHksIElzLnN0cmluZykpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnRyaWdnZXJLaW5kID09PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLnRyaWdnZXJLaW5kID09PSBDb2RlQWN0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCB8fCBjYW5kaWRhdGUudHJpZ2dlcktpbmQgPT09IENvZGVBY3Rpb25UcmlnZ2VyS2luZC5BdXRvbWF0aWMpO1xuICAgIH1cbiAgICBDb2RlQWN0aW9uQ29udGV4dC5pcyA9IGlzO1xufSkoQ29kZUFjdGlvbkNvbnRleHQgfHwgKENvZGVBY3Rpb25Db250ZXh0ID0ge30pKTtcbnZhciBDb2RlQWN0aW9uO1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHRpdGxlLCBraW5kT3JDb21tYW5kT3JFZGl0LCBraW5kKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7IHRpdGxlOiB0aXRsZSB9O1xuICAgICAgICB2YXIgY2hlY2tLaW5kID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBraW5kT3JDb21tYW5kT3JFZGl0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY2hlY2tLaW5kID0gZmFsc2U7XG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGtpbmRPckNvbW1hbmRPckVkaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQ29tbWFuZC5pcyhraW5kT3JDb21tYW5kT3JFZGl0KSkge1xuICAgICAgICAgICAgcmVzdWx0LmNvbW1hbmQgPSBraW5kT3JDb21tYW5kT3JFZGl0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LmVkaXQgPSBraW5kT3JDb21tYW5kT3JFZGl0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGVja0tpbmQgJiYga2luZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGtpbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgQ29kZUFjdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGl0bGUpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmRpYWdub3N0aWNzID09PSB1bmRlZmluZWQgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUuZGlhZ25vc3RpY3MsIERpYWdub3N0aWMuaXMpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5raW5kID09PSB1bmRlZmluZWQgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5raW5kKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZWRpdCAhPT0gdW5kZWZpbmVkIHx8IGNhbmRpZGF0ZS5jb21tYW5kICE9PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmNvbW1hbmQgPT09IHVuZGVmaW5lZCB8fCBDb21tYW5kLmlzKGNhbmRpZGF0ZS5jb21tYW5kKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuaXNQcmVmZXJyZWQgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5pc1ByZWZlcnJlZCkpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmVkaXQgPT09IHVuZGVmaW5lZCB8fCBXb3Jrc3BhY2VFZGl0LmlzKGNhbmRpZGF0ZS5lZGl0KSk7XG4gICAgfVxuICAgIENvZGVBY3Rpb24uaXMgPSBpcztcbn0pKENvZGVBY3Rpb24gfHwgKENvZGVBY3Rpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29kZUxlbnMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgQ29kZUxlbnN9IGxpdGVyYWxzLlxuICovXG52YXIgQ29kZUxlbnM7XG4oZnVuY3Rpb24gKENvZGVMZW5zKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb2RlTGVucyBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgZGF0YSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0geyByYW5nZTogcmFuZ2UgfTtcbiAgICAgICAgaWYgKElzLmRlZmluZWQoZGF0YSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kYXRhID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb2RlTGVucy5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb2RlTGVuc30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmNvbW1hbmQpIHx8IENvbW1hbmQuaXMoY2FuZGlkYXRlLmNvbW1hbmQpKTtcbiAgICB9XG4gICAgQ29kZUxlbnMuaXMgPSBpcztcbn0pKENvZGVMZW5zIHx8IChDb2RlTGVucyA9IHt9KSk7XG4vKipcbiAqIFRoZSBGb3JtYXR0aW5nT3B0aW9ucyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBGb3JtYXR0aW5nT3B0aW9uc30gbGl0ZXJhbHMuXG4gKi9cbnZhciBGb3JtYXR0aW5nT3B0aW9ucztcbihmdW5jdGlvbiAoRm9ybWF0dGluZ09wdGlvbnMpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEZvcm1hdHRpbmdPcHRpb25zIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHRhYlNpemUsIGluc2VydFNwYWNlcykge1xuICAgICAgICByZXR1cm4geyB0YWJTaXplOiB0YWJTaXplLCBpbnNlcnRTcGFjZXM6IGluc2VydFNwYWNlcyB9O1xuICAgIH1cbiAgICBGb3JtYXR0aW5nT3B0aW9ucy5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBGb3JtYXR0aW5nT3B0aW9uc30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUudGFiU2l6ZSkgJiYgSXMuYm9vbGVhbihjYW5kaWRhdGUuaW5zZXJ0U3BhY2VzKTtcbiAgICB9XG4gICAgRm9ybWF0dGluZ09wdGlvbnMuaXMgPSBpcztcbn0pKEZvcm1hdHRpbmdPcHRpb25zIHx8IChGb3JtYXR0aW5nT3B0aW9ucyA9IHt9KSk7XG4vKipcbiAqIFRoZSBEb2N1bWVudExpbmsgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgRG9jdW1lbnRMaW5rfSBsaXRlcmFscy5cbiAqL1xudmFyIERvY3VtZW50TGluaztcbihmdW5jdGlvbiAoRG9jdW1lbnRMaW5rKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBEb2N1bWVudExpbmsgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIHRhcmdldCwgZGF0YSkge1xuICAgICAgICByZXR1cm4geyByYW5nZTogcmFuZ2UsIHRhcmdldDogdGFyZ2V0LCBkYXRhOiBkYXRhIH07XG4gICAgfVxuICAgIERvY3VtZW50TGluay5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBEb2N1bWVudExpbmt9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS50YXJnZXQpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUudGFyZ2V0KSk7XG4gICAgfVxuICAgIERvY3VtZW50TGluay5pcyA9IGlzO1xufSkoRG9jdW1lbnRMaW5rIHx8IChEb2N1bWVudExpbmsgPSB7fSkpO1xuLyoqXG4gKiBUaGUgU2VsZWN0aW9uUmFuZ2UgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbiB0byB3b3JrIHdpdGhcbiAqIFNlbGVjdGlvblJhbmdlIGxpdGVyYWxzLlxuICovXG52YXIgU2VsZWN0aW9uUmFuZ2U7XG4oZnVuY3Rpb24gKFNlbGVjdGlvblJhbmdlKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTZWxlY3Rpb25SYW5nZVxuICAgICAqIEBwYXJhbSByYW5nZSB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHBhcmVudCBhbiBvcHRpb25hbCBwYXJlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLCBwYXJlbnQ6IHBhcmVudCB9O1xuICAgIH1cbiAgICBTZWxlY3Rpb25SYW5nZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgKGNhbmRpZGF0ZS5wYXJlbnQgPT09IHVuZGVmaW5lZCB8fCBTZWxlY3Rpb25SYW5nZS5pcyhjYW5kaWRhdGUucGFyZW50KSk7XG4gICAgfVxuICAgIFNlbGVjdGlvblJhbmdlLmlzID0gaXM7XG59KShTZWxlY3Rpb25SYW5nZSB8fCAoU2VsZWN0aW9uUmFuZ2UgPSB7fSkpO1xuLyoqXG4gKiBBIHNldCBvZiBwcmVkZWZpbmVkIHRva2VuIHR5cGVzLiBUaGlzIHNldCBpcyBub3QgZml4ZWRcbiAqIGFuIGNsaWVudHMgY2FuIHNwZWNpZnkgYWRkaXRpb25hbCB0b2tlbiB0eXBlcyB2aWEgdGhlXG4gKiBjb3JyZXNwb25kaW5nIGNsaWVudCBjYXBhYmlsaXRpZXMuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgU2VtYW50aWNUb2tlblR5cGVzO1xuKGZ1bmN0aW9uIChTZW1hbnRpY1Rva2VuVHlwZXMpIHtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJuYW1lc3BhY2VcIl0gPSBcIm5hbWVzcGFjZVwiO1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBnZW5lcmljIHR5cGUuIEFjdHMgYXMgYSBmYWxsYmFjayBmb3IgdHlwZXMgd2hpY2ggY2FuJ3QgYmUgbWFwcGVkIHRvXG4gICAgICogYSBzcGVjaWZpYyB0eXBlIGxpa2UgY2xhc3Mgb3IgZW51bS5cbiAgICAgKi9cbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJ0eXBlXCJdID0gXCJ0eXBlXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiY2xhc3NcIl0gPSBcImNsYXNzXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiZW51bVwiXSA9IFwiZW51bVwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImludGVyZmFjZVwiXSA9IFwiaW50ZXJmYWNlXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wic3RydWN0XCJdID0gXCJzdHJ1Y3RcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJ0eXBlUGFyYW1ldGVyXCJdID0gXCJ0eXBlUGFyYW1ldGVyXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wicGFyYW1ldGVyXCJdID0gXCJwYXJhbWV0ZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJ2YXJpYWJsZVwiXSA9IFwidmFyaWFibGVcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJwcm9wZXJ0eVwiXSA9IFwicHJvcGVydHlcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJlbnVtTWVtYmVyXCJdID0gXCJlbnVtTWVtYmVyXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiZXZlbnRcIl0gPSBcImV2ZW50XCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiZnVuY3Rpb25cIl0gPSBcImZ1bmN0aW9uXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wibWV0aG9kXCJdID0gXCJtZXRob2RcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJtYWNyb1wiXSA9IFwibWFjcm9cIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJrZXl3b3JkXCJdID0gXCJrZXl3b3JkXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wibW9kaWZpZXJcIl0gPSBcIm1vZGlmaWVyXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiY29tbWVudFwiXSA9IFwiY29tbWVudFwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInN0cmluZ1wiXSA9IFwic3RyaW5nXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wibnVtYmVyXCJdID0gXCJudW1iZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJyZWdleHBcIl0gPSBcInJlZ2V4cFwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcIm9wZXJhdG9yXCJdID0gXCJvcGVyYXRvclwiO1xuICAgIC8qKlxuICAgICAqIEBzaW5jZSAzLjE3LjBcbiAgICAgKi9cbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJkZWNvcmF0b3JcIl0gPSBcImRlY29yYXRvclwiO1xufSkoU2VtYW50aWNUb2tlblR5cGVzIHx8IChTZW1hbnRpY1Rva2VuVHlwZXMgPSB7fSkpO1xuLyoqXG4gKiBBIHNldCBvZiBwcmVkZWZpbmVkIHRva2VuIG1vZGlmaWVycy4gVGhpcyBzZXQgaXMgbm90IGZpeGVkXG4gKiBhbiBjbGllbnRzIGNhbiBzcGVjaWZ5IGFkZGl0aW9uYWwgdG9rZW4gdHlwZXMgdmlhIHRoZVxuICogY29ycmVzcG9uZGluZyBjbGllbnQgY2FwYWJpbGl0aWVzLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFNlbWFudGljVG9rZW5Nb2RpZmllcnM7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5Nb2RpZmllcnMpIHtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiZGVjbGFyYXRpb25cIl0gPSBcImRlY2xhcmF0aW9uXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImRlZmluaXRpb25cIl0gPSBcImRlZmluaXRpb25cIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wicmVhZG9ubHlcIl0gPSBcInJlYWRvbmx5XCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcInN0YXRpY1wiXSA9IFwic3RhdGljXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImRlcHJlY2F0ZWRcIl0gPSBcImRlcHJlY2F0ZWRcIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiYWJzdHJhY3RcIl0gPSBcImFic3RyYWN0XCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImFzeW5jXCJdID0gXCJhc3luY1wiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJtb2RpZmljYXRpb25cIl0gPSBcIm1vZGlmaWNhdGlvblwiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJkb2N1bWVudGF0aW9uXCJdID0gXCJkb2N1bWVudGF0aW9uXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImRlZmF1bHRMaWJyYXJ5XCJdID0gXCJkZWZhdWx0TGlicmFyeVwiO1xufSkoU2VtYW50aWNUb2tlbk1vZGlmaWVycyB8fCAoU2VtYW50aWNUb2tlbk1vZGlmaWVycyA9IHt9KSk7XG4vKipcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFNlbWFudGljVG9rZW5zO1xuKGZ1bmN0aW9uIChTZW1hbnRpY1Rva2Vucykge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiAoY2FuZGlkYXRlLnJlc3VsdElkID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGNhbmRpZGF0ZS5yZXN1bHRJZCA9PT0gJ3N0cmluZycpICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGNhbmRpZGF0ZS5kYXRhKSAmJiAoY2FuZGlkYXRlLmRhdGEubGVuZ3RoID09PSAwIHx8IHR5cGVvZiBjYW5kaWRhdGUuZGF0YVswXSA9PT0gJ251bWJlcicpO1xuICAgIH1cbiAgICBTZW1hbnRpY1Rva2Vucy5pcyA9IGlzO1xufSkoU2VtYW50aWNUb2tlbnMgfHwgKFNlbWFudGljVG9rZW5zID0ge30pKTtcbi8qKlxuICogVGhlIElubGluZVZhbHVlVGV4dCBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBJbmxpbmVWYWx1ZVRleHRzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIElubGluZVZhbHVlVGV4dDtcbihmdW5jdGlvbiAoSW5saW5lVmFsdWVUZXh0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBJbmxpbmVWYWx1ZVRleHQgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLCB0ZXh0OiB0ZXh0IH07XG4gICAgfVxuICAgIElubGluZVZhbHVlVGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS50ZXh0KTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVUZXh0LmlzID0gaXM7XG59KShJbmxpbmVWYWx1ZVRleHQgfHwgKElubGluZVZhbHVlVGV4dCA9IHt9KSk7XG4vKipcbiAqIFRoZSBJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwIG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoIElubGluZVZhbHVlVmFyaWFibGVMb29rdXBzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIElubGluZVZhbHVlVmFyaWFibGVMb29rdXA7XG4oZnVuY3Rpb24gKElubGluZVZhbHVlVmFyaWFibGVMb29rdXApIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElubGluZVZhbHVlVGV4dCBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgdmFyaWFibGVOYW1lLCBjYXNlU2Vuc2l0aXZlTG9va3VwKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiByYW5nZSwgdmFyaWFibGVOYW1lOiB2YXJpYWJsZU5hbWUsIGNhc2VTZW5zaXRpdmVMb29rdXA6IGNhc2VTZW5zaXRpdmVMb29rdXAgfTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgSXMuYm9vbGVhbihjYW5kaWRhdGUuY2FzZVNlbnNpdGl2ZUxvb2t1cClcbiAgICAgICAgICAgICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLnZhcmlhYmxlTmFtZSkgfHwgY2FuZGlkYXRlLnZhcmlhYmxlTmFtZSA9PT0gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cC5pcyA9IGlzO1xufSkoSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cCB8fCAoSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cCA9IHt9KSk7XG4vKipcbiAqIFRoZSBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbiBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbi5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbjtcbihmdW5jdGlvbiAoSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBleHByZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiByYW5nZSwgZXhwcmVzc2lvbjogZXhwcmVzc2lvbiB9O1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSlcbiAgICAgICAgICAgICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLmV4cHJlc3Npb24pIHx8IGNhbmRpZGF0ZS5leHByZXNzaW9uID09PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbi5pcyA9IGlzO1xufSkoSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24gfHwgKElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uID0ge30pKTtcbi8qKlxuICogVGhlIElubGluZVZhbHVlQ29udGV4dCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBJbmxpbmVWYWx1ZUNvbnRleHR9IGxpdGVyYWxzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIElubGluZVZhbHVlQ29udGV4dDtcbihmdW5jdGlvbiAoSW5saW5lVmFsdWVDb250ZXh0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBJbmxpbmVWYWx1ZUNvbnRleHQgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUoZnJhbWVJZCwgc3RvcHBlZExvY2F0aW9uKSB7XG4gICAgICAgIHJldHVybiB7IGZyYW1lSWQ6IGZyYW1lSWQsIHN0b3BwZWRMb2NhdGlvbjogc3RvcHBlZExvY2F0aW9uIH07XG4gICAgfVxuICAgIElubGluZVZhbHVlQ29udGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBJbmxpbmVWYWx1ZUNvbnRleHR9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXModmFsdWUuc3RvcHBlZExvY2F0aW9uKTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVDb250ZXh0LmlzID0gaXM7XG59KShJbmxpbmVWYWx1ZUNvbnRleHQgfHwgKElubGluZVZhbHVlQ29udGV4dCA9IHt9KSk7XG4vKipcbiAqIElubGF5IGhpbnQga2luZHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5sYXlIaW50S2luZDtcbihmdW5jdGlvbiAoSW5sYXlIaW50S2luZCkge1xuICAgIC8qKlxuICAgICAqIEFuIGlubGF5IGhpbnQgdGhhdCBmb3IgYSB0eXBlIGFubm90YXRpb24uXG4gICAgICovXG4gICAgSW5sYXlIaW50S2luZC5UeXBlID0gMTtcbiAgICAvKipcbiAgICAgKiBBbiBpbmxheSBoaW50IHRoYXQgaXMgZm9yIGEgcGFyYW1ldGVyLlxuICAgICAqL1xuICAgIElubGF5SGludEtpbmQuUGFyYW1ldGVyID0gMjtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDEgfHwgdmFsdWUgPT09IDI7XG4gICAgfVxuICAgIElubGF5SGludEtpbmQuaXMgPSBpcztcbn0pKElubGF5SGludEtpbmQgfHwgKElubGF5SGludEtpbmQgPSB7fSkpO1xudmFyIElubGF5SGludExhYmVsUGFydDtcbihmdW5jdGlvbiAoSW5sYXlIaW50TGFiZWxQYXJ0KSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZSB9O1xuICAgIH1cbiAgICBJbmxheUhpbnRMYWJlbFBhcnQuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS50b29sdGlwID09PSB1bmRlZmluZWQgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS50b29sdGlwKSB8fCBNYXJrdXBDb250ZW50LmlzKGNhbmRpZGF0ZS50b29sdGlwKSlcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUubG9jYXRpb24gPT09IHVuZGVmaW5lZCB8fCBMb2NhdGlvbi5pcyhjYW5kaWRhdGUubG9jYXRpb24pKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5jb21tYW5kID09PSB1bmRlZmluZWQgfHwgQ29tbWFuZC5pcyhjYW5kaWRhdGUuY29tbWFuZCkpO1xuICAgIH1cbiAgICBJbmxheUhpbnRMYWJlbFBhcnQuaXMgPSBpcztcbn0pKElubGF5SGludExhYmVsUGFydCB8fCAoSW5sYXlIaW50TGFiZWxQYXJ0ID0ge30pKTtcbnZhciBJbmxheUhpbnQ7XG4oZnVuY3Rpb24gKElubGF5SGludCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwb3NpdGlvbiwgbGFiZWwsIGtpbmQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgcG9zaXRpb246IHBvc2l0aW9uLCBsYWJlbDogbGFiZWwgfTtcbiAgICAgICAgaWYgKGtpbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmtpbmQgPSBraW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIElubGF5SGludC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIFBvc2l0aW9uLmlzKGNhbmRpZGF0ZS5wb3NpdGlvbilcbiAgICAgICAgICAgICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLmxhYmVsKSB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5sYWJlbCwgSW5sYXlIaW50TGFiZWxQYXJ0LmlzKSlcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUua2luZCA9PT0gdW5kZWZpbmVkIHx8IElubGF5SGludEtpbmQuaXMoY2FuZGlkYXRlLmtpbmQpKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS50ZXh0RWRpdHMgPT09IHVuZGVmaW5lZCkgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUudGV4dEVkaXRzLCBUZXh0RWRpdC5pcylcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUudG9vbHRpcCA9PT0gdW5kZWZpbmVkIHx8IElzLnN0cmluZyhjYW5kaWRhdGUudG9vbHRpcCkgfHwgTWFya3VwQ29udGVudC5pcyhjYW5kaWRhdGUudG9vbHRpcCkpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnBhZGRpbmdMZWZ0ID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUucGFkZGluZ0xlZnQpKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5wYWRkaW5nUmlnaHQgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5wYWRkaW5nUmlnaHQpKTtcbiAgICB9XG4gICAgSW5sYXlIaW50LmlzID0gaXM7XG59KShJbmxheUhpbnQgfHwgKElubGF5SGludCA9IHt9KSk7XG52YXIgV29ya3NwYWNlRm9sZGVyO1xuKGZ1bmN0aW9uIChXb3Jrc3BhY2VGb2xkZXIpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgVVJJLmlzKGNhbmRpZGF0ZS51cmkpICYmIElzLnN0cmluZyhjYW5kaWRhdGUubmFtZSk7XG4gICAgfVxuICAgIFdvcmtzcGFjZUZvbGRlci5pcyA9IGlzO1xufSkoV29ya3NwYWNlRm9sZGVyIHx8IChXb3Jrc3BhY2VGb2xkZXIgPSB7fSkpO1xudmFyIEVPTCA9IFsnXFxuJywgJ1xcclxcbicsICdcXHInXTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIHRoZSB0ZXh0IGRvY3VtZW50IGZyb20gdGhlIG5ldyB2c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItdGV4dGRvY3VtZW50IHBhY2thZ2UuXG4gKi9cbnZhciBUZXh0RG9jdW1lbnQ7XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgSVRleHREb2N1bWVudCBsaXRlcmFsIGZyb20gdGhlIGdpdmVuIHVyaSBhbmQgY29udGVudC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBkb2N1bWVudCdzIHVyaS5cbiAgICAgKiBAcGFyYW0gbGFuZ3VhZ2VJZCBUaGUgZG9jdW1lbnQncyBsYW5ndWFnZSBJZC5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiBUaGUgZG9jdW1lbnQncyB2ZXJzaW9uLlxuICAgICAqIEBwYXJhbSBjb250ZW50IFRoZSBkb2N1bWVudCdzIGNvbnRlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCkge1xuICAgICAgICByZXR1cm4gbmV3IEZ1bGxUZXh0RG9jdW1lbnQodXJpLCBsYW5ndWFnZUlkLCB2ZXJzaW9uLCBjb250ZW50KTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIElUZXh0RG9jdW1lbnR9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmxhbmd1YWdlSWQpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUubGFuZ3VhZ2VJZCkpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5saW5lQ291bnQpXG4gICAgICAgICAgICAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5nZXRUZXh0KSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5wb3NpdGlvbkF0KSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5vZmZzZXRBdCkgPyB0cnVlIDogZmFsc2U7XG4gICAgfVxuICAgIFRleHREb2N1bWVudC5pcyA9IGlzO1xuICAgIGZ1bmN0aW9uIGFwcGx5RWRpdHMoZG9jdW1lbnQsIGVkaXRzKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gZG9jdW1lbnQuZ2V0VGV4dCgpO1xuICAgICAgICB2YXIgc29ydGVkRWRpdHMgPSBtZXJnZVNvcnQoZWRpdHMsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IGEucmFuZ2Uuc3RhcnQubGluZSAtIGIucmFuZ2Uuc3RhcnQubGluZTtcbiAgICAgICAgICAgIGlmIChkaWZmID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyIC0gYi5yYW5nZS5zdGFydC5jaGFyYWN0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsYXN0TW9kaWZpZWRPZmZzZXQgPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IHNvcnRlZEVkaXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgZSA9IHNvcnRlZEVkaXRzW2ldO1xuICAgICAgICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gZG9jdW1lbnQub2Zmc2V0QXQoZS5yYW5nZS5zdGFydCk7XG4gICAgICAgICAgICB2YXIgZW5kT2Zmc2V0ID0gZG9jdW1lbnQub2Zmc2V0QXQoZS5yYW5nZS5lbmQpO1xuICAgICAgICAgICAgaWYgKGVuZE9mZnNldCA8PSBsYXN0TW9kaWZpZWRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgc3RhcnRPZmZzZXQpICsgZS5uZXdUZXh0ICsgdGV4dC5zdWJzdHJpbmcoZW5kT2Zmc2V0LCB0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ092ZXJsYXBwaW5nIGVkaXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RNb2RpZmllZE9mZnNldCA9IHN0YXJ0T2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQuYXBwbHlFZGl0cyA9IGFwcGx5RWRpdHM7XG4gICAgZnVuY3Rpb24gbWVyZ2VTb3J0KGRhdGEsIGNvbXBhcmUpIHtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgIC8vIHNvcnRlZFxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHAgPSAoZGF0YS5sZW5ndGggLyAyKSB8IDA7XG4gICAgICAgIHZhciBsZWZ0ID0gZGF0YS5zbGljZSgwLCBwKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gZGF0YS5zbGljZShwKTtcbiAgICAgICAgbWVyZ2VTb3J0KGxlZnQsIGNvbXBhcmUpO1xuICAgICAgICBtZXJnZVNvcnQocmlnaHQsIGNvbXBhcmUpO1xuICAgICAgICB2YXIgbGVmdElkeCA9IDA7XG4gICAgICAgIHZhciByaWdodElkeCA9IDA7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGxlZnRJZHggPCBsZWZ0Lmxlbmd0aCAmJiByaWdodElkeCA8IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHJldCA9IGNvbXBhcmUobGVmdFtsZWZ0SWR4XSwgcmlnaHRbcmlnaHRJZHhdKTtcbiAgICAgICAgICAgIGlmIChyZXQgPD0gMCkge1xuICAgICAgICAgICAgICAgIC8vIHNtYWxsZXJfZXF1YWwgLT4gdGFrZSBsZWZ0IHRvIHByZXNlcnZlIG9yZGVyXG4gICAgICAgICAgICAgICAgZGF0YVtpKytdID0gbGVmdFtsZWZ0SWR4KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZ3JlYXRlciAtPiB0YWtlIHJpZ2h0XG4gICAgICAgICAgICAgICAgZGF0YVtpKytdID0gcmlnaHRbcmlnaHRJZHgrK107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGxlZnRJZHggPCBsZWZ0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZGF0YVtpKytdID0gbGVmdFtsZWZ0SWR4KytdO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChyaWdodElkeCA8IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZGF0YVtpKytdID0gcmlnaHRbcmlnaHRJZHgrK107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxufSkoVGV4dERvY3VtZW50IHx8IChUZXh0RG9jdW1lbnQgPSB7fSkpO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgdGhlIHRleHQgZG9jdW1lbnQgZnJvbSB0aGUgbmV3IHZzY29kZS1sYW5ndWFnZXNlcnZlci10ZXh0ZG9jdW1lbnQgcGFja2FnZS5cbiAqL1xudmFyIEZ1bGxUZXh0RG9jdW1lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRnVsbFRleHREb2N1bWVudCh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5fdXJpID0gdXJpO1xuICAgICAgICB0aGlzLl9sYW5ndWFnZUlkID0gbGFuZ3VhZ2VJZDtcbiAgICAgICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLCBcInVyaVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VyaTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZSwgXCJsYW5ndWFnZUlkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGFuZ3VhZ2VJZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZSwgXCJ2ZXJzaW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLmdldFRleHQgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLmVuZCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7XG4gICAgfTtcbiAgICBGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZXZlbnQsIHZlcnNpb24pIHtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGV2ZW50LnRleHQ7XG4gICAgICAgIHRoaXMuX3ZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLmdldExpbmVPZmZzZXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbGluZU9mZnNldHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGxpbmVPZmZzZXRzID0gW107XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuX2NvbnRlbnQ7XG4gICAgICAgICAgICB2YXIgaXNMaW5lU3RhcnQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGluZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVPZmZzZXRzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgIGlzTGluZVN0YXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjaCA9IHRleHQuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGlzTGluZVN0YXJ0ID0gKGNoID09PSAnXFxyJyB8fCBjaCA9PT0gJ1xcbicpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgaSArIDEgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0LmNoYXJBdChpICsgMSkgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNMaW5lU3RhcnQgJiYgdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGluZU9mZnNldHMucHVzaCh0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IGxpbmVPZmZzZXRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lT2Zmc2V0cztcbiAgICB9O1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLnBvc2l0aW9uQXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IE1hdGgubWF4KE1hdGgubWluKG9mZnNldCwgdGhpcy5fY29udGVudC5sZW5ndGgpLCAwKTtcbiAgICAgICAgdmFyIGxpbmVPZmZzZXRzID0gdGhpcy5nZXRMaW5lT2Zmc2V0cygpO1xuICAgICAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGxpbmVPZmZzZXRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGhpZ2ggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBQb3NpdGlvbi5jcmVhdGUoMCwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICAgICAgICBpZiAobGluZU9mZnNldHNbbWlkXSA+IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGxvdyBpcyB0aGUgbGVhc3QgeCBmb3Igd2hpY2ggdGhlIGxpbmUgb2Zmc2V0IGlzIGxhcmdlciB0aGFuIHRoZSBjdXJyZW50IG9mZnNldFxuICAgICAgICAvLyBvciBhcnJheS5sZW5ndGggaWYgbm8gbGluZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gdGhlIGN1cnJlbnQgb2Zmc2V0XG4gICAgICAgIHZhciBsaW5lID0gbG93IC0gMTtcbiAgICAgICAgcmV0dXJuIFBvc2l0aW9uLmNyZWF0ZShsaW5lLCBvZmZzZXQgLSBsaW5lT2Zmc2V0c1tsaW5lXSk7XG4gICAgfTtcbiAgICBGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZS5vZmZzZXRBdCA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICB2YXIgbGluZU9mZnNldHMgPSB0aGlzLmdldExpbmVPZmZzZXRzKCk7XG4gICAgICAgIGlmIChwb3NpdGlvbi5saW5lID49IGxpbmVPZmZzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvc2l0aW9uLmxpbmUgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGluZU9mZnNldCA9IGxpbmVPZmZzZXRzW3Bvc2l0aW9uLmxpbmVdO1xuICAgICAgICB2YXIgbmV4dExpbmVPZmZzZXQgPSAocG9zaXRpb24ubGluZSArIDEgPCBsaW5lT2Zmc2V0cy5sZW5ndGgpID8gbGluZU9mZnNldHNbcG9zaXRpb24ubGluZSArIDFdIDogdGhpcy5fY29udGVudC5sZW5ndGg7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihsaW5lT2Zmc2V0ICsgcG9zaXRpb24uY2hhcmFjdGVyLCBuZXh0TGluZU9mZnNldCksIGxpbmVPZmZzZXQpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLCBcImxpbmVDb3VudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGluZU9mZnNldHMoKS5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gRnVsbFRleHREb2N1bWVudDtcbn0oKSk7XG52YXIgSXM7XG4oZnVuY3Rpb24gKElzKSB7XG4gICAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgICBmdW5jdGlvbiBkZWZpbmVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xuICAgIH1cbiAgICBJcy5kZWZpbmVkID0gZGVmaW5lZDtcbiAgICBmdW5jdGlvbiB1bmRlZmluZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuICAgIElzLnVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICBmdW5jdGlvbiBib29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2U7XG4gICAgfVxuICAgIElzLmJvb2xlYW4gPSBib29sZWFuO1xuICAgIGZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuICAgIH1cbiAgICBJcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgZnVuY3Rpb24gbnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG4gICAgfVxuICAgIElzLm51bWJlciA9IG51bWJlcjtcbiAgICBmdW5jdGlvbiBudW1iZXJSYW5nZSh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJiBtaW4gPD0gdmFsdWUgJiYgdmFsdWUgPD0gbWF4O1xuICAgIH1cbiAgICBJcy5udW1iZXJSYW5nZSA9IG51bWJlclJhbmdlO1xuICAgIGZ1bmN0aW9uIGludGVnZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJiAtMjE0NzQ4MzY0OCA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSAyMTQ3NDgzNjQ3O1xuICAgIH1cbiAgICBJcy5pbnRlZ2VyID0gaW50ZWdlcjtcbiAgICBmdW5jdGlvbiB1aW50ZWdlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmIDAgPD0gdmFsdWUgJiYgdmFsdWUgPD0gMjE0NzQ4MzY0NztcbiAgICB9XG4gICAgSXMudWludGVnZXIgPSB1aW50ZWdlcjtcbiAgICBmdW5jdGlvbiBmdW5jKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9XG4gICAgSXMuZnVuYyA9IGZ1bmM7XG4gICAgZnVuY3Rpb24gb2JqZWN0TGl0ZXJhbCh2YWx1ZSkge1xuICAgICAgICAvLyBTdHJpY3RseSBzcGVha2luZyBjbGFzcyBpbnN0YW5jZXMgcGFzcyB0aGlzIGNoZWNrIGFzIHdlbGwuIFNpbmNlIHRoZSBMU1BcbiAgICAgICAgLy8gZG9lc24ndCB1c2UgY2xhc3NlcyB3ZSBpZ25vcmUgdGhpcyBmb3Igbm93LiBJZiB3ZSBkbyB3ZSBuZWVkIHRvIGFkZCBzb21ldGhpbmdcbiAgICAgICAgLy8gbGlrZSB0aGlzOiBgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZih4KSkgPT09IG51bGxgXG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xuICAgIH1cbiAgICBJcy5vYmplY3RMaXRlcmFsID0gb2JqZWN0TGl0ZXJhbDtcbiAgICBmdW5jdGlvbiB0eXBlZEFycmF5KHZhbHVlLCBjaGVjaykge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoY2hlY2spO1xuICAgIH1cbiAgICBJcy50eXBlZEFycmF5ID0gdHlwZWRBcnJheTtcbn0pKElzIHx8IChJcyA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDIwMzI6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uID0gZXhwb3J0cy5Ccm93c2VyTWVzc2FnZVdyaXRlciA9IGV4cG9ydHMuQnJvd3Nlck1lc3NhZ2VSZWFkZXIgPSB2b2lkIDA7XG5jb25zdCByaWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjgxMik7XG4vLyBJbnN0YWxsIHRoZSBicm93c2VyIHJ1bnRpbWUgYWJzdHJhY3QuXG5yaWxfMS5kZWZhdWx0Lmluc3RhbGwoKTtcbmNvbnN0IGFwaV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MjIzKTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDgyMjMpLCBleHBvcnRzKTtcbmNsYXNzIEJyb3dzZXJNZXNzYWdlUmVhZGVyIGV4dGVuZHMgYXBpXzEuQWJzdHJhY3RNZXNzYWdlUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX29uRGF0YSA9IG5ldyBhcGlfMS5FbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VMaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fb25EYXRhLmZpcmUoZXZlbnQuZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnRleHQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXZlbnQpID0+IHRoaXMuZmlyZUVycm9yKGV2ZW50KSk7XG4gICAgICAgIGNvbnRleHQub25tZXNzYWdlID0gdGhpcy5fbWVzc2FnZUxpc3RlbmVyO1xuICAgIH1cbiAgICBsaXN0ZW4oY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uRGF0YS5ldmVudChjYWxsYmFjayk7XG4gICAgfVxufVxuZXhwb3J0cy5Ccm93c2VyTWVzc2FnZVJlYWRlciA9IEJyb3dzZXJNZXNzYWdlUmVhZGVyO1xuY2xhc3MgQnJvd3Nlck1lc3NhZ2VXcml0ZXIgZXh0ZW5kcyBhcGlfMS5BYnN0cmFjdE1lc3NhZ2VXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5lcnJvckNvdW50ID0gMDtcbiAgICAgICAgY29udGV4dC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIChldmVudCkgPT4gdGhpcy5maXJlRXJyb3IoZXZlbnQpKTtcbiAgICB9XG4gICAgd3JpdGUobXNnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQucG9zdE1lc3NhZ2UobXNnKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IsIG1zZyk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUVycm9yKGVycm9yLCBtc2cpIHtcbiAgICAgICAgdGhpcy5lcnJvckNvdW50Kys7XG4gICAgICAgIHRoaXMuZmlyZUVycm9yKGVycm9yLCBtc2csIHRoaXMuZXJyb3JDb3VudCk7XG4gICAgfVxuICAgIGVuZCgpIHtcbiAgICB9XG59XG5leHBvcnRzLkJyb3dzZXJNZXNzYWdlV3JpdGVyID0gQnJvd3Nlck1lc3NhZ2VXcml0ZXI7XG5mdW5jdGlvbiBjcmVhdGVNZXNzYWdlQ29ubmVjdGlvbihyZWFkZXIsIHdyaXRlciwgbG9nZ2VyLCBvcHRpb25zKSB7XG4gICAgaWYgKGxvZ2dlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvZ2dlciA9IGFwaV8xLk51bGxMb2dnZXI7XG4gICAgfVxuICAgIGlmIChhcGlfMS5Db25uZWN0aW9uU3RyYXRlZ3kuaXMob3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsgY29ubmVjdGlvblN0cmF0ZWd5OiBvcHRpb25zIH07XG4gICAgfVxuICAgIHJldHVybiAoMCwgYXBpXzEuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24pKHJlYWRlciwgd3JpdGVyLCBsb2dnZXIsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiA9IGNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFpbi5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIDI4MTI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgY29uc29sZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzcxNik7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuY29uc3QgcmFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0MDYpO1xuY29uc3QgZGlzcG9zYWJsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MjUwKTtcbmNvbnN0IGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MjU3KTtcbmNvbnN0IG1lc3NhZ2VCdWZmZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTk0Nyk7XG5jbGFzcyBNZXNzYWdlQnVmZmVyIGV4dGVuZHMgbWVzc2FnZUJ1ZmZlcl8xLkFic3RyYWN0TWVzc2FnZUJ1ZmZlciB7XG4gICAgY29uc3RydWN0b3IoZW5jb2RpbmcgPSAndXRmLTgnKSB7XG4gICAgICAgIHN1cGVyKGVuY29kaW5nKTtcbiAgICAgICAgdGhpcy5hc2NpaURlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ2FzY2lpJyk7XG4gICAgfVxuICAgIGVtcHR5QnVmZmVyKCkge1xuICAgICAgICByZXR1cm4gTWVzc2FnZUJ1ZmZlci5lbXB0eUJ1ZmZlcjtcbiAgICB9XG4gICAgZnJvbVN0cmluZyh2YWx1ZSwgX2VuY29kaW5nKSB7XG4gICAgICAgIHJldHVybiAobmV3IFRleHRFbmNvZGVyKCkpLmVuY29kZSh2YWx1ZSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKHZhbHVlLCBlbmNvZGluZykge1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdhc2NpaScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFzY2lpRGVjb2Rlci5kZWNvZGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChuZXcgVGV4dERlY29kZXIoZW5jb2RpbmcpKS5kZWNvZGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzTmF0aXZlKGJ1ZmZlciwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhbGxvY05hdGl2ZShsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgfVxufVxuTWVzc2FnZUJ1ZmZlci5lbXB0eUJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDApO1xuY2xhc3MgUmVhZGFibGVTdHJlYW1XcmFwcGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihzb2NrZXQpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQgPSBzb2NrZXQ7XG4gICAgICAgIHRoaXMuX29uRGF0YSA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VMaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYmxvYiA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBibG9iLmFycmF5QnVmZmVyKCkudGhlbigoYnVmZmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25EYXRhLmZpcmUobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSk7XG4gICAgICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgKDAsIHJhbF8xLmRlZmF1bHQpKCkuY29uc29sZS5lcnJvcihgQ29udmVydGluZyBibG9iIHRvIGFycmF5IGJ1ZmZlciBmYWlsZWQuYCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuX21lc3NhZ2VMaXN0ZW5lcik7XG4gICAgfVxuICAgIG9uQ2xvc2UobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBkaXNwb3NhYmxlXzEuRGlzcG9zYWJsZS5jcmVhdGUoKCkgPT4gdGhpcy5zb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBsaXN0ZW5lcikpO1xuICAgIH1cbiAgICBvbkVycm9yKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gZGlzcG9zYWJsZV8xLkRpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHRoaXMuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgb25FbmQobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZW5kJywgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gZGlzcG9zYWJsZV8xLkRpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHRoaXMuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZCcsIGxpc3RlbmVyKSk7XG4gICAgfVxuICAgIG9uRGF0YShsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fb25EYXRhLmV2ZW50KGxpc3RlbmVyKTtcbiAgICB9XG59XG5jbGFzcyBXcml0YWJsZVN0cmVhbVdyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKHNvY2tldCkge1xuICAgICAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgICB9XG4gICAgb25DbG9zZShsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVfMS5EaXNwb3NhYmxlLmNyZWF0ZSgoKSA9PiB0aGlzLnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbG9zZScsIGxpc3RlbmVyKSk7XG4gICAgfVxuICAgIG9uRXJyb3IobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBkaXNwb3NhYmxlXzEuRGlzcG9zYWJsZS5jcmVhdGUoKCkgPT4gdGhpcy5zb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBsaXN0ZW5lcikpO1xuICAgIH1cbiAgICBvbkVuZChsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdlbmQnLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBkaXNwb3NhYmxlXzEuRGlzcG9zYWJsZS5jcmVhdGUoKCkgPT4gdGhpcy5zb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgd3JpdGUoZGF0YSwgZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgZW5jb2RpbmcgIT09ICd1dGYtOCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluIGEgQnJvd3NlciBlbnZpcm9ubWVudHMgb25seSB1dGYtOCB0ZXh0IGVuY29kaW5nIGlzIHN1cHBvcnRlZC4gQnV0IGdvdCBlbmNvZGluZzogJHtlbmNvZGluZ31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5zZW5kKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZW5kKCkge1xuICAgICAgICB0aGlzLnNvY2tldC5jbG9zZSgpO1xuICAgIH1cbn1cbmNvbnN0IF90ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgX3JpbCA9IE9iamVjdC5mcmVlemUoe1xuICAgIG1lc3NhZ2VCdWZmZXI6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBjcmVhdGU6IChlbmNvZGluZykgPT4gbmV3IE1lc3NhZ2VCdWZmZXIoZW5jb2RpbmcpXG4gICAgfSksXG4gICAgYXBwbGljYXRpb25Kc29uOiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgZW5jb2RlcjogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICBuYW1lOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICBlbmNvZGU6IChtc2csIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jaGFyc2V0ICE9PSAndXRmLTgnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW4gYSBCcm93c2VyIGVudmlyb25tZW50cyBvbmx5IHV0Zi04IHRleHQgZW5jb2RpbmcgaXMgc3VwcG9ydGVkLiBCdXQgZ290IGVuY29kaW5nOiAke29wdGlvbnMuY2hhcnNldH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShfdGV4dEVuY29kZXIuZW5jb2RlKEpTT04uc3RyaW5naWZ5KG1zZywgdW5kZWZpbmVkLCAwKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgZGVjb2RlcjogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICBuYW1lOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICBkZWNvZGU6IChidWZmZXIsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIShidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluIGEgQnJvd3NlciBlbnZpcm9ubWVudHMgb25seSBVaW50OEFycmF5cyBhcmUgc3VwcG9ydGVkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKEpTT04ucGFyc2UobmV3IFRleHREZWNvZGVyKG9wdGlvbnMuY2hhcnNldCkuZGVjb2RlKGJ1ZmZlcikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9KSxcbiAgICBzdHJlYW06IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBhc1JlYWRhYmxlU3RyZWFtOiAoc29ja2V0KSA9PiBuZXcgUmVhZGFibGVTdHJlYW1XcmFwcGVyKHNvY2tldCksXG4gICAgICAgIGFzV3JpdGFibGVTdHJlYW06IChzb2NrZXQpID0+IG5ldyBXcml0YWJsZVN0cmVhbVdyYXBwZXIoc29ja2V0KVxuICAgIH0pLFxuICAgIGNvbnNvbGU6IGNvbnNvbGUsXG4gICAgdGltZXI6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCBtcywgLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dChjYWxsYmFjaywgbXMsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZGlzcG9zZTogKCkgPT4gY2xlYXJUaW1lb3V0KGhhbmRsZSkgfTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KGNhbGxiYWNrLCAwLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB7IGRpc3Bvc2U6ICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpIH07XG4gICAgICAgIH0sXG4gICAgICAgIHNldEludGVydmFsKGNhbGxiYWNrLCBtcywgLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0SW50ZXJ2YWwoY2FsbGJhY2ssIG1zLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB7IGRpc3Bvc2U6ICgpID0+IGNsZWFySW50ZXJ2YWwoaGFuZGxlKSB9O1xuICAgICAgICB9LFxuICAgIH0pXG59KTtcbmZ1bmN0aW9uIFJJTCgpIHtcbiAgICByZXR1cm4gX3JpbDtcbn1cbihmdW5jdGlvbiAoUklMKSB7XG4gICAgZnVuY3Rpb24gaW5zdGFsbCgpIHtcbiAgICAgICAgcmFsXzEuZGVmYXVsdC5pbnN0YWxsKF9yaWwpO1xuICAgIH1cbiAgICBSSUwuaW5zdGFsbCA9IGluc3RhbGw7XG59KShSSUwgfHwgKFJJTCA9IHt9KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFJJTDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJpbC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIDgyMjM6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vLi4vdHlwaW5ncy90aGVuYWJsZS5kLnRzXCIgLz5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5UcmFjZUZvcm1hdCA9IGV4cG9ydHMuVHJhY2VWYWx1ZXMgPSBleHBvcnRzLlRyYWNlID0gZXhwb3J0cy5Qcm9ncmVzc1R5cGUgPSBleHBvcnRzLlByb2dyZXNzVG9rZW4gPSBleHBvcnRzLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uID0gZXhwb3J0cy5OdWxsTG9nZ2VyID0gZXhwb3J0cy5Db25uZWN0aW9uT3B0aW9ucyA9IGV4cG9ydHMuQ29ubmVjdGlvblN0cmF0ZWd5ID0gZXhwb3J0cy5Xcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyID0gZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLk1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLlJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlciA9IGV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5NZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlbiA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UgPSBleHBvcnRzLkVtaXR0ZXIgPSBleHBvcnRzLkV2ZW50ID0gZXhwb3J0cy5EaXNwb3NhYmxlID0gZXhwb3J0cy5MUlVDYWNoZSA9IGV4cG9ydHMuVG91Y2ggPSBleHBvcnRzLkxpbmtlZE1hcCA9IGV4cG9ydHMuUGFyYW1ldGVyU3RydWN0dXJlcyA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTkgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU4ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNyA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTYgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU1ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNCA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTMgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUyID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTAgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUgPSBleHBvcnRzLkVycm9yQ29kZXMgPSBleHBvcnRzLlJlc3BvbnNlRXJyb3IgPSBleHBvcnRzLlJlcXVlc3RUeXBlOSA9IGV4cG9ydHMuUmVxdWVzdFR5cGU4ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTcgPSBleHBvcnRzLlJlcXVlc3RUeXBlNiA9IGV4cG9ydHMuUmVxdWVzdFR5cGU1ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTQgPSBleHBvcnRzLlJlcXVlc3RUeXBlMyA9IGV4cG9ydHMuUmVxdWVzdFR5cGUyID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTEgPSBleHBvcnRzLlJlcXVlc3RUeXBlMCA9IGV4cG9ydHMuUmVxdWVzdFR5cGUgPSBleHBvcnRzLk1lc3NhZ2UgPSBleHBvcnRzLlJBTCA9IHZvaWQgMDtcbmV4cG9ydHMuQ2FuY2VsbGF0aW9uU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0gZXhwb3J0cy5Db25uZWN0aW9uRXJyb3IgPSBleHBvcnRzLkNvbm5lY3Rpb25FcnJvcnMgPSBleHBvcnRzLkxvZ1RyYWNlTm90aWZpY2F0aW9uID0gZXhwb3J0cy5TZXRUcmFjZU5vdGlmaWNhdGlvbiA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2MTMpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWVzc2FnZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTWVzc2FnZTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXF1ZXN0VHlwZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGUwXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTA7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGUxXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTE7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGUyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTI7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGUzXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTM7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGU0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGU1XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGU2XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTY7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGU3XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTc7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGU4XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTg7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGU5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTk7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVzcG9uc2VFcnJvclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFcnJvckNvZGVzXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5FcnJvckNvZGVzOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTBcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUwOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGUxXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlMTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlMlwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTI7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTNcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUzOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGU0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlNDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlNVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTZcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU2OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGU3XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlNzsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlOFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTg7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTlcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBhcmFtZXRlclN0cnVjdHVyZXNcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXM7IH0gfSkpO1xuY29uc3QgbGlua2VkTWFwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MTQpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTGlua2VkTWFwXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGlua2VkTWFwXzEuTGlua2VkTWFwOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxSVUNhY2hlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGlua2VkTWFwXzEuTFJVQ2FjaGU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVG91Y2hcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaW5rZWRNYXBfMS5Ub3VjaDsgfSB9KSk7XG5jb25zdCBkaXNwb3NhYmxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyNTApO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlzcG9zYWJsZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpc3Bvc2FibGVfMS5EaXNwb3NhYmxlOyB9IH0pKTtcbmNvbnN0IGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MjU3KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV2ZW50XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXZlbnRzXzEuRXZlbnQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRW1pdHRlclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV2ZW50c18xLkVtaXR0ZXI7IH0gfSkpO1xuY29uc3QgY2FuY2VsbGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNzIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2VcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYW5jZWxsYXRpb25fMS5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYW5jZWxsYXRpb25Ub2tlblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbmNlbGxhdGlvbl8xLkNhbmNlbGxhdGlvblRva2VuOyB9IH0pKTtcbmNvbnN0IG1lc3NhZ2VSZWFkZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjA3KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lc3NhZ2VSZWFkZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlUmVhZGVyXzEuTWVzc2FnZVJlYWRlcjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBYnN0cmFjdE1lc3NhZ2VSZWFkZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlUmVhZGVyXzEuQWJzdHJhY3RNZXNzYWdlUmVhZGVyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VSZWFkZXJfMS5SZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXI7IH0gfSkpO1xuY29uc3QgbWVzc2FnZVdyaXRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MjE0KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lc3NhZ2VXcml0ZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlV3JpdGVyXzEuTWVzc2FnZVdyaXRlcjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBYnN0cmFjdE1lc3NhZ2VXcml0ZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlV3JpdGVyXzEuQWJzdHJhY3RNZXNzYWdlV3JpdGVyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldyaXRlYWJsZVN0cmVhbU1lc3NhZ2VXcml0ZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlV3JpdGVyXzEuV3JpdGVhYmxlU3RyZWFtTWVzc2FnZVdyaXRlcjsgfSB9KSk7XG5jb25zdCBjb25uZWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwNzUpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29ubmVjdGlvblN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNvbm5lY3Rpb25TdHJhdGVneTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb25uZWN0aW9uT3B0aW9uc1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Db25uZWN0aW9uT3B0aW9uczsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOdWxsTG9nZ2VyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLk51bGxMb2dnZXI7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb247IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUHJvZ3Jlc3NUb2tlblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Qcm9ncmVzc1Rva2VuOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlByb2dyZXNzVHlwZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Qcm9ncmVzc1R5cGU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhY2VcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuVHJhY2U7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhY2VWYWx1ZXNcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuVHJhY2VWYWx1ZXM7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhY2VGb3JtYXRcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuVHJhY2VGb3JtYXQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2V0VHJhY2VOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuU2V0VHJhY2VOb3RpZmljYXRpb247IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTG9nVHJhY2VOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuTG9nVHJhY2VOb3RpZmljYXRpb247IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29ubmVjdGlvbkVycm9yc1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Db25uZWN0aW9uRXJyb3JzOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbm5lY3Rpb25FcnJvclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Db25uZWN0aW9uRXJyb3I7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5DYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbmNlbGxhdGlvblN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNhbmNlbGxhdGlvblN0cmF0ZWd5OyB9IH0pKTtcbmNvbnN0IHJhbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NDA2KTtcbmV4cG9ydHMuUkFMID0gcmFsXzEuZGVmYXVsdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwaS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIDEwNzI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW4gPSB2b2lkIDA7XG5jb25zdCByYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTQwNik7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTI3OCk7XG5jb25zdCBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzI1Nyk7XG52YXIgQ2FuY2VsbGF0aW9uVG9rZW47XG4oZnVuY3Rpb24gKENhbmNlbGxhdGlvblRva2VuKSB7XG4gICAgQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBpc0NhbmNlbGxhdGlvblJlcXVlc3RlZDogZmFsc2UsXG4gICAgICAgIG9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkOiBldmVudHNfMS5FdmVudC5Ob25lXG4gICAgfSk7XG4gICAgQ2FuY2VsbGF0aW9uVG9rZW4uQ2FuY2VsbGVkID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIGlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkOiB0cnVlLFxuICAgICAgICBvbkNhbmNlbGxhdGlvblJlcXVlc3RlZDogZXZlbnRzXzEuRXZlbnQuTm9uZVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIChjYW5kaWRhdGUgPT09IENhbmNlbGxhdGlvblRva2VuLk5vbmVcbiAgICAgICAgICAgIHx8IGNhbmRpZGF0ZSA9PT0gQ2FuY2VsbGF0aW9uVG9rZW4uQ2FuY2VsbGVkXG4gICAgICAgICAgICB8fCAoSXMuYm9vbGVhbihjYW5kaWRhdGUuaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQpICYmICEhY2FuZGlkYXRlLm9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKSk7XG4gICAgfVxuICAgIENhbmNlbGxhdGlvblRva2VuLmlzID0gaXM7XG59KShDYW5jZWxsYXRpb25Ub2tlbiA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW4gfHwgKGV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW4gPSB7fSkpO1xuY29uc3Qgc2hvcnRjdXRFdmVudCA9IE9iamVjdC5mcmVlemUoZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgY29uc3QgaGFuZGxlID0gKDAsIHJhbF8xLmRlZmF1bHQpKCkudGltZXIuc2V0VGltZW91dChjYWxsYmFjay5iaW5kKGNvbnRleHQpLCAwKTtcbiAgICByZXR1cm4geyBkaXNwb3NlKCkgeyBoYW5kbGUuZGlzcG9zZSgpOyB9IH07XG59KTtcbmNsYXNzIE11dGFibGVUb2tlbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0NhbmNlbGxlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0NhbmNlbGxlZDtcbiAgICB9XG4gICAgZ2V0IG9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCkge1xuICAgICAgICBpZiAodGhpcy5faXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzaG9ydGN1dEV2ZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZW1pdHRlcikge1xuICAgICAgICAgICAgdGhpcy5fZW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9lbWl0dGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2VtaXR0ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSB7XG4gICAgZ2V0IHRva2VuKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Rva2VuKSB7XG4gICAgICAgICAgICAvLyBiZSBsYXp5IGFuZCBjcmVhdGUgdGhlIHRva2VuIG9ubHkgd2hlblxuICAgICAgICAgICAgLy8gYWN0dWFsbHkgbmVlZGVkXG4gICAgICAgICAgICB0aGlzLl90b2tlbiA9IG5ldyBNdXRhYmxlVG9rZW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW47XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90b2tlbikge1xuICAgICAgICAgICAgLy8gc2F2ZSBhbiBvYmplY3QgYnkgcmV0dXJuaW5nIHRoZSBkZWZhdWx0XG4gICAgICAgICAgICAvLyBjYW5jZWxsZWQgdG9rZW4gd2hlbiBjYW5jZWxsYXRpb24gaGFwcGVuc1xuICAgICAgICAgICAgLy8gYmVmb3JlIHNvbWVvbmUgYXNrcyBmb3IgdGhlIHRva2VuXG4gICAgICAgICAgICB0aGlzLl90b2tlbiA9IENhbmNlbGxhdGlvblRva2VuLkNhbmNlbGxlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdG9rZW4pIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSB0byBpbml0aWFsaXplIHdpdGggYW4gZW1wdHkgdG9rZW4gaWYgd2UgaGFkIG5vbmVcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl90b2tlbiBpbnN0YW5jZW9mIE11dGFibGVUb2tlbikge1xuICAgICAgICAgICAgLy8gYWN0dWFsbHkgZGlzcG9zZVxuICAgICAgICAgICAgdGhpcy5fdG9rZW4uZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSA9IENhbmNlbGxhdGlvblRva2VuU291cmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FuY2VsbGF0aW9uLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzA3NTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiA9IGV4cG9ydHMuQ29ubmVjdGlvbk9wdGlvbnMgPSBleHBvcnRzLkNhbmNlbGxhdGlvblN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSA9IGV4cG9ydHMuQ29ubmVjdGlvblN0cmF0ZWd5ID0gZXhwb3J0cy5Db25uZWN0aW9uRXJyb3IgPSBleHBvcnRzLkNvbm5lY3Rpb25FcnJvcnMgPSBleHBvcnRzLkxvZ1RyYWNlTm90aWZpY2F0aW9uID0gZXhwb3J0cy5TZXRUcmFjZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuVHJhY2VGb3JtYXQgPSBleHBvcnRzLlRyYWNlVmFsdWVzID0gZXhwb3J0cy5UcmFjZSA9IGV4cG9ydHMuTnVsbExvZ2dlciA9IGV4cG9ydHMuUHJvZ3Jlc3NUeXBlID0gZXhwb3J0cy5Qcm9ncmVzc1Rva2VuID0gdm9pZCAwO1xuY29uc3QgcmFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0MDYpO1xuY29uc3QgSXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNzgpO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTYxMyk7XG5jb25zdCBsaW5rZWRNYXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQxNCk7XG5jb25zdCBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzI1Nyk7XG5jb25zdCBjYW5jZWxsYXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTA3Mik7XG52YXIgQ2FuY2VsTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChDYW5jZWxOb3RpZmljYXRpb24pIHtcbiAgICBDYW5jZWxOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUoJyQvY2FuY2VsUmVxdWVzdCcpO1xufSkoQ2FuY2VsTm90aWZpY2F0aW9uIHx8IChDYW5jZWxOb3RpZmljYXRpb24gPSB7fSkpO1xudmFyIFByb2dyZXNzVG9rZW47XG4oZnVuY3Rpb24gKFByb2dyZXNzVG9rZW4pIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xuICAgIH1cbiAgICBQcm9ncmVzc1Rva2VuLmlzID0gaXM7XG59KShQcm9ncmVzc1Rva2VuID0gZXhwb3J0cy5Qcm9ncmVzc1Rva2VuIHx8IChleHBvcnRzLlByb2dyZXNzVG9rZW4gPSB7fSkpO1xudmFyIFByb2dyZXNzTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChQcm9ncmVzc05vdGlmaWNhdGlvbikge1xuICAgIFByb2dyZXNzTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlKCckL3Byb2dyZXNzJyk7XG59KShQcm9ncmVzc05vdGlmaWNhdGlvbiB8fCAoUHJvZ3Jlc3NOb3RpZmljYXRpb24gPSB7fSkpO1xuY2xhc3MgUHJvZ3Jlc3NUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICB9XG59XG5leHBvcnRzLlByb2dyZXNzVHlwZSA9IFByb2dyZXNzVHlwZTtcbnZhciBTdGFyUmVxdWVzdEhhbmRsZXI7XG4oZnVuY3Rpb24gKFN0YXJSZXF1ZXN0SGFuZGxlcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBJcy5mdW5jKHZhbHVlKTtcbiAgICB9XG4gICAgU3RhclJlcXVlc3RIYW5kbGVyLmlzID0gaXM7XG59KShTdGFyUmVxdWVzdEhhbmRsZXIgfHwgKFN0YXJSZXF1ZXN0SGFuZGxlciA9IHt9KSk7XG5leHBvcnRzLk51bGxMb2dnZXIgPSBPYmplY3QuZnJlZXplKHtcbiAgICBlcnJvcjogKCkgPT4geyB9LFxuICAgIHdhcm46ICgpID0+IHsgfSxcbiAgICBpbmZvOiAoKSA9PiB7IH0sXG4gICAgbG9nOiAoKSA9PiB7IH1cbn0pO1xudmFyIFRyYWNlO1xuKGZ1bmN0aW9uIChUcmFjZSkge1xuICAgIFRyYWNlW1RyYWNlW1wiT2ZmXCJdID0gMF0gPSBcIk9mZlwiO1xuICAgIFRyYWNlW1RyYWNlW1wiTWVzc2FnZXNcIl0gPSAxXSA9IFwiTWVzc2FnZXNcIjtcbiAgICBUcmFjZVtUcmFjZVtcIkNvbXBhY3RcIl0gPSAyXSA9IFwiQ29tcGFjdFwiO1xuICAgIFRyYWNlW1RyYWNlW1wiVmVyYm9zZVwiXSA9IDNdID0gXCJWZXJib3NlXCI7XG59KShUcmFjZSA9IGV4cG9ydHMuVHJhY2UgfHwgKGV4cG9ydHMuVHJhY2UgPSB7fSkpO1xudmFyIFRyYWNlVmFsdWVzO1xuKGZ1bmN0aW9uIChUcmFjZVZhbHVlcykge1xuICAgIC8qKlxuICAgICAqIFR1cm4gdHJhY2luZyBvZmYuXG4gICAgICovXG4gICAgVHJhY2VWYWx1ZXMuT2ZmID0gJ29mZic7XG4gICAgLyoqXG4gICAgICogVHJhY2UgbWVzc2FnZXMgb25seS5cbiAgICAgKi9cbiAgICBUcmFjZVZhbHVlcy5NZXNzYWdlcyA9ICdtZXNzYWdlcyc7XG4gICAgLyoqXG4gICAgICogQ29tcGFjdCBtZXNzYWdlIHRyYWNpbmcuXG4gICAgICovXG4gICAgVHJhY2VWYWx1ZXMuQ29tcGFjdCA9ICdjb21wYWN0JztcbiAgICAvKipcbiAgICAgKiBWZXJib3NlIG1lc3NhZ2UgdHJhY2luZy5cbiAgICAgKi9cbiAgICBUcmFjZVZhbHVlcy5WZXJib3NlID0gJ3ZlcmJvc2UnO1xufSkoVHJhY2VWYWx1ZXMgPSBleHBvcnRzLlRyYWNlVmFsdWVzIHx8IChleHBvcnRzLlRyYWNlVmFsdWVzID0ge30pKTtcbihmdW5jdGlvbiAoVHJhY2UpIHtcbiAgICBmdW5jdGlvbiBmcm9tU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGlmICghSXMuc3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFRyYWNlLk9mZjtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ29mZic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYWNlLk9mZjtcbiAgICAgICAgICAgIGNhc2UgJ21lc3NhZ2VzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhY2UuTWVzc2FnZXM7XG4gICAgICAgICAgICBjYXNlICdjb21wYWN0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhY2UuQ29tcGFjdDtcbiAgICAgICAgICAgIGNhc2UgJ3ZlcmJvc2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBUcmFjZS5WZXJib3NlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhY2UuT2ZmO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRyYWNlLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgVHJhY2UuT2ZmOlxuICAgICAgICAgICAgICAgIHJldHVybiAnb2ZmJztcbiAgICAgICAgICAgIGNhc2UgVHJhY2UuTWVzc2FnZXM6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdtZXNzYWdlcyc7XG4gICAgICAgICAgICBjYXNlIFRyYWNlLkNvbXBhY3Q6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdjb21wYWN0JztcbiAgICAgICAgICAgIGNhc2UgVHJhY2UuVmVyYm9zZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3ZlcmJvc2UnO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ29mZic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVHJhY2UudG9TdHJpbmcgPSB0b1N0cmluZztcbn0pKFRyYWNlID0gZXhwb3J0cy5UcmFjZSB8fCAoZXhwb3J0cy5UcmFjZSA9IHt9KSk7XG52YXIgVHJhY2VGb3JtYXQ7XG4oZnVuY3Rpb24gKFRyYWNlRm9ybWF0KSB7XG4gICAgVHJhY2VGb3JtYXRbXCJUZXh0XCJdID0gXCJ0ZXh0XCI7XG4gICAgVHJhY2VGb3JtYXRbXCJKU09OXCJdID0gXCJqc29uXCI7XG59KShUcmFjZUZvcm1hdCA9IGV4cG9ydHMuVHJhY2VGb3JtYXQgfHwgKGV4cG9ydHMuVHJhY2VGb3JtYXQgPSB7fSkpO1xuKGZ1bmN0aW9uIChUcmFjZUZvcm1hdCkge1xuICAgIGZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgaWYgKCFJcy5zdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gVHJhY2VGb3JtYXQuVGV4dDtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJ2pzb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gVHJhY2VGb3JtYXQuSlNPTjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBUcmFjZUZvcm1hdC5UZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIFRyYWNlRm9ybWF0LmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xufSkoVHJhY2VGb3JtYXQgPSBleHBvcnRzLlRyYWNlRm9ybWF0IHx8IChleHBvcnRzLlRyYWNlRm9ybWF0ID0ge30pKTtcbnZhciBTZXRUcmFjZU5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoU2V0VHJhY2VOb3RpZmljYXRpb24pIHtcbiAgICBTZXRUcmFjZU5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZSgnJC9zZXRUcmFjZScpO1xufSkoU2V0VHJhY2VOb3RpZmljYXRpb24gPSBleHBvcnRzLlNldFRyYWNlTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLlNldFRyYWNlTm90aWZpY2F0aW9uID0ge30pKTtcbnZhciBMb2dUcmFjZU5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoTG9nVHJhY2VOb3RpZmljYXRpb24pIHtcbiAgICBMb2dUcmFjZU5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZSgnJC9sb2dUcmFjZScpO1xufSkoTG9nVHJhY2VOb3RpZmljYXRpb24gPSBleHBvcnRzLkxvZ1RyYWNlTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkxvZ1RyYWNlTm90aWZpY2F0aW9uID0ge30pKTtcbnZhciBDb25uZWN0aW9uRXJyb3JzO1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uRXJyb3JzKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbm5lY3Rpb24gaXMgY2xvc2VkLlxuICAgICAqL1xuICAgIENvbm5lY3Rpb25FcnJvcnNbQ29ubmVjdGlvbkVycm9yc1tcIkNsb3NlZFwiXSA9IDFdID0gXCJDbG9zZWRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgY29ubmVjdGlvbiBnb3QgZGlzcG9zZWQuXG4gICAgICovXG4gICAgQ29ubmVjdGlvbkVycm9yc1tDb25uZWN0aW9uRXJyb3JzW1wiRGlzcG9zZWRcIl0gPSAyXSA9IFwiRGlzcG9zZWRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgY29ubmVjdGlvbiBpcyBhbHJlYWR5IGluIGxpc3RlbmluZyBtb2RlLlxuICAgICAqL1xuICAgIENvbm5lY3Rpb25FcnJvcnNbQ29ubmVjdGlvbkVycm9yc1tcIkFscmVhZHlMaXN0ZW5pbmdcIl0gPSAzXSA9IFwiQWxyZWFkeUxpc3RlbmluZ1wiO1xufSkoQ29ubmVjdGlvbkVycm9ycyA9IGV4cG9ydHMuQ29ubmVjdGlvbkVycm9ycyB8fCAoZXhwb3J0cy5Db25uZWN0aW9uRXJyb3JzID0ge30pKTtcbmNsYXNzIENvbm5lY3Rpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQ29ubmVjdGlvbkVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Db25uZWN0aW9uRXJyb3IgPSBDb25uZWN0aW9uRXJyb3I7XG52YXIgQ29ubmVjdGlvblN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uU3RyYXRlZ3kpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5jYW5jZWxVbmRpc3BhdGNoZWQpO1xuICAgIH1cbiAgICBDb25uZWN0aW9uU3RyYXRlZ3kuaXMgPSBpcztcbn0pKENvbm5lY3Rpb25TdHJhdGVneSA9IGV4cG9ydHMuQ29ubmVjdGlvblN0cmF0ZWd5IHx8IChleHBvcnRzLkNvbm5lY3Rpb25TdHJhdGVneSA9IHt9KSk7XG52YXIgQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneTtcbihmdW5jdGlvbiAoQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSkge1xuICAgIENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuTWVzc2FnZSA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBjcmVhdGVDYW5jZWxsYXRpb25Ub2tlblNvdXJjZShfKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGNhbmNlbGxhdGlvbl8xLkNhbmNlbGxhdGlvblRva2VuU291cmNlKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5jcmVhdGVDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSk7XG4gICAgfVxuICAgIENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuaXMgPSBpcztcbn0pKENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgfHwgKGV4cG9ydHMuQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSA9IHt9KSk7XG52YXIgQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3k7XG4oZnVuY3Rpb24gKENhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5KSB7XG4gICAgQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kuTWVzc2FnZSA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBzZW5kQ2FuY2VsbGF0aW9uKGNvbm4sIGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gY29ubi5zZW5kTm90aWZpY2F0aW9uKENhbmNlbE5vdGlmaWNhdGlvbi50eXBlLCB7IGlkIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhbnVwKF8pIHsgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLmZ1bmMoY2FuZGlkYXRlLnNlbmRDYW5jZWxsYXRpb24pICYmIElzLmZ1bmMoY2FuZGlkYXRlLmNsZWFudXApO1xuICAgIH1cbiAgICBDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneS5pcyA9IGlzO1xufSkoQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5IHx8IChleHBvcnRzLkNhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5ID0ge30pKTtcbnZhciBDYW5jZWxsYXRpb25TdHJhdGVneTtcbihmdW5jdGlvbiAoQ2FuY2VsbGF0aW9uU3RyYXRlZ3kpIHtcbiAgICBDYW5jZWxsYXRpb25TdHJhdGVneS5NZXNzYWdlID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIHJlY2VpdmVyOiBDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5Lk1lc3NhZ2UsXG4gICAgICAgIHNlbmRlcjogQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kuTWVzc2FnZVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuaXMoY2FuZGlkYXRlLnJlY2VpdmVyKSAmJiBDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneS5pcyhjYW5kaWRhdGUuc2VuZGVyKTtcbiAgICB9XG4gICAgQ2FuY2VsbGF0aW9uU3RyYXRlZ3kuaXMgPSBpcztcbn0pKENhbmNlbGxhdGlvblN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25TdHJhdGVneSB8fCAoZXhwb3J0cy5DYW5jZWxsYXRpb25TdHJhdGVneSA9IHt9KSk7XG52YXIgQ29ubmVjdGlvbk9wdGlvbnM7XG4oZnVuY3Rpb24gKENvbm5lY3Rpb25PcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgKENhbmNlbGxhdGlvblN0cmF0ZWd5LmlzKGNhbmRpZGF0ZS5jYW5jZWxsYXRpb25TdHJhdGVneSkgfHwgQ29ubmVjdGlvblN0cmF0ZWd5LmlzKGNhbmRpZGF0ZS5jb25uZWN0aW9uU3RyYXRlZ3kpKTtcbiAgICB9XG4gICAgQ29ubmVjdGlvbk9wdGlvbnMuaXMgPSBpcztcbn0pKENvbm5lY3Rpb25PcHRpb25zID0gZXhwb3J0cy5Db25uZWN0aW9uT3B0aW9ucyB8fCAoZXhwb3J0cy5Db25uZWN0aW9uT3B0aW9ucyA9IHt9KSk7XG52YXIgQ29ubmVjdGlvblN0YXRlO1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uU3RhdGUpIHtcbiAgICBDb25uZWN0aW9uU3RhdGVbQ29ubmVjdGlvblN0YXRlW1wiTmV3XCJdID0gMV0gPSBcIk5ld1wiO1xuICAgIENvbm5lY3Rpb25TdGF0ZVtDb25uZWN0aW9uU3RhdGVbXCJMaXN0ZW5pbmdcIl0gPSAyXSA9IFwiTGlzdGVuaW5nXCI7XG4gICAgQ29ubmVjdGlvblN0YXRlW0Nvbm5lY3Rpb25TdGF0ZVtcIkNsb3NlZFwiXSA9IDNdID0gXCJDbG9zZWRcIjtcbiAgICBDb25uZWN0aW9uU3RhdGVbQ29ubmVjdGlvblN0YXRlW1wiRGlzcG9zZWRcIl0gPSA0XSA9IFwiRGlzcG9zZWRcIjtcbn0pKENvbm5lY3Rpb25TdGF0ZSB8fCAoQ29ubmVjdGlvblN0YXRlID0ge30pKTtcbmZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uKG1lc3NhZ2VSZWFkZXIsIG1lc3NhZ2VXcml0ZXIsIF9sb2dnZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsb2dnZXIgPSBfbG9nZ2VyICE9PSB1bmRlZmluZWQgPyBfbG9nZ2VyIDogZXhwb3J0cy5OdWxsTG9nZ2VyO1xuICAgIGxldCBzZXF1ZW5jZU51bWJlciA9IDA7XG4gICAgbGV0IG5vdGlmaWNhdGlvblNlcXVlbmNlTnVtYmVyID0gMDtcbiAgICBsZXQgdW5rbm93blJlc3BvbnNlU2VxdWVuY2VOdW1iZXIgPSAwO1xuICAgIGNvbnN0IHZlcnNpb24gPSAnMi4wJztcbiAgICBsZXQgc3RhclJlcXVlc3RIYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJlcXVlc3RIYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICBsZXQgc3Rhck5vdGlmaWNhdGlvbkhhbmRsZXIgPSB1bmRlZmluZWQ7XG4gICAgY29uc3Qgbm90aWZpY2F0aW9uSGFuZGxlcnMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgcHJvZ3Jlc3NIYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICBsZXQgdGltZXI7XG4gICAgbGV0IG1lc3NhZ2VRdWV1ZSA9IG5ldyBsaW5rZWRNYXBfMS5MaW5rZWRNYXAoKTtcbiAgICBsZXQgcmVzcG9uc2VQcm9taXNlcyA9IG5ldyBNYXAoKTtcbiAgICBsZXQga25vd25DYW5jZWxlZFJlcXVlc3RzID0gbmV3IFNldCgpO1xuICAgIGxldCByZXF1ZXN0VG9rZW5zID0gbmV3IE1hcCgpO1xuICAgIGxldCB0cmFjZSA9IFRyYWNlLk9mZjtcbiAgICBsZXQgdHJhY2VGb3JtYXQgPSBUcmFjZUZvcm1hdC5UZXh0O1xuICAgIGxldCB0cmFjZXI7XG4gICAgbGV0IHN0YXRlID0gQ29ubmVjdGlvblN0YXRlLk5ldztcbiAgICBjb25zdCBlcnJvckVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgIGNvbnN0IGNsb3NlRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgY29uc3QgdW5oYW5kbGVkTm90aWZpY2F0aW9uRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgY29uc3QgdW5oYW5kbGVkUHJvZ3Jlc3NFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICBjb25zdCBkaXNwb3NlRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgY29uc3QgY2FuY2VsbGF0aW9uU3RyYXRlZ3kgPSAob3B0aW9ucyAmJiBvcHRpb25zLmNhbmNlbGxhdGlvblN0cmF0ZWd5KSA/IG9wdGlvbnMuY2FuY2VsbGF0aW9uU3RyYXRlZ3kgOiBDYW5jZWxsYXRpb25TdHJhdGVneS5NZXNzYWdlO1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3RRdWV1ZUtleShpZCkge1xuICAgICAgICBpZiAoaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3Qgc2VuZCByZXF1ZXN0cyB3aXRoIGlkIG51bGwgc2luY2UgdGhlIHJlc3BvbnNlIGNhbid0IGJlIGNvcnJlbGF0ZWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdyZXEtJyArIGlkLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlUXVldWVLZXkoaWQpIHtcbiAgICAgICAgaWYgKGlkID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3Jlcy11bmtub3duLScgKyAoKyt1bmtub3duUmVzcG9uc2VTZXF1ZW5jZU51bWJlcikudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAncmVzLScgKyBpZC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU5vdGlmaWNhdGlvblF1ZXVlS2V5KCkge1xuICAgICAgICByZXR1cm4gJ25vdC0nICsgKCsrbm90aWZpY2F0aW9uU2VxdWVuY2VOdW1iZXIpLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZE1lc3NhZ2VUb1F1ZXVlKHF1ZXVlLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNSZXF1ZXN0KG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBxdWV1ZS5zZXQoY3JlYXRlUmVxdWVzdFF1ZXVlS2V5KG1lc3NhZ2UuaWQpLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNSZXNwb25zZShtZXNzYWdlKSkge1xuICAgICAgICAgICAgcXVldWUuc2V0KGNyZWF0ZVJlc3BvbnNlUXVldWVLZXkobWVzc2FnZS5pZCksIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcXVldWUuc2V0KGNyZWF0ZU5vdGlmaWNhdGlvblF1ZXVlS2V5KCksIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbmNlbFVuZGlzcGF0Y2hlZChfbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0xpc3RlbmluZygpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuTGlzdGVuaW5nO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0Nsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ2xvc2VkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0Rpc3Bvc2VkKCkge1xuICAgICAgICByZXR1cm4gc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5EaXNwb3NlZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xvc2VIYW5kbGVyKCkge1xuICAgICAgICBpZiAoc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5OZXcgfHwgc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5MaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgIHN0YXRlID0gQ29ubmVjdGlvblN0YXRlLkNsb3NlZDtcbiAgICAgICAgICAgIGNsb3NlRW1pdHRlci5maXJlKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGNvbm5lY3Rpb24gaXMgZGlzcG9zZWQgZG9uJ3Qgc2VudCBjbG9zZSBldmVudHMuXG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRFcnJvckhhbmRsZXIoZXJyb3IpIHtcbiAgICAgICAgZXJyb3JFbWl0dGVyLmZpcmUoW2Vycm9yLCB1bmRlZmluZWQsIHVuZGVmaW5lZF0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZUVycm9ySGFuZGxlcihkYXRhKSB7XG4gICAgICAgIGVycm9yRW1pdHRlci5maXJlKGRhdGEpO1xuICAgIH1cbiAgICBtZXNzYWdlUmVhZGVyLm9uQ2xvc2UoY2xvc2VIYW5kbGVyKTtcbiAgICBtZXNzYWdlUmVhZGVyLm9uRXJyb3IocmVhZEVycm9ySGFuZGxlcik7XG4gICAgbWVzc2FnZVdyaXRlci5vbkNsb3NlKGNsb3NlSGFuZGxlcik7XG4gICAgbWVzc2FnZVdyaXRlci5vbkVycm9yKHdyaXRlRXJyb3JIYW5kbGVyKTtcbiAgICBmdW5jdGlvbiB0cmlnZ2VyTWVzc2FnZVF1ZXVlKCkge1xuICAgICAgICBpZiAodGltZXIgfHwgbWVzc2FnZVF1ZXVlLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aW1lciA9ICgwLCByYWxfMS5kZWZhdWx0KSgpLnRpbWVyLnNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICB0aW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHByb2Nlc3NNZXNzYWdlUXVldWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb2Nlc3NNZXNzYWdlUXVldWUoKSB7XG4gICAgICAgIGlmIChtZXNzYWdlUXVldWUuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlUXVldWUuc2hpZnQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNSZXF1ZXN0KG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlUmVxdWVzdChtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc05vdGlmaWNhdGlvbihtZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZU5vdGlmaWNhdGlvbihtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc1Jlc3BvbnNlKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlUmVzcG9uc2UobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVJbnZhbGlkTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyaWdnZXJNZXNzYWdlUXVldWUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjYWxsYmFjayA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIHJlY2VpdmVkIGEgY2FuY2VsbGF0aW9uIG1lc3NhZ2UuIENoZWNrIGlmIHRoZSBtZXNzYWdlIGlzIHN0aWxsIGluIHRoZSBxdWV1ZVxuICAgICAgICAgICAgLy8gYW5kIGNhbmNlbCBpdCBpZiBhbGxvd2VkIHRvIGRvIHNvLlxuICAgICAgICAgICAgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc05vdGlmaWNhdGlvbihtZXNzYWdlKSAmJiBtZXNzYWdlLm1ldGhvZCA9PT0gQ2FuY2VsTm90aWZpY2F0aW9uLnR5cGUubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsSWQgPSBtZXNzYWdlLnBhcmFtcy5pZDtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBjcmVhdGVSZXF1ZXN0UXVldWVLZXkoY2FuY2VsSWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvQ2FuY2VsID0gbWVzc2FnZVF1ZXVlLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNSZXF1ZXN0KHRvQ2FuY2VsKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJhdGVneSA9IG9wdGlvbnM/LmNvbm5lY3Rpb25TdHJhdGVneTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSAoc3RyYXRlZ3kgJiYgc3RyYXRlZ3kuY2FuY2VsVW5kaXNwYXRjaGVkKSA/IHN0cmF0ZWd5LmNhbmNlbFVuZGlzcGF0Y2hlZCh0b0NhbmNlbCwgY2FuY2VsVW5kaXNwYXRjaGVkKSA6IGNhbmNlbFVuZGlzcGF0Y2hlZCh0b0NhbmNlbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiAocmVzcG9uc2UuZXJyb3IgIT09IHVuZGVmaW5lZCB8fCByZXNwb25zZS5yZXN1bHQgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VRdWV1ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuZGVsZXRlKGNhbmNlbElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmlkID0gdG9DYW5jZWwuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjZVNlbmRpbmdSZXNwb25zZShyZXNwb25zZSwgbWVzc2FnZS5tZXRob2QsIERhdGUubm93KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVdyaXRlci53cml0ZShyZXNwb25zZSkuY2F0Y2goKCkgPT4gbG9nZ2VyLmVycm9yKGBTZW5kaW5nIHJlc3BvbnNlIGZvciBjYW5jZWxlZCBtZXNzYWdlIGZhaWxlZC5gKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsbGF0aW9uVG9rZW4gPSByZXF1ZXN0VG9rZW5zLmdldChjYW5jZWxJZCk7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHJlcXVlc3QgaXMgYWxyZWFkeSBydW5uaW5nLiBDYW5jZWwgdGhlIHRva2VuXG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbGxhdGlvblRva2VuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uVG9rZW4uY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlUmVjZWl2ZWROb3RpZmljYXRpb24obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoZSBjYW5jZWwgYnV0IHN0aWxsIHF1ZXVlIHRoZSBtZXNzYWdlIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGNsZWFuIHVwIHN0YXRlIGluIHByb2Nlc3MgbWVzc2FnZS5cbiAgICAgICAgICAgICAgICAgICAga25vd25DYW5jZWxlZFJlcXVlc3RzLmFkZChjYW5jZWxJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkTWVzc2FnZVRvUXVldWUobWVzc2FnZVF1ZXVlLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyaWdnZXJNZXNzYWdlUXVldWUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gaGFuZGxlUmVxdWVzdChyZXF1ZXN0TWVzc2FnZSkge1xuICAgICAgICBpZiAoaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICAvLyB3ZSByZXR1cm4gaGVyZSBzaWxlbnRseSBzaW5jZSB3ZSBmaXJlZCBhbiBldmVudCB3aGVuIHRoZVxuICAgICAgICAgICAgLy8gY29ubmVjdGlvbiBnb3QgZGlzcG9zZWQuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVwbHkocmVzdWx0T3JFcnJvciwgbWV0aG9kLCBzdGFydFRpbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAganNvbnJwYzogdmVyc2lvbixcbiAgICAgICAgICAgICAgICBpZDogcmVxdWVzdE1lc3NhZ2UuaWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocmVzdWx0T3JFcnJvciBpbnN0YW5jZW9mIG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXJyb3IgPSByZXN1bHRPckVycm9yLnRvSnNvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5yZXN1bHQgPSByZXN1bHRPckVycm9yID09PSB1bmRlZmluZWQgPyBudWxsIDogcmVzdWx0T3JFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNlU2VuZGluZ1Jlc3BvbnNlKG1lc3NhZ2UsIG1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIG1lc3NhZ2VXcml0ZXIud3JpdGUobWVzc2FnZSkuY2F0Y2goKCkgPT4gbG9nZ2VyLmVycm9yKGBTZW5kaW5nIHJlc3BvbnNlIGZhaWxlZC5gKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVwbHlFcnJvcihlcnJvciwgbWV0aG9kLCBzdGFydFRpbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAganNvbnJwYzogdmVyc2lvbixcbiAgICAgICAgICAgICAgICBpZDogcmVxdWVzdE1lc3NhZ2UuaWQsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLnRvSnNvbigpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJhY2VTZW5kaW5nUmVzcG9uc2UobWVzc2FnZSwgbWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgbWVzc2FnZVdyaXRlci53cml0ZShtZXNzYWdlKS5jYXRjaCgoKSA9PiBsb2dnZXIuZXJyb3IoYFNlbmRpbmcgcmVzcG9uc2UgZmFpbGVkLmApKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXBseVN1Y2Nlc3MocmVzdWx0LCBtZXRob2QsIHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgLy8gVGhlIEpTT04gUlBDIGRlZmluZXMgdGhhdCBhIHJlc3BvbnNlIG11c3QgZWl0aGVyIGhhdmUgYSByZXN1bHQgb3IgYW4gZXJyb3JcbiAgICAgICAgICAgIC8vIFNvIHdlIGNhbid0IHRyZWF0IHVuZGVmaW5lZCBhcyBhIHZhbGlkIHJlc3BvbnNlIHJlc3VsdC5cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGpzb25ycGM6IHZlcnNpb24sXG4gICAgICAgICAgICAgICAgaWQ6IHJlcXVlc3RNZXNzYWdlLmlkLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJhY2VTZW5kaW5nUmVzcG9uc2UobWVzc2FnZSwgbWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgbWVzc2FnZVdyaXRlci53cml0ZShtZXNzYWdlKS5jYXRjaCgoKSA9PiBsb2dnZXIuZXJyb3IoYFNlbmRpbmcgcmVzcG9uc2UgZmFpbGVkLmApKTtcbiAgICAgICAgfVxuICAgICAgICB0cmFjZVJlY2VpdmVkUmVxdWVzdChyZXF1ZXN0TWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSByZXF1ZXN0SGFuZGxlcnMuZ2V0KHJlcXVlc3RNZXNzYWdlLm1ldGhvZCk7XG4gICAgICAgIGxldCB0eXBlO1xuICAgICAgICBsZXQgcmVxdWVzdEhhbmRsZXI7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICB0eXBlID0gZWxlbWVudC50eXBlO1xuICAgICAgICAgICAgcmVxdWVzdEhhbmRsZXIgPSBlbGVtZW50LmhhbmRsZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKHJlcXVlc3RIYW5kbGVyIHx8IHN0YXJSZXF1ZXN0SGFuZGxlcikge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5LZXkgPSByZXF1ZXN0TWVzc2FnZS5pZCA/PyBTdHJpbmcoRGF0ZS5ub3coKSk7IC8vXG4gICAgICAgICAgICBjb25zdCBjYW5jZWxsYXRpb25Tb3VyY2UgPSBjYW5jZWxsYXRpb25TdHJhdGVneS5yZWNlaXZlci5jcmVhdGVDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSh0b2tlbktleSk7XG4gICAgICAgICAgICBpZiAocmVxdWVzdE1lc3NhZ2UuaWQgIT09IG51bGwgJiYga25vd25DYW5jZWxlZFJlcXVlc3RzLmhhcyhyZXF1ZXN0TWVzc2FnZS5pZCkpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25Tb3VyY2UuY2FuY2VsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdE1lc3NhZ2UuaWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW5zLnNldCh0b2tlbktleSwgY2FuY2VsbGF0aW9uU291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGhhbmRsZXJSZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0TWVzc2FnZS5wYXJhbXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLm51bWJlck9mUGFyYW1zICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnZhbGlkUGFyYW1zLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZGVmaW5lcyAke3R5cGUubnVtYmVyT2ZQYXJhbXN9IHBhcmFtcyBidXQgcmVjZWl2ZWQgbm9uZS5gKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJSZXN1bHQgPSByZXF1ZXN0SGFuZGxlcihjYW5jZWxsYXRpb25Tb3VyY2UudG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVxdWVzdE1lc3NhZ2UucGFyYW1zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLnBhcmFtZXRlclN0cnVjdHVyZXMgPT09IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLkludmFsaWRQYXJhbXMsIGBSZXF1ZXN0ICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfSBkZWZpbmVzIHBhcmFtZXRlcnMgYnkgbmFtZSBidXQgcmVjZWl2ZWQgcGFyYW1ldGVycyBieSBwb3NpdGlvbmApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlclJlc3VsdCA9IHJlcXVlc3RIYW5kbGVyKC4uLnJlcXVlc3RNZXNzYWdlLnBhcmFtcywgY2FuY2VsbGF0aW9uU291cmNlLnRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS5wYXJhbWV0ZXJTdHJ1Y3R1cmVzID09PSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuSW52YWxpZFBhcmFtcywgYFJlcXVlc3QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9IGRlZmluZXMgcGFyYW1ldGVycyBieSBwb3NpdGlvbiBidXQgcmVjZWl2ZWQgcGFyYW1ldGVycyBieSBuYW1lYCksIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyUmVzdWx0ID0gcmVxdWVzdEhhbmRsZXIocmVxdWVzdE1lc3NhZ2UucGFyYW1zLCBjYW5jZWxsYXRpb25Tb3VyY2UudG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJSZXF1ZXN0SGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyUmVzdWx0ID0gc3RhclJlcXVlc3RIYW5kbGVyKHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgcmVxdWVzdE1lc3NhZ2UucGFyYW1zLCBjYW5jZWxsYXRpb25Tb3VyY2UudG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gaGFuZGxlclJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZXJSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFRva2Vucy5kZWxldGUodG9rZW5LZXkpO1xuICAgICAgICAgICAgICAgICAgICByZXBseVN1Y2Nlc3MoaGFuZGxlclJlc3VsdCwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9taXNlLnRoZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS50aGVuKChyZXN1bHRPckVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW5zLmRlbGV0ZSh0b2tlbktleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBseShyZXN1bHRPckVycm9yLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuZGVsZXRlKHRva2VuS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5RXJyb3IoZXJyb3IsIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yICYmIElzLnN0cmluZyhlcnJvci5tZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuSW50ZXJuYWxFcnJvciwgYFJlcXVlc3QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9IGZhaWxlZCB3aXRoIG1lc3NhZ2U6ICR7ZXJyb3IubWVzc2FnZX1gKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnRlcm5hbEVycm9yLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZmFpbGVkIHVuZXhwZWN0ZWRseSB3aXRob3V0IHByb3ZpZGluZyBhbnkgZGV0YWlscy5gKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuZGVsZXRlKHRva2VuS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgcmVwbHkoaGFuZGxlclJlc3VsdCwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuZGVsZXRlKHRva2VuS2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbHkoZXJyb3IsIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IgJiYgSXMuc3RyaW5nKGVycm9yLm1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuSW50ZXJuYWxFcnJvciwgYFJlcXVlc3QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9IGZhaWxlZCB3aXRoIG1lc3NhZ2U6ICR7ZXJyb3IubWVzc2FnZX1gKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnRlcm5hbEVycm9yLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZmFpbGVkIHVuZXhwZWN0ZWRseSB3aXRob3V0IHByb3ZpZGluZyBhbnkgZGV0YWlscy5gKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuTWV0aG9kTm90Rm91bmQsIGBVbmhhbmRsZWQgbWV0aG9kICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfWApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlUmVzcG9uc2UocmVzcG9uc2VNZXNzYWdlKSB7XG4gICAgICAgIGlmIChpc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgIC8vIFNlZSBoYW5kbGUgcmVxdWVzdC5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2VNZXNzYWdlLmlkID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VNZXNzYWdlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBSZWNlaXZlZCByZXNwb25zZSBtZXNzYWdlIHdpdGhvdXQgaWQ6IEVycm9yIGlzOiBcXG4ke0pTT04uc3RyaW5naWZ5KHJlc3BvbnNlTWVzc2FnZS5lcnJvciwgdW5kZWZpbmVkLCA0KX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgUmVjZWl2ZWQgcmVzcG9uc2UgbWVzc2FnZSB3aXRob3V0IGlkLiBObyBmdXJ0aGVyIGVycm9yIGluZm9ybWF0aW9uIHByb3ZpZGVkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gcmVzcG9uc2VNZXNzYWdlLmlkO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VQcm9taXNlID0gcmVzcG9uc2VQcm9taXNlcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIHRyYWNlUmVjZWl2ZWRSZXNwb25zZShyZXNwb25zZU1lc3NhZ2UsIHJlc3BvbnNlUHJvbWlzZSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VQcm9taXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2VzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZU1lc3NhZ2UuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gcmVzcG9uc2VNZXNzYWdlLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlamVjdChuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKGVycm9yLmNvZGUsIGVycm9yLm1lc3NhZ2UsIGVycm9yLmRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXNwb25zZU1lc3NhZ2UucmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlTWVzc2FnZS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbmV2ZXIgaGFwcGVuLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBSZXNwb25zZSBoYW5kbGVyICcke3Jlc3BvbnNlUHJvbWlzZS5tZXRob2R9JyBmYWlsZWQgd2l0aCBtZXNzYWdlOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFJlc3BvbnNlIGhhbmRsZXIgJyR7cmVzcG9uc2VQcm9taXNlLm1ldGhvZH0nIGZhaWxlZCB1bmV4cGVjdGVkbHkuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlTm90aWZpY2F0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGlzRGlzcG9zZWQoKSkge1xuICAgICAgICAgICAgLy8gU2VlIGhhbmRsZSByZXF1ZXN0LlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0eXBlID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgbm90aWZpY2F0aW9uSGFuZGxlcjtcbiAgICAgICAgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBDYW5jZWxOb3RpZmljYXRpb24udHlwZS5tZXRob2QpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbElkID0gbWVzc2FnZS5wYXJhbXMuaWQ7XG4gICAgICAgICAgICBrbm93bkNhbmNlbGVkUmVxdWVzdHMuZGVsZXRlKGNhbmNlbElkKTtcbiAgICAgICAgICAgIHRyYWNlUmVjZWl2ZWROb3RpZmljYXRpb24obWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gbm90aWZpY2F0aW9uSGFuZGxlcnMuZ2V0KG1lc3NhZ2UubWV0aG9kKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlciA9IGVsZW1lbnQuaGFuZGxlcjtcbiAgICAgICAgICAgICAgICB0eXBlID0gZWxlbWVudC50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub3RpZmljYXRpb25IYW5kbGVyIHx8IHN0YXJOb3RpZmljYXRpb25IYW5kbGVyKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRyYWNlUmVjZWl2ZWROb3RpZmljYXRpb24obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vdGlmaWNhdGlvbkhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UucGFyYW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZS5udW1iZXJPZlBhcmFtcyAhPT0gMCAmJiB0eXBlLnBhcmFtZXRlclN0cnVjdHVyZXMgIT09IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBOb3RpZmljYXRpb24gJHttZXNzYWdlLm1ldGhvZH0gZGVmaW5lcyAke3R5cGUubnVtYmVyT2ZQYXJhbXN9IHBhcmFtcyBidXQgcmVjZWl2ZWQgbm9uZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShtZXNzYWdlLnBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGFyZSBKU09OLVJQQyBsaWJyYXJpZXMgdGhhdCBzZW5kIHByb2dyZXNzIG1lc3NhZ2UgYXMgcG9zaXRpb25hbCBwYXJhbXMgYWx0aG91Z2hcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZCBhcyBuYW1lZC4gU28gY29udmVydCB0aGVtIGlmIHRoaXMgaXMgdGhlIGNhc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBtZXNzYWdlLnBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLm1ldGhvZCA9PT0gUHJvZ3Jlc3NOb3RpZmljYXRpb24udHlwZS5tZXRob2QgJiYgcGFyYW1zLmxlbmd0aCA9PT0gMiAmJiBQcm9ncmVzc1Rva2VuLmlzKHBhcmFtc1swXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVyKHsgdG9rZW46IHBhcmFtc1swXSwgdmFsdWU6IHBhcmFtc1sxXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUucGFyYW1ldGVyU3RydWN0dXJlcyA9PT0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBOb3RpZmljYXRpb24gJHttZXNzYWdlLm1ldGhvZH0gZGVmaW5lcyBwYXJhbWV0ZXJzIGJ5IG5hbWUgYnV0IHJlY2VpdmVkIHBhcmFtZXRlcnMgYnkgcG9zaXRpb25gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZS5udW1iZXJPZlBhcmFtcyAhPT0gbWVzc2FnZS5wYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE5vdGlmaWNhdGlvbiAke21lc3NhZ2UubWV0aG9kfSBkZWZpbmVzICR7dHlwZS5udW1iZXJPZlBhcmFtc30gcGFyYW1zIGJ1dCByZWNlaXZlZCAke3BhcmFtcy5sZW5ndGh9IGFyZ3VtZW50c2ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXIoLi4ucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS5wYXJhbWV0ZXJTdHJ1Y3R1cmVzID09PSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTm90aWZpY2F0aW9uICR7bWVzc2FnZS5tZXRob2R9IGRlZmluZXMgcGFyYW1ldGVycyBieSBwb3NpdGlvbiBidXQgcmVjZWl2ZWQgcGFyYW1ldGVycyBieSBuYW1lYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVyKG1lc3NhZ2UucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGFyTm90aWZpY2F0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBzdGFyTm90aWZpY2F0aW9uSGFuZGxlcihtZXNzYWdlLm1ldGhvZCwgbWVzc2FnZS5wYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTm90aWZpY2F0aW9uIGhhbmRsZXIgJyR7bWVzc2FnZS5tZXRob2R9JyBmYWlsZWQgd2l0aCBtZXNzYWdlOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE5vdGlmaWNhdGlvbiBoYW5kbGVyICcke21lc3NhZ2UubWV0aG9kfScgZmFpbGVkIHVuZXhwZWN0ZWRseS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1bmhhbmRsZWROb3RpZmljYXRpb25FbWl0dGVyLmZpcmUobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlSW52YWxpZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcignUmVjZWl2ZWQgZW1wdHkgbWVzc2FnZS4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZXJyb3IoYFJlY2VpdmVkIG1lc3NhZ2Ugd2hpY2ggaXMgbmVpdGhlciBhIHJlc3BvbnNlIG5vciBhIG5vdGlmaWNhdGlvbiBtZXNzYWdlOlxcbiR7SlNPTi5zdHJpbmdpZnkobWVzc2FnZSwgbnVsbCwgNCl9YCk7XG4gICAgICAgIC8vIFRlc3Qgd2hldGhlciB3ZSBmaW5kIGFuIGlkIHRvIHJlamVjdCB0aGUgcHJvbWlzZVxuICAgICAgICBjb25zdCByZXNwb25zZU1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICBpZiAoSXMuc3RyaW5nKHJlc3BvbnNlTWVzc2FnZS5pZCkgfHwgSXMubnVtYmVyKHJlc3BvbnNlTWVzc2FnZS5pZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHJlc3BvbnNlTWVzc2FnZS5pZDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlSGFuZGxlciA9IHJlc3BvbnNlUHJvbWlzZXMuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VIYW5kbGVyLnJlamVjdChuZXcgRXJyb3IoJ1RoZSByZWNlaXZlZCByZXNwb25zZSBoYXMgbmVpdGhlciBhIHJlc3VsdCBub3IgYW4gZXJyb3IgcHJvcGVydHkuJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeVRyYWNlKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQgfHwgcGFyYW1zID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodHJhY2UpIHtcbiAgICAgICAgICAgIGNhc2UgVHJhY2UuVmVyYm9zZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFyYW1zLCBudWxsLCA0KTtcbiAgICAgICAgICAgIGNhc2UgVHJhY2UuQ29tcGFjdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFyYW1zKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFjZVNlbmRpbmdSZXF1ZXN0KG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYgfHwgIXRyYWNlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZUZvcm1hdCA9PT0gVHJhY2VGb3JtYXQuVGV4dCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoKHRyYWNlID09PSBUcmFjZS5WZXJib3NlIHx8IHRyYWNlID09PSBUcmFjZS5Db21wYWN0KSAmJiBtZXNzYWdlLnBhcmFtcykge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBgUGFyYW1zOiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UucGFyYW1zKX1cXG5cXG5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2VyLmxvZyhgU2VuZGluZyByZXF1ZXN0ICcke21lc3NhZ2UubWV0aG9kfSAtICgke21lc3NhZ2UuaWR9KScuYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdzZW5kLXJlcXVlc3QnLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFjZVNlbmRpbmdOb3RpZmljYXRpb24obWVzc2FnZSkge1xuICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLk9mZiB8fCAhdHJhY2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNlRm9ybWF0ID09PSBUcmFjZUZvcm1hdC5UZXh0KSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuVmVyYm9zZSB8fCB0cmFjZSA9PT0gVHJhY2UuQ29tcGFjdCkge1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gYFBhcmFtczogJHtzdHJpbmdpZnlUcmFjZShtZXNzYWdlLnBhcmFtcyl9XFxuXFxuYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSAnTm8gcGFyYW1ldGVycyBwcm92aWRlZC5cXG5cXG4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNlci5sb2coYFNlbmRpbmcgbm90aWZpY2F0aW9uICcke21lc3NhZ2UubWV0aG9kfScuYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdzZW5kLW5vdGlmaWNhdGlvbicsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYWNlU2VuZGluZ1Jlc3BvbnNlKG1lc3NhZ2UsIG1ldGhvZCwgc3RhcnRUaW1lKSB7XG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2VGb3JtYXQgPT09IFRyYWNlRm9ybWF0LlRleHQpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5WZXJib3NlIHx8IHRyYWNlID09PSBUcmFjZS5Db21wYWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZXJyb3IgJiYgbWVzc2FnZS5lcnJvci5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBgRXJyb3IgZGF0YTogJHtzdHJpbmdpZnlUcmFjZShtZXNzYWdlLmVycm9yLmRhdGEpfVxcblxcbmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBgUmVzdWx0OiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UucmVzdWx0KX1cXG5cXG5gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1lc3NhZ2UuZXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICdObyByZXN1bHQgcmV0dXJuZWQuXFxuXFxuJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNlci5sb2coYFNlbmRpbmcgcmVzcG9uc2UgJyR7bWV0aG9kfSAtICgke21lc3NhZ2UuaWR9KScuIFByb2Nlc3NpbmcgcmVxdWVzdCB0b29rICR7RGF0ZS5ub3coKSAtIHN0YXJ0VGltZX1tc2AsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nTFNQTWVzc2FnZSgnc2VuZC1yZXNwb25zZScsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYWNlUmVjZWl2ZWRSZXF1ZXN0KG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYgfHwgIXRyYWNlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZUZvcm1hdCA9PT0gVHJhY2VGb3JtYXQuVGV4dCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoKHRyYWNlID09PSBUcmFjZS5WZXJib3NlIHx8IHRyYWNlID09PSBUcmFjZS5Db21wYWN0KSAmJiBtZXNzYWdlLnBhcmFtcykge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBgUGFyYW1zOiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UucGFyYW1zKX1cXG5cXG5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2VyLmxvZyhgUmVjZWl2ZWQgcmVxdWVzdCAnJHttZXNzYWdlLm1ldGhvZH0gLSAoJHttZXNzYWdlLmlkfSknLmAsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nTFNQTWVzc2FnZSgncmVjZWl2ZS1yZXF1ZXN0JywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhY2VSZWNlaXZlZE5vdGlmaWNhdGlvbihtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIgfHwgbWVzc2FnZS5tZXRob2QgPT09IExvZ1RyYWNlTm90aWZpY2F0aW9uLnR5cGUubWV0aG9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNlRm9ybWF0ID09PSBUcmFjZUZvcm1hdC5UZXh0KSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuVmVyYm9zZSB8fCB0cmFjZSA9PT0gVHJhY2UuQ29tcGFjdCkge1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gYFBhcmFtczogJHtzdHJpbmdpZnlUcmFjZShtZXNzYWdlLnBhcmFtcyl9XFxuXFxuYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSAnTm8gcGFyYW1ldGVycyBwcm92aWRlZC5cXG5cXG4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNlci5sb2coYFJlY2VpdmVkIG5vdGlmaWNhdGlvbiAnJHttZXNzYWdlLm1ldGhvZH0nLmAsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nTFNQTWVzc2FnZSgncmVjZWl2ZS1ub3RpZmljYXRpb24nLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFjZVJlY2VpdmVkUmVzcG9uc2UobWVzc2FnZSwgcmVzcG9uc2VQcm9taXNlKSB7XG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2VGb3JtYXQgPT09IFRyYWNlRm9ybWF0LlRleHQpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5WZXJib3NlIHx8IHRyYWNlID09PSBUcmFjZS5Db21wYWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZXJyb3IgJiYgbWVzc2FnZS5lcnJvci5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBgRXJyb3IgZGF0YTogJHtzdHJpbmdpZnlUcmFjZShtZXNzYWdlLmVycm9yLmRhdGEpfVxcblxcbmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBgUmVzdWx0OiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UucmVzdWx0KX1cXG5cXG5gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1lc3NhZ2UuZXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICdObyByZXN1bHQgcmV0dXJuZWQuXFxuXFxuJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXNwb25zZVByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG1lc3NhZ2UuZXJyb3IgPyBgIFJlcXVlc3QgZmFpbGVkOiAke21lc3NhZ2UuZXJyb3IubWVzc2FnZX0gKCR7bWVzc2FnZS5lcnJvci5jb2RlfSkuYCA6ICcnO1xuICAgICAgICAgICAgICAgIHRyYWNlci5sb2coYFJlY2VpdmVkIHJlc3BvbnNlICcke3Jlc3BvbnNlUHJvbWlzZS5tZXRob2R9IC0gKCR7bWVzc2FnZS5pZH0pJyBpbiAke0RhdGUubm93KCkgLSByZXNwb25zZVByb21pc2UudGltZXJTdGFydH1tcy4ke2Vycm9yfWAsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhY2VyLmxvZyhgUmVjZWl2ZWQgcmVzcG9uc2UgJHttZXNzYWdlLmlkfSB3aXRob3V0IGFjdGl2ZSByZXNwb25zZSBwcm9taXNlLmAsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nTFNQTWVzc2FnZSgncmVjZWl2ZS1yZXNwb25zZScsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvZ0xTUE1lc3NhZ2UodHlwZSwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoIXRyYWNlciB8fCB0cmFjZSA9PT0gVHJhY2UuT2ZmKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbHNwTWVzc2FnZSA9IHtcbiAgICAgICAgICAgIGlzTFNQTWVzc2FnZTogdHJ1ZSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICAgIH07XG4gICAgICAgIHRyYWNlci5sb2cobHNwTWVzc2FnZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCkge1xuICAgICAgICBpZiAoaXNDbG9zZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihDb25uZWN0aW9uRXJyb3JzLkNsb3NlZCwgJ0Nvbm5lY3Rpb24gaXMgY2xvc2VkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoQ29ubmVjdGlvbkVycm9ycy5EaXNwb3NlZCwgJ0Nvbm5lY3Rpb24gaXMgZGlzcG9zZWQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdGhyb3dJZkxpc3RlbmluZygpIHtcbiAgICAgICAgaWYgKGlzTGlzdGVuaW5nKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoQ29ubmVjdGlvbkVycm9ycy5BbHJlYWR5TGlzdGVuaW5nLCAnQ29ubmVjdGlvbiBpcyBhbHJlYWR5IGxpc3RlbmluZycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRocm93SWZOb3RMaXN0ZW5pbmcoKSB7XG4gICAgICAgIGlmICghaXNMaXN0ZW5pbmcoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsIGxpc3RlbigpIGZpcnN0LicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuZGVmaW5lZFRvTnVsbChwYXJhbSkge1xuICAgICAgICBpZiAocGFyYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbnVsbFRvVW5kZWZpbmVkKHBhcmFtKSB7XG4gICAgICAgIGlmIChwYXJhbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpc05hbWVkUGFyYW0ocGFyYW0pIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtICE9PSB1bmRlZmluZWQgJiYgcGFyYW0gIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkocGFyYW0pICYmIHR5cGVvZiBwYXJhbSA9PT0gJ29iamVjdCc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXB1dGVTaW5nbGVQYXJhbShwYXJhbWV0ZXJTdHJ1Y3R1cmVzLCBwYXJhbSkge1xuICAgICAgICBzd2l0Y2ggKHBhcmFtZXRlclN0cnVjdHVyZXMpIHtcbiAgICAgICAgICAgIGNhc2UgbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG86XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFtZWRQYXJhbShwYXJhbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGxUb1VuZGVmaW5lZChwYXJhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3VuZGVmaW5lZFRvTnVsbChwYXJhbSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZTpcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFtZWRQYXJhbShwYXJhbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWNlaXZlZCBwYXJhbWV0ZXJzIGJ5IG5hbWUgYnV0IHBhcmFtIGlzIG5vdCBhbiBvYmplY3QgbGl0ZXJhbC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxUb1VuZGVmaW5lZChwYXJhbSk7XG4gICAgICAgICAgICBjYXNlIG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieVBvc2l0aW9uOlxuICAgICAgICAgICAgICAgIHJldHVybiBbdW5kZWZpbmVkVG9OdWxsKHBhcmFtKV07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwYXJhbWV0ZXIgc3RydWN0dXJlICR7cGFyYW1ldGVyU3RydWN0dXJlcy50b1N0cmluZygpfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXB1dGVNZXNzYWdlUGFyYW1zKHR5cGUsIHBhcmFtcykge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBjb25zdCBudW1iZXJPZlBhcmFtcyA9IHR5cGUubnVtYmVyT2ZQYXJhbXM7XG4gICAgICAgIHN3aXRjaCAobnVtYmVyT2ZQYXJhbXMpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY29tcHV0ZVNpbmdsZVBhcmFtKHR5cGUucGFyYW1ldGVyU3RydWN0dXJlcywgcGFyYW1zWzBdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoICYmIGkgPCBudW1iZXJPZlBhcmFtczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHVuZGVmaW5lZFRvTnVsbChwYXJhbXNbaV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPCBudW1iZXJPZlBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gcGFyYW1zLmxlbmd0aDsgaSA8IG51bWJlck9mUGFyYW1zOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB7XG4gICAgICAgIHNlbmROb3RpZmljYXRpb246ICh0eXBlLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICB0aHJvd0lmQ2xvc2VkT3JEaXNwb3NlZCgpO1xuICAgICAgICAgICAgbGV0IG1ldGhvZDtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlUGFyYW1zO1xuICAgICAgICAgICAgaWYgKElzLnN0cmluZyh0eXBlKSkge1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9IHR5cGU7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIGxldCBwYXJhbVN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1ldGVyU3RydWN0dXJlcyA9IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuaXMoZmlyc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtU3RhcnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gZmlyc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBwYXJhbUVuZCA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bWJlck9mUGFyYW1zID0gcGFyYW1FbmQgLSBwYXJhbVN0YXJ0O1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobnVtYmVyT2ZQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gY29tcHV0ZVNpbmdsZVBhcmFtKHBhcmFtZXRlclN0cnVjdHVyZXMsIGFyZ3NbcGFyYW1TdGFydF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1ldGVyU3RydWN0dXJlcyA9PT0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVjZWl2ZWQgJHtudW1iZXJPZlBhcmFtc30gcGFyYW1ldGVycyBmb3IgJ2J5IE5hbWUnIG5vdGlmaWNhdGlvbiBwYXJhbWV0ZXIgc3RydWN0dXJlLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IGFyZ3Muc2xpY2UocGFyYW1TdGFydCwgcGFyYW1FbmQpLm1hcCh2YWx1ZSA9PiB1bmRlZmluZWRUb051bGwodmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZS5tZXRob2Q7XG4gICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IGNvbXB1dGVNZXNzYWdlUGFyYW1zKHR5cGUsIHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub3RpZmljYXRpb25NZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGpzb25ycGM6IHZlcnNpb24sXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBtZXNzYWdlUGFyYW1zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJhY2VTZW5kaW5nTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbk1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VXcml0ZXIud3JpdGUobm90aWZpY2F0aW9uTWVzc2FnZSkuY2F0Y2goKCkgPT4gbG9nZ2VyLmVycm9yKGBTZW5kaW5nIG5vdGlmaWNhdGlvbiBmYWlsZWQuYCkpO1xuICAgICAgICB9LFxuICAgICAgICBvbk5vdGlmaWNhdGlvbjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCk7XG4gICAgICAgICAgICBsZXQgbWV0aG9kO1xuICAgICAgICAgICAgaWYgKElzLmZ1bmModHlwZSkpIHtcbiAgICAgICAgICAgICAgICBzdGFyTm90aWZpY2F0aW9uSGFuZGxlciA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKElzLnN0cmluZyh0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVycy5zZXQodHlwZSwgeyB0eXBlOiB1bmRlZmluZWQsIGhhbmRsZXIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlLm1ldGhvZDtcbiAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlcnMuc2V0KHR5cGUubWV0aG9kLCB7IHR5cGUsIGhhbmRsZXIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlcnMuZGVsZXRlKG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFyTm90aWZpY2F0aW9uSGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIG9uUHJvZ3Jlc3M6IChfdHlwZSwgdG9rZW4sIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChwcm9ncmVzc0hhbmRsZXJzLmhhcyh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb2dyZXNzIGhhbmRsZXIgZm9yIHRva2VuICR7dG9rZW59IGFscmVhZHkgcmVnaXN0ZXJlZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvZ3Jlc3NIYW5kbGVycy5zZXQodG9rZW4sIGhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzSGFuZGxlcnMuZGVsZXRlKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBzZW5kUHJvZ3Jlc3M6IChfdHlwZSwgdG9rZW4sIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5zZW5kTm90aWZpY2F0aW9uKFByb2dyZXNzTm90aWZpY2F0aW9uLnR5cGUsIHsgdG9rZW4sIHZhbHVlIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvblVuaGFuZGxlZFByb2dyZXNzOiB1bmhhbmRsZWRQcm9ncmVzc0VtaXR0ZXIuZXZlbnQsXG4gICAgICAgIHNlbmRSZXF1ZXN0OiAodHlwZSwgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgdGhyb3dJZkNsb3NlZE9yRGlzcG9zZWQoKTtcbiAgICAgICAgICAgIHRocm93SWZOb3RMaXN0ZW5pbmcoKTtcbiAgICAgICAgICAgIGxldCBtZXRob2Q7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZVBhcmFtcztcbiAgICAgICAgICAgIGxldCB0b2tlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChJcy5zdHJpbmcodHlwZSkpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0ID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGxldCBwYXJhbVN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1ldGVyU3RydWN0dXJlcyA9IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuaXMoZmlyc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtU3RhcnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gZmlyc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBwYXJhbUVuZCA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChjYW5jZWxsYXRpb25fMS5DYW5jZWxsYXRpb25Ub2tlbi5pcyhsYXN0KSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbUVuZCA9IHBhcmFtRW5kIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBsYXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBudW1iZXJPZlBhcmFtcyA9IHBhcmFtRW5kIC0gcGFyYW1TdGFydDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG51bWJlck9mUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IGNvbXB1dGVTaW5nbGVQYXJhbShwYXJhbWV0ZXJTdHJ1Y3R1cmVzLCBhcmdzW3BhcmFtU3RhcnRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtZXRlclN0cnVjdHVyZXMgPT09IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlY2VpdmVkICR7bnVtYmVyT2ZQYXJhbXN9IHBhcmFtZXRlcnMgZm9yICdieSBOYW1lJyByZXF1ZXN0IHBhcmFtZXRlciBzdHJ1Y3R1cmUuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gYXJncy5zbGljZShwYXJhbVN0YXJ0LCBwYXJhbUVuZCkubWFwKHZhbHVlID0+IHVuZGVmaW5lZFRvTnVsbCh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gYXJncztcbiAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlLm1ldGhvZDtcbiAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gY29tcHV0ZU1lc3NhZ2VQYXJhbXModHlwZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBjb25zdCBudW1iZXJPZlBhcmFtcyA9IHR5cGUubnVtYmVyT2ZQYXJhbXM7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBjYW5jZWxsYXRpb25fMS5DYW5jZWxsYXRpb25Ub2tlbi5pcyhwYXJhbXNbbnVtYmVyT2ZQYXJhbXNdKSA/IHBhcmFtc1tudW1iZXJPZlBhcmFtc10gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpZCA9IHNlcXVlbmNlTnVtYmVyKys7XG4gICAgICAgICAgICBsZXQgZGlzcG9zYWJsZTtcbiAgICAgICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2FibGUgPSB0b2tlbi5vbkNhbmNlbGxhdGlvblJlcXVlc3RlZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBjYW5jZWxsYXRpb25TdHJhdGVneS5zZW5kZXIuc2VuZENhbmNlbGxhdGlvbihjb25uZWN0aW9uLCBpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYFJlY2VpdmVkIG5vIHByb21pc2UgZnJvbSBjYW5jZWxsYXRpb24gc3RyYXRlZ3kgd2hlbiBjYW5jZWxsaW5nIGlkICR7aWR9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgU2VuZGluZyBjYW5jZWxsYXRpb24gbWVzc2FnZXMgZm9yIGlkICR7aWR9IGZhaWxlZGApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0TWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICAgICAganNvbnJwYzogdmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBtZXNzYWdlUGFyYW1zXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlV2l0aENsZWFudXAgPSAocikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHIpO1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25TdHJhdGVneS5zZW5kZXIuY2xlYW51cChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FibGU/LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlamVjdFdpdGhDbGVhbnVwID0gKHIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHIpO1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25TdHJhdGVneS5zZW5kZXIuY2xlYW51cChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FibGU/LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGxldCByZXNwb25zZVByb21pc2UgPSB7IG1ldGhvZDogbWV0aG9kLCB0aW1lclN0YXJ0OiBEYXRlLm5vdygpLCByZXNvbHZlOiByZXNvbHZlV2l0aENsZWFudXAsIHJlamVjdDogcmVqZWN0V2l0aENsZWFudXAgfTtcbiAgICAgICAgICAgICAgICB0cmFjZVNlbmRpbmdSZXF1ZXN0KHJlcXVlc3RNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlV3JpdGVyLndyaXRlKHJlcXVlc3RNZXNzYWdlKS5jYXRjaCgoKSA9PiBsb2dnZXIuZXJyb3IoYFNlbmRpbmcgcmVxdWVzdCBmYWlsZWQuYCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXcml0aW5nIHRoZSBtZXNzYWdlIGZhaWxlZC4gU28gd2UgbmVlZCB0byByZWplY3QgdGhlIHByb21pc2UuXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZWplY3QobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuTWVzc2FnZVdyaXRlRXJyb3IsIGUubWVzc2FnZSA/IGUubWVzc2FnZSA6ICdVbmtub3duIHJlYXNvbicpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2VzLnNldChpZCwgcmVzcG9uc2VQcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUmVxdWVzdDogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCk7XG4gICAgICAgICAgICBsZXQgbWV0aG9kID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChTdGFyUmVxdWVzdEhhbmRsZXIuaXModHlwZSkpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgc3RhclJlcXVlc3RIYW5kbGVyID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKElzLnN0cmluZyh0eXBlKSkge1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SGFuZGxlcnMuc2V0KHR5cGUsIHsgaGFuZGxlcjogaGFuZGxlciwgdHlwZTogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZS5tZXRob2Q7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIYW5kbGVycy5zZXQodHlwZS5tZXRob2QsIHsgdHlwZSwgaGFuZGxlciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhhbmRsZXJzLmRlbGV0ZShtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhclJlcXVlc3RIYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzUGVuZGluZ1Jlc3BvbnNlOiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VQcm9taXNlcy5zaXplID4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhY2U6IGFzeW5jIChfdmFsdWUsIF90cmFjZXIsIHNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgbGV0IF9zZW5kTm90aWZpY2F0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgX3RyYWNlRm9ybWF0ID0gVHJhY2VGb3JtYXQuVGV4dDtcbiAgICAgICAgICAgIGlmIChzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChJcy5ib29sZWFuKHNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgX3NlbmROb3RpZmljYXRpb24gPSBzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfc2VuZE5vdGlmaWNhdGlvbiA9IHNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucy5zZW5kTm90aWZpY2F0aW9uIHx8IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBfdHJhY2VGb3JtYXQgPSBzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMudHJhY2VGb3JtYXQgfHwgVHJhY2VGb3JtYXQuVGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZSA9IF92YWx1ZTtcbiAgICAgICAgICAgIHRyYWNlRm9ybWF0ID0gX3RyYWNlRm9ybWF0O1xuICAgICAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYpIHtcbiAgICAgICAgICAgICAgICB0cmFjZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFjZXIgPSBfdHJhY2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9zZW5kTm90aWZpY2F0aW9uICYmICFpc0Nsb3NlZCgpICYmICFpc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uZWN0aW9uLnNlbmROb3RpZmljYXRpb24oU2V0VHJhY2VOb3RpZmljYXRpb24udHlwZSwgeyB2YWx1ZTogVHJhY2UudG9TdHJpbmcoX3ZhbHVlKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogZXJyb3JFbWl0dGVyLmV2ZW50LFxuICAgICAgICBvbkNsb3NlOiBjbG9zZUVtaXR0ZXIuZXZlbnQsXG4gICAgICAgIG9uVW5oYW5kbGVkTm90aWZpY2F0aW9uOiB1bmhhbmRsZWROb3RpZmljYXRpb25FbWl0dGVyLmV2ZW50LFxuICAgICAgICBvbkRpc3Bvc2U6IGRpc3Bvc2VFbWl0dGVyLmV2ZW50LFxuICAgICAgICBlbmQ6ICgpID0+IHtcbiAgICAgICAgICAgIG1lc3NhZ2VXcml0ZXIuZW5kKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZSA9IENvbm5lY3Rpb25TdGF0ZS5EaXNwb3NlZDtcbiAgICAgICAgICAgIGRpc3Bvc2VFbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuUGVuZGluZ1Jlc3BvbnNlUmVqZWN0ZWQsICdQZW5kaW5nIHJlc3BvbnNlIHJlamVjdGVkIHNpbmNlIGNvbm5lY3Rpb24gZ290IGRpc3Bvc2VkJyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb21pc2Ugb2YgcmVzcG9uc2VQcm9taXNlcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIHByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICByZXF1ZXN0VG9rZW5zID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAga25vd25DYW5jZWxlZFJlcXVlc3RzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgbWVzc2FnZVF1ZXVlID0gbmV3IGxpbmtlZE1hcF8xLkxpbmtlZE1hcCgpO1xuICAgICAgICAgICAgLy8gVGVzdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIGlmIChJcy5mdW5jKG1lc3NhZ2VXcml0ZXIuZGlzcG9zZSkpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlV3JpdGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChJcy5mdW5jKG1lc3NhZ2VSZWFkZXIuZGlzcG9zZSkpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlUmVhZGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbGlzdGVuOiAoKSA9PiB7XG4gICAgICAgICAgICB0aHJvd0lmQ2xvc2VkT3JEaXNwb3NlZCgpO1xuICAgICAgICAgICAgdGhyb3dJZkxpc3RlbmluZygpO1xuICAgICAgICAgICAgc3RhdGUgPSBDb25uZWN0aW9uU3RhdGUuTGlzdGVuaW5nO1xuICAgICAgICAgICAgbWVzc2FnZVJlYWRlci5saXN0ZW4oY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICBpbnNwZWN0OiAoKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgKDAsIHJhbF8xLmRlZmF1bHQpKCkuY29uc29sZS5sb2coJ2luc3BlY3QnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29ubmVjdGlvbi5vbk5vdGlmaWNhdGlvbihMb2dUcmFjZU5vdGlmaWNhdGlvbi50eXBlLCAocGFyYW1zKSA9PiB7XG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ZXJib3NlID0gdHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3Q7XG4gICAgICAgIHRyYWNlci5sb2cocGFyYW1zLm1lc3NhZ2UsIHZlcmJvc2UgPyBwYXJhbXMudmVyYm9zZSA6IHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gICAgY29ubmVjdGlvbi5vbk5vdGlmaWNhdGlvbihQcm9ncmVzc05vdGlmaWNhdGlvbi50eXBlLCAocGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBwcm9ncmVzc0hhbmRsZXJzLmdldChwYXJhbXMudG9rZW4pO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgaGFuZGxlcihwYXJhbXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdW5oYW5kbGVkUHJvZ3Jlc3NFbWl0dGVyLmZpcmUocGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb25uZWN0aW9uO1xufVxuZXhwb3J0cy5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiA9IGNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdGlvbi5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIDQyNTA6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5EaXNwb3NhYmxlID0gdm9pZCAwO1xudmFyIERpc3Bvc2FibGU7XG4oZnVuY3Rpb24gKERpc3Bvc2FibGUpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoZnVuYykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlzcG9zZTogZnVuY1xuICAgICAgICB9O1xuICAgIH1cbiAgICBEaXNwb3NhYmxlLmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKERpc3Bvc2FibGUgPSBleHBvcnRzLkRpc3Bvc2FibGUgfHwgKGV4cG9ydHMuRGlzcG9zYWJsZSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXNwb3NhYmxlLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzI1Nzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5FbWl0dGVyID0gZXhwb3J0cy5FdmVudCA9IHZvaWQgMDtcbmNvbnN0IHJhbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NDA2KTtcbnZhciBFdmVudDtcbihmdW5jdGlvbiAoRXZlbnQpIHtcbiAgICBjb25zdCBfZGlzcG9zYWJsZSA9IHsgZGlzcG9zZSgpIHsgfSB9O1xuICAgIEV2ZW50Lk5vbmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfZGlzcG9zYWJsZTsgfTtcbn0pKEV2ZW50ID0gZXhwb3J0cy5FdmVudCB8fCAoZXhwb3J0cy5FdmVudCA9IHt9KSk7XG5jbGFzcyBDYWxsYmFja0xpc3Qge1xuICAgIGFkZChjYWxsYmFjaywgY29udGV4dCA9IG51bGwsIGJ1Y2tldCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gW107XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5fY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYnVja2V0KSkge1xuICAgICAgICAgICAgYnVja2V0LnB1c2goeyBkaXNwb3NlOiAoKSA9PiB0aGlzLnJlbW92ZShjYWxsYmFjaywgY29udGV4dCkgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlKGNhbGxiYWNrLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmb3VuZENhbGxiYWNrV2l0aERpZmZlcmVudENvbnRleHQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuX2NhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NhbGxiYWNrc1tpXSA9PT0gY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29udGV4dHNbaV0gPT09IGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbGJhY2sgJiBjb250ZXh0IG1hdGNoID0+IHJlbW92ZSBpdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kQ2FsbGJhY2tXaXRoRGlmZmVyZW50Q29udGV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmb3VuZENhbGxiYWNrV2l0aERpZmZlcmVudENvbnRleHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2hlbiBhZGRpbmcgYSBsaXN0ZW5lciB3aXRoIGEgY29udGV4dCwgeW91IHNob3VsZCByZW1vdmUgaXQgd2l0aCB0aGUgc2FtZSBjb250ZXh0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW52b2tlKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSBbXSwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzLnNsaWNlKDApLCBjb250ZXh0cyA9IHRoaXMuX2NvbnRleHRzLnNsaWNlKDApO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKGNhbGxiYWNrc1tpXS5hcHBseShjb250ZXh0c1tpXSwgYXJncykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgICgwLCByYWxfMS5kZWZhdWx0KSgpLmNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9jYWxsYmFja3MgfHwgdGhpcy5fY2FsbGJhY2tzLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9jb250ZXh0cyA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG5jbGFzcyBFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihfb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gX29wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvciB0aGUgcHVibGljIHRvIGFsbG93IHRvIHN1YnNjcmliZVxuICAgICAqIHRvIGV2ZW50cyBmcm9tIHRoaXMgRW1pdHRlclxuICAgICAqL1xuICAgIGdldCBldmVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudCkge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnQgPSAobGlzdGVuZXIsIHRoaXNBcmdzLCBkaXNwb3NhYmxlcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IG5ldyBDYWxsYmFja0xpc3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMgJiYgdGhpcy5fb3B0aW9ucy5vbkZpcnN0TGlzdGVuZXJBZGQgJiYgdGhpcy5fY2FsbGJhY2tzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLm9uRmlyc3RMaXN0ZW5lckFkZCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLmFkZChsaXN0ZW5lciwgdGhpc0FyZ3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkaXNwb3NhYmxlIGlzIGRpc3Bvc2VkIGFmdGVyIGVtaXR0ZXIgaXMgZGlzcG9zZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLnJlbW92ZShsaXN0ZW5lciwgdGhpc0FyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmRpc3Bvc2UgPSBFbWl0dGVyLl9ub29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMgJiYgdGhpcy5fb3B0aW9ucy5vbkxhc3RMaXN0ZW5lclJlbW92ZSAmJiB0aGlzLl9jYWxsYmFja3MuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkxhc3RMaXN0ZW5lclJlbW92ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcG9zYWJsZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FibGVzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUbyBiZSBrZXB0IHByaXZhdGUgdG8gZmlyZSBhbiBldmVudCB0b1xuICAgICAqIHN1YnNjcmliZXJzXG4gICAgICovXG4gICAgZmlyZShldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MuaW52b2tlLmNhbGwodGhpcy5fY2FsbGJhY2tzLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRW1pdHRlciA9IEVtaXR0ZXI7XG5FbWl0dGVyLl9ub29wID0gZnVuY3Rpb24gKCkgeyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZlbnRzLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTI3ODpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5zdHJpbmdBcnJheSA9IGV4cG9ydHMuYXJyYXkgPSBleHBvcnRzLmZ1bmMgPSBleHBvcnRzLmVycm9yID0gZXhwb3J0cy5udW1iZXIgPSBleHBvcnRzLnN0cmluZyA9IGV4cG9ydHMuYm9vbGVhbiA9IHZvaWQgMDtcbmZ1bmN0aW9uIGJvb2xlYW4odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlO1xufVxuZXhwb3J0cy5ib29sZWFuID0gYm9vbGVhbjtcbmZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nO1xufVxuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG5mdW5jdGlvbiBudW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcjtcbn1cbmV4cG9ydHMubnVtYmVyID0gbnVtYmVyO1xuZnVuY3Rpb24gZXJyb3IodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFcnJvcjtcbn1cbmV4cG9ydHMuZXJyb3IgPSBlcnJvcjtcbmZ1bmN0aW9uIGZ1bmModmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5mdW5jID0gZnVuYztcbmZ1bmN0aW9uIGFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuZXhwb3J0cy5hcnJheSA9IGFycmF5O1xuZnVuY3Rpb24gc3RyaW5nQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gYXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KGVsZW0gPT4gc3RyaW5nKGVsZW0pKTtcbn1cbmV4cG9ydHMuc3RyaW5nQXJyYXkgPSBzdHJpbmdBcnJheTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTQxNDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xudmFyIF9hO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkxSVUNhY2hlID0gZXhwb3J0cy5MaW5rZWRNYXAgPSBleHBvcnRzLlRvdWNoID0gdm9pZCAwO1xudmFyIFRvdWNoO1xuKGZ1bmN0aW9uIChUb3VjaCkge1xuICAgIFRvdWNoLk5vbmUgPSAwO1xuICAgIFRvdWNoLkZpcnN0ID0gMTtcbiAgICBUb3VjaC5Bc09sZCA9IFRvdWNoLkZpcnN0O1xuICAgIFRvdWNoLkxhc3QgPSAyO1xuICAgIFRvdWNoLkFzTmV3ID0gVG91Y2guTGFzdDtcbn0pKFRvdWNoID0gZXhwb3J0cy5Ub3VjaCB8fCAoZXhwb3J0cy5Ub3VjaCA9IHt9KSk7XG5jbGFzcyBMaW5rZWRNYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzW19hXSA9ICdMaW5rZWRNYXAnO1xuICAgICAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2hlYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3RhaWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IDA7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLl9tYXAuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5faGVhZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fdGFpbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5faGVhZCAmJiAhdGhpcy5fdGFpbDtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgIH1cbiAgICBnZXQgZmlyc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFkPy52YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGxhc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YWlsPy52YWx1ZTtcbiAgICB9XG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyhrZXkpO1xuICAgIH1cbiAgICBnZXQoa2V5LCB0b3VjaCA9IFRvdWNoLk5vbmUpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3VjaCAhPT0gVG91Y2guTm9uZSkge1xuICAgICAgICAgICAgdGhpcy50b3VjaChpdGVtLCB0b3VjaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW0udmFsdWU7XG4gICAgfVxuICAgIHNldChrZXksIHZhbHVlLCB0b3VjaCA9IFRvdWNoLk5vbmUpIHtcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBpdGVtLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAodG91Y2ggIT09IFRvdWNoLk5vbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvdWNoKGl0ZW0sIHRvdWNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0gPSB7IGtleSwgdmFsdWUsIG5leHQ6IHVuZGVmaW5lZCwgcHJldmlvdXM6IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgc3dpdGNoICh0b3VjaCkge1xuICAgICAgICAgICAgICAgIGNhc2UgVG91Y2guTm9uZTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRJdGVtTGFzdChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBUb3VjaC5GaXJzdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRJdGVtRmlyc3QoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVG91Y2guTGFzdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRJdGVtTGFzdChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRJdGVtTGFzdChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tYXAuc2V0KGtleSwgaXRlbSk7XG4gICAgICAgICAgICB0aGlzLl9zaXplKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5yZW1vdmUoa2V5KTtcbiAgICB9XG4gICAgcmVtb3ZlKGtleSkge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICB0aGlzLnJlbW92ZUl0ZW0oaXRlbSk7XG4gICAgICAgIHRoaXMuX3NpemUtLTtcbiAgICAgICAgcmV0dXJuIGl0ZW0udmFsdWU7XG4gICAgfVxuICAgIHNoaWZ0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2hlYWQgJiYgIXRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkIHx8ICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9oZWFkO1xuICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGl0ZW0ua2V5KTtcbiAgICAgICAgdGhpcy5yZW1vdmVJdGVtKGl0ZW0pO1xuICAgICAgICB0aGlzLl9zaXplLS07XG4gICAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgIH1cbiAgICBmb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXNBcmcpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja2ZuLmJpbmQodGhpc0FyZykoY3VycmVudC52YWx1ZSwgY3VycmVudC5rZXksIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tmbihjdXJyZW50LnZhbHVlLCBjdXJyZW50LmtleSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgIT09IHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaW5rZWRNYXAgZ290IG1vZGlmaWVkIGR1cmluZyBpdGVyYXRpb24uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5faGVhZDtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB7XG4gICAgICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExpbmtlZE1hcCBnb3QgbW9kaWZpZWQgZHVyaW5nIGl0ZXJhdGlvbi5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyB2YWx1ZTogY3VycmVudC5rZXksIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgfVxuICAgIHZhbHVlcygpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHtcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgIT09IHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGlua2VkTWFwIGdvdCBtb2RpZmllZCBkdXJpbmcgaXRlcmF0aW9uLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHZhbHVlOiBjdXJyZW50LnZhbHVlLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgIH1cbiAgICBlbnRyaWVzKCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0ge1xuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl06ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaW5rZWRNYXAgZ290IG1vZGlmaWVkIGR1cmluZyBpdGVyYXRpb24uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgdmFsdWU6IFtjdXJyZW50LmtleSwgY3VycmVudC52YWx1ZV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgfVxuICAgIFsoX2EgPSBTeW1ib2wudG9TdHJpbmdUYWcsIFN5bWJvbC5pdGVyYXRvcildKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG4gICAgfVxuICAgIHRyaW1PbGQobmV3U2l6ZSkge1xuICAgICAgICBpZiAobmV3U2l6ZSA+PSB0aGlzLnNpemUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3U2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5faGVhZDtcbiAgICAgICAgbGV0IGN1cnJlbnRTaXplID0gdGhpcy5zaXplO1xuICAgICAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50U2l6ZSA+IG5ld1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5kZWxldGUoY3VycmVudC5rZXkpO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgIGN1cnJlbnRTaXplLS07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGVhZCA9IGN1cnJlbnQ7XG4gICAgICAgIHRoaXMuX3NpemUgPSBjdXJyZW50U2l6ZTtcbiAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGN1cnJlbnQucHJldmlvdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICB9XG4gICAgYWRkSXRlbUZpcnN0KGl0ZW0pIHtcbiAgICAgICAgLy8gRmlyc3QgdGltZSBJbnNlcnRcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkICYmICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5faGVhZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0ubmV4dCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgICAgICB0aGlzLl9oZWFkLnByZXZpb3VzID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oZWFkID0gaXRlbTtcbiAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICB9XG4gICAgYWRkSXRlbUxhc3QoaXRlbSkge1xuICAgICAgICAvLyBGaXJzdCB0aW1lIEluc2VydFxuICAgICAgICBpZiAoIXRoaXMuX2hlYWQgJiYgIXRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXRlbS5wcmV2aW91cyA9IHRoaXMuX3RhaWw7XG4gICAgICAgICAgICB0aGlzLl90YWlsLm5leHQgPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RhaWwgPSBpdGVtO1xuICAgICAgICB0aGlzLl9zdGF0ZSsrO1xuICAgIH1cbiAgICByZW1vdmVJdGVtKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0gPT09IHRoaXMuX2hlYWQgJiYgaXRlbSA9PT0gdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXRlbSA9PT0gdGhpcy5faGVhZCkge1xuICAgICAgICAgICAgLy8gVGhpcyBjYW4gb25seSBoYXBwZW5lZCBpZiBzaXplID09PSAxIHdoaWNoIGlzIGhhbmRsZVxuICAgICAgICAgICAgLy8gYnkgdGhlIGNhc2UgYWJvdmUuXG4gICAgICAgICAgICBpZiAoIWl0ZW0ubmV4dCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtLm5leHQucHJldmlvdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gaXRlbS5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGl0ZW0gPT09IHRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuZWQgaWYgc2l6ZSA9PT0gMSB3aGljaCBpcyBoYW5kbGVcbiAgICAgICAgICAgIC8vIGJ5IHRoZSBjYXNlIGFib3ZlLlxuICAgICAgICAgICAgaWYgKCFpdGVtLnByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwgPSBpdGVtLnByZXZpb3VzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGl0ZW0ubmV4dDtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gaXRlbS5wcmV2aW91cztcbiAgICAgICAgICAgIGlmICghbmV4dCB8fCAhcHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dC5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgICAgICAgICAgcHJldmlvdXMubmV4dCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaXRlbS5uZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpdGVtLnByZXZpb3VzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9zdGF0ZSsrO1xuICAgIH1cbiAgICB0b3VjaChpdGVtLCB0b3VjaCkge1xuICAgICAgICBpZiAoIXRoaXMuX2hlYWQgfHwgIXRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0b3VjaCAhPT0gVG91Y2guRmlyc3QgJiYgdG91Y2ggIT09IFRvdWNoLkxhc3QpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvdWNoID09PSBUb3VjaC5GaXJzdCkge1xuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IHRoaXMuX2hlYWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gaXRlbS5uZXh0O1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXMgPSBpdGVtLnByZXZpb3VzO1xuICAgICAgICAgICAgLy8gVW5saW5rIHRoZSBpdGVtXG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzIG11c3QgYmUgZGVmaW5lZCBzaW5jZSBpdGVtIHdhcyBub3QgaGVhZCBidXQgaXMgdGFpbFxuICAgICAgICAgICAgICAgIC8vIFNvIHRoZXJlIGFyZSBtb3JlIHRoYW4gb24gaXRlbSBpbiB0aGUgbWFwXG4gICAgICAgICAgICAgICAgcHJldmlvdXMubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLl90YWlsID0gcHJldmlvdXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBCb3RoIG5leHQgYW5kIHByZXZpb3VzIGFyZSBub3QgdW5kZWZpbmVkIHNpbmNlIGl0ZW0gd2FzIG5laXRoZXIgaGVhZCBub3IgdGFpbC5cbiAgICAgICAgICAgICAgICBuZXh0LnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgICAgICAgICAgICAgcHJldmlvdXMubmV4dCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbnNlcnQgdGhlIG5vZGUgYXQgaGVhZFxuICAgICAgICAgICAgaXRlbS5wcmV2aW91cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGl0ZW0ubmV4dCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgICAgICB0aGlzLl9oZWFkLnByZXZpb3VzID0gaXRlbTtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSBpdGVtO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0b3VjaCA9PT0gVG91Y2guTGFzdCkge1xuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IHRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gaXRlbS5uZXh0O1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXMgPSBpdGVtLnByZXZpb3VzO1xuICAgICAgICAgICAgLy8gVW5saW5rIHRoZSBpdGVtLlxuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IHRoaXMuX2hlYWQpIHtcbiAgICAgICAgICAgICAgICAvLyBuZXh0IG11c3QgYmUgZGVmaW5lZCBzaW5jZSBpdGVtIHdhcyBub3QgdGFpbCBidXQgaXMgaGVhZFxuICAgICAgICAgICAgICAgIC8vIFNvIHRoZXJlIGFyZSBtb3JlIHRoYW4gb24gaXRlbSBpbiB0aGUgbWFwXG4gICAgICAgICAgICAgICAgbmV4dC5wcmV2aW91cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFkID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEJvdGggbmV4dCBhbmQgcHJldmlvdXMgYXJlIG5vdCB1bmRlZmluZWQgc2luY2UgaXRlbSB3YXMgbmVpdGhlciBoZWFkIG5vciB0YWlsLlxuICAgICAgICAgICAgICAgIG5leHQucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICAgICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW0ubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMgPSB0aGlzLl90YWlsO1xuICAgICAgICAgICAgdGhpcy5fdGFpbC5uZXh0ID0gaXRlbTtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwgPSBpdGVtO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBmcm9tSlNPTihkYXRhKSB7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkxpbmtlZE1hcCA9IExpbmtlZE1hcDtcbmNsYXNzIExSVUNhY2hlIGV4dGVuZHMgTGlua2VkTWFwIHtcbiAgICBjb25zdHJ1Y3RvcihsaW1pdCwgcmF0aW8gPSAxKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2xpbWl0ID0gbGltaXQ7XG4gICAgICAgIHRoaXMuX3JhdGlvID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgcmF0aW8pLCAxKTtcbiAgICB9XG4gICAgZ2V0IGxpbWl0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGltaXQ7XG4gICAgfVxuICAgIHNldCBsaW1pdChsaW1pdCkge1xuICAgICAgICB0aGlzLl9saW1pdCA9IGxpbWl0O1xuICAgICAgICB0aGlzLmNoZWNrVHJpbSgpO1xuICAgIH1cbiAgICBnZXQgcmF0aW8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yYXRpbztcbiAgICB9XG4gICAgc2V0IHJhdGlvKHJhdGlvKSB7XG4gICAgICAgIHRoaXMuX3JhdGlvID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgcmF0aW8pLCAxKTtcbiAgICAgICAgdGhpcy5jaGVja1RyaW0oKTtcbiAgICB9XG4gICAgZ2V0KGtleSwgdG91Y2ggPSBUb3VjaC5Bc05ldykge1xuICAgICAgICByZXR1cm4gc3VwZXIuZ2V0KGtleSwgdG91Y2gpO1xuICAgIH1cbiAgICBwZWVrKGtleSkge1xuICAgICAgICByZXR1cm4gc3VwZXIuZ2V0KGtleSwgVG91Y2guTm9uZSk7XG4gICAgfVxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyLnNldChrZXksIHZhbHVlLCBUb3VjaC5MYXN0KTtcbiAgICAgICAgdGhpcy5jaGVja1RyaW0oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNoZWNrVHJpbSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSA+IHRoaXMuX2xpbWl0KSB7XG4gICAgICAgICAgICB0aGlzLnRyaW1PbGQoTWF0aC5yb3VuZCh0aGlzLl9saW1pdCAqIHRoaXMuX3JhdGlvKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkxSVUNhY2hlID0gTFJVQ2FjaGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW5rZWRNYXAuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1OTQ3OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlQnVmZmVyID0gdm9pZCAwO1xuY29uc3QgQ1IgPSAxMztcbmNvbnN0IExGID0gMTA7XG5jb25zdCBDUkxGID0gJ1xcclxcbic7XG5jbGFzcyBBYnN0cmFjdE1lc3NhZ2VCdWZmZXIge1xuICAgIGNvbnN0cnVjdG9yKGVuY29kaW5nID0gJ3V0Zi04Jykge1xuICAgICAgICB0aGlzLl9lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgICAgICB0aGlzLl9jaHVua3MgPSBbXTtcbiAgICAgICAgdGhpcy5fdG90YWxMZW5ndGggPSAwO1xuICAgIH1cbiAgICBnZXQgZW5jb2RpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmNvZGluZztcbiAgICB9XG4gICAgYXBwZW5kKGNodW5rKSB7XG4gICAgICAgIGNvbnN0IHRvQXBwZW5kID0gdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJyA/IHRoaXMuZnJvbVN0cmluZyhjaHVuaywgdGhpcy5fZW5jb2RpbmcpIDogY2h1bms7XG4gICAgICAgIHRoaXMuX2NodW5rcy5wdXNoKHRvQXBwZW5kKTtcbiAgICAgICAgdGhpcy5fdG90YWxMZW5ndGggKz0gdG9BcHBlbmQuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgdHJ5UmVhZEhlYWRlcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGF0ZSA9IDA7XG4gICAgICAgIGxldCBjaHVua0luZGV4ID0gMDtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGxldCBjaHVua0J5dGVzUmVhZCA9IDA7XG4gICAgICAgIHJvdzogd2hpbGUgKGNodW5rSW5kZXggPCB0aGlzLl9jaHVua3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2NodW5rc1tjaHVua0luZGV4XTtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICBjb2x1bW46IHdoaWxlIChvZmZzZXQgPCBjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNodW5rW29mZnNldF07XG4gICAgICAgICAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENSOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTEY6XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgcm93O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNodW5rQnl0ZXNSZWFkICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBjaHVua0luZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlICE9PSA0KSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBidWZmZXIgY29udGFpbnMgdGhlIHR3byBDUkxGIGF0IHRoZSBlbmQuIFNvIHdlIHdpbGxcbiAgICAgICAgLy8gaGF2ZSB0d28gZW1wdHkgbGluZXMgYWZ0ZXIgdGhlIHNwbGl0IGF0IHRoZSBlbmQgYXMgd2VsbC5cbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5fcmVhZChjaHVua0J5dGVzUmVhZCArIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMudG9TdHJpbmcoYnVmZmVyLCAnYXNjaWknKS5zcGxpdChDUkxGKTtcbiAgICAgICAgaWYgKGhlYWRlcnMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXIgPSBoZWFkZXJzW2ldO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBoZWFkZXIuaW5kZXhPZignOicpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWVzc2FnZSBoZWFkZXIgbXVzdCBzZXBhcmF0ZSBrZXkgYW5kIHZhbHVlIHVzaW5nIDonKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGhlYWRlci5zdWJzdHIoMCwgaW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBoZWFkZXIuc3Vic3RyKGluZGV4ICsgMSkudHJpbSgpO1xuICAgICAgICAgICAgcmVzdWx0LnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0cnlSZWFkQm9keShsZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RvdGFsTGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkKGxlbmd0aCk7XG4gICAgfVxuICAgIGdldCBudW1iZXJPZkJ5dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG90YWxMZW5ndGg7XG4gICAgfVxuICAgIF9yZWFkKGJ5dGVDb3VudCkge1xuICAgICAgICBpZiAoYnl0ZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbXB0eUJ1ZmZlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChieXRlQ291bnQgPiB0aGlzLl90b3RhbExlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVhZCBzbyBtYW55IGJ5dGVzIWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jaHVua3NbMF0uYnl0ZUxlbmd0aCA9PT0gYnl0ZUNvdW50KSB7XG4gICAgICAgICAgICAvLyBzdXBlciBmYXN0IHBhdGgsIHByZWNpc2VseSBmaXJzdCBjaHVuayBtdXN0IGJlIHJldHVybmVkXG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2NodW5rc1swXTtcbiAgICAgICAgICAgIHRoaXMuX2NodW5rcy5zaGlmdCgpO1xuICAgICAgICAgICAgdGhpcy5fdG90YWxMZW5ndGggLT0gYnl0ZUNvdW50O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXNOYXRpdmUoY2h1bmspO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jaHVua3NbMF0uYnl0ZUxlbmd0aCA+IGJ5dGVDb3VudCkge1xuICAgICAgICAgICAgLy8gZmFzdCBwYXRoLCB0aGUgcmVhZGluZyBpcyBlbnRpcmVseSB3aXRoaW4gdGhlIGZpcnN0IGNodW5rXG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2NodW5rc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYXNOYXRpdmUoY2h1bmssIGJ5dGVDb3VudCk7XG4gICAgICAgICAgICB0aGlzLl9jaHVua3NbMF0gPSBjaHVuay5zbGljZShieXRlQ291bnQpO1xuICAgICAgICAgICAgdGhpcy5fdG90YWxMZW5ndGggLT0gYnl0ZUNvdW50O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmFsbG9jTmF0aXZlKGJ5dGVDb3VudCk7XG4gICAgICAgIGxldCByZXN1bHRPZmZzZXQgPSAwO1xuICAgICAgICBsZXQgY2h1bmtJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChieXRlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2NodW5rc1tjaHVua0luZGV4XTtcbiAgICAgICAgICAgIGlmIChjaHVuay5ieXRlTGVuZ3RoID4gYnl0ZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjaHVuayB3aWxsIHN1cnZpdmVcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVua1BhcnQgPSBjaHVuay5zbGljZSgwLCBieXRlQ291bnQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoY2h1bmtQYXJ0LCByZXN1bHRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdE9mZnNldCArPSBieXRlQ291bnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2h1bmtzW2NodW5rSW5kZXhdID0gY2h1bmsuc2xpY2UoYnl0ZUNvdW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLl90b3RhbExlbmd0aCAtPSBieXRlQ291bnQ7XG4gICAgICAgICAgICAgICAgYnl0ZUNvdW50IC09IGJ5dGVDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgY2h1bmsgd2lsbCBiZSBlbnRpcmVseSByZWFkXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChjaHVuaywgcmVzdWx0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICByZXN1bHRPZmZzZXQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaHVua3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90b3RhbExlbmd0aCAtPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJ5dGVDb3VudCAtPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VCdWZmZXIgPSBBYnN0cmFjdE1lc3NhZ2VCdWZmZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXNzYWdlQnVmZmVyLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjA3OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLlJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlciA9IGV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5NZXNzYWdlUmVhZGVyID0gdm9pZCAwO1xuY29uc3QgcmFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0MDYpO1xuY29uc3QgSXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNzgpO1xuY29uc3QgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyNTcpO1xudmFyIE1lc3NhZ2VSZWFkZXI7XG4oZnVuY3Rpb24gKE1lc3NhZ2VSZWFkZXIpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuZnVuYyhjYW5kaWRhdGUubGlzdGVuKSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5kaXNwb3NlKSAmJlxuICAgICAgICAgICAgSXMuZnVuYyhjYW5kaWRhdGUub25FcnJvcikgJiYgSXMuZnVuYyhjYW5kaWRhdGUub25DbG9zZSkgJiYgSXMuZnVuYyhjYW5kaWRhdGUub25QYXJ0aWFsTWVzc2FnZSk7XG4gICAgfVxuICAgIE1lc3NhZ2VSZWFkZXIuaXMgPSBpcztcbn0pKE1lc3NhZ2VSZWFkZXIgPSBleHBvcnRzLk1lc3NhZ2VSZWFkZXIgfHwgKGV4cG9ydHMuTWVzc2FnZVJlYWRlciA9IHt9KSk7XG5jbGFzcyBBYnN0cmFjdE1lc3NhZ2VSZWFkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVycm9yRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuY2xvc2VFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZUVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLmVycm9yRW1pdHRlci5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuY2xvc2VFbWl0dGVyLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgZ2V0IG9uRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yRW1pdHRlci5ldmVudDtcbiAgICB9XG4gICAgZmlyZUVycm9yKGVycm9yKSB7XG4gICAgICAgIHRoaXMuZXJyb3JFbWl0dGVyLmZpcmUodGhpcy5hc0Vycm9yKGVycm9yKSk7XG4gICAgfVxuICAgIGdldCBvbkNsb3NlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9zZUVtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGZpcmVDbG9zZSgpIHtcbiAgICAgICAgdGhpcy5jbG9zZUVtaXR0ZXIuZmlyZSh1bmRlZmluZWQpO1xuICAgIH1cbiAgICBnZXQgb25QYXJ0aWFsTWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFydGlhbE1lc3NhZ2VFbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBmaXJlUGFydGlhbE1lc3NhZ2UoaW5mbykge1xuICAgICAgICB0aGlzLnBhcnRpYWxNZXNzYWdlRW1pdHRlci5maXJlKGluZm8pO1xuICAgIH1cbiAgICBhc0Vycm9yKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKGBSZWFkZXIgcmVjZWl2ZWQgZXJyb3IuIFJlYXNvbjogJHtJcy5zdHJpbmcoZXJyb3IubWVzc2FnZSkgPyBlcnJvci5tZXNzYWdlIDogJ3Vua25vd24nfWApO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VSZWFkZXIgPSBBYnN0cmFjdE1lc3NhZ2VSZWFkZXI7XG52YXIgUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucztcbihmdW5jdGlvbiAoUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGZyb21PcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGNoYXJzZXQ7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGxldCBjb250ZW50RGVjb2RlcjtcbiAgICAgICAgY29uc3QgY29udGVudERlY29kZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICBsZXQgY29udGVudFR5cGVEZWNvZGVyO1xuICAgICAgICBjb25zdCBjb250ZW50VHlwZURlY29kZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY2hhcnNldCA9IG9wdGlvbnMgPz8gJ3V0Zi04JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoYXJzZXQgPSBvcHRpb25zLmNoYXJzZXQgPz8gJ3V0Zi04JztcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbnRlbnREZWNvZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50RGVjb2RlciA9IG9wdGlvbnMuY29udGVudERlY29kZXI7XG4gICAgICAgICAgICAgICAgY29udGVudERlY29kZXJzLnNldChjb250ZW50RGVjb2Rlci5uYW1lLCBjb250ZW50RGVjb2Rlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb250ZW50RGVjb2RlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZGVjb2RlciBvZiBvcHRpb25zLmNvbnRlbnREZWNvZGVycykge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50RGVjb2RlcnMuc2V0KGRlY29kZXIubmFtZSwgZGVjb2Rlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29udGVudFR5cGVEZWNvZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZURlY29kZXIgPSBvcHRpb25zLmNvbnRlbnRUeXBlRGVjb2RlcjtcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZURlY29kZXJzLnNldChjb250ZW50VHlwZURlY29kZXIubmFtZSwgY29udGVudFR5cGVEZWNvZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbnRlbnRUeXBlRGVjb2RlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZGVjb2RlciBvZiBvcHRpb25zLmNvbnRlbnRUeXBlRGVjb2RlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGVEZWNvZGVycy5zZXQoZGVjb2Rlci5uYW1lLCBkZWNvZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlRGVjb2RlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb250ZW50VHlwZURlY29kZXIgPSAoMCwgcmFsXzEuZGVmYXVsdCkoKS5hcHBsaWNhdGlvbkpzb24uZGVjb2RlcjtcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlRGVjb2RlcnMuc2V0KGNvbnRlbnRUeXBlRGVjb2Rlci5uYW1lLCBjb250ZW50VHlwZURlY29kZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNoYXJzZXQsIGNvbnRlbnREZWNvZGVyLCBjb250ZW50RGVjb2RlcnMsIGNvbnRlbnRUeXBlRGVjb2RlciwgY29udGVudFR5cGVEZWNvZGVycyB9O1xuICAgIH1cbiAgICBSZXNvbHZlZE1lc3NhZ2VSZWFkZXJPcHRpb25zLmZyb21PcHRpb25zID0gZnJvbU9wdGlvbnM7XG59KShSZXNvbHZlZE1lc3NhZ2VSZWFkZXJPcHRpb25zIHx8IChSZXNvbHZlZE1lc3NhZ2VSZWFkZXJPcHRpb25zID0ge30pKTtcbmNsYXNzIFJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlciBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVJlYWRlciB7XG4gICAgY29uc3RydWN0b3IocmVhZGFibGUsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5yZWFkYWJsZSA9IHJlYWRhYmxlO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBSZXNvbHZlZE1lc3NhZ2VSZWFkZXJPcHRpb25zLmZyb21PcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9ICgwLCByYWxfMS5kZWZhdWx0KSgpLm1lc3NhZ2VCdWZmZXIuY3JlYXRlKHRoaXMub3B0aW9ucy5jaGFyc2V0KTtcbiAgICAgICAgdGhpcy5fcGFydGlhbE1lc3NhZ2VUaW1lb3V0ID0gMTAwMDA7XG4gICAgICAgIHRoaXMubmV4dE1lc3NhZ2VMZW5ndGggPSAtMTtcbiAgICAgICAgdGhpcy5tZXNzYWdlVG9rZW4gPSAwO1xuICAgIH1cbiAgICBzZXQgcGFydGlhbE1lc3NhZ2VUaW1lb3V0KHRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5fcGFydGlhbE1lc3NhZ2VUaW1lb3V0ID0gdGltZW91dDtcbiAgICB9XG4gICAgZ2V0IHBhcnRpYWxNZXNzYWdlVGltZW91dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnRpYWxNZXNzYWdlVGltZW91dDtcbiAgICB9XG4gICAgbGlzdGVuKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMubmV4dE1lc3NhZ2VMZW5ndGggPSAtMTtcbiAgICAgICAgdGhpcy5tZXNzYWdlVG9rZW4gPSAwO1xuICAgICAgICB0aGlzLnBhcnRpYWxNZXNzYWdlVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZWFkYWJsZS5vbkRhdGEoKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25EYXRhKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWFkYWJsZS5vbkVycm9yKChlcnJvcikgPT4gdGhpcy5maXJlRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgdGhpcy5yZWFkYWJsZS5vbkNsb3NlKCgpID0+IHRoaXMuZmlyZUNsb3NlKCkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBvbkRhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLmJ1ZmZlci5hcHBlbmQoZGF0YSk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0TWVzc2FnZUxlbmd0aCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5idWZmZXIudHJ5UmVhZEhlYWRlcnMoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gaGVhZGVycy5nZXQoJ0NvbnRlbnQtTGVuZ3RoJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFjb250ZW50TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSGVhZGVyIG11c3QgcHJvdmlkZSBhIENvbnRlbnQtTGVuZ3RoIHByb3BlcnR5LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChjb250ZW50TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4obGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRlbnQtTGVuZ3RoIHZhbHVlIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubmV4dE1lc3NhZ2VMZW5ndGggPSBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gdGhpcy5idWZmZXIudHJ5UmVhZEJvZHkodGhpcy5uZXh0TWVzc2FnZUxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoYm9keSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLyoqIFdlIGhhdmVuJ3QgcmVjZWl2ZWQgdGhlIGZ1bGwgbWVzc2FnZSB5ZXQuICovXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQYXJ0aWFsTWVzc2FnZVRpbWVyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbGVhclBhcnRpYWxNZXNzYWdlVGltZXIoKTtcbiAgICAgICAgICAgIHRoaXMubmV4dE1lc3NhZ2VMZW5ndGggPSAtMTtcbiAgICAgICAgICAgIGxldCBwO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250ZW50RGVjb2RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcCA9IHRoaXMub3B0aW9ucy5jb250ZW50RGVjb2Rlci5kZWNvZGUoYm9keSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwID0gUHJvbWlzZS5yZXNvbHZlKGJvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcC50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5jb250ZW50VHlwZURlY29kZXIuZGVjb2RlKHZhbHVlLCB0aGlzLm9wdGlvbnMpLnRoZW4oKG1zZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKG1zZyk7XG4gICAgICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZUVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZUVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyUGFydGlhbE1lc3NhZ2VUaW1lcigpIHtcbiAgICAgICAgaWYgKHRoaXMucGFydGlhbE1lc3NhZ2VUaW1lcikge1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMucGFydGlhbE1lc3NhZ2VUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRQYXJ0aWFsTWVzc2FnZVRpbWVyKCkge1xuICAgICAgICB0aGlzLmNsZWFyUGFydGlhbE1lc3NhZ2VUaW1lcigpO1xuICAgICAgICBpZiAodGhpcy5fcGFydGlhbE1lc3NhZ2VUaW1lb3V0IDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcnRpYWxNZXNzYWdlVGltZXIgPSAoMCwgcmFsXzEuZGVmYXVsdCkoKS50aW1lci5zZXRUaW1lb3V0KCh0b2tlbiwgdGltZW91dCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSB0aGlzLm1lc3NhZ2VUb2tlbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZVBhcnRpYWxNZXNzYWdlKHsgbWVzc2FnZVRva2VuOiB0b2tlbiwgd2FpdGluZ1RpbWU6IHRpbWVvdXQgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQYXJ0aWFsTWVzc2FnZVRpbWVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMuX3BhcnRpYWxNZXNzYWdlVGltZW91dCwgdGhpcy5tZXNzYWdlVG9rZW4sIHRoaXMuX3BhcnRpYWxNZXNzYWdlVGltZW91dCk7XG4gICAgfVxufVxuZXhwb3J0cy5SZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXIgPSBSZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXNzYWdlUmVhZGVyLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjIxNDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5Xcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyID0gZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLk1lc3NhZ2VXcml0ZXIgPSB2b2lkIDA7XG5jb25zdCByYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTQwNik7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTI3OCk7XG5jb25zdCBzZW1hcGhvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDE5Nyk7XG5jb25zdCBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzI1Nyk7XG5jb25zdCBDb250ZW50TGVuZ3RoID0gJ0NvbnRlbnQtTGVuZ3RoOiAnO1xuY29uc3QgQ1JMRiA9ICdcXHJcXG4nO1xudmFyIE1lc3NhZ2VXcml0ZXI7XG4oZnVuY3Rpb24gKE1lc3NhZ2VXcml0ZXIpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuZnVuYyhjYW5kaWRhdGUuZGlzcG9zZSkgJiYgSXMuZnVuYyhjYW5kaWRhdGUub25DbG9zZSkgJiZcbiAgICAgICAgICAgIElzLmZ1bmMoY2FuZGlkYXRlLm9uRXJyb3IpICYmIElzLmZ1bmMoY2FuZGlkYXRlLndyaXRlKTtcbiAgICB9XG4gICAgTWVzc2FnZVdyaXRlci5pcyA9IGlzO1xufSkoTWVzc2FnZVdyaXRlciA9IGV4cG9ydHMuTWVzc2FnZVdyaXRlciB8fCAoZXhwb3J0cy5NZXNzYWdlV3JpdGVyID0ge30pKTtcbmNsYXNzIEFic3RyYWN0TWVzc2FnZVdyaXRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZXJyb3JFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5jbG9zZUVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLmVycm9yRW1pdHRlci5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuY2xvc2VFbWl0dGVyLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgZ2V0IG9uRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yRW1pdHRlci5ldmVudDtcbiAgICB9XG4gICAgZmlyZUVycm9yKGVycm9yLCBtZXNzYWdlLCBjb3VudCkge1xuICAgICAgICB0aGlzLmVycm9yRW1pdHRlci5maXJlKFt0aGlzLmFzRXJyb3IoZXJyb3IpLCBtZXNzYWdlLCBjb3VudF0pO1xuICAgIH1cbiAgICBnZXQgb25DbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2VFbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBmaXJlQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VFbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICB9XG4gICAgYXNFcnJvcihlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgV3JpdGVyIHJlY2VpdmVkIGVycm9yLiBSZWFzb246ICR7SXMuc3RyaW5nKGVycm9yLm1lc3NhZ2UpID8gZXJyb3IubWVzc2FnZSA6ICd1bmtub3duJ31gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlV3JpdGVyID0gQWJzdHJhY3RNZXNzYWdlV3JpdGVyO1xudmFyIFJlc29sdmVkTWVzc2FnZVdyaXRlck9wdGlvbnM7XG4oZnVuY3Rpb24gKFJlc29sdmVkTWVzc2FnZVdyaXRlck9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBmcm9tT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFyc2V0OiBvcHRpb25zID8/ICd1dGYtOCcsIGNvbnRlbnRUeXBlRW5jb2RlcjogKDAsIHJhbF8xLmRlZmF1bHQpKCkuYXBwbGljYXRpb25Kc29uLmVuY29kZXIgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNoYXJzZXQ6IG9wdGlvbnMuY2hhcnNldCA/PyAndXRmLTgnLCBjb250ZW50RW5jb2Rlcjogb3B0aW9ucy5jb250ZW50RW5jb2RlciwgY29udGVudFR5cGVFbmNvZGVyOiBvcHRpb25zLmNvbnRlbnRUeXBlRW5jb2RlciA/PyAoMCwgcmFsXzEuZGVmYXVsdCkoKS5hcHBsaWNhdGlvbkpzb24uZW5jb2RlciB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIFJlc29sdmVkTWVzc2FnZVdyaXRlck9wdGlvbnMuZnJvbU9wdGlvbnMgPSBmcm9tT3B0aW9ucztcbn0pKFJlc29sdmVkTWVzc2FnZVdyaXRlck9wdGlvbnMgfHwgKFJlc29sdmVkTWVzc2FnZVdyaXRlck9wdGlvbnMgPSB7fSkpO1xuY2xhc3MgV3JpdGVhYmxlU3RyZWFtTWVzc2FnZVdyaXRlciBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVdyaXRlciB7XG4gICAgY29uc3RydWN0b3Iod3JpdGFibGUsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IHdyaXRhYmxlO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBSZXNvbHZlZE1lc3NhZ2VXcml0ZXJPcHRpb25zLmZyb21PcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmVycm9yQ291bnQgPSAwO1xuICAgICAgICB0aGlzLndyaXRlU2VtYXBob3JlID0gbmV3IHNlbWFwaG9yZV8xLlNlbWFwaG9yZSgxKTtcbiAgICAgICAgdGhpcy53cml0YWJsZS5vbkVycm9yKChlcnJvcikgPT4gdGhpcy5maXJlRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgdGhpcy53cml0YWJsZS5vbkNsb3NlKCgpID0+IHRoaXMuZmlyZUNsb3NlKCkpO1xuICAgIH1cbiAgICBhc3luYyB3cml0ZShtc2cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVTZW1hcGhvcmUubG9jayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gdGhpcy5vcHRpb25zLmNvbnRlbnRUeXBlRW5jb2Rlci5lbmNvZGUobXNnLCB0aGlzLm9wdGlvbnMpLnRoZW4oKGJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29udGVudEVuY29kZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmNvbnRlbnRFbmNvZGVyLmVuY29kZShidWZmZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkLnRoZW4oKGJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLnB1c2goQ29udGVudExlbmd0aCwgYnVmZmVyLmJ5dGVMZW5ndGgudG9TdHJpbmcoKSwgQ1JMRik7XG4gICAgICAgICAgICAgICAgaGVhZGVycy5wdXNoKENSTEYpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRvV3JpdGUobXNnLCBoZWFkZXJzLCBidWZmZXIpO1xuICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBkb1dyaXRlKG1zZywgaGVhZGVycywgZGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy53cml0YWJsZS53cml0ZShoZWFkZXJzLmpvaW4oJycpLCAnYXNjaWknKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndyaXRhYmxlLndyaXRlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlcnJvciwgbXNnKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlRXJyb3IoZXJyb3IsIG1zZykge1xuICAgICAgICB0aGlzLmVycm9yQ291bnQrKztcbiAgICAgICAgdGhpcy5maXJlRXJyb3IoZXJyb3IsIG1zZywgdGhpcy5lcnJvckNvdW50KTtcbiAgICB9XG4gICAgZW5kKCkge1xuICAgICAgICB0aGlzLndyaXRhYmxlLmVuZCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuV3JpdGVhYmxlU3RyZWFtTWVzc2FnZVdyaXRlciA9IFdyaXRlYWJsZVN0cmVhbU1lc3NhZ2VXcml0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXNzYWdlV3JpdGVyLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTYxMzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5NZXNzYWdlID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlOSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTggPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU3ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNiA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTUgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU0ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMyA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTIgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUxID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMCA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZSA9IGV4cG9ydHMuUmVxdWVzdFR5cGU5ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTggPSBleHBvcnRzLlJlcXVlc3RUeXBlNyA9IGV4cG9ydHMuUmVxdWVzdFR5cGU2ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTUgPSBleHBvcnRzLlJlcXVlc3RUeXBlNCA9IGV4cG9ydHMuUmVxdWVzdFR5cGUzID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTIgPSBleHBvcnRzLlJlcXVlc3RUeXBlMSA9IGV4cG9ydHMuUmVxdWVzdFR5cGUgPSBleHBvcnRzLlJlcXVlc3RUeXBlMCA9IGV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlID0gZXhwb3J0cy5QYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gZXhwb3J0cy5SZXNwb25zZUVycm9yID0gZXhwb3J0cy5FcnJvckNvZGVzID0gdm9pZCAwO1xuY29uc3QgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNzgpO1xuLyoqXG4gKiBQcmVkZWZpbmVkIGVycm9yIGNvZGVzLlxuICovXG52YXIgRXJyb3JDb2RlcztcbihmdW5jdGlvbiAoRXJyb3JDb2Rlcykge1xuICAgIC8vIERlZmluZWQgYnkgSlNPTiBSUENcbiAgICBFcnJvckNvZGVzLlBhcnNlRXJyb3IgPSAtMzI3MDA7XG4gICAgRXJyb3JDb2Rlcy5JbnZhbGlkUmVxdWVzdCA9IC0zMjYwMDtcbiAgICBFcnJvckNvZGVzLk1ldGhvZE5vdEZvdW5kID0gLTMyNjAxO1xuICAgIEVycm9yQ29kZXMuSW52YWxpZFBhcmFtcyA9IC0zMjYwMjtcbiAgICBFcnJvckNvZGVzLkludGVybmFsRXJyb3IgPSAtMzI2MDM7XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgc3RhcnQgcmFuZ2Ugb2YgSlNPTiBSUEMgcmVzZXJ2ZWQgZXJyb3IgY29kZXMuXG4gICAgICogSXQgZG9lc24ndCBkZW5vdGUgYSByZWFsIGVycm9yIGNvZGUuIE5vIGFwcGxpY2F0aW9uIGVycm9yIGNvZGVzIHNob3VsZFxuICAgICAqIGJlIGRlZmluZWQgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCByYW5nZS4gRm9yIGJhY2t3YXJkc1xuICAgICAqIGNvbXBhdGliaWxpdHkgdGhlIGBTZXJ2ZXJOb3RJbml0aWFsaXplZGAgYW5kIHRoZSBgVW5rbm93bkVycm9yQ29kZWBcbiAgICAgKiBhcmUgbGVmdCBpbiB0aGUgcmFuZ2UuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMy4xNi4wXG4gICAgKi9cbiAgICBFcnJvckNvZGVzLmpzb25ycGNSZXNlcnZlZEVycm9yUmFuZ2VTdGFydCA9IC0zMjA5OTtcbiAgICAvKiogQGRlcHJlY2F0ZWQgdXNlICBqc29ucnBjUmVzZXJ2ZWRFcnJvclJhbmdlU3RhcnQgKi9cbiAgICBFcnJvckNvZGVzLnNlcnZlckVycm9yU3RhcnQgPSAtMzIwOTk7XG4gICAgLyoqXG4gICAgICogQW4gZXJyb3Igb2NjdXJyZWQgd2hlbiB3cml0ZSBhIG1lc3NhZ2UgdG8gdGhlIHRyYW5zcG9ydCBsYXllci5cbiAgICAgKi9cbiAgICBFcnJvckNvZGVzLk1lc3NhZ2VXcml0ZUVycm9yID0gLTMyMDk5O1xuICAgIC8qKlxuICAgICAqIEFuIGVycm9yIG9jY3VycmVkIHdoZW4gcmVhZGluZyBhIG1lc3NhZ2UgZnJvbSB0aGUgdHJhbnNwb3J0IGxheWVyLlxuICAgICAqL1xuICAgIEVycm9yQ29kZXMuTWVzc2FnZVJlYWRFcnJvciA9IC0zMjA5ODtcbiAgICAvKipcbiAgICAgKiBUaGUgY29ubmVjdGlvbiBnb3QgZGlzcG9zZWQgb3IgbG9zdCBhbmQgYWxsIHBlbmRpbmcgcmVzcG9uc2VzIGdvdFxuICAgICAqIHJlamVjdGVkLlxuICAgICAqL1xuICAgIEVycm9yQ29kZXMuUGVuZGluZ1Jlc3BvbnNlUmVqZWN0ZWQgPSAtMzIwOTc7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbm5lY3Rpb24gaXMgaW5hY3RpdmUgYW5kIGEgdXNlIG9mIGl0IGZhaWxlZC5cbiAgICAgKi9cbiAgICBFcnJvckNvZGVzLkNvbm5lY3Rpb25JbmFjdGl2ZSA9IC0zMjA5NjtcbiAgICAvKipcbiAgICAgKiBFcnJvciBjb2RlIGluZGljYXRpbmcgdGhhdCBhIHNlcnZlciByZWNlaXZlZCBhIG5vdGlmaWNhdGlvbiBvclxuICAgICAqIHJlcXVlc3QgYmVmb3JlIHRoZSBzZXJ2ZXIgaGFzIHJlY2VpdmVkIHRoZSBgaW5pdGlhbGl6ZWAgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBFcnJvckNvZGVzLlNlcnZlck5vdEluaXRpYWxpemVkID0gLTMyMDAyO1xuICAgIEVycm9yQ29kZXMuVW5rbm93bkVycm9yQ29kZSA9IC0zMjAwMTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBlbmQgcmFuZ2Ugb2YgSlNPTiBSUEMgcmVzZXJ2ZWQgZXJyb3IgY29kZXMuXG4gICAgICogSXQgZG9lc24ndCBkZW5vdGUgYSByZWFsIGVycm9yIGNvZGUuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMy4xNi4wXG4gICAgKi9cbiAgICBFcnJvckNvZGVzLmpzb25ycGNSZXNlcnZlZEVycm9yUmFuZ2VFbmQgPSAtMzIwMDA7XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSAganNvbnJwY1Jlc2VydmVkRXJyb3JSYW5nZUVuZCAqL1xuICAgIEVycm9yQ29kZXMuc2VydmVyRXJyb3JFbmQgPSAtMzIwMDA7XG59KShFcnJvckNvZGVzID0gZXhwb3J0cy5FcnJvckNvZGVzIHx8IChleHBvcnRzLkVycm9yQ29kZXMgPSB7fSkpO1xuLyoqXG4gKiBBbiBlcnJvciBvYmplY3QgcmV0dXJuIGluIGEgcmVzcG9uc2UgaW4gY2FzZSBhIHJlcXVlc3RcbiAqIGhhcyBmYWlsZWQuXG4gKi9cbmNsYXNzIFJlc3BvbnNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSwgZGF0YSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gaXMubnVtYmVyKGNvZGUpID8gY29kZSA6IEVycm9yQ29kZXMuVW5rbm93bkVycm9yQ29kZTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFJlc3BvbnNlRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG4gICAgdG9Kc29uKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2VcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQuZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuUmVzcG9uc2VFcnJvciA9IFJlc3BvbnNlRXJyb3I7XG5jbGFzcyBQYXJhbWV0ZXJTdHJ1Y3R1cmVzIHtcbiAgICBjb25zdHJ1Y3RvcihraW5kKSB7XG4gICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgfVxuICAgIHN0YXRpYyBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IFBhcmFtZXRlclN0cnVjdHVyZXMuYXV0byB8fCB2YWx1ZSA9PT0gUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUgfHwgdmFsdWUgPT09IFBhcmFtZXRlclN0cnVjdHVyZXMuYnlQb3NpdGlvbjtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtpbmQ7XG4gICAgfVxufVxuZXhwb3J0cy5QYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gUGFyYW1ldGVyU3RydWN0dXJlcztcbi8qKlxuICogVGhlIHBhcmFtZXRlciBzdHJ1Y3R1cmUgaXMgYXV0b21hdGljYWxseSBpbmZlcnJlZCBvbiB0aGUgbnVtYmVyIG9mIHBhcmFtZXRlcnNcbiAqIGFuZCB0aGUgcGFyYW1ldGVyIHR5cGUgaW4gY2FzZSBvZiBhIHNpbmdsZSBwYXJhbS5cbiAqL1xuUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvID0gbmV3IFBhcmFtZXRlclN0cnVjdHVyZXMoJ2F1dG8nKTtcbi8qKlxuICogRm9yY2VzIGBieVBvc2l0aW9uYCBwYXJhbWV0ZXIgc3RydWN0dXJlLiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3UgaGF2ZSBhIHNpbmdsZVxuICogcGFyYW1ldGVyIHdoaWNoIGhhcyBhIGxpdGVyYWwgdHlwZS5cbiAqL1xuUGFyYW1ldGVyU3RydWN0dXJlcy5ieVBvc2l0aW9uID0gbmV3IFBhcmFtZXRlclN0cnVjdHVyZXMoJ2J5UG9zaXRpb24nKTtcbi8qKlxuICogRm9yY2VzIGBieU5hbWVgIHBhcmFtZXRlciBzdHJ1Y3R1cmUuIFRoaXMgaXMgb25seSB1c2VmdWwgd2hlbiBoYXZpbmcgYSBzaW5nbGVcbiAqIHBhcmFtZXRlci4gVGhlIGxpYnJhcnkgd2lsbCByZXBvcnQgZXJyb3JzIGlmIHVzZWQgd2l0aCBhIGRpZmZlcmVudCBudW1iZXIgb2ZcbiAqIHBhcmFtZXRlcnMuXG4gKi9cblBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lID0gbmV3IFBhcmFtZXRlclN0cnVjdHVyZXMoJ2J5TmFtZScpO1xuLyoqXG4gKiBBbiBhYnN0cmFjdCBpbXBsZW1lbnRhdGlvbiBvZiBhIE1lc3NhZ2VUeXBlLlxuICovXG5jbGFzcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgbnVtYmVyT2ZQYXJhbXMpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIHRoaXMubnVtYmVyT2ZQYXJhbXMgPSBudW1iZXJPZlBhcmFtcztcbiAgICB9XG4gICAgZ2V0IHBhcmFtZXRlclN0cnVjdHVyZXMoKSB7XG4gICAgICAgIHJldHVybiBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG87XG4gICAgfVxufVxuZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUgPSBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmU7XG4vKipcbiAqIENsYXNzZXMgdG8gdHlwZSByZXF1ZXN0IHJlc3BvbnNlIHBhaXJzXG4gKi9cbmNsYXNzIFJlcXVlc3RUeXBlMCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMCk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTAgPSBSZXF1ZXN0VHlwZTA7XG5jbGFzcyBSZXF1ZXN0VHlwZSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kLCBfcGFyYW1ldGVyU3RydWN0dXJlcyA9IFBhcmFtZXRlclN0cnVjdHVyZXMuYXV0bykge1xuICAgICAgICBzdXBlcihtZXRob2QsIDEpO1xuICAgICAgICB0aGlzLl9wYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxuICAgIGdldCBwYXJhbWV0ZXJTdHJ1Y3R1cmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcztcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlID0gUmVxdWVzdFR5cGU7XG5jbGFzcyBSZXF1ZXN0VHlwZTEgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG8pIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAxKTtcbiAgICAgICAgdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcyA9IF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbiAgICBnZXQgcGFyYW1ldGVyU3RydWN0dXJlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTEgPSBSZXF1ZXN0VHlwZTE7XG5jbGFzcyBSZXF1ZXN0VHlwZTIgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDIpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGUyID0gUmVxdWVzdFR5cGUyO1xuY2xhc3MgUmVxdWVzdFR5cGUzIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAzKTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlMyA9IFJlcXVlc3RUeXBlMztcbmNsYXNzIFJlcXVlc3RUeXBlNCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNCk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTQgPSBSZXF1ZXN0VHlwZTQ7XG5jbGFzcyBSZXF1ZXN0VHlwZTUgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDUpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGU1ID0gUmVxdWVzdFR5cGU1O1xuY2xhc3MgUmVxdWVzdFR5cGU2IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA2KTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlNiA9IFJlcXVlc3RUeXBlNjtcbmNsYXNzIFJlcXVlc3RUeXBlNyBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNyk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTcgPSBSZXF1ZXN0VHlwZTc7XG5jbGFzcyBSZXF1ZXN0VHlwZTggZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDgpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGU4ID0gUmVxdWVzdFR5cGU4O1xuY2xhc3MgUmVxdWVzdFR5cGU5IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA5KTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlOSA9IFJlcXVlc3RUeXBlOTtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGUgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG8pIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAxKTtcbiAgICAgICAgdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcyA9IF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbiAgICBnZXQgcGFyYW1ldGVyU3RydWN0dXJlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlID0gTm90aWZpY2F0aW9uVHlwZTtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGUwIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAwKTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGUwID0gTm90aWZpY2F0aW9uVHlwZTA7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlMSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kLCBfcGFyYW1ldGVyU3RydWN0dXJlcyA9IFBhcmFtZXRlclN0cnVjdHVyZXMuYXV0bykge1xuICAgICAgICBzdXBlcihtZXRob2QsIDEpO1xuICAgICAgICB0aGlzLl9wYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxuICAgIGdldCBwYXJhbWV0ZXJTdHJ1Y3R1cmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcztcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGUxID0gTm90aWZpY2F0aW9uVHlwZTE7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlMiBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMik7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMiA9IE5vdGlmaWNhdGlvblR5cGUyO1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTMgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDMpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTMgPSBOb3RpZmljYXRpb25UeXBlMztcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGU0IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA0KTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGU0ID0gTm90aWZpY2F0aW9uVHlwZTQ7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlNSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNSA9IE5vdGlmaWNhdGlvblR5cGU1O1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTYgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDYpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTYgPSBOb3RpZmljYXRpb25UeXBlNjtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGU3IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA3KTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGU3ID0gTm90aWZpY2F0aW9uVHlwZTc7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlOCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgOCk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlOCA9IE5vdGlmaWNhdGlvblR5cGU4O1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTkgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDkpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTkgPSBOb3RpZmljYXRpb25UeXBlOTtcbnZhciBNZXNzYWdlO1xuKGZ1bmN0aW9uIChNZXNzYWdlKSB7XG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhlIGdpdmVuIG1lc3NhZ2UgaXMgYSByZXF1ZXN0IG1lc3NhZ2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1JlcXVlc3QobWVzc2FnZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBtZXNzYWdlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGlzLnN0cmluZyhjYW5kaWRhdGUubWV0aG9kKSAmJiAoaXMuc3RyaW5nKGNhbmRpZGF0ZS5pZCkgfHwgaXMubnVtYmVyKGNhbmRpZGF0ZS5pZCkpO1xuICAgIH1cbiAgICBNZXNzYWdlLmlzUmVxdWVzdCA9IGlzUmVxdWVzdDtcbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGUgZ2l2ZW4gbWVzc2FnZSBpcyBhIG5vdGlmaWNhdGlvbiBtZXNzYWdlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOb3RpZmljYXRpb24obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBtZXNzYWdlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGlzLnN0cmluZyhjYW5kaWRhdGUubWV0aG9kKSAmJiBtZXNzYWdlLmlkID09PSB2b2lkIDA7XG4gICAgfVxuICAgIE1lc3NhZ2UuaXNOb3RpZmljYXRpb24gPSBpc05vdGlmaWNhdGlvbjtcbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGUgZ2l2ZW4gbWVzc2FnZSBpcyBhIHJlc3BvbnNlIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Jlc3BvbnNlKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gbWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiAoY2FuZGlkYXRlLnJlc3VsdCAhPT0gdm9pZCAwIHx8ICEhY2FuZGlkYXRlLmVycm9yKSAmJiAoaXMuc3RyaW5nKGNhbmRpZGF0ZS5pZCkgfHwgaXMubnVtYmVyKGNhbmRpZGF0ZS5pZCkgfHwgY2FuZGlkYXRlLmlkID09PSBudWxsKTtcbiAgICB9XG4gICAgTWVzc2FnZS5pc1Jlc3BvbnNlID0gaXNSZXNwb25zZTtcbn0pKE1lc3NhZ2UgPSBleHBvcnRzLk1lc3NhZ2UgfHwgKGV4cG9ydHMuTWVzc2FnZSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXNzYWdlcy5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIDU0MDY6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmxldCBfcmFsO1xuZnVuY3Rpb24gUkFMKCkge1xuICAgIGlmIChfcmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBydW50aW1lIGFic3RyYWN0aW9uIGxheWVyIGluc3RhbGxlZGApO1xuICAgIH1cbiAgICByZXR1cm4gX3JhbDtcbn1cbihmdW5jdGlvbiAoUkFMKSB7XG4gICAgZnVuY3Rpb24gaW5zdGFsbChyYWwpIHtcbiAgICAgICAgaWYgKHJhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHJ1bnRpbWUgYWJzdHJhY3Rpb24gbGF5ZXIgcHJvdmlkZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBfcmFsID0gcmFsO1xuICAgIH1cbiAgICBSQUwuaW5zdGFsbCA9IGluc3RhbGw7XG59KShSQUwgfHwgKFJBTCA9IHt9KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFJBTDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhbC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIDQxOTc6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuU2VtYXBob3JlID0gdm9pZCAwO1xuY29uc3QgcmFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0MDYpO1xuY2xhc3MgU2VtYXBob3JlIHtcbiAgICBjb25zdHJ1Y3RvcihjYXBhY2l0eSA9IDEpIHtcbiAgICAgICAgaWYgKGNhcGFjaXR5IDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FwYWNpdHkgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhcGFjaXR5ID0gY2FwYWNpdHk7XG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IDA7XG4gICAgICAgIHRoaXMuX3dhaXRpbmcgPSBbXTtcbiAgICB9XG4gICAgbG9jayh0aHVuaykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fd2FpdGluZy5wdXNoKHsgdGh1bmssIHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICAgICAgICAgIHRoaXMucnVuTmV4dCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGFjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgICB9XG4gICAgcnVuTmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dhaXRpbmcubGVuZ3RoID09PSAwIHx8IHRoaXMuX2FjdGl2ZSA9PT0gdGhpcy5fY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAoMCwgcmFsXzEuZGVmYXVsdCkoKS50aW1lci5zZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5kb1J1bk5leHQoKSk7XG4gICAgfVxuICAgIGRvUnVuTmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dhaXRpbmcubGVuZ3RoID09PSAwIHx8IHRoaXMuX2FjdGl2ZSA9PT0gdGhpcy5fY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5fd2FpdGluZy5zaGlmdCgpO1xuICAgICAgICB0aGlzLl9hY3RpdmUrKztcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZSA+IHRoaXMuX2NhcGFjaXR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvIG1hbnkgdGh1bmtzIGFjdGl2ZWApO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXh0LnRodW5rKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmUtLTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5OZXh0KCk7XG4gICAgICAgICAgICAgICAgfSwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmUtLTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5OZXh0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmUtLTtcbiAgICAgICAgICAgICAgICBuZXh0LnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bk5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmUtLTtcbiAgICAgICAgICAgIG5leHQucmVqZWN0KGVycik7XG4gICAgICAgICAgICB0aGlzLnJ1bk5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU2VtYXBob3JlID0gU2VtYXBob3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VtYXBob3JlLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjA5NDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGZvckVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyNDMpO1xudmFyIGF2YWlsYWJsZVR5cGVkQXJyYXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTkxKTtcbnZhciBjYWxsQmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oOTQyOSk7XG52YXIgY2FsbEJvdW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjgwKTtcbnZhciBnT1BEID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMjYpO1xuXG52YXIgJHRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJyk7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyMjYpKCk7XG5cbnZhciBnID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX3JlcXVpcmVfXy5nIDogZ2xvYmFsVGhpcztcbnZhciB0eXBlZEFycmF5cyA9IGF2YWlsYWJsZVR5cGVkQXJyYXlzKCk7XG5cbnZhciAkc2xpY2UgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUuc2xpY2UnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjsgLy8gcmVxdWlyZSgnZ2V0cHJvdG90eXBlb2YnKTtcblxudmFyICRpbmRleE9mID0gY2FsbEJvdW5kKCdBcnJheS5wcm90b3R5cGUuaW5kZXhPZicsIHRydWUpIHx8IGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRpZiAoYXJyYXlbaV0gPT09IHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gaTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIC0xO1xufTtcbnZhciBjYWNoZSA9IHsgX19wcm90b19fOiBudWxsIH07XG5pZiAoaGFzVG9TdHJpbmdUYWcgJiYgZ09QRCAmJiBnZXRQcm90b3R5cGVPZikge1xuXHRmb3JFYWNoKHR5cGVkQXJyYXlzLCBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuXHRcdHZhciBhcnIgPSBuZXcgZ1t0eXBlZEFycmF5XSgpO1xuXHRcdGlmIChTeW1ib2wudG9TdHJpbmdUYWcgaW4gYXJyKSB7XG5cdFx0XHR2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihhcnIpO1xuXHRcdFx0dmFyIGRlc2NyaXB0b3IgPSBnT1BEKHByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0aWYgKCFkZXNjcmlwdG9yKSB7XG5cdFx0XHRcdHZhciBzdXBlclByb3RvID0gZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuXHRcdFx0XHRkZXNjcmlwdG9yID0gZ09QRChzdXBlclByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0fVxuXHRcdFx0Y2FjaGVbJyQnICsgdHlwZWRBcnJheV0gPSBjYWxsQmluZChkZXNjcmlwdG9yLmdldCk7XG5cdFx0fVxuXHR9KTtcbn0gZWxzZSB7XG5cdGZvckVhY2godHlwZWRBcnJheXMsIGZ1bmN0aW9uICh0eXBlZEFycmF5KSB7XG5cdFx0dmFyIGFyciA9IG5ldyBnW3R5cGVkQXJyYXldKCk7XG5cdFx0Y2FjaGVbJyQnICsgdHlwZWRBcnJheV0gPSBjYWxsQmluZChhcnIuc2xpY2UpO1xuXHR9KTtcbn1cblxudmFyIHRyeVR5cGVkQXJyYXlzID0gZnVuY3Rpb24gdHJ5QWxsVHlwZWRBcnJheXModmFsdWUpIHtcblx0dmFyIGZvdW5kID0gZmFsc2U7XG5cdGZvckVhY2goY2FjaGUsIGZ1bmN0aW9uIChnZXR0ZXIsIHR5cGVkQXJyYXkpIHtcblx0XHRpZiAoIWZvdW5kKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoJyQnICsgZ2V0dGVyKHZhbHVlKSA9PT0gdHlwZWRBcnJheSkge1xuXHRcdFx0XHRcdGZvdW5kID0gJHNsaWNlKHR5cGVkQXJyYXksIDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7IC8qKi8gfVxuXHRcdH1cblx0fSk7XG5cdHJldHVybiBmb3VuZDtcbn07XG5cbnZhciB0cnlTbGljZXMgPSBmdW5jdGlvbiB0cnlBbGxTbGljZXModmFsdWUpIHtcblx0dmFyIGZvdW5kID0gZmFsc2U7XG5cdGZvckVhY2goY2FjaGUsIGZ1bmN0aW9uIChnZXR0ZXIsIG5hbWUpIHtcblx0XHRpZiAoIWZvdW5kKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRnZXR0ZXIodmFsdWUpO1xuXHRcdFx0XHRmb3VuZCA9ICRzbGljZShuYW1lLCAxKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHsgLyoqLyB9XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGZvdW5kO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB3aGljaFR5cGVkQXJyYXkodmFsdWUpIHtcblx0aWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnKSB7XG5cdFx0dmFyIHRhZyA9ICRzbGljZSgkdG9TdHJpbmcodmFsdWUpLCA4LCAtMSk7XG5cdFx0aWYgKCRpbmRleE9mKHR5cGVkQXJyYXlzLCB0YWcpID4gLTEpIHtcblx0XHRcdHJldHVybiB0YWc7XG5cdFx0fVxuXHRcdGlmICh0YWcgIT09ICdPYmplY3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdC8vIG5vZGUgPCAwLjYgaGl0cyBoZXJlIG9uIHJlYWwgVHlwZWQgQXJyYXlzXG5cdFx0cmV0dXJuIHRyeVNsaWNlcyh2YWx1ZSk7XG5cdH1cblx0aWYgKCFnT1BEKSB7IHJldHVybiBudWxsOyB9IC8vIHVua25vd24gZW5naW5lXG5cdHJldHVybiB0cnlUeXBlZEFycmF5cyh2YWx1ZSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyMTkxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgcG9zc2libGVOYW1lcyA9IFtcblx0J0JpZ0ludDY0QXJyYXknLFxuXHQnQmlnVWludDY0QXJyYXknLFxuXHQnRmxvYXQzMkFycmF5Jyxcblx0J0Zsb2F0NjRBcnJheScsXG5cdCdJbnQxNkFycmF5Jyxcblx0J0ludDMyQXJyYXknLFxuXHQnSW50OEFycmF5Jyxcblx0J1VpbnQxNkFycmF5Jyxcblx0J1VpbnQzMkFycmF5Jyxcblx0J1VpbnQ4QXJyYXknLFxuXHQnVWludDhDbGFtcGVkQXJyYXknXG5dO1xuXG52YXIgZyA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19yZXF1aXJlX18uZyA6IGdsb2JhbFRoaXM7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXZhaWxhYmxlVHlwZWRBcnJheXMoKSB7XG5cdHZhciBvdXQgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwb3NzaWJsZU5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKHR5cGVvZiBnW3Bvc3NpYmxlTmFtZXNbaV1dID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRvdXRbb3V0Lmxlbmd0aF0gPSBwb3NzaWJsZU5hbWVzW2ldO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gb3V0O1xufTtcblxuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcbi8qKioqKiovIFx0XHRcdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcbi8qKioqKiovIFx0XHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG4vKioqKioqLyBcdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcbi8qKioqKiovIFx0XHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuLyoqKioqKi8gXHRcdFx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG4vKioqKioqLyBcdFx0XHR0cnkge1xuLyoqKioqKi8gXHRcdFx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbi8qKioqKiovIFx0XHRcdH0gY2F0Y2ggKGUpIHtcbi8qKioqKiovIFx0XHRcdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdH0pKCk7XG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKVxuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuLyoqKioqKi8gXHRcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IHt9O1xuLy8gVGhpcyBlbnRyeSBuZWVkIHRvIGJlIHdyYXBwZWQgaW4gYW4gSUlGRSBiZWNhdXNlIGl0IG5lZWQgdG8gYmUgaW4gc3RyaWN0IG1vZGUuXG4oKCkgPT4ge1xuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBFU00gQ09NUEFUIEZMQUdcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbiAgTGFuZ3VhZ2VDbGllbnQ6ICgpID0+ICgvKiBiaW5kaW5nICovIExhbmd1YWdlQ2xpZW50KVxufSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS13cy1qc29ucnBjL25vZGVfbW9kdWxlcy92c2NvZGUtanNvbnJwYy9saWIvYnJvd3Nlci9tYWluLmpzXG52YXIgbWFpbiA9IF9fd2VicGFja19yZXF1aXJlX18oMjAzMik7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtd3MtanNvbnJwYy9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb25ycGMvbGliL2NvbW1vbi9tZXNzYWdlcy5qc1xudmFyIG1lc3NhZ2VzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NjEzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLXdzLWpzb25ycGMvbGliL2Rpc3Bvc2FibGUuanNcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqIENvcHlyaWdodCAoYykgMjAxOC0yMDIyIFR5cGVGb3ggR21iSCAoaHR0cDovL3d3dy50eXBlZm94LmlvKS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG5jbGFzcyBEaXNwb3NhYmxlQ29sbGVjdGlvbiB7XHJcbiAgICBkaXNwb3NhYmxlcyA9IFtdO1xyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICB3aGlsZSAodGhpcy5kaXNwb3NhYmxlcy5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNwb3NhYmxlcy5wb3AoKS5kaXNwb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcHVzaChkaXNwb3NhYmxlKSB7XHJcbiAgICAgICAgY29uc3QgZGlzcG9zYWJsZXMgPSB0aGlzLmRpc3Bvc2FibGVzO1xyXG4gICAgICAgIGRpc3Bvc2FibGVzLnB1c2goZGlzcG9zYWJsZSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGlzcG9zZSgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZGlzcG9zYWJsZXMuaW5kZXhPZihkaXNwb3NhYmxlKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwb3NhYmxlcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzcG9zYWJsZS5qcy5tYXBcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS13cy1qc29ucnBjL25vZGVfbW9kdWxlcy92c2NvZGUtanNvbnJwYy9saWIvY29tbW9uL21lc3NhZ2VSZWFkZXIuanNcbnZhciBtZXNzYWdlUmVhZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMDcpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtd3MtanNvbnJwYy9saWIvc29ja2V0L3JlYWRlci5qc1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogQ29weXJpZ2h0IChjKSAyMDE4LTIwMjIgVHlwZUZveCBHbWJIIChodHRwOi8vd3d3LnR5cGVmb3guaW8pLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbmNsYXNzIFdlYlNvY2tldE1lc3NhZ2VSZWFkZXIgZXh0ZW5kcyBtZXNzYWdlUmVhZGVyLkFic3RyYWN0TWVzc2FnZVJlYWRlciB7XHJcbiAgICBzb2NrZXQ7XHJcbiAgICBzdGF0ZSA9ICdpbml0aWFsJztcclxuICAgIGNhbGxiYWNrO1xyXG4gICAgZXZlbnRzID0gW107XHJcbiAgICBjb25zdHJ1Y3Rvcihzb2NrZXQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuc29ja2V0ID0gc29ja2V0O1xyXG4gICAgICAgIHRoaXMuc29ja2V0Lm9uTWVzc2FnZShtZXNzYWdlID0+IHRoaXMucmVhZE1lc3NhZ2UobWVzc2FnZSkpO1xyXG4gICAgICAgIHRoaXMuc29ja2V0Lm9uRXJyb3IoZXJyb3IgPT4gdGhpcy5maXJlRXJyb3IoZXJyb3IpKTtcclxuICAgICAgICB0aGlzLnNvY2tldC5vbkNsb3NlKChjb2RlLCByZWFzb24pID0+IHtcclxuICAgICAgICAgICAgaWYgKGNvZGUgIT09IDEwMDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICcnICsgY29kZSxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgRXJyb3IgZHVyaW5nIHNvY2tldCByZWNvbm5lY3Q6IGNvZGUgPSAke2NvZGV9LCByZWFzb24gPSAke3JlYXNvbn1gXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlRXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZmlyZUNsb3NlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBsaXN0ZW4oY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2luaXRpYWwnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnbGlzdGVuaW5nJztcclxuICAgICAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5ldmVudHMubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9IHRoaXMuZXZlbnRzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50Lm1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRNZXNzYWdlKGV2ZW50Lm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmVFcnJvcihldmVudC5lcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmVDbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbGxiYWNrID09PSBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmVhZE1lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnaW5pdGlhbCcpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMuc3BsaWNlKDAsIDAsIHsgbWVzc2FnZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gJ2xpc3RlbmluZycpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFjayhkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnJyArIDQwMCxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgRXJyb3IgZHVyaW5nIG1lc3NhZ2UgcGFyc2luZywgcmVhc29uID0gJHt0eXBlb2YgZXJyID09PSAnb2JqZWN0JyA/IGVyci5tZXNzYWdlIDogJ3Vua25vd24nfWBcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVFcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmaXJlRXJyb3IoZXJyb3IpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2luaXRpYWwnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLnNwbGljZSgwLCAwLCB7IGVycm9yIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSAnbGlzdGVuaW5nJykge1xyXG4gICAgICAgICAgICBzdXBlci5maXJlRXJyb3IoZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZpcmVDbG9zZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2luaXRpYWwnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLnNwbGljZSgwLCAwLCB7fSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09ICdsaXN0ZW5pbmcnKSB7XHJcbiAgICAgICAgICAgIHN1cGVyLmZpcmVDbG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0YXRlID0gJ2Nsb3NlZCc7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhZGVyLmpzLm1hcFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLXdzLWpzb25ycGMvbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29ucnBjL2xpYi9jb21tb24vbWVzc2FnZVdyaXRlci5qc1xudmFyIG1lc3NhZ2VXcml0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYyMTQpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtd3MtanNvbnJwYy9saWIvc29ja2V0L3dyaXRlci5qc1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogQ29weXJpZ2h0IChjKSAyMDE4LTIwMjIgVHlwZUZveCBHbWJIIChodHRwOi8vd3d3LnR5cGVmb3guaW8pLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbmNsYXNzIFdlYlNvY2tldE1lc3NhZ2VXcml0ZXIgZXh0ZW5kcyBtZXNzYWdlV3JpdGVyLkFic3RyYWN0TWVzc2FnZVdyaXRlciB7XHJcbiAgICBzb2NrZXQ7XHJcbiAgICBlcnJvckNvdW50ID0gMDtcclxuICAgIGNvbnN0cnVjdG9yKHNvY2tldCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5zb2NrZXQgPSBzb2NrZXQ7XHJcbiAgICB9XHJcbiAgICBlbmQoKSB7XHJcbiAgICB9XHJcbiAgICBhc3luYyB3cml0ZShtc2cpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gSlNPTi5zdHJpbmdpZnkobXNnKTtcclxuICAgICAgICAgICAgdGhpcy5zb2NrZXQuc2VuZChjb250ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvckNvdW50Kys7XHJcbiAgICAgICAgICAgIHRoaXMuZmlyZUVycm9yKGUsIG1zZywgdGhpcy5lcnJvckNvdW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d3JpdGVyLmpzLm1hcFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtd3MtanNvbnJwYy9saWIvc29ja2V0L2Nvbm5lY3Rpb24uanNcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqIENvcHlyaWdodCAoYykgMjAxOC0yMDIyIFR5cGVGb3ggR21iSCAoaHR0cDovL3d3dy50eXBlZm94LmlvKS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVdlYlNvY2tldENvbm5lY3Rpb24oc29ja2V0LCBsb2dnZXIpIHtcclxuICAgIGNvbnN0IG1lc3NhZ2VSZWFkZXIgPSBuZXcgV2ViU29ja2V0TWVzc2FnZVJlYWRlcihzb2NrZXQpO1xyXG4gICAgY29uc3QgbWVzc2FnZVdyaXRlciA9IG5ldyBXZWJTb2NrZXRNZXNzYWdlV3JpdGVyKHNvY2tldCk7XHJcbiAgICBjb25zdCBjb25uZWN0aW9uID0gKDAsbWFpbi5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbikobWVzc2FnZVJlYWRlciwgbWVzc2FnZVdyaXRlciwgbG9nZ2VyKTtcclxuICAgIGNvbm5lY3Rpb24ub25DbG9zZSgoKSA9PiBjb25uZWN0aW9uLmRpc3Bvc2UoKSk7XHJcbiAgICByZXR1cm4gY29ubmVjdGlvbjtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25uZWN0aW9uLmpzLm1hcFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtd3MtanNvbnJwYy9saWIvc29ja2V0L2luZGV4LmpzXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTgtMjAyMiBUeXBlRm94IEdtYkggKGh0dHA6Ly93d3cudHlwZWZveC5pbykuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuXHJcblxyXG5cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS13cy1qc29ucnBjL2xpYi9sb2dnZXIuanNcbi8qIHByb3ZpZGVkIGRlcGVuZGVuY3kgKi8gdmFyIGNvbnNvbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3MTYpO1xuY2xhc3MgQ29uc29sZUxvZ2dlciB7XHJcbiAgICBlcnJvcihtZXNzYWdlKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcclxuICAgIH1cclxuICAgIHdhcm4obWVzc2FnZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcclxuICAgIH1cclxuICAgIGluZm8obWVzc2FnZSkge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhtZXNzYWdlKTtcclxuICAgIH1cclxuICAgIGxvZyhtZXNzYWdlKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgICBkZWJ1ZyhtZXNzYWdlKSB7XHJcbiAgICAgICAgY29uc29sZS5kZWJ1ZyhtZXNzYWdlKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dnZXIuanMubWFwXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS13cy1qc29ucnBjL2xpYi9jb25uZWN0aW9uLmpzXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTgtMjAyMiBUeXBlRm94IEdtYkggKGh0dHA6Ly93d3cudHlwZWZveC5pbykuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIGxpc3RlbihvcHRpb25zKSB7XHJcbiAgICBjb25zdCB7IHdlYlNvY2tldCwgb25Db25uZWN0aW9uIH0gPSBvcHRpb25zO1xyXG4gICAgY29uc3QgbG9nZ2VyID0gb3B0aW9ucy5sb2dnZXIgfHwgbmV3IENvbnNvbGVMb2dnZXIoKTtcclxuICAgIHdlYlNvY2tldC5vbm9wZW4gPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc29ja2V0ID0gdG9Tb2NrZXQod2ViU29ja2V0KTtcclxuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gY3JlYXRlV2ViU29ja2V0Q29ubmVjdGlvbihzb2NrZXQsIGxvZ2dlcik7XHJcbiAgICAgICAgb25Db25uZWN0aW9uKGNvbm5lY3Rpb24pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiB0b1NvY2tldCh3ZWJTb2NrZXQpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc2VuZDogY29udGVudCA9PiB3ZWJTb2NrZXQuc2VuZChjb250ZW50KSxcclxuICAgICAgICBvbk1lc3NhZ2U6IGNiID0+IHtcclxuICAgICAgICAgICAgd2ViU29ja2V0Lm9ubWVzc2FnZSA9IGV2ZW50ID0+IGNiKGV2ZW50LmRhdGEpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25FcnJvcjogY2IgPT4ge1xyXG4gICAgICAgICAgICB3ZWJTb2NrZXQub25lcnJvciA9IGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICgnbWVzc2FnZScgaW4gZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYihldmVudC5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQ2xvc2U6IGNiID0+IHtcclxuICAgICAgICAgICAgd2ViU29ja2V0Lm9uY2xvc2UgPSBldmVudCA9PiBjYihldmVudC5jb2RlLCBldmVudC5yZWFzb24pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGlzcG9zZTogKCkgPT4gd2ViU29ja2V0LmNsb3NlKClcclxuICAgIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdGlvbi5qcy5tYXBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLXdzLWpzb25ycGMvbGliL2luZGV4LmpzXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTgtMjAyMiBUeXBlRm94IEdtYkggKGh0dHA6Ly93d3cudHlwZWZveC5pbykuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1sYW5ndWFnZXNlcnZlci1wcm90b2NvbC9saWIvYnJvd3Nlci9tYWluLmpzXG52YXIgYnJvd3Nlcl9tYWluID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOTQpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlc2VydmVyLXByb3RvY29sL2Jyb3dzZXIuanNcbnZhciBicm93c2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzg5KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvc2VydmljZXMvYmFzZS1zZXJ2aWNlLnRzXG52YXIgYmFzZV9zZXJ2aWNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NDg3KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9tZXNzYWdlLXR5cGVzLnRzXG5mdW5jdGlvbiBfZGVmaW5lX3Byb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5jbGFzcyBCYXNlTWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3Ioc2Vzc2lvbklkKXtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInNlc3Npb25JZFwiLCB2b2lkIDApO1xuICAgICAgICB0aGlzLnNlc3Npb25JZCA9IHNlc3Npb25JZDtcbiAgICB9XG59XG5jbGFzcyBJbml0TWVzc2FnZSBleHRlbmRzICgvKiB1bnVzZWQgcHVyZSBleHByZXNzaW9uIG9yIHN1cGVyICovIG51bGwgJiYgKEJhc2VNZXNzYWdlKSkge1xuICAgIGNvbnN0cnVjdG9yKHNlc3Npb25JZCwgdmFsdWUsIHZlcnNpb24sIG1vZGUsIG9wdGlvbnMpe1xuICAgICAgICBzdXBlcihzZXNzaW9uSWQpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidHlwZVwiLCBNZXNzYWdlVHlwZS5pbml0KTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcIm1vZGVcIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInZhbHVlXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ2ZXJzaW9uXCIsIHZvaWQgMCk7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG59XG5jbGFzcyBGb3JtYXRNZXNzYWdlIGV4dGVuZHMgKC8qIHVudXNlZCBwdXJlIGV4cHJlc3Npb24gb3Igc3VwZXIgKi8gbnVsbCAmJiAoQmFzZU1lc3NhZ2UpKSB7XG4gICAgY29uc3RydWN0b3Ioc2Vzc2lvbklkLCB2YWx1ZSwgZm9ybWF0KXtcbiAgICAgICAgc3VwZXIoc2Vzc2lvbklkKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInR5cGVcIiwgTWVzc2FnZVR5cGUuZm9ybWF0KTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInZhbHVlXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJmb3JtYXRcIiwgdm9pZCAwKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcbiAgICB9XG59XG5jbGFzcyBDb21wbGV0ZU1lc3NhZ2UgZXh0ZW5kcyAoLyogdW51c2VkIHB1cmUgZXhwcmVzc2lvbiBvciBzdXBlciAqLyBudWxsICYmIChCYXNlTWVzc2FnZSkpIHtcbiAgICBjb25zdHJ1Y3RvcihzZXNzaW9uSWQsIHZhbHVlKXtcbiAgICAgICAgc3VwZXIoc2Vzc2lvbklkKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInR5cGVcIiwgTWVzc2FnZVR5cGUuY29tcGxldGUpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwgdm9pZCAwKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn1cbmNsYXNzIFJlc29sdmVDb21wbGV0aW9uTWVzc2FnZSBleHRlbmRzICgvKiB1bnVzZWQgcHVyZSBleHByZXNzaW9uIG9yIHN1cGVyICovIG51bGwgJiYgKEJhc2VNZXNzYWdlKSkge1xuICAgIGNvbnN0cnVjdG9yKHNlc3Npb25JZCwgdmFsdWUpe1xuICAgICAgICBzdXBlcihzZXNzaW9uSWQpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidHlwZVwiLCBNZXNzYWdlVHlwZS5yZXNvbHZlQ29tcGxldGlvbik7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuY2xhc3MgSG92ZXJNZXNzYWdlIGV4dGVuZHMgKC8qIHVudXNlZCBwdXJlIGV4cHJlc3Npb24gb3Igc3VwZXIgKi8gbnVsbCAmJiAoQmFzZU1lc3NhZ2UpKSB7XG4gICAgY29uc3RydWN0b3Ioc2Vzc2lvbklkLCB2YWx1ZSl7XG4gICAgICAgIHN1cGVyKHNlc3Npb25JZCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ0eXBlXCIsIE1lc3NhZ2VUeXBlLmhvdmVyKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInZhbHVlXCIsIHZvaWQgMCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG59XG5jbGFzcyBWYWxpZGF0ZU1lc3NhZ2UgZXh0ZW5kcyAoLyogdW51c2VkIHB1cmUgZXhwcmVzc2lvbiBvciBzdXBlciAqLyBudWxsICYmIChCYXNlTWVzc2FnZSkpIHtcbiAgICBjb25zdHJ1Y3RvcihzZXNzaW9uSWQpe1xuICAgICAgICBzdXBlcihzZXNzaW9uSWQpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidHlwZVwiLCBNZXNzYWdlVHlwZS52YWxpZGF0ZSk7XG4gICAgfVxufVxuY2xhc3MgQ2hhbmdlTWVzc2FnZSBleHRlbmRzICgvKiB1bnVzZWQgcHVyZSBleHByZXNzaW9uIG9yIHN1cGVyICovIG51bGwgJiYgKEJhc2VNZXNzYWdlKSkge1xuICAgIGNvbnN0cnVjdG9yKHNlc3Npb25JZCwgdmFsdWUsIHZlcnNpb24pe1xuICAgICAgICBzdXBlcihzZXNzaW9uSWQpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidHlwZVwiLCBNZXNzYWdlVHlwZS5jaGFuZ2UpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInZlcnNpb25cIiwgdm9pZCAwKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIH1cbn1cbmNsYXNzIERlbHRhc01lc3NhZ2UgZXh0ZW5kcyAoLyogdW51c2VkIHB1cmUgZXhwcmVzc2lvbiBvciBzdXBlciAqLyBudWxsICYmIChCYXNlTWVzc2FnZSkpIHtcbiAgICBjb25zdHJ1Y3RvcihzZXNzaW9uSWQsIHZhbHVlLCB2ZXJzaW9uKXtcbiAgICAgICAgc3VwZXIoc2Vzc2lvbklkKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInR5cGVcIiwgTWVzc2FnZVR5cGUuYXBwbHlEZWx0YSk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidmVyc2lvblwiLCB2b2lkIDApO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgfVxufVxuY2xhc3MgQ2hhbmdlTW9kZU1lc3NhZ2UgZXh0ZW5kcyAoLyogdW51c2VkIHB1cmUgZXhwcmVzc2lvbiBvciBzdXBlciAqLyBudWxsICYmIChCYXNlTWVzc2FnZSkpIHtcbiAgICBjb25zdHJ1Y3RvcihzZXNzaW9uSWQsIHZhbHVlLCBtb2RlKXtcbiAgICAgICAgc3VwZXIoc2Vzc2lvbklkKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInR5cGVcIiwgTWVzc2FnZVR5cGUuY2hhbmdlTW9kZSk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJtb2RlXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgfVxufVxuY2xhc3MgQ2hhbmdlT3B0aW9uc01lc3NhZ2UgZXh0ZW5kcyAoLyogdW51c2VkIHB1cmUgZXhwcmVzc2lvbiBvciBzdXBlciAqLyBudWxsICYmIChCYXNlTWVzc2FnZSkpIHtcbiAgICBjb25zdHJ1Y3RvcihzZXNzaW9uSWQsIG9wdGlvbnMsIG1lcmdlID0gZmFsc2Upe1xuICAgICAgICBzdXBlcihzZXNzaW9uSWQpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidHlwZVwiLCBNZXNzYWdlVHlwZS5jaGFuZ2VPcHRpb25zKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcIm1lcmdlXCIsIHZvaWQgMCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMubWVyZ2UgPSBtZXJnZTtcbiAgICB9XG59XG5jbGFzcyBEaXNwb3NlTWVzc2FnZSBleHRlbmRzICgvKiB1bnVzZWQgcHVyZSBleHByZXNzaW9uIG9yIHN1cGVyICovIG51bGwgJiYgKEJhc2VNZXNzYWdlKSkge1xuICAgIGNvbnN0cnVjdG9yKHNlc3Npb25JZCl7XG4gICAgICAgIHN1cGVyKHNlc3Npb25JZCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ0eXBlXCIsIE1lc3NhZ2VUeXBlLmRpc3Bvc2UpO1xuICAgIH1cbn1cbmNsYXNzIEdsb2JhbE9wdGlvbnNNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlTmFtZSwgb3B0aW9ucywgbWVyZ2Upe1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidHlwZVwiLCBNZXNzYWdlVHlwZS5nbG9iYWxPcHRpb25zKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInNlcnZpY2VOYW1lXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJvcHRpb25zXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJtZXJnZVwiLCB2b2lkIDApO1xuICAgICAgICB0aGlzLnNlcnZpY2VOYW1lID0gc2VydmljZU5hbWU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMubWVyZ2UgPSBtZXJnZTtcbiAgICB9XG59XG5jbGFzcyBDb25maWd1cmVGZWF0dXJlc01lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VOYW1lLCBvcHRpb25zKXtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInR5cGVcIiwgTWVzc2FnZVR5cGUuY29uZmlndXJlRmVhdHVyZXMpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwic2VydmljZU5hbWVcIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlTmFtZSA9IHNlcnZpY2VOYW1lO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbn1cbmNsYXNzIFNpZ25hdHVyZUhlbHBNZXNzYWdlIGV4dGVuZHMgKC8qIHVudXNlZCBwdXJlIGV4cHJlc3Npb24gb3Igc3VwZXIgKi8gbnVsbCAmJiAoQmFzZU1lc3NhZ2UpKSB7XG4gICAgY29uc3RydWN0b3Ioc2Vzc2lvbklkLCB2YWx1ZSl7XG4gICAgICAgIHN1cGVyKHNlc3Npb25JZCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ0eXBlXCIsIE1lc3NhZ2VUeXBlLnNpZ25hdHVyZUhlbHApO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwgdm9pZCAwKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn1cbmNsYXNzIERvY3VtZW50SGlnaGxpZ2h0TWVzc2FnZSBleHRlbmRzICgvKiB1bnVzZWQgcHVyZSBleHByZXNzaW9uIG9yIHN1cGVyICovIG51bGwgJiYgKEJhc2VNZXNzYWdlKSkge1xuICAgIGNvbnN0cnVjdG9yKHNlc3Npb25JZCwgdmFsdWUpe1xuICAgICAgICBzdXBlcihzZXNzaW9uSWQpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidHlwZVwiLCBNZXNzYWdlVHlwZS5kb2N1bWVudEhpZ2hsaWdodCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxudmFyIE1lc3NhZ2VUeXBlO1xuKGZ1bmN0aW9uKE1lc3NhZ2VUeXBlKSB7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJpbml0XCJdID0gMF0gPSBcImluaXRcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcImZvcm1hdFwiXSA9IDFdID0gXCJmb3JtYXRcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcImNvbXBsZXRlXCJdID0gMl0gPSBcImNvbXBsZXRlXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJyZXNvbHZlQ29tcGxldGlvblwiXSA9IDNdID0gXCJyZXNvbHZlQ29tcGxldGlvblwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiY2hhbmdlXCJdID0gNF0gPSBcImNoYW5nZVwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiaG92ZXJcIl0gPSA1XSA9IFwiaG92ZXJcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcInZhbGlkYXRlXCJdID0gNl0gPSBcInZhbGlkYXRlXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJhcHBseURlbHRhXCJdID0gN10gPSBcImFwcGx5RGVsdGFcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcImNoYW5nZU1vZGVcIl0gPSA4XSA9IFwiY2hhbmdlTW9kZVwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiY2hhbmdlT3B0aW9uc1wiXSA9IDldID0gXCJjaGFuZ2VPcHRpb25zXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJkaXNwb3NlXCJdID0gMTBdID0gXCJkaXNwb3NlXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJnbG9iYWxPcHRpb25zXCJdID0gMTFdID0gXCJnbG9iYWxPcHRpb25zXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJjb25maWd1cmVGZWF0dXJlc1wiXSA9IDEyXSA9IFwiY29uZmlndXJlRmVhdHVyZXNcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcInNpZ25hdHVyZUhlbHBcIl0gPSAxM10gPSBcInNpZ25hdHVyZUhlbHBcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcImRvY3VtZW50SGlnaGxpZ2h0XCJdID0gMTRdID0gXCJkb2N1bWVudEhpZ2hsaWdodFwiO1xufSkoTWVzc2FnZVR5cGUgfHwgKE1lc3NhZ2VUeXBlID0ge30pKTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3NlcnZpY2VzL2xhbmd1YWdlLWNsaWVudC50c1xuLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgbGFuZ3VhZ2VfY2xpZW50X2NvbnNvbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3MTYpO1xuZnVuY3Rpb24gbGFuZ3VhZ2VfY2xpZW50X2RlZmluZV9wcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuXG5cblxuXG5cbmNsYXNzIExhbmd1YWdlQ2xpZW50IGV4dGVuZHMgYmFzZV9zZXJ2aWNlLkJhc2VTZXJ2aWNlIHtcbiAgICAkY29ubmVjdFNvY2tldChpbml0aWFsaXphdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICAgICAgICBsaXN0ZW4oe1xuICAgICAgICAgICAgICAgIHdlYlNvY2tldDogdGhpcy5zb2NrZXQsXG4gICAgICAgICAgICAgICAgb25Db25uZWN0aW9uOiAoY29ubmVjdGlvbik9PntcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY29ubmVjdChjb25uZWN0aW9uLCBpbml0aWFsaXphdGlvbk9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ29wZW4nKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaXN0ZW4oe1xuICAgICAgICAgICAgICAgIHdlYlNvY2tldDogdGhpcy5zb2NrZXQsXG4gICAgICAgICAgICAgICAgb25Db25uZWN0aW9uOiAoY29ubmVjdGlvbik9PntcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY29ubmVjdChjb25uZWN0aW9uLCBpbml0aWFsaXphdGlvbk9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgICRjb25uZWN0V29ya2VyKHdvcmtlciwgaW5pdGlhbGl6YXRpb25PcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSAoMCxicm93c2VyLmNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbikobmV3IGJyb3dzZXIuQnJvd3Nlck1lc3NhZ2VSZWFkZXIod29ya2VyKSwgbmV3IGJyb3dzZXIuQnJvd3Nlck1lc3NhZ2VXcml0ZXIod29ya2VyKSk7XG4gICAgICAgIHRoaXMuJGNvbm5lY3QoY29ubmVjdGlvbiwgaW5pdGlhbGl6YXRpb25PcHRpb25zKTtcbiAgICB9XG4gICAgJGNvbm5lY3QoY29ubmVjdGlvbiwgaW5pdGlhbGl6YXRpb25PcHRpb25zKSB7XG4gICAgICAgIGNvbm5lY3Rpb24ubGlzdGVuKCk7XG4gICAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgICAgICB0aGlzLnNlbmRJbml0aWFsaXplKGluaXRpYWxpemF0aW9uT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5vbk5vdGlmaWNhdGlvbigndGV4dERvY3VtZW50L3B1Ymxpc2hEaWFnbm9zdGljcycsIChyZXN1bHQpPT57XG4gICAgICAgICAgICBsZXQgcG9zdE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IE1lc3NhZ2VUeXBlLnZhbGlkYXRlLFxuICAgICAgICAgICAgICAgIFwic2Vzc2lvbklkXCI6IHJlc3VsdC51cmkucmVwbGFjZSgvXmZpbGU6XFwvezIsM30vLCBcIlwiKSxcbiAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHJlc3VsdC5kaWFnbm9zdGljc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuY3R4LnBvc3RNZXNzYWdlKHBvc3RNZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5vbk5vdGlmaWNhdGlvbignd2luZG93L3Nob3dNZXNzYWdlJywgKHBhcmFtcyk9PntcbiAgICAgICAgICAgIHRoaXMuc2hvd0xvZyhwYXJhbXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLm9uTm90aWZpY2F0aW9uKCd3aW5kb3cvbG9nTWVzc2FnZScsIChwYXJhbXMpPT57XG4gICAgICAgICAgICB0aGlzLnNob3dMb2cocGFyYW1zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5vbk5vdGlmaWNhdGlvbignJC9sb2dUcmFjZScsIChwYXJhbXMpPT57XG4gICAgICAgICAgICB0aGlzLnNob3dUcmFjZShwYXJhbXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLm9uUmVxdWVzdCgnd2luZG93L3Nob3dNZXNzYWdlUmVxdWVzdCcsIChwYXJhbXMpPT57XG4gICAgICAgICAgICB0aGlzLnNob3dMb2cocGFyYW1zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5vblJlcXVlc3QoJ3dvcmtzcGFjZS9jb25maWd1cmF0aW9uJywgKHBhcmFtcyk9PntcbiAgICAgICAgICAgIGxhbmd1YWdlX2NsaWVudF9jb25zb2xlLmxvZyhwYXJhbXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLm9uUmVxdWVzdCgnY2xpZW50L3JlZ2lzdGVyQ2FwYWJpbGl0eScsIChwYXJhbXMpPT57XG4gICAgICAgICAgICBsYW5ndWFnZV9jbGllbnRfY29uc29sZS5sb2cocGFyYW1zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5vbkVycm9yKChlKT0+e1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5vbkNsb3NlKCgpPT57XG4gICAgICAgICAgICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaG93TG9nKHBhcmFtcykge1xuICAgICAgICBzd2l0Y2gocGFyYW1zLnR5cGUpe1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGxhbmd1YWdlX2NsaWVudF9jb25zb2xlLmVycm9yKHBhcmFtcy5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBsYW5ndWFnZV9jbGllbnRfY29uc29sZS53YXJuKHBhcmFtcy5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBsYW5ndWFnZV9jbGllbnRfY29uc29sZS5pbmZvKHBhcmFtcy5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbGFuZ3VhZ2VfY2xpZW50X2NvbnNvbGUubG9nKHBhcmFtcy5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzaG93VHJhY2UocGFyYW1zKSB7XG4gICAgICAgIGxhbmd1YWdlX2NsaWVudF9jb25zb2xlLmxvZyhwYXJhbXMubWVzc2FnZSk7XG4gICAgICAgIGlmIChwYXJhbXMudmVyYm9zZSkge1xuICAgICAgICAgICAgbGFuZ3VhZ2VfY2xpZW50X2NvbnNvbGUubG9nKHBhcmFtcy52ZXJib3NlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGREb2N1bWVudChkb2N1bWVudCkge1xuICAgICAgICBzdXBlci5hZGREb2N1bWVudChkb2N1bWVudCk7XG4gICAgICAgIGNvbnN0IHRleHREb2N1bWVudE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICB0ZXh0RG9jdW1lbnQ6IGRvY3VtZW50XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW5xdWV1ZUlmTm90Q29ubmVjdGVkKCgpPT50aGlzLmNvbm5lY3Rpb24uc2VuZE5vdGlmaWNhdGlvbigndGV4dERvY3VtZW50L2RpZE9wZW4nLCB0ZXh0RG9jdW1lbnRNZXNzYWdlKSk7XG4gICAgfVxuICAgIGVucXVldWVJZk5vdENvbm5lY3RlZChjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdHNRdWV1ZS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlRG9jdW1lbnQoZG9jdW1lbnQpIHtcbiAgICAgICAgc3VwZXIucmVtb3ZlRG9jdW1lbnQoZG9jdW1lbnQpO1xuICAgICAgICB0aGlzLmVucXVldWVJZk5vdENvbm5lY3RlZCgoKT0+dGhpcy5jb25uZWN0aW9uLnNlbmROb3RpZmljYXRpb24oJ3RleHREb2N1bWVudC9kaWRDbG9zZScsIHtcbiAgICAgICAgICAgICAgICB0ZXh0RG9jdW1lbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdXJpOiBkb2N1bWVudC51cmlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8qXG4gICAgICAgIGNsb3NlKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zb2NrZXQpXG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICovIHNlbmRJbml0aWFsaXplKGluaXRpYWxpemF0aW9uT3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgY2FwYWJpbGl0aWVzOiB0aGlzLmNsaWVudENhcGFiaWxpdGllcyxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uT3B0aW9uczogaW5pdGlhbGl6YXRpb25PcHRpb25zLFxuICAgICAgICAgICAgcHJvY2Vzc0lkOiBudWxsLFxuICAgICAgICAgICAgcm9vdFVyaTogXCJcIixcbiAgICAgICAgICAgIHdvcmtzcGFjZUZvbGRlcnM6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLnNlbmRSZXF1ZXN0KFwiaW5pdGlhbGl6ZVwiLCBtZXNzYWdlKS50aGVuKChwYXJhbXMpPT57XG4gICAgICAgICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zZXJ2aWNlQ2FwYWJpbGl0aWVzID0gcGFyYW1zLmNhcGFiaWxpdGllcztcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5zZW5kTm90aWZpY2F0aW9uKCdpbml0aWFsaXplZCcsIHt9KS50aGVuKCgpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLnNlbmROb3RpZmljYXRpb24oJ3dvcmtzcGFjZS9kaWRDaGFuZ2VDb25maWd1cmF0aW9uJywge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nczoge31cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RzUXVldWUuZm9yRWFjaCgocmVxdWVzdENhbGxiYWNrKT0+cmVxdWVzdENhbGxiYWNrKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdHNRdWV1ZSA9IFtdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhcHBseURlbHRhcyhpZGVudGlmaWVyLCBkZWx0YXMpIHtcbiAgICAgICAgc3VwZXIuYXBwbHlEZWx0YXMoaWRlbnRpZmllciwgZGVsdGFzKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEodGhpcy5zZXJ2aWNlQ2FwYWJpbGl0aWVzICYmIHRoaXMuc2VydmljZUNhcGFiaWxpdGllcy50ZXh0RG9jdW1lbnRTeW5jICE9PSBicm93c2VyX21haW4uVGV4dERvY3VtZW50U3luY0tpbmQuSW5jcmVtZW50YWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRWYWx1ZShpZGVudGlmaWVyLCB0aGlzLmdldERvY3VtZW50KGlkZW50aWZpZXIudXJpKS5nZXRUZXh0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRleHREb2N1bWVudENoYW5nZSA9IHtcbiAgICAgICAgICAgIHRleHREb2N1bWVudDoge1xuICAgICAgICAgICAgICAgIHVyaTogaWRlbnRpZmllci51cmksXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogaWRlbnRpZmllci52ZXJzaW9uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGVudENoYW5nZXM6IGRlbHRhc1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uc2VuZE5vdGlmaWNhdGlvbigndGV4dERvY3VtZW50L2RpZENoYW5nZScsIHRleHREb2N1bWVudENoYW5nZSk7XG4gICAgfVxuICAgIHNldFZhbHVlKGlkZW50aWZpZXIsIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyLnNldFZhbHVlKGlkZW50aWZpZXIsIHZhbHVlKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGV4dERvY3VtZW50Q2hhbmdlID0ge1xuICAgICAgICAgICAgdGV4dERvY3VtZW50OiB7XG4gICAgICAgICAgICAgICAgdXJpOiBpZGVudGlmaWVyLnVyaSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBpZGVudGlmaWVyLnZlcnNpb25cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250ZW50Q2hhbmdlczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5zZW5kTm90aWZpY2F0aW9uKCd0ZXh0RG9jdW1lbnQvZGlkQ2hhbmdlJywgdGV4dERvY3VtZW50Q2hhbmdlKTtcbiAgICB9XG4gICAgYXN5bmMgZG9Ib3Zlcihkb2N1bWVudCwgcG9zaXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXM7XG4gICAgICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgoX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcyA9IHRoaXMuc2VydmljZUNhcGFiaWxpdGllcykgPT09IG51bGwgfHwgX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcy5ob3ZlclByb3ZpZGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB0ZXh0RG9jdW1lbnQ6IHtcbiAgICAgICAgICAgICAgICB1cmk6IGRvY3VtZW50LnVyaVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnNlbmRSZXF1ZXN0KCd0ZXh0RG9jdW1lbnQvaG92ZXInLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZG9Db21wbGV0ZShkb2N1bWVudCwgcG9zaXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXM7XG4gICAgICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgoX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcyA9IHRoaXMuc2VydmljZUNhcGFiaWxpdGllcykgPT09IG51bGwgfHwgX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcy5jb21wbGV0aW9uUHJvdmlkZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHRleHREb2N1bWVudDoge1xuICAgICAgICAgICAgICAgIHVyaTogZG9jdW1lbnQudXJpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24uc2VuZFJlcXVlc3QoJ3RleHREb2N1bWVudC9jb21wbGV0aW9uJywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGRvUmVzb2x2ZShpdGVtKSB7XG4gICAgICAgIHZhciBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzX2NvbXBsZXRpb25Qcm92aWRlciwgX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcztcbiAgICAgICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoISgoX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcyA9IHRoaXMuc2VydmljZUNhcGFiaWxpdGllcykgPT09IG51bGwgfHwgX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXNfY29tcGxldGlvblByb3ZpZGVyID0gX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcy5jb21wbGV0aW9uUHJvdmlkZXIpID09PSBudWxsIHx8IF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXNfY29tcGxldGlvblByb3ZpZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzX2NvbXBsZXRpb25Qcm92aWRlci5yZXNvbHZlUHJvdmlkZXIpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5zZW5kUmVxdWVzdCgnY29tcGxldGlvbkl0ZW0vcmVzb2x2ZScsIGl0ZW1bXCJpdGVtXCJdKTtcbiAgICB9XG4gICAgYXN5bmMgZG9WYWxpZGF0aW9uKGRvY3VtZW50KSB7XG4gICAgICAgIC8vVE9ETzogdGV4dERvY3VtZW50L2RpYWdub3N0aWMgY2FwYWJpbGl0eVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGFzeW5jIGZvcm1hdChkb2N1bWVudCwgcmFuZ2UsIGZvcm1hdCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHRoaXMuc2VydmljZUNhcGFiaWxpdGllcyAmJiAodGhpcy5zZXJ2aWNlQ2FwYWJpbGl0aWVzLmRvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUHJvdmlkZXIgfHwgdGhpcy5zZXJ2aWNlQ2FwYWJpbGl0aWVzLmRvY3VtZW50Rm9ybWF0dGluZ1Byb3ZpZGVyKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc2VydmljZUNhcGFiaWxpdGllcy5kb2N1bWVudFJhbmdlRm9ybWF0dGluZ1Byb3ZpZGVyKSB7XG4gICAgICAgICAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0RG9jdW1lbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdXJpOiBkb2N1bWVudC51cmlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGZvcm1hdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24uc2VuZFJlcXVlc3QoJ3RleHREb2N1bWVudC9mb3JtYXR0aW5nJywgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0RG9jdW1lbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdXJpOiBkb2N1bWVudC51cmlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGZvcm1hdCxcbiAgICAgICAgICAgICAgICByYW5nZTogcmFuZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnNlbmRSZXF1ZXN0KCd0ZXh0RG9jdW1lbnQvcmFuZ2VGb3JtYXR0aW5nJywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0R2xvYmFsT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyLnNldEdsb2JhbE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0c1F1ZXVlLnB1c2goKCk9PnRoaXMuc2V0R2xvYmFsT3B0aW9ucyhvcHRpb25zKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uZmlnQ2hhbmdlcyA9IHtcbiAgICAgICAgICAgIHNldHRpbmdzOiBvcHRpb25zXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5zZW5kTm90aWZpY2F0aW9uKCd3b3Jrc3BhY2UvZGlkQ2hhbmdlQ29uZmlndXJhdGlvbicsIGNvbmZpZ0NoYW5nZXMpO1xuICAgIH1cbiAgICBhc3luYyBmaW5kRG9jdW1lbnRIaWdobGlnaHRzKGRvY3VtZW50LCBwb3NpdGlvbikge1xuICAgICAgICB2YXIgX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcztcbiAgICAgICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIHJldHVybiBbXTtcbiAgICAgICAgaWYgKCEoKF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMgPSB0aGlzLnNlcnZpY2VDYXBhYmlsaXRpZXMpID09PSBudWxsIHx8IF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMuZG9jdW1lbnRIaWdobGlnaHRQcm92aWRlcikpIHJldHVybiBbXTtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB0ZXh0RG9jdW1lbnQ6IHtcbiAgICAgICAgICAgICAgICB1cmk6IGRvY3VtZW50LnVyaVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnNlbmRSZXF1ZXN0KCd0ZXh0RG9jdW1lbnQvZG9jdW1lbnRIaWdobGlnaHQnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcHJvdmlkZVNpZ25hdHVyZUhlbHAoZG9jdW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzO1xuICAgICAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghKChfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzID0gdGhpcy5zZXJ2aWNlQ2FwYWJpbGl0aWVzKSA9PT0gbnVsbCB8fCBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzLnNpZ25hdHVyZUhlbHBQcm92aWRlcikpIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHRleHREb2N1bWVudDoge1xuICAgICAgICAgICAgICAgIHVyaTogZG9jdW1lbnQudXJpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24uc2VuZFJlcXVlc3QoJ3RleHREb2N1bWVudC9zaWduYXR1cmVIZWxwJywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHNlcnZlckRhdGEsIGN0eCl7XG4gICAgICAgIHN1cGVyKHNlcnZlckRhdGEubW9kZXMpO1xuICAgICAgICBsYW5ndWFnZV9jbGllbnRfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwiJHNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICAgICAgbGFuZ3VhZ2VfY2xpZW50X2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcImlzQ29ubmVjdGVkXCIsIGZhbHNlKTtcbiAgICAgICAgbGFuZ3VhZ2VfY2xpZW50X2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcImlzSW5pdGlhbGl6ZWRcIiwgZmFsc2UpO1xuICAgICAgICBsYW5ndWFnZV9jbGllbnRfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwic29ja2V0XCIsIHZvaWQgMCk7XG4gICAgICAgIGxhbmd1YWdlX2NsaWVudF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJjb25uZWN0aW9uXCIsIHZvaWQgMCk7XG4gICAgICAgIGxhbmd1YWdlX2NsaWVudF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJyZXF1ZXN0c1F1ZXVlXCIsIFtdKTtcbiAgICAgICAgbGFuZ3VhZ2VfY2xpZW50X2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcImNsaWVudENhcGFiaWxpdGllc1wiLCB7XG4gICAgICAgICAgICB0ZXh0RG9jdW1lbnQ6IHtcbiAgICAgICAgICAgICAgICBob3Zlcjoge1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50Rm9ybWF0OiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFya2Rvd24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BsYWludGV4dCdcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3luY2hyb25pemF0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNSZWdpc3RyYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHdpbGxTYXZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZGlkU2F2ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHdpbGxTYXZlV2FpdFVudGlsOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZm9ybWF0dGluZzoge1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb21wbGV0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNSZWdpc3RyYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb25JdGVtOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbmlwcGV0U3VwcG9ydDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1pdENoYXJhY3RlcnNTdXBwb3J0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb25Gb3JtYXQ6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWFya2Rvd24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwbGFpbnRleHQnXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwcmVjYXRlZFN1cHBvcnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VsZWN0U3VwcG9ydDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dFN1cHBvcnQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmVIZWxwOiB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZUluZm9ybWF0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uRm9ybWF0OiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtkb3duJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncGxhaW50ZXh0J1xuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVBhcmFtZXRlclN1cHBvcnQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRIaWdobGlnaHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pY1JlZ2lzdHJhdGlvbjogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3b3Jrc3BhY2U6IHtcbiAgICAgICAgICAgICAgICBkaWRDaGFuZ2VDb25maWd1cmF0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNSZWdpc3RyYXRpb246IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsYW5ndWFnZV9jbGllbnRfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwiY3R4XCIsIHZvaWQgMCk7XG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgICAgICBzd2l0Y2goc2VydmVyRGF0YS50eXBlKXtcbiAgICAgICAgICAgIGNhc2UgXCJ3ZWJ3b3JrZXJcIjpcbiAgICAgICAgICAgICAgICBpZiAoJ3dvcmtlcicgaW4gc2VydmVyRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjb25uZWN0V29ya2VyKHNlcnZlckRhdGEud29ya2VyLCBzZXJ2ZXJEYXRhLmluaXRpYWxpemF0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gd29ya2VyIHByb3ZpZGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzb2NrZXRcIjpcbiAgICAgICAgICAgICAgICBpZiAoJ3NvY2tldCcgaW4gc2VydmVyRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldCA9IHNlcnZlckRhdGEuc29ja2V0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjb25uZWN0U29ja2V0KHNlcnZlckRhdGEuaW5pdGlhbGl6YXRpb25PcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzb2NrZXRVcmwgcHJvdmlkZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHNlcnZlciB0eXBlOiBcIiArIHNlcnZlckRhdGEudHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbn0pKCk7XG5cbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTsiXSwibmFtZXMiOlsid2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJyb290IiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJhIiwiaSIsIl9fd2VicGFja19tb2R1bGVzX18iLCJfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwicHJvY2VzcyIsImNvbnNvbGUiLCJfdHlwZW9mIiwib2JqIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJfcmVxdWlyZSIsIl9yZXF1aXJlJGNvZGVzIiwiY29kZXMiLCJFUlJfQU1CSUdVT1VTX0FSR1VNRU5UIiwiRVJSX0lOVkFMSURfQVJHX1RZUEUiLCJFUlJfSU5WQUxJRF9BUkdfVkFMVUUiLCJFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUiLCJFUlJfTUlTU0lOR19BUkdTIiwiQXNzZXJ0aW9uRXJyb3IiLCJfcmVxdWlyZTIiLCJpbnNwZWN0IiwiX3JlcXVpcmUkdHlwZXMiLCJ0eXBlcyIsImlzUHJvbWlzZSIsImlzUmVnRXhwIiwib2JqZWN0QXNzaWduIiwiT2JqZWN0IiwiYXNzaWduIiwib2JqZWN0SXMiLCJpcyIsImVycm9yQ2FjaGUiLCJNYXAiLCJpc0RlZXBFcXVhbCIsImlzRGVlcFN0cmljdEVxdWFsIiwicGFyc2VFeHByZXNzaW9uQXQiLCJmaW5kTm9kZUFyb3VuZCIsImRlY29kZXIiLCJsYXp5TG9hZENvbXBhcmlzb24iLCJjb21wYXJpc29uIiwiZXNjYXBlU2VxdWVuY2VzUmVnRXhwIiwibWV0YSIsImVzY2FwZUZuIiwic3RyIiwiY2hhckNvZGVBdCIsIndhcm5lZCIsImFzc2VydCIsIm9rIiwiTk9fRVhDRVBUSU9OX1NFTlRJTkVMIiwiaW5uZXJGYWlsIiwibWVzc2FnZSIsIkVycm9yIiwiZmFpbCIsImFjdHVhbCIsImV4cGVjdGVkIiwib3BlcmF0b3IiLCJzdGFja1N0YXJ0Rm4iLCJhcmdzTGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiaW50ZXJuYWxNZXNzYWdlIiwidW5kZWZpbmVkIiwid2FybiIsImVtaXRXYXJuaW5nIiwiYmluZCIsImVyckFyZ3MiLCJlcnIiLCJnZW5lcmF0ZWRNZXNzYWdlIiwiaW5uZXJPayIsImZuIiwiYXJnTGVuIiwidmFsdWUiLCJfbGVuIiwiYXJncyIsIkFycmF5IiwiX2tleSIsImFwcGx5IiwiY29uY2F0IiwiZXF1YWwiLCJub3RFcXVhbCIsImRlZXBFcXVhbCIsIm5vdERlZXBFcXVhbCIsImRlZXBTdHJpY3RFcXVhbCIsIm5vdERlZXBTdHJpY3RFcXVhbCIsInN0cmljdEVxdWFsIiwibm90U3RyaWN0RXF1YWwiLCJDb21wYXJpc29uIiwia2V5cyIsIl90aGlzIiwiZm9yRWFjaCIsImtleSIsInRlc3QiLCJjb21wYXJlRXhjZXB0aW9uS2V5IiwiYiIsIm5hbWUiLCJleHBlY3RlZEV4Y2VwdGlvbiIsIm1zZyIsInB1c2giLCJpc1Byb3RvdHlwZU9mIiwiY2FsbCIsImdldEFjdHVhbCIsImUiLCJjaGVja0lzUHJvbWlzZSIsInRoZW4iLCJjYXRjaCIsIndhaXRGb3JBY3R1YWwiLCJwcm9taXNlRm4iLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlc3VsdFByb21pc2UiLCJleHBlY3RzRXJyb3IiLCJlcnJvciIsImRldGFpbHMiLCJmblR5cGUiLCJleHBlY3RzTm9FcnJvciIsInRocm93cyIsIl9sZW4yIiwiX2tleTIiLCJyZWplY3RzIiwiX2xlbjMiLCJfa2V5MyIsInJlc3VsdCIsImRvZXNOb3RUaHJvdyIsIl9sZW40IiwiX2tleTQiLCJkb2VzTm90UmVqZWN0IiwiX2xlbjUiLCJfa2V5NSIsImlmRXJyb3IiLCJuZXdFcnIiLCJvcmlnU3RhY2siLCJzdGFjayIsInRtcDIiLCJzcGxpdCIsInNoaWZ0IiwidG1wMSIsInBvcyIsImluZGV4T2YiLCJzbGljZSIsImpvaW4iLCJzdHJpY3QiLCJfbGVuNiIsIl9rZXk2IiwiX29iamVjdFNwcmVhZCIsInRhcmdldCIsInNvdXJjZSIsIm93bktleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJzeW0iLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiX2RlZmluZVByb3BlcnR5IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJzZWxmIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiX3NldFByb3RvdHlwZU9mIiwiX3dyYXBOYXRpdmVTdXBlciIsIkNsYXNzIiwiX2NhY2hlIiwiX2lzTmF0aXZlRnVuY3Rpb24iLCJoYXMiLCJnZXQiLCJzZXQiLCJXcmFwcGVyIiwiX2NvbnN0cnVjdCIsIl9nZXRQcm90b3R5cGVPZiIsImlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJzaGFtIiwiUHJveHkiLCJEYXRlIiwidG9TdHJpbmciLCJQYXJlbnQiLCJGdW5jdGlvbiIsIm8iLCJwIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJnZXRQcm90b3R5cGVPZiIsImVuZHNXaXRoIiwic2VhcmNoIiwidGhpc19sZW4iLCJzdWJzdHJpbmciLCJyZXBlYXQiLCJjb3VudCIsIk1hdGgiLCJmbG9vciIsIm1heENvdW50IiwibG9nIiwiYmx1ZSIsImdyZWVuIiwicmVkIiwid2hpdGUiLCJrUmVhZGFibGVPcGVyYXRvciIsInN0cmljdEVxdWFsT2JqZWN0Iiwibm90U3RyaWN0RXF1YWxPYmplY3QiLCJub3RJZGVudGljYWwiLCJrTWF4U2hvcnRMZW5ndGgiLCJjb3B5RXJyb3IiLCJpbnNwZWN0VmFsdWUiLCJ2YWwiLCJjb21wYWN0IiwiY3VzdG9tSW5zcGVjdCIsImRlcHRoIiwibWF4QXJyYXlMZW5ndGgiLCJJbmZpbml0eSIsInNob3dIaWRkZW4iLCJicmVha0xlbmd0aCIsInNob3dQcm94eSIsInNvcnRlZCIsImdldHRlcnMiLCJjcmVhdGVFcnJEaWZmIiwib3RoZXIiLCJyZXMiLCJsYXN0UG9zIiwiZW5kIiwic2tpcHBlZCIsImFjdHVhbEluc3BlY3RlZCIsImFjdHVhbExpbmVzIiwiZXhwZWN0ZWRMaW5lcyIsImluZGljYXRvciIsImlucHV0TGVuZ3RoIiwibWF4TGVuZ3RoIiwic3RkZXJyIiwiaXNUVFkiLCJjb2x1bW5zIiwicG9wIiwibWF4TGluZXMiLCJtYXgiLCJfYWN0dWFsTGluZXMiLCJwcmludGVkTGluZXMiLCJza2lwcGVkTXNnIiwiY3VyIiwiZXhwZWN0ZWRMaW5lIiwiYWN0dWFsTGluZSIsImRpdmVyZ2luZ0xpbmVzIiwiX0Vycm9yIiwib3B0aW9ucyIsImxpbWl0Iiwic3RhY2tUcmFjZUxpbWl0IiwiU3RyaW5nIiwiZ2V0Q29sb3JEZXB0aCIsImJhc2UiLCJfcmVzIiwia25vd25PcGVyYXRvcnMiLCJjb2RlIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJjdXN0b20iLCJyZWN1cnNlVGltZXMiLCJjdHgiLCJ1dGlsIiwiY3JlYXRlRXJyb3JUeXBlIiwiQmFzZSIsImdldE1lc3NhZ2UiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJOb2RlRXJyb3IiLCJfQmFzZSIsIm9uZU9mIiwidGhpbmciLCJpc0FycmF5IiwibGVuIiwibWFwIiwic3RhcnRzV2l0aCIsInN1YnN0ciIsImluY2x1ZGVzIiwic3RhcnQiLCJkZXRlcm1pbmVyIiwicmVwbGFjZSIsInR5cGUiLCJyZWFzb24iLCJpbnNwZWN0ZWQiLCJSYW5nZUVycm9yIiwiaW5wdXQiLCJfc2xpY2VkVG9BcnJheSIsImFyciIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl9ub25JdGVyYWJsZVJlc3QiLCJfYXJyIiwiX24iLCJfZCIsIl9lIiwiX2kiLCJfcyIsIm5leHQiLCJkb25lIiwicmVnZXhGbGFnc1N1cHBvcnRlZCIsImZsYWdzIiwiYXJyYXlGcm9tU2V0IiwiYXJyYXkiLCJhcnJheUZyb21NYXAiLCJvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJudW1iZXJJc05hTiIsIk51bWJlciIsImlzTmFOIiwidW5jdXJyeVRoaXMiLCJmIiwiaGFzT3duUHJvcGVydHkiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIm9iamVjdFRvU3RyaW5nIiwiaXNBbnlBcnJheUJ1ZmZlciIsImlzQXJyYXlCdWZmZXJWaWV3IiwiaXNEYXRlIiwiaXNNYXAiLCJpc1NldCIsImlzTmF0aXZlRXJyb3IiLCJpc0JveGVkUHJpbWl0aXZlIiwiaXNOdW1iZXJPYmplY3QiLCJpc1N0cmluZ09iamVjdCIsImlzQm9vbGVhbk9iamVjdCIsImlzQmlnSW50T2JqZWN0IiwiaXNTeW1ib2xPYmplY3QiLCJpc0Zsb2F0MzJBcnJheSIsImlzRmxvYXQ2NEFycmF5IiwiaXNOb25JbmRleCIsInBvdyIsImdldE93bk5vbkluZGV4UHJvcGVydGllcyIsImNvbXBhcmUiLCJ4IiwieSIsIm1pbiIsIk9OTFlfRU5VTUVSQUJMRSIsImtTdHJpY3QiLCJrTG9vc2UiLCJrTm9JdGVyYXRvciIsImtJc0FycmF5Iiwia0lzU2V0Iiwia0lzTWFwIiwiYXJlU2ltaWxhclJlZ0V4cHMiLCJSZWdFeHAiLCJhcmVTaW1pbGFyRmxvYXRBcnJheXMiLCJieXRlTGVuZ3RoIiwib2Zmc2V0IiwiYXJlU2ltaWxhclR5cGVkQXJyYXlzIiwiVWludDhBcnJheSIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJhcmVFcXVhbEFycmF5QnVmZmVycyIsImJ1ZjEiLCJidWYyIiwiaXNFcXVhbEJveGVkUHJpbWl0aXZlIiwidmFsMSIsInZhbDIiLCJ2YWx1ZU9mIiwiQm9vbGVhbiIsIkJpZ0ludCIsImlubmVyRGVlcEVxdWFsIiwibWVtb3MiLCJ2YWwxVGFnIiwidmFsMlRhZyIsImtleXMxIiwia2V5czIiLCJrZXlDaGVjayIsImdldFRpbWUiLCJfa2V5cyIsIl9rZXlzMiIsInNpemUiLCJnZXRFbnVtZXJhYmxlcyIsImsiLCJpdGVyYXRpb25UeXBlIiwiYUtleXMiLCJiS2V5cyIsInN5bWJvbEtleXNBIiwic3ltYm9sS2V5c0IiLCJfc3ltYm9sS2V5c0IiLCJwb3NpdGlvbiIsInZhbDJNZW1vQSIsInZhbDJNZW1vQiIsImFyZUVxIiwib2JqRXF1aXYiLCJkZWxldGUiLCJzZXRIYXNFcXVhbEVsZW1lbnQiLCJtZW1vIiwic2V0VmFsdWVzIiwiZmluZExvb3NlTWF0Y2hpbmdQcmltaXRpdmVzIiwicHJpbSIsInNldE1pZ2h0SGF2ZUxvb3NlUHJpbSIsImFsdFZhbHVlIiwibWFwTWlnaHRIYXZlTG9vc2VQcmltIiwiaXRlbSIsImN1ckIiLCJzZXRFcXVpdiIsImFWYWx1ZXMiLCJTZXQiLCJhZGQiLCJiVmFsdWVzIiwiX3ZhbCIsIm1hcEhhc0VxdWFsRW50cnkiLCJrZXkxIiwiaXRlbTEiLCJrZXkyIiwibWFwRXF1aXYiLCJhRW50cmllcyIsIl9hRW50cmllcyRpIiwiaXRlbTIiLCJiRW50cmllcyIsIl9pMiIsIl9iRW50cmllcyRfaSIsImtleXNBIiwiR2V0SW50cmluc2ljIiwiY2FsbEJpbmQiLCIkaW5kZXhPZiIsImNhbGxCb3VuZEludHJpbnNpYyIsImFsbG93TWlzc2luZyIsImludHJpbnNpYyIsIiRhcHBseSIsIiRjYWxsIiwiJHJlZmxlY3RBcHBseSIsIiRnT1BEIiwiJGRlZmluZVByb3BlcnR5IiwiJG1heCIsIm9yaWdpbmFsRnVuY3Rpb24iLCJmdW5jIiwiZGVzYyIsImFwcGx5QmluZCIsIm5vdyIsInRpbWVzIiwiZyIsIndpbmRvdyIsImZ1bmN0aW9ucyIsImluZm8iLCJ0aW1lIiwidGltZUVuZCIsInRyYWNlIiwiZGlyIiwiY29uc29sZUFzc2VydCIsInR1cGxlIiwibGFiZWwiLCJkdXJhdGlvbiIsImZvcm1hdCIsIm9iamVjdCIsImV4cHJlc3Npb24iLCJoYXNTeW1ib2xzIiwidG9TdHIiLCJvcmlnRGVmaW5lUHJvcGVydHkiLCJpc0Z1bmN0aW9uIiwiaGFzUHJvcGVydHlEZXNjcmlwdG9ycyIsInN1cHBvcnRzRGVzY3JpcHRvcnMiLCJwcmVkaWNhdGUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHJlZGljYXRlcyIsImZpcnN0U291cmNlIiwidG8iLCJuZXh0U291cmNlIiwia2V5c0FycmF5IiwibmV4dEluZGV4IiwibmV4dEtleSIsInBvbHlmaWxsIiwiaXNDYWxsYWJsZSIsImZvckVhY2hBcnJheSIsInJlY2VpdmVyIiwiZm9yRWFjaFN0cmluZyIsInN0cmluZyIsImNoYXJBdCIsImZvckVhY2hPYmplY3QiLCJsaXN0IiwidGhpc0FyZyIsIkVSUk9SX01FU1NBR0UiLCJmdW5jVHlwZSIsInRoYXQiLCJib3VuZCIsImJpbmRlciIsImJvdW5kTGVuZ3RoIiwiYm91bmRBcmdzIiwiRW1wdHkiLCJpbXBsZW1lbnRhdGlvbiIsIiRTeW50YXhFcnJvciIsIlN5bnRheEVycm9yIiwiJEZ1bmN0aW9uIiwiJFR5cGVFcnJvciIsImdldEV2YWxsZWRDb25zdHJ1Y3RvciIsImV4cHJlc3Npb25TeW50YXgiLCJ0aHJvd1R5cGVFcnJvciIsIlRocm93VHlwZUVycm9yIiwiY2FsbGVlIiwiY2FsbGVlVGhyb3dzIiwiZ09QRHRocm93cyIsImhhc1Byb3RvIiwiZ2V0UHJvdG8iLCJuZWVkc0V2YWwiLCJUeXBlZEFycmF5IiwiSU5UUklOU0lDUyIsIkFnZ3JlZ2F0ZUVycm9yIiwiQXJyYXlCdWZmZXIiLCJBdG9taWNzIiwiQmlnSW50NjRBcnJheSIsIkJpZ1VpbnQ2NEFycmF5IiwiRGF0YVZpZXciLCJkZWNvZGVVUkkiLCJkZWNvZGVVUklDb21wb25lbnQiLCJlbmNvZGVVUkkiLCJlbmNvZGVVUklDb21wb25lbnQiLCJldmFsIiwiRXZhbEVycm9yIiwiRmxvYXQzMkFycmF5IiwiRmxvYXQ2NEFycmF5IiwiRmluYWxpemF0aW9uUmVnaXN0cnkiLCJJbnQ4QXJyYXkiLCJJbnQxNkFycmF5IiwiSW50MzJBcnJheSIsImlzRmluaXRlIiwiSlNPTiIsInBhcnNlRmxvYXQiLCJwYXJzZUludCIsIlNoYXJlZEFycmF5QnVmZmVyIiwiVWludDhDbGFtcGVkQXJyYXkiLCJVaW50MTZBcnJheSIsIlVpbnQzMkFycmF5IiwiVVJJRXJyb3IiLCJXZWFrTWFwIiwiV2Vha1JlZiIsIldlYWtTZXQiLCJlcnJvclByb3RvIiwiZG9FdmFsIiwiZ2VuIiwiTEVHQUNZX0FMSUFTRVMiLCJoYXNPd24iLCIkY29uY2F0IiwiJHNwbGljZUFwcGx5Iiwic3BsaWNlIiwiJHJlcGxhY2UiLCIkc3RyU2xpY2UiLCIkZXhlYyIsImV4ZWMiLCJyZVByb3BOYW1lIiwicmVFc2NhcGVDaGFyIiwic3RyaW5nVG9QYXRoIiwiZmlyc3QiLCJsYXN0IiwibWF0Y2giLCJudW1iZXIiLCJxdW90ZSIsInN1YlN0cmluZyIsImdldEJhc2VJbnRyaW5zaWMiLCJpbnRyaW5zaWNOYW1lIiwiYWxpYXMiLCJwYXJ0cyIsImludHJpbnNpY0Jhc2VOYW1lIiwiaW50cmluc2ljUmVhbE5hbWUiLCJza2lwRnVydGhlckNhY2hpbmciLCJpc093biIsInBhcnQiLCJoYXNBcnJheUxlbmd0aERlZmluZUJ1ZyIsImZvbyIsIiRPYmplY3QiLCJvcmlnU3ltYm9sIiwiaGFzU3ltYm9sU2hhbSIsImhhc05hdGl2ZVN5bWJvbHMiLCJzeW1PYmoiLCJzeW1WYWwiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwic3ltcyIsImhhc1RvU3RyaW5nVGFnU2hhbXMiLCJ0b1N0cmluZ1RhZyIsImluaGVyaXRzIiwiY3RvciIsInN1cGVyQ3RvciIsInN1cGVyXyIsIlRlbXBDdG9yIiwiaGFzVG9TdHJpbmdUYWciLCJjYWxsQm91bmQiLCIkdG9TdHJpbmciLCJpc1N0YW5kYXJkQXJndW1lbnRzIiwiaXNBcmd1bWVudHMiLCJpc0xlZ2FjeUFyZ3VtZW50cyIsInN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMiLCJmblRvU3RyIiwicmVmbGVjdEFwcGx5IiwiYmFkQXJyYXlMaWtlIiwiaXNDYWxsYWJsZU1hcmtlciIsIl8iLCJjb25zdHJ1Y3RvclJlZ2V4IiwiaXNFUzZDbGFzc0ZuIiwiaXNFUzZDbGFzc0Z1bmN0aW9uIiwiZm5TdHIiLCJ0cnlGdW5jdGlvbk9iamVjdCIsInRyeUZ1bmN0aW9uVG9TdHIiLCJvYmplY3RDbGFzcyIsImZuQ2xhc3MiLCJnZW5DbGFzcyIsImRkYUNsYXNzIiwiZGRhQ2xhc3MyIiwiZGRhQ2xhc3MzIiwiaXNJRTY4IiwiaXNEREEiLCJpc0RvY3VtZW50RG90QWxsIiwiZG9jdW1lbnQiLCJhbGwiLCJzdHJDbGFzcyIsImlzRm5SZWdleCIsImdldEdlbmVyYXRvckZ1bmMiLCJHZW5lcmF0b3JGdW5jdGlvbiIsImlzR2VuZXJhdG9yRnVuY3Rpb24iLCJnZW5lcmF0b3JGdW5jIiwiZ2V0UG9seWZpbGwiLCJzaGltIiwiTmFOIiwic2hpbU51bWJlcklzTmFOIiwidGVzdElzTmFOIiwid2hpY2hUeXBlZEFycmF5IiwiaXNUeXBlZEFycmF5Iiwic2hpbU9iamVjdElzIiwidGVzdE9iamVjdElzIiwia2V5c1NoaW0iLCJpc0FyZ3MiLCJpc0VudW1lcmFibGUiLCJoYXNEb250RW51bUJ1ZyIsImhhc1Byb3RvRW51bUJ1ZyIsImRvbnRFbnVtcyIsImVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlIiwiZXhjbHVkZWRLZXlzIiwiJGFwcGxpY2F0aW9uQ2FjaGUiLCIkY29uc29sZSIsIiRleHRlcm5hbCIsIiRmcmFtZSIsIiRmcmFtZUVsZW1lbnQiLCIkZnJhbWVzIiwiJGlubmVySGVpZ2h0IiwiJGlubmVyV2lkdGgiLCIkb25tb3pmdWxsc2NyZWVuY2hhbmdlIiwiJG9ubW96ZnVsbHNjcmVlbmVycm9yIiwiJG91dGVySGVpZ2h0IiwiJG91dGVyV2lkdGgiLCIkcGFnZVhPZmZzZXQiLCIkcGFnZVlPZmZzZXQiLCIkcGFyZW50IiwiJHNjcm9sbExlZnQiLCIkc2Nyb2xsVG9wIiwiJHNjcm9sbFgiLCIkc2Nyb2xsWSIsIiRzZWxmIiwiJHdlYmtpdEluZGV4ZWREQiIsIiR3ZWJraXRTdG9yYWdlSW5mbyIsIiR3aW5kb3ciLCJoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWciLCJlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kiLCJpc09iamVjdCIsImlzU3RyaW5nIiwidGhlS2V5cyIsInNraXBQcm90byIsImoiLCJza2lwQ29uc3RydWN0b3IiLCJvcmlnS2V5cyIsIm9yaWdpbmFsS2V5cyIsInNoaW1PYmplY3RLZXlzIiwia2V5c1dvcmtzV2l0aEFyZ3VtZW50cyIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiZGVmYXVsdENsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwicXVldWUiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJkcmFpblF1ZXVlIiwidGltZW91dCIsInJ1biIsIm5leHRUaWNrIiwiSXRlbSIsInRpdGxlIiwiYnJvd3NlciIsImVudiIsImFyZ3YiLCJ2ZXJzaW9uIiwidmVyc2lvbnMiLCJub29wIiwib24iLCJhZGRMaXN0ZW5lciIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImVtaXQiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwibGlzdGVuZXJzIiwiYmluZGluZyIsImN3ZCIsImNoZGlyIiwidW1hc2siLCJfX3VudXNlZF93ZWJwYWNrX21vZHVsZSIsIl9fd2VicGFja19leHBvcnRzX18iLCJkIiwiQmFzZVNlcnZpY2UiLCJfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyIsInZzY29kZV9sYW5ndWFnZXNlcnZlcl90ZXh0ZG9jdW1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyIsIl9kZWZpbmVfcHJvcGVydHkiLCJhZGREb2N1bWVudCIsImRvY3VtZW50cyIsInVyaSIsIm4iLCJsYW5ndWFnZUlkIiwidGV4dCIsImdldERvY3VtZW50IiwicmVtb3ZlRG9jdW1lbnQiLCJnZXREb2N1bWVudFZhbHVlIiwiX3RoaXNfZ2V0RG9jdW1lbnQiLCJnZXRUZXh0Iiwic2V0VmFsdWUiLCJpZGVudGlmaWVyIiwic2V0R2xvYmFsT3B0aW9ucyIsImdsb2JhbE9wdGlvbnMiLCJzZXRPcHRpb25zIiwic2Vzc2lvbklEIiwibWVyZ2UiLCJQTSIsImdldE9wdGlvbiIsIm9wdGlvbk5hbWUiLCJhcHBseURlbHRhcyIsImRlbHRhcyIsInVwZGF0ZSIsImRvQ29tcGxldGUiLCJkb0hvdmVyIiwiZG9SZXNvbHZlIiwiZG9WYWxpZGF0aW9uIiwicmFuZ2UiLCJwcm92aWRlU2lnbmF0dXJlSGVscCIsImZpbmREb2N1bWVudEhpZ2hsaWdodHMiLCJvcHRpb25zVG9GaWx0ZXJEaWFnbm9zdGljcyIsIl90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvSWdub3JlIiwiX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9UcmVhdEFzV2FybmluZyIsIl90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm8iLCJfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yTWVzc2FnZXNUb0lnbm9yZSIsIl90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmciLCJfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yTWVzc2FnZXNUb1RyZWF0QXNJbmZvIiwiZXJyb3JDb2Rlc1RvSWdub3JlIiwiZXJyb3JDb2Rlc1RvVHJlYXRBc1dhcm5pbmciLCJlcnJvckNvZGVzVG9UcmVhdEFzSW5mbyIsImVycm9yTWVzc2FnZXNUb0lnbm9yZSIsImVycm9yTWVzc2FnZXNUb1RyZWF0QXNXYXJuaW5nIiwiZXJyb3JNZXNzYWdlc1RvVHJlYXRBc0luZm8iLCJtb2RlIiwibWVyZ2VPYmplY3RzIiwib2JqMSIsIm9iajIiLCJtZXJnZWRPYmplY3RzIiwibm90RW1wdHkiLCJtZXJnZVJhbmdlcyIsInJhbmdlcyIsInNvcnQiLCJjb21wYXJlUG9pbnRzIiwiY21wIiwiaXNFbXB0eSIsInJvdyIsImNvbHVtbiIsInAxIiwicDIiLCJjaGVja1ZhbHVlQWdhaW5zdFJlZ2V4cEFycmF5IiwicmVnZXhwQXJyYXkiLCJpc0J1ZmZlciIsImFyZyIsImNvcHkiLCJmaWxsIiwicmVhZFVJbnQ4IiwiaXNBcmd1bWVudHNPYmplY3QiLCJCaWdJbnRTdXBwb3J0ZWQiLCJTeW1ib2xTdXBwb3J0ZWQiLCJPYmplY3RUb1N0cmluZyIsIm51bWJlclZhbHVlIiwic3RyaW5nVmFsdWUiLCJib29sZWFuVmFsdWUiLCJiaWdJbnRWYWx1ZSIsInN5bWJvbFZhbHVlIiwiY2hlY2tCb3hlZFByaW1pdGl2ZSIsInByb3RvdHlwZVZhbHVlT2YiLCJpc1ZpZXciLCJpc0RhdGFWaWV3IiwiaXNVaW50OEFycmF5IiwiaXNVaW50OENsYW1wZWRBcnJheSIsImlzVWludDE2QXJyYXkiLCJpc1VpbnQzMkFycmF5IiwiaXNJbnQ4QXJyYXkiLCJpc0ludDE2QXJyYXkiLCJpc0ludDMyQXJyYXkiLCJpc0JpZ0ludDY0QXJyYXkiLCJpc0JpZ1VpbnQ2NEFycmF5IiwiaXNNYXBUb1N0cmluZyIsIndvcmtpbmciLCJpc1NldFRvU3RyaW5nIiwiaXNXZWFrTWFwVG9TdHJpbmciLCJpc1dlYWtNYXAiLCJpc1dlYWtTZXRUb1N0cmluZyIsImlzV2Vha1NldCIsImlzQXJyYXlCdWZmZXJUb1N0cmluZyIsImlzQXJyYXlCdWZmZXIiLCJpc0RhdGFWaWV3VG9TdHJpbmciLCJTaGFyZWRBcnJheUJ1ZmZlckNvcHkiLCJpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmciLCJpc1NoYXJlZEFycmF5QnVmZmVyIiwiaXNBc3luY0Z1bmN0aW9uIiwiaXNNYXBJdGVyYXRvciIsImlzU2V0SXRlcmF0b3IiLCJpc0dlbmVyYXRvck9iamVjdCIsImlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZSIsIm1ldGhvZCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZXNjcmlwdG9ycyIsImZvcm1hdFJlZ0V4cCIsIm9iamVjdHMiLCJzdHJpbmdpZnkiLCJpc051bGwiLCJkZXByZWNhdGUiLCJub0RlcHJlY2F0aW9uIiwiZGVwcmVjYXRlZCIsInRocm93RGVwcmVjYXRpb24iLCJ0cmFjZURlcHJlY2F0aW9uIiwiZGVidWdzIiwiZGVidWdFbnZSZWdleCIsIk5PREVfREVCVUciLCJkZWJ1Z0VudiIsInRvVXBwZXJDYXNlIiwiZGVidWdsb2ciLCJwaWQiLCJvcHRzIiwic2VlbiIsInN0eWxpemUiLCJzdHlsaXplTm9Db2xvciIsImNvbG9ycyIsImlzQm9vbGVhbiIsIl9leHRlbmQiLCJpc1VuZGVmaW5lZCIsInN0eWxpemVXaXRoQ29sb3IiLCJmb3JtYXRWYWx1ZSIsInN0eWxlcyIsInN0eWxlVHlwZSIsInN0eWxlIiwiYXJyYXlUb0hhc2giLCJoYXNoIiwiaWR4IiwicmV0IiwicHJpbWl0aXZlIiwiZm9ybWF0UHJpbWl0aXZlIiwidmlzaWJsZUtleXMiLCJpc0Vycm9yIiwiZm9ybWF0RXJyb3IiLCJicmFjZXMiLCJ0b1VUQ1N0cmluZyIsIm91dHB1dCIsImZvcm1hdEFycmF5IiwiZm9ybWF0UHJvcGVydHkiLCJyZWR1Y2VUb1NpbmdsZVN0cmluZyIsInNpbXBsZSIsImlzTnVtYmVyIiwibCIsImxpbmUiLCJudW1MaW5lc0VzdCIsInJlZHVjZSIsInByZXYiLCJhciIsImlzTnVsbE9yVW5kZWZpbmVkIiwiaXNTeW1ib2wiLCJyZSIsImlzUHJpbWl0aXZlIiwicGFkIiwibW9udGhzIiwidGltZXN0YW1wIiwiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwiZ2V0U2Vjb25kcyIsImdldERhdGUiLCJnZXRNb250aCIsIm9yaWdpbiIsInByb3AiLCJrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wiLCJwcm9taXNpZnkiLCJvcmlnaW5hbCIsInByb21pc2VSZXNvbHZlIiwicHJvbWlzZVJlamVjdCIsInByb21pc2UiLCJyZWplY3QiLCJjYWxsYmFja2lmeU9uUmVqZWN0ZWQiLCJjYiIsIm5ld1JlYXNvbiIsImNhbGxiYWNraWZ5IiwiY2FsbGJhY2tpZmllZCIsIm1heWJlQ2IiLCJyZWoiLCJfX2NyZWF0ZUJpbmRpbmciLCJtIiwiazIiLCJfX2VzTW9kdWxlIiwiX19leHBvcnRTdGFyIiwiY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24iLCJCcm93c2VyTWVzc2FnZVdyaXRlciIsIkJyb3dzZXJNZXNzYWdlUmVhZGVyIiwicmlsXzEiLCJkZWZhdWx0IiwiaW5zdGFsbCIsImFwaV8xIiwiQWJzdHJhY3RNZXNzYWdlUmVhZGVyIiwibGlzdGVuIiwiY2FsbGJhY2siLCJfb25EYXRhIiwiZXZlbnQiLCJwb3J0IiwiRW1pdHRlciIsIl9tZXNzYWdlTGlzdGVuZXIiLCJmaXJlIiwiZGF0YSIsImFkZEV2ZW50TGlzdGVuZXIiLCJmaXJlRXJyb3IiLCJvbm1lc3NhZ2UiLCJBYnN0cmFjdE1lc3NhZ2VXcml0ZXIiLCJ3cml0ZSIsInBvc3RNZXNzYWdlIiwiaGFuZGxlRXJyb3IiLCJlcnJvckNvdW50IiwicmVhZGVyIiwid3JpdGVyIiwibG9nZ2VyIiwiTnVsbExvZ2dlciIsIkNvbm5lY3Rpb25TdHJhdGVneSIsImNvbm5lY3Rpb25TdHJhdGVneSIsIk1lc3NhZ2VCdWZmZXIiLCJBYnN0cmFjdE1lc3NhZ2VCdWZmZXIiLCJlbXB0eUJ1ZmZlciIsImZyb21TdHJpbmciLCJfZW5jb2RpbmciLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImVuY29kaW5nIiwiYXNjaWlEZWNvZGVyIiwiZGVjb2RlIiwiVGV4dERlY29kZXIiLCJhc05hdGl2ZSIsImFsbG9jTmF0aXZlIiwiUmVhZGFibGVTdHJlYW1XcmFwcGVyIiwib25DbG9zZSIsImxpc3RlbmVyIiwic29ja2V0IiwiRGlzcG9zYWJsZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJvbkVycm9yIiwib25FbmQiLCJvbkRhdGEiLCJibG9iIiwiYXJyYXlCdWZmZXIiLCJSQUwiLCJXcml0YWJsZVN0cmVhbVdyYXBwZXIiLCJzZW5kIiwiY2xvc2UiLCJfdGV4dEVuY29kZXIiLCJfcmlsIiwiZnJlZXplIiwibWVzc2FnZUJ1ZmZlciIsImFwcGxpY2F0aW9uSnNvbiIsImVuY29kZXIiLCJjaGFyc2V0IiwicGFyc2UiLCJzdHJlYW0iLCJhc1JlYWRhYmxlU3RyZWFtIiwiYXNXcml0YWJsZVN0cmVhbSIsInRpbWVyIiwibXMiLCJoYW5kbGUiLCJkaXNwb3NlIiwic2V0SW1tZWRpYXRlIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiUklMIiwiUHJvZ3Jlc3NUeXBlIiwiUHJvZ3Jlc3NUb2tlbiIsIkNvbm5lY3Rpb25PcHRpb25zIiwiV3JpdGVhYmxlU3RyZWFtTWVzc2FnZVdyaXRlciIsIk1lc3NhZ2VXcml0ZXIiLCJSZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXIiLCJNZXNzYWdlUmVhZGVyIiwiU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5IiwiU2hhcmVkQXJyYXlTZW5kZXJTdHJhdGVneSIsIkNhbmNlbGxhdGlvblRva2VuIiwiQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UiLCJFdmVudCIsIkxSVUNhY2hlIiwiVG91Y2giLCJMaW5rZWRNYXAiLCJQYXJhbWV0ZXJTdHJ1Y3R1cmVzIiwiTm90aWZpY2F0aW9uVHlwZTkiLCJOb3RpZmljYXRpb25UeXBlOCIsIk5vdGlmaWNhdGlvblR5cGU3IiwiTm90aWZpY2F0aW9uVHlwZTYiLCJOb3RpZmljYXRpb25UeXBlNSIsIk5vdGlmaWNhdGlvblR5cGU0IiwiTm90aWZpY2F0aW9uVHlwZTMiLCJOb3RpZmljYXRpb25UeXBlMiIsIk5vdGlmaWNhdGlvblR5cGUxIiwiTm90aWZpY2F0aW9uVHlwZTAiLCJOb3RpZmljYXRpb25UeXBlIiwiRXJyb3JDb2RlcyIsIlJlc3BvbnNlRXJyb3IiLCJSZXF1ZXN0VHlwZTkiLCJSZXF1ZXN0VHlwZTgiLCJSZXF1ZXN0VHlwZTciLCJSZXF1ZXN0VHlwZTYiLCJSZXF1ZXN0VHlwZTUiLCJSZXF1ZXN0VHlwZTQiLCJSZXF1ZXN0VHlwZTMiLCJSZXF1ZXN0VHlwZTIiLCJSZXF1ZXN0VHlwZTEiLCJSZXF1ZXN0VHlwZTAiLCJSZXF1ZXN0VHlwZSIsIk1lc3NhZ2UiLCJNZXNzYWdlU3RyYXRlZ3kiLCJDYW5jZWxsYXRpb25TdHJhdGVneSIsIkNhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5IiwiQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSIsIkNvbm5lY3Rpb25FcnJvciIsIkNvbm5lY3Rpb25FcnJvcnMiLCJMb2dUcmFjZU5vdGlmaWNhdGlvbiIsIlNldFRyYWNlTm90aWZpY2F0aW9uIiwiVHJhY2VGb3JtYXQiLCJUcmFjZVZhbHVlcyIsIlRyYWNlIiwibWVzc2FnZXNfMSIsImxpbmtlZE1hcF8xIiwiZGlzcG9zYWJsZV8xIiwiZXZlbnRzXzEiLCJjYW5jZWxsYXRpb25fMSIsInNoYXJlZEFycmF5Q2FuY2VsbGF0aW9uXzEiLCJtZXNzYWdlUmVhZGVyXzEiLCJtZXNzYWdlV3JpdGVyXzEiLCJtZXNzYWdlQnVmZmVyXzEiLCJjb25uZWN0aW9uXzEiLCJyYWxfMSIsIklzIiwiTm9uZSIsImlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkIiwib25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQiLCJDYW5jZWxsZWQiLCJjYW5kaWRhdGUiLCJib29sZWFuIiwic2hvcnRjdXRFdmVudCIsImNvbnRleHQiLCJNdXRhYmxlVG9rZW4iLCJjYW5jZWwiLCJfaXNDYW5jZWxsZWQiLCJfZW1pdHRlciIsInRva2VuIiwiX3Rva2VuIiwiUmVxdWVzdENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kiLCJJZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kiLCJDYW5jZWxOb3RpZmljYXRpb24iLCJQcm9ncmVzc05vdGlmaWNhdGlvbiIsIlN0YXJSZXF1ZXN0SGFuZGxlciIsIk9mZiIsIk1lc3NhZ2VzIiwiQ29tcGFjdCIsIlZlcmJvc2UiLCJ0b0xvd2VyQ2FzZSIsIlRleHQiLCJjYW5jZWxVbmRpc3BhdGNoZWQiLCJraW5kIiwiY3JlYXRlQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UiLCJzZW5kQ2FuY2VsbGF0aW9uIiwiY29ubiIsImlkIiwic2VuZE5vdGlmaWNhdGlvbiIsImNsZWFudXAiLCJzZW5kZXIiLCJoYW5kbGVNZXNzYWdlIiwiY2FuY2VsbGF0aW9uU3RyYXRlZ3kiLCJtZXNzYWdlU3RyYXRlZ3kiLCJDb25uZWN0aW9uU3RhdGUiLCJtZXNzYWdlUmVhZGVyIiwibWVzc2FnZVdyaXRlciIsIl9sb2dnZXIiLCJzZXF1ZW5jZU51bWJlciIsIm5vdGlmaWNhdGlvblNlcXVlbmNlTnVtYmVyIiwidW5rbm93blJlc3BvbnNlU2VxdWVuY2VOdW1iZXIiLCJzdGFyUmVxdWVzdEhhbmRsZXIiLCJyZXF1ZXN0SGFuZGxlcnMiLCJzdGFyTm90aWZpY2F0aW9uSGFuZGxlciIsIm5vdGlmaWNhdGlvbkhhbmRsZXJzIiwicHJvZ3Jlc3NIYW5kbGVycyIsIm1lc3NhZ2VRdWV1ZSIsInJlc3BvbnNlUHJvbWlzZXMiLCJrbm93bkNhbmNlbGVkUmVxdWVzdHMiLCJyZXF1ZXN0VG9rZW5zIiwidHJhY2VGb3JtYXQiLCJ0cmFjZXIiLCJzdGF0ZSIsIk5ldyIsImVycm9yRW1pdHRlciIsImNsb3NlRW1pdHRlciIsInVuaGFuZGxlZE5vdGlmaWNhdGlvbkVtaXR0ZXIiLCJ1bmhhbmRsZWRQcm9ncmVzc0VtaXR0ZXIiLCJkaXNwb3NlRW1pdHRlciIsImNyZWF0ZVJlcXVlc3RRdWV1ZUtleSIsImNyZWF0ZVJlc3BvbnNlUXVldWVLZXkiLCJjcmVhdGVOb3RpZmljYXRpb25RdWV1ZUtleSIsImFkZE1lc3NhZ2VUb1F1ZXVlIiwiaXNSZXF1ZXN0IiwiaXNSZXNwb25zZSIsIl9tZXNzYWdlIiwiaXNMaXN0ZW5pbmciLCJMaXN0ZW5pbmciLCJpc0Nsb3NlZCIsIkNsb3NlZCIsImlzRGlzcG9zZWQiLCJEaXNwb3NlZCIsImNsb3NlSGFuZGxlciIsInJlYWRFcnJvckhhbmRsZXIiLCJ3cml0ZUVycm9ySGFuZGxlciIsInRyaWdnZXJNZXNzYWdlUXVldWUiLCJwcm9jZXNzTWVzc2FnZVF1ZXVlIiwiaGFuZGxlUmVxdWVzdCIsImlzTm90aWZpY2F0aW9uIiwiaGFuZGxlTm90aWZpY2F0aW9uIiwiaGFuZGxlUmVzcG9uc2UiLCJoYW5kbGVJbnZhbGlkTWVzc2FnZSIsImNhbmNlbElkIiwicGFyYW1zIiwidG9DYW5jZWwiLCJzdHJhdGVneSIsInJlc3BvbnNlIiwidHJhY2VTZW5kaW5nUmVzcG9uc2UiLCJjYW5jZWxsYXRpb25Ub2tlbiIsInRyYWNlUmVjZWl2ZWROb3RpZmljYXRpb24iLCJyZXF1ZXN0TWVzc2FnZSIsInJlcGx5IiwicmVzdWx0T3JFcnJvciIsInN0YXJ0VGltZSIsImpzb25ycGMiLCJ0b0pzb24iLCJyZXBseUVycm9yIiwicmVwbHlTdWNjZXNzIiwidHJhY2VSZWNlaXZlZFJlcXVlc3QiLCJlbGVtZW50IiwicmVxdWVzdEhhbmRsZXIiLCJoYW5kbGVyIiwidG9rZW5LZXkiLCJjYW5jZWxsYXRpb25Tb3VyY2UiLCJoYW5kbGVyUmVzdWx0IiwibnVtYmVyT2ZQYXJhbXMiLCJJbnZhbGlkUGFyYW1zIiwicGFyYW1ldGVyU3RydWN0dXJlcyIsImJ5TmFtZSIsImJ5UG9zaXRpb24iLCJJbnRlcm5hbEVycm9yIiwiTWV0aG9kTm90Rm91bmQiLCJyZXNwb25zZU1lc3NhZ2UiLCJyZXNwb25zZVByb21pc2UiLCJ0cmFjZVJlY2VpdmVkUmVzcG9uc2UiLCJub3RpZmljYXRpb25IYW5kbGVyIiwicmVzcG9uc2VIYW5kbGVyIiwic3RyaW5naWZ5VHJhY2UiLCJ0cmFjZVNlbmRpbmdSZXF1ZXN0IiwibG9nTFNQTWVzc2FnZSIsInRyYWNlU2VuZGluZ05vdGlmaWNhdGlvbiIsInRpbWVyU3RhcnQiLCJsc3BNZXNzYWdlIiwiaXNMU1BNZXNzYWdlIiwidGhyb3dJZkNsb3NlZE9yRGlzcG9zZWQiLCJ0aHJvd0lmTGlzdGVuaW5nIiwiQWxyZWFkeUxpc3RlbmluZyIsInRocm93SWZOb3RMaXN0ZW5pbmciLCJ1bmRlZmluZWRUb051bGwiLCJwYXJhbSIsIm51bGxUb1VuZGVmaW5lZCIsImlzTmFtZWRQYXJhbSIsImNvbXB1dGVTaW5nbGVQYXJhbSIsImF1dG8iLCJjb21wdXRlTWVzc2FnZVBhcmFtcyIsImNvbm5lY3Rpb24iLCJtZXNzYWdlUGFyYW1zIiwicGFyYW1TdGFydCIsInBhcmFtRW5kIiwibm90aWZpY2F0aW9uTWVzc2FnZSIsIm9uTm90aWZpY2F0aW9uIiwib25Qcm9ncmVzcyIsIl90eXBlIiwic2VuZFByb2dyZXNzIiwib25VbmhhbmRsZWRQcm9ncmVzcyIsInNlbmRSZXF1ZXN0IiwiZGlzcG9zYWJsZSIsImVuYWJsZUNhbmNlbGxhdGlvbiIsInJlc29sdmVXaXRoQ2xlYW51cCIsInIiLCJyZWplY3RXaXRoQ2xlYW51cCIsIk1lc3NhZ2VXcml0ZUVycm9yIiwib25SZXF1ZXN0IiwiaGFzUGVuZGluZ1Jlc3BvbnNlIiwiX3ZhbHVlIiwiX3RyYWNlciIsInNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucyIsIl9zZW5kTm90aWZpY2F0aW9uIiwiX3RyYWNlRm9ybWF0Iiwib25VbmhhbmRsZWROb3RpZmljYXRpb24iLCJvbkRpc3Bvc2UiLCJQZW5kaW5nUmVzcG9uc2VSZWplY3RlZCIsInZhbHVlcyIsInZlcmJvc2UiLCJfZGlzcG9zYWJsZSIsIkNhbGxiYWNrTGlzdCIsImJ1Y2tldCIsIl9jYWxsYmFja3MiLCJfY29udGV4dHMiLCJyZW1vdmUiLCJmb3VuZENhbGxiYWNrV2l0aERpZmZlcmVudENvbnRleHQiLCJpbnZva2UiLCJjYWxsYmFja3MiLCJjb250ZXh0cyIsIl9ldmVudCIsInRoaXNBcmdzIiwiZGlzcG9zYWJsZXMiLCJfb3B0aW9ucyIsIm9uRmlyc3RMaXN0ZW5lckFkZCIsIl9ub29wIiwib25MYXN0TGlzdGVuZXJSZW1vdmUiLCJzdHJpbmdBcnJheSIsImV2ZXJ5IiwiZWxlbSIsIl9hIiwiRmlyc3QiLCJBc09sZCIsIkxhc3QiLCJBc05ldyIsImNsZWFyIiwiX21hcCIsIl9oZWFkIiwiX3RhaWwiLCJfc2l6ZSIsIl9zdGF0ZSIsInRvdWNoIiwicHJldmlvdXMiLCJhZGRJdGVtTGFzdCIsImFkZEl0ZW1GaXJzdCIsInJlbW92ZUl0ZW0iLCJjYWxsYmFja2ZuIiwiY3VycmVudCIsImVudHJpZXMiLCJ0cmltT2xkIiwibmV3U2l6ZSIsImN1cnJlbnRTaXplIiwidG9KU09OIiwiZnJvbUpTT04iLCJfbGltaXQiLCJjaGVja1RyaW0iLCJyYXRpbyIsIl9yYXRpbyIsInBlZWsiLCJyb3VuZCIsIkNSIiwiTEYiLCJDUkxGIiwiYXBwZW5kIiwiY2h1bmsiLCJ0b0FwcGVuZCIsIl9jaHVua3MiLCJfdG90YWxMZW5ndGgiLCJ0cnlSZWFkSGVhZGVycyIsImxvd2VyQ2FzZUtleXMiLCJjaHVua0luZGV4IiwiY2h1bmtCeXRlc1JlYWQiLCJfcmVhZCIsImhlYWRlcnMiLCJoZWFkZXIiLCJpbmRleCIsInRyaW0iLCJ0cnlSZWFkQm9keSIsIm51bWJlck9mQnl0ZXMiLCJieXRlQ291bnQiLCJyZXN1bHRPZmZzZXQiLCJjaHVua1BhcnQiLCJzZW1hcGhvcmVfMSIsIm9uUGFydGlhbE1lc3NhZ2UiLCJhc0Vycm9yIiwiZmlyZUNsb3NlIiwicGFydGlhbE1lc3NhZ2VFbWl0dGVyIiwiZmlyZVBhcnRpYWxNZXNzYWdlIiwiUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucyIsImZyb21PcHRpb25zIiwiY29udGVudERlY29kZXIiLCJjb250ZW50RGVjb2RlcnMiLCJjb250ZW50VHlwZURlY29kZXIiLCJjb250ZW50VHlwZURlY29kZXJzIiwicGFydGlhbE1lc3NhZ2VUaW1lb3V0IiwiX3BhcnRpYWxNZXNzYWdlVGltZW91dCIsIm5leHRNZXNzYWdlTGVuZ3RoIiwibWVzc2FnZVRva2VuIiwicGFydGlhbE1lc3NhZ2VUaW1lciIsInJlYWRhYmxlIiwiY29udGVudExlbmd0aCIsImJvZHkiLCJzZXRQYXJ0aWFsTWVzc2FnZVRpbWVyIiwiY2xlYXJQYXJ0aWFsTWVzc2FnZVRpbWVyIiwicmVhZFNlbWFwaG9yZSIsImxvY2siLCJieXRlcyIsIndhaXRpbmdUaW1lIiwiU2VtYXBob3JlIiwiQ29udGVudExlbmd0aCIsIlJlc29sdmVkTWVzc2FnZVdyaXRlck9wdGlvbnMiLCJjb250ZW50VHlwZUVuY29kZXIiLCJjb250ZW50RW5jb2RlciIsIndyaXRlU2VtYXBob3JlIiwicGF5bG9hZCIsImRvV3JpdGUiLCJBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUiLCJQYXJzZUVycm9yIiwiSW52YWxpZFJlcXVlc3QiLCJqc29ucnBjUmVzZXJ2ZWRFcnJvclJhbmdlU3RhcnQiLCJzZXJ2ZXJFcnJvclN0YXJ0IiwiTWVzc2FnZVJlYWRFcnJvciIsIkNvbm5lY3Rpb25JbmFjdGl2ZSIsIlNlcnZlck5vdEluaXRpYWxpemVkIiwiVW5rbm93bkVycm9yQ29kZSIsImpzb25ycGNSZXNlcnZlZEVycm9yUmFuZ2VFbmQiLCJzZXJ2ZXJFcnJvckVuZCIsIl9wYXJhbWV0ZXJTdHJ1Y3R1cmVzIiwiX3JhbCIsInJhbCIsInRodW5rIiwiX3dhaXRpbmciLCJydW5OZXh0IiwiYWN0aXZlIiwiX2FjdGl2ZSIsIl9jYXBhY2l0eSIsImRvUnVuTmV4dCIsImNhcGFjaXR5IiwiQ2FuY2VsbGF0aW9uU3RhdGUiLCJDb250aW51ZSIsInJlcXVlc3QiLCJidWZmZXJzIiwiJGNhbmNlbGxhdGlvbkRhdGEiLCJfY29ubiIsInN0b3JlIiwiU2hhcmVkQXJyYXlCdWZmZXJDYW5jZWxsYXRpb25Ub2tlbiIsImxvYWQiLCJTaGFyZWRBcnJheUJ1ZmZlckNhbmNlbGxhdGlvblRva2VuU291cmNlIiwiY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uIiwiYnJvd3Nlcl8xIiwiTFNQRXJyb3JDb2RlcyIsImxzcFJlc2VydmVkRXJyb3JSYW5nZVN0YXJ0IiwiUmVxdWVzdEZhaWxlZCIsIlNlcnZlckNhbmNlbGxlZCIsIkNvbnRlbnRNb2RpZmllZCIsIlJlcXVlc3RDYW5jZWxsZWQiLCJsc3BSZXNlcnZlZEVycm9yUmFuZ2VFbmQiLCJ2c2NvZGVfanNvbnJwY18xIiwiUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlIiwiUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlMCIsIlByb3RvY29sUmVxdWVzdFR5cGUiLCJQcm90b2NvbFJlcXVlc3RUeXBlMCIsIlJlZ2lzdHJhdGlvblR5cGUiLCJNZXNzYWdlRGlyZWN0aW9uIiwiQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0IiwiQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0IiwiQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0IiwibWVzc2FnZURpcmVjdGlvbiIsImNsaWVudFRvU2VydmVyIiwiQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0IiwiRG9jdW1lbnRDb2xvclJlcXVlc3QiLCJDb25maWd1cmF0aW9uUmVxdWVzdCIsInNlcnZlclRvQ2xpZW50IiwiRGVjbGFyYXRpb25SZXF1ZXN0IiwiX19ub0R5bmFtaWNJbXBvcnQiLCJEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3QiLCJXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdCIsIkRvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QiLCJEb2N1bWVudERpYWdub3N0aWNSZXBvcnRLaW5kIiwiRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGEiLCJyZXRyaWdnZXJSZXF1ZXN0IiwiRnVsbCIsIlVuY2hhbmdlZCIsInBhcnRpYWxSZXN1bHQiLCJXaWxsRGVsZXRlRmlsZXNSZXF1ZXN0IiwiRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb24iLCJEaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbiIsIldpbGxSZW5hbWVGaWxlc1JlcXVlc3QiLCJEaWRDcmVhdGVGaWxlc05vdGlmaWNhdGlvbiIsIldpbGxDcmVhdGVGaWxlc1JlcXVlc3QiLCJGaWxlT3BlcmF0aW9uUGF0dGVybktpbmQiLCJmaWxlIiwiZm9sZGVyIiwiRm9sZGluZ1JhbmdlUmVxdWVzdCIsIkltcGxlbWVudGF0aW9uUmVxdWVzdCIsIklubGF5SGludFJlZnJlc2hSZXF1ZXN0IiwiSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QiLCJJbmxheUhpbnRSZXF1ZXN0IiwiSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdCIsIklubGluZVZhbHVlUmVxdWVzdCIsIldvcmtzcGFjZVN5bWJvbFJlcXVlc3QiLCJDb2RlQWN0aW9uUmVzb2x2ZVJlcXVlc3QiLCJDb2RlQWN0aW9uUmVxdWVzdCIsIkRvY3VtZW50U3ltYm9sUmVxdWVzdCIsIkRvY3VtZW50SGlnaGxpZ2h0UmVxdWVzdCIsIlJlZmVyZW5jZXNSZXF1ZXN0IiwiRGVmaW5pdGlvblJlcXVlc3QiLCJTaWduYXR1cmVIZWxwUmVxdWVzdCIsIlNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZCIsIkhvdmVyUmVxdWVzdCIsIkNvbXBsZXRpb25SZXNvbHZlUmVxdWVzdCIsIkNvbXBsZXRpb25SZXF1ZXN0IiwiQ29tcGxldGlvblRyaWdnZXJLaW5kIiwiUHVibGlzaERpYWdub3N0aWNzTm90aWZpY2F0aW9uIiwiV2F0Y2hLaW5kIiwiUmVsYXRpdmVQYXR0ZXJuIiwiRmlsZUNoYW5nZVR5cGUiLCJEaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24iLCJXaWxsU2F2ZVRleHREb2N1bWVudFdhaXRVbnRpbFJlcXVlc3QiLCJXaWxsU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiIsIlRleHREb2N1bWVudFNhdmVSZWFzb24iLCJEaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uIiwiRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24iLCJEaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24iLCJUZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnQiLCJEaWRPcGVuVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uIiwiVGV4dERvY3VtZW50U3luY0tpbmQiLCJUZWxlbWV0cnlFdmVudE5vdGlmaWNhdGlvbiIsIkxvZ01lc3NhZ2VOb3RpZmljYXRpb24iLCJTaG93TWVzc2FnZVJlcXVlc3QiLCJTaG93TWVzc2FnZU5vdGlmaWNhdGlvbiIsIk1lc3NhZ2VUeXBlIiwiRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbiIsIkV4aXROb3RpZmljYXRpb24iLCJTaHV0ZG93blJlcXVlc3QiLCJJbml0aWFsaXplZE5vdGlmaWNhdGlvbiIsIkluaXRpYWxpemVFcnJvckNvZGVzIiwiSW5pdGlhbGl6ZVJlcXVlc3QiLCJXb3JrRG9uZVByb2dyZXNzT3B0aW9ucyIsIlRleHREb2N1bWVudFJlZ2lzdHJhdGlvbk9wdGlvbnMiLCJTdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zIiwiUG9zaXRpb25FbmNvZGluZ0tpbmQiLCJGYWlsdXJlSGFuZGxpbmdLaW5kIiwiUmVzb3VyY2VPcGVyYXRpb25LaW5kIiwiVW5yZWdpc3RyYXRpb25SZXF1ZXN0IiwiUmVnaXN0cmF0aW9uUmVxdWVzdCIsIkRvY3VtZW50U2VsZWN0b3IiLCJOb3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIiLCJOb3RlYm9va0RvY3VtZW50RmlsdGVyIiwiVGV4dERvY3VtZW50RmlsdGVyIiwiVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdCIsIlR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCIsIk1vbmlrZXJSZXF1ZXN0IiwiTW9uaWtlcktpbmQiLCJVbmlxdWVuZXNzTGV2ZWwiLCJMaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0IiwiU2hvd0RvY3VtZW50UmVxdWVzdCIsIlNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZSIsIlNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QiLCJTZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdCIsIlNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0IiwiU2VtYW50aWNUb2tlbnNSZXF1ZXN0IiwiVG9rZW5Gb3JtYXQiLCJXb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uIiwiV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QiLCJXb3JrRG9uZVByb2dyZXNzIiwiU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0IiwiRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvbiIsIldvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0IiwiVHlwZURlZmluaXRpb25SZXF1ZXN0IiwiQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdCIsIkV4ZWN1dGVDb21tYW5kUmVxdWVzdCIsIlByZXBhcmVSZW5hbWVSZXF1ZXN0IiwiUmVuYW1lUmVxdWVzdCIsIlByZXBhcmVTdXBwb3J0RGVmYXVsdEJlaGF2aW9yIiwiRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdCIsIkRvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUmVxdWVzdCIsIkRvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3QiLCJEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdCIsIkRvY3VtZW50TGlua1JlcXVlc3QiLCJDb2RlTGVuc1JlZnJlc2hSZXF1ZXN0IiwiQ29kZUxlbnNSZXNvbHZlUmVxdWVzdCIsIkNvZGVMZW5zUmVxdWVzdCIsIldvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0IiwiRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uIiwiRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24iLCJEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uIiwiTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2UiLCJEaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiIsIk5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZSIsIk5vdGVib29rRG9jdW1lbnQiLCJOb3RlYm9va0NlbGwiLCJFeGVjdXRpb25TdW1tYXJ5IiwiTm90ZWJvb2tDZWxsS2luZCIsIlR5cGVIaWVyYXJjaHlTdXBlcnR5cGVzUmVxdWVzdCIsInZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xIiwicHJvdG9jb2xfaW1wbGVtZW50YXRpb25fMSIsInByb3RvY29sX3R5cGVEZWZpbml0aW9uXzEiLCJwcm90b2NvbF93b3Jrc3BhY2VGb2xkZXJfMSIsInByb3RvY29sX2NvbmZpZ3VyYXRpb25fMSIsInByb3RvY29sX2NvbG9yUHJvdmlkZXJfMSIsInByb3RvY29sX2ZvbGRpbmdSYW5nZV8xIiwicHJvdG9jb2xfZGVjbGFyYXRpb25fMSIsInByb3RvY29sX3NlbGVjdGlvblJhbmdlXzEiLCJwcm90b2NvbF9wcm9ncmVzc18xIiwicHJvdG9jb2xfY2FsbEhpZXJhcmNoeV8xIiwicHJvdG9jb2xfc2VtYW50aWNUb2tlbnNfMSIsInByb3RvY29sX3Nob3dEb2N1bWVudF8xIiwicHJvdG9jb2xfbGlua2VkRWRpdGluZ1JhbmdlXzEiLCJwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xIiwicHJvdG9jb2xfbW9uaWtlcl8xIiwicHJvdG9jb2xfdHlwZUhpZXJhcmNoeV8xIiwicHJvdG9jb2xfaW5saW5lVmFsdWVfMSIsInByb3RvY29sX2lubGF5SGludF8xIiwicHJvdG9jb2xfZGlhZ25vc3RpY18xIiwicHJvdG9jb2xfbm90ZWJvb2tfMSIsImxhbmd1YWdlIiwic2NoZW1lIiwicGF0dGVybiIsIm9iamVjdExpdGVyYWwiLCJub3RlYm9va1R5cGUiLCJub3RlYm9vayIsIkNyZWF0ZSIsIlJlbmFtZSIsIkRlbGV0ZSIsIkFib3J0IiwiVHJhbnNhY3Rpb25hbCIsIlRleHRPbmx5VHJhbnNhY3Rpb25hbCIsIlVuZG8iLCJVVEY4IiwiVVRGMTYiLCJVVEYzMiIsImhhc0lkIiwiZG9jdW1lbnRTZWxlY3RvciIsIndvcmtEb25lUHJvZ3Jlc3MiLCJoYXNXb3JrRG9uZVByb2dyZXNzIiwidW5rbm93blByb3RvY29sVmVyc2lvbiIsIldhcm5pbmciLCJJbmZvIiwiTG9nIiwiSW5jcmVtZW50YWwiLCJpc0luY3JlbWVudGFsIiwicmFuZ2VMZW5ndGgiLCJpc0Z1bGwiLCJNYW51YWwiLCJBZnRlckRlbGF5IiwiRm9jdXNPdXQiLCJDcmVhdGVkIiwiQ2hhbmdlZCIsIkRlbGV0ZWQiLCJVUkkiLCJiYXNlVXJpIiwiV29ya3NwYWNlRm9sZGVyIiwiQ2hhbmdlIiwiSW52b2tlZCIsIlRyaWdnZXJDaGFyYWN0ZXIiLCJUcmlnZ2VyRm9ySW5jb21wbGV0ZUNvbXBsZXRpb25zIiwiQ29udGVudENoYW5nZSIsIklkZW50aWZpZXIiLCJwcm9qZWN0IiwiZ3JvdXAiLCJnbG9iYWwiLCIkaW1wb3J0IiwiJGV4cG9ydCIsImxvY2FsIiwiTWFya3VwIiwiQ29kZSIsImV4ZWN1dGlvbk9yZGVyIiwic3VjY2VzcyIsInVpbnRlZ2VyIiwiZXF1YWxzIiwib25lIiwiRG9jdW1lbnRVcmkiLCJtZXRhZGF0YSIsImRpZmYiLCJ0d28iLCJleGVjdXRpb25TdW1tYXJ5IiwiZXF1YWxzTWV0YWRhdGEiLCJvbmVBcnJheSIsIm90aGVyQXJyYXkiLCJvbmVLZXlzIiwib3RoZXJLZXlzIiwiY2VsbHMiLCJpbnRlZ2VyIiwidHlwZWRBcnJheSIsInJlZ2lzdHJhdGlvbk1ldGhvZCIsImRlbGV0ZUNvdW50IiwiUmVsYXRpdmUiLCJjaGVjayIsIlRleHREb2N1bWVudCIsIl9fc3ByZWFkQXJyYXkiLCJmcm9tIiwicGFjayIsIkZ1bGxUZXh0RG9jdW1lbnQiLCJjb250ZW50IiwiX3VyaSIsIl9sYW5ndWFnZUlkIiwiX3ZlcnNpb24iLCJfY29udGVudCIsIl9saW5lT2Zmc2V0cyIsIm9mZnNldEF0IiwiY2hhbmdlcyIsImNoYW5nZXNfMSIsImNoYW5nZSIsImdldFdlbGxmb3JtZWRSYW5nZSIsInN0YXJ0T2Zmc2V0IiwiZW5kT2Zmc2V0Iiwic3RhcnRMaW5lIiwiZW5kTGluZSIsImxpbmVPZmZzZXRzIiwiYWRkZWRMaW5lT2Zmc2V0cyIsImNvbXB1dGVMaW5lT2Zmc2V0cyIsImdldExpbmVPZmZzZXRzIiwicG9zaXRpb25BdCIsImxvdyIsImhpZ2giLCJjaGFyYWN0ZXIiLCJtaWQiLCJsaW5lT2Zmc2V0IiwibmV4dExpbmVPZmZzZXQiLCJhcHBseUVkaXRzIiwiZWRpdHMiLCJzb3J0ZWRFZGl0cyIsIm1lcmdlU29ydCIsImdldFdlbGxmb3JtZWRFZGl0IiwibGFzdE1vZGlmaWVkT2Zmc2V0Iiwic3BhbnMiLCJzb3J0ZWRFZGl0c18xIiwibmV3VGV4dCIsImxlZnQiLCJyaWdodCIsImxlZnRJZHgiLCJyaWdodElkeCIsImlzQXRMaW5lU3RhcnQiLCJ0ZXh0T2Zmc2V0IiwiY2giLCJ0ZXh0RWRpdCIsIkFubm90YXRlZFRleHRFZGl0IiwiQ2hhbmdlQW5ub3RhdGlvbiIsIkNoYW5nZUFubm90YXRpb25JZGVudGlmaWVyIiwiQ29kZUFjdGlvbiIsIkNvZGVBY3Rpb25Db250ZXh0IiwiQ29kZUFjdGlvbktpbmQiLCJDb2RlQWN0aW9uVHJpZ2dlcktpbmQiLCJDb2RlRGVzY3JpcHRpb24iLCJDb2RlTGVucyIsIkNvbG9yIiwiQ29sb3JJbmZvcm1hdGlvbiIsIkNvbG9yUHJlc2VudGF0aW9uIiwiQ29tbWFuZCIsIkNvbXBsZXRpb25JdGVtIiwiQ29tcGxldGlvbkl0ZW1LaW5kIiwiQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHMiLCJDb21wbGV0aW9uSXRlbVRhZyIsIkNvbXBsZXRpb25MaXN0IiwiQ3JlYXRlRmlsZSIsIkRlbGV0ZUZpbGUiLCJEaWFnbm9zdGljIiwiRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbiIsIkRpYWdub3N0aWNTZXZlcml0eSIsIkRpYWdub3N0aWNUYWciLCJEb2N1bWVudEhpZ2hsaWdodCIsIkRvY3VtZW50SGlnaGxpZ2h0S2luZCIsIkRvY3VtZW50TGluayIsIkRvY3VtZW50U3ltYm9sIiwiRU9MIiwiRm9sZGluZ1JhbmdlIiwiRm9sZGluZ1JhbmdlS2luZCIsIkZvcm1hdHRpbmdPcHRpb25zIiwiSG92ZXIiLCJJbmxheUhpbnQiLCJJbmxheUhpbnRLaW5kIiwiSW5sYXlIaW50TGFiZWxQYXJ0IiwiSW5saW5lVmFsdWVDb250ZXh0IiwiSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24iLCJJbmxpbmVWYWx1ZVRleHQiLCJJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwIiwiSW5zZXJ0UmVwbGFjZUVkaXQiLCJJbnNlcnRUZXh0Rm9ybWF0IiwiSW5zZXJ0VGV4dE1vZGUiLCJMb2NhdGlvbiIsIkxvY2F0aW9uTGluayIsIk1hcmtlZFN0cmluZyIsIk1hcmt1cENvbnRlbnQiLCJNYXJrdXBLaW5kIiwiT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIiwiUGFyYW1ldGVySW5mb3JtYXRpb24iLCJQb3NpdGlvbiIsIlJhbmdlIiwiUmVuYW1lRmlsZSIsIlNlbGVjdGlvblJhbmdlIiwiU2VtYW50aWNUb2tlbk1vZGlmaWVycyIsIlNlbWFudGljVG9rZW5UeXBlcyIsIlNlbWFudGljVG9rZW5zIiwiU2lnbmF0dXJlSW5mb3JtYXRpb24iLCJTeW1ib2xJbmZvcm1hdGlvbiIsIlN5bWJvbEtpbmQiLCJTeW1ib2xUYWciLCJUZXh0RG9jdW1lbnRFZGl0IiwiVGV4dERvY3VtZW50SWRlbnRpZmllciIsIlRleHREb2N1bWVudEl0ZW0iLCJUZXh0RWRpdCIsIlZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIiLCJXb3Jrc3BhY2VDaGFuZ2UiLCJXb3Jrc3BhY2VFZGl0IiwiV29ya3NwYWNlU3ltYm9sIiwiTUlOX1ZBTFVFIiwiTUFYX1ZBTFVFIiwidGhyZWUiLCJmb3VyIiwidGFyZ2V0VXJpIiwidGFyZ2V0UmFuZ2UiLCJ0YXJnZXRTZWxlY3Rpb25SYW5nZSIsIm9yaWdpblNlbGVjdGlvblJhbmdlIiwiYWxwaGEiLCJudW1iZXJSYW5nZSIsImNvbG9yIiwiYWRkaXRpb25hbFRleHRFZGl0cyIsIkNvbW1lbnQiLCJJbXBvcnRzIiwiUmVnaW9uIiwic3RhcnRDaGFyYWN0ZXIiLCJlbmRDaGFyYWN0ZXIiLCJjb2xsYXBzZWRUZXh0IiwiZGVmaW5lZCIsImxvY2F0aW9uIiwiSW5mb3JtYXRpb24iLCJIaW50IiwiVW5uZWNlc3NhcnkiLCJEZXByZWNhdGVkIiwiaHJlZiIsInNldmVyaXR5IiwicmVsYXRlZEluZm9ybWF0aW9uIiwiY29kZURlc2NyaXB0aW9uIiwiY29tbWFuZCIsImluc2VydCIsImRlbCIsIm5lZWRzQ29uZmlybWF0aW9uIiwiZGVzY3JpcHRpb24iLCJhbm5vdGF0aW9uIiwiYW5ub3RhdGlvbklkIiwidGV4dERvY3VtZW50Iiwib3ZlcndyaXRlIiwiaWdub3JlSWZFeGlzdHMiLCJvbGRVcmkiLCJuZXdVcmkiLCJyZWN1cnNpdmUiLCJpZ25vcmVJZk5vdEV4aXN0cyIsImRvY3VtZW50Q2hhbmdlcyIsIlRleHRFZGl0Q2hhbmdlSW1wbCIsImNoYW5nZUFubm90YXRpb25zIiwiZWRpdCIsImFzc2VydENoYW5nZUFubm90YXRpb25zIiwibWFuYWdlIiwiQ2hhbmdlQW5ub3RhdGlvbnMiLCJhbm5vdGF0aW9ucyIsIl9hbm5vdGF0aW9ucyIsIl9jb3VudGVyIiwiaWRPckFubm90YXRpb24iLCJuZXh0SWQiLCJ3b3Jrc3BhY2VFZGl0IiwiX3RleHRFZGl0Q2hhbmdlcyIsIl93b3Jrc3BhY2VFZGl0IiwiX2NoYW5nZUFubm90YXRpb25zIiwidGV4dEVkaXRDaGFuZ2UiLCJpbml0RG9jdW1lbnRDaGFuZ2VzIiwiZ2V0VGV4dEVkaXRDaGFuZ2UiLCJ0ZXh0RG9jdW1lbnRFZGl0IiwiaW5pdENoYW5nZXMiLCJjcmVhdGVGaWxlIiwib3B0aW9uc09yQW5ub3RhdGlvbiIsIm9wZXJhdGlvbiIsInJlbmFtZUZpbGUiLCJkZWxldGVGaWxlIiwiUGxhaW5UZXh0IiwiTWFya2Rvd24iLCJNZXRob2QiLCJGaWVsZCIsIlZhcmlhYmxlIiwiSW50ZXJmYWNlIiwiTW9kdWxlIiwiUHJvcGVydHkiLCJVbml0IiwiVmFsdWUiLCJFbnVtIiwiS2V5d29yZCIsIlNuaXBwZXQiLCJGaWxlIiwiUmVmZXJlbmNlIiwiRm9sZGVyIiwiRW51bU1lbWJlciIsIkNvbnN0YW50IiwiU3RydWN0IiwiT3BlcmF0b3IiLCJUeXBlUGFyYW1ldGVyIiwiYXNJcyIsImFkanVzdEluZGVudGF0aW9uIiwiZGV0YWlsIiwiaXRlbXMiLCJpc0luY29tcGxldGUiLCJmcm9tUGxhaW5UZXh0IiwicGxhaW5UZXh0IiwiY29udGVudHMiLCJkb2N1bWVudGF0aW9uIiwicGFyYW1ldGVycyIsIlJlYWQiLCJXcml0ZSIsIk5hbWVzcGFjZSIsIlBhY2thZ2UiLCJLZXkiLCJOdWxsIiwiY29udGFpbmVyTmFtZSIsInNlbGVjdGlvblJhbmdlIiwiY2hpbGRyZW4iLCJ0YWdzIiwiUXVpY2tGaXgiLCJSZWZhY3RvciIsIlJlZmFjdG9yRXh0cmFjdCIsIlJlZmFjdG9ySW5saW5lIiwiUmVmYWN0b3JSZXdyaXRlIiwiU291cmNlIiwiU291cmNlT3JnYW5pemVJbXBvcnRzIiwiU291cmNlRml4QWxsIiwiQXV0b21hdGljIiwiZGlhZ25vc3RpY3MiLCJvbmx5IiwidHJpZ2dlcktpbmQiLCJraW5kT3JDb21tYW5kT3JFZGl0IiwiY2hlY2tLaW5kIiwiaXNQcmVmZXJyZWQiLCJ0YWJTaXplIiwiaW5zZXJ0U3BhY2VzIiwicGFyZW50IiwicmVzdWx0SWQiLCJ2YXJpYWJsZU5hbWUiLCJjYXNlU2Vuc2l0aXZlTG9va3VwIiwiZnJhbWVJZCIsInN0b3BwZWRMb2NhdGlvbiIsIlR5cGUiLCJQYXJhbWV0ZXIiLCJ0b29sdGlwIiwidGV4dEVkaXRzIiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nUmlnaHQiLCJsaW5lQ291bnQiLCJpc0xpbmVTdGFydCIsImF2YWlsYWJsZVR5cGVkQXJyYXlzIiwiZ09QRCIsImdsb2JhbFRoaXMiLCJ0eXBlZEFycmF5cyIsIiRzbGljZSIsImNhY2hlIiwicHJvdG8iLCJzdXBlclByb3RvIiwidHJ5VHlwZWRBcnJheXMiLCJ0cnlBbGxUeXBlZEFycmF5cyIsImZvdW5kIiwiZ2V0dGVyIiwidHJ5U2xpY2VzIiwidHJ5QWxsU2xpY2VzIiwidGFnIiwicG9zc2libGVOYW1lcyIsIm91dCIsIl9fd2VicGFja19tb2R1bGVfY2FjaGVfXyIsIm1vZHVsZUlkIiwiY2FjaGVkTW9kdWxlIiwiZGVmaW5pdGlvbiIsIkxhbmd1YWdlQ2xpZW50IiwibWFpbiIsIm1lc3NhZ2VzIiwiRGlzcG9zYWJsZUNvbGxlY3Rpb24iLCJXZWJTb2NrZXRNZXNzYWdlUmVhZGVyIiwiZXZlbnRzIiwicmVhZE1lc3NhZ2UiLCJvbk1lc3NhZ2UiLCJXZWJTb2NrZXRNZXNzYWdlV3JpdGVyIiwiY3JlYXRlV2ViU29ja2V0Q29ubmVjdGlvbiIsIkNvbnNvbGVMb2dnZXIiLCJkZWJ1ZyIsIndlYlNvY2tldCIsIm9uQ29ubmVjdGlvbiIsIm9ub3BlbiIsInRvU29ja2V0Iiwib25lcnJvciIsIm9uY2xvc2UiLCJicm93c2VyX21haW4iLCJiYXNlX3NlcnZpY2UiLCJCYXNlTWVzc2FnZSIsInNlc3Npb25JZCIsIkluaXRNZXNzYWdlIiwiaW5pdCIsIkZvcm1hdE1lc3NhZ2UiLCJDb21wbGV0ZU1lc3NhZ2UiLCJjb21wbGV0ZSIsIlJlc29sdmVDb21wbGV0aW9uTWVzc2FnZSIsInJlc29sdmVDb21wbGV0aW9uIiwiSG92ZXJNZXNzYWdlIiwiaG92ZXIiLCJWYWxpZGF0ZU1lc3NhZ2UiLCJ2YWxpZGF0ZSIsIkNoYW5nZU1lc3NhZ2UiLCJEZWx0YXNNZXNzYWdlIiwiYXBwbHlEZWx0YSIsIkNoYW5nZU1vZGVNZXNzYWdlIiwiY2hhbmdlTW9kZSIsIkNoYW5nZU9wdGlvbnNNZXNzYWdlIiwiY2hhbmdlT3B0aW9ucyIsIkRpc3Bvc2VNZXNzYWdlIiwiR2xvYmFsT3B0aW9uc01lc3NhZ2UiLCJzZXJ2aWNlTmFtZSIsIkNvbmZpZ3VyZUZlYXR1cmVzTWVzc2FnZSIsImNvbmZpZ3VyZUZlYXR1cmVzIiwiU2lnbmF0dXJlSGVscE1lc3NhZ2UiLCJzaWduYXR1cmVIZWxwIiwiRG9jdW1lbnRIaWdobGlnaHRNZXNzYWdlIiwiZG9jdW1lbnRIaWdobGlnaHQiLCJsYW5ndWFnZV9jbGllbnRfY29uc29sZSIsImxhbmd1YWdlX2NsaWVudF9kZWZpbmVfcHJvcGVydHkiLCIkY29ubmVjdFNvY2tldCIsImluaXRpYWxpemF0aW9uT3B0aW9ucyIsInJlYWR5U3RhdGUiLCJXZWJTb2NrZXQiLCJPUEVOIiwiJGNvbm5lY3QiLCJkaXNwYXRjaEV2ZW50IiwiJGNvbm5lY3RXb3JrZXIiLCJ3b3JrZXIiLCJpc0Nvbm5lY3RlZCIsInNlbmRJbml0aWFsaXplIiwic2hvd0xvZyIsInNob3dUcmFjZSIsInRleHREb2N1bWVudE1lc3NhZ2UiLCJlbnF1ZXVlSWZOb3RDb25uZWN0ZWQiLCJyZXF1ZXN0c1F1ZXVlIiwiY2FwYWJpbGl0aWVzIiwiY2xpZW50Q2FwYWJpbGl0aWVzIiwicHJvY2Vzc0lkIiwicm9vdFVyaSIsIndvcmtzcGFjZUZvbGRlcnMiLCJpc0luaXRpYWxpemVkIiwic2VydmljZUNhcGFiaWxpdGllcyIsInNldHRpbmdzIiwicmVxdWVzdENhbGxiYWNrIiwidGV4dERvY3VtZW50U3luYyIsInRleHREb2N1bWVudENoYW5nZSIsImNvbnRlbnRDaGFuZ2VzIiwiX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcyIsImhvdmVyUHJvdmlkZXIiLCJjb21wbGV0aW9uUHJvdmlkZXIiLCJfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzX2NvbXBsZXRpb25Qcm92aWRlciIsInJlc29sdmVQcm92aWRlciIsImRvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUHJvdmlkZXIiLCJkb2N1bWVudEZvcm1hdHRpbmdQcm92aWRlciIsImNvbmZpZ0NoYW5nZXMiLCJkb2N1bWVudEhpZ2hsaWdodFByb3ZpZGVyIiwic2lnbmF0dXJlSGVscFByb3ZpZGVyIiwic2VydmVyRGF0YSIsIm1vZGVzIiwiZHluYW1pY1JlZ2lzdHJhdGlvbiIsImNvbnRlbnRGb3JtYXQiLCJzeW5jaHJvbml6YXRpb24iLCJ3aWxsU2F2ZSIsImRpZFNhdmUiLCJ3aWxsU2F2ZVdhaXRVbnRpbCIsImZvcm1hdHRpbmciLCJjb21wbGV0aW9uIiwiY29tcGxldGlvbkl0ZW0iLCJzbmlwcGV0U3VwcG9ydCIsImNvbW1pdENoYXJhY3RlcnNTdXBwb3J0IiwiZG9jdW1lbnRhdGlvbkZvcm1hdCIsImRlcHJlY2F0ZWRTdXBwb3J0IiwicHJlc2VsZWN0U3VwcG9ydCIsImNvbnRleHRTdXBwb3J0Iiwic2lnbmF0dXJlSW5mb3JtYXRpb24iLCJhY3RpdmVQYXJhbWV0ZXJTdXBwb3J0Iiwid29ya3NwYWNlIiwiZGlkQ2hhbmdlQ29uZmlndXJhdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=